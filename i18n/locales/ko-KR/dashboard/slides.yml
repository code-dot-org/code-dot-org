ko:
  slides:
    maze_intro:
      1:
        image: notes/hoc1_1.jpg
        text: Hour of code 에 오신 것을 환영합니다. 프로그래밍의 재미를 느껴 보세요.
      2:
        image: notes/hoc1_2.jpg
        text: '코드를 작성하기 위해, 드래그 & 드롭 방식의 비주얼 프로그래밍 언어인 블러클리(Blockly)를 사용합니다.'
      3:
        image: notes/hoc1_3.jpg
        text: 대부분의 프로그래밍언어들은 텍스트로 작성해야 하지만, 블러클리는 그래픽 방식의 블럭들을 이용해 프로그래밍 합니다. 각 각의 블럭들은 실제 프로그래밍언어(자바스크립트) 코드와 1:1로 대응합니다.
      4:
        image: notes/hoc1_4.jpg
        text: 화성 탐사선 제어 프로그램과 같이 어디서나 사용될 수 있는, 프로그램들을 만들기 위해 필요한기초적인 개념들과, 컴퓨터과학(정보과학)의 프로그래밍과 알고리즘에 대해 간단히 경험할 수 있습니다.
      5:
        image: notes/hoc1_5.jpg
        text: 프로그램은 컴퓨터가 실행해야하는 명령들의 집합이라고 할 수 있습니다.
      6:
        image: notes/hoc1_6.jpg
        text: 처음 만드는 프로그램의 목표는, 앵그리버드를 움직여 초록 돼지를 잡는 것 입니다.
      7:
        image: notes/hoc1_7.jpg
        text: 왼쪽은 프로그램이 실행되는 미로입니다. 각 퍼즐의 목표들은 미로의 아래쪽에 나타납니다.
      8:
        image: notes/hoc1_8.jpg
        text: 가운데 도구상자는 앵그리버드를 움직이기 위한 명령들이 있습니다. 이 블럭들을 사용해 프로그램의 코드를 만들 수 있습니다.
      9:
        image: notes/hoc1_9.jpg
        text: 오른쪽은, 프로그램을 만들기 위해 도구 상자에서 블럭들을 꺼내어 놓는 곳입니다. 블럭을 삭제하려면, 구석에 있는 휴지통에 버리면 됩니다.
      10:
        image: notes/hoc1_10.jpg
        text: '하나의 블럭은 하나의 명령을 의미합니다. "앞으로 이동하기" 블럭을 오른쪽의 프로그래밍 영역에 가져다 놓은 후, "프로그램 실행"을 누르면, 앵그리버드가 한 칸 앞으로 이동합니다.'
      11:
        image: notes/hoc1_11.jpg
        text: 하나 이상의 동작을 실행하기 위해서, 여러 개의 블럭들을 프로그래밍 작업공간에 드래그해 넣고 서로 붙이면 됩니다. 플래피 버드를 동작시키는 명령어들은 위에서 아래로 순서대로 실행될 것입니다.
      12:
        image: notes/hoc1_12.jpg
        text: '프로그램을 실행시켜 본 후, 수정하거나 다시 실행 하고 싶으면, "처음 상태로" 버튼을 누르면 됩니다.'
      13:
        image: notes/hoc1_13.jpg
        text: 자! 이제, 초록 돼지를 잡으러 갑시다!
    artist_intro:
      1:
        image: notes/stage5_1.jpg
        text: 안녕하세요. 저는 JR 입니다! 카레이싱 경주에서 우승하기 위해서, 카레이서 팀은 반드시 컴퓨터과학(정보과학)이 필요합니다. 컴퓨터과학(정보과학)을 활용해서 자동차를 더 빠르게 달릴 수 있도록, 자동차에서 보내지는 데이터들을 분석해야하기 때문입니다.
      2:
        image: notes/stage5_2.jpg
        text: 이번 퍼즐들에서는, 선을 그리며 돌아다니는 예술가가 되어 보세요.
      3:
        image: notes/stage5_3.jpg
        text: '이것은 "앞으로 이동... 픽셀... " 블럭입니다. 픽셀은 여러 분이 보고 있는 화면을 구성하는 아주 아주 작은 점들입니다.'
      4:
        image: notes/stage5_4.jpg
        text: '이 블럭은 "오른쪽으로 90도 만큼 돌아라!" 라는 명령을 의미합니다. 미로 퍼즐에서 "왼쪽/오른쪽으로 돌기" 블럭을 사용했던 것과 똑같이 돌려줍니다.'
      5:
        image: notes/stage5_5.jpg
        text: 블럭들에 나타나있는 아래쪽 삼각형을 눌러보면, 거리나 각도를 원하는 만큼 지정할 수 있습니다. 새로운 블럭들을 연습하면서 익숙해져 보세요.
    farmer_intro:
      1:
        image: notes/stage9_1.jpg
        text: 안녕하세요. 저는 파올라입니다! 이번 퍼즐들에서는 농작물을 기르기 위해서 밭 전체를 고르게 만들어야 하는, 농부 아가씨가 되어 보세요.
      2:
        image: notes/stage9_2.jpg
        text: 여러분들은 농부 아가씨가 흙더미와 구덩이를 모두 없앨 수 있게 도와야 합니다.
      3:
        image: notes/stage9_3.jpg
        text: 새롭게 사용할 수 있는 블럭은, 흙더미를 1번 치우거나 구덩이를 1번 메웁니다.
      4:
        image: notes/stage9_4.jpg
        text: 흙더미의 크기, 구덩이의 깊이가 다르기 때문에 어떤 크기인지 알려주어야 합니다.
    flappy_intro:
      1:
        image: notes/flappy01.jpg
        text: 안녕하세요 저는 케이티입니다. 컴퓨터 과학의 재미있는 점 하나를 이야기하자면 컴퓨터 프로그램이 사람이 원하는데로 상호작용을 하도록 만들 수 있다는 것입니다.
      2:
        image: notes/flappy02.jpg
        text: 컴퓨터나 스마트폰을 클릭하거나 문자를 입력하면 이벤트라는 것이 발생합니다. 이러한 이벤트가 발생했을 때 실행시킬 수 있는 코드들을 마음대로 결정할 수 있습니다.
      3:
        image: notes/flappy03.jpg
        text: '예를 들어, "마우스가 클릭되었을 때, 소리를 출력해라."와 같은 이벤트 핸들러를 사용할 수 있습니다.'
      4:
        image: notes/flappy04.jpg
        text: 플래피버드(FlappyBird) 게임을 들어본 적이 있나요? 이벤트 핸들러들을 이용해서 자기만의 플래피버드 프로그램을 만들어 보도록 할 것입니다.
      5:
        image: notes/flappy05.jpg
        text: 드래그/드롭하는 블럭들은 컴퓨터가 수행해야할 명령들을 의미합니다. 블럭들은 실제 코드로 변환되어 실행됩니다.
      6:
        image: notes/flappy06.jpg
        text: 코드 블럭 편집창을 보면, 연두색 블럭들이 있는데 이것이 이벤트 핸들러입니다.
      7:
        image: notes/flappy07.jpg
        text: '마우스를 클릭 했을 때 날개를 펄럭이려면, "펄럭" 블럭을 이벤트 핸들러에 붙이면 됩니다. 그렇게 하면 마우스를 클릭할 때마다 날개를 펄럭일 것입니다.'
      8:
        image: notes/flappy08.jpg
        text: 이 퍼즐들에서는 연두색의 새로운 이벤트 블럭이 주어지고, 원하는 이벤트가 발생했을 때에 따른 적당한 블럭을 생각해 사용할 수 있습니다.
      9:
        image: notes/flappy09.jpg
        text: 이와 같은 선택 메뉴 화살표가 나타나면 설정을 바꿀 수 있다는 것을 의미합니다. 플래피가 땅에 닿았을 때 소리가 나도록 하는 것과 같은 것이 가능합니다.
      10:
        image: notes/flappy10.jpg
        text: 마지막 퍼즐에서는 자신이 원하는 게임을 만들고 다른 친구들과 공유할 수 있습니다. 재미있게 즐기세요!
    loop_times:
      1:
        image: notes/hoc2_1.jpg
        text: 안녕하세요! 여러분? 저는 마크 입니다. 반복 실행(loop)에 대해 살펴 볼까요? 반복 실행 구조를 사용해, 원하는 작업을 수 천 번... 수 백 만 번, 반복하도록 할 수 있습니다.
      2:
        image: notes/hoc2_2.jpg
        text: '이 퍼즐에서는 앵그리버드가 초록 돼지를 잡을 수 있도록, 5번 "앞으로 이동" 시켜야합니다.'
      3:
        image: notes/hoc2_3.jpg
        text: '새로운 "반복(횟수)" 블럭을 이용해서 해결 할 수 있습니다.'
      4:
        image: notes/hoc2_4.jpg
        text: '"앞으로 이동하기" 블럭 5개를 하나로 붙여 사용하는 대신...'
      5:
        image: notes/hoc2_5.jpg
        text: '"앞으로 이동하기" 블럭 1개를  "반복(횟수)" 블럭 안에 집어 넣고, 반복할 횟수를 숫자로 입력하면 됩니다.'
      6:
        image: notes/hoc2_6.jpg
        text: '그리고 이렇게 하는 것은 매우 중요합니다: 여러 개의 명령 블럭을 "반복(횟수)" 블럭 안에 넣어 실행시킬 수 있기 때문입니다.'
      7:
        image: notes/hoc2_7.jpg
        text: '"반복(횟수)" 블럭을 잘 사용해 보세요!'
    loop_until:
      1:
        image: notes/hoc3_1.jpg
        text: '안녕하세요? 저는 크리스 입니다. 저는 마이애미 히트(Miami Heat)에서 일하기 전에, 조지아 공과대학(Georgia Tech)에서 컴퓨터과학(Computer Science) 분야를 공부했습니다. 새로운 블럭인 "반복(~할 때까지)" 블럭을 살펴보도록 하겠습니다.'
      2:
        image: notes/hoc3_2.jpg
        text: 앵그리버드가 초록 돼지를 잡기 위해, 이동해야하는 거리를 모른다면 어떻게 해야 할까요?
      3:
        image: notes/hoc3_3.jpg
        text: '"반복(~할 때까지)" 블럭 안에 "앞으로 이동하기" 블럭을 넣으면, 초록 돼지를 붙잡을 때 까지... 앵그리버드가 앞으로 이동하게 됩니다.'
      4:
        image: notes/hoc3_4.jpg
        text: '이렇게 하는 것은 매우 중요합니다: 이전과 마찬가지로, 여러 개의 블럭들을 "반복(~할 때까지)" 블럭 안에 넣어서, 원하는 작업들을 반복시킬 수 있기 때문입니다.'
    if:
      1:
        image: notes/hoc4_1.jpg
        text: '안녕하세요? 저는 빌 입니다! 이제 새로운 기초 개념들을 배워 봅시다: "만약" 명령문입니다. 이 명령문을 이용해서, 컴퓨터가 생각하는 것처럼 만들 수 있습니다.'
      2:
        image: notes/hoc4_2.jpg
        text: '"만약"? 이라는 생각은 매우 일상적입니다. "만약"에 밖에 비가 내리면? 우산을 가지고 나가야 합니다.'
      3:
        image: notes/hoc4_3.jpg
        text: '좀비에게, "앞에 길이 있는지", "왼쪽에 길이 있는지"를 먼저 확인하게 한 후, 그 방향으로 회전시킬 수 있습니다.'
      4:
        image: notes/hoc4_4.jpg
        text: '그렇게 만들려면, "만약" 블럭 안에 "왼쪽으로 돌기" 블럭을 넣으면 됩니다.'
      5:
        image: notes/hoc4_5.jpg
        text: '그 다음, "앞으로 이동" 블럭을 그 위에 붙이고, "반복(횟수)" 블럭 안에 넣으면.. 좀비가 움직일 때마다 길을 확인한 다음, 그 쪽으로 움직이게 할 수 있습니다. "반복(횟수)" 명령 안에서, 움직일 때마다 이동 방향을 결정하도록 하는 작업은 매우 중요합니다.'
      6:
        image: notes/hoc4_6.jpg
        text: '컴퓨터과학(정보과학)에서 "만약" 명령은  매우 중요합니다. 제가 처음 만들었던 프로그램 중 하나가, 3*3 크기의 표 안에 O와 X를 번갈아 작성해 넣는 틱택토(tic-tac-toe) 게임이었는데, 그 프로그램에서, 어떤 사람이 이겼는지를 "만약" 명령이 결정해 주었습니다. "만약" 블럭은 이긴 사람을 결정하는 역할을 해 줄 수 있습니다.'
      7:
        image: notes/hoc4_7.jpg
        text: '"만약" 블럭을 재미있게 사용해 보세요!'
    if_else:
      1:
        image: notes/hoc5_1.jpg
        text: '안녕하세요? 저는 살로니 에요. 저는 건강/신약개발 분야에서 컴퓨터과학(정보과학)에서 배운 것들을 활용했어요. "만약.. 아니면" 블럭을 어떻게 사용할 수 있는지 살펴보도록 하죠. "만약" 블럭과 비슷하지만, "아니면" 부분이 더 있어요.'
      2:
        image: notes/hoc5_2.jpg
        text: '"실행" 부분에 "앞으로 이동" 블럭을 넣고, "왼쪽으로 회전" 블럭을 "아니면"이라고 쓰여진 부분에 넣으면, 좀비는 2가지 경우 중에서 하나 만 선택하게 되요. 만약 앞에 길이 있으면, "앞으로 이동"하고, 아니면(즉, 앞에 길이 없으면), "왼쪽으로 회전"을 하게 되요.'
      3:
        image: notes/hoc5_3.jpg
        text: '"만약" 블럭과 똑같이, "만약~아니면" 블럭 안에 "반복" 블럭들을 넣어 좀비를 이동시킬 수 있습니다. "만약-아니면" 블럭을 이용해 회전할 곳인지 아닌지 계속 확인하게 됩니다.'
      4:
        image: notes/hoc5_4.jpg
        text: 자 이제, 좀비들에게 가봅시다!
    if_else_scrat:
      1:
        image: notes/saloni_ifelse_scrat1.jpg
        text: 하나의 만약-아니면(if-else) 조건/선택실행문은 2가지 중 하나를 반드시 선택/실행하게 됩니다. 자 이제 우리 친구 다람쥐 스크랫(scrat)과 함께 만약-아니면 조건/선택실행문을 어떻게 사용하는지 알아봅시다.
      2:
        image: notes/saloni_ifelse_scrat2.jpg
        text: '이 블럭은 "만약" 블럭과 같은 것처럼 보이지만, 그 아래에 "그렇지 않으면" 부분이 더 있습니다. "실행"이라고 쓰여있는 부분에 "앞으로 이동" 블럭을 넣고, "그렇지 않으면" 부분에 "오른쪽으로 회전" 블럭을 넣으면, 다람쥐 스크랫은 앞쪽에 길이 있으면 앞으로 이동하라는 것을 의미합니다. 앞쪽에 길이 없으면, 스크랫은 오른쪽으로 회전 할 것입니다.'
      3:
        image: notes/saloni_ifelse_scrat3.jpg
        text: '조건/선택에 따라 2가지 동작 중 반드시 하나를 결정합니다. 그리고 "만약" 블럭과 거의 똑같습니다, "만약-아니면(if-else)" 블럭안에서 "반복(repeat)" 블럭들을 사용할 수 있습니다.'
      4:
        image: notes/saloni_ifelse_scrat4.jpg
        text: 이제 다람쥐 스크랫이 도토리를 잡을 수 있게 도와주세요!
    function:
      1:
        image: notes/stage13_1.jpg
        text: '안녕하세요. 저는 인스타그램(Instagram)에서 엔지니어로 일하고 있는 브리나입니다. 함수는 많이 사용하는 명령들을 원하는  이름으로 정의해 둔 것으로, 필요한 명령 블럭들을 모두 사용할 필요 없이, 미리 정의해 둔 블럭을 하나 만 사용해서 같은 작업들을 실행할 수 있게 해 줍니다.'
      2:
        image: notes/stage13_2.jpg
        text: 이제, 어떤 함수를 만드는 방법을 살펴보겠습니다. 함수가 실행 해야하는 명령들은, 별 모양이 그려져 있는 블럭을 이용해 만들 수 있습니다. 그리고 그렇게 만든 함수의 이름도 지어 넣을 수 있습니다.
      3:
        image: notes/stage13_3.jpg
        text: '별이 그려져 있는 함수 정의 블럭 안에 넣어진 블럭들은, 그 함수가 실행될 때 실행해야 할 명령들을 의미합니다. 따라서, "메우기 5번" 이라는 함수는 "반복(횟수)" 블럭과 "메우기" 블럭으로 채워져(정의되어) 있는 것입니다.'
      4:
        image: notes/stage13_4.jpg
        text: '하지만, 이렇게 만들어(정의해)두기만 해서는 실행하지 않습니다. 함수 분류에서 "메우기 5번" 이라는 함수 블럭을 끌어와서 사용해야만 실행이 됩니다.  '
      5:
        image: notes/stage13_5.jpg
        text: '자 이제, 재미("fun")있게 함수("FUNction")를 사용해 보세요! '
    loop_while:
      1:
        image: notes/stage9_5.jpg
        text: '안녕하세요? 마킨데입니다. 이번에는 "반복(~인 동안)" 블럭에 대해서 알아보겠습니다 '
      2:
        image: notes/stage9_6.jpg
        text: '"반복(~인 동안)" 블럭은 어떤 상황에서 계속 반복 해야하는 명령들을 넣을 수 있게 해 줍니다. 반복 해야 하는 조건이 블럭 위에 적혀있고, 그 상황이 참(TRUE)이면 계속 반복시켜줍니다.'
      3:
        image: notes/stage9_7.jpg
        text: '예를 들어, 농부 아가씨가 흙더미 위에 있다면, 계속해서 "치우기 1번"을 수행할 것입니다.'
    loop_for:
      1:
        image: notes/stage11_1.jpg
        text: 안녕하세요. 트리나입니다. 저는 픽사(Pixar)에서 일하고 있는데, 슈렉을 비롯한 여러 가지 애니메이션을 만드는 작업을 해 왔습니다.
      2:
        image: notes/stage11_2.jpg
        text: '이건 "카운터" 라는 반복 블럭입니다. 이 카운터 블럭을 사용하면 원하는 작업을 반복할 수 있는데,  반복 할 때마다 어떤 값을 조금씩 바꿔가면서도 이용할 수 있습니다. '
      3:
        image: notes/stage11_3.jpg
        text: '이 예제에서, "카운터" 반복 블럭에는 "카운트 : 50 부터 90까지, 증가 10"라고 쓰여 있여있고, 그 안에 "사각형 그리기" 블럭이 들어있습니다. 변수 분류에서 "카운터" 블럭을 가져와 "길이" 부분에 넣어보세요.'
      4:
        image: notes/stage11_4.jpg
        text: 이렇게 하면, 예술가가 50 픽셀 길이인 사각형 부터 그리기 시작해서, 10 픽셀 크기만큼 늘려 60 픽셀 길이의 사각형을 그리고, 다시 10 픽셀 크기만큼 늘려 70 길이로 그리고.... 그렇게 반복하면서 90을 넘지 않을 때까지 증가시키면서 반복합니다. 그래서 50, 60, 70, 80, 90 길이의 사각형들을 그리게 되는 것이죠.
    parameters:
      1:
        image: notes/stage15_1.jpg
        text: 안녕하세요. 징가(Zynga)에서 엔지니어로 일하고 있는 자넷입니다.
      2:
        image: notes/stage15_2.jpg
        text: 크기가 다른 삼각형들을 아주 많이 그려야 한다면 어떻게 해야할까요?
      3:
        image: notes/stage15_3.jpg
        text: 일일이 모두 각각 코드를 작성하는 방법도 있지만, 값을 전달받는 함수를 사용할 수도 있습니다.
      4:
        image: notes/stage15_4.jpg
        text: '그러기 위해, "삼각형 그리기" 함수의 파랑별을 눌러 보세요. 그 다음에 "전달받을값"(input name)을 "전달값"(input) 블럭에 끼워 넣으세요.'
      5:
        image: notes/stage15_5.jpg
        text: '그 다음에 "x"라고 쓰여진 부분을 "길이"(length)라고 수정하면 됩니다. 그렇게 하면 함수에게 전달되는 값을 사용할 수 있게 됩니다.'
      6:
        image: notes/stage15_6.jpg
        text: '그 다음 다시 별을 누르고, 변수 분류에 들어가서 "길이"(length) 블럭을 가져와서 "앞으로 이동"(move forward) 블럭에 넣어주면 됩니다. 이전 블럭은 치워버리면 됩니다.'
      7:
        image: notes/stage15_7.jpg
        text: '함수 분류를 열어 "삼각형 그리기 사용:" 블럭을 가져와 사용하면 됩니다.'
      8:
        image: notes/stage15_8.jpg
        text: 또한, 삼각형의 크기를 원하는데로 바꾸기 위해서, 계산 블럭을 사용할 수 있습니다.
    hoc_wrapup:
      1:
        image: notes/hoc6_1.jpg
        text: 축하합니다! 여러분은 마지막 퍼즐을 해결함으로서, 복잡한 미로/동굴/터널 속에서도 스스로 길을 찾아 움직일 수 있는 로봇을 만들 수 있게 되었습니다. 좀비, 새, 화성탐사선, 스스로 움직이는 자동차 등에도 모두 적용시킬 수 있겠죠?
      2:
        image: notes/hoc6_2.jpg
        text: '지금까지 사용한 기초적인 개념들은, 매일 사용하는 앱(응용프로그램)들을 만들어 내는 가장 기본적인 방법들입니다. 지금까지 반복 실행을 위한, "반복(횟수)", "반복(~할 때까지)" 명령과 선택 실행을 위한 "만약", "만약....아니면" 명령들에 대해 배워 보았습니다.'
      3:
        image: notes/hoc6_3.jpg
        text: '처음 해 본, Hour of Code 가 재미있으면, http://code.org 를 통해 컴퓨터과학(정보과학)의 기초개념들을 더 배워보세요!  그 과정을 끝내고 나면, 프로그래밍을 위한 기초적인 지식을 모두 배울 수 있게 됩니다. 여러분들은 스마트폰 앱 만들기, 로봇 조종, 게임 만들기 등, 원하는 것을 모두 할 수 있는 기본적인 지식들을 얻게 되는 거에요!'
      4:
        image: notes/hoc6_4.jpg
        text: '컴퓨터과학(정보과학)에서 배우는 지식과 기술들은 모든 사람들의 생활 방식을 바꿔가고 있습니다 : 프로그래밍은 재미있고, 창의적인 과정이며, 누구나 배울 수 있습니다!'
    20_wrapup:
      1:
        image: notes/bird.png
        text: 프레젠테이션 준비 중!
    frozen_intro:
      1:
        image: notes/frozen1_1.jpg
        text: 안녕하세요, 제 이름은 린지입니다. 저는 모델이고, 연극도하고, 앱들을 직접만들고 있습니다. 얼음의 마술과 아름다움을 탐구하는 안나, 엘사와 함께 코드를 배워보세요.
      2:
        image: notes/frozen1_2.jpg
        text: 스케이트를 타면서 눈송이들과 패턴을 만들고, 겨울왕국을 만들어서 친구들에게 보여주세요.
      3:
        image: notes/frozen1_3.jpg
        text: 이제부터, 코드를 만들어낼 수 있는 기초/개념/원리들을 배우게 될 것입니다. 일반적인 프로그래밍은 텍스트(문자들)를 사용하지만, 여기서는 비주얼 블럭들로 프로그래밍하는 블러클리(Blockly)를 이용해 블럭들을 드래그 앤 드롭해서 프로그램을 만들 수 있습니다. 때때로 처음 배우는 대학생들도 해보는 방법입니다. 하지만, 여러분들도 똑같이 코드를 만들고 있는 것입니다.
      4:
        image: notes/frozen1_4.jpg
        text: 하나의 프로그램은 컴퓨터가 실행해야 할 작업들을 알려주는 명령어들의 집합에 불과합니다. 자 이제, 엘사가 간단한 선을 그리도록 하는 코드, 프로그램을 만들어 봅시다. 이 간단한 방법을 이용해서 나중에 보다 복잡한 패턴들을 만들어낼 수 있게 될 것입니다.
      5:
        image: notes/frozen1_5.jpg
        text: 화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 얼음 판입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다.
      6:
        image: notes/frozen1_6.jpg
        text: 가운데 영역은 도구상자이고, 각각의 블록들은 엘사와 안나가 실행할 수 있는 동작들을 나타냅니다.
      7:
        image: notes/frozen1_7.jpg
        text: '오른쪽의 아무것도 없는 흰 공간은 작업공간(workspace)이라고 부르고, 그 곳에서 프로그램의 코드를 만들게 될 것입니다. 얼음판에서 이리 저리 움직이기 위해, "앞으로 이동"블럭을 사용하게 될 것입니다.'
      8:
        image: notes/frozen1_8.jpg
        text: '여기 "앞으로 이동" 블럭의 의미는 "앞으로 100 픽셀만큼 이동해라" 입니다. "실행하기"를 누르면 어떤 일이 일어날까요? 화면에서 엘사가 어느 정도 만큼 앞으로 움직일 것입니다. 정확히 100 픽셀만큼 움직입니다! 픽셀은 기본적으로 컴퓨터 화면의 그림을 만들어내는 아주 작은 단위의 사각형을 의미합니다.'
      9:
        image: notes/frozen1_9.jpg
        text: '이 퍼즐에서 주어진 다른 블럭은 "오른쪽으로 90도 만큼 회전하라"라는 것을 의미합니다. "오른쪽으로 회전" 블럭을 사용하면 엘사가 오른쪽으로 어느 정도 회전합니다. 원하는 만큼 엘사가 회전하도록 할 수 있습니다. 회전할 각도는 엘사가 바라보고 있는 앞을 기준으로 측정됩니다. 따라서 이것은 90도 회전하는 것이고, 이것은 120도 만큼 회전하는 것입니다.'
      10:
        image: notes/frozen1_10.jpg
        text: 각 블럭에서 아래쪽 화살표 부분을 클릭하면 원하는 픽셀만큼의 거리나, 회전할 각도의 값을 바꿀 수 있습니다.
    frozen_loops:
      1:
        image: notes/frozen2_1.jpg
        text: 안녕하세요! 저는 파올라라고 합니다! 컴퓨터들은 반복적인 작업을 진짜 아주 잘 합니다. 여러분들은 10, 20, 100까지 셀수 있습니다. 하지만 컴퓨터는 10억?, 1조 까지도 셀 수 있습니다. 컴퓨터는 전혀 지루해 하지도 않으면서 몇 초만에 다 셀 수 있습니다. 수를 세던, 그림을 그리던, 다른 어떤 것들을 하던지--컴퓨터들은 수백번~ 수십억번까지 반복해서 할 수 있습니다.
      2:
        image: notes/frozen2_2.jpg
        text: '이러한 것을 프로그래밍에서 루프(loop)라고 합니다. 루프를 이용하면 원하는 코드를 계속, 계속 반복해서 실행할 수 있습니다. 다음 퍼즐에서, 여러분의 목표는 "반복(Repeat)" 블럭을 이용해서 안나가 사각형을 그릴 수 있도록 도와주는 것입니다.'
      3:
        image: notes/frozen2_3.jpg
        text: '"반복(Repeat)" 블럭 안에 넣는 블럭들은 순서대로 실행되면서, 원하는 만큼 반복적으로 실행될 것입니다.'
      4:
        image: notes/frozen2_4.jpg
        text: '사각형을 그리기 위해서, "앞으로 이동" 블럭과 "오른쪽으로 회전" 블럭을 4번 사용할 수 있습니다. 하지만, 컴퓨터에게 "앞으로 이동", "오른쪽으로 90도 회전"을 한 번 실행시켰다면, 똑같은 방법을 4번 반복하라고 하면 매우 편리합니다. 그렇게 하기 위해, "앞으로 이동"블럭과 "오른쪽으로 회전" 블럭을 "반복(Repeat)" 블럭 안에 넣으면 됩니다.'
      5:
        image: notes/frozen2_5.jpg
        text: '"반복(Repeat)" 블럭안에 반복되어야 할 수를 마음대로 넣을 수 있습니다. 넣은 수만큼 반복해서 실행할 것입니다.'
    frozen_functions:
      1:
        image: notes/frozen3_1.jpg
        text: '안녕하세요. 저는 크리스 보쉬(Crish Bosh) 입니다.  저는 프로 농구 선수이면서, 대학에서 코딩을 하고 있습니다.'
      2:
        image: notes/frozen3_2.jpg
        text: 컴퓨터과학(정보과학)에서 가장 중요한 기초/개념/원리들 중 하나는 새로운 명령어들을 정의해서 만들어내는 것입니다. 대부분의 컴퓨터 프로그래밍언어는 기껏해야 100 단어 보다 작은 명령어들만으로 구성되어있습니다. 그리고 실제로 예술적이면서도 마법같은 것은 이러한 블럭들을 이용해, 자신이 원하는 새로운 블럭을 만들어낼 수 있다는 것입니다.
      3:
        image: notes/frozen3_3.jpg
        text: 일단, 한 번만 컴퓨터가 실행해야할 명령들을 컴퓨터에게 알려주었다면, 그러한 명령들을 묶어 새로운 이름을 붙일 수 있고, 그렇게하면 나중에 매우 쉽게 반복시킬 수 있게 됩니다. 명령들을 조합하고 거기에 원하는 이름을 붙이면, 그것을 바로 함수(function)라고 합니다.
      4:
        image: notes/frozen3_4.jpg
        text: 안녕하세요, 저는 제스입니다. 블럭을 사용해 프로그래밍을 할 때 어떤 동작들을 여러 번 반복해야 한다면 함수를 사용해 볼 수 있습니다. 예를 들어, 앞에서 만들었던 사각형을 그리는 코드를 생각해보세요.
      5:
        image: notes/frozen3_5.jpg
        text: '이 코드는 "사각형 그리기"라는 함수로 정의할 수 있습니다. '
      6:
        image: notes/frozen3_6.jpg
        text: 이제, 여러개의 사각형을 만들기 위해, 여러번 사용할 수 있는 새로운 블럭이 만들어졌습니다.
      7:
        image: notes/frozen3_7.jpg
        text: 여러 가지의 많은 단순한 모양들은 보다 복잡한 패턴들을 만들어내는데 사용될 수 있습니다. 다음 퍼즐들에서는 바로 전에 원을 만들기 위해 작성했던 코드를 새로운 함수로 정의하고, 그 함수를 이용해서 서로 다른 크기의 원들을 만들 수 있게 됩니다. 그 함수를 이용해서 복잡하고 아름다운 패턴의 눈을 만들어낼 수 있도록 엘사를 도와주세요.
    playlab_intro:
      1:
        image: notes/playlab_intro_1.png
        text: 이제 플레이 랩을 이용해 게임을 만들어보려고 합니다. 좋은 게임은 이야기가 있고, 모든 이야기들에는 주인공 캐릭터들이 있습니다. 이제 캐릭터들을 마녀, 외계인, 동물들로 설정하고 말하고, 움직이고 서로 서로 같이 이야기/반응하게 할 수 있습니다. 이 튜토리얼을 마칠 때 쯤이면 여러분들은 처음부터 시작해서 게임을 만들고 친구들에게 공유할 수 있게 될 것입니다.
      2:
        image: notes/playlab_intro_2.png
        text: 화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다.
      3:
        image: notes/playlab_intro_3.png
        text: 가운데 공간은 도구 상자이며, 이 블럭들은 각각 어떤 코드 조각을 의미합니다. 오른쪽의 흰색 빈 공간은 작업공간(workspace)이라고 부르는 곳으로 그곳에서 프로그램을 만들게 됩니다.
      4:
        image: notes/playlab_intro_4.png
        text: '처음 시작하기 위해서, 사용할 블럭들을 "실행하면" 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다.'
      5:
        image: notes/playlab_intro_5.png
        text: '이 첫번째 퍼즐에서, 캐릭터는 펭귄이고 말하기(say) 블럭을 이용해 "Hello!"라고 말하도록 만들것입니다. 실행하면 블럭에 붙인 후 "Hello"라고 입력하면 됩니다. 그리고 오른쪽으로 이동, 왼쪽으로 이동 블럭을 이용해 펭귄을 움직이도록 할 수도 있습니다. 블럭을 붙여본 후에 실행하기 버튼을 눌러 어떻게 실행되는지 살펴보세요.'
      6:
        image: notes/playlab_intro_6.png
        text: 시작하고나서 마지막 쯤에는, 여러분이 직접 여러가지 캐릭터들을 이용해 게임을 만들고, 표정을 바꾸게하고, 점수를 올리거나 서로 파이어볼을 쏘거나 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요.
    playlab_events:
      1:
        image: notes/playlab_events_1.png
        text: 이제, 모든 게임 프로그래머들이 매일 매일 사용하는 것들을 배워보도록 하겠습니다. 이벤트라고 합니다. 하나의 이벤트는 어떤 일이 일어났는지 여러분이 만든 프로그램에게 알려줄 수 있습니다. 따라서, 어떤 일(이벤트)가 일어났을 때 어떤 동작을 실행하게 할 수 있는 것입니다.
      2:
        image: notes/playlab_events_2.png
        text: 여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다.
      3:
        image: notes/playlab_events_3.png
        text: '이제, 캐릭터를 클릭했을 때 지구인들에게 인사하는 우주 로봇을 만들어보도록 하겠습니다. "클릭하면"이라는 블럭을 이용하고 "말하기"블럭을 붙이면 됩니다. 플레이어가 우주 로봇을 클릭하면, "클릭하면" 블럭에 붙어있는 모든 것들이 순서대로 실행될 것입니다. 여러분의 외계인 캐릭터가 어떻게 동작할까요?'
      4:
        image: notes/playlab_events_4.png
        text: '"방향키 누름"블록이 있습니다. 이 블록들에 "이동하기" 블록을 붙이면 방향키를 눌렀을 때, 위로, 아래로, 왼쪽으로, 오른쪽으로 이동시킬 수 있습니다. 한 단계씩 여러분이 만든 게임이 더 인터랙티브하게 변화해 갈 것입니다.'
    playlab_repeat_forever:
      1:
        image: notes/playlab_repeat_forever_1.png
        text: '이번에는 "무한 반복"블럭입니다. 이 블럭의 안에 넣은 블럭들은 게임이 실행되는 동안 계속해서 무한히 실행될 것입니다.'
      2:
        image: notes/playlab_repeat_forever_2.png
        text: '만약에 캐릭터를 어떤 동작에 대해서 반복적으로 실행하게 하려면, 반복시킬 블럭들을 "무한 반복" 블럭 안에 넣으면 됩니다.'
      3:
        image: notes/playlab_repeat_forever_3.png
        text: 이 퍼즐에서, 우리의 목표는 마법사 캐릭터가 왕국의 경계를 순찰하도록 하는 것입니다. 왼쪽에서 오른쪽으로 계속 반복해서 움직이도록 하는 것입니다. 반복 실행 명령어를 배우고 이용하면, 여러분이 만든 게임에서 일일이 모두 반복적으로 작성할 필요가 없이, 한 번만 작성한 후에 계속해서 여러번 사용할 수 있게 되는 것입니다.
    C1_artist_intro:
      1:
        image: notes/C1_artist_intro_1.png
        text: 다음은 그리기 블록입니다. 회색선들을 채워야하는 예술가를 움직이기 위해 정확한 방법을 사용하세요.
      2:
        image: notes/C1_artist_intro_2.png
        text: 이번에는 점프 블록입니다. 여러분이 이것을 할 때 당신의 예술가는 그림을 그리는 것 뿐만 아니라 움직이기도 합니다. 그럴때 다음 회색선으로 점프를 이용하세요.
    C1_bee_level_intro:
      1:
        image: notes/C1_bee_level_intro_1.png
        text: '꿀벌들은 정말 멋진 곤충입니다. 다음 퍼즐들의 목표는 꿀벌을 꽃으로 이동시켜서 꽃꿀을 뽑고, 벌집으로 이동시켜서 꿀을 만드는 것입니다. "꽃꿀 얻기" 와 "꿀 만들기" 블록을 사용하면 됩니다.'
      2:
        image: notes/C1_bee_level_intro_2.png
        text: '모든 꽃은 서로 다른 양의 꽃꿀을 가지고 있습니다: 1, 2, 3, 또는 그 이상. 빨강 꽃의 모서리에는 꽃꿀의 양이 나타나 있다는 것을 알 수 있습니다. 앞으로 이동하기 전에 꽃의 꽃꿀을 모두 뽑아내세요. 그리고, 모든 벌집은 그 만큼의 꿀을 보관할 수 있습니다: 1, 2, 3, 또는 그 이상. 따라서, 해당 벌집이 보관할 수 있을 만큼 씩만 꿀을 만들어야 합니다.'
      3:
        image: notes/C1_bee_level_intro_3.png
        text: '여러분이 만약에 모든 넥타를 얻을 수 있다면 여러분은 성공을 한 것이고, 다음 레벨로 가게됩니다. 만약 그렇지 않다면, 여러분은 이 퍼즐을 다시 해야 합니다. 다시 돌아가서 "꿀벌" 프로그래머와 같은 기분을 느껴보세요!'
    C1_bee_loops:
      1:
        image: notes/C1_bee_loops_1.png
        text: |
          반복 구조는 어떤 실행 내용을 반복하도록 하는 것입니다. 들어가서 조사하고, 구조를 살펴보고, 다시 나오는, 한 번의 과정을 여러 번 실행 시킬 수 있습니다.
          반복 구조 안에 넣으면, 똑같은 작업을 여러 번 실행할 수 있습니다.
      2:
        image: notes/C1_bee_loops_2.png
        text: |-
          이번 레벨에서 우리는 꽃에서 세개의 넥타를 수집하는 벌을 원합니다. 세개의 '넥타 얻기' 블록을 사용하는 대신에, 당신은 넥타를 세번 얻기 위해서 반복 블록을 사용해야 합니다. 만약 당신이 그것을 잘 얻었다고 보인다면 "실행"버튼을 눌러서 확인해보세요. 잘 했어요!
    C1_bigevent_unplugged:
      1:
        image: notes/C1_bigevent_unplugged_1.png
        text: 이번 레슨의 제목은 큰! 이벤트 입니다. 우리가 프로그램들을 움직이고, 버튼이나 마우스를 눌러 이벤트들을 전달해서 프로그램의 실행을 변화시키는 것들에 대한 이야기입니다.
      2:
        image: notes/C1_bigevent_unplugged_2.png
        text: 이번 레슨에서 여러분들은, 종이 리모트 컨트롤에 의해서 조종될 것입니다. 마치 실시간 비디오 게임과 비슷할 것입니다.
      3:
        image: notes/C1_bigevent_unplugged_3.png
        text: 이벤트는 어떤 일이 일어나도록 하는 동작입니다. 여러분이 마우스를 클릭했을 때, 웹페이지가 로드 되는 것과 같습니다. 그것이 바로 이벤트입니다. 태블릿의 화면을 스크롤 하기 위해서 화면을 터치할 때, 그것도 이벤트입니다. 이벤트들은 사용자들이 프로그램의 동작을 제어할 수 있도록하는 훌륭한 방법입니다.
      4:
        image: notes/C1_bigevent_unplugged_4.png
        text: 우리는 모든 일들에 응답할 수 있습니다. 우리는 배고픔을 느끼면 냉장고로 달려갑니다. 우리는 우편배달부가 와서 우체통에 편지를 넣는 소리를 듣고 메일을 가질러 달려갑니다. 그런 것들이 버튼을 누르거나 조이스틱을 움직이는 것과 같은 이벤트입니다. 이벤트는 어떤 일을 일으키는 방아쇠 같은 역할을 합니다.
      5:
        image: notes/C1_bigevent_unplugged_5.png
        text: '비디오 게임들에서 "업데이트"라는 이벤트는 1초에 30번 또는 60번 일어납니다. 비디오 게임 프로그래머에게는 버튼을 누르거나 조이스틱을 움직이는 것보다 더 중요합니다.'
      6:
        image: notes/C1_bigevent_unplugged_6.png
        text: '우리가 살펴보고자하는 메인 이벤트는 "업데이트"라는 신호 입니다. 아주 짧은 시간 동안에 조이스틱의 움직임을 체크합니다. 그렇게 "이 프레임에서 누군가가 단추를 눌렀나? 그런가? 아닌가?" 등을 확인할 수 있습니다. 이런 이벤트들이 없다면 게임 플레이어가 움직일 수도, 점프를 할 수도, 제어할 수도 없습니다. 비디오게임에서 화면을 바꿔 애니메이션을 보여줄 수도 없을 것입니다.'
    C1_building_foundation:
      1:
        image: notes/C1_building_foundation_1.jpg
        text: 여러분들은 모래 조각에서, 실패도 프로그램의 일부분이라는 것을 알았을 것입니다. 하지만 계속 노력하면, 점점 더 잘하게 되고 더 재미있게 됩니다. 이제 끊임없는 노력과 열정이라는 게임을 함께 살펴봅시다. 아주 재미있을 거에요.
      2:
        image: notes/C1_building_foundation_2.jpg
        text: 이번 레슨의 제목은 기초 만들기 입니다. 이 레슨에서는 정말 어려운 작업을 하게 될 것입니다. 여러분들은 최대로 이 컵들 높이 정도 만큼의 구조로, 책의 무게를 견딜 수 있도록 하는 구조를 어떻게 만들어낼 지 생각해 내야 합니다.
      3:
        image: notes/C1_building_foundation_3.jpg
        text: 만들어 낸 것이 원하는 대로 움직이지 않을 것입니다. 당황스럽고 포기하고 싶을 것입니다. 그런 순간들이 매우 많이 있을 수 있습니다. 하지만 계속 노력하고, 반복해서 최선을 다 한다면, 언젠가는 될 것이라는 것을 알고 있습니다.
      4:
        image: notes/C1_building_foundation_4.jpg
        text: 끊임없는 노력과 열정은, 여러분들이 정말로 포기하고 싶을 때 포기하지 않게 해주는 힘이라고 할 수 있습니다. 여러분들이 지금까지는 없었던 새롭고 다른 것을 만들어내려고 한다면, 그 앞에는 수 많은 실패들이 놓여 있을 것입니다.
      5:
        image: notes/C1_building_foundation_5.jpg
        text: 끊임없는 노력과 열정은, 실망하고 좌절해서 포기하려는 것이 아니라, 실패들로부터 더 배우고 계속 도전해 나가는 것을 선택하면서 만들어지게 됩니다. 실망과 좌절은 실제로는 그 근처에 멋진 세상이 있다는 것을 의미합니다. 그렇기 때문에.. 원하는 것을 얻기 전까지 포기하지 말고 힘내세요!
    C1_getting_loopy:
      1:
        image: notes/C1_getting_loopy_1.png
        text: 안녕하세요. 여러분! 저는 일루미나티(iLuminati) 작품들을 만들어낸 마이랄 코트(Miral kotb) 입니다. 작품들을 만들기 위해서는 춤(dances) 과, 프로그래밍이 되는 라이트 슈트(lightsuits) 가 모두 필요합니다. 이건 반복이에요! 반복은 어떤 동작을 무한히 반복해 줍니다.
      2:
        image: notes/C1_getting_loopy_2.png
        text: 여러분들이 어떤 작업을 여러 번 반복할 때에는, 제가 훌라후프를 계속 돌리기 위한 동작을 하는 것처럼, 동작을 반복해서 실행하고 있는 것입니다. 이것이 반복입니다. 이것도 반복입니다. 이것도 반복입니다.
      3:
        image: notes/C1_getting_loopy_3.png
        text: 오늘 우리는 무도회를 할 것입니다. 우리는 루프를 새로운 춤을 통해 작동시킬 것입니다. 반복합니다. 우리는 루프를 춤을 통해 배울 것입니다. 여러분은 쉬운 몇 단계를 학습하고, 반복해 춤을 끝낼 것입니다.
      4:
        image: notes/C1_getting_loopy_4.png
        text: 여기에 여러분이 배워야 할 단계들이 있습니다. 손뼉을 쳐보세요. 머리 뒤로 손을 올려보세요. 손을 허리에 두세요. 왼손을 드세요. 오른손을 드세요. 정말 간단하죠? 그렇죠? 여러분은 어떤 춤의 동작들을 반복문 안에 넣어, 같은 내용을 짧게 만들 수 있습니다.
      5:
        image: notes/C1_getting_loopy_5.png
        text: |
          우리는 실제로 춤에서 반복을 이용합니다. 컴퓨터를 착용한 댄서들은 모두 같은 네트워크 상에 있습니다. 나는 아마도 댄서들에게 반복적으로 계속하하게 함으로써........ 할지도 모릅니다........
          그리고 그것이 반복으로 만들어낼 수 있는 전부입니다. 반복은 컴퓨터과학에서 중요합니다. 왜냐하면 그것은 우리의 작업을 쉽고 간결하게 해 주기 때문입니다.
    C1_happy_maps_unplugged:
      1:
        image: notes/C1_happy_maps_unplugged_1.png
        text: 이번 학습은 행복한 지도라고 합니다. 오늘 우리는 털북숭이 작은 친구 Flurb가 과일 있는 곳에 도착하도록 도울 것입니다.
      2:
        image: notes/C1_happy_maps_unplugged_2.png
        text: 여러분의 Flurb가 과일 있는 곳까지 가도록 해 주세요. 그러기 위해 여러분은 Flurb가 가야할 길을 생각해 내야만 하고, 화살표로 지시해야 합니다. Flurb가 사과에 도착하게 하기 위해서 Flurb가 어느 방향으로 가야할까요? 선을 그려보세요.
      3:
        image: notes/C1_happy_maps_unplugged_3.png
        text: 그것을 얻기 위해 원이 움직여야 할 방향이 있다.
      4:
        image: notes/C1_happy_maps_unplugged_4.png
        text: 문제를 풀기 위해 필요한 알고리즘을 지도 옆에 있는 화살표들 붙여 만들어보세요. 두 번째 것도 같은 것인데, 아래로 내려가는 것입니다.
      5:
        image: notes/C1_happy_maps_unplugged_5.png
        text: 그것은 종이를 가지고 프로그래밍 하는 것과 같습니다. 그리고 그게 전부입니다.
    C1_maze_debugging:
      1:
        image: notes/C1_maze_debugging_1.png
        text: 디버깅은 문제를 찾아내고 수정하는 것입니다. 문제들을 디버깅 많은 방법들이 있습니다. 가장 쉬운 방법 중 하나는, 무언가 잘못된 것을 찾을 때까지 한 단계씩 진행하는 것입니다. 저는 빔 위에서 백핸드스프링을 연습하려고 하는데 계속 떨어졌습니다.
      2:
        image: notes/C1_maze_debugging_2.png
        text: 나는 각 단계를 살펴보고 나의 실수를 깨달았습니다. 나는 나의 손을 정확한 빔 위에 놓지 않았습니다. 그래서 나는 나의 새로운 손 위치를 이용하여 빔 위의 다른 백 핸드 스프링을 시도하였고, 결국 해결하게 되었습니다. 나는 나의 백 핸드스프링 오류를 발견하고 수정하여서 정말 기뻤습니다.
      3:
        image: notes/C1_maze_debugging_3.png
        text: 디버깅에 대해 배우기 위해 우리는 각 단계에서 이미 블록 세트를 시작하였습니다. 우리는 이 블록들이 여러분들의 목표에 닿지 않을 것이라는 걸 알게 될 것입니다. 우리는 그것을 수정하고 디버깅 할 필요가 있습니다. 무엇이 잘못되었나요? 여러분들은 하나 이상의 블록을 서쪽으로 옮길 필요가 있다는 것을 알게 될 겁니다.
      4:
        image: notes/C1_maze_debugging_4.png
        text: 왼쪽블록을 추가하여 이것을 고쳐보세요. 만약에 여러분이 옳게 하였다면 결과를 확인하기 위해 실행버튼을 눌러보세요. 와우! 여러분은 성공하였습니다!
    C1_maze_intro_sequencing:
      1:
        image: notes/C1_maze_intro_sequencing_1.png
        text: 이번 퍼즐에서, 여러분들은 새를 돼지에게 이동시켜야 합니다. 퍼즐을 살펴보고 어떤 방향으로 움직여야 될 지 찾아보세요.
      2:
        image: notes/C1_maze_intro_sequencing_2.png
        text: |-
          여러분은 작업 영역에 있는 툴박스에서 블록을 드래그 해야 합니다. '실행하면" 버튼 아래 여러분이 생각하는 블록을 붙이고, 여러분이 정확하게 했다고 생각할 때 "실행" 버튼을 클릭하여고, 앵그리버드가 돼지를 향해 움직이는 것을 확인하세요.
    C1_maze_loops:
      1:
        image: notes/C1_maze_loops_1.png
        text: 컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다.
      2:
        image: notes/C1_maze_loops_2.png
        text: 예를 들어, 제가 페이스북의 모든 사람들에게 생일 축하 이메일을 보내려고 할 때, 그 사람들에게 모두에게 이메일을 따로 작성하려고 한다면, 100년 넘게 걸릴 수도 있습니다. 하지만, 코드 몇 줄이면 페이스북의 모든 사람들에게 생일 축하를 알리는 메일을 보내는 시스템을 만들 수 있습니다.
      3:
        image: notes/C1_maze_loops_3.png
        text: '이 레벨에서 앵그리버드가 돼지를 얻기 위해 여러분은 작업공간에서 세번의 위쪽 블록을 가져오는 대신 "반복"블록을 사용할 것입니다. 작업공간에서 "반복" 블록을 끌어오고 숫자에 3을 적어 넣으세요. 그리고 나서 "반복" 블록 안에 "위쪽" 블록을 넣고, 그것이 잘 되었는지 확인하기 위해 "실행" 버튼을 클릭해보세요. 당신이 해 냈군요!! 축하합니다!! ^^'
    C1_moveitmoveit_unplugged:
      1:
        image: notes/C1_moveitmoveit_unplugged_1.png
        text: 이번 레슨은 흔들흔들이라고 부릅니다. 우리는 여러분의 친구들이 나침도를 가지고 시작하여 스마일 얼굴에 도착하도록 하는 프로그램을 작성할 것입니다.
      2:
        image: notes/C1_moveitmoveit_unplugged_2.png
        text: 하지만 스마일리는 고개를 숙이고 있고, 오로지 1명만 저 곳에 갈 방법을 알고 있습니다. 이 프로그램을 시작시켜보세요.
      3:
        image: notes/C1_moveitmoveit_unplugged_3.png
        text: 프로그램은 기계가 실행할 수 있도록 코드화된 알고리즘입니다. 대부분의 사람들은 프로그램이 컴퓨터에서만 사용되는 것이라고 생각합니다. 컴퓨터에서 정말 잘 사용되지만, 다른 곳에서도 도움이 됩니다. 자신만의 게임을 만들거나, 여러분을 위해 일을 하는 로봇을 프로그램할 수도 있습니다.
    C1_going_places_safely:
      1:
        image: notes/C1_going_places_safely_1.png
        text: |
          제 이름은 예레미아입니다. 안녕하세요! 저는 7살입니다. 저는 제 어머니의 컴퓨터를 가지고 노는 것을 좋아하지만 언제나 먼저 허락을 받습니다.
          예레미아: "엄마, 컴퓨터 써도 되요?"
          엄마: "당연하지!"
      2:
        image: notes/C1_going_places_safely_2.png
        text: 저는 인터넷을 쓸 수 있기 때문에 제 어머니의 컴퓨터를 좋아합니다. 인터넷은 이웃 같아요. 멋있는 곳도 방문할 수 있고, 가족과 친구들에게 말 할 수 있고, 새로운 것도 많이 배울 수 있으니까요.
      3:
        image: notes/C1_going_places_safely_3.png
        text: 어제, 나는 우리 집 근처에 있는 동물원에 갔었습니다. 거기서 나는 아기 얼룩말을 보았습니다. 사진을 찍었고, 얼룩 무늬의 색을 바꿔보았습니다. 그리고나서 모자를 씌우고, 나의 익살스러운 동물 모음에 추가하였습니다. 멋져요! 나는 나중에 아주 먼 곳 아프리카의 케냐에 갔습니다. 거기에는 많은 얼룩말이 살고 있습니다.
      4:
        image: notes/C1_going_places_safely_4.png
        text: '때때로 인터넷 상에서 나는 다른 도시에 사시는 할머니와 같이 내가 알고 있는 사람들과 이야기를 나눕니다. 할머니 안녕하세요! 할머니는 제 생일에 보내주실 쿠키를 만드시는 중이랍니다. "와~ 맛있겠어요. 인터넷이 smelloeama를 가졌으면 좋겠어요!" 나는 인터넷에서 내 사촌과 같은 또 다른 사람들과도 이야기할 수 있는데 오직 아는 사람하고만 이야기합니다.'
      5:
        image: notes/C1_going_places_safely_5.png
        text: 내가 인터넷에서 가장 좋아하는 것은 재미있는 게임을 하는 것입니다. 점수 따기! 나는 또한 그림을 그리고 새로운 것을 만들고 그것을 친구들과 나누기를 좋아합니다. 신나요! 때때로 새로운 것을 배우는 웹사이트를 방문하가도 하지만 나는 항상 나에게 딱 맞는 웹사이트를 고수합니다. 와, 공룡이예요!
      6:
        image: notes/C1_going_places_safely_6.png
        text: |
          인터넷은 정말로 재미있는 곳이에요. 그러나 도로를 건널 때 처럼 인터넷을 쓸 때도 조심해야해요. 기억해야 할 룰이 3개 있어요.
          1. 먼저 부모님에게 허락을 받아야 해요.
          2. 아는 사람들에게만 이야기하세요.
          3. 방문해야 될 웹사이트만 방문하세요.
      7:
        image: notes/C1_going_places_safely_7.png
        text: 와우! 정말 신나! 이제 저녁시간이에요. 나는 이제 로그 오프를 합니다. 나는 다음에 방문할 곳을 알기 위해 새로 로그인을 할때까지 기다리기 힘들어요.
    C1_pair_programming:
      1:
        image: notes/C1_pair_programming_1.png
        text: 오늘 우리는 페어 프로그래밍에 대해서 배울거에요. 페어 프로그래밍에서 여러분은 팀으로 작업합니다. 왜 한 컴퓨터를 두 명이 사용해야 할까요? 왜냐하면 두 사람의 두뇌가 한 사람 보다는 낫기 때문입니다. 페어 로그래밍에서 여러분과 여러분의 짝은 한 컴퓨터 앞에 같이 앉아서 같은 프로젝트에 대해 함께 작업합니다.
      2:
        image: notes/C1_pair_programming_2.png
        text: 페어 프로그래밍에서는 마치 자동차 운전에서와 같이 한 사람은 운전자이고 다른 한 사람은 동승자입니다. 운전자는 컴퓨터 앞에 앉아서 키보드, 마우스 또는 터치스크린을 사용하는 사람이며 컴퓨터의 주요 동작을 제어합니다. 다른 한 사람은 동승자입니다. 동승자는 운전자의 질문에 대답하고 잠재적인 문제 또는 실수를 짚어내며 운전자에게 도움을 줍니다.
      3:
        image: notes/C1_pair_programming_3.png
        text: 커뮤니케이션은 성공적인 페어 프로그래밍을 위한 열쇠입니다. 창피하게 만들지 말고, 이래라 저래라 지시하지 말아주세요. 누구나 그렇게 대우 받기 싫어하기 때문입니다. 서로 존중해 주세요. 여러분과 여러분의 짝은 항상 대화를 해야 합니다. 드라이버는 자기가 무엇을 하고 있는지 설명할 수 있고, 네비게이터는 다음에 무엇을 해야하는지 제안하면서 서로 도울 수 있습니다.
      4:
        image: notes/C1_pair_programming_4.png
        text: 동승자는 큰 그림에 대해 이야기해야 하고 운전자는 세부 사항에 초점을 맞춥니다. 두 사람의 역할 모두 중요합니다. 페어 프로그래밍은 함께 팀을 이루어 작업하는 것에 관한 모든 것입니다.
    C1_planting_seed:
      1:
        image: notes/C1_planting_seed_1.png
        text: 이번 수업은 씨앗 심기라고 불리고, 우리가 알고리즘을 이해하는데 도움이 될 것입니다. 알고리즘은 무엇인가를 하기 위한 순서를 설명하는 구체적인 명령문들입니다. 아침 식사 또는 양치질과 같은 일상의 일들조차 그 일을 하기 위한 작은 단계들이 필요합니다.
      2:
        image: notes/C1_planting_seed_2.png
        text: 컴퓨터는 아주 똑똑해질 수 있지만, 한 단계씩 한 단계씩 정확하게 이야기 해 주었을 때에만 이해할 수 있습니다. 알고리즘들의 위대함은, 여러분들이 원하는 작업을 어떻게 해야하는지 몰랐는데도 불구하고, 어떤 순서에 따라서 작업을 수행했을 때 그 작업을 수행할 수 있게 된다는 점입니다. 마치 요리법을 따라하는 것과 같습니다.
      3:
        image: notes/C1_planting_seed_3.png
        text: 오늘 우리는 알고리즘을 이용하여 씨앗을 심을 것입니다. 그림을 오려내어 여러분만의 알고리즘을 만들어 보세요. 씨앗을 심는 단계를 보여주는 그림을 선택하고 그 그림들을 올바른 순서대로 배열해 보세요.
      4:
        image: notes/C1_planting_seed_4.png
        text: 이제 여러분의 알고리즘이 동작하는 것을 볼 시간입니다. 매우 주의깊게 알고리즘의 단계를 따라가 보세요. 올바른 순서대로 되어 있나요? 알고리즘을 따름으로써 씨앗 심기에 성공했나요? 그것은 그림들을 가지고 프로그래밍하는 것과 같습니다.
      5:
        image: notes/C1_planting_seed_5.png
        text: 우리가 초콜렛 만들기를 원할 때 그 과정에 아주 많은 큰 단계들이 있고, 그 큰 단계들 각각은 더 작은 단계 집합으로 되어 있습니다. 그리고 어떤 초콜렛 맛을 원하는지에 따른 서로 다른 레시피나 알고리즘이 있습니다. 작은 단계일지라도 각 단계는 중요해서 한 단계라도 제외하면 나머지로 완성할 수 없습니다. 다른 사람들이 이해할 수 있는 알고리즘을 만드는 것은 매우 중요합니다. 그것이 각 단계를 적어 놓아야 하는이유이며 그리하여 누가 행하든 관계 없이 그 결과는 같게 됩니다.
    C1_playlab_storytelling:
      1:
        image: notes/C1_playlab_storytelling_1.png
        text: 여러분의 코딩 기술을 창조적으로 사용하여 이야기할 시간입니다. 여러분의 이야기에는 배우가 있을 것이고 여러분은 이 배우들이 말하게도, 서로 상호작용하게도 만들 수 있습니다. 여러분이 하고 싶은 이야기가 어떤 종류의 이야기인지 생각해보세요.
      2:
        image: notes/C1_playlab_storytelling_2.png
        text: '고양이는 항상 강아지를 무서워했습니다. 고양이는 강아지가 착해지려고 노력하는 중이라고 생각한다면 어떻게 될까요? "~할 때 실행" 블록은 어느 것이든 시작합니다. "이동" 블록은 여러분의 주인공을 움직이게 할 것이고, "말하기" 블록은 여러분이 입력하는대로 주인공이 말하게 할 것입니다.'
      3:
        image: notes/C1_playlab_storytelling_3.png
        text: '"배우가 충돌할 때" 블록은 다른 블록들과 연결할 수 있는 블록입니다.'
      4:
        image: notes/C1_playlab_storytelling_4.png
        text: '나는 강아지가 다가와서 "안녕"이라고 말했지만 그 다음에 고양이가 너무 무서워서 도망갔다고 만들었었습니다. "아" 좀 더 시간이 있었다면 그 이야기는 해피엔딩이 되었을 텐데요. 끝!'
    C1_spelling_bee_intro:
      1:
        image: notes/C1_spelling_bee_intro_1.png
        text: 이것은 철자 맞추기 수준입니다. 퍼즐 조각을 사용하여 벌이 움직이도록 해 보세요. 벌이 이동함에 따라 글자를 수집하여 단어가 되도록 할 것입니다.
      2:
        image: notes/C1_spelling_bee_intro_2.png
        text: 만약에 여러분이 단어를 만들 수 있다면 무대 아래쪽 상자 안에 그들이 주는 것을 보세요. 하지만 조심하세요! (be careful을 잘못 쓴 것인가? 아니면 꿀벌인가..? ㅎㅎ) 잘못된 방향으로 이동하면 여러분이 원하지 않는 글자가 추가될 것입니다.
    C1_zuck_repeat_loop:
      1:
        image: notes/C1_zuck_repeat_loop_1.png
        text: 컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다.
      2:
        image: notes/C1_zuck_repeat_loop_2.png
        text: 예를 들어, 제가 페이스북의 모든 사람들에게 생일 축하 이메일을 보내려고 할 때, 그 사람들에게 모두에게 이메일을 따로 작성하려고 한다면, 100년 넘게 걸릴 수도 있습니다. 하지만, 코드 몇 줄이면 페이스북의 모든 사람들에게 생일 축하를 알리는 메일을 보내는 시스템을 만들 수 있습니다.
      3:
        image: notes/C1_zuck_repeat_loop_3.png
        text: 이 예제에서 여러분의 목표는 새가 돼지를 잡도록 이동시키는 것입니다. 자, 우리는 아주 쉽게 이것을 가능하게 하는 반복 블록을 사용할 수 있게 될 것입니다. 여러분은 새가 한 번에 한 발짝씩 전진하여 돼지에게 갈 수 있도록 컴퓨터에게 앞으로 전진 명령을 다섯 번 줌으로써 이를 실행할 수도 있고, 아니면 그냥 앞으로 한 번만 이동하라고 한 뒤에 이를 다섯 번 반복하라고 명령할 수도 있는데 이것은 둘 다 똑같이 실행됩니다.
      4:
        image: notes/C1_zuck_repeat_loop_4.png
        text: 이것을 하기 위해서 앞으로 전진 명령을 드래그하여 반복 블록 안에 넣으세요. 그리고 그것을 클릭하여 앞으로 이동시키고 싶은 걸음수만큼 그 블록의 반복 횟수를 입력하면 됩니다.
      5:
        image: notes/C1_zuck_repeat_loop_5.png
        text: 또 한 가지는 여러분은 반복 블록 안에 여러분이 원하는 만큼의 명령을 넣을 수 있다는 것입니다. 그래서 이 예제에서 여러분은 다섯 번 실행되는 앞으로 이동 명령과 왼쪽으로 돌기 명령을 내릴 수 있습니다. 즐거운 시간 보내세요!
    C2_artist_intro:
      1:
        image: notes/C2_artist_intro_1.png
        text: 컴퓨터과학(정보과학) 에 대한 전문가가 없다면, 자동차 레이스에서 예선도 통과하지 못 할 수 있습니다. 왜냐하면, 어떻게 해야 자동차 경주에서 효과적일지 알아내기 위해서 컴퓨터 프로그램을 만들어야 하는데, 그러기 위해서 자동차의 수많은 데이터들을 계속해서 수집하고, 그러한 데이터를 이용해서 필요한 정보를 만들어내는 프로그램을 만들어내는 사람이 있어야 하기 때문입니다.
      2:
        image: notes/C2_artist_intro_2.png
        text: 이번 퍼즐들에서는, 연필을 이용해 여러 가지 도형을 그리는 화가가 될 것입니다. 화가가 이동하면 그 뒤에 선이 그려질 것입니다.
      3:
        image: notes/C2_artist_intro_3.png
        text: 캔버스를 돌아다니기 위해서 앞으로 이동 블록을 사용할 수 있습니다. 여기있는 앞으로 이동 블록은 100 픽셀씩 앞으로 가도록 하고 있습니다. 실행시키면 어떤 일이 일어날까요? 여러분의 예술가가 정확히 100 픽셀만큼 앞으로 이동합니다. 픽셀은 기본적으로 여러분 컴퓨터 화면 위의 아주 작은 사각형입니다.
      4:
        image: notes/C2_artist_intro_4.png
        text: 이 퍼즐에서 우리가 가진 또 다른 블록은 오른쪽으로 90 회전하는 블록입니다. 그리고 우리가 그 블록을 끌어낼 때 우리의 예술가가 정해진만큼 회전합니다. 그래서 여러분은 예술가가 얼마나 회전하길 원하는지를 가지고 놀 수 있습니다. 이것이 90도 회전입니다.
      5:
        image: notes/C2_artist_intro_5.png
        text: 그리고 이것은 120 도 회전입니다. 여러분들은 픽셀이나 각도를 지정하기 위해 수 옆에 있는 화살표들을 클릭해서 이런 값들을 바꿀 수 있습니다. 여러분의 화가로 마음 껏 그려보세요!
    C2_bee_conditionals:
      1:
        image: notes/C2_bee_conditionals_1.png
        text: 이것은 조건부 블록입니다. IF는 꽃꿀이나 꿀의 양이 어떤 숫자보다 더 적은지, 같은지 또는 더 많은지를 말해주고, THEN은 무언가를 실행합니다.
      2:
        image: notes/C2_bee_conditionals_2.png
        text: 이것은 여기 물음표가 함께 보이는 것처럼 우리가 얻어야 꽃꿀이나 꿀이 얼마나 많은지 모를 때 유용합니다.
      3:
        image: notes/C2_bee_conditionals_3.png
        text: 이 예제에서 우리는 자주색 꽃이 0보다 많은 꽃꿀을 가지고 있다면 꽃꿀을 얻으라고 말할거예요. 그것은 꽃꿀이 있는 한 계속 얻도록 하는 것입니다. 기대하시라!
    C2_binary_bracelets:
      1:
        image: notes/C2_binary_bracelets_1.png
        text: 이것은 이진 팔찌 레슨입니다. 우리는 우리가 찰 수도 있고 모든 친구들에게 보여줄 수 있는 팔찌에 우리의 이니셜을 코드로 만들 것입니다.
      2:
        image: notes/C2_binary_bracelets_2.png
        text: 2진 체계는 오직 두 가지 선택사항만을 사용하여 정보를 표현하는 방법입니다. 때때로 사람들은 이것을 오직 1과 0으로 만 생각합니다. 하지만 on/off, 위/아래, 안/밖 등 서로 반대되는 어떤 세트라도 사용해 표현할 수 있습니다.
      3:
        image: notes/C2_binary_bracelets_3.png
        text: 안녕하세요. 저는 여기 Play-im 에서 로봇 프로그래밍을 하고 있는 오리온이라고 합니다. 모든 컴퓨터와 로봇들의 두뇌들은 가장 기본적인 수준에서는 조그만 전기 논리 게이트들입니다. 논리 게이트가 열리면, 전기가 흐르고, 논리 게이트가 닫히면 전기가 흐르지 못합니다.
      4:
        image: notes/C2_binary_bracelets_4.png
        text: 이 로봇에 있어서 2진의 예시는 로봇의 눈입니다. 로봇의 눈은 on/off 되는 LED들로 구성되어있습니다. LED는 2진 체계로 되어있습니다. 우리는 빛을 이용해 2진수를 표현할 수 있습니다. 한 세트의 로봇이 있다고 하면, 첫 번째 위치의 로봇, 두 번째 위치의 로봇, 세 번째 위치의 로봇... 로 생각할 수 있습니다. 그러한 방법으로 2진 수를 표현할 수 있습니다. 로봇들은 그들의 2진 눈으로 표현할 것이고, 여러분을 위해 계산해 줄 것입니다.
    C2_conditionals_with_cards:
      1:
        image: notes/C2_conditionals_with_cards_1.png
        text: "이 수업은 '카드를 사용한 조건'이라고 불립니다. 매일 여러분은 여러분이 보고 듣는 것에 기초하여 결정을 내립니다."
      2:
        image: notes/C2_conditionals_with_cards_2.png
        text: 공원에 산책을 가고 싶은데, 먼저 우산을 가지고 가야할지 말지를 먼저 결정해야 합니다. 그래서 먼저 창문 밖을 봅니다. 구름낀 흐린 날이라면? 우산을 가져야하고, 그렇지 않다면? 선글라스를 가지고 산책을 갈 것입니다. 우산을 가지고 나가는 것이 좋을 것 같네요. 이렇게 제가 먼저 보고 들은 것 때문에, 공원에 어떤 것을 가지고 갈지 결정할 수 있는 것입니다.
      3:
        image: notes/C2_conditionals_with_cards_3.png
        text: '조건/선택 구조는 게임에서도 사용됩니다. 여기서 우리는 카드 게임에서 조건/선택 구조를 사용하는 방법을 연습해 볼 것입니다. 이 게임에서, 제가 카드를 내려 놓으면, 그 카드에 따라서 친구들이 해야할 행동을 지정해 주게 됩니다. 제가 만약 7 카드를 내려놓으면? 모든 친구들이 손벽을 쳐야합니다. 그렇지 않으면, 모든 친구들이 "아으"라고 말합니다. 자 이제 해보세요! "아으". 자 모두들 화이팅해보세요!'
      4:
        image: notes/C2_conditionals_with_cards_4.png
        text: 조건/선택 구조들을 이용하면, 게임들을 좀 더 재미있게 만들 수 있습니다. 자 한 번 해보세요! 조건/선택 구조들은 컴퓨터를 똑똑하게 만들어 줍니다. 조건/선택 구조들이 사용되고 있는 컴퓨터 프로그램들은, 사람들의 반응에 따라 서로 다른 작업들을 수행할 수 있게 됩니다.
      5:
        image: notes/C2_conditionals_with_cards_5.png
        text: 여러분이 제일 좋아하는 비디오 게임을 생각해 보세요. 여러분은 다른 동작을 할 때에 비해 어떤 동작에 대해서 점수를 더 얻나요? 이것은 컴퓨터가 조건문을 사용하기 때문에 발생합니다. 이것이 컴퓨터가 결정을 내리는 방식입니다. 자, 여러분이 목표물을 맞추면 여러분은 10점을 얻습니다. 그렇지 않으면 여러분은 3점을 잃습니다. 조건문이 어떻게 동작하는지를 알 때 여러분은 모든 종류의 흥미진진한 게임을 만들 수 있습니다.
    C2_artist_debugging:
      1:
        image: notes/C2_artist_debugging_1.png
        text: 작업 공간에 몇 개의 블록들이 있습니다. 하지만 뭔가 잘못 된 것 같네요.
      2:
        image: notes/C2_artist_debugging_2.png
        text: 이번에는 코드의 실행 속도를 느리게 하거나, 한 번에 한 블록씩 실행시켜 살펴보면서 코드의 오류를 수정해보세요.
      3:
        image: notes/C2_artist_debugging_3.png
        text: 아, 문제가 있어요! 그 고양이의 수염의 길이는 25픽셀이 아니고 75픽셀입니다.
    C2_bee_debugging:
      1:
        image: notes/C2_bee_debugging_1.png
        text: 디버그/디버깅이라는 말을 들어본 적이 있나요? 디버깅은 프로그램이 제대로 동작하지 않는 원인들을 찾아내고 고치는 과정입니다. 여러분들이 코드를 살펴보고 오류를 찾아내서 고칠 때, 그러한 작업을 디버깅이라고 하는 것입니다.
      2:
        image: notes/C2_bee_debugging_2.png
        text: 작업 공간에 몇 개의 블록들이 놓여져 있습니다. 이제 단계 버튼을 눌러서, 블록들을 한 번에 한 단계씩 실행시키면서 코드가 제대로 동작하는지? 어디를 고쳐야하는 지 살펴볼 것입니다.
      3:
        image: notes/C2_bee_debugging_3.png
        text: 여기 해결해야할 문제가 있는 것 같네요! 앞으로 이동 블록이 1개 이상 필요한 것 같습니다. 단계 버튼을 사용하면, 오류를 찾아내는 디버깅 과정에 편리하게 사용하고 오류를 수정할 수 있게 해줍니다.
    C2_digital_footprint:
      1:
        image: notes/C2_digital_footprint_1.png
        text: 모자를 보관하기 위해서 머리를 사용할 수도 있지만, 머리로 생각하면, 지금 어디에 있는지? 생각하거나, 동물원에 대해서 생각하거나, 고개를 숙여 인사하는 등에 사용할 수 있습니다. 온라인에서 접속해 있을 때에는! 여러분의 마음 속에 품고 있는 생각들을 함부로 풀어놓지 마시고 어떻게 해야 자신이 안전할 지, 여러 분의 개인 사생활을 어떻게 보호해야 할 지를 머리로 생각하세요! 여러분의 머리부터 발끝까지, 잠깐 멈추고, 그런 것들을 생각하세요. 여러분의 발끝부터 코 위까지, 잠깐 멈춰서! 생각하세요. 온라인이라는 것을 생각하세요!
      2:
        image: notes/C2_digital_footprint_2.png
        text: |
          여러분의 마음이 점점 더 올바르게 커 갈 수 있게 해주세요. 좋은 마음을 가진 사람이 되세요. 다른 사람들에게 여러분들이 좋은 사람이 되도록 하세요! 여러분이 온라인에 접속해 있을 때, 어떤 것이 바른 것인지 생각하고, 항상 친절하고 착한 마음을 가지고, 여러분의 친구들을 존중해주고, 공정하고 멋지게 행동하세요.
          여러분의 머리부터 발끝까지, 그런 것들에 대해서 잠깐만! 생각해주세요. 여러분의 발끝부터 코까지, 잠깐만 온라인이라는 것을 생각해주세요!
      3:
        image: notes/C2_digital_footprint_3.png
        text: 여러분의 양팔을, 애완동물을 안아주기 위해서, 옷이 젖지 않게, 좋아하는 옷을 입기위해, 여러분이 날아오르게, 여러분에 대한 신뢰를 만들어 내도록 사용해주세요. 여러분의 양팔을 온라인에서도 사용해주세요. 잠깐 생각을 멈추고, 충분히 생각하고, 여러분의 능력을 나쁘게 과시하지 않고, 어떤 행동 이후에 벌어질 상황들에 대해서 생각해보세요.
      4:
        image: notes/C2_digital_footprint_4.png
        text: 여러분의 위장을, 음식을 먹고 소화시키는데 사용하고, 속에서 부글거리는 것을 참고, 충격을 흡수하는데 사용하고, 탄산 음료를 먹었을 때의 거북함을 참을 때도 사용한다는 것을 생각해보세요. 여러분의 넓은 마음을 온라인에서도 사용해주세요. 마음에 들지 않는 거북한 것들을 마주하게 되었을 때, 어떤 상황들을 어떻게 받아들이고, 어떻게 해야하는지 생각하기 위해서 사용해주세요. 머리부터 발끝까지, 잠깐만! 그것에 대해서 침착하게 생각해보세요. 발끝부터 코까지, 잠깐만! 온라인으로 접속해 있다는 것을 생각해주세요.
      5:
        image: notes/C2_digital_footprint_5.png
        text: 그리고, 온라인에 접속해 있을 때에는, 머리로 함께 생각하고, 마음으로 느껴보고, 넓은 마음으로 안아주고, 여러분의 감정에 대해서 조심해주세요. 여러분의 냄새나는 양말 속에 있는 다리를, 달리고 차고, 대나무 춤을 추기 위해서 통통 뛰고, 무대에서 춤추는데 사용해주세요. 여러분의 다리를 온라인에서도 사용해주세요. 지켜야 할 선을 넘는 사람들을 말리기 위해서, 꾿꾿하게 서있기 위해서, 크고 작은 생물들에게도 피해를 주지 않도록 다리를 사용해 주세요.
      6:
        image: notes/C2_digital_footprint_6.png
        text: 머리부터 발끝까지, 잠깐만! 생각해주세요. 발끝부터 코까지, 온라인이라는 것을 잠깐만 생각해주세요! 여러분의 머리, 마음, 양팔, 넓은 가슴, 다리 모두를 사용해 생각해주세요. 머리부터 발끝까지, 잠깐만! 생각해주세요. 발끈부터 코까지, 온라인이라는 것을 잠깐만 생각해주세요!
    C2_digital_footprint_v2:
      1:
        image: notes/C2_digital_footprint_v2_1.png
        text: |
          여러분들이 온라인에 접속할 때마다, 여러분들은 검색되고, 복사되고, 공유되고, 널리 퍼트려지고, 영원히 남을 수 있는, 디지털 흔적들을 남기게 됩니다.
          어떤 디지털 흔적들을 남기고 있는 것 일까요? 어떤 디지털 흔적들을 남기고 싶으신가요?
    C2_graph_paper:
      1:
        image: notes/C2_graph_paper_1.png
        text: '이번 레슨은 "모눈종이 프로그래밍" 이라고 부르는데, 알고리즘들에 대한 이야기라고 할 수 있습니다. 여기서는, 손으로 그려진 화살표들만 이용해서, 흑백이미지들을 만들어낼 수 있는 방법을 이해해보고, 그런 이미지들을 만들 수 있는 프로그램을 만드는 방법에 대해서 배울 것입니다.'
      2:
        image: notes/C2_graph_paper_2.png
        text: |
          알고리즘은 어떤 작업을 완료하기 위해 필요한 명령어들의 리스트입니다. 이런 명령어 리스트를 따라가며 그릇을 만들 것입니다.
          알고리즘들은 여러분들이 누군가에게 작업 방법을 이해시키려고 할 때 정말 도움이 됩니다.
      3:
        image: notes/C2_graph_paper_3.png
        text: 만약에 컴퓨터에 대한 알고리즘을 작성한다면 여러분은 아주 작은 단계가 되도록 쪼개나가야 합니다. 그래서 한 줄을 끝내고 다음 줄로 이동하고 그리고 나서 또 다음 줄로, 그러다 보면 끝날 것입니다.
      4:
        image: notes/C2_graph_paper_4.png
        text: 저는 제 작품들을 만들어내기 위해 알고리즘들을 사용합니다. 제가 작품을 만들기 위해 필요한 모든 단계들을 기록해 두면, 같은 조각을 쉽게 만들 수 있습니다. 물론, 다른 사람들에게 어떻게 만들 수 있는지 가르쳐줄 수도 있습니다. 유리 조각들을 가마에 넣고, 함께 녹여붙인 후, 유리 그릇을 만들어 내기 위해 필요한 나머지 단계들을 순서대로 따라갑니다. 알고리즘들은 어떤 작업을 수행하기 위해 필요한 순서와 방법을 알려주는 지도(로드맵) 입니다.
    C2_artist_loops:
      1:
        image: notes/C2_artist_loops_1.png
        text: 이제 화가를 프로그래밍 할 때 반복(횟수) 블록을 사용해서, 필요한 코드를 줄이도록 하겠습니다. 몇 개의 블록들을 빼 두었고, 실행시켜 보기만 하면 됩니다.
      2:
        image: notes/C2_artist_loops_2.png
        text: 사각형 전체를 그리기 위해서, 저 블록들을 반복 구조를 사용해서 4번 실행시키려고 합니다. 반복 블록 안에, 앞으로 이동 후 오른쪽으로 회전하도록 하는 블록을 넣어 두었습니다. 실행 시키면, 화가는 그 단계들을 4번 반복 시켜서 사각형을 그릴 것입니다.
    C2_bee_loops:
      1:
        image: notes/C2_bee_loops_1.png
        text: |
          반복 구조는 어떤 실행 내용을 반복하도록 하는 것입니다. 들어가서 조사하고, 구조를 살펴보고, 다시 나오는, 한 번의 과정을 여러 번 실행 시킬 수 있습니다.
          반복 구조 안에 넣으면, 똑같은 작업을 여러 번 실행할 수 있습니다.
      2:
        image: notes/C2_bee_loops_2.png
        text: |
          이것은 반복 블록 입니다. 이 블록 안에 반복 시킬 작업과 횟수를 넣을 수 있습니다.
          예를 들어, 이 퍼즐에서, 앞으로 이동한 후 꽃꿀을 얻는 작업을 일일이 3번씩 실행 시킬 필요없이, 반복 시킬 작업을 1번 만 넣으면 3번 반복하게 됩니다.
          아주 쉽게 할 수 있습니다!
    C2_maze_intro:
      1:
        image: notes/C2_maze_intro_1.png
        text: 일반적으로 프로그래밍은 텍스트로 작성을 하지만, 오늘 우리는 블러클리(Blockly) 를 사용할 것입니다. 블러클리는 프로그램을 작성하기 위해서 비주얼 블록들을 사용합니다. 하지만, 내부적으로는 코드를 작성하는 것입니다. 시작하면서, 앵그리 버드가 자기 알들을 훔쳐간 나쁜 돼지를 미로를 이동해서 잡을 수 있도록 코드를 작성할 것입니다.
      2:
        image: notes/C2_maze_intro_2.png
        text: 블러클리의 화면은 3개의 주 화면으로 분할되어있습니다. 왼쪽은 프로그램이 실행된 후 새가 움직일 미로입니다. 각 레벨을 위한 설명은 미로 아래에 작성되어있습니다. 가운데 영역은 도구 상자이고, 이 블록들은 새를 동작시킬 수 있는 명령어입니다. 오른쪽의 빈 공간은 프로그램을 만드는 작업 공간입니다.
      3:
        image: notes/C2_maze_intro_3.png
        text: '만약 제가 이동 블럭을 작업공간에 끌어다 놓고 "실행" 버튼을 누르면 어떻게 될까요? 새가 격자판에서 앞으로 한 박스만큼 움직일 것입니다. 그리고 새가 한 박스 이동한 다음 무엇을 하길 원한다면 어쩌지요? 저는 프로그램에 또 다른 블록을 추가할 수 있습니다.'
      4:
        image: notes/C2_maze_intro_4.png
        text: '저는 "오른쪽으로 이동" 블록을 선택할 것입니다. 그리고 노란 화살표가 보일 때까지 이동 블록 아래로 끌 것입니다. 그 다음에 놓으면 두 블록은 서로 달라붙을 것입니다. 제가 "실행" 버튼을 다시 눌렀을 때, 새는 여러분의 작업 공간에 쌓여 있는 명령들을 위에서 아래로 수행할 것입니다.'
      5:
        image: notes/C2_maze_intro_5.png
        text: 어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 휴지통으로 넣으면 됩니다. 실행시켰을 때에는 재실행 버튼을 눌러 새를 처음 위치로 돌려 놓을 수 있습니다. 이제 저 돼지들을 잡아보세요!
    C2_paper_airplanes:
      1:
        image: notes/C2_paper_airplanes_1.png
        text: 이번 레슨은 실생활 알고리즘이라고 불립니다. 알고리즘은 사람들이 매일 하는 일을 설명합니다. 쿠키 레시피와 새집 짓는 방법은 둘 다 일상의 알고리즘입니다.
      2:
        image: notes/C2_paper_airplanes_2.png
        text: 오늘 우리는 종이 비행기를 만드는 알고리즘을 만들고, 창작해 내고, 테스트할 것입니다. 하지만 우선 우리는 이 큰 프로젝트를 따라하기 쉬운 작은 단계로 나누어야 합니다. 우리가 종이 비행기를 만들기 위해서 어떤 단계들을 어떤 순서로 해야할지 결정해야 합니다.
      3:
        image: notes/C2_paper_airplanes_3.png
        text: '여러분들은 첫번째 잘라진 사진 조각을 이용하여 알고리즘을 만들 것입니다.그리고 난 뒤, 종이비행기를 만들기 위해 단계별로 필요한 6개의 사진 조각을 선택하고,  올바른 순서로 사진 조각을 배치할 것입니다.여러분들은 순서에 따른 모든 조각을 갖게 된 후 알고리즘이 잘 작동하는지 확인하기 위해 다른 학생 팀과 알고리즘을 맞바꿀 것입니다. 잘 설계된 알고리즘은 가장 훌륭한 종이 비행기를 만드는데 아주아주 중요합니다!'
      4:
        image: notes/C2_paper_airplanes_4.png
        text: 우리가 초콜렛을 만들고 싶을 때, 그 과정에는 여러 개의 큰 단계가 필요하다. 그리고 각각의 큰 단계는 또 다른 작은 단계들로 구성된다. 또한 그 과정에는 우리가 어떤 맛의 초콜렛을 만들기 원하느냐에 따라 다른 레시피나 알고리즘이 있다. 각각의 단계는 모두 중요하다. 작은 단계들도 마찬가지이다. 그래서 하나의 단계가 없다면 나머지 단계는 완성될 수 없다. 이해할 수 있는 알고리즘을 만드는 것은 정말로 중요하다. 그것이 누가 그것을 수행하든 문제없이 똑같은 결과가 나올 수 있도록 각각의 단계가 잘 기술되어야 하는 이유이다.
    C2_playlab_createastory:
      1:
        image: notes/C2_playlab_createastory_1.png
        text: 지금까지 여러분들은 애니메이션이나 이야기들을 만들어보았습니다. 그리고 여러분들이 실행시켜보는 다른 모든 것들과 똑같은 것이었습니다. 이제는 여러분들이 실제로 플레이할 수 있는 인터랙티브 게임을 만들 수 있습니다.
      2:
        image: notes/C2_playlab_createastory_2.png
        text: '"방향키" 블럭과 "움직이기" 블럭이 있습니다. 이 블럭들을 이용해서 방향키로 캐릭터들을 이리 저리 이동시킬 수 있습니다.'
    C2_relay_programming:
      1:
        image: notes/C2_relay_programming_1.png
        text: 오늘 우리는 프로그래밍 릴레이를 할 것입니다. 그것은 압축된 모든 프로그래밍 과정이고, 가끔 여러분이 팀 내에서 너무 빠르게 일을 하려고 할 때 발생할 수 있는 실수를 디버깅 하는 것입니다. 우리는 실제 코딩인 것처럼 하기 위해 모눈종이 프로그래밍을 사용할 것이고 마감시간을 갖는 것 처럼 릴레이 경주를 할 것입니다.
      2:
        image: notes/C2_relay_programming_2.png
        text: 릴레이 프로그래밍을 할 때, 팀들은 모눈종이 프로그램을 끝내기 위해 경주를 할 것이다. 여러분들은 팀원들이 하는 것을 체크하면서 실수를 고치고 오류를 수정해야 하며, 화살표를 추가하고 뒤로 움직이며 팀원들과 서로 연결해야 한다.
      3:
        image: notes/C2_relay_programming_3.png
        text: 프로그래머들은 알고리즘이나 코드에 있는 문제들을 발견하고 고치기 위해 많은 디버깅을 사용한다. 오류들을 수정하는 데에는 많은 방법들이 있다. 가장 쉬운 것 중 하나는 어디에 오류가 있고 무엇이 잘못되었는지 찾기 위해 천천히 단계별로 움직여 보는 것이다.
      4:
        image: notes/C2_relay_programming_4.png
        text: |
          여기서, 저는 백 핸드스프링을 연습하고 있는데, 계속 잘 안되었습니다. 그래서 각 단계마다, 한 단계씩 하면서, 어떤 실수를 했는지 알게 되었습니다. 코치님은 두 손을 정확하게 빔 위에 놓지 못했다고 이야기 해주셨습니다. 그래서 저는 두 손의 위치를 바꿔서 다른 백 핸드스프링을 연습했고, 해냈습니다! 진짜 기뻤습니다.  저는 저의 백 핸드스프링 방법을 디버깅한 것이라고 볼 수 있습니다.
          그렇습니다! 디버깅은 오류를 찾고 그 문제들을 고치는 것입니다. 좋아요, 잘했어요!
    C2_zuck_repeat_loop:
      1:
        image: notes/C2_zuck_repeat_loop_1.png
        text: 컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다.
      2:
        image: notes/C2_zuck_repeat_loop_2.png
        text: 예를 들어, 제가 페이스북을 사용하는 모든 사람들에게 생일 축하 이메일을 보내려고 했을 때, 실제 그 모든 사람들에게 각각 이메일을 쓰는 것은 100년 이상 걸릴 것입니다. 하지만, 몇 줄의 코드를 만들면 페이스북의 모든 사람들에게 생일 축하 이메일을 보내는 시스템을 만들어 가질 수 있게 됩니다. 그렇습니다. 그런 것들이 반복 구조들의 의미이며, 가치가 있는 이유이며, 컴퓨터들이 아주 잘 할 수 있는 것들 중 하나 입니다.
      3:
        image: notes/C2_zuck_repeat_loop_3.png
        text: '여러분의 목표는 새를 돼지에게 이동시키는 것입니다. 이제 쉽게 할 수 있도록 "반복(횟수)" 블록을 사용할 수 있도록 할 것입니다. 여러분들은 새가 돼지에게 한 번에 한 걸음씩 움직일 수 있도록, "앞으로 이동" 명령을 5번 컴퓨터에게 지시할 수 있습니다.'
      4:
        image: notes/C2_zuck_repeat_loop_4.png
        text: '그렇지 않으면, 컴퓨터에게 "앞으로 이동" 명령을 한 번 알려준 후에, 그것을 5 번 "반복" 하도록 해서 같은 작업을 할 수 있습니다. 이렇게 하기 위해서 "앞으로 이동" 명령을 드래그 해서, "반복" 블록 안에 넣어주세요. 그 다음에 반복 해야하는 횟수를 알려준 후에 실행시켜보면 됩니다.'
      5:
        image: notes/C2_zuck_repeat_loop_5.png
        text: '한 가지 더 이야기해 드릴 것은, 원하는 만큼의 명령어들을 "반복" 블록 안에 넣을 수 있다는 것입니다. 이 퍼즐에서는 앞으로 이동하고 왼쪽으로 회전하도록 하는데, 그렇게 하면 5번 반복될 것입니다. 자 이제 재미있게 시도해보세요!'
    C3_artist_functions:
      1:
        image: notes/C3_artist_functions_1.png
        text: 컴퓨터 프로그래밍에서 더 멋진 것은, 일단 컴퓨터가 해야할 작업을 컴퓨터에게 가르쳐 놓으면, 함수로 다시 불러 실행시킬 수 있다는 것입니다. 원하는 작업들을 하나로 묶어 이름을 붙여두면, 다시 불러 실행시킬 수 있습니다. 이것은 마치 사용 가능한 언어들을 확장시키는 것과 거의 같습니다.
      2:
        image: notes/C3_artist_functions_2.png
        text: '우리가 만든 프로그램에서, 이동하고 회전하는 작업을 4번 반복함으로써 1개의 사각형을 그릴 수 있다는 것을 배웠습니다. 그러한 작업을 함수로 만들어, 사각형 그리기라고 이름을 붙여두면, 원할 때마다 불러 사용할 수 있습니다. 불러서 사용할 때에는 "사각형 그리기"라고 말하면, 그 함수를 호출하고 그렇게 이름 붙여둔 한 묶음의 코드를 실행하게 될 것입니다. 이제 가능하게 되었네요. 우리가 사용하는 프로그래밍 언어에 그런 함수 개념을 추가했습니다.'
    C3_artist_intro:
      1:
        image: notes/C3_artist_intro_1.png
        text: 컴퓨터과학(정보과학) 에 대한 전문가가 없다면, 자동차 레이스에서 예선도 통과하지 못 할 수 있습니다. 왜냐하면, 어떻게 해야 자동차 경주에서 효과적일지 알아내기 위해서 컴퓨터 프로그램을 만들어야 하는데, 그러기 위해서 자동차의 수많은 데이터들을 계속해서 수집하고, 그러한 데이터를 이용해서 필요한 정보를 만들어내는 프로그램을 만들어내는 사람이 있어야 하기 때문입니다.
      2:
        image: notes/C3_artist_intro_2.png
        text: 이번 퍼즐들에서는, 연필을 이용해 여러 가지 도형을 그리는 화가가 될 것입니다. 화가가 이동하면 그 뒤에 선이 그려질 것입니다.
      3:
        image: notes/C3_artist_intro_3.png
        text: 캔버스를 돌아다니기 위해서 앞으로 이동 블록을 사용할 수 있습니다. 여기있는 앞으로 이동 블록은 100 픽셀씩 앞으로 가도록 하고 있습니다. 실행시키면 어떤 일이 일어날까요? 여러분의 예술가가 정확히 100 픽셀만큼 앞으로 이동합니다. 픽셀은 기본적으로 여러분 컴퓨터 화면 위의 아주 작은 사각형입니다.
      4:
        image: notes/C3_artist_intro_4.png
        text: 이 퍼즐에서 우리가 가진 또 다른 블록은 오른쪽으로 90 회전하는 블록입니다. 그리고 우리가 그 블록을 끌어낼 때 우리의 예술가가 정해진만큼 회전합니다. 그래서 여러분은 예술가가 얼마나 회전하길 원하는지를 가지고 놀 수 있습니다. 이것이 90도 회전입니다.
      5:
        image: notes/C3_artist_intro_5.png
        text: 그리고 이것은 120 도 회전입니다. 여러분들은 픽셀이나 각도를 지정하기 위해 수 옆에 있는 화살표들을 클릭해서 이런 값들을 바꿀 수 있습니다. 여러분의 화가로 마음 껏 그려보세요!
    C3_artist_nested_loops:
      1:
        image: notes/C3_artist_nested_loops_1.png
        text: 어떤 반복 구조 안에 다른 반복 구조를 넣은 것을 중첩 반복 이라고 합니다. 예를 들어, 한 변의 길이가 100 픽셀인 삼각형 1개를 반복 구조를 이용해 그리는 코드에는, 길이가 100 픽셀인 선을 3번 반복해서 삼각형의 한 변을 한 번에 하나씩 그립니다.
      2:
        image: notes/C3_artist_nested_loops_2.png
        text: 하지만 만약, 6개의 삼각형들을 그리려고 한다면. 그렇게 하기 위해서 다른 반복(횟수) 블록 안에 넣고 실행시키면 됩니다. 꽤 멋지죠!
    C3_bee_conditionals:
      1:
        image: notes/C3_bee_conditionals_1.png
        text: 이것은 조건부 블록입니다. IF는 꽃꿀이나 꿀의 양이 어떤 숫자보다 더 적은지, 같은지 또는 더 많은지를 말해주고, THEN은 무언가를 실행합니다.
      2:
        image: notes/C3_bee_conditionals_2.png
        text: 이것은 여기 물음표가 함께 보이는 것처럼 우리가 얻어야 꽃꿀이나 꿀이 얼마나 많은지 모를 때 유용합니다.
      3:
        image: notes/C3_bee_conditionals_3.png
        text: 이 예제에서 우리는 자주색 꽃이 0보다 많은 꽃꿀을 가지고 있다면 꽃꿀을 얻으라고 말할거예요. 그것은 꽃꿀이 있는 한 계속 얻도록 하는 것입니다. 기대하시라!
    C3_debugging_bee:
      1:
        image: notes/C3_debugging_bee_1.png
        text: 디버그/디버깅이라는 말을 들어본 적이 있나요? 디버깅은 프로그램이 제대로 동작하지 않는 원인들을 찾아내고 고치는 과정입니다. 여러분들이 코드를 살펴보고 오류를 찾아내서 고칠 때, 그러한 작업을 디버깅이라고 하는 것입니다.
      2:
        image: notes/C3_debugging_bee_2.png
        text: 작업 공간에 몇 개의 블록들이 놓여져 있습니다. 이제 단계 버튼을 눌러서, 블록들을 한 번에 한 단계씩 실행시키면서 코드가 제대로 동작하는지? 어디를 고쳐야하는 지 살펴볼 것입니다.
      3:
        image: notes/C3_debugging_bee_3.png
        text: 여기 해결해야할 문제가 있는 것 같네요! 앞으로 이동 블록이 1개 이상 필요한 것 같습니다. 단계 버튼을 사용하면, 오류를 찾아내는 디버깅 과정에 편리하게 사용하고 오류를 수정할 수 있게 해줍니다.
    C3_bee_functions:
      1:
        image: notes/C3_bee_functions_1.png
        text: 컴퓨터과학(정보과학) 에서 가장 중요한 개념들 중 하나는 새로운 명령어들을 정의하는 방법으로, 여러분이 만든것을 새로운 명령으로 추가하는 것입니다. 대부분의 컴퓨터 프로그래밍 언어들은 기껏해야 100 개 정도의 단어나 명령어에 대한 것들입니다. 컴퓨터 프로그래밍 언어의 예술과 마술은, 이러한 블록들과 같은 새로운 단어들을 정의하는 것입니다.
      2:
        image: notes/C3_bee_functions_2.png
        text: 이러한 정의는 스포츠게임에서 항상 하는 일들입니다. 예를 들어 농구를 배우기 위해서 처음에는 드리블, 레이업, 리바운드 방법을 배우면서 시작합니다. 이러한 기초적인 동작들을 배우고 나면, 픽엔롤이나 기브엔고와 같은 새로운 동작들을 배운 후, 이런 블록들에 함께 넣을 수 있습니다. 그 다음에는 그런 것들을 이용해서 더 복잡한 플레이 방법들을 수행할 수 있게 됩니다. 그렇게 새로운 방법들을 배우고 이름을 붙이면, 팀원 모두가 어떻게 하는지 이해할 수 있는 것입니다.
      3:
        image: notes/C3_bee_functions_3.png
        text: 비슷하게, 이런 명령어들을 이용해서 컴퓨터가 수행해야 할 동작들을 컴퓨터에게 가르쳐두면 됩니다. 그러한 동작들에 원하는 이름을 붙여두면 나중에 쉽게 반복시킬 수 있게 됩니다. 이렇게 필요한 명령들을 모아 자신이 원하는 이름으로 정의해 둔 것을 함수라고 합니다. 이제 우리는 꿀벌을 도와주기 위해서 함수들을 사용하게 될 것입니다.
      4:
        image: notes/C3_bee_functions_4.png
        text: '이 예제에서 여기에 있는 이 녹색 함수의 이름은 "꽃꿀 2번 얻기" 입니다. 이 회색 상자의 작업 내용은 꽃꿀을 2번 얻는 것이라는 것을 알 수 있는데, 이것이 바로 함수 정의입니다. 그 안을 살펴보면, 꽃꿀 2번 얻기는 꽃꿀을 2번 반복해서 뽑아내는 내용입니다. 회색 상자 안에 어떤 것들이 들어있는지 항상 잘 살펴보면, 이 녹색 함수 블록들로 무엇을 할 수 있는지 알게 될 것입니다.'
    C3_bee_nested_loops:
      1:
        image: notes/C3_bee_nested_loops_1.png
        text: 이제 우리는 꿀벌과 함께 중첩 루프를 사용할 것입니다. 꿀벌이 앞으로 이동하여 꽃꿀을 세 번 뽑고 그 다음 오른쪽으로 회전하는 시작 코드가 주어졌습니다. 코드 조각 전체를 가져와서 반복 블록 안에 포함시키고 이를 세 번 반복하도록 설정해 봅시다. 좋아요!
    C3_bounce:
      1:
        image: notes/C3_bounce_1.png
        text: 여러분만의 바운스 볼 게임을 만들어 보고 친구들과 함께 할 것입니다. 얼마나 멋져요!
      2:
        image: notes/C3_bounce_2.png
        text: 시작하려면 키보드 방향키와 제어 패들을 연결하여야 합니다.
      3:
        image: notes/C3_bounce_3.png
        text: 이런 연결을 통하여 우리는 왼쪽으로 이동 불록을 사용하고 싶을 때 왼쪽 방향키를 사용하고 오른쪽으로 이동 블록을 사용하고 싶을 땐 오른쪽 방향키를 사용할 수 있습니다. 한 번 해보세요. 금방 여러분만의 바운스 게임 프로그래밍을 할 수 있을 것입니다.
    C3_computational_thinking:
      1:
        image: notes/C3_computational_thinking_1.png
        text: 이번 레슨은 컴퓨팅 사고력입니다. 가끔은 새로운 게임을 배우는 것이 어려울 수 있습니다. 맞죠? 우선 아주 혼란스럽게 보이기도 하고 때때로 여러분에게 게임 룰을 가르쳐 주는 사람이 없기도 합니다. 그러면 여러분 스스로 생각해 내야 합니다.
      2:
        image: notes/C3_computational_thinking_2.png
        text: 좋은 소식은 여러분이 약간의 생각하는 요령을 알고 있다면 스스로 알아내는 것을 더 잘 할 수 있게 된다는 것입니다. 이 요령들은 문제를 찾고 해결하는 유일한 방법입니다. 이 레슨에서 여러분은 네 가지의 요령을 배울 것이고 여러분 친구들과 함께 게임의 룰을 생각해 내는 것으로써 훈련할 것입니다.
      3:
        image: notes/C3_computational_thinking_3.png
        text: 커다란 문제를 좀 더 작은 조각으로 분할하기 위해 여러분은 여러분의 두뇌를 이용할 것입니다. 한 번은 커다란 문제를 몇 개의 더 작은 문제글로 나누었고, 패턴 매치라고 불리는 다음 요령으로 넘어갈 수 있습니다.
      4:
        image: notes/C3_computational_thinking_4.png
        text: 그것은 바로 사물들 사이의 유사점을 찾을 때입니다. 유사한 점을 찾고 나서, 어떤 점들이 서로 다른지 알아낼 수 있습니다. 그러한 차이점들을 제거했을 때 그것을 추상화라고 합니다.
      5:
        image: notes/C3_computational_thinking_5.png
        text: 어떤 문제를 해결할 수 있는 단계들을 생각해 낸 후에, 그 단계들을 알고리즘이라고 하는 어떤 특별한 순서에 따라 그 단계들을 나타낼 수 있습니다. 그렇게하면 누구나 문제를 풀기 위해 그 방법을 사용할 수 있습니다. 우리는 규칙이 없는 게임을 플레이하는 방법을 알아내기 위해서 4 단계를 사용할 것입니다. 이 게임의 마지막에 여러분들은 이런 것과 같은 것을 할 수 있게 될 것입니다.
    C3_crowdsourcing:
      1:
        image: notes/C3_crowdsourcing_1.png
        text: 이 레슨은 크라우드소싱이라고 불립니다. 이 레슨에서는 모두들 혼자서 일을 하려고 하는 대신에 그룹을 지어 할 수 있는 일들이 얼마나 더 많이 쉬운지에 관해 배우는 한 벌의 카드를 이용할 것입니다. 몇 친구들을 붙잡고 무언가를 아주 멋지게 만들어 보세요. 크라우드소싱은 어떤 일을 더 빨리 해결하기 위해 많은 사람들 집단으로부터 도움을 얻는 것입니다.
      2:
        image: notes/C3_crowdsourcing_2.png
        text: 컴퓨터과학에서 우리는 언제나 크라우드소싱을 이용합니다. 수천명의 아마추어와 전문가들은 엄청나게 많은 정보 조각들을 철저하게 조사하기 위해 그들의 컴퓨터를 서로 연결하였습니다. 다음 번 메르센 소수 같은 것이나 심지어는 가능한 외계인 통신을 찾고 있습니다.
      3:
        image: notes/C3_crowdsourcing_3.png
        text: 여러분이 영화를 볼 때, 영화는 초당 24개의 독립적인 사진들로 이루어지며 이를 프레임이라고 부릅니다. 그러한 사진들 모두는 만들어지고 렌더링되고 함께 놓여져야 합니다. 저의 팀과 저는 모두 소프트웨어 개발자입니다. 우리는 실제적으로 이미지를 만들고, 여러분이 화면에서 보는 최종 이미지를 만들어주는 소프트웨어 제작 일을 모두 함께 하고 있습니다. 그것은 예술가와 개발자들이 협동작업을 할 때 사용되고, 그들이 화면에 나오길 원하는 이미지를 만들어내는 과정에서 사용될 수 있는 도구입니다.
      4:
        image: notes/C3_crowdsourcing_4.png
        text: 예를 들어, 니모를 찾아서라는 영화에서, 크러쉬, 스쿼트, 친구들은 동 호주 해류를 통해 물속을 날아다닙니다. 여러분들은 거북이 등의 색들을 통해서, 물고기의 옆 모습을 통해서, 물속을 날아다니는 것과 같은 이미지들을 보게됩니다. 그런 모든 것들은 우리가 만들어낸 수학식과 프로그램들을 통해서 만들어진 것들입니다. 그렇게 만들어 낸 결과물들을 영상 예술가들에게 보내 최종 결과물을 만들고, 색감을 조정하고, 아름답게 보이거나 재미있게 보이도록 합니다.
    C3_dice_race:
      1:
        image: notes/C3_dice_race_1.png
        text: 이 레슨은 주사위 경주라고 합니다. 거의 모든 사람들은 컴퓨터 게임을 하는 것을 좋아합니다. 여러분은 컴퓨터 프로그래머가 어떻게 게임의 단계를 프로그램으로 바꾸는지 생각해 본 적이 있나요? 컴퓨터 게임을 창작하고 어떤 문제를 해결하는 첫 번째 단계에서는 생각하고 계획하는 것이 필요합니다.
      2:
        image: notes/C3_dice_race_2.png
        text: 문제 해결 단계에 대해 생각하는 것은 문제를 해결하거나 작업을 완수하기 위한 단계별 계획인 알고리즘을 생산해냅니다. 이번 레슨에서 여러분은 주사위 경주에 대한 알고리즘을 작성할 것입니다. 그리고나서 여러분의 친구들에게 요청하여 친구들이 게임을 하기 위한 단계를 따라할 수 있는지 볼 것입니다. 프로그래머가 그 단계들이 올바르다고 확신한 이후, 컴퓨터가 이해할 수 있는 언어를 가지고 일고리즘을 프로그램으로 변환합니다.
      3:
        image: notes/C3_dice_race_3.png
        text: 우리가 매일 매일 하는 거의 모든 일들에는, 일을 마치기 위해서 따라야하는 단계들의 집합인 알고리즘이 필요합니다. 친구들과 함께 학교를 가려고 하거나, 함께 놀 계획을 세우거나, 간단한 식사를 만들거나 할 때를 생각해보세요. 그러한 일들을 수행하기 위해서는, 보다 작은 단계들로 나누어야 하고, 그러한 단계들을 완료하기 위해서 어떤 기준에 따른 작업 순서가 필요하기도 합니다.
      4:
        image: notes/C3_dice_race_4.png
        text: 샌드위치 만드는 것을 생각해보세요. 어떤 샌드위치를 만드는 지는 중요하지 않습니다. 하지만, 땅콩버터 뚜껑을 열지 않고 땅콩버터를 바를 수 없습니다. 우리가 아무런 생각없이도 할 수 있는 아주 간단한 것이라고 하더라도, 어떻게 작업을 해야하는지 알려주는 알고리즘들이나 프로그램들을 컴퓨터들은 필요로 합니다.
      5:
        image: notes/C3_dice_race_5.png
        text: 알고리즘은 어떤 일을 하기 위해 필요한 생각이라고 할 수 있는데, 프로그램은 컴퓨터에게 작업을 시키기 위해서 필요한 실제적인 명령어들이라고 할 수 있습니다. 알고리즘은 프로그램으로 변환되어야만 컴퓨터가 실행할 수 있게 됩니다. 어떤 작업을 알고리즘이라는 단계들로 자세히 나누는 것은 때때로 어렵습니다. 하지만, 다른 것들과 마찬가지로 연습하면 할 수록 더 쉽게 됩니다.
    C3_farmer_while:
      1:
        image: notes/C3_farmer_while_1.png
        text: 반복 구조들은, 일상생활에서 어떤 일들을 반복하는 것과 매우 비슷합니다. 자동차를 세차할 때를 예로 들자면, 깨끗하게 될 때까지 자동차를 닦을 것입니다. 깨끗하지 않다면, 계속 닦을 것입니다. 이렇게 어떤 상태를 판단하는 것을 항상 하고 있는 것입니다.
      2:
        image: notes/C3_farmer_while_2.png
        text: 농부를 도와줄 수 있는 새로운 블록이 있습니다. 반복 블록이라고 부릅니다. 반복 블록은 매우 간단합니다. 가장 윗쪽의 조건문이 참이면, 입력 되어있는 작업을 합니다. 예를 들어, 흙더미가 있는 동안 치울 수 있습니다. 농부로 시도해보세요.
    C3_functional_suncatchers:
      1:
        image: notes/C3_functional_suncatchers_1.png
        text: 이번 레슨은 햇빛가리개 입니다. 이런 이쁜 햇빛가리개들을 함수들을 이용해 만들 수 있습니다. 이런 햇빛가리개를 1개 만들어 내기 위해서는 여러 개의 단계가 필요합니다. 그 중 한 단계는 여러 번 실행시키는 것입니다.
      2:
        image: notes/C3_functional_suncatchers_2.png
        text: 선캐처를 만드는 과정을 단순화하는 첫 번째 단계는 계속해서 반복해야만 하는 것이 무엇인지 생각해 내는 것입니다. 우리는 이러한 단계들을 함수라고 부르는 것으로 그룹화할 수 있습니다.
      3:
        image: notes/C3_functional_suncatchers_3.png
        text: 하지만, 멋진 햇빛가리개를 만들기 위해서는, 정확한 단계들을 따라가는 것에 무언가가 더 필요합니다. 창의적으로 구슬들의 색을 바꿔 볼 수도 있습니다. 서로 다른 구슬 색으로, 서로 다른 햇빛가리개를 만들 수 있습니다.
      4:
        image: notes/C3_functional_suncatchers_4.png
        text: 변화될 수 있는 변수 단어로서 구슬들을 생각하게 되면, 세상에 하나 뿐인 햇빛가리개가 될 수 있습니다. 함수와 변수를 사용해 멋진 햇빛가리개를 만들며 즐겨보세요!
    C3_internet:
      1:
        image: notes/C3_internet_1.png
        text: 이번 레슨은 인터넷에 대한 것입니다. 인터넷은 매우 바쁜 공간으로, 이런 바쁜 도로와 비슷합니다. 크게 확대되어 보이는 자동차들과 같은 메시지들은 목적지를 향해 이동합니다. 메시지들은 인터넷을 통해 매우 빠르게 이동합니다.
      2:
        image: notes/C3_internet_2.png
        text: 인터넷이 어떻게 동작하는지 살펴봄으로서, 인터넷에 접속해 있을 때 어떤 일들이 일어나는지 이해하는데 도움이 될 것입니다. 여러분들은 메시지들이 여러분들의 컴퓨터에서 입력되어서 웹사이트에 전송되거나, 친구로부터 이메일 박스에 전송되는 것에 대해서 배우게 될 것입니다. 도로들을 알고 표지판들을 읽을 수 있을 때 도로들을 이동해 다니는 것이 쉬운 것처럼, 인터넷 내부적으로 일어나는 일들을 이해하면 그렇게 복잡하지는 않습니다.
      3:
        image: notes/C3_internet_3.png
        text: 인터넷을 통해 메시지를 보내는 것은, 우체국을 통해서 편지를 보내는 것과 아주 조금 다를 뿐입니다. 저는 Google.com 에 접속해 있습니다. 이 웹사이트의 IP 주소는 이 숫자들입니다. IP 주소는 편지를 주고 받을 때 사용하는 주소라고 생각하면 됩니다. 자, 우체국에서 편지에 메시지를 작성해 넣은 후, 저곳으로 보낸다고 생각해 봅시다. 문 앞에 URL 과 IP 주소가 보이나요? 저는 이 메시지를 작성해서 보내기를 누릅니다.
      4:
        image: notes/C3_internet_4.png
        text: 현실의 우체국 우편 서비스와 다른 것은, 인터넷은 메시지를 보다 작은 단위의 조각들로 나누어서 더 쉽게 보낸다는 것입니다. 작게 나누어진 조각을 패킷이라고 부릅니다. 메시지가 나뉘어진 각 패킷들은 한 번에 하나씩 목적지로 발송됩니다. 이런 패킷들은 나중에 순서에 맞춰 순서대로 정확하게 조립되기 때문에, 받는 사람들은 받은 메시지를 똑같이 읽을 수 있습니다. 물론, 인터넷이 어떻게 움직이는지 이해하기 위해서는 더 많이 배워야 하지만, 지금 이야기한 메시지 전달이 가장 기본적입니다. 여러분들은 똑똑한 인터넷 사용자가 되는 길에 올라와 있습니다! 여러분의 가족과 친구들에게, 여러분들이 배운 것들에 대해서 꼭 이야기해주세요!
      5:
        image: notes/C3_internet_5.png
        text: 저는 아만다 캠프이고, 저는 구글에서 소프트웨어 엔지니어로 일하고 있습니다. 저는 어떤 팀에서 함께 일을 하고 있는데, 사람들의 프로필과 연락처들을 저장하는 백엔드서버와 관련된 일들을 합니다. 우리 팀이 일을 할 때, 어떻게하면 연락처들을 스마트폰과 같은 다른 장비들에 전달시킬지에 대해서 많은 생각들을 해야합니다. 여러분들도 그렇다시피 사람들은 매우 많은 연락처를 가지고 있는데, 1000 개의 연락처가 있을 때, 1000 개의 연락처를 한 번에 모두 스마트폰에 메시지로 전달하려고 하지 않습니다. 왜냐하면 그렇게 되면 메시지의 용량이 너무 커지기 때문입니다. 인터넷에서도 비슷하게, 큰 메시지를 보다 조그만 패킷 조각으로 나누는데, 페이징이라는 개념을 이용해서 100 개의 연락처 단위로 나누어 하나를 전달합니다. 그렇게 하면, 스마트폰에서 보내진 연락처를 확인을 하거나 다음 100 개를 요청하게 됩니다.
      6:
        image: notes/C3_internet_6.png
        text: 소프트웨어의 가장 멋진 점은, 전 세계에 영향을 미칠 수 있다는 것입니다. 저는 19살 때, 처음 프로그래밍을 배웠습니다. 아마 고등학교 2학년이나 대학교 1학년 때 인 것 같습니다. 기억 나는 프로그램 중에서 하나는 섭씨 온도를 화씨 온도로 바꾸는 것 이었습니다. 저는 사람들을 돕는 것을 좋아하기 때문에 프로그래밍이 좋습니다. 저는 전세계 사람들을 돕는 프로그램을 구글에서 만들 수 있고, 그건 정말 짜릿하고 재미있는 일입니다.
    C3_maze_conditionals:
      1:
        image: notes/C3_maze_conditionals_1.png
        text: 사람들은 매일 매일 결정을 내립니다. 예를 들어, 여러분들은 밖에 나가기 전에, 비가 올 지, 안 올지? 조건을 확인하고, 선택을 한 후 재킷을 가지고 나갈 지 말 지를 선택을 합니다. 일단 여러분이 그런 조건/선택문을 결정 해주면, 컴퓨터들은 믿기 어려운 속도/빠르기로 정확하게, 조건/선택에 따른 작업들을 멋지게 수행합니다. 하나의 컴퓨터 프로그램은 실제로, 수학적 계산 조금과, 조건/선택문들에 의해서 만들어지는 것이라고도 생각할 수 있습니다.
      2:
        image: notes/C3_maze_conditionals_2.png
        text: 만약 블록은 좀비가 조건에 따라 선택할 수 있게 해줍니다. 어떤 상태를 확인할 수 있게 해줍니다. 예를 들어 만약 블록을 사용하면, 왼쪽에 길이 있을 때, 왼쪽으로 회전하도록 하는 명령어를 그 안에 넣을 수 있습니다. 그렇게 좀비 주변에 대해서 검사할 수 있도록 해서, 왼쪽에 길이 있을 때 회전하도록 하는 것입니다.
      3:
        image: notes/C3_maze_conditionals_3.png
        text: 그 다음에, 앞으로 이동 블록을 반복 블록 안에 넣어서 계속 앞으로 이동하도록 할 수 있습니다. 그리고 나서, 만약 블록은 왼쪽으로 회전할 수 있을 때를 알려줄 수 있게 합니다. 그렇게, 만약 블록을 사용해서 왼쪽에 길이 있을 때 왼쪽으로 회전도록 하고, 왼쪽에 길이 없으면 계속 앞으로 이동할 수 있도록 하면 목표를 달성할 수 있게 됩니다.
      4:
        image: notes/C3_maze_conditionals_4.png
        text: 이것은 컴퓨터 프로그래밍의 기초적인 개념인 조건/선택문을 사용하는 예시입니다. 제가 처음 배웠던 것 중 하나는, 틱택토 게임을 하는 프로그램이었습니다. 그 프로그램에서 저는 상대방이 이길 수 있는 때를 알려줄 수 있는 조건/선택문을 사용해서, 그 지점을 막을 수 있도록 해야했습니다. 조건/선택문을 사용하는 방법을 재미있게 배워보세요. 조건/선택문은 핵심 개념입니다.
    C3_maze_level_4:
      1:
        image: notes/C3_maze_level_4_1.png
        text: 이번 예제에서의 목표는 좀비를 해바라기로 보내는 것입니다. 앞으로 이동 블록을 5번 사용하거나, 1개의 반복 블록을 이용해서 앞으로 이동을 5번 반복하도록 할 수 있습니다.
      2:
        image: notes/C3_maze_level_4_2.png
        text: 그렇게 하면 시간도 아끼고 더 쉽게 할 수 있습니다. 반복 시키려면, 앞으로 이동 블록을 반복 블록 안에 넣으면 됩니다. 실행시키면, 좀비가 5번 앞으로 이동해서 해바라기로 갈 것입니다.
    C3_playlab_create_game:
      1:
        image: notes/C3_playlab_create_game_1.png
        text: 지금까지 여러분들은 애니메이션이나 이야기들을 만들어보았습니다. 그리고 여러분들이 실행시켜보는 다른 모든 것들과 똑같은 것이었습니다. 이제는 여러분들이 실제로 플레이할 수 있는 인터랙티브 게임을 만들 수 있습니다.
      2:
        image: notes/C3_playlab_create_game_2.png
        text: '"방향키" 블럭과 "움직이기" 블럭이 있습니다. 이 블럭들을 이용해서 방향키로 캐릭터들을 이리 저리 이동시킬 수 있습니다.'
    C3_songwriting_with_parameters:
      1:
        image: notes/C3_songwriting_with_parameters_1.png
        text: 이번에는 작곡 레슨입니다. 음악은 컴퓨터 프로그램과 아주 많이 비슷합니다. 악보에 쓰여있는 음표와 가사는 가수가 어떻게 노래를 불러야 하는지를 정확하게 이야기해줍니다. 음악 악보에서 어떤 부분들은 계속 반복적으로 사용되기도 하고요.
      2:
        image: notes/C3_songwriting_with_parameters_2.png
        text: 그런 부분을 후렴이라고 합니다. 컴퓨터 프로그램에 있어서도, 반복적으로 사용되는 부분들을 함수들로 만들어 사용할 수 있습니다. 노래 가사를 읽을 때, 후렴이라고 쓰여 있으면 후렴이라고 말하고 끝내지는 않죠? 노래가 적혀있는 페이지의 가장 윗 부분에 보면, 어떤 부분이 반복해서 불러야 하는 후렴인지 알 수 있게 쓰여 있기 때문입니다.
      3:
        image: notes/C3_songwriting_with_parameters_3.png
        text: 여러분은 이번 레슨에서, 작은 토끼 후 후 라는 간단한 노래를 배울 것입니다. 그 노래에는 반복적으로 불러야 하는 후렴 부분이 있습니다. 함수는 한 번 정의한 후, 반복적으로 불러 쓸 수 있는 코드 조각이라고 생각할 수 있습니다. 함수를 사용하면 반복시킬 작업을 모두 일일이 작성하지 않아도 되기 때문에, 쉽고 효율적으로 프로그래밍이 가능하게 해줍니다. 한 번만 작성해두면 되는 것이죠!
    C4_bee_conditional:
      1:
        image: notes/C4_bee_conditional_1.png
        text: 이것은 조건/선택 블록입니다. 꽃이나 벌집에 있을 때에 따라 작업을 시켜줍니다. 이렇게 물음표가 표시되어서 꿀이나 꽃꿀의 양이 얼마인지 몰라도, 조건/선택을 사용하면 편리합니다.
      2:
        image: notes/C4_bee_conditional_2.png
        text: 이 예제에서는 꽃이면 모든 꽃꿀을 뽑고, 그렇지 않고 벌집이면 꿀을 만들도록 할 것입니다. 짜잔!
    C4_conditionals:
      1:
        image: notes/C4_conditionals_1.png
        text: 만약/아니면 이라는 새로운 블록이 생겼습니다. 이전 퍼즐들에서 사용했던 조건 블록과 비슷합니만 아래에 아니면 이라는 부분이 더 있습니다. 만약/아니면 블록은 2가지 선택 중에서 1가지를 실행시킬 수 있게 합니다. 꿀벌이 꽃 위에 있으면, 첫번째 부분에 넣은 작업들을 할 것입니다. 그렇지않다면, 꿀벌은 아니면 부분에 들어있는 작업들을 실행할 것입니다.
      2:
        image: notes/C4_conditionals_2.png
        text: 조건/선택문은 컴퓨터들이 결정을 내릴 수 있게하는 방법입니다. 어떤 상황에서 조건에 따른 작업을 설정해 두면, 컴퓨터들은 그 상황에서 설정해 조건에 따라 다른 작업들을 실행할 수 있게 됩니다. 주어진 만약/아니면 블록의 가장 위에는 꽃이 있는지에 대한 판단 조건이 있습니다. 하지만, 꽃꿀의 개수가 2인지, 길이 앞에 있는지와 같은 다른 조건을 사용할 수도 있는데 그 조건을 확인한 결과에 따라 같은 방법으로 동작하도록 할 수 있습니다. 즉, 조건/선택문의 가장 윗쪽에 있는 조건을 판단한 결과가 참이면 그 아래 첫번째 구역에 있는 동작들을 실행하고, 참이 아니면 그 아래의 두번째 구역에 있는 동작들을 실행하는 것입니다.
    C4_for_loops:
      1:
        image: notes/C4_for_loops_1.png
        text: 코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다.
      2:
        image: notes/C4_for_loops_2.png
        text: 예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다.
      3:
        image: notes/C4_for_loops_3.png
        text: "일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다. 예를 들어, 꽃꿀이 1 만큼씩 들어있는 꽃들이 한 줄 있고, 그 다음 줄에는 꽃꿀이 2만큼씩, 그 다음에는 3만큼씩 들어있는 꽃들이 있다고 한다면, 첫 줄에서 1, 두 번째 줄에서 2, 세번째 줄에서 3으로 증가하는 '카운터' 를 이용해서 꿀벌이 꽃꿀을 모으도록 할 수 있습니다."
      4:
        image: notes/C4_for_loops_4.png
        text: for 반복을 이용하면, 카운터 증가 값으로 1 이상의 값을 사용할 수 있습니다. 2 만큼 씩, 4 만큼 씩 등, 한번 작업을 실행한 후에 원하는 값 만큼씩 카운트의 값이 증가 하도록 할 수 있습니다.
    C4_for_loops_bee:
      1:
        image: notes/C4_for_loops_bee_1.png
        text: 코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다.
      2:
        image: notes/C4_for_loops_bee_2.png
        text: 예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다.
      3:
        image: notes/C4_for_loops_bee_3.png
        text: "일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다. 예를 들어, 꽃꿀이 1 만큼씩 들어있는 꽃들이 한 줄 있고, 그 다음 줄에는 꽃꿀이 2만큼씩, 그 다음에는 3만큼씩 들어있는 꽃들이 있다고 한다면, 첫 줄에서 1, 두 번째 줄에서 2, 세번째 줄에서 3으로 증가하는 '카운터' 를 이용해서 꿀벌이 꽃꿀을 모으도록 할 수 있습니다."
      4:
        image: notes/C4_for_loops_bee_4.png
        text: for 반복을 이용하면, 카운터 증가 값으로 1 이상의 값을 사용할 수 있습니다. 2 만큼 씩, 4 만큼 씩 등, 한번 작업을 실행한 후에 원하는 값 만큼씩 카운트의 값이 증가 하도록 할 수 있습니다.
    C4_for_loops_no_bee:
      1:
        image: notes/C4_for_loops_no_bee_1.png
        text: 코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다.
      2:
        image: notes/C4_for_loops_no_bee_2.png
        text: 예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다. 일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다.
    C4_function_create:
      1:
        image: notes/C4_function_create_1.png
        text: 여러분은 함수 블록을 수정해 보았습니다. 이번에는 새로운 함수 블록 만들기를 시도해 볼 시간입니다. 진짜 쉽습니다. 도구 상자를 보면 함수라는 카테고리를 볼 수 있을 것입니다. 그 것을 클릭하면 함수 만들기라는 오렌지색 버튼을 볼 수 있습니다. 그것을 클릭하면 이전에 함수 블록을 수정할 때 사용했던 함수 편집 창이 나타납니다.
      2:
        image: notes/C4_function_create_2.png
        text: 이전과 마찬가지로, 함수 이름을 만들고, 함수에 대한 설명을 작성합니다. 예를 들어, 사각형이나 삼각형을 그릴 수 있도록 한 후, 툴박스에서 블록들을 드래그해서 작업공간으로 가져다 놓습니다. 함수로 만들기 위해서는 이 블록들을 녹색 부분 안으로 넣으면 됩니다.
      3:
        image: notes/C4_function_create_3.png
        text: 그렇게 완성되면, 저장하고 끝내면 됩니다. 그렇게 하면 원래 퍼즐의 작업공간으로 이동할 것입니다. 새로 만든 함수는 도구 상자의 함수 카테고리에 녹색 블록으로 나타나게 될 것입니다. 만든 블록을 작업 공간으로 가져와 사용하면 다른 블록들과 마찬가지로 퍼즐을 해결할 때 사용할 수 있습니다.
    C4_function_edit:
      1:
        image: notes/C4_function_edit_1.png
        text: 컴퓨터 프로그래밍에서 더 멋진 것은, 일단 컴퓨터가 해야할 작업을 컴퓨터에게 가르쳐 놓으면, 함수로 다시 불러 실행시킬 수 있다는 것입니다. 원하는 작업들을 하나로 묶어 이름을 붙여두면, 다시 불러 실행시킬 수 있습니다. 이것은 마치 사용 가능한 언어들을 확장시키는 것과 거의 같습니다.
      2:
        image: notes/C4_function_edit_2.png
        text: '우리가 만든 프로그램에서, 이동하고 회전하는 작업을 4번 반복함으로써 1개의 사각형을 그릴 수 있다는 것을 배웠습니다. 그러한 작업을 함수로 만들어, 사각형 그리기라고 이름을 붙여두면, 원할 때마다 불러 사용할 수 있습니다. 불러서 사용할 때에는 "사각형 그리기"라고 말하면, 그 함수를 호출하고 그렇게 이름 붙여둔 한 묶음의 코드를 실행하게 될 것입니다. 이제 가능하게 되었네요. 우리가 사용하는 프로그래밍 언어에 그런 함수 개념을 추가했습니다.'
      3:
        image: notes/C4_function_edit_3.png
        text: 이 퍼즐에서 우리는 여러분을 위한 정사각형 그리기 함수를 만들었습니다. 그것은 도구 상자에서 초록색 블록으로 보일 거예요. 여러분이 해야 할 일은 이전에 정사각형을 그리기 위해 작성했던 코드를 똑같이 작성하고 이 함수 안에 집어 넣는 것입니다. 그렇게 하기 위해 초록색의 정사각형 그리기 블록 안의 편집 옵션을 클릭하세요. 함수 편집기가 열릴 것입니다. 함수 편집기는 세 부분으로 나뉘어집니다. 함수의 이름을 짓는 부분. 이것은 그 함수 앞에 초록색 블록 위에 보일 것입니다. 그리고나서 함수가 할 일에 대한 짧은 설명을 적습니다.
      4:
        image: notes/C4_function_edit_4.png
        text: 이런 상황에서 그것은 사각형을 그리는 것으로 여겨질 수 있습니다. 이것 아래에 있는 흰색 공간은 작업 공간이고, 그것은 여러분들이 이미 사용중인 작업공간처럼 작동될 것입니다. 이 작업공간 안에 있는 툴박스로부터 블록들을 드래그 하고 드롭하세요. 함수를 만들기 위해 초록색으로 둘러싼 블록 안에 사각형을 만들 블록을 넣을 것을 기억하세요. 여러분이 일단 그것을 했다면 저장버튼을 클릭하고 빠져나가세요. 이것은 여러분을 작업 공간의 메인 퍼즐로 돌아가게 해 줄 것입니다. 이제 여러분은 퍼즐을 풀기 위한 다른 블록과 같이 사각형을 그리는 함수 블록을 사용할 수 있습니다.
    C4_function_parameters:
      1:
        image: notes/C4_function_parameters_1.png
        text: 여기 한 변의 길이가 50 픽셀인 사각형을 1개 그리는 함수가 있습니다. 그렇다면, 한 개는 한 변의 길이가 50 픽셀이 되도록 그리고, 다른 한 개는 한 변의 길이가 100 픽셀이 되도록 그리려고 한다면 어떻게 해야할까요? 거의 비슷한 두 개의 함수를 따로 따로 만들 필요는 없습니다. 대신, 하나의 함수에 하나의 매개 변수를 함께 사용하면 됩니다.
      2:
        image: notes/C4_function_parameters_2.png
        text: 매개 변수는 함수에서 사용하는 변수에 값을 전달합니다. 다른 크기의 사각형을 만들기 위해 함수를 호출하며 매개 변수를 전달해 봅시다. 방금 매개 변수를 추가했던 것처럼 함수 편집기에서 이름과 설명을 편집할 수 있습니다. 빈 칸에 매개 변수의 이름을 입력하고 매개 변수 추가하기를 클릭하세요. 그러면 방금 만든 매개 변수의 이름에 빨간 블록이 생길 것입니다. 이제 매개 변수의 길이에 의해 100블록 앞으로 이동할 것입니다.
      3:
        image: notes/C4_function_parameters_3.png
        text: 저장하고 닫기를 누른 후 새로 만든 사각형 만들기 블록을 함수 카테고리에서 도구상자로 드래그 하세요. 그렇게 하면, 길이라고 쓰여있는 곳 옆이 비어있다는 것을 알게 될 것입니다. 함수는 길이 매개 변수를 사용하기 때문입니다. 수학 카테고리에서 수 블록을 드래그해서, 이 공간에 놓으세요. 함수를 계속 사용해보면서 살펴보고, 서로 다른 크기의 사각형들을 만들어보세요. 열심히 시도해 보세요!
    C4_intro:
      1:
        image: notes/C4_intro_1.png
        text: 일반적으로 프로그래밍은 텍스트로 작성을 하지만, 오늘 우리는 블러클리(Blockly) 를 사용할 것입니다. 블러클리는 프로그램을 작성하기 위해서 비주얼 블록들을 사용합니다. 하지만, 내부적으로는 코드를 작성하는 것입니다. 시작하면서, 앵그리 버드가 자기 알들을 훔쳐간 나쁜 돼지를 미로를 이동해서 잡을 수 있도록 코드를 작성할 것입니다.
      2:
        image: notes/C4_intro_2.png
        text: 블러클리의 화면은 3개의 주 화면으로 분할되어있습니다. 왼쪽은 프로그램이 실행된 후 새가 움직일 미로입니다. 각 레벨을 위한 설명은 미로 아래에 작성되어있습니다. 가운데 영역은 도구 상자이고, 이 블록들은 새를 동작시킬 수 있는 명령어입니다. 오른쪽의 빈 공간은 프로그램을 만드는 작업 공간입니다.
      3:
        image: notes/C4_intro_3.png
        text: '만약 제가 이동 블럭을 작업공간에 끌어다 놓고 "실행" 버튼을 누르면 어떻게 될까요? 새가 격자판에서 앞으로 한 박스만큼 움직일 것입니다. 그리고 새가 한 박스 이동한 다음 무엇을 하길 원한다면 어쩌지요? 저는 프로그램에 또 다른 블록을 추가할 수 있습니다.'
      4:
        image: notes/C4_intro_4.png
        text: '저는 "오른쪽으로 이동" 블록을 선택할 것입니다. 그리고 노란색 화살표가 보일 때까지 이동 블록 아래로 끌 것입니다. 그 다음에 놓으면 두 블록은 서로 달라붙을 것입니다. 제가 "실행" 버튼을 다시 눌렀을 때, 새는 여러분의 작업 공간에 쌓여 있는 명령들을 위에서 아래로 수행할 것입니다.'
      5:
        image: notes/C4_intro_5.png
        text: 어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 휴지통으로 넣으면 됩니다. 실행시켰을 때에는 재실행 버튼을 눌러 새를 처음 위치로 돌려 놓을 수 있습니다. 이제 저 돼지들을 잡아보세요!
    C4_math_artist:
      1:
        image: notes/C4_math_artist_1.png
        text: 만약에 높이가 50 픽셀이고 너비는 높이의 두 배만큼 넓은 사각형을 그리고 싶다면 컴퓨터가 그 일을 하도록 어떻게 프로그래밍 하면 될까요? 자, 저는 예술가에게 50만큼 위로 올라가서 오른쪽으로 돌고 그 다음에 100만큼 가는 것을 두 번 하라고 말할거예요. 하지만 그러면 저는 컴퓨터를 위해 수학을 하고 있는 것입니다.
      2:
        image: notes/C4_math_artist_2.png
        text: 머리 속으로 50에 2를 곱하는 것은 그리 어렵지 않을런지도 모릅니다. 하지만 컴퓨터는 정말 수학을 잘하기 때문에 우리는 가능한 그것을 컴퓨터에게 맡겨야 합니다. 만약에 제가 숫자 대신에 높이라는 변수를 사용했다면 높이를 50으로 쉽게 바꿀 수 있었을 것입니다. 그 다음에 예술가가 높이보다 두 배 넓은 사각형을 그리도록 높이만큼 위로 올라간 다음 오른쪽으로 돌고 나서 높이의 두 배만큼 앞으로 가도록 알고리즘을 변경할 수 있었을 것입니다.
    C4_unplugged_algorithms:
      1:
        image: notes/C4_unplugged_algorithms_1.png
        text: 이번 학습은 칠교놀이 알고리즘입니다. 칠교놀이는 다른 모양을 만들기 위한 일곱개의 조각으로 하는 퍼즐입니다. 여러분들은 이 퍼즐을 어떻게 함께하는지 설명하기 위해 알고리즘을 이용할 수 있습니다.
      2:
        image: notes/C4_unplugged_algorithms_2.png
        text: 알고리즘은 어떤 작업을 완료하기 위해서 수행할 수 있는 단계들의 리스트에 불과합니다. 우리는 쇼핑리스트나 음식 요리법과 같은 곳에서 매일 알고리즘을 사용합니다. 알고리즘이 간단하면 여러 가지 형태로 변화시켜 사용할 수 있으며, 여러분이 원하는 것을 정확히 모르는 사람이라도 알고리즘을 통해 정확히 수행시킬 수 있습니다. 어떤 사람이라도 여러분이 원하는 것을 정확히 수행하기를 원한다면, 알고리즘은 매우 자세하고 상세해야 합니다.
      3:
        image: notes/C4_unplugged_algorithms_3.png
        text: 나는 그림을 완성하기 위해 알고리즘을 사용하고 있습니다. 나는 몇 마리의 늑대 그림을 그리는 것을 시도하기고 싶었습니다. 하지만 나는 그다지 훌륭한 화가가 아니에요. 나로써는 다행히 사람들을 위해 숫자로 된 그림이 있습니다. 40개의 색깔이 있고, 그것은 작은 문자들과 숫자들을 갖고 있습니다. 그리고 그것들은 당신에게 각 영역에 어떤 색을 칠해야 할 지 알려줄 것입니다. 숫자로 그리는 그림은 어떤 색이 어디에 사용되는지 나에게 정확하게 말해 줍니다.
      4:
        image: notes/C4_unplugged_algorithms_4.png
        text: 내가 방향을 따라갈 수 있고, 그림은 아주 훌륭해 보일 것이 분명합니다. 그것이 훌륭한 알고리즘입니다. 만약에 지시사항이 아주 구체적이지 않다면, 나의 늑대들은 멋져 보이지 않을 것입니다. 여러분들이 계획한 방법을 정확하게 보여주기 위해 정말로 무언가를 원할 때 그것이 아주 정확하게 만들어 질 것입니다.
    C4_unplugged_binary:
      1:
        image: notes/C4_unplugged_binary_1.png
        text: 각 팀에서, 각 팀원의 종이를 펼지 접을지 지시하는 사람은, 누가 on 기호를 나타내고, 누가 off 기호를 나타내야 하는지 이해하고 있어야 합니다. 2진 체계는 마치 2개의 문자로만 이루어진 알파벳 문자라고도 생각할 수 있습니다. A와 B만으로, 모든 나머지 알파벳들을 표시해야하는 것과 같습니다. 2진 체계는 0 과 1 만으로 모든 것들을 표현해야 한다는 것입니다.
      2:
        image: notes/C4_unplugged_binary_2.png
        text: '이진법을 사용하는 가장 일반적인 방법은 조건문입니다.  조건문은 프로그래밍에서 고전적인 방법입니다. 프로그램은 무엇인가 참이라면 이것을, 참이 아니라면 다른 것을 실행합니다. 만약 무엇인가 실행하기를 원한다면 좀 더 복잡해질 수도 있습니다. 조건문 대신에 컴퓨터의 이미지나 소리와 같은 무엇인가를 이용하여 작업할 수 있습니다.'
      3:
        image: notes/C4_unplugged_binary_3.png
        text: '컴퓨터는 2진 체계만 이해할 수 있습니다. 이미지는 0 과 1 로만 구성된 2진 체계가 아닌데 어떻게 이미지를 표현할 수 있는 것 일까요? 여기 예시가 있습니다: 이런 멋진 그림입니다. 그림은 기본적으로 정보의 형태라고 볼 수 있습니다. 모든 정보는 2진 체계를 이용해 여러 가지 형태로 저장될 수 있습니다. 어떻게 그렇게 할 수 있는지 이해할 수 있을 것입니다.'
      4:
        image: notes/C4_unplugged_binary_4.png
        text: "You imagine that we're going to put a grid over this panda bear and for each square, we're going to decide whether that square is more black or more white. And then we're going to color it that way. Now each cell on the grid is either black or white and then the black squares we say those are zeros (binary digit) and the white squares are ones, the other binary digit. At the end, you're left with just a bunch of ones and zeros. That's how you represent this image in binary."
    C4_unplugged_forloops:
      1:
        image: notes/C4_unplugged_forloops_1.png
        text: "This lesson is called for loop fun. In this lesson, we'll use a number line to play a dice game. Each player will roll three times to assign a starting value, a stopping value, and our interval. During each turn, we circle our starting value, and every value that is the same number of steps forward as our interval value. We stop circling when we get to our stopping value. The person with the highest score wins!"
      2:
        image: notes/C4_unplugged_forloops_2.png
        text: For 반복 구조는 여러 곳에서 편리하게 사용될 수 있습니다. 기상학자가 되고 싶어하는 사람들은 for 반복 구조를 항상 사용하는 것이 좋습니다. 안녕하세요. 저는 베키입니다. 저는 EverPower 라는 재생에너지 회사에서, 바람 관련 기상학자로 일하고 있습니다. 저는 저희 회사가 운영하고 있는 풍력 발전기들이 있는, 콜럼비아 강 협곡 지역의 바람 속도에 대해 미리 예측하고 있습니다.
      3:
        image: notes/C4_unplugged_forloops_3.png
        text: "We're trying to understand how much wind is going to be there so that we know how much power is going to be outputted. We give that information to real time energy traders. They buy and sell power based on how much power we tell them is going to be there in order to make sure the power grid is balanced, your lights stay on, and that we maximize the amount of energy we get out of our farms."
      4:
        image: notes/C4_unplugged_forloops_4.png
        text: "We're at the national control center for EverPower Renewables here in Portland and this is where we have information coming in from all our farms across the country. Even the highest power computers today can't simulate the atmosphere everywhere. In computer forecasting models, we have what we call a grid. Each grid point is a latitude, longitude. We have to calculate the physics and try and figure out the wind speed, temperature,  pressure, that sort of thing."
      5:
        image: notes/C4_unplugged_forloops_5.png
        text: "Since these are fairly big grids and we're doing this in a lot of points we're looping over these things millions and millions of times. Everything I do I'll use for loops. Here for example is a for loop right there. When you're forecasting wind, there's so many different parameters that go into it it would be impossible for a human to sit down and do all those calculations. There's so many different aspects to what's going to be affecting what's happening to the wind that we need a computer model in order to forecast it."
    C4_unplugged_madlibs:
      1:
        image: notes/C4_unplugged_madlibs_1.png
        text: 이 레슨에서 우리는 비어 있는 이야기를 채우는 놀이를 할 것입니다. 여러분은 유사하지만 아주 재미있는 차이점들을 가진 이야기들을 만들어 그 안을 채울 수 있는 양식을 가지게 됩니다.
      2:
        image: notes/C4_unplugged_madlibs_2.png
        text: "In this lesson, we also learned how to make an abstracted template from two stories that have already been created. Abstraction is the art of removing differences and details so that you can see how one solution might work for many different problems. It's very helpful in computer science because it allows us to create functions that may be useful in several different situations."
    C4_unplugged_parameters:
      1:
        image: notes/C4_unplugged_parameters_1.png
        text: "This lesson is called songwriting with parameters. We're going to be writing some songs here. Sometimes the chorus is just a little bit different each time you sing it. Do you remember Old Macdonald Had a Farm? The chorus is slightly different for each animal. And on that farm, he had a cow, e-i-e-i-o. The small change in each chorus can be shown using something we call parameters."
      2:
        image: notes/C4_unplugged_parameters_2.png
        text: 때때로 함수는 매개 변수가 필요합니다. 매개변수는 함수를 특별한 요구에 최적화시키기 위해 여러분이 함수에게 전달할 수 있는 추가 정보입니다. 여러분이 친구와 아이스크림 선디를 만들 때 여러분은 컴퓨터 프로그램에서 매개변수를 사용하는 것과 비슷한 과정을 사용합니다.
      3:
        image: notes/C4_unplugged_parameters_3.png
        text: "The disk of vanilla ice cream might be the same for every sundae but when you ask your friends which two toppings they'd like, you could get lots of different combinations. Topping is the function name but each type of topping is a parameter. Functions and parameters work together to make great computer programs and great sundaes too."
    C4_unplugged_variables:
      1:
        image: notes/C4_unplugged_variables_1.png
        text: "This lesson is called variables in envelopes. We're going to learn how we can build sentences when we're still missing pieces of information. Most of us are already familiar with the idea of filling in a blank. We do it when we're putting our name on our homework. Sometimes there's more than one word that needs to be filled out and in that case, we give that blank a label so that we know which piece of information goes where."
      2:
        image: notes/C4_unplugged_variables_2.png
        text: Variables are placeholders for pieces of information that can change. By using a variable for the missing information, we can continue working on whatever we were doing and let someone else fill in the missing information later. In software, we use variables a lot. We use variables as placeholders for name, email address, and even username. That way we can let the program know where those details will appear after the user fills them in. We use variables all the time in our work.
      3:
        image: notes/C4_unplugged_variables_3.png
        text: 여러분은 나중에 사용하기 위해서 일부 정보를 남겨둘 수 있는데, 변수를 사용하면 됩니다. 트위터에서 트윗 된 횟수를 카운트할 필요가 있다고 생각해봅시다. 트위터 사용자들이 트윗 할 때마다 1씩 더해 수를 올리고, 트윗을 지울 때마다 1씩 감소 시킵니다. 사용자들이 트윗 한 횟수를 알고 싶을 때에는 변수에 저장되어있는 값만 살펴보면 됩니다.
    C4_variables_artist:
      1:
        image: notes/C4_variables_artist_1.png
        text: 변수는 어떤 값을 저장시킬 수 있는 컨테이너입니다. 어떤 알고리즘에서 변수를 사용하면, 변수에 저장되어있는 값을 사용할 수 있습니다. 변수를 사용하면 변수에 저장되어있는 값에 따라서 다르게 움직이는 똑똑한 알고리즘을 만들 수 있습니다.
      2:
        image: notes/C4_variables_artist_2.png
        text: "예를 들어, 동생의 생일을 축하하는 알고리즘을 만들고 싶을 때, 올해에는 10번째 생일을 축하합니다! 라고 작성할 수 있는데, 내년에는 11번째 생일을 축하합니다라고 작성해야합니다. 그러한 경우 나이를 나타내는 수 대신에, 나이라는 변수에 동생의 나이를 저장해 두고 변경해 가면서 매년 축하 메시지를 만들 수 있게 됩니다. '나이'='나이'+1 로 매년 업데이트 시켜주면 되기 때문입니다."
      3:
        image: notes/C4_variables_artist_3.png
        text: 이 퍼즐에서 우리는 우리의 예술가가 그림을 그리는 선의 길이를 설정하기 위해 변수를 사용할 것입니다. 우리가 코딩한 후에 블록으로의 움직임은 이동하기 블록은 여러분이 설정한 변수가 무엇인지 알기 위해 길이 변수를 보게 될 것입니다.
    C4_variables_playlab:
      1:
        image: notes/C4_variables_playlab_1.png
        text: 변수는 어떤 값을 저장시킬 수 있는 컨테이너입니다. 어떤 알고리즘에서 변수를 사용하면, 변수에 저장되어있는 값을 사용할 수 있습니다. 변수를 사용하면 변수에 저장되어있는 값에 따라서 다르게 움직이는 똑똑한 알고리즘을 만들 수 있습니다.
      2:
        image: notes/C4_variables_playlab_2.png
        text: "Now you're going to try playlab where you are given different games and you can change the values of variables like speed, height, score, in order to change the game. You won't have to change the algorithm of the game to change how it plays, just the variable."
      3:
        image: notes/C4_variables_playlab_3.png
        text: In my work for Kindle and on X-ray for books, we apply variables in many different ways. One way that you can use a variable is to store page numbers of a book. A user can increase and decrease the size of the font on a page. Based on the font size, the number of pages in the book can change. We can adjust it by storing the number of pages in the variable.
    infinity_playlab_events:
      1:
        image: notes/infinity_playlab_events_1.png
        text: 이제 우리는 모든 게임프로그래머들이 매일 사용하는 것에 대해서 배울 것입니다. 이벤트라고 하는 것들입니다. 하나의 이벤트는 프로그램이 어떤 사건이 일어났을 때, 어떻게 해야하는지 프로그램에게 알려줄 때 사용하는 것이라고 볼 수 있는데, 게임의 경우에는 어떤 동작을 하게 되는 것이라고 볼 수 있습니다. 마우스 클릭, 방향키 누르기, 화면 터치하기 등이 바로 이벤트들입니다.
      2:
        image: notes/infinity_playlab_events_2.png
        text: '이제, 플레이어가 위/아래 방향키나 버튼을 사용할 때, 베이맥스가 위로 올라가 히로를 터치하고, 다시 아래로 내려와 라푼젤을 터치하도록 할 것입니다. 위쪽 화살표 블록에, 캐릭터를 위로 이동시켜주는 블록을 붙여서, 위쪽 방향키가 눌렸을 때 "위쪽 방향키가 눌렸을 때" 블록에 붙여져 있는 모든 것을 실행시키도록 할 것입니다. 아래쪽 화살표 블록에 대해서도 움직이도록 하면 됩니다. 게임이 점점 더 인터랙티브하게 바뀌어 가고 있습니다.'
    infinity_playlab_intro:
      1:
        image: notes/infinity_playlab_intro_1.png
        text: "So what grade are you in? Second. Tenth grade. First grade. I was in eighth grade when I learned to program. I got my first computer when I was in sixth grade. What gets me excited is being able to fix people's problems. You can express yourself, you can build things from an idea."
      2:
        image: notes/infinity_playlab_intro_2.png
        text: 컴퓨터과학(정보과학) 은 대학생과 전문직에 종사하는 사람들이 앞으로 20 ~ 30 년 동안 해야하는 많은 일들을 위한 기초입니다. 저는 다른 사람들을 돕는 것을 좋아하기 때문에 프로그래밍을 좋아합니다. 저는 다른 사람들의 삶을 보다 편하게 만들 수 있는, 그 무엇이라도 만들 수 있는 기회를 얻었습니다. 저는 그런 것이 우리가 슈퍼 파워를 가질 수 있는 것에 가장 가까운 것이라고 생각하고 있습니다. 일단, 시작하는 것이 가장 중요합니다. 저는 스스로 초보자라고 생각하고 있습니다. 저와 같이 함께 배워보세요.
      3:
        image: notes/infinity_playlab_intro_3.png
        text: "I'm John Vechey, I'm one of the co-founders of PopCap Games. We make games like Plants vs. Zombies, Bejeweled, and Peggle. A lot about games isn't how perfect your code is, it's not how perfect your art is, it's about how does it feel and how much fun it is. You can only get that sense by trying it, by doing it, by learning and adapting and iterating your own skills of making games."
      4:
        image: notes/infinity_playlab_intro_4.png
        text: 좋아하는 비디오 게임이 있나요? 우리는 Play Lab 에서 그런 게임을 만들기 위해서 한 단계씩 배워 나갈 것입니다. 좋은 게임들은 스토리가 있고, 모든 스토리에는 주인공 캐릭터들이 있습니다. 캐릭터들은 말하고, 이동하고, 다른 캐릭터들과 인터랙티브하게 상호작용합니다. 그리고 게임 스코어 포인트는 게임의 규칙에 따라 달라집니다. 오늘 우리는 스마트폰에서 실행되고 공유될 수 있는 게임을 한 단계씩 만들어 나가 볼 것입니다. 안나, 엘사, 히로, 베이백스, 라푼젤과 같은 게임 속 재미있는 캐릭터들을 이용해 게임을 만들어보세요.
      5:
        image: notes/infinity_playlab_intro_5.png
        text: 화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다. 가운데 공간은 도구상자이고, 이 블록들은 코드들의 일부 입니다. 오른쪽의 흰 공간은 작업 공간이라고 부르는데 그 안에서 프로그램을 작성할 것입니다.
      6:
        image: notes/infinity_playlab_intro_6.png
        text: '처음 시작하기 위해서, 사용할 블럭들을 "실행하면" 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다. 이 첫번째 퍼즐에서, 히로는 캐릭터 1이고, 베이맥스는 캐릭터 2입니다. "실행하면" 블록에 "앞으로 이동하기" 블록을 드래그해서 붙여 히로를 베이맥스에게 움직이도록 해야합니다. 블록들을 배치하면, "실행" 버튼을 눌러 실행 결과를 살펴보세요.'
      7:
        image: notes/infinity_playlab_intro_7.png
        text: 시작하고나서 마지막 쯤에는, 여러분이 직접 여러가지 캐릭터들을 이용해 게임을 만들고, 인터랙티브하게 움직이고, 점수를 올리거나, 마이크로봇/체리/냄비/불꽃/아이스를 던지고.. 서로 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요.
    infinity_playlab_repeat_forever:
      1:
        image: notes/infinity_playlab_repeat_forever_1.png
        text: 여러분들은 어떤 작업을 무한히 반복한다는 것을 상상해 본 적이 있나요? 다행히도 여러분은 전혀 그럴 필요가 없습니다. 컴퓨터들이 그렇게 반복하는 것을 아주 잘하기 때문입니다. 이것은 무한 반복 블록입니다. 이 블록의 안에 넣는 것은 게임 중에 무한히 반복 실행될 것입니다.
      2:
        image: notes/infinity_playlab_repeat_forever_2.png
        text: "So if we wanted an actor to do something repeatedly without the player having to do anything, we'll put those blocks inside the repeat forever block. In this next puzzle, our goal is to help Anna walk up and down continuously. Learning how the repeat commands work will save you a ton of time later when you build your own game."
    tutorial_puzzle_challenge:
      1:
        image: notes/tutorial_puzzle_challenge_1.png
        text: "What do you want to be when you grow up Olivia? An astronaut. Do you happen to know what a computer programmer is? Yeah um no. Ummm wait what? I'm not really sure how to explain it computer programming is pretty simple. It's a set of instructions like a recipe, you have to follow them step-by-step to get the end result you want."
      2:
        image: notes/tutorial_puzzle_challenge_2.png
        text: "I can change the number of pixels, the length of the line, using this dropdown. How long was it again? You can see the instructions again by looking under the run button. Here I used the move forward block and I'm going to select 100 pixels. I can delete a block by dragging it into the toolbox or the trash can. Let's put it back."
      3:
        image: notes/tutorial_puzzle_challenge_3.png
        text: "Run the code by pressing run. Well that didn't work! I'll press reset and figure out what's wrong. You can try a puzzle as many times as you'd like and skip puzzles and come back to them. Just make sure to try your best and don't give up. Let's add another move forward. That still didn't work. I can place a block between other blocks."
      4:
        image: notes/tutorial_puzzle_challenge_4.png
        text: "Let's take a turn block and place it in between the move forwards. Turn left 45 degrees. Let's run it again. Reset, run, awesome! Here's another puzzle. Sometimes you are given starter code to complete. Here I need to add the appropriate lengths and degrees."
      5:
        image: notes/tutorial_puzzle_challenge_5.png
        text: "You may sometimes accidentally trash the starter code. What do you do then? You can press clear puzzle and start all over again. I'm going to drag this number block into the different pixel areas. Select 100 for pixels, 45 for degrees and 100 for pixels again. Awesome! Here is the Code Studio bee. I need to move the bee to each flower and get nectar."
      6:
        image: notes/tutorial_puzzle_challenge_6.png
        text: "The first flower is three blocks away so I need three move forwards. 1, 2, 3. Then a get nectar, then another get nectar. Well that didn't work! I'll place another move forward between the get nectars and run it again. Yay, it works! You just learned how to use the Code Studio artist and bee puzzles. Good luck on the Code Studio puzzle challenge."
    unplug1:
      1:
        image: notes/unplug1_1.png
        text: "What do you want to be when you grow up Olivia? Umm, an astronaut! Do you happen to know what a computer programmer is? Yeahh, umm, no. Umm, what what? I'm not really sure how to explain it. Computer programming is pretty simple. It's a set of instructions, like a recipe. You have to follow them step by step to get the end result you want."
      2:
        image: notes/unplug1_2.png
        text: 컴퓨터과학(정보과학) 은 모든 세상에 영향을 줄 수 있는 한 가지 방법입니다. 어떤 사람이 또 다른 누군가들과 연결되어있던지 그렇지 않던지간에 세상에 영향을 줄 수가 있습니다. 뮤직비디오가 될 수도 있고, 게임이 될 수도 있습니다. 다른 사람들의 친구들을 찾아 볼 수도 있습니다. 사람들의 생명을 구하는 그 어떤 형태의 것이라도 할 수 있습니다. 여러분은 자동차를 운전할 수도 있고, 저는 페인트 칠을 할 수도 있습니다. 저는 위대한 프로그래밍이란 것이, 위대한 예술가들의 작품들과 그렇게 크게 다르지 않다고 생각합니다.
      3:
        image: notes/unplug1_3.png
        text: When I finally learned a little bit of programming, that blank wall resolved into a bunch of doors and you open them and of course then you find behind them is another hallway filled with a bunch of doors. Programming is fun and easy. You can do anything your mind wants to do. Finally you start to open enough doors the light comes in. To me a finished program is like a structure filled with light. All the corners are illuminated. The number of people that you can touch and interact with is something the world has never seen before.
      4:
        image: notes/unplug1_4.png
        text: "Our first lesson in this series is all about what computer science is, what a computer scientist does and how you can be more responsible in your use of technology. It's a very important lesson but it is a little text-heavy. At the end, you get to make your very own customized encoding using your initials. It's a fun activity and it's very empowering because binary is one of those things that feels very technical but once you understand it, it's like you speak a secret language."
    unplug2:
      1:
        image: notes/unplug2_1.png
        text: 컴퓨팅 사고력에 대한 레슨은 커다란 어려운 문제를 몇 개의 더 간단한 문제로 분할하는 방법을 여러분에게 가르쳐주려고 한다. 이 레슨의 목표는 누군가가 이 수업 계획에 포함되어 있는 괴물 중의 하나를 따라 그릴 수 있도록 하는 설명 세트를 작성하는 것이다.
      2:
        image: notes/unplug2_2.png
        text: '학생들은 설명문을 작성하기 위한 그룹들로 나뉠 것입니다. 그 다음에 그들은 괴물을 그려야 할 다른 그룹과 바꿀 것입니다. 그룹들은 컴퓨팅 사고력의 네 단계를 사용한 설명문을 작성할 것입니다: 분할, 패턴 찾기, 추상화와 알고리즘.'
      3:
        image: notes/unplug2_3.png
        text: 첫 번째 그룹들은 게임을 만들어내기 위한 계획을, 보다 작은 작업들로 분해할 것입니다. 그 다음에 카타로그에 나와있는 모든 몬스터들 사이에 어떤 패턴들이 있는지 살펴보게 될 것입니다. 몬스터들 사이의 차이를 발견하면, 그러한 자세한 차이들을 추상화하거나 고려하지 않을 수 있게 될 것입니다. 즉, 카탈로그의 한 몬스터는 베지터 눈을 가지고 있고, 다른 몬스터는 스프라이트 눈을 가지고 있습니다. 하지만, 두 몬스터 모두 눈을 가지고 있기 때문에, 몬스터는 어떤 눈을 가지고 있다고 작성할 수 있습니다.
      4:
        image: notes/unplug2_4.png
        text: 그래서 학생들은 괴물의 각 부분이 어떤 스타일이어야 하는지는 빈칸으로 되어 있는 설명 세트(알고리즘이라 부르는) 를 작성할 수 있을 것입니다. 이것은 그들만의 괴물을 재현하기 위해 다른 학생들에게 전달할 설명 세트입니다.
    unplug3:
      1:
        image: notes/unplug3_1.png
        text: In graph paper programming, we help explain how coding works by trying to help people recreate drawings using only arrows and scribbles. One person is given a small drawing on graph paper and they need to go through using only specific arrows and try to describe how to recreate that drawing.
      2:
        image: notes/unplug3_2.png
        text: 'In this activity, the only symbols you can use are these: move one square forward, one square backward, move one square up, move one square down, change to next color, and fill in your square with color. Once we have that coded up, we can hand it off to another person who can read the code and try and recreate the picture.'
    unplug4:
      1:
        image: notes/unplug4_1.png
        text: In graph paper programming, we help explain how coding works by trying to help people recreate drawings using only arrows and scribbles. One person is given a small drawing on graph paper and they need to go through using only specific arrows and try to describe how to recreate that drawing.
      2:
        image: notes/unplug4_2.png
        text: "In the second half of the activity, we ask students how many different ways they can fold a piece of paper to create sixteen identical rectangles. Then you'll discuss how multiple solutions can lead to the same end result and why some solutions are better in certain situations."
    unplug5:
      1:
        image: notes/unplug5_1.png
        text: In graph paper programming, we help explain how coding works by trying to help people recreate drawings using only arrows and scribbles. One person is given a small drawing on graph paper and they need to go through using only specific arrows and try to describe how to recreate that drawing.
      2:
        image: notes/unplug5_2.png
        text: "In the second half of the activity, we ask students how many different ways they can fold a piece of paper to create sixteen identical rectangles. Then you'll discuss how multiple solutions can lead to the same end result and why some solutions are better in certain situations."
    unplug6:
      1:
        image: notes/unplug6_1.png
        text: "This activity is called coding with cards and it's great for any age. Like you learned with the if statements in earlier lessons,  during Blockly, if statements have a piece about them you have to evaluate to find out if it's true or false. That's the conditional and it can be used in lots of different ways."
      2:
        image: notes/unplug6_2.png
        text: We take advantage of that by creating programs on paper that you run using a random draw of playing cards. You might have an if statement that says something like if the card you draw is greater than 8, you get a point. Otherwise, your opponent gets a point. You can make it as simple or as complicated as you feel comfortable.
    unplug7:
      1:
        image: notes/unplug7_1.png
        text: 여러분은 노래 가사를 볼 때 맨 먼저 후렴구가 정의되어 있고, 노래의 나머지 부분에서는 그 후렴구를 참조하도록 되어 있는 방법을 알고 있을 것입니다. 그것이 함수 호출이라는 것입니다.
      2:
        image: notes/unplug7_2.png
        text: "In this lesson, we define the chorus at the beginning of our song and then we sing through our song and go back and we notice that the class doesn't sing the word chorus, they automatically go up to the top where we define the chorus and sing through that. We use that as a great introduction to how to understand what a program is doing when it defines and calls a function."
      3:
        image: notes/unplug7_3.png
        text: "We use familiar songs including Old Macdonald to talk about how a chorus is called over and over and how sometimes a chorus can change. When you have a song like Old Macdonald, where certain words change, that's a great place to introduce the idea of parameters. Passing certain words through so that you can send extra information to your function. Once we're sure everybody gets it, you can take your own familiar songs and break them up yourself. See if you can figure it out together."
    unplug8:
      1:
        image: notes/unplug8_1.png
        text: Our lesson on abstraction uses the familiar concept of madlibs, where you basically insert a blank in a story that can be filled with lots of different words. We take that idea, challenge kids to come up with their own words for their own stories, and really explain the concept of abstraction.
      2:
        image: notes/unplug8_2.png
        text: "It's all about functions and how you can have a function, like in Old Macdonald, where you have a structure for your chorus but you have something little that changes and you abstract out that little thing that changes and you can fill it in with your own word every time through. But sometimes you have three words that change and so you fill those in with three parameters, that's still pretty helpful."
      3:
        image: notes/unplug8_3.png
        text: 여러분은 많은 서로 다른 문제들을 처리하는 하나의 함수를 사용할 수 있습니다. 많은 경우에 사람들은 그러한 모든 문제들이 아주 작은 차이점만 존재한다는 사실을 깨닫지 못하고 그것들을 처리하기 위해 서로 다른 함수들을 사용할 것입니다. 만약에 사람들이 하나의 작은 차이점을 처리하는 방법을 찾을 수만 있다면 그들은 14개의 서로 다른 함수를 사용하는 대신에 하나의 함수를 계속해서 재사용할 수 있을 것입니다.
    unplug9:
      1:
        image: notes/unplug9_1.png
        text: 릴레이 프로그래밍은 컴퓨터과학(정보과학) 에 대해 더 잘 이해할 수 있는 매우 재미있는 수업입니다. 가끔씩 모든 사람들은 약간 불안해지고 여러분은 그들이 원상태로 돌아오도록 하고 싶습니다. 좋은 방법은 컴퓨터과학(정보과학) 에 몇 가지 신나는 것을 추가하는 것입니다.
      2:
        image: notes/unplug9_2.png
        text: You break everyone up into two groups where they stand in a line and run relay style. The first person in each group runs to the other side of the room where you have a graph paper drawing and a blank piece of paper waiting for them. They write down the first step to creating that image, run back to their line, tag the next player who goes back up to write the next step.
      3:
        image: notes/unplug9_3.png
        text: "This is a great way to get across the idea of debugging, needing to proofread your own work, and needing to check the work of the people done before you. You'll quickly understand how important it is that you be careful in your coding when a whole team is depending on you."
    unplug10:
      1:
        image: notes/unplug10_1.png
        text: 이 활동은 인터넷이 어떻게 동작하는지에 대해 이해하기 쉬운 방법으로 설명합니다. 우리는 학생들이 이메일과 같은 메시지 전송을 시뮬레이션 할 수 있도록 모든 필요한 기술에 대해 간단한 용어로 설명합니다.
      2:
        image: notes/unplug10_2.png
        text: 학생들이 세 가지 전송 방법 중 하나인 척 하는동안 메시지를 전송할 것입니다. 무선 인터넷, DSL 또는 광섬유 케이블. wifi를 표현하는 학생들은 그들의 머리에 전송할 메시지를 쓰고 있어야 합니다. 왜냐하면 wifi는 몇 가지 정보를 가장 잘 놓치기 때문입니다.
      3:
        image: notes/unplug10_3.png
        text: DSL이나 전화선인 척 하는 학생들은 정보를 약간 덜 놓치는 손등으로 메시지를 옮길 것입니다. 그리고 광섬유 케이블을 표현하는 학생들은 양손으로 메시지를 옮기게 될 것입니다. 이러한 활동은 우리가 일상에서 사용하는 많은 것들을 이해하는 훌륭한 방법입니다.
    unplug11:
      1:
        image: notes/unplug11_1.png
        text: 지금은 다시 돌아가서 지난 19레슨에서 여러분이 해 보았 듯 모든 것을 새의 관점에서 볼 시간입니다. 그들이 그저 해 본 것을 다른 학생들에게 큰 소리로 말하는 즐거운 시간은 커다란 성취가 됩니다. 학생들은 이 레슨에서 대부분의 어른들이 컴퓨터과학(정보과학) 에 대해 알고 있는 것보다 더 많이 배웁니다.
      2:
        image: notes/unplug11_2.png
        text: 한 반 수업이나 보다 작은 모둠 수업에서 학생들이 좋아하는 수업들에 대해서 토론해보세요. 일단 배웠던 모든 것들에 대해서 살펴보고 나면, 그 때 학생들의 창의성이 빛날 수 있습니다. 학생들을 보다 작은 그룹으로 나눈 후, 언플러그드 활동을 만들어 보도록 해보세요. 각 그룹에 함수, 알고리즘과 같은 핵심 개념을 할당해 주고, 학생들이 사용할 수 있는 여러 가지 재료와 도구들을 나누어 주세요. 각 그룹별로 자신들이 만들어낸 언플러그드 활동을 발표하도록 하던지, 다른 날을 잡아 학생들이 만들어낸 활동들을 직접 해볼 수 있도록 해보세요.
      3:
        image: notes/unplug11_3.png
        text: Code.org 의 모든 여러분들이 이 코스를 재미있게 경험해 보기를 바랍니다. 여러분의 꿈이, 최고의 새로운 앱을 만드는 것, 사람들의 질병을 치료하는데 도움이 되도록 프로그래밍을 활용하는 것, 유명한 문제해결 고수가 되는 것이 아니더라도, 이 코스는 그러한 꿈을 이루기 위한 첫번째 단계라고 볼 수 있습니다.
    starwars_intro:
      1:
        image: notes/starwars_intro_1.JPG
        text: '안녕하세요. 저는 캐슬린 케네디이고, 스타워즈: 깨어난 포스 영화의 제작자입니다. 오늘 여러분은 스타워즈에 나오는 별들 중 하나에서 작업을 하게 될 것인데, BB-8은 공처럼 생긴 드로이드입니다. BB-8 의 모든 동작과 움직임은 컴퓨터 소프트웨어를 통해 이루어집니다. 컴퓨터과학(정보과학) 은 마켓팅, 헬스케어, 영화까지 모든 산업에 영향을 줍니다. 실제로, 수백명의 컴퓨터 엔지니어들이 함께 작업해서, 스타워즈 같은 영화를 만들어내는 것입니다.'
      2:
        image: notes/starwars_intro_2.JPG
        text: '안녕하세요, 저는 레이첼 로즈입니다. 저는 ILM의 수석 R&D 엔지니어로서, 애니메이션과 크리쳐 개발 팀을 이끌고 있습니다. 스타워즈: 깨어난 포스에서, 저는 예술가들이, 머나 먼 우주 어딘가에 실제로 있을 것 같은 캐릭터들의 장식을 만드는 것을 돕고 있습니다.'
      3:
        image: notes/starwars_intro_3.JPG
        text: "In the next hour, we're going to build our own Star Wars game. We'll teach you the basic concepts of programming. Usually programming is all text but we're going to use blocks here so that we can drag and drop to write the programs. Under the hood, you're still creating code. After you try the basics with blocks, we'll switch you to JavaScript, one of the most popular programming languages on the web."
      4:
        image: notes/starwars_intro_4.JPG
        text: "To start off, we're going to work with Rey to program BB-8 to walk to collect all of the scrap parts. Your screen is split into three parts. On the left is the Star Wars game space, where code will run. The instructions for each level are written below the game space."
      5:
        image: notes/starwars_intro_5.JPG
        text: 가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 명령어입니다.
      6:
        image: notes/starwars_intro_6.JPG
        text: 오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다.
      7:
        image: notes/starwars_intro_7.JPG
        text: 만약에 제가 moveLeft(); 블록을 작업공간으로 끌어와서 실행을 누르면 어떤 일이 일어날까요? BB-8이 격자판에서 왼쪽으로 한 블록 이동합니다.
      8:
        image: notes/starwars_intro_8.JPG
        text: MoveLeft(); 블록 다음에 다른 작업을 BB-8에게 시키려면? 다른 블록을 추가할 수 있습니다. moveUp(); 블록을 선택한 다음에 moveLeft(); 블록 아래에 강조 빛이 나타날 때까지 드래그 합니다. 그 다음에 놓으면 두 블록들이 서로 달라 붙게 됩니다.
      9:
        image: notes/starwars_intro_9.JPG
        text: 제가 실행을 다시 누르면, BB-8은 작업공간에 쌓인 명령문들을 위에서부터 아래로 수행할 것입니다. 만약에 여러분이 한 블록을 삭제하고 싶다면 언제든지 그 블록을 명령 블록들에서 제거하여 다시 도구 상자쪽으로 끌어내면 됩니다.
      10:
        image: notes/starwars_intro_10.JPG
        text: 실행한 후에 여러분은 언제든지 재실행 버튼을 눌러서 BB-8을 다시 시작하게 할 수 있습니다. 자, 이제 시작해 보세요!
    starwars_typing:
      1:
        image: notes/starwars_typing_1.JPG
        text: "Inside the blocks we've been using are JavaScript commands. JavaScript is the most popular programming language for professional developers today. Blocks are a great way to get started learning to code and in fact, top universities like Harvard and Berkeley start teaching this way. But once we learn the basics, engineers write code by typing because it allows us to go faster."
      2:
        image: notes/starwars_typing_2.JPG
        text: 우리는 도구상자에서 그것을 찾거나 끌어내지 않고도 수백 개의 명령어를 입력할 수 있습니다. 여러분은 이제 막 배우고 있기 때문에 입력하는 것이 처음에는 좀 느릴지도 모르지만 우리는 여러분이 한 번 시도해 보길 바랍니다.
      3:
        image: notes/starwars_typing_3.JPG
        text: 여러분은 작업 공간의 오른쪽 상단에서 텍스트 보기 버튼을 클릭하여 어떤 퍼즐의 블록이든지 글자로 입력된 코드로 전환할 수 있습니다.
      4:
        image: notes/starwars_typing_4.JPG
        text: 다음 레슨에서 우리는 여러분이 입력 모드에서 시작하도록 할 것입니다. 여러분은 여전히 도구상자로부터 블록을 끌어낼 수 있고, 명령어를 입력할 수도 있습니다. 여러분이 입력하기 시작하면 여러분이 입력하고 있는 그 아래에 사용 가능한 명령어들의 이름이 나타나는 것을 볼 수 있을 것입니다. 명령어 이름 전체를 입력하는 대신에 이것들 중 하나를 선택하여 더 빠르게 할 수 있습니다. 저는 직장에서 코드를 작성할 때 이런 자동완성 기능을 항상 사용합니다.
      5:
        image: notes/starwars_typing_5.JPG
        text: 여러분이 코드를 작성할 때는 아주 정확해야 합니다. 여러분은 철자를 잘 써야 합니다. 괄호와 세미콜론을 포함하여 명령 이름도 정확히 올바르게 대문자로 써야 합니다. 아주 사소한 실수에도 BB-8은 그 코드를 이해할 수 없어 움직이지 못합니다.
      6:
        image: notes/starwars_typing_6.JPG
        text: 명령줄에 오류가 있다면 편집기는 그것을 하이라이트로 표시하여 여러분이 그것을 고치게 할 것입니다.
      7:
        image: notes/starwars_typing_7.JPG
        text: 여러분이 중간에 막히게 되면 언제든지 다시 시작 버튼을 눌러 다시 시작할 수 있습니다. 그리고 언제든지 오른쪽 상단을 클릭하여 블록 모드로 돌아갈 수 있습니다. 좋아요, 이제 명령어를 입력해 봅시다. 그리고 만약에 여러분이 실수를 하게 되었을 때 좌절하지 마세요. 제대로 하려면 누구나 꽤 많은 시도가 필요합니다.
    starwars_events:
      1:
        image: notes/starwars_events_1.JPG
        text: 안녕하세요. 저는 월트디즈니 이미지어링에서, 수석 크리에이티브 프로듀서로 일하고 있는 채리타 카터입니다. 저는 저희 고객들이 경험하게될, 여러 가지 매력적인 것들을 만들어내는 팀들을 이끌고 있습니다. 우리는 고객들의 경험을 개선하고, 좀 더 나아지도록 하기 위한 방법들을 항상 찾아왔는데, 컴퓨터과학기술은 그러한 것의 핵심입니다.
      2:
        image: notes/starwars_events_2.JPG
        text: 축하합니다, 해냈습니다! 여러분이 BB-8 을 프로그래밍 했습니다. 이제 더 어려운 것을 할 준비가 되었다고 생각합니다. 여러분은 이제 프로그래밍의 기초를 배웠기 때문에, R2-D2와 C3PO를 주연으로 하는 여러분 만의 게임을 만들 때가 왔습니다.
      3:
        image: notes/starwars_events_3.JPG
        text: '게임을 만들기 위해 우리는 게임 프로그래머가 매일 사용하는 어떤 것을 배워야 합니다: 그것은 이벤트라고 부릅니다. 이벤트는 여러분의 프로그램에게 어떤 일이 발생했는지 알려주거나 또는 어떤 일이 발생할 때까지 기다렸다가 그 일이 발생하면 어떤 액션을 수행합니다.'
      4:
        image: notes/starwars_events_4.JPG
        text: 여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다.
      5:
        image: notes/starwars_events_5.JPG
        text: 이번에는 R2-D2를 위로 보내 메시지를 조종사에게 전달한 후, 아래로 움직여 다른 조종사에게 이동할 수 있도록 할 것입니다. R2-D2를 이동시키기 위해서 이벤트들을 사용하면 됩니다. 플레이어는 위/아래 방향키나 버튼들을 사용합니다.
      6:
        image: notes/starwars_events_6.JPG
        text: 우리는 whenUp() 이벤트 블록을 goUp() 이벤트 블록에 연결할 것입니다. 플레이어가 위쪽 방향키를 누르면 whenUp() 블록에 연결된 코드가 실행됩니다. 그리고 우리는 같은 방법으로 R2-D2가 아래로 내려가게도 할 것입니다.
      7:
        image: notes/starwars_events_7.JPG
        text: 이렇게 하기 위해, 우리 whenUp() 이라는 명령을 사용할 것입니다. 도구상자에서 명령을 끌어내면 여러분은 세미콜론 대신 시작과 끝에 중괄호를 볼 수 있습니다. 이것은 그 사이에 다른 명령을 넣기 위한 공간입니다. 선수가 위쪽 방향키를 누르면 우리가 이 괄호 안에 넣은 모든 명령이 실행됩니다.
      8:
        image: notes/starwars_events_8.JPG
        text: 우리는 R2-D2가 위로 올라가길 원하므로 명령 내부에 goUp(); 블록을 넣도록 해요. 그리고 같은 방법으로 R2-D2를 아래로 내려가도록 만들어 볼 거예요.
      9:
        image: notes/starwars_events_9.JPG
        text: 이제 드로이드를 제어하는 모든 코드를 미리 작성하는 대신, 버튼들을 눌렀을 때 R2-D2가 화면 이리저리 움직일 수 있도록 할 수 있습니다. 한 단계씩 진행해 나아가면 게임이 인터랙티브하게 변화될 것입니다.
    starwars_congrats:
      1:
        image: notes/starwars_congrats_1.JPG
        text: 안녕하세요, 저는 앨리스입니다. 저는 Code.org 를 운영하고, 엔지니어링 팀을 맏고 있습니다. 그리고, 여러분들이 지금 하고 있는 튜토리얼을 만들 때에도 참여했습니다.
      2:
        image: notes/starwars_congrats_2.JPG
        text: 여러분은 지금 막 마지막 레벨을 성공하였습니다. 축하합니다! 여러분은 여러분만의 스타워즈 게임을만들기 위해 알아야 할 모든 것을 배웠습니다. 이제 더 이상의 목표도, 해결해야 할 퍼즐도 없습니다. 여러분은 여러분만의 게임을 만들 수 있고 어떻게 작동하도록 할지 선택할 수 있습니다. 한 가지 더, 여러분은 알아야 할 새로운 소리와 새로운 명령어를 모두 알아냈습니다.
      3:
        image: notes/starwars_congrats_3.JPG
        text: '[students speaking] So we made a game basically where you get points when you get puffer pigs. The twist is everytime you get a puffer pig a storm trooper appears. Actually the whole screen is full of puffer pigs and then when you touch 10,000 of them, you win.'
      4:
        image: notes/starwars_congrats_4.JPG
        text: "[students speaking] We made a game where you can't lose and everything you kill gives you points. For my program, I reversed the keys so that whenever you click up, your character goes down and when you go right, your character goes left. It's really hard! Sometimes you just get an advantage, an unfair advantage if you're the developer of the game. Did I get it? Yay!"
      5:
        image: notes/starwars_congrats_5.JPG
        text: 여러분이 게임을 다 만들었을 때, 친구들과 공유하거나 여러분의 휴대전화에서 게임을 할 수 있도록 하는 공유 링크를 선택하세요. 즐거운 시간 보내세요!
    starwars_blocks_intro:
      1:
        image: notes/starwars_blocks_intro_1.JPG
        text: '안녕하세요. 저는 캐슬린 케네디이고, 스타워즈: 깨어난 포스 영화의 제작자입니다. 오늘 여러분은 스타워즈에 나오는 별들 중 하나에서 작업을 하게 될 것인데, BB-8은 공처럼 생긴 드로이드입니다. BB-8 의 모든 동작과 움직임은 컴퓨터 소프트웨어를 통해 이루어집니다. 컴퓨터과학(정보과학) 은 마켓팅, 헬스케어, 영화까지 모든 산업에 영향을 줍니다. 실제로, 수백명의 컴퓨터 엔지니어들이 함께 작업해서, 스타워즈 같은 영화를 만들어내는 것입니다.'
      2:
        image: notes/starwars_blocks_intro_2.JPG
        text: '안녕하세요, 저는 레이첼 로즈입니다. 저는 ILM의 수석 R&D 엔지니어로서, 애니메이션과 크리쳐 개발 팀을 이끌고 있습니다. 스타워즈: 깨어난 포스에서, 저는 예술가들이, 머나 먼 우주 어딘가에 실제로 있을 것 같은 캐릭터들의 장식을 만드는 것을 돕고 있습니다.'
      3:
        image: notes/starwars_blocks_intro_3.JPG
        text: 다음 시간에 우리는 여러분에게 프로그래밍의 기본 개념을 가르쳐 줄 스타워즈 게임을 할 것입니다. 대부분의 프로그래밍은 모두 텍스트로 되어 있습니다. 우리는 블록을 끌어다 놓는 것으로 프로그램을 작성할 수 있습니다. 우선, 우리는 레이와 함께 BB-8이 돌아다니며 모든 부품을 수집하고 다니도록 만들 것입니다.
      4:
        image: notes/starwars_blocks_intro_4.JPG
        text: 화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 스타워즈 게임 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다.
      5:
        image: notes/starwars_blocks_intro_5.JPG
        text: 가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 명령어입니다.
      6:
        image: notes/starwars_blocks_intro_6.JPG
        text: 오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다.
      7:
        image: notes/starwars_blocks_intro_7.JPG
        text: 만약에 제가 moveLeft(); 블록을 작업공간으로 끌어오면 어떤 일이 일어날까요? BB-8이 그리드 위에서 왼쪽으로 한 블록 이동합니다.
      8:
        image: notes/starwars_blocks_intro_8.JPG
        text: MoveLeft(); 블록 다음에 다른 작업을 BB-8에게 시키려면? 다른 블록을 추가할 수 있습니다. moveUp(); 블록을 선택한 다음에 moveLeft(); 블록 아래에 강조 빛이 나타날 때까지 드래그 합니다. 그 다음에 놓으면 두 블록들이 서로 달라 붙게 됩니다. 다시 실행시키면, BB-8 은 작업 공간에 쌓여 있는 명령들을 순서대로 실행할 것입니다.
      9:
        image: notes/starwars_blocks_intro_9.JPG
        text: 어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 툴박스로 다시 가져다 놓으면 됩니다.
      10:
        image: notes/starwars_blocks_intro_10.JPG
        text: 실행한 후에 여러분은 언제든지 재실행 버튼을 눌러서 BB-8을 다시 시작하게 할 수 있습니다. 자, 이제 시작해 보세요!
    starwars_blocks_events:
      1:
        image: notes/starwars_blocks_events_1.JPG
        text: 안녕하세요. 저는 월트디즈니 이미지어링에서, 수석 크리에이티브 프로듀서로 일하고 있는 채리타 카터입니다. 저는 저희 고객들이 경험하게될, 여러 가지 매력적인 것들을 만들어내는 팀들을 이끌고 있습니다. 우리는 고객들의 경험을 개선하고, 좀 더 나아지도록 하기 위한 방법들을 항상 찾아왔는데, 컴퓨터과학기술은 그러한 것의 핵심입니다.
      2:
        image: notes/starwars_blocks_events_2.JPG
        text: 축하합니다, 해냈습니다! 여러분이 BB-8 을 프로그래밍 했습니다. 이제 더 어려운 것을 할 준비가 되었다고 생각합니다. 여러분은 이제 프로그래밍의 기초를 배웠기 때문에, R2-D2와 C3PO를 주연으로 하는 여러분 만의 게임을 만들 때가 왔습니다.
      3:
        image: notes/starwars_blocks_events_3.JPG
        text: '게임을 만들기 위해 우리는 게임 프로그래머가 매일 사용하는 어떤 것을 배워야 합니다: 그것은 이벤트라고 부릅니다. 이벤트는 여러분의 프로그램에게 어떤 일이 발생했는지 알려주거나 또는 어떤 일이 발생할 때까지 기다렸다가 그 일이 발생하면 어떤 액션을 수행합니다.'
      4:
        image: notes/starwars_blocks_events_4.JPG
        text: 여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다.
      5:
        image: notes/starwars_blocks_events_5.JPG
        text: 이번에는 R2-D2를 위로 보내 메시지를 조종사에게 전달한 후, 아래로 움직여 다른 조종사에게 이동할 수 있도록 할 것입니다. R2-D2를 이동시키기 위해서 이벤트들을 사용하면 됩니다. 플레이어는 위/아래 방향키나 버튼들을 사용합니다.
      6:
        image: notes/starwars_blocks_events_6.JPG
        text: 우리는 whenUp() 이벤트 블록을 사용하고 그것에 goUp() 블록을 연결할 거에요. 플레이어가 위쪽 방향키를 누르면 whenUp() 블록에 연결된 코드가 실행됩니다. 그리고 우리는 같은 방식으로 R2-D2가 아래로 이동하도록 할 것입니다. 이제 드로이드를 제어 하는 모든 코드를 미리 작성하는 대신 화면을 돌아다니도록 하는 버튼 프레스 이벤트에 우리의 R2-D2가 반응하도록 할 수 있습니다.
      7:
        image: notes/starwars_blocks_events_7.JPG
        text: 점차적으로 여러분의 게임이 좀 더 인터랙티브하게 됩니다.
    starwars_blocks_congrats:
      1:
        image: notes/starwars_blocks_congrats_1.JPG
        text: 안녕하세요, 저는 앨리스입니다. 저는 Code.org 를 운영하고, 엔지니어링 팀을 맏고 있습니다. 그리고, 여러분들이 지금 하고 있는 튜토리얼을 만들 때에도 참여했습니다.
      2:
        image: notes/starwars_blocks_congrats_2.JPG
        text: 여러분은 지금 막 마지막 레벨을 성공하였습니다. 축하합니다! 여러분은 여러분만의 스타워즈 게임을만들기 위해 알아야 할 모든 것을 배웠습니다. 이제 더 이상의 목표도, 해결해야 할 퍼즐도 없습니다. 여러분은 여러분만의 게임을 만들 수 있고 어떻게 작동하도록 할지 선택할 수 있습니다. 한 가지 더, 여러분은 알아야 할 새로운 소리와 새로운 명령어를 모두 알아냈습니다.
      3:
        image: notes/starwars_blocks_congrats_3.JPG
        text: '[students speaking] So we made a game basically where you get points when you get puffer pigs. The twist is everytime you get a puffer pig a storm trooper appears. Actually the whole screen is full of puffer pigs and then when you touch 10,000 of them, you win.'
      4:
        image: notes/starwars_blocks_congrats_4.JPG
        text: "[students speaking] We made a game where you can't lose and everything you kill gives you points. For my program, I reversed the keys so that whenever you click up, your character goes down and when you go right, your character goes left. It's really hard! Sometimes you just get an advantage, an unfair advantage if you're the developer of the game. Did I get it? Yay!"
      5:
        image: notes/starwars_blocks_congrats_5.JPG
        text: 여러분이 게임을 다 만들었을 때, 친구들과 공유하거나 여러분의 휴대전화에서 게임을 할 수 있도록 하는 공유 링크를 선택하세요. 즐거운 시간 보내세요!
    mc_intro:
      1:
        image: notes/mc_intro_1.JPG
        text: 제 이름은 Jens Bergensten이지만 다들 Jeb이라고 부르죠. 제가 여기 스톡홀름 Mojang의 Minecraft 리드 개발자에요. 11살인가 12살 때 프로그래밍을 시작했던 것 같아요. 게임을 만들고 싶었거든요. 아버지 친구 중 한 분이 말해주셨는데 게임을 만들려면 프로그래밍을 배워야 한다고 하셨죠. 그렇게 시작하게 됐죠. 전 사물의 구성을 설계하고 계산하는 걸 좋아해요. 그게 바로 제가 Minecraft에서 좋아하는 점이죠.
      2:
        image: notes/mc_intro_2.JPG
        text: 앞으로 몇 시간에 걸쳐서 여러분은 Minecraft 월드를 재현한 곳에서 알렉스나 스티브를 움직이게 프로그래밍하면서 컴퓨터 공학의 기초를 배우게 될 거에요.
      3:
        image: notes/mc_intro_3.JPG
        text: 전통적인 프로그래밍은 보통 텍스트로 해요. 하지만 오늘 우리는 블록을 드래그 드롭하며 프로그램을 만드는 Blockly라는 시스템을 사용할 거에요. 모르는 사이에 여러분은 자바 스크립트 코드를 만들게 될 거에요.
      4:
        image: notes/mc_intro_4.JPG
        text: 여러분이 배울 개념은 컴퓨터 프로그래머들이 매일 사용하고 컴퓨터 공학에 기초가 되는 것이죠. Mojang에서 Minecraft를 만드는데 이것과 동일한 개념을 사용해요.
      5:
        image: notes/mc_intro_5.JPG
        text: 시작하기 전에 캐릭터를 고르세요. 전 알렉스를 고를 거에요. 알렉스가 화면에서 돌아다닐 수 있게 프로그램 코드를 만들어 볼까요.
      6:
        image: notes/mc_intro_6.JPG
        text: 화면은 세 개의 주요 부분들로 나뉘어 있어요. 왼쪽은 Minecraft 플레이 공간으로, 여러분의 프로그램이 실행되죠. 각 레벨에 대한 설명은 아래에 적혀있어요.
      7:
        image: notes/mc_intro_7.JPG
        text: 중간은 툴 박스인데, 이 블록들 각각은 알렉스의 행동을 지시하는 명령어에요.
      8:
        image: notes/mc_intro_8.JPG
        text: 오른쪽에 흰 공간은 작업 공간이라고 불리는데 여기서 프로그램을 빌드할 거에요.
      9:
        image: notes/mc_intro_9.JPG
        text: 앞으로 이동 블록을 드래그해서 작업 공간에 놓고 실행하기를 클릭하면, 어떻게 되죠? 알렉스가 한 칸 앞으로 이동해요.
      10:
        image: notes/mc_intro_10.JPG
        text: 알렉스가 한 칸 앞으로 이동한 다음에 무언가를 하게 하려면 어떻게 할까요? 프로그램에 다른 블록을 추가하면 돼요. 전 오른쪽으로 돌기 블록을 선택할 거에요. 그걸 앞으로 이동 아래에 놓고, 주황색 선이 나타나면 내려놓으세요. 그러면 두 블록이 결합되죠. 실행하기를 다시 누르면, 알렉스가 작업 공간에 위에서부터 쌓여있는 명령어들을 수행할 거에요.
      11:
        image: notes/mc_intro_11.JPG
        text: 만약에 블록을 삭제하고 싶으면 그 블록을 끌어서 다시 툴 박스에 가져다 놓으면 돼요.
      12:
        image: notes/mc_intro_12.JPG
        text: 실행 취소를 하고 싶거나 레벨 시작 단계로 돌아가고 싶으면, 작업 공간 오른쪽 위에 있는 다시 시작 버튼을 사용하세요. 그리고 돌기 블록들에 있는 이 작은 삼각형 보이죠? 이런 삼각형이 보이면 다른 옵션을 고를 수 있다는 뜻이에요. 그럼, 코딩을 시작해 볼까요!
    mc_repeat:
      1:
        image: notes/mc_repeat_1.JPG
        text: 전 Mojang의 브랜드 디렉터 Lydia Winters에요. 우리가 Minecraft라는 작은 게임을 만들었죠.
      2:
        image: notes/mc_repeat_2.JPG
        text: Minecraft에서 제가 가장 좋아하는 건 탐험하는 거에요. 동굴 속에서 모험을 하고 제가 찾은걸 보는 걸 좋아하죠. 프로그래머가 아닌 입장에서 전 Minecraft 강의를 듣는 게 너무 신나요. 그리고 코딩을 직접 배운다는 것도 신나고요.
      3:
        image: notes/mc_repeat_3.JPG
        text: 지난 레벨에서는 앞으로 이동 블록들이 많이 필요했어요. 컴퓨터에게 여러 번 반복해서 앞으로 이동하라고 말할 수 있으면 더 쉬울 거에요. 다행히도 컴퓨터는 반복문으로 명령을 반복하는 걸 아주 잘하죠.
      4:
        image: notes/mc_repeat_4.JPG
        text: Minecraft를 건설할 때 새로운 세계를 만들기 위해서 모든 기초 재료를 놓을 때 반복문을 사용해요. 엄청나게 많은 블록들이 되죠. 알렉스가 걸을 때 발이 앞뒤로 왔다 갔다 하게 만드는 것 같은 작은 활동에도 반복문을 써요. 반복문은 프로그래밍에서 굉장한 부분이에요.
      5:
        image: notes/mc_repeat_5.JPG
        text: 밤이 됐으니 다음 레벨들에서는 안전하게 머물 집을 지어볼 거에요. 블록 반복하기를 사용해서 아주 쉽게 할거에요.
      6:
        image: notes/mc_repeat_6.JPG
        text: 집에 벽을 쌓으려면 알렉스에게 앞으로 가서 목재를 4번 놓으라고 하거나 앞으로 가서 목재 한 개를 놓은 다음에 블록 반복하기를 써서 여러 번 행동을 수행하게 할 수 있어요. 이제 블록 반복하기를 클릭해서 몇 번을 반복하게 하고 싶은지 선택해봐요. 자, 이제 밤이 되기 전에 집을 만들어 볼까요! 재미있는 시간 되세요.
    mc_if_statements:
      1:
        image: notes/mc_if_statements_1.JPG
        text: 이번에는 if문(만약 블록)에 대해서 배워볼 거에요. if문은 프로그래밍의 기초가 되는 부분이에요. 컴퓨터가 결정을 하는 걸 도와주죠.
      2:
        image: notes/mc_if_statements_2.JPG
        text: 모든 컴퓨터는 if문을 사용해요. 제 스마트폰도 그렇죠. 예를 들어 제가 폰을 잠금 해제할 때, 폰은 어떤 코드를 실행시켜요. 정확한 비밀번호를 입력하면 폰을 잠금 해제하고, 그렇지 않으면 오류 메시지를 띄우죠.
      3:
        image: notes/mc_if_statements_3.JPG
        text: 코드에서 if문을 이용해서 스티브와 알렉스가 월드에서 본 것에 반응하게 만들 수 있어요. 예를 들어, 앞에 돌이 있을 때 왼쪽으로 돌 수 있죠. 아니면 나무를 만났을 때 오른쪽으로 돌거나요.
      4:
        image: notes/mc_if_statements_4.JPG
        text: 이때 용암에 빠지면 안되겠죠. 용암을 피하는 건 어렵지 않아요. 화면에서 볼 수 있죠. 그런데 돌 밑에 있어서 볼 수 없는 용암은 어떻게 할까요?
      5:
        image: notes/mc_if_statements_5.JPG
        text: 돌을 채굴한 다음 확인해야 해요. 앞으로 이동하기 전에 그곳에 용암이 있는지를 말이죠. 용암이 있으면 앞으로 이동하기 전에 캐릭터 앞에 돌을 놓으세요. 그렇게 하면 안전하게 이동할 수 있어요. 채굴을 더 할 시간이에요! 발밑을 조심하려면 if문(만약 블록)을 사용하는 걸 잊지 마세요.
    mc_congrats_share:
      1:
        image: notes/mc_congrats_share_1.JPG
        text: 축하해요! 지금까지 여러분은 컴퓨터 공학의 기본적인 것들 몇 개를 배웠어요.
      2:
        image: notes/mc_congrats_share_2.JPG
        text: 이제 이 블록들을 이용해서 원하는 걸 만들 수 있어요. 더 이상 지시 사항이나 풀어야 할 퍼즐도 없어요. 여러분이 원하는 어떤 것이든 만들 수 있어요. 선택은 여러분에게 달렸어요.
      3:
        image: notes/mc_congrats_share_3.JPG
        text: '[학생들] 거의 다 돼가요. 털 깎기. 전 횃불로 L자를 만들었어요. 전 자작나무 판자로 A자를 만들었어요. 돼요, 진짜 돼요. 우리는 양털로 집을 만들었어요!'
      4:
        image: notes/mc_congrats_share_4.JPG
        text: 만들기가 끝나면 공유하기를 선택해서 친구들과 공유할 링크를 만드세요. 재미있는 시간 되세요!
    mc_congrats_no_share:
      1:
        image: notes/mc_congrats_no_share_1.JPG
        text: 축하해요! 지금까지 여러분은 컴퓨터 공학의 기본적인 것들 몇 개를 배웠어요.
      2:
        image: notes/mc_congrats_no_share_2.JPG
        text: 이제 이 블록들을 이용해서 원하는 걸 만들 수 있어요. 더 이상 지시 사항이나 풀어야 할 퍼즐도 없어요. 여러분이 원하는 어떤 것이든 만들 수 있어요. 선택은 여러분에게 달렸어요.
      3:
        image: notes/mc_congrats_no_share_3.JPG
        text: '[학생들] 거의 다 돼가요. 털 깎기. 전 횃불로 L자를 만들었어요. 전 자작나무 판자로 A자를 만들었어요. 돼요, 진짜 돼요. 우리는 양털로 집을 만들었어요!'
      4:
        image: notes/mc_congrats_no_share_4.JPG
        text: 이제 여러분은 원하는 건 뭐든 만들 수 있어요. 마음껏 즐겨보세요!
    gumball_intro:
      1:
        image: notes/gumball_intro_1.JPG
        text: 만약 여러분만의 게임을 만들고 싶다면 그것은 정말 쉽습니다. 약간의 기초적인 프로그래밍만으로 여러분이 원하는 모든 것을 만들 수 있고, 여러분이 창작한 게임을 시작할 수 있습니다.
      2:
        image: notes/gumball_intro_2.JPG
        text: 좋아하는 비디오 게임이 있나요? 우리는 Play Lab 에서 그런 게임을 만들기 위해서 한 단계씩 배워 나갈 것입니다. 좋은 게임들은 스토리가 있고, 모든 스토리에는 주인공 캐릭터들이 있습니다. 캐릭터들은 말하고, 이동하고, 다른 캐릭터들과 인터랙티브하게 상호작용합니다. 그리고 게임 스코어 포인트는 게임의 규칙에 따라 달라집니다. 오늘 우리는 스마트폰에서 실행되고 공유될 수 있는 게임을 한 단계씩 만들어 나가 볼 것입니다. 게임 속 재미있는 캐릭터들을 이용해 게임을 만들어보세요.
      3:
        image: notes/gumball_intro_3.JPG
        text: 오늘 우리는 어떻게 이러한 일들을 모두 할 수 있는지를 재미있는 배우와 함께 하나씩 배우게 될 것입니다. 그리고나서 휴대전화에서 재생되고 공유될 수 있는 스크래치로 게임을 제작해 보세요.
      4:
        image: notes/gumball_intro_4.JPG
        text: 화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다.
      5:
        image: notes/gumball_intro_5.JPG
        text: 가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 코드입니다.
      6:
        image: notes/gumball_intro_6.JPG
        text: 오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다.
      7:
        image: notes/gumball_intro_7.JPG
        text: 처음 시작하기 위해서, 사용할 블럭들을 실행하면 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다.
      8:
        image: notes/gumball_intro_8.JPG
        text: '첫 번째 퍼즐에서 우리는 "말하기" 블록을 "~할 때 실행" 블록에 붙이고 메세지를 입력하여 배우가 무언가를 말하도록 만들 것입니다. 블록이 제 자리에 놓여지고 난 후, 프로그래밍 한 것을 보려면 실행 버튼을 누르세요.'
      9:
        image: notes/gumball_intro_9.JPG
        text: 시작하고나서 마지막 쯤에는, 가능한 캐릭터들을 이용해 게임을 만들고, 인터랙티브하게 움직이고, 점수를 올리거나, 발사체들을 던지고.. 서로 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요.
    gumball_events:
      1:
        image: notes/gumball_events_1.JPG
        text: 이제 우리는 모든 게임프로그래머들이 매일 사용하는 것에 대해서 배울 것입니다. 이벤트라고 하는 것들입니다. 하나의 이벤트는 프로그램이 어떤 사건이 일어났을 때, 어떻게 해야하는지 프로그램에게 알려줄 때 사용하는 것이라고 볼 수 있는데, 게임의 경우에는 어떤 동작을 하게 되는 것이라고 볼 수 있습니다.
      2:
        image: notes/gumball_events_2.JPG
        text: 여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다.
      3:
        image: notes/gumball_events_3.JPG
        text: '이제, 캐릭터를 클릭하면 뭔가 말하도록 해보세요. "클릭하면" 블록에 "말하기" 블록을 붙여 사용하면 됩니다. 플레이어가 클릭하면 이 블록에 붙여져 있는 모든 블록들이 실행될 것입니다.'
      4:
        image: notes/gumball_events_4.JPG
        text: 방향키 누름 블록이 있습니다. 이 블록들에 이동하기 블록을 붙이면 방향키를 눌렀을 때, 위로, 아래로, 왼쪽으로, 오른쪽으로 이동시킬 수 있습니다. 한 단계씩 여러분이 만든 게임이 더 인터랙티브하게 변화해 갈 것입니다.
    gumball_repeat:
      1:
        image: notes/gumball_repeat_1.JPG
        text: 여러분들은 어떤 작업을 무한히 반복한다는 것을 상상해 본 적이 있나요? 다행히도 여러분은 전혀 그럴 필요가 없습니다. 컴퓨터들이 그렇게 반복하는 것을 아주 잘하기 때문입니다.
      2:
        image: notes/gumball_repeat_2.JPG
        text: 이것은 무한반복 블록입니다. 이 블록 안에 있는 어떤 것이든 이 게임 안에서 끝없이 실행됩니다. 만약에 게임을 하는 사람이 아무 것도 하지 않아도 주인공이 무언가를 반복적으로 하길 원한다면 우리는 그 블록들을 무한반복 블록 안에 넣으면 됩니다.
      3:
        image: notes/gumball_repeat_3.JPG
        text: 이 다음 퍼즐에서 우리의 목표는 주인공이 일을 계속하도록 돕는 것입니다. 반복문이 어떻게 동작하는지에 대한 학습은 여러분이 자신의 게임을 만들 때 아주 많은 양의 시간을 절약해 줄 것입니다.
