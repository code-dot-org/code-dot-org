#TODO: Wrap numeric keys in quotes & rectify translations on Crowdin.
#Why? Well...
#1) Numeric keys in Yaml are loaded as Fixnums, not strings.
#2) Rails' i18n can only look up string or symbol keys.
#3) Crowdin proofreaders are translating filepaths, despite being hidden.
ko:
  slides:
    maze_intro:
      1:
        image: 'notes/hoc1_1.jpg'
        text: "Hour of code 에 오신 것을 환영합니다. 프로그래밍의 재미를 느껴 보세요."
      2:
        image: 'notes/hoc1_2.jpg'
        text: "코드를 작성하기 위해, 드래그 & 드롭 방식의 비주얼 프로그래밍 언어인 블러클리(Blockly)를 사용합니다."
      3:
        image: 'notes/hoc1_3.jpg'
        text: "대부분의 프로그래밍언어들은 텍스트로 작성해야 하지만, 블러클리는 그래픽 방식의 블럭들을 이용해 프로그래밍 합니다. 각 각의 블럭들은 실제 프로그래밍언어(자바스크립트) 코드와 1:1로 대응합니다."
      4:
        image: 'notes/hoc1_4.jpg'
        text: "화성 탐사선 제어 프로그램과 같이 어디서나 사용될 수 있는, 프로그램들을 만들기 위해 필요한기초적인 개념들과, 컴퓨터과학(정보과학)의 프로그래밍과 알고리즘에 대해 간단히 경험할 수 있습니다."
      5:
        image: 'notes/hoc1_5.jpg'
        text: "프로그램은 컴퓨터가 실행해야하는 명령들의 집합이라고 할 수 있습니다."
      6:
        image: 'notes/hoc1_6.jpg'
        text: "처음 만드는 프로그램의 목표는, 앵그리버드를 움직여 초록 돼지를 잡는 것 입니다."
      7:
        image: 'notes/hoc1_7.jpg'
        text: "왼쪽은 프로그램이 실행되는 미로입니다. 각 퍼즐의 목표들은 미로의 아래쪽에 나타납니다."
      8:
        image: 'notes/hoc1_8.jpg'
        text: "가운데 도구상자는 앵그리버드를 움직이기 위한 명령들이 있습니다. 이 블럭들을 사용해 프로그램의 코드를 만들 수 있습니다."
      9:
        image: 'notes/hoc1_9.jpg'
        text: "오른쪽은, 프로그램을 만들기 위해 도구 상자에서 블럭들을 꺼내어 놓는 곳입니다. 블럭을 삭제하려면, 구석에 있는 휴지통에 버리면 됩니다."
      10:
        image: 'notes/hoc1_10.jpg'
        text: "하나의 블럭은 하나의 명령을 의미합니다. \"앞으로 이동하기\" 블럭을 오른쪽의 프로그래밍 영역에 가져다 놓은 후, \"프로그램 실행\"을 누르면, 앵그리버드가 한 칸 앞으로 이동합니다."
      11:
        image: 'notes/hoc1_11.jpg'
        text: "하나 이상의 동작을 실행하기 위해서, 여러 개의 블럭들을 프로그래밍 작업공간에 드래그해 넣고 서로 붙이면 됩니다. 플래피 버드를 동작시키는 명령어들은 위에서 아래로 순서대로 실행될 것입니다."
      12:
        image: 'notes/hoc1_12.jpg'
        text: "프로그램을 실행시켜 본 후, 수정하거나 다시 실행 하고 싶으면, \"처음 상태로\" 버튼을 누르면 됩니다."
      13:
        image: 'notes/hoc1_13.jpg'
        text: "자! 이제, 초록 돼지를 잡으러 갑시다!"
    artist_intro:
      1:
        image: 'notes/stage5_1.jpg'
        text: "안녕하세요. 저는 JR 입니다! 카레이싱 경주에서 우승하기 위해서, 카레이서 팀은 반드시 컴퓨터과학(정보과학)이 필요합니다. 컴퓨터과학(정보과학)을 활용해서 자동차를 더 빠르게 달릴 수 있도록, 자동차에서 보내지는 데이터들을 분석해야하기 때문입니다."
      2:
        image: 'notes/stage5_2.jpg'
        text: "이번 퍼즐들에서는, 선을 그리며 돌아다니는 예술가가 되어 보세요."
      3:
        image: 'notes/stage5_3.jpg'
        text: "이것은 \"앞으로 이동... 픽셀... \" 블럭입니다. 픽셀은 여러 분이 보고 있는 화면을 구성하는 아주 아주 작은 점들입니다."
      4:
        image: 'notes/stage5_4.jpg'
        text: "이 블럭은 \"오른쪽으로 90도 만큼 돌아라!\" 라는 명령을 의미합니다. 미로 퍼즐에서 \"왼쪽/오른쪽으로 돌기\" 블럭을 사용했던 것과 똑같이 돌려줍니다."
      5:
        image: 'notes/stage5_5.jpg'
        text: "블럭들에 나타나있는 아래쪽 삼각형을 눌러보면, 거리나 각도를 원하는 만큼 지정할 수 있습니다. 새로운 블럭들을 연습하면서 익숙해져 보세요."
    farmer_intro:
      1:
        image: 'notes/stage9_1.jpg'
        text: "안녕하세요. 저는 파올라입니다! 이번 퍼즐들에서는 농작물을 기르기 위해서 밭 전체를 고르게 만들어야 하는, 농부 아가씨가 되어 보세요."
      2:
        image: 'notes/stage9_2.jpg'
        text: "여러분들은 농부 아가씨가 흙더미와 구덩이를 모두 없앨 수 있게 도와야 합니다."
      3:
        image: 'notes/stage9_3.jpg'
        text: "새롭게 사용할 수 있는 블럭은, 흙더미를 1번 치우거나 구덩이를 1번 메웁니다."
      4:
        image: 'notes/stage9_4.jpg'
        text: "흙더미의 크기, 구덩이의 깊이가 다르기 때문에 어떤 크기인지 알려주어야 합니다."
    flappy_intro:
      1:
        text: "안녕하세요 저는 케이티입니다. 컴퓨터 과학의 재미있는 점 하나를 이야기하자면 컴퓨터 프로그램이 사람이 원하는데로 상호작용을 하도록 만들 수 있다는 것입니다."
      2:
        text: "컴퓨터나 스마트폰을 클릭하거나 문자를 입력하면 이벤트라는 것이 발생합니다. 이러한 이벤트가 발생했을 때 실행시킬 수 있는 코드들을 마음대로 결정할 수 있습니다."
      3:
        text: "예를 들어, \"마우스가 클릭되었을 때, 소리를 출력해라.\"와 같은 이벤트 핸들러를 사용할 수 있습니다."
      4:
        text: "플래피버드(FlappyBird) 게임을 들어본 적이 있나요? 이벤트 핸들러들을 이용해서 자기만의 플래피버드 프로그램을 만들어 보도록 할 것입니다."
      5:
        text: "드래그/드롭하는 블럭들은 컴퓨터가 수행해야할 명령들을 의미합니다. 블럭들은 실제 코드로 변환되어 실행됩니다."
      6:
        text: "코드 블럭 편집창을 보면, 연두색 블럭들이 있는데 이것이 이벤트 핸들러입니다."
      7:
        text: "마우스를 클릭 했을 때 날개를 펄럭이려면, \"펄럭\" 블럭을 이벤트 핸들러에 붙이면 됩니다. 그렇게 하면 마우스를 클릭할 때마다 날개를 펄럭일 것입니다."
      8:
        text: "이 퍼즐들에서는 연두색의 새로운 이벤트 블럭이 주어지고, 원하는 이벤트가 발생했을 때에 따른 적당한 블럭을 생각해 사용할 수 있습니다."
      9:
        text: "이와 같은 선택 메뉴 화살표가 나타나면 설정을 바꿀 수 있다는 것을 의미합니다. 플래피가 땅에 닿았을 때 소리가 나도록 하는 것과 같은 것이 가능합니다."
      10:
        text: "마지막 퍼즐에서는 자신이 원하는 게임을 만들고 다른 친구들과 공유할 수 있습니다. 재미있게 즐기세요!"
    loop_times:
      1:
        image: 'notes/hoc2_1.jpg'
        text: "안녕하세요! 여러분? 저는 마크 입니다. 반복 실행(loop)에 대해 살펴 볼까요? 반복 실행 구조를 사용해, 원하는 작업을 수 천 번... 수 백 만 번, 반복하도록 할 수 있습니다."
      2:
        image: 'notes/hoc2_2.jpg'
        text: "이 퍼즐에서는 앵그리버드가 초록 돼지를 잡을 수 있도록, 5번 \"앞으로 이동\" 시켜야합니다."
      3:
        image: 'notes/hoc2_3.jpg'
        text: "새로운 \"반복(횟수)\" 블럭을 이용해서 해결 할 수 있습니다."
      4:
        image: 'notes/hoc2_4.jpg'
        text: "\"앞으로 이동하기\" 블럭 5개를 하나로 붙여 사용하는 대신..."
      5:
        image: 'notes/hoc2_5.jpg'
        text: "\"앞으로 이동하기\" 블럭 1개를  \"반복(횟수)\" 블럭 안에 집어 넣고, 반복할 횟수를 숫자로 입력하면 됩니다."
      6:
        image: 'notes/hoc2_6.jpg'
        text: "그리고 이렇게 하는 것은 매우 중요합니다: 여러 개의 명령 블럭을 \"반복(횟수)\" 블럭 안에 넣어 실행시킬 수 있기 때문입니다."
      7:
        image: 'notes/hoc2_7.jpg'
        text: "\"반복(횟수)\" 블럭을 잘 사용해 보세요!"
    loop_until:
      1:
        image: 'notes/hoc3_1.jpg'
        text: "안녕하세요? 저는 크리스 입니다. 저는 마이애미 히트(Miami Heat)에서 일하기 전에, 조지아 공과대학(Georgia Tech)에서 컴퓨터과학(Computer Science) 분야를 공부했습니다. 새로운 블럭인 \"반복(~할 때까지)\" 블럭을 살펴보도록 하겠습니다."
      2:
        image: 'notes/hoc3_2.jpg'
        text: "앵그리버드가 초록 돼지를 잡기 위해, 이동해야하는 거리를 모른다면 어떻게 해야 할까요?"
      3:
        image: 'notes/hoc3_3.jpg'
        text: "\"반복(~할 때까지)\" 블럭 안에 \"앞으로 이동하기\" 블럭을 넣으면, 초록 돼지를 붙잡을 때 까지... 앵그리버드가 앞으로 이동하게 됩니다."
      4:
        image: 'notes/hoc3_4.jpg'
        text: '이렇게 하는 것은 매우 중요합니다: 이전과 마찬가지로, 여러 개의 블럭들을 "반복(~할 때까지)" 블럭 안에 넣어서, 원하는 작업들을 반복시킬 수 있기 때문입니다.'
    if:
      1:
        image: 'notes/hoc4_1.jpg'
        text: "안녕하세요? 저는 빌 입니다! 이제 새로운 기초 개념들을 배워 봅시다: \"만약\" 명령문입니다. 이 명령문을 이용해서, 컴퓨터가 생각하는 것처럼 만들 수 있습니다."
      2:
        image: 'notes/hoc4_2.jpg'
        text: "\"만약\"? 이라는 생각은 매우 일상적입니다. \"만약\"에 밖에 비가 내리면? 우산을 가지고 나가야 합니다."
      3:
        image: 'notes/hoc4_3.jpg'
        text: "좀비에게, \"앞에 길이 있는지\", \"왼쪽에 길이 있는지\"를 먼저 확인하게 한 후, 그 방향으로 회전시킬 수 있습니다."
      4:
        image: 'notes/hoc4_4.jpg'
        text: "그렇게 만들려면, \"만약\" 블럭 안에 \"왼쪽으로 돌기\" 블럭을 넣으면 됩니다."
      5:
        image: 'notes/hoc4_5.jpg'
        text: "그 다음, \"앞으로 이동\" 블럭을 그 위에 붙이고, \"반복(횟수)\" 블럭 안에 넣으면.. 좀비가 움직일 때마다 길을 확인한 다음, 그 쪽으로 움직이게 할 수 있습니다. \"반복(횟수)\" 명령 안에서, 움직일 때마다 이동 방향을 결정하도록 하는 작업은 매우 중요합니다."
      6:
        image: 'notes/hoc4_6.jpg'
        text: "컴퓨터과학(정보과학)에서 \"만약\" 명령은  매우 중요합니다. 제가 처음 만들었던 프로그램 중 하나가, 3*3 크기의 표 안에 O와 X를 번갈아 작성해 넣는 틱택토(tic-tac-toe) 게임이었는데, 그 프로그램에서, 어떤 사람이 이겼는지를 \"만약\" 명령이 결정해 주었습니다. \"만약\" 블럭은 이긴 사람을 결정하는 역할을 해 줄 수 있습니다."
      7:
        image: 'notes/hoc4_7.jpg'
        text: "\"만약\" 블럭을 재미있게 사용해 보세요!"
    if_else:
      1:
        image: 'notes/hoc5_1.jpg'
        text: "안녕하세요? 저는 살로니 에요. 저는 건강/신약개발 분야에서 컴퓨터과학(정보과학)에서 배운 것들을 활용했어요. \"만약.. 아니면\" 블럭을 어떻게 사용할 수 있는지 살펴보도록 하죠. \"만약\" 블럭과 비슷하지만, \"아니면\" 부분이 더 있어요."
      2:
        image: 'notes/hoc5_2.jpg'
        text: "\"실행\" 부분에 \"앞으로 이동\" 블럭을 넣고, \"왼쪽으로 회전\" 블럭을 \"아니면\"이라고 쓰여진 부분에 넣으면, 좀비는 2가지 경우 중에서 하나 만 선택하게 되요. 만약 앞에 길이 있으면, \"앞으로 이동\"하고, 아니면(즉, 앞에 길이 없으면), \"왼쪽으로 회전\"을 하게 되요."
      3:
        image: 'notes/hoc5_3.jpg'
        text: "\"만약\" 블럭과 똑같이, \"만약~아니면\" 블럭 안에 \"반복\" 블럭들을 넣어 좀비를 이동시킬 수 있습니다. \"만약-아니면\" 블럭을 이용해 회전할 곳인지 아닌지 계속 확인하게 됩니다."
      4:
        image: 'notes/hoc5_4.jpg'
        text: "자 이제, 좀비들에게 가봅시다!"
    if_else_scrat:
      1:
        text: "하나의 만약-아니면(if-else) 조건/선택실행문은 2가지 중 하나를 반드시 선택/실행하게 됩니다. 자 이제 우리 친구 다람쥐 스크랫(scrat)과 함께 만약-아니면 조건/선택실행문을 어떻게 사용하는지 알아봅시다."
      2:
        text: "이 블럭은 \"만약\" 블럭과 같은 것처럼 보이지만, 그 아래에 \"그렇지 않으면\" 부분이 더 있습니다. \"실행\"이라고 쓰여있는 부분에 \"앞으로 이동\" 블럭을 넣고, \"그렇지 않으면\" 부분에 \"오른쪽으로 회전\" 블럭을 넣으면, 다람쥐 스크랫은 앞쪽에 길이 있으면 앞으로 이동하라는 것을 의미합니다. 앞쪽에 길이 없으면, 스크랫은 오른쪽으로 회전 할 것입니다."
      3:
        text: "조건/선택에 따라 2가지 동작 중 반드시 하나를 결정합니다. 그리고 \"만약\" 블럭과 거의 똑같습니다, \"만약-아니면(if-else)\" 블럭안에서 \"반복(repeat)\" 블럭들을 사용할 수 있습니다."
      4:
        text: "이제 다람쥐 스크랫이 도토리를 잡을 수 있게 도와주세요!"
    function:
      1:
        image: 'notes/stage13_1.jpg'
        text: "안녕하세요. 저는 인스타그램(Instagram)에서 엔지니어로 일하고 있는 브리나입니다. 함수는 많이 사용하는 명령들을 원하는  이름으로 정의해 둔 것으로, 필요한 명령 블럭들을 모두 사용할 필요 없이, 미리 정의해 둔 블럭을 하나 만 사용해서 같은 작업들을 실행할 수 있게 해 줍니다."
      2:
        image: 'notes/stage13_2.jpg'
        text: "이제, 어떤 함수를 만드는 방법을 살펴보겠습니다. 함수가 실행 해야하는 명령들은, 별 모양이 그려져 있는 블럭을 이용해 만들 수 있습니다. 그리고 그렇게 만든 함수의 이름도 지어 넣을 수 있습니다."
      3:
        image: 'notes/stage13_3.jpg'
        text: "별이 그려져 있는 함수 정의 블럭 안에 넣어진 블럭들은, 그 함수가 실행될 때 실행해야 할 명령들을 의미합니다. 따라서, \"메우기 5번\" 이라는 함수는 \"반복(횟수)\" 블럭과 \"메우기\" 블럭으로 채워져(정의되어) 있는 것입니다."
      4:
        image: 'notes/stage13_4.jpg'
        text: "하지만, 이렇게 만들어(정의해)두기만 해서는 실행하지 않습니다. 함수 분류에서 \"메우기 5번\" 이라는 함수 블럭을 끌어와서 사용해야만 실행이 됩니다.  "
      5:
        image: 'notes/stage13_5.jpg'
        text: "자 이제, 재미(\"fun\")있게 함수(\"FUNction\")를 사용해 보세요! "
    loop_while:
      1:
        image: 'notes/stage9_5.jpg'
        text: "안녕하세요? 마킨데입니다. 이번에는 \"반복(~인 동안)\" 블럭에 대해서 알아보겠습니다 "
      2:
        image: 'notes/stage9_6.jpg'
        text: "\"반복(~인 동안)\" 블럭은 어떤 상황에서 계속 반복 해야하는 명령들을 넣을 수 있게 해 줍니다. 반복 해야 하는 조건이 블럭 위에 적혀있고, 그 상황이 참(TRUE)이면 계속 반복시켜줍니다."
      3:
        image: 'notes/stage9_7.jpg'
        text: "예를 들어, 농부 아가씨가 흙더미 위에 있다면, 계속해서 \"치우기 1번\"을 수행할 것입니다."
    loop_for:
      1:
        image: 'notes/stage11_1.jpg'
        text: "안녕하세요. 트리나입니다. 저는 픽사(Pixar)에서 일하고 있는데, 슈렉을 비롯한 여러 가지 애니메이션을 만드는 작업을 해 왔습니다."
      2:
        image: 'notes/stage11_2.jpg'
        text: "이건 \"카운터\" 라는 반복 블럭입니다. 이 카운터 블럭을 사용하면 원하는 작업을 반복할 수 있는데,  반복 할 때마다 어떤 값을 조금씩 바꿔가면서도 이용할 수 있습니다. "
      3:
        image: 'notes/stage11_3.jpg'
        text: "이 예제에서, \"카운터\" 반복 블럭에는 \"카운트 : 50 부터 90까지, 증가 10\"라고 쓰여 있여있고, 그 안에 \"사각형 그리기\" 블럭이 들어있습니다. 변수 분류에서 \"카운터\" 블럭을 가져와 \"길이\" 부분에 넣어보세요."
      4:
        image: 'notes/stage11_4.jpg'
        text: "이렇게 하면, 예술가가 50 픽셀 길이인 사각형 부터 그리기 시작해서, 10 픽셀 크기만큼 늘려 60 픽셀 길이의 사각형을 그리고, 다시 10 픽셀 크기만큼 늘려 70 길이로 그리고.... 그렇게 반복하면서 90을 넘지 않을 때까지 증가시키면서 반복합니다. 그래서 50, 60, 70, 80, 90 길이의 사각형들을 그리게 되는 것이죠."
    parameters:
      1:
        image: 'notes/stage15_1.jpg'
        text: "안녕하세요. 징가(Zynga)에서 엔지니어로 일하고 있는 자넷입니다."
      2:
        image: 'notes/stage15_2.jpg'
        text: "크기가 다른 삼각형들을 아주 많이 그려야 한다면 어떻게 해야할까요?"
      3:
        image: 'notes/stage15_3.jpg'
        text: "일일이 모두 각각 코드를 작성하는 방법도 있지만, 값을 전달받는 함수를 사용할 수도 있습니다."
      4:
        image: 'notes/stage15_4.jpg'
        text: "그러기 위해, \"삼각형 그리기\" 함수의 파랑별을 눌러 보세요. 그 다음에 \"전달받을값\"(input name)을 \"전달값\"(input) 블럭에 끼워 넣으세요."
      5:
        image: 'notes/stage15_5.jpg'
        text: "그 다음에 \"x\"라고 쓰여진 부분을 \"길이\"(length)라고 수정하면 됩니다. 그렇게 하면 함수에게 전달되는 값을 사용할 수 있게 됩니다."
      6:
        image: 'notes/stage15_6.jpg'
        text: "그 다음 다시 별을 누르고, 변수 분류에 들어가서 \"길이\"(length) 블럭을 가져와서 \"앞으로 이동\"(move forward) 블럭에 넣어주면 됩니다. 이전 블럭은 치워버리면 됩니다."
      7:
        image: 'notes/stage15_7.jpg'
        text: "함수 분류를 열어 \"삼각형 그리기 사용:\" 블럭을 가져와 사용하면 됩니다."
      8:
        image: 'notes/stage15_8.jpg'
        text: "또한, 삼각형의 크기를 원하는데로 바꾸기 위해서, 계산 블럭을 사용할 수 있습니다."
    hoc_wrapup:
      1:
        image: 'notes/hoc6_1.jpg'
        text: "축하합니다! 여러분은 마지막 퍼즐을 해결함으로서, 복잡한 미로/동굴/터널 속에서도 스스로 길을 찾아 움직일 수 있는 로봇을 만들 수 있게 되었습니다. 좀비, 새, 화성탐사선, 스스로 움직이는 자동차 등에도 모두 적용시킬 수 있겠죠?"
      2:
        image: 'notes/hoc6_2.jpg'
        text: "지금까지 사용한 기초적인 개념들은, 매일 사용하는 앱(응용프로그램)들을 만들어 내는 가장 기본적인 방법들입니다. 지금까지 반복 실행을 위한, \"반복(횟수)\", \"반복(~할 때까지)\" 명령과 선택 실행을 위한 \"만약\", \"만약....아니면\" 명령들에 대해 배워 보았습니다."
      3:
        image: 'notes/hoc6_3.jpg'
        text: "처음 해 본, Hour of Code 가 재미있으면, http://code.org 를 통해 컴퓨터과학(정보과학)의 기초개념들을 더 배워보세요!  그 과정을 끝내고 나면, 프로그래밍을 위한 기초적인 지식을 모두 배울 수 있게 됩니다. 여러분들은 스마트폰 앱 만들기, 로봇 조종, 게임 만들기 등, 원하는 것을 모두 할 수 있는 기본적인 지식들을 얻게 되는 거에요!"
      4:
        image: 'notes/hoc6_4.jpg'
        text: "컴퓨터과학(정보과학)에서 배우는 지식과 기술들은 모든 사람들의 생활 방식을 바꿔가고 있습니다 : 프로그래밍은 재미있고, 창의적인 과정이며, 누구나 배울 수 있습니다!"
    20_wrapup:
      1:
        image: 'notes/bird.png'
        text: "프레젠테이션 준비 중!"
    frozen_intro:
      1:
        text: "안녕하세요, 제 이름은 린지입니다. 저는 모델이고, 연극도하고, 앱들을 직접만들고 있습니다. 얼음의 마술과 아름다움을 탐구하는 안나, 엘사와 함께 코드를 배워보세요."
      2:
        text: "스케이트를 타면서 눈송이들과 패턴을 만들고, 겨울왕국을 만들어서 친구들에게 보여주세요."
      3:
        text: "이제부터, 코드를 만들어낼 수 있는 기초/개념/원리들을 배우게 될 것입니다. 일반적인 프로그래밍은 텍스트(문자들)를 사용하지만, 여기서는 비주얼 블럭들로 프로그래밍하는 블러클리(Blockly)를 이용해 블럭들을 드래그 앤 드롭해서 프로그램을 만들 수 있습니다. 때때로 처음 배우는 대학생들도 해보는 방법입니다. 하지만, 여러분들도 똑같이 코드를 만들고 있는 것입니다."
      4:
        text: "하나의 프로그램은 컴퓨터가 실행해야 할 작업들을 알려주는 명령어들의 집합에 불과합니다. 자 이제, 엘사가 간단한 선을 그리도록 하는 코드, 프로그램을 만들어 봅시다. 이 간단한 방법을 이용해서 나중에 보다 복잡한 패턴들을 만들어낼 수 있게 될 것입니다."
      5:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 얼음 판입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다."
      6:
        text: "가운데 영역은 도구상자이고, 각각의 블록들은 엘사와 안나가 실행할 수 있는 동작들을 나타냅니다."
      7:
        text: "오른쪽의 아무것도 없는 흰 공간은 작업공간(workspace)이라고 부르고, 그 곳에서 프로그램의 코드를 만들게 될 것입니다. 얼음판에서 이리 저리 움직이기 위해, \"앞으로 이동\"블럭을 사용하게 될 것입니다."
      8:
        text: "여기 \"앞으로 이동\" 블럭의 의미는 \"앞으로 100 픽셀만큼 이동해라\" 입니다. \"실행하기\"를 누르면 어떤 일이 일어날까요? 화면에서 엘사가 어느 정도 만큼 앞으로 움직일 것입니다. 정확히 100 픽셀만큼 움직입니다! 픽셀은 기본적으로 컴퓨터 화면의 그림을 만들어내는 아주 작은 단위의 사각형을 의미합니다."
      9:
        text: "이 퍼즐에서 주어진 다른 블럭은 \"오른쪽으로 90도 만큼 회전하라\"라는 것을 의미합니다. \"오른쪽으로 회전\" 블럭을 사용하면 엘사가 오른쪽으로 어느 정도 회전합니다. 원하는 만큼 엘사가 회전하도록 할 수 있습니다. 회전할 각도는 엘사가 바라보고 있는 앞을 기준으로 측정됩니다. 따라서 이것은 90도 회전하는 것이고, 이것은 120도 만큼 회전하는 것입니다."
      10:
        text: "각 블럭에서 아래쪽 화살표 부분을 클릭하면 원하는 픽셀만큼의 거리나, 회전할 각도의 값을 바꿀 수 있습니다."
    frozen_loops:
      1:
        text: "안녕하세요! 저는 파올라라고 합니다! 컴퓨터들은 반복적인 작업을 진짜 아주 잘 합니다. 여러분들은 10, 20, 100까지 셀수 있습니다. 하지만 컴퓨터는 10억?, 1조 까지도 셀 수 있습니다. 컴퓨터는 전혀 지루해 하지도 않으면서 몇 초만에 다 셀 수 있습니다. 수를 세던, 그림을 그리던, 다른 어떤 것들을 하던지--컴퓨터들은 수백번~ 수십억번까지 반복해서 할 수 있습니다."
      2:
        text: "이러한 것을 프로그래밍에서 루프(loop)라고 합니다. 루프를 이용하면 원하는 코드를 계속, 계속 반복해서 실행할 수 있습니다. 다음 퍼즐에서, 여러분의 목표는 \"반복(Repeat)\" 블럭을 이용해서 안나가 사각형을 그릴 수 있도록 도와주는 것입니다."
      3:
        text: "\"반복(Repeat)\" 블럭 안에 넣는 블럭들은 순서대로 실행되면서, 원하는 만큼 반복적으로 실행될 것입니다."
      4:
        text: "사각형을 그리기 위해서, \"앞으로 이동\" 블럭과 \"오른쪽으로 회전\" 블럭을 4번 사용할 수 있습니다. 하지만, 컴퓨터에게 \"앞으로 이동\", \"오른쪽으로 90도 회전\"을 한 번 실행시켰다면, 똑같은 방법을 4번 반복하라고 하면 매우 편리합니다. 그렇게 하기 위해, \"앞으로 이동\"블럭과 \"오른쪽으로 회전\" 블럭을 \"반복(Repeat)\" 블럭 안에 넣으면 됩니다."
      5:
        text: "\"반복(Repeat)\" 블럭안에 반복되어야 할 수를 마음대로 넣을 수 있습니다. 넣은 수만큼 반복해서 실행할 것입니다."
    frozen_functions:
      1:
        text: "안녕하세요. 저는 크리스 보쉬(Crish Bosh) 입니다.  저는 프로 농구 선수이면서, 대학에서 코딩을 하고 있습니다."
      2:
        text: "컴퓨터과학(정보과학)에서 가장 중요한 기초/개념/원리들 중 하나는 새로운 명령어들을 정의해서 만들어내는 것입니다. 대부분의 컴퓨터 프로그래밍언어는 기껏해야 100 단어 보다 작은 명령어들만으로 구성되어있습니다. 그리고 실제로 예술적이면서도 마법같은 것은 이러한 블럭들을 이용해, 자신이 원하는 새로운 블럭을 만들어낼 수 있다는 것입니다."
      3:
        text: "일단, 한 번만 컴퓨터가 실행해야할 명령들을 컴퓨터에게 알려주었다면, 그러한 명령들을 묶어 새로운 이름을 붙일 수 있고, 그렇게하면 나중에 매우 쉽게 반복시킬 수 있게 됩니다. 명령들을 조합하고 거기에 원하는 이름을 붙이면, 그것을 바로 함수(function)라고 합니다."
      4:
        text: "안녕하세요, 저는 제스입니다. 블럭을 사용해 프로그래밍을 할 때 어떤 동작들을 여러 번 반복해야 한다면 함수를 사용해 볼 수 있습니다. 예를 들어, 앞에서 만들었던 사각형을 그리는 코드를 생각해보세요."
      5:
        text: "이 코드는 \"사각형 그리기\"라는 함수로 정의할 수 있습니다. "
      6:
        text: "이제, 여러개의 사각형을 만들기 위해, 여러번 사용할 수 있는 새로운 블럭이 만들어졌습니다."
      7:
        text: "여러 가지의 많은 단순한 모양들은 보다 복잡한 패턴들을 만들어내는데 사용될 수 있습니다. 다음 퍼즐들에서는 바로 전에 원을 만들기 위해 작성했던 코드를 새로운 함수로 정의하고, 그 함수를 이용해서 서로 다른 크기의 원들을 만들 수 있게 됩니다. 그 함수를 이용해서 복잡하고 아름다운 패턴의 눈을 만들어낼 수 있도록 엘사를 도와주세요."
    playlab_intro:
      1:
        text: "이제 플레이 랩을 이용해 게임을 만들어보려고 합니다. 좋은 게임은 이야기가 있고, 모든 이야기들에는 주인공 캐릭터들이 있습니다. 이제 캐릭터들을 마녀, 외계인, 동물들로 설정하고 말하고, 움직이고 서로 서로 같이 이야기/반응하게 할 수 있습니다. 이 튜토리얼을 마칠 때 쯤이면 여러분들은 처음부터 시작해서 게임을 만들고 친구들에게 공유할 수 있게 될 것입니다."
      2:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다."
      3:
        text: "가운데 공간은 도구 상자이며, 이 블럭들은 각각 어떤 코드 조각을 의미합니다. 오른쪽의 흰색 빈 공간은 작업공간(workspace)이라고 부르는 곳으로 그곳에서 프로그램을 만들게 됩니다."
      4:
        text: "처음 시작하기 위해서, 사용할 블럭들을 \"실행하면\" 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다."
      5:
        text: "이 첫번째 퍼즐에서, 캐릭터는 펭귄이고 말하기(say) 블럭을 이용해 \"Hello!\"라고 말하도록 만들것입니다. 실행하면 블럭에 붙인 후 \"Hello\"라고 입력하면 됩니다. 그리고 오른쪽으로 이동, 왼쪽으로 이동 블럭을 이용해 펭귄을 움직이도록 할 수도 있습니다. 블럭을 붙여본 후에 실행하기 버튼을 눌러 어떻게 실행되는지 살펴보세요."
      6:
        text: "시작하고나서 마지막 쯤에는, 여러분이 직접 여러가지 캐릭터들을 이용해 게임을 만들고, 표정을 바꾸게하고, 점수를 올리거나 서로 파이어볼을 쏘거나 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요."
    playlab_events:
      1:
        text: "이제, 모든 게임 프로그래머들이 매일 매일 사용하는 것들을 배워보도록 하겠습니다. 이벤트라고 합니다. 하나의 이벤트는 어떤 일이 일어났는지 여러분이 만든 프로그램에게 알려줄 수 있습니다. 따라서, 어떤 일(이벤트)가 일어났을 때 어떤 동작을 실행하게 할 수 있는 것입니다."
      2:
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      3:
        text: "이제, 캐릭터를 클릭했을 때 지구인들에게 인사하는 우주 로봇을 만들어보도록 하겠습니다. \"클릭하면\"이라는 블럭을 이용하고 \"말하기\"블럭을 붙이면 됩니다. 플레이어가 우주 로봇을 클릭하면, \"클릭하면\" 블럭에 붙어있는 모든 것들이 순서대로 실행될 것입니다. 여러분의 외계인 캐릭터가 어떻게 동작할까요?"
      4:
        text: "\"방향키 누름\"블록이 있습니다. 이 블록들에 \"이동하기\" 블록을 붙이면 방향키를 눌렀을 때, 위로, 아래로, 왼쪽으로, 오른쪽으로 이동시킬 수 있습니다. 한 단계씩 여러분이 만든 게임이 더 인터랙티브하게 변화해 갈 것입니다."
    playlab_repeat_forever:
      1:
        text: "이번에는 \"무한 반복\"블럭입니다. 이 블럭의 안에 넣은 블럭들은 게임이 실행되는 동안 계속해서 무한히 실행될 것입니다."
      2:
        text: "만약에 캐릭터를 어떤 동작에 대해서 반복적으로 실행하게 하려면, 반복시킬 블럭들을 \"무한 반복\" 블럭 안에 넣으면 됩니다."
      3:
        text: "이 퍼즐에서, 우리의 목표는 마법사 캐릭터가 왕국의 경계를 순찰하도록 하는 것입니다. 왼쪽에서 오른쪽으로 계속 반복해서 움직이도록 하는 것입니다. 반복 실행 명령어를 배우고 이용하면, 여러분이 만든 게임에서 일일이 모두 반복적으로 작성할 필요가 없이, 한 번만 작성한 후에 계속해서 여러번 사용할 수 있게 되는 것입니다."
    C1_artist_intro:
      1:
        text: "그리기 블록들이 있습니다. 회색 선들 위에 그리기 위해서 화가를 정확히 움직여주세요."
      2:
        text: "점프 블록들이 있습니다. 이 블록들을 사용하면 선을 그리지 않고 화가를 이동시킬 수 있습니다. 다음 회색 선으로 점프하는데 사용하세요."
    C1_bee_level_intro:
      1:
        text: "꿀벌들은 정말 멋진 곤충입니다. 다음 퍼즐들의 목표는 꿀벌을 꽃으로 이동시켜서 꽃꿀을 뽑고, 벌집으로 이동시켜서 꿀을 만드는 것입니다. \"꽃꿀 얻기\" 와 \"꿀 만들기\" 블록을 사용하면 됩니다."
      2:
        text: "모든 꽃은 서로 다른 양의 꽃꿀을 가지고 있습니다: 1, 2, 3, 또는 그 이상. 빨강 꽃의 모서리에는 꽃꿀의 양이 나타나 있다는 것을 알 수 있습니다. 앞으로 이동하기 전에 꽃의 꽃꿀을 모두 뽑아내세요. 그리고, 모든 벌집은 그 만큼의 꿀을 보관할 수 있습니다: 1, 2, 3, 또는 그 이상. 따라서, 해당 벌집이 보관할 수 있을 만큼 씩만 꿀을 만들어야 합니다."
      3:
        text: "모든 꽃꿀을 모아서 꿀을 만들어야 다음 퍼즐로 갈 수 있습니다. 이리 저리 살펴보고 \"꿀벌\" 프로그래머가 되어 보세요."
    C1_bee_loops:
      1:
        text: "반복 구조는 어떤 실행 내용을 반복하도록 하는 것입니다. 들어가서 조사하고, 구조를 살펴보고, 다시 나오는, 한 번의 과정을 여러 번 실행 시킬 수 있습니다.\n반복 구조 안에 넣으면, 똑같은 작업을 여러 번 실행할 수 있습니다."
      2:
        text: "이번 레벨에서는 꽃에서 3개의 꽃꿀을 모아야 합니다. \"꽃꿀 모으기\" 블록을 3번 사용하는 대신, 반복 블록을 사용해서 3번 반복시켜보세요. \"실행\"을 눌러 살펴보세요. 잘 했습니다!"
    C1_bigevent_unplugged:
      1:
        text: "이번 레슨의 제목은 큰! 이벤트 입니다. 우리가 프로그램들을 움직이고, 버튼이나 마우스를 눌러 이벤트들을 전달해서 프로그램의 실행을 변화시키는 것들에 대한 이야기입니다."
      2:
        text: "이번 레슨에서 여러분들은, 종이 리모트 컨트롤에 의해서 조종될 것입니다. 마치 실시간 비디오 게임과 비슷할 것입니다."
      3:
        text: "이벤트는 어떤 일이 일어나도록 하는 동작입니다. 여러분이 마우스를 클릭했을 때, 웹페이지가 로드 되는 것과 같습니다. 그것이 바로 이벤트입니다. 태블릿의 화면을 스크롤 하기 위해서 화면을 터치할 때, 그것도 이벤트입니다. 이벤트들은 사용자들이 프로그램의 동작을 제어할 수 있도록하는 훌륭한 방법입니다."
      4:
        text: "상황에 따라 대처해야하는 일들이 많이 있습니다. 배가 고프면 냉장고로 갑니다. 우체국 아저씨가 우편물 상자에 우편물을 집어넣으면, 그것을 가지러 갑니다. 그러한 모든 것들은 버튼을 누르거나 조이스틱을 움직이는 것과 같은 이벤트들입니다. 이러한 이벤트들은 어떤 작업을 하기 위해서 필요한 첫 시작 신호라고 볼 수 있습니다."
      5:
        text: "비디오 게임들에서 \"업데이트\"라는 이벤트는 1초에 30번 또는 60번 일어납니다. 비디오 게임 프로그래머에게는 버튼을 누르거나 조이스틱을 움직이는 것보다 더 중요합니다."
      6:
        text: "우리가 살펴보고자하는 메인 이벤트는 \"업데이트\"라는 신호 입니다. 아주 짧은 시간 동안에 조이스틱의 움직임을 체크합니다. 그렇게 \"이 프레임에서 누군가가 단추를 눌렀나? 그런가? 아닌가?\" 등을 확인할 수 있습니다. 이런 이벤트들이 없다면 게임 플레이어가 움직일 수도, 점프를 할 수도, 제어할 수도 없습니다. 비디오게임에서 화면을 바꿔 애니메이션을 보여줄 수도 없을 것입니다."
    C1_building_foundation:
      1:
        text: "여러분들은 모래 조각에서, 실패도 프로그램의 일부분이라는 것을 알았을 것입니다. 하지만 계속 노력하면, 점점 더 잘하게 되고 더 재미있게 됩니다. 이제 끊임없는 노력과 열정이라는 게임을 함께 살펴봅시다. 아주 재미있을 거에요."
      2:
        text: "이번 레슨의 제목은 기초 만들기 입니다. 이 레슨에서는 정말 어려운 작업을 하게 될 것입니다. 여러분들은 최대로 이 컵들 높이 정도 만큼의 구조로, 책의 무게를 견딜 수 있도록 하는 구조를 어떻게 만들어낼 지 생각해 내야 합니다."
      3:
        text: "만들어 낸 것이 원하는 대로 움직이지 않을 것입니다. 당황스럽고 포기하고 싶을 것입니다. 그런 순간들이 매우 많이 있을 수 있습니다. 하지만 계속 노력하고, 반복해서 최선을 다 한다면, 언젠가는 될 것이라는 것을 알고 있습니다."
      4:
        text: "끊임없는 노력과 열정은, 여러분들이 정말로 포기하고 싶을 때 포기하지 않게 해주는 힘이라고 할 수 있습니다. 여러분들이 지금까지는 없었던 새롭고 다른 것을 만들어내려고 한다면, 그 앞에는 수 많은 실패들이 놓여 있을 것입니다."
      5:
        text: "끊임없는 노력과 열정은, 실망하고 좌절해서 포기하려는 것이 아니라, 실패들로부터 더 배우고 계속 도전해 나가는 것을 선택하면서 만들어지게 됩니다. 실망과 좌절은 실제로는 그 근처에 멋진 세상이 있다는 것을 의미합니다. 그렇기 때문에.. 원하는 것을 얻기 전까지 포기하지 말고 힘내세요!"
    C1_getting_loopy:
      1:
        text: "안녕하세요. 여러분! 저는 일루미나티(iLuminati) 작품들을 만들어낸 마이랄 코트(Miral kotb) 입니다. 작품들을 만들기 위해서는 춤(dances) 과, 프로그래밍이 되는 라이트 슈트(lightsuits) 가 모두 필요합니다. 이건 반복이에요! 반복은 어떤 동작을 무한히 반복해 줍니다."
      2:
        text: "여러분들이 어떤 작업을 여러 번 반복할 때에는, 제가 훌라후프를 계속 돌리기 위한 동작을 하는 것처럼, 동작을 반복해서 실행하고 있는 것입니다. 이것이 반복입니다. 이것도 반복입니다. 이것도 반복입니다."
      3:
        text: "오늘 우리는 댄스 파티를 할 예정입니다. 새로운 춤을 반복적으로 동작할 것입니다. 반복. 이번에는 춤을 예로 들어 반복 구조들에 대해서 배울 것입니다. 여러분들은 춤을 완성하기 위해서, 몇 개의 쉬운 단계들을 따라가며 계속적으로 반복 할 것입니다."
      4:
        text: "여기에 여러분이 배워야 할 단계들이 있습니다. 손뼉을 쳐보세요. 머리 뒤로 손을 올려보세요. 손을 허리에 두세요. 왼손을 드세요. 오른손을 드세요. 정말 간단하죠? 그렇죠? 여러분은 어떤 춤의 동작들을 반복문 안에 넣어, 같은 내용을 짧게 만들 수 있습니다."
      5:
        text: "실제로 춤을 출 때에도 반복 구조들을 사용합니다. 댄서들은 웨어러블 컴퓨터들을 입고 있으며, 동일한 네트워크로 접속해 있습니다. 저는 반복을 이용해서 같은 댄서들의 불빛을 반복시킬 수 있습니다. 반복 구조 안에서 반복적으로 빛이 켜지는 시간을 조절할 수도 있는데, 6명의 댄서들의 빛이 켜지는 속도를 조절할 수 있습니다. 이러한 모든 것은 반복 구조들을 사용하기 때문에 가능합니다. 반복 구조들은 반복적인 작업을 짧고 쉽게 표현할 수 있게 해주기 때문에 컴퓨터과학에서 매우 중요합니다."
    C1_happy_maps_unplugged:
      1:
        text: "이번 레슨은 해피 맵 입니다. 조그만 털복숭이 친구인 플러브를 과일로 이동할 수 있도록 도와주세요."
      2:
        text: "플러브가 과일로 이동할 수 있도록 도와주세요. 어떤 화살표들을 사용해서 플러브를 이동시킬 수 있을지 생각해야 합니다. 플러브를 사과로 보내기 위해서, 어떤 방향으로 가야할까요? 따라 움직일 선을 그려보세요."
      3:
        text: "저 곳으로 이동하기 위해서는 방향을 회전시켜야 합니다."
      4:
        text: "문제를 풀기 위해 필요한 알고리즘을 지도 옆에 있는 화살표들 붙여 만들어보세요. 두 번째 것도 같은 것인데, 아래로 내려가는 것입니다."
      5:
        text: "이것은 마치 종이로 프로그래밍 하는 것과 같습니다. 그리고 실제로 그렇습니다!"
    C1_maze_debugging:
      1:
        text: "디버깅은 문제를 찾아내고 수정하는 것입니다. 문제들을 디버깅 많은 방법들이 있습니다. 가장 쉬운 방법 중 하나는, 무언가 잘못된 것을 찾을 때까지 한 단계씩 진행하는 것입니다. 저는 빔 위에서 백핸드스프링을 연습하려고 하는데 계속 떨어졌습니다."
      2:
        text: "저는 각 단계를 하나 하나씩 생각해 본 후에 저의 실수를 찾아냈습니다. 저는 빔 위에 정확히 손을 놓지 못하고 있었던 것이었습니다. 그래서 저는 빔 위에 놓는 손의 위치를 바꾸어 할 수 있는 다른 백 핸드 스프링을 연습해서 성공했습니다. 제 백 핸드 스프링의 잘못된 점을 찾아내서 너무 기뻤습니다."
      3:
        text: "디버깅에 대해서 배우기 위해서, 미리 몇 개의 블럭을 놓아두었습니다. 이 블록들로는 목표에 도달할 수 없다는 것을 알게 될 것입니다. 우리는 이 방법을 디버깅해서 고쳐야 합니다. 어떤 것이 잘못 되었을까요? 왼쪽으로 한 블록 더 이동해야 한다는 것을 금방 알 수 있습니다."
      4:
        text: "왼쪽으로 이동 블록을 추가해서 고친 후, 잘 되는지 실행시켜보세요. 예! 성공했네요."
    C1_maze_intro_sequencing:
      1:
        text: "이번 퍼즐에서, 여러분들은 새를 돼지에게 이동시켜야 합니다. 퍼즐을 살펴보고 어떤 방향으로 움직여야 될 지 찾아보세요."
      2:
        text: "도구상자에서 블록들을 드래그해서 작업공간으로 가져가야 합니다. \"실행하면\" 블록 아래에 붙이고, 정확하게 만들었다고 생각되면 \"실행\"을 눌러 새가 돼지에게 갈 수 있는지 확인해보세요."
    C1_maze_loops:
      1:
        text: "컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다."
      2:
        text: "예를 들어, 제가 페이스북의 모든 사람들에게 생일 축하 이메일을 보내려고 할 때, 그 사람들에게 모두에게 이메일을 따로 작성하려고 한다면, 100년 넘게 걸릴 수도 있습니다. 하지만, 코드 몇 줄이면 페이스북의 모든 사람들에게 생일 축하를 알리는 메일을 보내는 시스템을 만들 수 있습니다."
      3:
        text: "이 레벨에서 새를 돼지에게 이동시키기위해서... 작업 공간에 위쪽으로 이동하는 블록을 3개 사용하는대신, \"반복\" 블록을 사용할 것입니다. \"반복\" 블록을 작업공간에 가져간 다음에 3을 입력해보세요. 그 다음에 \"위로 이동\" 블록을 그 반복 블록 안에 넣은 다음에 \"실행\"을 눌러 제대로 동작하는지 살펴보세요. 축하합니다. 성공했습니다!"
    C1_moveitmoveit_unplugged:
      1:
        text: "이번 레슨은 움직여! 움직여! 입니다. 이번에는 장미 덩굴 미로에서 웃는 얼굴 지점으로 빠져나오도록 하는 프로그램을 만들어 볼 것입니다."
      2:
        text: "하지만 스마일리는 고개를 숙이고 있고, 오로지 1명만 저 곳에 갈 방법을 알고 있습니다. 이 프로그램을 시작시켜보세요."
      3:
        text: "프로그램은 기계가 실행할 수 있도록 코드화된 알고리즘입니다. 대부분의 사람들은 프로그램이 컴퓨터에서만 사용되는 것이라고 생각합니다. 컴퓨터에서 정말 잘 사용되지만, 다른 곳에서도 도움이 됩니다. 자신만의 게임을 만들거나, 여러분을 위해 일을 하는 로봇을 프로그램할 수도 있습니다."
    C1_going_places_safely:
      1:
        text: "저는 예레미아이고 7살이에요. 저는 엄마 컴퓨터를 가지고 노는 것을 좋아하지만, 컴퓨터를 사용하려면 항상 엄마의 허락을 받아야 해요. \"엄마, 컴퓨터 써도 되요? 어 물론이지!\""
      2:
        text: "저는 인터넷을 할 수 있는 엄마의 컴퓨터가 좋아요. 인터넷은 이웃과 비슷하다고 할 수 있습니다. 멋진 곳들을 방문할 수도 있고, 친구나 가족들과 이야기하고 많은 새로운 것들을 배울 수도 있습니다."
      3:
        text: "어제 저는 우리집 근처에 있는 동물원에 갔었습니다. 거기서 아기 얼룩말을 보았어요. 얼룩말 사진을 찍고, 줄무니 색을 바꾸고, 사진에 모자를 씌운 다음에 저의 재미있는 동물 컬렉션에 추가했답니다. 멋지죠! 그리고, 예전에 아주 먼곳으로 갔던 적이 있었어요. 케냐를 갔었습니다. 아프리카에 있는 나라인데, 아주 많은 얼룩말이 살고 있습니다."
      4:
        text: "저는 가끔 인터넷으로, 다른 주에 사는 제 할머니와 같은 제가 아는 사람들과 이야기를 합니다. 안녕하세요. 할머니! 할머니는 제 생일에 저에게 보내줄 쿠키를 만들고 계시네요. \"맛 있을 것 같아요, 저는 인터넷을 통해 냄새도 맡을 수 있으면 좋겠어요!\" 저는 인터넷을 통해서 제 사촌들과 같은, 다른 사람들과도 이야기할 수 있지만, 저는 확실히 아는 사람들과만 이야기 한답니다."
      5:
        text: "인터넷을 하면서 가장 좋아하는 것은, 재미있는 게임들을 하는 것입니다. 점수! 그리고, 어떤 모양을 그리거나, 새로운 것들을 만들고 친구들과 공유하는 것도 좋아합니다. 멋져요! 웹사이트들에 접속하면서 새로운 것들을 많이 배우지만, 저는 항상 저에게 적당한 사이트만 접속합니다. 와, 공룡들이네요!"
      6:
        text: "인터넷은 아주 아주 재미있는 곳이에요. 하지만, 여러분들이 집 주변의 길을 건널 때 안전에 조심해야하는 것처럼, 온라인에 접속해있을 때에는 매우 조심해야 합니다. 인터넷을 사용할 때 반드시 기억하고 조심해야할 3가지가 있습니다. 규칙 1: 항상 먼저 부모님께 물어봐야 한다. 규칙 2: 아는 사람들과만 이야기해야 한다. 규칙 3: 자신에게 적합한 곳에만 접속해야 한다."
      7:
        text: "와 너무 재미있었어요! 이제 저녁이네요. 이제 끝내야 할 것 같아요. 아 이제 다음에 언제 또 하게 될지 너무 기대되요."
    C1_pair_programming:
      1:
        text: "오늘 우리는 페어프로그래밍에 대해서 배워볼 것입니다. 페어프로그래밍은 두명이 한 팀으로 작업하게 됩니다. 왜 2명이 컴퓨터 하나를 사용하냐고요? 두 사람의 머리가 한 사람의 머리보다 더 좋기 때문입니다. 페어프로그래밍에서 여러분과 여러분의 짝은, 하나의 컴퓨터 앞에 같이 앉아서, 하나의 프로젝트에 대해서 함께 작업하게 될 것입니다."
      2:
        text: "페어프로그래밍에서는 마치 자동차 랠리 경주를 할 때 처럼, 한 사람은 운전자이고, 다른 한 사람은 동승자입니다. 운전자는 컴퓨터 앞에 앉아서 키보드와 마우스, 터치스크린을 이용해서 컴퓨터를 조작합니다. 동승자는 운전자를 도와서, 운전자가 궁금한 것들에 대해서 말해주고, 발생할 수 있는 오류들이나 실수들을 짚어주면 됩니다."
      3:
        text: "커뮤니케이션은 성공적인 페어 프로그래밍을 위한 열쇠입니다. 창피하게 만들지 말고, 이래라 저래라 지시하지 말아주세요. 누구나 그렇게 대우 받기 싫어하기 때문입니다. 서로 존중해 주세요. 여러분과 여러분의 짝은 항상 대화를 해야 합니다. 운전자는 자기가 무엇을 하고 있는지 설명할 수 있고, 동승자는 다음에 무엇을 해야하는지 제안하면서 서로 도울 수 있습니다."
      4:
        text: "동승자는 전체적인 큰 그림에 대해서 생각해야하고, 운전자는 자세한 사항에 대해서 집중해야 합니다. 두 사람의 역할 모두 중요합니다. 페어프로그래밍은 두 명이 한 팀으로 협력해서 작업하는 것입니다."
    C1_planting_seed:
      1:
        text: "이번 레슨은 씨앗 심기라고 부르고, 우리가 알고리즘을 이해하는데 도움을 줄 것입니다. 알고리즘은 무언가를 하기 위한 순서를 설명해주는 구체적인 명령들을 말합니다. 아침 식사 또는 양치질과 같은 일상의 일조차 그 일을 하기 위한 작은 단계들이 필요한 알고리즘입니다."
      2:
        text: "컴퓨터는 아주 똑똑해질 수 있지만, 한 단계씩 한 단계씩 정확하게 이야기 해 주었을 때에만 이해할 수 있습니다. 알고리즘들의 위대함은, 여러분들이 원하는 작업을 어떻게 해야하는지 몰랐는데도 불구하고, 어떤 순서에 따라서 작업을 수행했을 때 그 작업을 수행할 수 있게 된다는 점입니다. 마치 요리법을 따라하는 것과 같습니다."
      3:
        text: "오늘 우리는 알고리즘을 이용하여 씨앗을 심을 것입니다. 그림을 오려내어 여러분만의 알고리즘을 만들어 보세요. 씨앗을 심는 단계를 보여주는 그림을 선택하고 그 그림들을 올바른 순서대로 배열해 보세요."
      4:
        text: "이제, 여러분의 알고리즘이 동작하는 것을 볼 시간입니다. 알고리즘의 각 단계를 주의 깊게 따라가 보세요. 정확한 순서대로 되어 있는지 확인 했나요? 알고리즘을 따라가면서 씨를 심는 것에 성공했나요? 이것은 마치 그림들로 프로그래밍하는 것과 같습니다."
      5:
        text: "우리가 초콜렛을 만들고 싶을 때, 그 과정에는 많은 커다란 단계들이 필요하고, 각각의 커다란 단계는 좀 더 작은 단계들로 구성됩니다. 그리고 우리가 어떤 맛의 초콜렛을 만들기를 원하는지에 따라 서로 다른 레시피나 알고리즘이 있습니다. 각 단계는 작은 단계일지라도 아주 중요해서 한 단계라도 제외하면 나머지 단계들은 완성될 수 없습니다. 다른 사람들이 이해할 수 있는 알고리즘을 만드는 것은 매우 중요합니다. 그것이 누가 수행하든 관계 없이 똑같은 결과가 나올 수 있도록 각 단계가 잘 기술되어야 하는 이유입니다."
    C1_playlab_storytelling:
      1:
        text: "스토리를 이야기하기 위해 코딩을 만들고 사용할 시간입니다. 이야기들 속에는 캐릭터들을 등장시키고, 캐릭터들이 서로 말을 주고 받게 할 수 있습니다. 어떤 스토리를 이야기하고 싶은지 생각하고 시작해보세요."
      2:
        text: "고양이는 항상 강아지를 무서워하는데, 강아지는 그렇게 무섭게 느끼지 않도록 노력한다는 것을 고양이가 안다면 어떨까요? \"실행하면\" 블록은 모든 것을 실행시킵니다. \"이동하기\" 블록은 캐릭터를 이동시켜주고, \"말하기\" 블록은 여러분이 입력한 것을 캐릭터가 말하도록 해 줄 것입니다."
      3:
        text: "이 블록은 \"캐릭터들이 충돌하면\" 블록이고, 다른 블록들을 연결시킬 수 있습니다."
      4:
        text: "저는 강아지가 여기로 와서 \"안녕\"이라고 말하면, 고양이가 무서워서 도망가도록 만들고 있었어요. \"아..\" 시간이 좀 더 있었더라면, 해피엔딩으로 만들 수도 있었겠네요. 이제 끝!"
    C1_spelling_bee_intro:
      1:
        text: "이번에는 말하는 꿀벌입니다. 퍼즐 조각들 위로 꿀벌이 이동하도록 해주세요. 꿀벌이 이동하면서 문자들을 모아서 단어를 말하게 될 것입니다."
      2:
        text: "아래쪽 상자에 주어진 단어를 보고, 그 단어를 만들 수 있는지 살펴보세요. 하지만 조심하세요! 다른 방향으로 움직이면, 주어진 단어를 만들 수 없습니다."
    C1_zuck_repeat_loop:
      1:
        text: "컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다."
      2:
        text: "예를 들어, 제가 페이스북의 모든 사람들에게 생일 축하 이메일을 보내려고 할 때, 그 사람들에게 모두에게 이메일을 따로 작성하려고 한다면, 100년 넘게 걸릴 수도 있습니다. 하지만, 코드 몇 줄이면 페이스북의 모든 사람들에게 생일 축하를 알리는 메일을 보내는 시스템을 만들 수 있습니다."
      3:
        text: "이 예제에서 여러분의 목표는 새가 돼지를 잡도록 이동시키는 것입니다. 이제 우리는 이것을 아주 쉽게 할 수 있는 반복 블록을 사용할 수 있을 것입니다. 여러분은 컴퓨터에게 앞으로 이동 명령을 다섯 번 줌으로써 새가 한 번에 한 걸음씩 전진하여 돼지에게 갈 수 있도록 할 수도 있고, 아니면 그냥 앞으로 한 번만 이동하라고 한 뒤에 이를 다섯 번 반복하라고 명령할 수도 있는데 이것은 둘 다 똑같이 실행됩니다."
      4:
        text: "앞으로 이동 명령을 드래그해서 반복 블록 안에 넣어주세요. 그 다음에 클릭해서, 앞으로 이동해야하는 횟수를 생각해서 입력하면 됩니다."
      5:
        text: "반복 블럭 안에는 원하는 만큼의 명령어들을 넣을 수 있습니다. 이번 예제에서, 앞으로 이동하고 회전하는 것을 5번 하면 됩니다. 재미있게 해보세요!"
    C2_artist_intro:
      1:
        text: "컴퓨터과학(정보과학) 에 대한 전문가가 없다면, 자동차 레이스에서 예선도 통과하지 못 할 수 있습니다. 왜냐하면, 어떻게 해야 자동차 경주에서 효과적일지 알아내기 위해서 컴퓨터 프로그램을 만들어야 하는데, 그러기 위해서 자동차의 수많은 데이터들을 계속해서 수집하고, 그러한 데이터를 이용해서 필요한 정보를 만들어내는 프로그램을 만들어내는 사람이 있어야 하기 때문입니다."
      2:
        text: "이번 퍼즐들에서는, 연필을 이용해 여러 가지 도형을 그리는 화가가 될 것입니다. 화가가 이동하면 그 뒤에 선이 그려질 것입니다."
      3:
        text: "캔버스를 돌아다니기 위해서 앞으로 이동 블록을 사용할 수 있습니다. 여기에 있는 앞으로 이동 블록은 100 픽셀 앞으로 이동하는 것을 의미합니다. 실행 시키면 어떤 일이 일어날까요? 화가가 정확히 100 픽셀 만큼 앞으로 이동합니다. 픽셀은 큰 화면을 구성하는 아주 작은 조그만 사각형입니다. (화면을 아주 가까이에서 보면 아주 조그만 사각형이 보일 것입니다.)"
      4:
        text: "이 퍼즐에 있는 다른 블록은 90도 만큼 회전하도록 만드는 블록입니다. 그 블록을 사용하면 화가가 회전하는 각도를 지정할 수 있습니다. 화가가 얼마나 회전해야하는지 생각해보세요. 이것은 90도 회전입니다."
      5:
        text: "그리고 이것은 120 도 회전입니다. 여러분들은 픽셀이나 각도를 지정하기 위해 수 옆에 있는 화살표들을 클릭해서 이런 값들을 바꿀 수 있습니다. 여러분의 화가로 마음 껏 그려보세요!"
    C2_bee_conditionals:
      1:
        text: "이 블록은 조건/선택 블록입니다. 만약 꽃꿀이나 꿀의 개수가 어떤 수보다 작은지, 같은지, 큰지를 확인한 후, 그에 따라 다른 작업을 시킬 수 있습니다."
      2:
        text: "이것은 꽃꿀이나 꿀의 양을 알 수 없을 때 편리합니다. 이렇게 물음표가 있는 곳입니다."
      3:
        text: "이번 예제에서는, 자주색 꽃의 꽃꿀이 있을 때 꽃꿀을 모으도록 할 것입니다. 그렇게 하면, 꿀벌이 꽃꿀을 모두 모을 수 있습니다. 짜잔!"
    C2_binary_bracelets:
      1:
        text: "이번은 2진 팔찌 레슨입니다. 팔찌에 이름 이니셜을 코드화 해서 만들고, 친구들에게 보여주세요!"
      2:
        text: "2진 체계는 오직 두 가지 선택사항만을 사용하여 정보를 표현하는 방법입니다. 때때로 사람들은 이것을 오직 1과 0으로 만 생각합니다. 하지만 on/off, 위/아래, 안/밖 등 서로 반대되는 어떤 세트라도 사용해 표현할 수 있습니다."
      3:
        text: "안녕하세요. 저는 여기 Play-im 에서 로봇 프로그래밍을 하고 있는 오리온이라고 합니다. 모든 컴퓨터와 로봇들의 두뇌들은 가장 기본적인 수준에서는 조그만 전기 논리 게이트들입니다. 논리 게이트가 열리면, 전기가 흐르고, 논리 게이트가 닫히면 전기가 흐르지 못합니다."
      4:
        text: "이 로봇에 있어서 2진의 예시는 로봇의 눈입니다. 로봇의 눈은 on/off 되는 LED들로 구성되어있습니다. LED는 2진 체계로 되어있습니다. 우리는 빛을 이용해 2진수를 표현할 수 있습니다. 한 세트의 로봇이 있다고 하면, 첫 번째 위치의 로봇, 두 번째 위치의 로봇, 세 번째 위치의 로봇... 로 생각할 수 있습니다. 그러한 방법으로 2진 수를 표현할 수 있습니다. 로봇들은 그들의 2진 눈으로 표현할 것이고, 여러분을 위해 계산해 줄 것입니다."
    C2_conditionals_with_cards:
      1:
        text: "이번 레슨은 카드들을 사용하는 조건/선택입니다. 우리는 매일 보고 듣는 것을 판단해 결정을 내립니다."
      2:
        text: "공원에 산책을 가고 싶은데, 먼저 우산을 가지고 가야할지 말지를 먼저 결정해야 합니다. 그래서 먼저 창문 밖을 봅니다. 구름낀 흐린 날이라면? 우산을 가져야하고, 그렇지 않다면? 선글라스를 가지고 산책을 갈 것입니다. 우산을 가지고 나가는 것이 좋을 것 같네요. 이렇게 제가 먼저 보고 들은 것 때문에, 공원에 어떤 것을 가지고 갈지 결정할 수 있는 것입니다."
      3:
        text: "조건/선택 구조는 게임에서도 사용됩니다. 여기서 우리는 카드 게임에서 조건/선택 구조를 사용하는 방법을 연습해 볼 것입니다. 이 게임에서, 제가 카드를 내려 놓으면, 그 카드에 따라서 친구들이 해야할 행동을 지정해 주게 됩니다. 제가 만약 7 카드를 내려놓으면? 모든 친구들이 손벽을 쳐야합니다. 그렇지 않으면, 모든 친구들이 \"아으\"라고 말합니다. 자 이제 해보세요! \"아으\". 자 모두들 화이팅해보세요!"
      4:
        text: "조건/선택 구조들을 이용하면, 게임들을 좀 더 재미있게 만들 수 있습니다. 자 한 번 해보세요! 조건/선택 구조들은 컴퓨터를 똑똑하게 만들어 줍니다. 조건/선택 구조들이 사용되고 있는 컴퓨터 프로그램들은, 사람들의 반응에 따라 서로 다른 작업들을 수행할 수 있게 됩니다."
      5:
        text: "여러분이 좋아하는 게임을 할 때를 생각해 봅시다. 어떤 동작들 대신에, 다른 동작들을 하면 더 많은 점수를 얻을 수 있을까요? 이렇게, 어떤 상황에서 선택 가능한 것들 중에서 하나를 선택해 실행할 수 있도록 하는 조건/선택 구조들을 컴퓨터에서도 사용합니다. 그렇게 컴퓨터가 어떤 결정을 내리도록 할 수 있습니다. 예를 들어, 타겟을 맞추면 10 포인트를 얻고, 못 맞추면 3 포인트를 잃고. 이런 조건/선택 구조들을 사용할 수 있게 되면, 아주 많은 종류의 재미있는 게임들을 만들 수 있게 됩니다."
    C2_artist_debugging:
      1:
        text: "작업 공간에 몇 개의 블록들이 있습니다. 하지만 뭔가 잘못 된 것 같네요."
      2:
        text: "이번에는 코드의 실행 속도를 느리게 하거나, 한 번에 한 블록씩 실행시켜 살펴보면서 코드의 오류를 수정해보세요."
      3:
        text: "아, 문제가 있네요! 고양이 수염의 길이는 25가 아니라 75 픽셀입니다."
    C2_bee_debugging:
      1:
        text: "디버그/디버깅이라는 말을 들어본 적이 있나요? 디버깅은 프로그램이 제대로 동작하지 않는 원인들을 찾아내고 고치는 과정입니다. 여러분들이 코드를 살펴보고 오류를 찾아내서 고칠 때, 그러한 작업을 디버깅이라고 하는 것입니다."
      2:
        text: "작업 공간에 몇 개의 블록들이 놓여져 있습니다. 이제 단계 버튼을 눌러서, 블록들을 한 번에 한 단계씩 실행시키면서 코드가 제대로 동작하는지? 어디를 고쳐야하는 지 살펴볼 것입니다."
      3:
        text: "여기 해결해야할 문제가 있는 것 같네요! 앞으로 이동 블록이 1개 이상 필요한 것 같습니다. 단계 버튼을 사용하면, 오류를 찾아내는 디버깅 과정에 편리하게 사용하고 오류를 수정할 수 있게 해줍니다."
    C2_digital_footprint:
      1:
        text: "모자를 보관하기 위해서 머리를 사용할 수도 있지만, 머리로 생각하면, 지금 어디에 있는지? 생각하거나, 동물원에 대해서 생각하거나, 고개를 숙여 인사하는 등에 사용할 수 있습니다. 온라인에서 접속해 있을 때에는! 여러분의 마음 속에 품고 있는 생각들을 함부로 풀어놓지 마시고 어떻게 해야 자신이 안전할 지, 여러 분의 개인 사생활을 어떻게 보호해야 할 지를 머리로 생각하세요! 여러분의 머리부터 발끝까지, 잠깐 멈추고, 그런 것들을 생각하세요. 여러분의 발끝부터 코 위까지, 잠깐 멈춰서! 생각하세요. 온라인이라는 것을 생각하세요!"
      2:
        text: "여러분의 마음이 점점 더 올바르게 커 갈 수 있게 해주세요. 좋은 마음을 가진 사람이 되세요. 다른 사람들에게 여러분들이 좋은 사람이 되도록 하세요! 여러분이 온라인에 접속해 있을 때, 어떤 것이 바른 것인지 생각하고, 항상 친절하고 착한 마음을 가지고, 여러분의 친구들을 존중해주고, 공정하고 멋지게 행동하세요.\n여러분의 머리부터 발끝까지, 그런 것들에 대해서 잠깐만! 생각해주세요. 여러분의 발끝부터 코까지, 잠깐만 온라인이라는 것을 생각해주세요!"
      3:
        text: "여러분의 양팔을, 애완동물을 안아주기 위해서, 옷이 젖지 않게, 좋아하는 옷을 입기위해, 여러분이 날아오르게, 여러분에 대한 신뢰를 만들어 내도록 사용해주세요. 여러분의 양팔을 온라인에서도 사용해주세요. 잠깐 생각을 멈추고, 충분히 생각하고, 여러분의 능력을 나쁘게 과시하지 않고, 어떤 행동 이후에 벌어질 상황들에 대해서 생각해보세요."
      4:
        text: "여러분의 위장을, 음식을 먹고 소화시키는데 사용하고, 속에서 부글거리는 것을 참고, 충격을 흡수하는데 사용하고, 탄산 음료를 먹었을 때의 거북함을 참을 때도 사용한다는 것을 생각해보세요. 여러분의 넓은 마음을 온라인에서도 사용해주세요. 마음에 들지 않는 거북한 것들을 마주하게 되었을 때, 어떤 상황들을 어떻게 받아들이고, 어떻게 해야하는지 생각하기 위해서 사용해주세요. 머리부터 발끝까지, 잠깐만! 그것에 대해서 침착하게 생각해보세요. 발끝부터 코까지, 잠깐만! 온라인으로 접속해 있다는 것을 생각해주세요."
      5:
        text: "그리고, 온라인에 접속해 있을 때에는, 머리로 함께 생각하고, 마음으로 느껴보고, 넓은 마음으로 안아주고, 여러분의 감정에 대해서 조심해주세요. 여러분의 냄새나는 양말 속에 있는 다리를, 달리고 차고, 대나무 춤을 추기 위해서 통통 뛰고, 무대에서 춤추는데 사용해주세요. 여러분의 다리를 온라인에서도 사용해주세요. 지켜야 할 선을 넘는 사람들을 말리기 위해서, 꾿꾿하게 서있기 위해서, 크고 작은 생물들에게도 피해를 주지 않도록 다리를 사용해 주세요."
      6:
        text: "머리부터 발끝까지, 잠깐만! 생각해주세요. 발끝부터 코까지, 온라인이라는 것을 잠깐만 생각해주세요! 여러분의 머리, 마음, 양팔, 넓은 가슴, 다리 모두를 사용해 생각해주세요. 머리부터 발끝까지, 잠깐만! 생각해주세요. 발끈부터 코까지, 온라인이라는 것을 잠깐만 생각해주세요!"
    C2_digital_footprint_v2:
      1:
        text: "여러분들이 온라인에 접속할 때마다, 여러분들은 검색되고, 복사되고, 공유되고, 널리 퍼트려지고, 영원히 남을 수 있는, 디지털 흔적들을 남기게 됩니다.\n어떤 디지털 흔적들을 남기고 있는 것 일까요? 어떤 디지털 흔적들을 남기고 싶으신가요?"
    C2_graph_paper:
      1:
        text: "이번 레슨은 \"모눈종이 프로그래밍\" 이라고 부르는데, 알고리즘들에 대한 이야기라고 할 수 있습니다. 여기서는, 손으로 그려진 화살표들만 이용해서, 흑백이미지들을 만들어낼 수 있는 방법을 이해해보고, 그런 이미지들을 만들 수 있는 프로그램을 만드는 방법에 대해서 배울 것입니다."
      2:
        text: "알고리즘은 어떤 작업을 완료하기 위해 필요한 명령어들의 리스트입니다. 이런 명령어 리스트를 따라가며 그릇을 만들 것입니다.\n알고리즘들은 여러분들이 누군가에게 작업 방법을 이해시키려고 할 때 정말 도움이 됩니다."
      3:
        text: "여러분이 어떤 컴퓨터 프로그램을 만들려고 한다면, 그 프로그램을 보다 작은 단계들로 나누어 생각해야합니다. 먼저 이 줄을 만들고, 그 다음, 그 다음 한 단계씩 해나가면 될 것입니다."
      4:
        text: "저는 제 작품들을 만들어내기 위해 알고리즘들을 사용합니다. 제가 작품을 만들기 위해 필요한 모든 단계들을 기록해 두면, 같은 조각을 쉽게 만들 수 있습니다. 물론, 다른 사람들에게 어떻게 만들 수 있는지 가르쳐줄 수도 있습니다. 유리 조각들을 가마에 넣고, 함께 녹여붙인 후, 유리 그릇을 만들어 내기 위해 필요한 나머지 단계들을 순서대로 따라갑니다. 알고리즘들은 어떤 작업을 수행하기 위해 필요한 순서와 방법을 알려주는 지도(로드맵) 입니다."
    C2_artist_loops:
      1:
        text: "이제 화가를 프로그래밍 할 때 반복(횟수) 블록을 사용해서, 필요한 코드를 줄이도록 하겠습니다. 몇 개의 블록들을 빼 두었고, 실행시켜 보기만 하면 됩니다."
      2:
        text: "사각형 전체를 그리기 위해서, 저 블록들을 반복 구조를 사용해서 4번 실행시키려고 합니다. 반복 블록 안에, 앞으로 이동 후 오른쪽으로 회전하도록 하는 블록을 넣어 두었습니다. 실행 시키면, 화가는 그 단계들을 4번 반복 시켜서 사각형을 그릴 것입니다."
    C2_bee_loops:
      1:
        text: "반복 구조는 어떤 실행 내용을 반복하도록 하는 것입니다. 들어가서 조사하고, 구조를 살펴보고, 다시 나오는, 한 번의 과정을 여러 번 실행 시킬 수 있습니다.\n반복 구조 안에 넣으면, 똑같은 작업을 여러 번 실행할 수 있습니다."
      2:
        text: "이것은 반복 블록 입니다. 이 블록 안에 반복 시킬 작업과 횟수를 넣을 수 있습니다.\n예를 들어, 이 퍼즐에서, 앞으로 이동한 후 꽃꿀을 얻는 작업을 일일이 3번씩 실행 시킬 필요없이, 반복 시킬 작업을 1번 만 넣으면 3번 반복하게 됩니다.\n아주 쉽게 할 수 있습니다!"
    C2_maze_intro:
      1:
        text: "일반적으로 프로그래밍은 텍스트로 작성을 하지만, 오늘 우리는 블러클리(Blockly) 를 사용할 것입니다. 블러클리는 프로그램을 작성하기 위해서 비주얼 블록들을 사용합니다. 하지만, 내부적으로는 코드를 작성하는 것입니다. 시작하면서, 앵그리 버드가 자기 알들을 훔쳐간 나쁜 돼지를 미로를 이동해서 잡을 수 있도록 코드를 작성할 것입니다."
      2:
        text: "블러클리의 화면은 3개의 주 화면으로 분할되어있습니다. 왼쪽은 프로그램이 실행된 후 새가 움직일 미로입니다. 각 레벨을 위한 설명은 미로 아래에 작성되어있습니다. 가운데 영역은 도구 상자이고, 이 블록들은 새를 동작시킬 수 있는 명령어입니다. 오른쪽의 빈 공간은 프로그램을 만드는 작업 공간입니다."
      3:
        text: "만약 제가 이동하기 블록을 작업 공간에 끌어다 놓고 \"실행\" 버튼을 누르면 어떻게 될까요? 새가 앞으로 한 칸 움직입니다. 그리고 새가 한 칸 이동한 다음에 무언가를 하길 원한다면 어떻게 하면 될까요? 다른 블록을 추가하면 됩니다."
      4:
        text: "저는 \"오른쪽으로 회전\" 블록을 드래그해서, 저의 이동 블록 아래에 노란 화살표가 나타날 때까지 가깝게 가져간 다음에, 두 블록을 붙일 것입니다. \"실행\"을 다시 누르면, 새는 작업 공간에 쌓여서 붙어있는 블록들을 위에서 아래로 읽어가면서 순서대로 실행 할 것입니다."
      5:
        text: "어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 휴지통으로 넣으면 됩니다. 실행시켰을 때에는 재실행 버튼을 눌러 새를 처음 위치로 돌려 놓을 수 있습니다. 이제 저 돼지들을 잡아보세요!"
    C2_paper_airplanes:
      1:
        text: "이번 레슨은 실생활 알고리즘입니다. 알고리즘으로 사람들이 매일 하는 일상적인 것들을 표현할 수 있습니다. 쿠키를 만드는 방법과 새집을 만드는 제작 방법들은 모두 일상생활에서의 알고리즘들이라고 말 할 수 있습니다."
      2:
        text: "오늘 우리는 종이 비행기를 만드는 방법을 생각하고, 만들고, 테스트 할 것입니다. 하지만 무엇보다도 먼저, 프로젝트를 따라 하기 쉬운 보다 작은 단계들로 나누어야 합니다. 종이 비행기를 만들어내기 위해서, 어떤 순서로 어떤 단계들을 따라 만들어야 하는지 먼저 판단해야 합니다."
      3:
        text: "여러분들은 그림들을 여러 조각들로 잘라내는 것부터 시작해서, 알고리즘을 만들게 될 것입니다. 그런 다음에 종이 비행기를 만드는데 필요한 6개의 조각을 선택한 다음에, 그 조각들을 정확한 순서로 배치시켜야 합니다. 모든 것이 제대로 맞는지 확인하고 난 후에, 다른 팀과 알고리즘을 서로 교환해서 그 알고리즘들이 제대로 작동하는지 테스트 해보게 될 것입니다. 잘 만들어진 알고리즘은 가장 멋진 종이 비행기를 만들기 위해서 아주 중요합니다."
      4:
        text: "초콜렛을 만들려고 하면 많은 큰 단계들이 필요하고, 각각의 큰 단계는 좀 더 작은 단계들로 구성됩니다. 그리고 우리가 어떤 맛의 초콜렛을 만들기를 원하는지에 따라 서로 다른 레시피나 알고리즘이 있습니다. 각 단계는 작은 단계일지라도 아주 중요해서, 한 단계라도 제외하면 나머지 단계들을 통해서 완성할 수가 없습니다. 다른 사람들이 이해할 수 있는 알고리즘을 만드는 것은 매우 중요합니다. 왜냐하면, 어떤 사람들이 따라하던지 관계 없이, 똑같은 결과가 나올 수 있도록 각 단계가 자세하고 정확하게 표현되어야 하기 때문입니다."
    C2_playlab_createstory:
      1:
        text: "지금까지 여러분들은 애니메이션이나 이야기들을 만들어보았습니다. 그리고 여러분들이 실행시켜보는 다른 모든 것들과 똑같은 것이었습니다. 이제는 여러분들이 실제로 플레이할 수 있는 인터랙티브 게임을 만들 수 있습니다."
      2:
        text: "\"방향키\" 블럭과 \"움직이기\" 블럭이 있습니다. 이 블럭들을 이용해서 방향키로 캐릭터들을 이리 저리 이동시킬 수 있습니다."
    C2_relay_programming:
      1:
        text: "이번에는 릴레이 프로그래밍을 해 볼 것입니다. 시간과 압박에 쫓기는 상황에서 아주 빨리, 혹은 팀으로 함께 오류들을 디버깅해야하는 프로그래밍 관련 단체 게임입니다. 우리는 코딩을 테스트하기 위해서 모눈종이 프로그래밍을 사용할 것이고, 어느 팀이 더 빠르게 하는지 릴레이 경주를 할 것입니다."
      2:
        text: "릴레이 프로그래밍을 할 때, 각 팀들은 모눈종이 프로그래밍을 완료하기 위해서 경쟁해야 할 것입니다. 여러분들은 함께 일해야하고, 실수가 발생하면 그 오류를 수정하고 고치기 위해서, 화살표를 추가하고, 다시 돌아와서 다른 팀원에게 임무를 전달하기 위해서, 팀원들의 협동과 협력을 중요하게 확인해야합니다."
      3:
        text: "프로그래머들은 여러 가지 알고리즘이나 코드에 들어있는 문제점을 찾고 수정하기 위해서 매우 많이 디버깅을 합니다. 프로그램들을 디버깅하는 방법은 아주 많이 있습니다. 가장 쉬운 방법은, 이상한 점을 찾아낼 때까지 순서대로 한 단계씩 실행해 보고 오류를 찾아낸 다음 고치는 것입니다."
      4:
        text: "여기서, 저는 백 핸드스프링을 연습하고 있는데, 계속 잘 안되었습니다. 그래서 각 단계마다, 한 단계씩 하면서, 어떤 실수를 했는지 알게 되었습니다. 코치님은 두 손을 정확하게 빔 위에 놓지 못했다고 이야기 해주셨습니다. 그래서 저는 두 손의 위치를 바꿔서 다른 백 핸드스프링을 연습했고, 해냈습니다! 진짜 기뻤습니다.  저는 저의 백 핸드스프링 방법을 디버깅한 것이라고 볼 수 있습니다.\n그렇습니다! 디버깅은 오류를 찾고 그 문제들을 고치는 것입니다. 좋아요, 잘했어요!"
    C2_zuck_repeat_loop:
      1:
        text: "컴퓨터들이 정말 잘 하는 것은 명령들을 반복해서 실행하는 것입니다. 만약 여러분들이 같은 작업을 여러번 해야한다면 정말 지루할 것입니다. 하지만 컴퓨터는 수 백만 또는 수 십억 번 똑같은 작업을 수행할 수 있고, 지루해 하지 않으며, 정말 잘 실행할 수 있습니다."
      2:
        text: "예를 들어, 제가 페이스북을 사용하는 모든 사람들에게 생일 축하 이메일을 보내려고 했을 때, 실제 그 모든 사람들에게 각각 이메일을 쓰는 것은 100년 이상 걸릴 것입니다. 하지만, 몇 줄의 코드를 만들면 페이스북의 모든 사람들에게 생일 축하 이메일을 보내는 시스템을 만들어 가질 수 있게 됩니다. 그렇습니다. 그런 것들이 반복 구조들의 의미이며, 가치가 있는 이유이며, 컴퓨터들이 아주 잘 할 수 있는 것들 중 하나 입니다."
      3:
        text: "여러분의 목표는 새를 돼지에게 이동시키는 것입니다. 이제 쉽게 할 수 있도록 \"반복(횟수)\" 블록을 사용할 수 있도록 할 것입니다. 여러분들은 새가 돼지에게 한 번에 한 걸음씩 움직일 수 있도록, \"앞으로 이동\" 명령을 5번 컴퓨터에게 지시할 수 있습니다."
      4:
        text: "그렇지 않으면, 컴퓨터에게 \"앞으로 이동\" 명령을 한 번 알려준 후에, 그것을 5 번 \"반복\" 하도록 해서 같은 작업을 할 수 있습니다. 이렇게 하기 위해서 \"앞으로 이동\" 명령을 드래그 해서, \"반복\" 블록 안에 넣어주세요. 그 다음에 반복 해야하는 횟수를 알려준 후에 실행시켜보면 됩니다."
      5:
        text: "한 가지 더 이야기해 드릴 것은, 원하는 만큼의 명령어들을 \"반복\" 블록 안에 넣을 수 있다는 것입니다. 이 퍼즐에서는 앞으로 이동하고 왼쪽으로 회전하도록 하는데, 그렇게 하면 5번 반복될 것입니다. 자 이제 재미있게 시도해보세요!"
    C3_artist_functions:
      1:
        text: "컴퓨터 프로그래밍에서 더 멋진 것은, 일단 컴퓨터가 해야할 작업을 컴퓨터에게 가르쳐 놓으면, 함수로 다시 불러 실행시킬 수 있다는 것입니다. 원하는 작업들을 하나로 묶어 이름을 붙여두면, 다시 불러 실행시킬 수 있습니다. 이것은 마치 사용 가능한 언어들을 확장시키는 것과 거의 같습니다."
      2:
        text: "우리가 만든 프로그램에서, 이동하고 회전하는 작업을 4번 반복함으로써 1개의 사각형을 그릴 수 있다는 것을 배웠습니다. 그러한 작업을 함수로 만들어, 사각형 그리기라고 이름을 붙여두면, 원할 때마다 불러 사용할 수 있습니다. 불러서 사용할 때에는 \"사각형 그리기\"라고 말하면, 그 함수를 호출하고 그렇게 이름 붙여둔 한 묶음의 코드를 실행하게 될 것입니다. 이제 가능하게 되었네요. 우리가 사용하는 프로그래밍 언어에 그런 함수 개념을 추가했습니다."
    C3_artist_intro:
      1:
        text: "컴퓨터과학(정보과학) 에 대한 전문가가 없다면, 자동차 레이스에서 예선도 통과하지 못 할 수 있습니다. 왜냐하면, 어떻게 해야 자동차 경주에서 효과적일지 알아내기 위해서 컴퓨터 프로그램을 만들어야 하는데, 그러기 위해서 자동차의 수많은 데이터들을 계속해서 수집하고, 그러한 데이터를 이용해서 필요한 정보를 만들어내는 프로그램을 만들어내는 사람이 있어야 하기 때문입니다."
      2:
        text: "이번 퍼즐들에서는, 연필을 이용해 여러 가지 도형을 그리는 화가가 될 것입니다. 화가가 이동하면 그 뒤에 선이 그려질 것입니다."
      3:
        text: "캔버스를 돌아다니기 위해서 앞으로 이동 블록을 사용할 수 있습니다. 여기에 있는 앞으로 이동 블록은 100 픽셀 앞으로 이동하는 것을 의미합니다. 실행 시키면 어떤 일이 일어날까요? 화가가 정확히 100 픽셀 만큼 앞으로 이동합니다. 픽셀은 큰 화면을 구성하는 아주 작은 조그만 사각형입니다. (화면을 아주 가까이에서 보면 아주 조그만 사각형이 보일 것입니다.)"
      4:
        text: "이 퍼즐에 있는 다른 블록은 90도 만큼 회전하도록 만드는 블록입니다. 그 블록을 사용하면 화가가 회전하는 각도를 지정할 수 있습니다. 화가가 얼마나 회전해야하는지 생각해보세요. 이것은 90도 회전입니다."
      5:
        text: "그리고 이것은 120 도 회전입니다. 여러분들은 픽셀이나 각도를 지정하기 위해 수 옆에 있는 화살표들을 클릭해서 이런 값들을 바꿀 수 있습니다. 여러분의 화가로 마음 껏 그려보세요!"
    C3_artist_nested_loops:
      1:
        text: "어떤 반복 구조 안에 다른 반복 구조를 넣은 것을 중첩 반복 이라고 합니다. 예를 들어, 한 변의 길이가 100 픽셀인 삼각형 1개를 반복 구조를 이용해 그리는 코드에는, 길이가 100 픽셀인 선을 3번 반복해서 삼각형의 한 변을 한 번에 하나씩 그립니다."
      2:
        text: "하지만 만약, 6개의 삼각형들을 그리려고 한다면. 그렇게 하기 위해서 다른 반복(횟수) 블록 안에 넣고 실행시키면 됩니다. 꽤 멋지죠!"
    C3_bee_conditionals:
      1:
        text: "이 블록은 조건/선택 블록입니다. 만약 꽃꿀이나 꿀의 개수가 어떤 수보다 작은지, 같은지, 큰지를 확인한 후, 그에 따라 다른 작업을 시킬 수 있습니다."
      2:
        text: "이것은 꽃꿀이나 꿀의 양을 알 수 없을 때 편리합니다. 이렇게 물음표가 있는 곳입니다."
      3:
        text: "이번 예제에서는, 자주색 꽃의 꽃꿀이 있을 때 꽃꿀을 모으도록 할 것입니다. 그렇게 하면, 꿀벌이 꽃꿀을 모두 모을 수 있습니다. 짜잔!"
    C3_bee_debugging:
      1:
        text: "디버그/디버깅이라는 말을 들어본 적이 있나요? 디버깅은 프로그램이 제대로 동작하지 않는 원인들을 찾아내고 고치는 과정입니다. 여러분들이 코드를 살펴보고 오류를 찾아내서 고칠 때, 그러한 작업을 디버깅이라고 하는 것입니다."
      2:
        text: "작업 공간에 몇 개의 블록들이 놓여져 있습니다. 이제 단계 버튼을 눌러서, 블록들을 한 번에 한 단계씩 실행시키면서 코드가 제대로 동작하는지? 어디를 고쳐야하는 지 살펴볼 것입니다."
      3:
        text: "여기 해결해야할 문제가 있는 것 같네요! 앞으로 이동 블록이 1개 이상 필요한 것 같습니다. 단계 버튼을 사용하면, 오류를 찾아내는 디버깅 과정에 편리하게 사용하고 오류를 수정할 수 있게 해줍니다."
    C3_bee_functions:
      1:
        text: "컴퓨터과학(정보과학) 에서 가장 중요한 개념들 중 하나는 새로운 명령어들을 정의하는 방법으로, 여러분이 만든것을 새로운 명령으로 추가하는 것입니다. 대부분의 컴퓨터 프로그래밍 언어들은 기껏해야 100 개 정도의 단어나 명령어에 대한 것들입니다. 컴퓨터 프로그래밍 언어의 예술과 마술은, 이러한 블록들과 같은 새로운 단어들을 정의하는 것입니다."
      2:
        text: "이러한 정의는 스포츠게임에서 항상 하는 일들입니다. 예를 들어 농구를 배우기 위해서 처음에는 드리블, 레이업, 리바운드 방법을 배우면서 시작합니다. 이러한 기초적인 동작들을 배우고 나면, 픽엔롤이나 기브엔고와 같은 새로운 동작들을 배운 후, 이런 블록들에 함께 넣을 수 있습니다. 그 다음에는 그런 것들을 이용해서 더 복잡한 플레이 방법들을 수행할 수 있게 됩니다. 그렇게 새로운 방법들을 배우고 이름을 붙이면, 팀원 모두가 어떻게 하는지 이해할 수 있는 것입니다."
      3:
        text: "비슷하게, 이런 명령어들을 이용해서 컴퓨터가 수행해야 할 동작들을 컴퓨터에게 가르쳐두면 됩니다. 그러한 동작들에 원하는 이름을 붙여두면 나중에 쉽게 반복시킬 수 있게 됩니다. 이렇게 필요한 명령들을 모아 자신이 원하는 이름으로 정의해 둔 것을 함수라고 합니다. 이제 우리는 꿀벌을 도와주기 위해서 함수들을 사용하게 될 것입니다."
      4:
        text: "이 예제에서 여기에 있는 이 녹색 함수의 이름은 \"꽃꿀 2번 얻기\" 입니다. 이 회색 상자의 작업 내용은 꽃꿀을 2번 얻는 것이라는 것을 알 수 있는데, 이것이 바로 함수 정의입니다. 그 안을 살펴보면, 꽃꿀 2번 얻기는 꽃꿀을 2번 반복해서 뽑아내는 내용입니다. 회색 상자 안에 어떤 것들이 들어있는지 항상 잘 살펴보면, 이 녹색 함수 블록들로 무엇을 할 수 있는지 알게 될 것입니다."
    C3_bee_nested_loops:
      1:
        text: "이번에는 꿀벌에게 중첩 반복 구조를 적용시킬 것 입니다. 처음에 주어진 코드가 있는데, 꿀펄이 한 번 앞으로 이동한 후에 세 번 꽃꿀을 얻고 나서 오른쪽으로 회전합니다. 전체 코드를 살펴보고, 다른 반복 블록 구조 안에 넣어서 전체를 3번 반복시켜보세요. 해보세요!"
    C3_bounce:
      1:
        text: "여러분들은 친구들에게 보여줄 수 있는, 자기만의 바운스 게임을 만들 준비가 되었습니다. 멋지죠!"
      2:
        text: "게임을 시작하려면, 키보드의 방향키를 눌러 라켓을 움직일 수 있도록 연결해야 합니다."
      3:
        text: "\"위/아래/왼쪽/오른쪽 방향키가 눌렸을 때\" 블록들을 연결하면 됩니다. 한 번 시험삼아 해보세요. 바로 자신만의 바운스 게임을 만들 수 있을 것입니다!"
    C3_computational_thinking:
      1:
        text: "이번 레슨은 컴퓨팅사고력(computational thinking) 입니다. 새로운 게임을 배우는 것은 때때로 매우 어렵습니다. 그렇죠? 처음에는 이해할 수 없어서 헷갈리고, 규칙에 대해서 설명해 주는 사람들이 없다면, 여러분 스스로 알아내야만 합니다."
      2:
        text: "다행인 것은 몇 가지 방법들만 이해하면, 훨씬 더 쉽게 파악할 수 있게 된다는 것입니다. 그런 방법들은 어떤 상황들을 살펴보거나, 문제들을 풀어내기 위해서 사용되는 특별한 몇 가지 방법들입니다. 이번 레슨에서 여러분들은, 친구들과 어떤 게임의 규칙들을 찾아보면서, 그런 몇 가지 방법들을 배우고 연습해 보게 될 것입니다."
      3:
        text: "큰 문제를 보다 작은 여러개의 작은 문제로 나눌 때에는 머리를 써야 합니다. 그리고 일단 그렇게 작은 문제들로 나누고 난 후에는, 다음 단계의 작업으로 갈 수 있는데, 그러한 것을 패턴 찾기라고 합니다."
      4:
        text: "그것은 바로 사물들 사이의 유사점을 찾을 때입니다. 유사한 점을 찾고 나서, 어떤 점들이 서로 다른지 알아낼 수 있습니다. 그러한 차이점들을 제거했을 때 그것을 추상화라고 합니다."
      5:
        text: "어떤 문제를 해결할 수 있는 단계들을 생각해 낸 후에, 그 단계들을 알고리즘이라고 하는 어떤 특별한 순서에 따라 그 단계들을 나타낼 수 있습니다. 그렇게하면 누구나 문제를 풀기 위해 그 방법을 사용할 수 있습니다. 우리는 규칙이 없는 게임을 플레이하는 방법을 알아내기 위해서 4 단계를 사용할 것입니다. 이 게임의 마지막에 여러분들은 이런 것과 같은 것을 할 수 있게 될 것입니다."
    C3_crowdsourcing:
      1:
        text: "이번 레슨은 클라우드소싱입니다. 한 벌의 카드를 사용해서, 혼자서 어떤 일을 몽땅 하지 않고, 여러명이 그룹으로 함께 할 수 있도록 하는 방법들이 얼마나 쉬운지 배우게 될 것입니다. 친구들과 함께 힘을 합쳐서 멋진 것을 만들어보세요. 클라우드소싱은 아주 많은 사람들이 함께 힘을 모아 어떤 일을 아주 빨리 완료하는데 큰 도움이 됩니다."
      2:
        text: "컴퓨터과학(정보과학) 에서, 클라우드소싱은 항상 이용됩니다. 수 천명의 아마추어와 전문가들은 네트워크로 연결된 컴퓨터들을 이용해서 수 십억개 이상의 정보들을 찾을 수 있습니다. 가장 큰 메르센 소수(prime number) 찾기(GIMPS) 나, 외계 생명체 찾기(SETI) 를 검색해서 살펴보세요."
      3:
        text: "영화는 1초에 24개의 사진이 빠르게 지나가는데, 그렇게 영상을 만들어내는 각 사진을 프레임이라고 합니다. 따라서 동영상을 만들려면 그런 사진들이 모두 만들어지거나 준비되어야 하고, 그 사진들이 모두 합쳐져서 만들어져야 합니다. 우리 팀과 저는 모두 소프트웨어 개발자입니다. 우리 팀에서는 동영상의 각 프레임 이미지들을 만들어내는 소프트웨어를 만들고, 여러분들이 영화관에서 보는 영화들에서 사용되는 최종적인 파이널 이미지 프레임들을 만들어 내고 있습니다. 그 소프트웨어는 아티스트들과 다른 개발자들이 영화에서 원하는 이미지들을 만들어내기 위해서 함께 협력해 작업해서 이미지들을 만들어낼 수 있는 툴입니다."
      4:
        text: "예를 들어, 니모를 찾아서라는 영화에서, 크러쉬, 스쿼트, 친구들은 동 호주 해류를 통해 물속을 날아다닙니다. 여러분들은 거북이 등의 색들을 통해서, 물고기의 옆 모습을 통해서, 물속을 날아다니는 것과 같은 이미지들을 보게됩니다. 그런 모든 것들은 우리가 만들어낸 수학식과 프로그램들을 통해서 만들어진 것들입니다. 그렇게 만들어 낸 결과물들을 영상 예술가들에게 보내 최종 결과물을 만들고, 색감을 조정하고, 아름답게 보이거나 재미있게 보이도록 합니다."
    C3_dice_race:
      1:
        text: "이번 레슨은 주사위 레이스입니다. 거의 모든 사람들이 컴퓨터 게임을 좋아합니다. 여러분들은 프로그래머들이 게임을 어떻게 프로그램으로 만드는지 생각해 본 적이 있나요? 컴퓨터 게임을 만드는 처음 단계나, 문제를 해결하는 첫 단계에서는 생각과 계획이 필요합니다."
      2:
        text: "문제 해결을 위해 생각하는 단계는 알고리즘을 만들어냅니다. 알고리즘은 어떤 문제를 해결하거나, 어떤 것을 만들어내기 위해 필요한 단계별 계획이라고 할 수 있습니다. 이번 레슨에서 여러분들은 주사위 경주 게임을 위한 알고리즘을 만들게 될 것입니다. 그런 다음에 여러분이 만들어낸 알고리즘을 친구에게 보여주고, 친구가 게임을 하기 위한 단계들을 따라갈 수 있는지 살펴보게 될 것입니다. 프로그래머가 각 단계들에 이상이 없다고 하면, 컴퓨터가 이해할 수 있는 프로그래밍 언어를 이용해서, 그 알고리즘을 프로그램으로 바꾸면 됩니다."
      3:
        text: "우리가 매일 매일 하는 거의 모든 일들에는, 일을 마치기 위해서 따라야하는 단계들의 집합인 알고리즘이 필요합니다. 친구들과 함께 학교를 가려고 하거나, 함께 놀 계획을 세우거나, 간단한 식사를 만들거나 할 때를 생각해보세요. 그러한 일들을 수행하기 위해서는, 보다 작은 단계들로 나누어야 하고, 그러한 단계들을 완료하기 위해서 어떤 기준에 따른 작업 순서가 필요하기도 합니다."
      4:
        text: "샌드위치 만드는 것을 생각해보세요. 어떤 샌드위치를 만드는 지는 중요하지 않습니다. 하지만, 땅콩버터 뚜껑을 열지 않고 땅콩버터를 바를 수 없습니다. 우리가 아무런 생각없이도 할 수 있는 아주 간단한 것이라고 하더라도, 어떻게 작업을 해야하는지 알려주는 알고리즘들이나 프로그램들을 컴퓨터들은 필요로 합니다."
      5:
        text: "알고리즘은 어떤 일을 하기 위해 필요한 생각이라고 할 수 있는데, 프로그램은 컴퓨터에게 작업을 시키기 위해서 필요한 실제적인 명령어들이라고 할 수 있습니다. 알고리즘은 프로그램으로 변환되어야만 컴퓨터가 실행할 수 있게 됩니다. 어떤 작업을 알고리즘이라는 단계들로 자세히 나누는 것은 때때로 어렵습니다. 하지만, 다른 것들과 마찬가지로 연습하면 할 수록 더 쉽게 됩니다."
    C3_farmer_while:
      1:
        text: "반복 구조들은, 일상생활에서 어떤 일들을 반복하는 것과 매우 비슷합니다. 자동차를 세차할 때를 예로 들자면, 깨끗하게 될 때까지 자동차를 닦을 것입니다. 깨끗하지 않다면, 계속 닦을 것입니다. 이렇게 어떤 상태를 판단하는 것을 항상 하고 있는 것입니다."
      2:
        text: "농부를 도와줄 수 있는 새로운 블록이 있습니다. 반복 블록이라고 부릅니다. 반복 블록은 매우 간단합니다. 가장 윗쪽의 조건문이 참이면, 입력 되어있는 작업을 합니다. 예를 들어, 흙더미가 있는 동안 치울 수 있습니다. 농부로 시도해보세요."
    C3_functional_suncatchers:
      1:
        text: "이번 레슨은 햇빛가리개 입니다. 이런 이쁜 햇빛가리개들을 함수들을 이용해 만들 수 있습니다. 이런 햇빛가리개를 1개 만들어 내기 위해서는 여러 개의 단계가 필요합니다. 그 중 한 단계는 여러 번 실행시키는 것입니다."
      2:
        text: "햇볓가리게를 만드는 과정과 단계들을 단순화하는 첫번째 단계는, 어떤 것을 반복시켜야 하는지 알아내는 것입니다. 이러한 단계들을 묶어, 함수라는 것으로 만들 수 있습니다."
      3:
        text: "하지만, 멋진 햇빛가리개를 만들기 위해서는, 정확한 단계들을 따라가는 것에 무언가가 더 필요합니다. 창의적으로 구슬들의 색을 바꿔 볼 수도 있습니다. 서로 다른 구슬 색으로, 서로 다른 햇빛가리개를 만들 수 있습니다."
      4:
        text: "변화될 수 있는 변수 단어로서 구슬들을 생각하게 되면, 세상에 하나 뿐인 햇빛가리개가 될 수 있습니다. 함수와 변수를 사용해 멋진 햇빛가리개를 만들며 즐겨보세요!"
    C3_internet:
      1:
        text: "이번 레슨은 인터넷에 대한 것입니다. 인터넷은 매우 바쁜 공간으로, 이런 바쁜 도로와 비슷합니다. 크게 확대되어 보이는 자동차들과 같은 메시지들은 목적지를 향해 이동합니다. 메시지들은 인터넷을 통해 매우 빠르게 이동합니다."
      2:
        text: "인터넷이 어떻게 동작하는지 살펴봄으로서, 인터넷에 접속해 있을 때 어떤 일들이 일어나는지 이해하는데 도움이 될 것입니다. 여러분들은 메시지들이 여러분들의 컴퓨터에서 입력되어서 웹사이트에 전송되거나, 친구로부터 이메일 박스에 전송되는 것에 대해서 배우게 될 것입니다. 도로들을 알고 표지판들을 읽을 수 있을 때 도로들을 이동해 다니는 것이 쉬운 것처럼, 인터넷 내부적으로 일어나는 일들을 이해하면 그렇게 복잡하지는 않습니다."
      3:
        text: "인터넷을 통해 메시지를 보내는 것은, 우체국을 통해서 편지를 보내는 것과 아주 조금 다를 뿐입니다. 저는 Google.com 에 접속해 있습니다. 이 웹사이트의 IP 주소는 이 숫자들입니다. IP 주소는 편지를 주고 받을 때 사용하는 주소라고 생각하면 됩니다. 자, 우체국에서 편지에 메시지를 작성해 넣은 후, 저곳으로 보낸다고 생각해 봅시다. 문 앞에 URL 과 IP 주소가 보이나요? 저는 이 메시지를 작성해서 보내기를 누릅니다."
      4:
        text: "현실의 우체국 우편 서비스와 다른 것은, 인터넷은 메시지를 보다 작은 단위의 조각들로 나누어서 더 쉽게 보낸다는 것입니다. 작게 나누어진 조각을 패킷이라고 부릅니다. 메시지가 나뉘어진 각 패킷들은 한 번에 하나씩 목적지로 발송됩니다. 이런 패킷들은 나중에 순서에 맞춰 순서대로 정확하게 조립되기 때문에, 받는 사람들은 받은 메시지를 똑같이 읽을 수 있습니다. 물론, 인터넷이 어떻게 움직이는지 이해하기 위해서는 더 많이 배워야 하지만, 지금 이야기한 메시지 전달이 가장 기본적입니다. 여러분들은 똑똑한 인터넷 사용자가 되는 길에 올라와 있습니다! 여러분의 가족과 친구들에게, 여러분들이 배운 것들에 대해서 꼭 이야기해주세요!"
      5:
        text: "저는 아만다 캠프이고, 저는 구글에서 소프트웨어 엔지니어로 일하고 있습니다. 저는 어떤 팀에서 함께 일을 하고 있는데, 사람들의 프로필과 연락처들을 저장하는 백엔드서버와 관련된 일들을 합니다. 우리 팀이 일을 할 때, 어떻게하면 연락처들을 스마트폰과 같은 다른 장비들에 전달시킬지에 대해서 많은 생각들을 해야합니다. 여러분들도 그렇다시피 사람들은 매우 많은 연락처를 가지고 있는데, 1000 개의 연락처가 있을 때, 1000 개의 연락처를 한 번에 모두 스마트폰에 메시지로 전달하려고 하지 않습니다. 왜냐하면 그렇게 되면 메시지의 용량이 너무 커지기 때문입니다. 인터넷에서도 비슷하게, 큰 메시지를 보다 조그만 패킷 조각으로 나누는데, 페이징이라는 개념을 이용해서 100 개의 연락처 단위로 나누어 하나를 전달합니다. 그렇게 하면, 스마트폰에서 보내진 연락처를 확인을 하거나 다음 100 개를 요청하게 됩니다."
      6:
        text: "소프트웨어의 가장 멋진 점은, 전 세계에 영향을 미칠 수 있다는 것입니다. 저는 19살 때, 처음 프로그래밍을 배웠습니다. 아마 고등학교 2학년이나 대학교 1학년 때 인 것 같습니다. 기억 나는 프로그램 중에서 하나는 섭씨 온도를 화씨 온도로 바꾸는 것 이었습니다. 저는 사람들을 돕는 것을 좋아하기 때문에 프로그래밍이 좋습니다. 저는 전세계 사람들을 돕는 프로그램을 구글에서 만들 수 있고, 그건 정말 짜릿하고 재미있는 일입니다."
    C3_maze_conditionals:
      1:
        text: "사람들은 매일 매일 결정을 내립니다. 예를 들어, 여러분들은 밖에 나가기 전에, 비가 올 지, 안 올지? 조건을 확인하고, 선택을 한 후 재킷을 가지고 나갈 지 말 지를 선택을 합니다. 일단 여러분이 그런 조건/선택문을 결정 해주면, 컴퓨터들은 믿기 어려운 속도/빠르기로 정확하게, 조건/선택에 따른 작업들을 멋지게 수행합니다. 하나의 컴퓨터 프로그램은 실제로, 수학적 계산 조금과, 조건/선택문들에 의해서 만들어지는 것이라고도 생각할 수 있습니다."
      2:
        text: "만약 블록은 좀비가 조건에 따라 선택할 수 있게 해줍니다. 어떤 상태를 확인할 수 있게 해줍니다. 예를 들어 만약 블록을 사용하면, 왼쪽에 길이 있을 때, 왼쪽으로 회전하도록 하는 명령어를 그 안에 넣을 수 있습니다. 그렇게 좀비 주변에 대해서 검사할 수 있도록 해서, 왼쪽에 길이 있을 때 회전하도록 하는 것입니다."
      3:
        text: "그 다음에, 앞으로 이동 블록을 반복 블록 안에 넣어서 계속 앞으로 이동하도록 할 수 있습니다. 그리고 나서, 만약 블록은 왼쪽으로 회전할 수 있을 때를 알려줄 수 있게 합니다. 그렇게, 만약 블록을 사용해서 왼쪽에 길이 있을 때 왼쪽으로 회전도록 하고, 왼쪽에 길이 없으면 계속 앞으로 이동할 수 있도록 하면 목표를 달성할 수 있게 됩니다."
      4:
        text: "이것은 컴퓨터 프로그래밍의 기초적인 개념인 조건/선택문을 사용하는 예시입니다. 제가 처음 배웠던 것 중 하나는, 틱택토 게임을 하는 프로그램이었습니다. 그 프로그램에서 저는 상대방이 이길 수 있는 때를 알려줄 수 있는 조건/선택문을 사용해서, 그 지점을 막을 수 있도록 해야했습니다. 조건/선택문을 사용하는 방법을 재미있게 배워보세요. 조건/선택문은 핵심 개념입니다."
    C3_maze_level_4:
      1:
        text: "이번 예제에서의 목표는 좀비를 해바라기로 보내는 것입니다. 앞으로 이동 블록을 5번 사용하거나, 1개의 반복 블록을 이용해서 앞으로 이동을 5번 반복하도록 할 수 있습니다."
      2:
        text: "그렇게 하면 시간도 아끼고 더 쉽게 할 수 있습니다. 반복 시키려면, 앞으로 이동 블록을 반복 블록 안에 넣으면 됩니다. 실행시키면, 좀비가 5번 앞으로 이동해서 해바라기로 갈 것입니다."
    C3_playlab_create_game:
      1:
        text: "지금까지 여러분들은 애니메이션이나 이야기들을 만들어보았습니다. 그리고 여러분들이 실행시켜보는 다른 모든 것들과 똑같은 것이었습니다. 이제는 여러분들이 실제로 플레이할 수 있는 인터랙티브 게임을 만들 수 있습니다."
      2:
        text: "\"방향키\" 블럭과 \"움직이기\" 블럭이 있습니다. 이 블럭들을 이용해서 방향키로 캐릭터들을 이리 저리 이동시킬 수 있습니다."
    C3_songwriting_with_parameters:
      1:
        text: "이번에는 작곡 레슨입니다. 음악은 컴퓨터 프로그램과 아주 많이 비슷합니다. 악보에 쓰여있는 음표와 가사는 가수가 어떻게 노래를 불러야 하는지를 정확하게 이야기해줍니다. 음악 악보에서 어떤 부분들은 계속 반복적으로 사용되기도 하고요."
      2:
        text: "그런 부분을 후렴이라고 합니다. 컴퓨터 프로그램에 있어서도, 반복적으로 사용되는 부분들을 함수들로 만들어 사용할 수 있습니다. 노래 가사를 읽을 때, 후렴이라고 쓰여 있으면 후렴이라고 말하고 끝내지는 않죠? 노래가 적혀있는 페이지의 가장 윗 부분에 보면, 어떤 부분이 반복해서 불러야 하는 후렴인지 알 수 있게 쓰여 있기 때문입니다."
      3:
        text: "여러분은 이번 레슨에서, 작은 토끼 후 후 라는 간단한 노래를 배울 것입니다. 그 노래에는 반복적으로 불러야 하는 후렴 부분이 있습니다. 함수는 한 번 정의한 후, 반복적으로 불러 쓸 수 있는 코드 조각이라고 생각할 수 있습니다. 함수를 사용하면 반복시킬 작업을 모두 일일이 작성하지 않아도 되기 때문에, 쉽고 효율적으로 프로그래밍이 가능하게 해줍니다. 한 번만 작성해두면 되는 것이죠!"
    C4_bee_conditional:
      1:
        text: "이것은 조건/선택 블록입니다. 꽃이나 벌집에 있을 때에 따라 작업을 시켜줍니다. 이렇게 물음표가 표시되어서 꿀이나 꽃꿀의 양이 얼마인지 몰라도, 조건/선택을 사용하면 편리합니다."
      2:
        text: "이 예제에서는 꽃이면 모든 꽃꿀을 뽑고, 그렇지 않고 벌집이면 꿀을 만들도록 할 것입니다. 짜잔!"
    C4_conditionals:
      1:
        text: "만약/아니면 이라는 새로운 블록이 생겼습니다. 이전 퍼즐들에서 사용했던 조건 블록과 비슷합니만 아래에 아니면 이라는 부분이 더 있습니다. 만약/아니면 블록은 2가지 선택 중에서 1가지를 실행시킬 수 있게 합니다. 꿀벌이 꽃 위에 있으면, 첫번째 부분에 넣은 작업들을 할 것입니다. 그렇지않다면, 꿀벌은 아니면 부분에 들어있는 작업들을 실행할 것입니다."
      2:
        text: "조건/선택문은 컴퓨터들이 결정을 내릴 수 있게하는 방법입니다. 어떤 상황에서 조건에 따른 작업을 설정해 두면, 컴퓨터들은 그 상황에서 설정해 조건에 따라 다른 작업들을 실행할 수 있게 됩니다. 주어진 만약/아니면 블록의 가장 위에는 꽃이 있는지에 대한 판단 조건이 있습니다. 하지만, 꽃꿀의 개수가 2인지, 길이 앞에 있는지와 같은 다른 조건을 사용할 수도 있는데 그 조건을 확인한 결과에 따라 같은 방법으로 동작하도록 할 수 있습니다. 즉, 조건/선택문의 가장 윗쪽에 있는 조건을 판단한 결과가 참이면 그 아래 첫번째 구역에 있는 동작들을 실행하고, 참이 아니면 그 아래의 두번째 구역에 있는 동작들을 실행하는 것입니다."
    C4_for_loops:
      1:
        text: "코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다."
      2:
        text: "예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다."
      3:
        text: "일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다. 예를 들어, 꽃꿀이 1 만큼씩 들어있는 꽃들이 한 줄 있고, 그 다음 줄에는 꽃꿀이 2만큼씩, 그 다음에는 3만큼씩 들어있는 꽃들이 있다고 한다면, 첫 줄에서 1, 두 번째 줄에서 2, 세번째 줄에서 3으로 증가하는 '카운터' 를 이용해서 꿀벌이 꽃꿀을 모으도록 할 수 있습니다."
      4:
        text: "for 반복을 이용하면, 카운터 증가 값으로 1 이상의 값을 사용할 수 있습니다. 2 만큼 씩, 4 만큼 씩 등, 한번 작업을 실행한 후에 원하는 값 만큼씩 카운트의 값이 증가 하도록 할 수 있습니다."
    C4_for_loops_bee:
      1:
        text: "코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다."
      2:
        text: "예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다."
      3:
        text: "일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다. 예를 들어, 꽃꿀이 1 만큼씩 들어있는 꽃들이 한 줄 있고, 그 다음 줄에는 꽃꿀이 2만큼씩, 그 다음에는 3만큼씩 들어있는 꽃들이 있다고 한다면, 첫 줄에서 1, 두 번째 줄에서 2, 세번째 줄에서 3으로 증가하는 '카운터' 를 이용해서 꿀벌이 꽃꿀을 모으도록 할 수 있습니다."
      4:
        text: "for 반복을 이용하면, 카운터 증가 값으로 1 이상의 값을 사용할 수 있습니다. 2 만큼 씩, 4 만큼 씩 등, 한번 작업을 실행한 후에 원하는 값 만큼씩 카운트의 값이 증가 하도록 할 수 있습니다."
    C4_for_loops_no_bee:
      1:
        text: "코드를 반복 시키기 위해서 반복 블록을 사용할 때, 컴퓨터는 어떻게 얼마나 반복 시켜야하는지 아는 것 일까요? 반복 블록은 실제로는 더 정교한 for 반복 코드가 숨겨져있는 코드로서, 어떤 값에서 시작해서 일정한 값을 더하면서 어떤 목표값까지 증가시키며 카운트 하는 코드의 간단한 형태의 코드라고 할 수 있습니다."
      2:
        text: "예를 들어, 3번 반복하는 코드는 1부터 3까지 1씩 증가시키며 카운트하는 것입니다. 반복 구조 안에 있는 코드를 실행한 후 한 번씩 카운트하는 것입니다. for 반복은 카운터 변수를 이용해서, 시작 값부터 목표 값까지 일정 값 만큼 씩 증가시키면서 실행합니다. 반복 구조안의 코드가 실행될 때마다 카운터 값을 증가시켜 반복을 시키는 것으로, 카운터 변수의 값이 마지막 목표 값보다 커지면 반복 실행을 중단합니다. 일반적인 반복 코드 대신에, for 반복을 사용했을 때의 장점은 반복 구조 안에 카운터 변수의 사용을 실제로 살펴볼 수 있다는 것입니다."
    C4_function_create:
      1:
        text: "여러분은 함수 블록을 수정해 보았습니다. 이번에는 새로운 함수 블록 만들기를 시도해 볼 시간입니다. 진짜 쉽습니다. 도구 상자를 보면 함수라는 카테고리를 볼 수 있을 것입니다. 그 것을 클릭하면 함수 만들기라는 오렌지색 버튼을 볼 수 있습니다. 그것을 클릭하면 이전에 함수 블록을 수정할 때 사용했던 함수 편집 창이 나타납니다."
      2:
        text: "이전과 마찬가지로, 함수 이름을 만들고, 함수에 대한 설명을 작성합니다. 예를 들어, 사각형이나 삼각형을 그릴 수 있도록 한 후, 툴박스에서 블록들을 드래그해서 작업공간으로 가져다 놓습니다. 함수로 만들기 위해서는 이 블록들을 녹색 부분 안으로 넣으면 됩니다."
      3:
        text: "그렇게 완성되면, 저장하고 끝내면 됩니다. 그렇게 하면 원래 퍼즐의 작업공간으로 이동할 것입니다. 새로 만든 함수는 도구 상자의 함수 카테고리에 녹색 블록으로 나타나게 될 것입니다. 만든 블록을 작업 공간으로 가져와 사용하면 다른 블록들과 마찬가지로 퍼즐을 해결할 때 사용할 수 있습니다."
    C4_function_edit:
      1:
        text: "컴퓨터 프로그래밍에서 더 멋진 것은, 일단 컴퓨터가 해야할 작업을 컴퓨터에게 가르쳐 놓으면, 함수로 다시 불러 실행시킬 수 있다는 것입니다. 원하는 작업들을 하나로 묶어 이름을 붙여두면, 다시 불러 실행시킬 수 있습니다. 이것은 마치 사용 가능한 언어들을 확장시키는 것과 거의 같습니다."
      2:
        text: "우리가 만든 프로그램에서, 이동하고 회전하는 작업을 4번 반복함으로써 1개의 사각형을 그릴 수 있다는 것을 배웠습니다. 그러한 작업을 함수로 만들어, 사각형 그리기라고 이름을 붙여두면, 원할 때마다 불러 사용할 수 있습니다. 불러서 사용할 때에는 \"사각형 그리기\"라고 말하면, 그 함수를 호출하고 그렇게 이름 붙여둔 한 묶음의 코드를 실행하게 될 것입니다. 이제 가능하게 되었네요. 우리가 사용하는 프로그래밍 언어에 그런 함수 개념을 추가했습니다."
      3:
        text: "이 퍼즐에는 사각형을 그리는 함수가 만들어져 있습니다. 도구상자에서 녹색 블록을 살펴볼 수 있습니다. 여러분들이 해야할 일은 예전에 만들었던 코드를 다시 만들어서 이 함수에 넣는 것입니다. 그렇게 하기 위해서는 녹색의 사각형 그리기 블록을 수정해야 합니다. 수정하기를 누르면 코드 편집 창이 뜨게 될 것 입니다 코드 편집 창은 3개의 부분을 나뉘어져 있습니다. 하나는 함수 이름을 넣는 부분이고, 녹색 함수 앞에 나타납니다. 그 다음에 만든 함수에 대한 간단한 설명을 작성해 넣으면 됩니다."
      4:
        text: "이렇게 하면 사각형을 그릴 수 있을 것 입니다. 이 아래에 있는 흰색 공간은 작업 공간이고, 여러분들이 이미 사용했었던 그 작업 공간과 같습니다. 도구 상자에 있는 블록들을 드래그 앤 드롭해서 이 작업 공간에 놓아보세요. 함수가 사각형을 그릴 수 있도록 녹색 영역 안에 사각형을 만들 수 있는 블록들을 집어 넣어주세요. 다 만들고 나면 저장하고 끝내세요. 작업 공간으로 돌아갈 것입니다. 그렇게 하고 나면 새로 만들어낸 사각형 그리기 블록을 다른 블록들처럼 똑같이 사용할 수 있습니다."
    C4_function_parameters:
      1:
        text: "여기 한 변의 길이가 50 픽셀인 사각형을 1개 그리는 함수가 있습니다. 그렇다면, 한 개는 한 변의 길이가 50 픽셀이 되도록 그리고, 다른 한 개는 한 변의 길이가 100 픽셀이 되도록 그리려고 한다면 어떻게 해야할까요? 거의 비슷한 두 개의 함수를 따로 따로 만들 필요는 없습니다. 대신, 하나의 함수에 하나의 매개 변수를 함께 사용하면 됩니다."
      2:
        text: "매개 변수들은 함수 안에서 사용되는 변수들처럼 사용되는데, 어떤 값들을 함수에게 전달하기 위해서 사용됩니다. 이 함수에 매개 변수를 추가해서 크기가 다른 사각형들을 그릴 수 있도록 하겠습니다. 이전처럼 함수 편집 창에서 이름과 설명을 수정할 수 있는데, 매개 변수를 추가해야 합니다. 빈 공간에 매개 변수 이름을 작성해 넣고 매개 변수 추가를 누르세요. 그렇게 하면 방금 만든 매개 변수 이름으로 빨간 블록이 만들어 질 것입니다. 이제 앞으로 이동 100 픽셀 이동하는 블록을 길이 매개 변수를 이용해서 그 길이 만큼 앞으로 이동하게 할 수 있습니다."
      3:
        text: "저장하고 닫기를 누른 후 새로 만든 사각형 만들기 블록을 함수 카테고리에서 도구상자로 드래그 하세요. 그렇게 하면, 길이라고 쓰여있는 곳 옆이 비어있다는 것을 알게 될 것입니다. 함수는 길이 매개 변수를 사용하기 때문입니다. 수학 카테고리에서 수 블록을 드래그해서, 이 공간에 놓으세요. 함수를 계속 사용해보면서 살펴보고, 서로 다른 크기의 사각형들을 만들어보세요. 열심히 시도해 보세요!"
    C4_intro:
      1:
        text: "일반적으로 프로그래밍은 텍스트로 작성을 하지만, 오늘 우리는 블러클리(Blockly) 를 사용할 것입니다. 블러클리는 프로그램을 작성하기 위해서 비주얼 블록들을 사용합니다. 하지만, 내부적으로는 코드를 작성하는 것입니다. 시작하면서, 앵그리 버드가 자기 알들을 훔쳐간 나쁜 돼지를 미로를 이동해서 잡을 수 있도록 코드를 작성할 것입니다."
      2:
        text: "블러클리의 화면은 3개의 주 화면으로 분할되어있습니다. 왼쪽은 프로그램이 실행된 후 새가 움직일 미로입니다. 각 레벨을 위한 설명은 미로 아래에 작성되어있습니다. 가운데 영역은 도구 상자이고, 이 블록들은 새를 동작시킬 수 있는 명령어입니다. 오른쪽의 빈 공간은 프로그램을 만드는 작업 공간입니다."
      3:
        text: "만약 제가 이동하기 블록을 작업 공간에 끌어다 놓고 \"실행\" 버튼을 누르면 어떻게 될까요? 새가 앞으로 한 칸 움직입니다. 그리고 새가 한 칸 이동한 다음에 무언가를 하길 원한다면, 어떻게 하면 될까요? 다른 블록을 추가하면 됩니다."
      4:
        text: "저는 \"오른쪽으로 이동\" 블록을 선택할 것입니다. 그리고 노란색 화살표가 보일 때까지 이동 블록 아래로 끌 것입니다. 그 다음에 놓으면 두 블록은 서로 달라붙을 것입니다. 제가 \"실행\" 버튼을 다시 눌렀을 때, 새는 여러분의 작업 공간에 쌓여 있는 명령들을 위에서 아래로 수행할 것입니다."
      5:
        text: "어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 휴지통으로 넣으면 됩니다. 실행시켰을 때에는 재실행 버튼을 눌러 새를 처음 위치로 돌려 놓을 수 있습니다. 이제 저 돼지들을 잡아보세요!"
    C4_math_artist:
      1:
        text: "높이가 50 픽셀이고, 너비가 높이의 두 배인 사각형 한 개를 그리려면, 컴퓨터로 어떻게 프로그래밍 해야할까요? 그럼 저는 화가에게 위로 50 만큼 움직이고, 오른쪽으로 돌고, 다시 100 만큼 가고... 하는 전체 단계를 두 번 시킬 수 있습니다. 하지만, 그렇게 하지 않고 수학적으로 계산해서 컴퓨터에게 시킬 것입니다."
      2:
        text: "머리 속으로 50에 2를 곱하는 것이 어렵지 않을 수도 있지만, 컴퓨터는 계산도 아주 잘하기 때문에, 그런 계산도 가능한 한 컴퓨터에게 맏겨야 합니다. 만약에 높이라는 변수를 대신 사용했다면, 높이를 50 으로 쉽게 바꿀 수 있고, 화가가 그 높이 만큼 위로 이동한 후, 오른쪽 회전하고, 그 높이의 2배 만큼 앞으로 이동하는 것을 2번 반복 시킬 수 있습니다. 그렇게하면 너비가 높이의 2배가 되는 사각형을 하나 그릴 수 있습니다."
    C4_unplugged_algorithms:
      1:
        text: "이번 레슨은 탱그램 알고리즘입니다. 탱그램은 7개의 조각을 이용해서 어떤 모양을 만들어내는 퍼즐입니다. 여러분은 여러분의 짝에게 퍼즐 조각을 맞추는 방법을 설명하기 위해서 알고리즘을 사용하게 될 것입니다."
      2:
        text: "알고리즘은 어떤 작업을 완료하기 위해서 수행할 수 있는 단계들의 리스트에 불과합니다. 우리는 쇼핑리스트나 음식 요리법과 같은 곳에서 매일 알고리즘을 사용합니다. 알고리즘이 간단하면 여러 가지 형태로 변화시켜 사용할 수 있으며, 여러분이 원하는 것을 정확히 모르는 사람이라도 알고리즘을 통해 정확히 수행시킬 수 있습니다. 어떤 사람이라도 여러분이 원하는 것을 정확히 수행하기를 원한다면, 알고리즘은 매우 자세하고 상세해야 합니다."
      3:
        text: "저는 그림을 완성하기 위해 알고리즘을 사용하고 있는 중입니다. 늑대들을 그리려고 하는데 그렇게 썩 잘 그리지는 못해요. 다행히도 저와 같은 사람들을 위해서 페인트에는 번호들이 붙여져 있습니다. 40 개의 색이 있는데 소문자들과 숫자가 쓰여 있어서, 각 부분에 어떤 페인트를 칠해야하는지 쉽게 알 수 있습니다. 번호 숫자들로 페인팅하는 것은, 제가 어떤 색을 어떤 자리에 칠해야하는지 정확하게 알려줍니다."
      4:
        text: "아주 자세하게 되어있어서, 설명들을 따라하면 저도 아주 멋진 그림들을 만들 수 있습니다. 그건 바로 아주 멋진 알고리즘입니다. 만약에 설명들이 충분히 자세하지 않다면, 제가 그린 늑대들은 별로 멋지지 않았을 것입니다. 여러분들이 어떤 일을 하는데, 계획한 것처럼 정확하게 되기를 원한다면, 아주 아주 세세하게 계획하는 것이 가장 좋은 방법입니다."
    C4_unplugged_binary:
      1:
        text: "각 팀에서, 각 팀원의 종이를 펼지 접을지 지시하는 사람은, 누가 on 기호를 나타내고, 누가 off 기호를 나타내야 하는지 이해하고 있어야 합니다. 2진 체계는 마치 2개의 문자로만 이루어진 알파벳 문자라고도 생각할 수 있습니다. A와 B만으로, 모든 나머지 알파벳들을 표시해야하는 것과 같습니다. 2진 체계는 0 과 1 만으로 모든 것들을 표현해야 한다는 것입니다."
      2:
        text: "2진 체계를 사용하는 가장 일반적인 방법은 조건문 입니다. 조건문은 프로그래밍에서 가장 오래된 개념 중 하나 입니다. 프로그램이 실행되다가 어떤 것이 참이면, 그에 따른 작업을 합니다. 만약 거짓이면 다른 작업을 하고요. 여러분은 더 복잡한 작업들도 원할 수 있습니다. 조건문 말고 컴퓨터로 이미지나 사운드 같은 것을 작업하는 것 같은 것들입니다."
      3:
        text: "컴퓨터는 2진 체계만 이해할 수 있습니다. 이미지는 0 과 1 로만 구성된 2진 체계가 아닌데 어떻게 이미지를 표현할 수 있는 것 일까요? 여기 예시가 있습니다: 이런 멋진 그림입니다. 그림은 기본적으로 정보의 형태라고 볼 수 있습니다. 모든 정보는 2진 체계를 이용해 여러 가지 형태로 저장될 수 있습니다. 어떻게 그렇게 할 수 있는지 이해할 수 있을 것입니다."
      4:
        text: "자 이 팬더곰 이미지 위에 격자를 그린다고 생각해 봅시다. 그렇게 만들어진 사각형들이 있는데 어떤 사각형이 더 검고, 어떤 사각형이 더 흰지 결정할 것입니다. 그런 방법을 컬러로도 적용할 수 있습니다. 이제 각각의 사각형은 검정 또는 흰색이고, 검정 사각형들은 0(2진수) 으로 흰색 사각형들은 1(2진수) 로 표현할 수 있습니다. 그리고 그렇게 다 하고 나면 1과 0의 뭉텅이들이 됩니다. 이렇게 표현하는 방법이 2진 체계를 이용해서, 이 이미지를 표현하는 방법이라고 할 수 있습니다."
    C4_unplugged_forloops:
      1:
        text: "이번 레슨은 재미있는 반복 구조입니다. 이번 레슨에서 우리는 주사위 게임을 하기 위해서, 선들을 사용할 것입니다. 각 플레이어는 시작 값, 정지 값, 증가 값을 결정하기 위해 주사위를 3번 던질 것입니다. 턴이 지날 때 마다, 시작 값에서 시작해서 증가값 만큼씩 원형으로 이동할 것입니다. 그러다가 정지 값에서 멈추게 됩니다. 가장 높은 점수를 얻는 플레이어가 이기게 됩니다!"
      2:
        text: "For 반복 구조는 여러 곳에서 편리하게 사용될 수 있습니다. 기상학자가 되고 싶어하는 사람들은 for 반복 구조를 항상 사용하는 것이 좋습니다. 안녕하세요. 저는 베키입니다. 저는 EverPower 라는 재생에너지 회사에서, 바람 관련 기상학자로 일하고 있습니다. 저는 저희 회사가 운영하고 있는 풍력 발전기들이 있는, 콜럼비아 강 협곡 지역의 바람 속도에 대해 미리 예측하고 있습니다."
      3:
        text: "우리는 얼마나 많은 바람이 불 때, 얼마나 많은 전기를 얻을 수 있는지 알아내고자 노력하고 있습니다. 그렇게 얻어진 정보는 실시간으로 에너지 거래 회사에게 전달합니다. 에너지 거래 회사는 우리가 전달해 주는 정보를 바탕으로 전력 생산 그리드의 균형을 맞춰가며 전기를 팔고 삽니다. 여러분 집의 전등들이 계속 켜져있는 것은, 우리 회사의 풍력 발전 농장에서 에너지를 최대로 생산하고 있기 때문입니다."
      4:
        text: "우리는 포틀랜드에 있는 EverPower 재생에너지 회사의 종합 제어 센터에 있는데, 이 곳에서는 전국에 있는 풍력 발전 농장으로부터 들어오는 정보들을 알 수 있습니다. 아무리 성능이 좋은 컴퓨터들이라고 할 지라도, 모든 대기의 흐름과 상태를 시뮬레이션 할 수 없습니다. 컴퓨터를 활용하는 일기예보 모델들이 있는데, 우리는 그것을 그리드라고 부릅니다. 각 그리드 포인트는 위도, 경도에 따라 점으로 나타납니다. 우리는 바람의 속도, 온도, 압력들과 같은 것을 예측하기 위해서 물리학적 계산들을 해야만 합니다."
      5:
        text: "이런 것들은 일반적으로 큰 격자들인데, 수 많은 그리드 점들에 대해서 수 백만 번 계산해야하기 때문에 그 만큼 시간도 많이 걸립니다. 그렇게 반복적으로 계산할 때 반복 구조들을 사용합니다. 여기 있는 예시는 그런 반복 구조에 대한 것입니다. 여러분들이 바람의 방향을 예측하려고 한다면, 사람이 앉아서 계산할 수 있을 정도의 계산이 아니라, 아주 많은 요인들과 변인들을 모두 고려한 수 많은 계산들이 필요합니다. 바람이 어떻게 영향을 받고 어떤 일이 일어날 지에는 아주 많은 원인들이 있기 때문에, 우리는 바람을 예측하기 위해서 컴퓨터 계산과 모델링이 반드시 필요합니다."
    C4_unplugged_madlibs:
      1:
        text: "이번 레슨에서는, 빈칸 채워 이야기 만들기를 할 것 입니다. 여러분에게는 빈칸을 채워 이야기를 만들 수 있는 양식을 가지고 있습니다. 그 빈칸에 어떤 것을 채우냐에 따라서 매우 재미있는 다양한 이야기들을 만들어 낼 수 있습니다."
      2:
        text: "이전에 이미 만들었던 2개의 스토리에서, 그리고 이번 레슨에서 추상화된 구조에 대해서 배웠습니다. 추상화는 어떤 내용을 대략적으로 생각하게 함으로서, 하나의 대략적인 해법으로 여러 가지 다른 문제들을 해결하는데 효과적으로 사용할 수 있다는 것을 알게되었을 것입니다. 컴퓨터과학에서 그런 추상화는 매우 편리한데, 아주 많은 상황들에서도 효과적으로 사용될 수 있는 함수들을 만들어 낼 수 있도록 해주기 때문입니다."
    C4_unplugged_parameters:
      1:
        text: "이번 레슨은 매개 변수들을 사용한 작곡입니다. 우리는 작곡을 하게 될 것입니다. 노래를 부를 때 코러스 부분을 보면 거의 같지만 약간 다른 부분이 있습니다. 여러분들은 이야이야오 라는 코러스 부분이 있는 동물놀이 노래를 아시나요? 그 노래에서 코러스 부분은 동물에 따라서 달라집니다. 동물 놀이를 해봐요. 병아리 놀이를 해봐요, 이야이야오. 각 코러스에서 바뀌는 부분을 매개 변수라고 할 수 있습니다."
      2:
        text: "어떤 함수들은 매개 변수를 사용합니다. 매개 변수는 함수에게 전달하려고 하는 추가적인 정보 조각이라고 할 수 있는데, 여러 가지 목적에 따라서 특별히 만들어 사용할 수 있습니다. 여러분들이 친구들과 함께 아이스크림을 만들때, 컴퓨터 프로그램에서 사용되는 매개 변수들과 같은 개념들을 이용해 비슷한 과정을 하는 것이라고 할 수 있습니다."
      3:
        text: "바닐라 아이스크림을 담는 그릇은 모두 같지만, 친구들에게 2가지 토핑을 고르라고 하면 아주 많은 조합이 만들어질 수 있습니다. 토핑은 함수 이름이고, 각 토핑 종류는 매개 변수라고 생각할 수 있습니다. 함수와 매개 변수는 멋지고 복잡한 프로그램들을 만들어내는데 함께 쓰입니다. 물론, 아주 많은 종류의 아이스크림도 그렇습니다."
    C4_unplugged_variables:
      1:
        text: "이번 레슨은 봉투와 변수입니다. 이번에는 뭔가 정보가 빠진 문장을 만드는 것을 해 볼 것입니다. 우리는 빈칸 채우기 문제가 어떤 것인지 알고 있습니다. 숙제를 할 때에도 빈 칸을 채우고, 이름을 적을 때에도 빈 칸을 채웁니다. 때로는 2개 이상의 단어를 채워야 할 때도 있습니다만, 그 자리를 비워 두는 것은, 그 자리에 어떤 정보를 채워야 한다는 의미라는 것을 알고있습니다."
      2:
        text: "변수는 바뀔 수 있는 정보가 놓이는 자리라고 볼 수도 있습니다. 변수를 사용해 정보를 바꿔가면서 작업을 할 수 있습니다. 소프트웨어에서는 변수들이 아주 많이 사용됩니다. 변수를 이용해 이름, 이메일 주소, 아이디 같은 것들을 바꿔가며 사용할 수 있습니다. 그런 방법을 사용해서 사용자들이 입력한 정보를 프로그램이 사용할 수 있게 되는 것입니다. 우리는 일을 하면서 변수들을 항상 사용하고 있습니다."
      3:
        text: "여러분은 나중에 사용하기 위해서 일부 정보를 남겨둘 수 있는데, 변수를 사용하면 됩니다. 트위터에서 트윗 된 횟수를 카운트할 필요가 있다고 생각해봅시다. 트위터 사용자들이 트윗 할 때마다 1씩 더해 수를 올리고, 트윗을 지울 때마다 1씩 감소 시킵니다. 사용자들이 트윗 한 횟수를 알고 싶을 때에는 변수에 저장되어있는 값만 살펴보면 됩니다."
    C4_variables_artist:
      1:
        text: "변수는 어떤 값을 저장시킬 수 있는 컨테이너입니다. 어떤 알고리즘에서 변수를 사용하면, 변수에 저장되어있는 값을 사용할 수 있습니다. 변수를 사용하면 변수에 저장되어있는 값에 따라서 다르게 움직이는 똑똑한 알고리즘을 만들 수 있습니다."
      2:
        text: "예를 들어, 동생의 생일을 축하하는 알고리즘을 만들고 싶을 때, 올해에는 10번째 생일을 축하합니다! 라고 작성할 수 있는데, 내년에는 11번째 생일을 축하합니다라고 작성해야합니다. 그러한 경우 나이를 나타내는 수 대신에, 나이라는 변수에 동생의 나이를 저장해 두고 변경해 가면서 매년 축하 메시지를 만들 수 있게 됩니다. '나이'='나이'+1 로 매년 업데이트 시켜주면 되기 때문입니다."
      3:
        text: "이 퍼즐에서는, 변수를 사용해서, 화가가 그리는 선의 길이를 설정할 것입니다. 나중에 코드를 살펴보면, 앞으로 이동하기 블록은 길이 변수에 설정해 놓은 값을 이용하게 될 것입니다."
    C4_variables_playlab:
      1:
        text: "변수는 어떤 값을 저장시킬 수 있는 컨테이너입니다. 어떤 알고리즘에서 변수를 사용하면, 변수에 저장되어있는 값을 사용할 수 있습니다. 변수를 사용하면 변수에 저장되어있는 값에 따라서 다르게 움직이는 똑똑한 알고리즘을 만들 수 있습니다."
      2:
        text: "이제 여러분은 여러분이 받은 다른 게임인 playlab을 시도해 볼 것입니다. 그리고 여러분은 속도, 높이, 점수 등과 같은 변수값을 바꿀 수 있습니다. 여러분은 변수가 어떻게 동작하는지 바꿔보기 위해 위해 게임의 알고리즘을 바꿀 필요가 없습니다."
      3:
        text: "전자책 킨들과 엑스레이 프로그램을 위해 작업을 할 때, 우리는 변수들을 다양한 방법으로 활용합니다. 책의 페이지를 저장하기 위해서 사용할 수 있는데, 페이지마다 글꼴의 크기를 다르게 저장해서 페이지가 바뀌면 글꼴의 크기도 바뀌도록 수도 있다는 것입니다. 변수들에 페이지를 저장해서 글꼴 크기들을 바꿔주도록 할 수 있습니다."
    infinity_playlab_events:
      1:
        text: "이제 우리는 모든 게임프로그래머들이 매일 사용하는 것에 대해서 배울 것입니다. 이벤트라고 하는 것들입니다. 하나의 이벤트는 프로그램이 어떤 사건이 일어났을 때, 어떻게 해야하는지 프로그램에게 알려줄 때 사용하는 것이라고 볼 수 있는데, 게임의 경우에는 어떤 동작을 하게 되는 것이라고 볼 수 있습니다. 마우스 클릭, 방향키 누르기, 화면 터치하기 등이 바로 이벤트들입니다."
      2:
        text: "이제, 플레이어가 위/아래 방향키나 버튼을 사용할 때, 베이맥스가 위로 올라가 히로를 터치하고, 다시 아래로 내려와 라푼젤을 터치하도록 할 것입니다. 위쪽 화살표 블록에, 캐릭터를 위로 이동시켜주는 블록을 붙여서, 위쪽 방향키가 눌렸을 때 \"위쪽 방향키가 눌렸을 때\" 블록에 붙여져 있는 모든 것을 실행시키도록 할 것입니다. 아래쪽 화살표 블록에 대해서도 움직이도록 하면 됩니다. 게임이 점점 더 인터랙티브하게 바뀌어 가고 있습니다."
    infinity_playlab_intro:
      1:
        text: "여러분은 몇 학년 인가요? 초등학교 2학년? 고등학교 1학년? 초등학교 1학년? 저는 중학교 2학년 때 처음으로 프로그래밍을 배웠습니다. 초등학교 6학년 때 처음 내 컴퓨터를 가지게 되었고요. 저는 다른 사람들의 문제들을 고쳐주는 것이 재미있었습니다. 여러분들은, 여러분들의 아이디어를 가지고 여러분 자신을 표현하거나, 원하는 것들을 만들어 낼 수 있습니다."
      2:
        text: "컴퓨터과학(정보과학) 은 대학생과 전문직에 종사하는 사람들이 앞으로 20 ~ 30 년 동안 해야하는 많은 일들을 위한 기초입니다. 저는 다른 사람들을 돕는 것을 좋아하기 때문에 프로그래밍을 좋아합니다. 저는 다른 사람들의 삶을 보다 편하게 만들 수 있는, 그 무엇이라도 만들 수 있는 기회를 얻었습니다. 저는 그런 것이 우리가 슈퍼 파워를 가질 수 있는 것에 가장 가까운 것이라고 생각하고 있습니다. 일단, 시작하는 것이 가장 중요합니다. 저는 스스로 초보자라고 생각하고 있습니다. 저와 같이 함께 배워보세요."
      3:
        text: "저는 존 배취(John Vechey) 이며, PopCap Games 의 공동 설립자입니다. 우리는 Plants vs. Zombies, Bejeweled, Peggle 등의 게임을 만들었습니다. 게임을 만드는 코드가 얼마나 완벽한가, 게임이 얼마나 예술적인가는 크게 중요하지 않습니다. 가장 중요한 것은 어떻게 사람들이 느끼고 재미있어 하는지입니다. 여러분들은 직접 해보면서 그런 것을 느낄 수 있기도하고, 게임을 직접 만들어보면서 그러한 것을 배우고, 터득하고, 여러분의 능력들을 반복적으로 사용하면서도 느낄 수 있습니다."
      4:
        text: "좋아하는 비디오 게임이 있나요? 우리는 Play Lab 에서 그런 게임을 만들기 위해서 한 단계씩 배워 나갈 것입니다. 좋은 게임들은 스토리가 있고, 모든 스토리에는 주인공 캐릭터들이 있습니다. 캐릭터들은 말하고, 이동하고, 다른 캐릭터들과 인터랙티브하게 상호작용합니다. 그리고 게임 스코어 포인트는 게임의 규칙에 따라 달라집니다. 오늘 우리는 스마트폰에서 실행되고 공유될 수 있는 게임을 한 단계씩 만들어 나가 볼 것입니다. 안나, 엘사, 히로, 베이백스, 라푼젤과 같은 게임 속 재미있는 캐릭터들을 이용해 게임을 만들어보세요."
      5:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다. 가운데 공간은 도구상자이고, 이 블록들은 코드들의 일부 입니다. 오른쪽의 흰 공간은 작업 공간이라고 부르는데 그 안에서 프로그램을 작성할 것입니다."
      6:
        text: "처음 시작하기 위해서, 사용할 블럭들을 \"실행하면\" 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다. 이 첫번째 퍼즐에서, 히로는 캐릭터 1이고, 베이맥스는 캐릭터 2입니다. \"실행하면\" 블록에 \"앞으로 이동하기\" 블록을 드래그해서 붙여 히로를 베이맥스에게 움직이도록 해야합니다. 블록들을 배치하면, \"실행\" 버튼을 눌러 실행 결과를 살펴보세요."
      7:
        text: "시작하고나서 마지막 쯤에는, 여러분이 직접 여러가지 캐릭터들을 이용해 게임을 만들고, 인터랙티브하게 움직이고, 점수를 올리거나, 마이크로봇/체리/냄비/불꽃/아이스를 던지고.. 서로 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요."
    infinity_playlab_repeat_forever:
      1:
        text: "여러분들은 어떤 작업을 무한히 반복한다는 것을 상상해 본 적이 있나요? 다행히도 여러분은 전혀 그럴 필요가 없습니다. 컴퓨터들이 그렇게 반복하는 것을 아주 잘하기 때문입니다. 이것은 무한 반복 블록입니다. 이 블록의 안에 넣는 것은 게임 중에 무한히 반복 실행될 것입니다."
      2:
        text: "캐릭터에게 반복적으로 작업을 시키고 싶은데, 더 이상 남은 작업이 없다면, 이 블록들을 무한 반복 블록 안에 넣을 수 있습니다. 이 다음 퍼즐에서의 목표는 안나를 반복적으로 위 아래로 움직이는 것입니다. 명령어들을 반복시키는 방법을 배우면 자기만의 게임을 만들 때 많은 시간을 줄일 수 있습니다."
    tutorial_puzzle_challenge:
      1:
        text: "커서 뭐가 되고 싶니 올리비아? 우주비행사요. 컴퓨터 프로그래머가 무슨 일을 하는 것인지 어떻게 알게 되었니? 음.. 잠시만요... 컴퓨터 프로그래밍이 정말 단순하다는 것을 어떻게 설명해야 할 지 잘 모르겠어요. 마치 요리법과 같은 명령어들의 집합이거든요. 단계별로 하나씩 따라가다보면 원하는 것을 얻게 될 거에요."
      2:
        text: "드롭 다운 메뉴를 이용해서 픽셀 값을 바꿔서 선의 길이를 조절할 수 있습니다. 얼마나 길었죠? 실행 버튼 아래를 보면 명령어들을 다시 살펴볼 수 있습니다. 여기서 앞으로 이동 블록을 사용하고, 100 픽셀을 선택합니다. 도구 상자에 블록을 넣거나 휴지통에 넣으면 블록을 없앨 수 있습니다. 다시 넣어 보세요."
      3:
        text: "실행을 눌러 코드를 실행시켜보세요. 잘 동작하지 않죠! 리셋을 눌러, 어디에 문제가 있는지 살펴보세요. 여러분들은 퍼즐들을 원하는 만큼 반복해서 해 볼 수도 있고, 안 하고 넘길 수도 있고, 다시 원하는 퍼즐로 돌아올 수 있습니다. 그냥 최선을 다해보고 포기만 하지 않으면 됩니다. 자 이제 다른 앞으로 이동 블록을 붙여 보세요. 아직 제대로 동작하지 않네요. 다른 블록들 사이에 한 블록을 넣을 수 있네요."
      4:
        text: "자 이제 회전 블록을 집어서, 앞으로 이동 블록들 사이에 넣어보세요. 45도 만큼 회전시키고, 다시 실행시켜보세요. 리셋하고, 실행하고, 짜잔! 이제 다른 퍼즐이네요. 퍼즐에 따라서 처음 시작 코드들이 주어지는 경우들이 있습니다. 여기서는 정확한 길이와 각도를 입력해야 합니다."
      5:
        text: "실수로 처음 주어진 코드를 휴지통에 버릴 수도 있습니다. 그럴 때는 어떻게 해야할까요? 처음 상태로 바꾸는 버튼을 눌러서 다시 시작시키면 됩니다. 이 수 블록을 다른 픽셀 영역에 넣을 것입니다. 100 픽셀, 45 도를 선택하고 다시 100 픽셀을 선택합니다. 좋아요! 코드 스튜디오의 꿀벌이네요. 꿀벌을 꽃들로 이동 시켜서 꽃꿀을 모아보세요."
      6:
        text: "첫 번째 꽃은 3 블록 앞에 있기 때문에, 앞으로 3번 이동해야 합니다. 1, 2, 3 그 다음에 꽃꿀을 모으고, 꽃꿀을 모으고.. 앗.. 잘 안되네요! 꿀모으기 블록들 사이에 앞으로 이동을 넣고 다시 해봐야겠네요. 예, 되네요! 여러분들은 코드 스튜디오의 화가 퍼즐, 꿀벌 퍼즐을 하는 법을 살펴보았습니다. 코드 스튜디오의 퍼즐 챌린지들에 도전해 보세요."
    unplug1:
      1:
        text: "커서 뭐가 되고 싶니 올리비아? 우주비행사요. 컴퓨터 프로그래머가 무슨 일을 하는 것인지 어떻게 알게 되었니? 음.. 잠시만요... 컴퓨터 프로그래밍이 정말 단순하다는 것을 어떻게 설명해야 할 지 잘 모르겠어요. 마치 요리법과 같은 명령어들의 집합이거든요. 단계별로 하나씩 따라가다보면 원하는 것을 얻게 될 거에요."
      2:
        text: "컴퓨터과학(정보과학) 은 모든 세상에 영향을 줄 수 있는 한 가지 방법입니다. 어떤 사람이 또 다른 누군가들과 연결되어있던지 그렇지 않던지간에 세상에 영향을 줄 수가 있습니다. 뮤직비디오가 될 수도 있고, 게임이 될 수도 있습니다. 다른 사람들의 친구들을 찾아 볼 수도 있습니다. 사람들의 생명을 구하는 그 어떤 형태의 것이라도 할 수 있습니다. 여러분은 자동차를 운전할 수도 있고, 저는 페인트 칠을 할 수도 있습니다. 저는 위대한 프로그래밍이란 것이, 위대한 예술가들의 작품들과 그렇게 크게 다르지 않다고 생각합니다."
      3:
        text: "제가 마지막으로 프로그래밍을 조금 배웠을 때, 이것 저것 이해가 되지 않고 막혀있었는데, 그 닫혔던 문을 열어주고 수 많은 길과 문이 있는 통로로 연결된 길로 인도해 준 것 같았습니다. 프로그래밍은 재미있고 쉽습니다. 원하는 것이 무엇이라도 할 수 있습니다. 여러분들은 이제 막 빛이 흘러나오는 문들을 이제 열기 시작했다는 것입니다. 저에게 있어서 만들고 난 프로그램은 빛으로 채워진 구조와 같습니다. 모든 곳이 반짝이고 있고요. 여러분들이 만나고 교류하는 많은 사람들은 예전에는 볼 수 없는 세상입니다."
      4:
        text: "이 시리즈의 첫번째 레슨은 컴퓨터과학이란 무엇인가, 컴퓨터과학자가 하는 일은 무엇인가, 컴퓨터과학기술을 어떻게 책임있게 사용해야 할 까 입니다. 그것은 매우 중요한 내용들이지만, 내용이 그렇게 많지는 않습니다. 마지막 쯤에는 여러분 이름의 이니셜을 이용해서 무언가를 만들게 될 것입니다. 2진 체계를 매우 기계적으로 느낄 수 있지만, 일단 한 번 이해하고 나면 마치 비밀 언어를 말하는 것과 같습니다. 재미있고 매우 중요한 활동이 될 것입니다."
    unplug2:
      1:
        text: "컴퓨팅사고력(computational thinking) 에 대한 이번 레슨은 여러분들에게, 큰 문제를 어떻게 보다 간단한 여러 개의 작은 문제들로 나눌 수 있는지 알려드리기 위한 목적이 있습니다. 이번 레슨의 목표는 수업 계획에 포함되어있는 몬스터들 중 하나를 똑같이 그릴 수 있도록 하는, 한 세트의 명령어들을 만들어 내는 것입니다."
      2:
        text: "명령들을 작성하기 위해서 학생들은 여러 개의 모둠으로 나뉠 것이고, 몬스터를 그리는데 필요한 명령어 세트를 만들어서 다른 모둠과 바꾸게 될 것입니다. 각 모둠들은 다음과 같은 컴퓨팅사고의 4단계를 따라 명령어들을 만들게 될 것입니다: 분해, 패턴 찾기, 추상화, 알고리즘."
      3:
        text: "첫 번째 그룹들은 게임을 만들어내기 위한 계획을, 보다 작은 작업들로 분해할 것입니다. 그 다음에 카타로그에 나와있는 모든 몬스터들 사이에 어떤 패턴들이 있는지 살펴보게 될 것입니다. 몬스터들 사이의 차이를 발견하면, 그러한 자세한 차이들을 추상화하거나 고려하지 않을 수 있게 될 것입니다. 즉, 카탈로그의 한 몬스터는 베지터 눈을 가지고 있고, 다른 몬스터는 스프라이트 눈을 가지고 있습니다. 하지만, 두 몬스터 모두 눈을 가지고 있기 때문에, 몬스터는 어떤 눈을 가지고 있다고 작성할 수 있습니다."
      4:
        text: "그렇게 학생들은 알고리즘이라고 불리는 명령어 집합을 만들 수 있을 것입니다. 그 알고리즘에는 몬스터의 각 부분의 스타일을 선택할 수 있도록 빈 칸들로 구성되어있어야 합니다. 이것이 바로 다른 학생들에게 전달해야할 명령어 세트로서, 이 명령어 세트를 이용해서 특정 몬스터 모양을 그대로 만들 수 있어야 합니다."
    unplug3:
      1:
        text: "모눈 종이 프로그래밍에서는, 화살표와 낙서들만 사용해서 어떤 그림을 똑같이 그려낼 수 있는 방법에 대해서 설명할 것입니다. 한 사람은 그림이 그려진 모눈 종이를 가지고 있는데, 그 사람은 화살표들만 이용해서, 그 그림을 어떻게 똑같이 그려낼 수 있는지 설명해야 합니다."
      2:
        text: "이번 활동에서 사용할 수 있는 기호들은 다음과 같습니다: 한 칸 앞으로 이동, 한 칸 뒤로 이동, 한 칸 위로 이동, 한 칸 아래로 이동, 색 바꾸기, 색으로 모눈 채우기. 이런 기호들을 사용해서 코드를 만들고 나면, 다른 사람에게 주어서 코드를 읽어 그림을 똑같이 그려보도록 할 것입니다."
    unplug4:
      1:
        text: "모눈 종이 프로그래밍에서는, 화살표와 낙서들만 사용해서 어떤 그림을 똑같이 그려낼 수 있는 방법에 대해서 설명할 것입니다. 한 사람은 그림이 그려진 모눈 종이를 가지고 있는데, 그 사람은 화살표들만 이용해서, 그 그림을 어떻게 똑같이 그려낼 수 있는지 설명해야 합니다."
      2:
        text: "활동의 중간 쯤에, 16개의 서로 다른 사각형들을 만들기 위해서 종이를 접는 방법이 모두 몇 가지인지 학생들에게 물어봅니다. 그 다음에 얼마나 많은 방법들이 같은 결과들을 만들어낼 수 있는지 토론해 보고, 어떤 상황에서 어떤 방법들이 더 효율적인지 이야기 해 볼 것입니다."
    unplug5:
      1:
        text: "모눈 종이 프로그래밍에서는, 화살표와 낙서들만 사용해서 어떤 그림을 똑같이 그려낼 수 있는 방법에 대해서 설명할 것입니다. 한 사람은 그림이 그려진 모눈 종이를 가지고 있는데, 그 사람은 화살표들만 이용해서, 그 그림을 어떻게 똑같이 그려낼 수 있는지 설명해야 합니다."
      2:
        text: "활동의 중간 쯤에, 16개의 서로 다른 사각형들을 만들기 위해서 종이를 접는 방법이 모두 몇 가지인지 학생들에게 물어봅니다. 그 다음에 얼마나 많은 방법들이 같은 결과들을 만들어낼 수 있는지 토론해 보고, 어떤 상황에서 어떤 방법들이 더 효율적인지 이야기 해 볼 것입니다."
    unplug6:
      1:
        text: "이 활동은 카드 코딩이라고 부르며, 어떤 나이에도 매우 좋습니다. 이전 레슨들에서 블러클리를 이용해서 조건/선택문에 대해서 배웠는데, 조건/선택 문은 주어진 내용이 참인지 거짓인지 평가해 주는 조각이라고 볼 수 있습니다. 그러한 것을 조건/선택이라고 하고, 매우 많은 다양한 방법으로 사용될 수 있습니다."
      2:
        text: "랜덤으로 만든 카드를 이용해서, 종이에 프로그램을 만들어 낼 수 있다는 장점이 있습니다. 랜덤으로 만든 카드의 수가 8보다 클 때, 어떤 말을 하도록하거나, 점수를 얻도록 하는 조건/선택문을 사용할 수 있습니다. 아니면, 상대방이 점수를 얻게 할 수 있습니다. 여러분이 원하는대로 단순하게, 복잡하게 마음대로 만들 수 있습니다."
    unplug7:
      1:
        text: "노래 가사를 보면 처음에 후렴 부분이 정해져 있는 것을 알 수 있습니다. 그리고 그 후렴 부분을 노래를 부를 때, 참고해야 한다는 것을 누구나 알고 있습니다. 함수는 그런 후렴과 비슷하게 생각할 수 있습니다."
      2:
        text: "이 레슨에서는, 처음에 노래의 코러스 반복 부분을 정의 한 다음에, 노래의 앞 뒤로 이동하면서 노래를 부를 것입니다. 하지만, 노래를 부를 때에는 코러스라는 말을 쓰지 않고, 자동으로 코러스(후렴) 부분이라는 곳으로 앞 뒤로 이동하면서 노래를 부르게 됩니다. 이는 마치 함수를 정의하고 호출해서 사용하는, 프로그래밍 과정을 이해하기에 매우 좋습니다."
      3:
        text: "우리는 이야이야호 동물놀이와 같은 익숙한 노래를 이용해서, 코러스 부분을 반복해서 부르거나, 조금씩 변형 시켜 부를 것입니다. 이야이야호와 같은 노래에서는 단어만 바꾸며 노래를 부릅니다. 그 점은 매개 변수를 설명하기 좋습니다. 매개 변수를 이용해서, 원하는 단어를 변수에 저장해서 함수에 전달할 수 있습니다. 모든 사람들이 알고 있는 익숙한 노래가 있으면, 그 노래를 이용해서 하면 됩니다. 같이 할 수 있나 살펴보세요."
    unplug8:
      1:
        text: "추상화에 대한 레슨은 마치 매드립 게임과 비슷합니다. 빈칸에 다양한 단어들을 채울 수 있기 때문에, 매우 다양한 이야기를 만들 수 있기 때문입니다. 그러한 상황을 이용해서, 아이들이 자기 자신들이 원하는 이름을 채워서 자기만의 이야기를 만들 수 있고, 그러한 방법으로 추상화 개념을 설명하게 됩니다."
      2:
        text: "그것은 모두 함수들에 대한 이야기입니다. 이야이야호 동물농장 노래에서는 반복되는 부분이 있지만, 조금씩 바뀌는 동물들과 소리가 있습니다. 그 바뀌는 부분에 다른 것이 들어갈 수 있다는 것을 알 것입니다. 만약 3개의 부분이 바뀐다면, 3개의 매개 변수를 사용해서 추상화시키면 되고, 그런 방법은 매우 편리합니다."
      3:
        text: "1개의 함수로도 서로 다른 많은 문제들을 해결할 수 있습니다. 여러 가지 문제들이 약간씩만 다르다는 것을 인식하지 못한 사람들은, 문제들을 해결하기 위해 필요한 함수들을 각각 따로 만들 것입니다. 약간씩 다른 차이들만 다르게 다룰 수 있는 방법을 찾게 되면, 14개의 함수들을 일일이 다 만드는 대신, 1개의 함수를 재사용 할 수 있을 것입니다."
    unplug9:
      1:
        text: "릴레이 프로그래밍은 매우 재미있는 수업으로, 컴퓨터과학(정보과학) 융합 수업이라고 할 수 있습니다. 학생들이 지쳐갈 때, 학생들을 활기차게 만들고 싶을 때가 자주 있습니다. 이 릴레이 프로그래밍은 컴퓨터과학 수업에 활기를 불어넣어 주는 방법들 중 하나 입니다."
      2:
        text: "모든 학생들을 2개의 그룹으로 나누어, 이어달리기를 할 때 처럼 각각 한 줄로 따로 서도록 합니다. 각 그룹의 첫번째 사람은 교실의 반대편에 있는 여러분에게 달려오도록 하는데, 여러분은 그림이 그려져 있는 모눈 종이를 들고 있고, 줄을 서있는 학생들은 빈 모눈 종이를 가지고 있습니다. 학생들은 자기 모눈 종이에 그림을 그려내기 위해서, 여러분에게 달려오고, 다시 그 줄의 맨 뒤에 서고를 반복하면서 다음 사람에게 다음 단계를 그릴 수 있도록 종이를 넘깁니다."
      3:
        text: "이 활동은, 자신이 만들어 낸 것과 다른 사람들이 만들어 낸 것들을 확인하는 디버깅과 연관된 활동으로 매우 좋은 방법입니다. 특히, 팀별로 함께 작업하는 과정에서는 자기가 코딩을 할 때 주의 깊게 하는 것이 매우 중요하다는 것을 금방 이해할 수 있습니다."
    unplug10:
      1:
        text: "이 활동은 이해하기 쉬운 방법으로, 인터넷이 동작하는 원리를 설명하는 것입니다. 우리는 여러분들에게 필요한 간단한 용어들의 의미에 대해서 모두 설명할 것이고, 그렇게 함으로서 학생들은 이메일과 같은 메시지 전송을 시뮬레이션 할 수 있게 될 것입니다."
      2:
        text: "학생들 각각은 자기가 무선 인터넷, 초고속인터넷, 광인터넷이라고 가정하고 메시지들을 전달할 것입니다. 무선 Wi-fi를 흉내내는 학생은 메시지를 전송할 때, 자기 머리위에 메시지를 놓아야 합니다. 왜냐하면 무선은 정보를 떨어뜨리기 쉽기 때문입니다."
      3:
        text: "초고속인터넷을 흉내내는 학생들은 손등으로 메시지를 전달할 것입니다. 정보가 비교적 잘 떨어지지 않기 때문입니다. 그리고 광케이블인터넷을 흉내내는 학생들은 양손으로 메시지를 전달할 것입니다. 이 활동은 우리가 매일 사용하는 것을 학생들이 이해할 수 있도록 하는 좋은 방법입니다."
    unplug11:
      1:
        text: "이제 지난 19개의 레슨들에서 여러분들이 해왔던 모든 것들을 전체적인 관점에서 살펴보고 생각해 볼 시간입니다. 학생들이 수행했던 것들이 매우 큰 성취 였다는 것을 학생들에게 이야기 해주기 매우 좋은 시간입니다. 학생들은 컴퓨터과학(정보과학) 에 대해서 대부분의 어른들이 알고 있는 것보다 훨씬 더 많이 배웠습니다."
      2:
        text: "한 반 수업이나 보다 작은 모둠 수업에서 학생들이 좋아하는 수업들에 대해서 토론해보세요. 일단 배웠던 모든 것들에 대해서 살펴보고 나면, 그 때 학생들의 창의성이 빛날 수 있습니다. 학생들을 보다 작은 그룹으로 나눈 후, 언플러그드 활동을 만들어 보도록 해보세요. 각 그룹에 함수, 알고리즘과 같은 핵심 개념을 할당해 주고, 학생들이 사용할 수 있는 여러 가지 재료와 도구들을 나누어 주세요. 각 그룹별로 자신들이 만들어낸 언플러그드 활동을 발표하도록 하던지, 다른 날을 잡아 학생들이 만들어낸 활동들을 직접 해볼 수 있도록 해보세요."
      3:
        text: "Code.org 의 모든 여러분들이 이 코스를 재미있게 경험해 보기를 바랍니다. 여러분의 꿈이, 최고의 새로운 앱을 만드는 것, 사람들의 질병을 치료하는데 도움이 되도록 프로그래밍을 활용하는 것, 유명한 문제해결 고수가 되는 것이 아니더라도, 이 코스는 그러한 꿈을 이루기 위한 첫번째 단계라고 볼 수 있습니다."
    starwars_intro:
      1:
        text: "안녕하세요. 저는 캐슬린 케네디이고, 스타워즈: 깨어난 포스 영화의 제작자입니다. 오늘 여러분은 스타워즈에 나오는 별들 중 하나에서 작업을 하게 될 것인데, BB-8은 공처럼 생긴 드로이드입니다. BB-8 의 모든 동작과 움직임은 컴퓨터 소프트웨어를 통해 이루어집니다. 컴퓨터과학(정보과학) 은 마켓팅, 헬스케어, 영화까지 모든 산업에 영향을 줍니다. 실제로, 수백명의 컴퓨터 엔지니어들이 함께 작업해서, 스타워즈 같은 영화를 만들어내는 것입니다."
      2:
        text: "안녕하세요, 저는 레이첼 로즈입니다. 저는 ILM의 수석 R&D 엔지니어로서, 애니메이션과 크리쳐 개발 팀을 이끌고 있습니다. 스타워즈: 깨어난 포스에서, 저는 예술가들이, 머나 먼 우주 어딘가에 실제로 있을 것 같은 캐릭터들의 장식을 만드는 것을 돕고 있습니다."
      3:
        text: "다음 시간에는 나만의 스타워즈 게임을 만들 것입니다. 여러분들에게 기본적인 프로그래밍 기초/개념/원리들을 알려드릴꺼에요. 일반 프로그래밍은 몽땅 텍스트로 키보드로 입력해서 작성하는데, 여기서 우리는 블록들을 이용해서 드래그 앤 드롭 방식으로 프로그램들을 만들어 볼 것입니다. 블록들로 프로그래밍을 하지만, 실제로 내부적으로는 실제 텍스트 코드를 만들고 있는 것이라고 볼 수 있습니다. 일단 블록들을 이용해서 기초적인 것들을 해보고 배운 후에, 웹 프로그래밍 언어로 가장 많이 사용되는 언어 중 하나인, 자바스크립트로 똑같은 퍼즐들을 해결해 볼 것입니다."
      4:
        text: "시작하기 위해서, 레이 공주가 BB-8을 프로그래밍해서, 부서진 조각들을 모을 수 있도록 할 것입니다. 화면은 3개의 부분으로 나뉘어져 있습니다. 왼쪽은 스타워즈의 게임 공간이고, 코드가 실행되는 곳입니다. 각 레벨의 목표들은 게임 공간의 아래에 적혀있습니다."
      5:
        text: "가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 명령어입니다."
      6:
        text: "오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다."
      7:
        text: "제가 moveLeft(); 블록을 작업 공간으로 드래그 한 후, 실행을 누르면 어떤 일이 일어날까요? BB-8이 왼쪽으로 한 블록 이동할 것입니다."
      8:
        text: "MoveLeft(); 블록 다음에 다른 작업을 BB-8에게 시키려면? 다른 블록을 추가할 수 있습니다. moveUp(); 블록을 선택한 다음에 moveLeft(); 블록 아래에 강조 빛이 나타날 때까지 드래그 합니다. 그 다음에 놓으면 두 블록들이 서로 달라 붙게 됩니다."
      9:
        text: "다시 실행을 누르면, BB-8은 작업 공간에 붙여져있는 명령들을 위에서 부터 아래로 수행할 것입니다. 만약에 블록을 하나 없애고 싶다면, 붙여져 있는 블록을 드래그 해서 도구상자에 가져다 놓으면 됩니다."
      10:
        text: "실행한 후에 여러분은 언제든지 재실행 버튼을 눌러서 BB-8을 다시 시작하게 할 수 있습니다. 자, 이제 시작해 보세요!"
    starwars_typing:
      1:
        text: "우리가 사용해온 블록들은 내부적으로는 자바스크립트 명령어들이었습니다. 자바스크립트는 전문 개발자들이 사용하고 있는 가장 일반적인 프로그래밍 언어입니다. 블록들을 사용하는 것은 프로그래밍을 처음 시작하기 좋으며, 실제로 하버드대나 버클리대 같은 최고 대학들에서도 블록 기반 프로그래밍으로 시작하기도 합니다. 하지만, 일단 기초적인 것들을 배우고 나면 엔지니어들은 텍스트 기반으로 코딩을 합니다. 왜냐하면 텍스트로 코딩하는 것이 더 빠르기 때문입니다."
      2:
        text: "도구 상자에서 명령들을 찾아서 드래그해서 빼내지 않아도, 수 백 가지 종류의 명령어들을 입력할 수 있습니다. 처음에는 명령어를 입력하는 것이 느릴 수 있지만, 한 번 해보세요."
      3:
        text: "모든 퍼즐들에서, 작업 공간의 오른쪽 위에 있는, 텍스트 보기 버튼을 누르면 블록들이 텍스트 코드로 바뀌어 나타날 것입니다."
      4:
        text: "이번 레슨에서는 텍스트 명령 모드로 시작할 것입니다. 도구상자에서 블록을 드래그 했었는데, 명령어를 입력할 수도 있습니다. 명령어를 입력하기 시작하면 입력하는 도중에 사용가능한 명령어들이 아래쪽으로 나타날 것입니다. 전체 명령이나 이름을 모두 타이핑할 필요 없이, 그 중에 원하는 것을 선택하면 빠릅니다. 제가 일을 하기 위해서 코딩을 할 때에는 항상, 이런 자동 완성 기능을 사용합니다."
      5:
        text: "코드를 타이핑 할 때에는 아주 정확히 입력해야 합니다. 대소문자, 중괄호, 세미콜론까지 정확하게 작성해야 합니다. 조금이라도 틀리게 입력하면, BB-8은 코드를 해석하지 못하고, 움직이지 않을 것입니다."
      6:
        text: "어떤 줄에 오류가 있다면, 편집기 화면에서 밝게 표시되기 때문에, 텍스트를 수정해서 고칠 수 있습니다."
      7:
        text: "시도하는 도중에 막히면, 다시 시작 버튼을 누르면 되고, 오른쪽 위에 있는 블록 모드로 언제든지 바꿀 수 있습니다. 자, 이제 한번 텍스트 명령어로 입력해보세요! 실수하더라도 당황하지 마세요. 몇 번 시도하다보면 다 잘 될 것입니다."
    starwars_events:
      1:
        text: "안녕하세요. 저는 월트디즈니 이미지어링에서, 수석 크리에이티브 프로듀서로 일하고 있는 채리타 카터입니다. 저는 저희 고객들이 경험하게될, 여러 가지 매력적인 것들을 만들어내는 팀들을 이끌고 있습니다. 우리는 고객들의 경험을 개선하고, 좀 더 나아지도록 하기 위한 방법들을 항상 찾아왔는데, 컴퓨터과학기술은 그러한 것의 핵심입니다."
      2:
        text: "축하합니다, 해냈습니다! 여러분이 BB-8 을 프로그래밍 했습니다. 이제 더 어려운 것을 할 준비가 되었다고 생각합니다. 여러분은 이제 프로그래밍의 기초를 배웠기 때문에, R2-D2와 C3PO를 주연으로 하는 여러분 만의 게임을 만들 때가 왔습니다."
      3:
        text: "게임을 만들기 위해서는, 게임 프로그래머들이 매일 사용하는 것들을 배워야 합니다: 이벤트라는 것이죠. 프로그램은 어떤 이벤트가 발생하는지 살펴보거나 기다렸다가, 어떤 이벤트가 발생하면 그때 지정해준 작업을 수행하게 됩니다."
      4:
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      5:
        text: "이번에는 R2-D2를 위로 보내 메시지를 조종사에게 전달한 후, 아래로 움직여 다른 조종사에게 이동할 수 있도록 할 것입니다. R2-D2를 이동시키기 위해서 이벤트들을 사용하면 됩니다. 플레이어는 위/아래 방향키나 버튼들을 사용합니다."
      6:
        text: "WhenUp() 이벤트 블록을 사용하고, goUp() 블록을 거기에 붙여 사용합니다. 플레이어가 위쪽 방향키를 누르면, whenUp() 블록에 붙여져 있는 코드들이 실행됩니다. 같은 방법으로 R2-D2를 아래쪽으로 이동하게 할 것입니다."
      7:
        text: "그렇게 하기 위해, whenUp() 이라는 명령어를 사용할 것입니다. 명령어를 도구상자에서 드래그 해보면, 세미콜론 대신에 중괄호로 시작되고 끝난다는 것을 알 수 있습니다. 그 중괄호 사이의 가운데 공간에는 다른 명령어들을 넣을 수 있는 공간 입니다. 이 중괄호 사이에 넣는 모든 명령들은 위쪽 방향키를 눌렀을 때 모두 실행이 될 것입니다."
      8:
        text: "R2-D2를 위로 보내기 위해서 goUp(); 블록을 넣으세요. 같은 방법으로 아래로 움직이도록 만들 것입니다."
      9:
        text: "이제 드로이드를 제어하는 모든 코드를 미리 작성하는 대신, 버튼들을 눌렀을 때 R2-D2가 화면 이리저리 움직일 수 있도록 할 수 있습니다. 한 단계씩 진행해 나아가면 게임이 인터랙티브하게 변화될 것입니다."
    starwars_congrats:
      1:
        text: "안녕하세요, 저는 앨리스입니다. 저는 Code.org 를 운영하고, 엔지니어링 팀을 맏고 있습니다. 그리고, 여러분들이 지금 하고 있는 튜토리얼을 만들 때에도 참여했습니다."
      2:
        text: "와 마지막 레벨을 끝마쳤습니다. 축하합니다! 이제 여러분은 자신만의 스타워즈 게임을 만들기 위해 필요한 모든 것들을 다 배웠습니다. 이제 설명도 없고, 풀어야 할 퍼즐도 없습니다. 여러분들이 원하는 대로 움직이는 게임을 만들 수 있습니다. 한 가지 더, 새로운 소리들과 새로운 명령어들이 있기 때문에 더 많은 것들도 할 수 있습니다."
      3:
        text: "[학생] 그래서 기본적으로는 퍼퍼 피그를 먹으면 점수가 올라가도록 만들었어요. 하지만, 퍼퍼 피그를 먹을 때마다 스톰트루퍼가 나타나도록 해서 어렵게 만들었습니다. 화면 전체가 퍼퍼 피그로 꽉 차 있고, 퍼퍼 피그를 10,000 마리 먹으면 이기게 됩니다."
      4:
        text: "[학생] 우리는 절대로 지지 않는 게임을 만들었어요. 뭐든지 잡으면 점수가 올라가요. 저는 방향키를 반대로 바꿔서 위를 누르면 아래로 가고, 아래를 누르면 위로, 왼쪽을 누르면 오른쪽으로 그렇게 반대로 이동하게 만들었어요. 진짜 어렵죠! 게임 개발자로서 공정하거나 그렇지 않거나 마음대로 할 수 있어요. 그렇죠? 오~예!"
      5:
        text: "게임을 다 만들고 나면, 친구들에게 전달하거나, 여러분의 스마트폰에서 게임을 할 수 있도록 공유를 해보세요. 즐거운 시간 보내세요!"
    starwars_blocks_intro:
      1:
        text: "안녕하세요. 저는 캐슬린 케네디이고, 스타워즈: 깨어난 포스 영화의 제작자입니다. 오늘 여러분은 스타워즈에 나오는 별들 중 하나에서 작업을 하게 될 것인데, BB-8은 공처럼 생긴 드로이드입니다. BB-8 의 모든 동작과 움직임은 컴퓨터 소프트웨어를 통해 이루어집니다. 컴퓨터과학(정보과학) 은 마켓팅, 헬스케어, 영화까지 모든 산업에 영향을 줍니다. 실제로, 수백명의 컴퓨터 엔지니어들이 함께 작업해서, 스타워즈 같은 영화를 만들어내는 것입니다."
      2:
        text: "안녕하세요, 저는 레이첼 로즈입니다. 저는 ILM의 수석 R&D 엔지니어로서, 애니메이션과 크리쳐 개발 팀을 이끌고 있습니다. 스타워즈: 깨어난 포스에서, 저는 예술가들이, 머나 먼 우주 어딘가에 실제로 있을 것 같은 캐릭터들의 장식을 만드는 것을 돕고 있습니다."
      3:
        text: "다음 시간에 우리는 여러분에게 프로그래밍의 기본 개념을 가르쳐 줄 스타워즈 게임을 할 것입니다. 대부분의 프로그래밍은 모두 텍스트로 되어 있지만, 우리는 블록을 드래그 해서 프로그램을 작성할 수 있습니다. 우선, 우리는 레이와 함께 BB-8이 부품 조각을 모을 수 있도록 할 것입니다."
      4:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽의 공간은 프로그램이 실행되는 스타워즈 게임 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다."
      5:
        text: "가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 명령어입니다."
      6:
        text: "오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다."
      7:
        text: "만약에 제가 moveLeft(); 블록을 작업공간으로 끌어오면 어떤 일이 일어날까요? BB-8이 그리드 위에서 왼쪽으로 한 블록 이동합니다."
      8:
        text: "MoveLeft(); 블록 다음에 다른 작업을 BB-8에게 시키려면? 다른 블록을 추가할 수 있습니다. moveUp(); 블록을 선택한 다음에 moveLeft(); 블록 아래에 강조 빛이 나타날 때까지 드래그 합니다. 그 다음에 놓으면 두 블록들이 서로 달라 붙게 됩니다. 다시 실행시키면, BB-8 은 작업 공간에 쌓여 있는 명령들을 순서대로 실행할 것입니다."
      9:
        text: "어떤 블록을 삭제하고 싶으면, 다른 블록들과 분리한 다음에 툴박스로 다시 가져다 놓으면 됩니다."
      10:
        text: "실행한 후에 여러분은 언제든지 재실행 버튼을 눌러서 BB-8을 다시 시작하게 할 수 있습니다. 자, 이제 시작해 보세요!"
    starwars_blocks_events:
      1:
        text: "안녕하세요. 저는 월트디즈니 이미지어링에서, 수석 크리에이티브 프로듀서로 일하고 있는 채리타 카터입니다. 저는 저희 고객들이 경험하게될, 여러 가지 매력적인 것들을 만들어내는 팀들을 이끌고 있습니다. 우리는 고객들의 경험을 개선하고, 좀 더 나아지도록 하기 위한 방법들을 항상 찾아왔는데, 컴퓨터과학기술은 그러한 것의 핵심입니다."
      2:
        text: "축하합니다, 해냈습니다! 여러분이 BB-8 을 프로그래밍 했습니다. 이제 더 어려운 것을 할 준비가 되었다고 생각합니다. 여러분은 이제 프로그래밍의 기초를 배웠기 때문에, R2-D2와 C3PO를 주연으로 하는 여러분 만의 게임을 만들 때가 왔습니다."
      3:
        text: "게임을 만들기 위해서는, 게임 프로그래머들이 매일 사용하는 것들을 배워야 합니다: 이벤트라는 것이죠. 프로그램은 어떤 이벤트가 발생하는지 살펴보거나 기다렸다가, 어떤 이벤트가 발생하면 그때 지정해준 작업을 수행하게 됩니다."
      4:
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      5:
        text: "이번에는 R2-D2를 위로 보내 메시지를 조종사에게 전달한 후, 아래로 움직여 다른 조종사에게 이동할 수 있도록 할 것입니다. R2-D2를 이동시키기 위해서 이벤트들을 사용하면 됩니다. 플레이어는 위/아래 방향키나 버튼들을 사용합니다."
      6:
        text: "우리는 whenUp() 이벤트 블록을 사용하고 그것에 goUp() 블록을 연결할 것입니다. 위쪽 방향키를 누르면 whenUp() 블록에 연결된 코드가 실행됩니다. 같은 방식으로 R2-D2가 아래로 이동시켜주세요. 드로이드를 제어 하는 모든 코드를 미리 작성하기 전에 먼저, 화면을 돌아다닐 수 있도록 버튼 누름 이벤트에 R2-D2가 움직이도록 해보세요."
      7:
        text: "한 단계씩 지나면서, 게임이 점점 더 인터랙티브하게 됩니다."
    starwars_blocks_congrats:
      1:
        text: "안녕하세요, 저는 앨리스입니다. 저는 Code.org 를 운영하고, 엔지니어링 팀을 맏고 있습니다. 그리고, 여러분들이 지금 하고 있는 튜토리얼을 만들 때에도 참여했습니다."
      2:
        text: "와 마지막 레벨을 끝마쳤습니다. 축하합니다! 이제 여러분은 자신만의 스타워즈 게임을 만들기 위해 필요한 모든 것들을 다 배웠습니다. 이제 설명도 없고, 풀어야 할 퍼즐도 없습니다. 여러분들이 원하는 대로 움직이는 게임을 만들 수 있습니다. 한 가지 더, 새로운 소리들과 새로운 명령어들이 있기 때문에 더 많은 것들도 할 수 있습니다."
      3:
        text: "[학생] 그래서 기본적으로는 퍼퍼 피그를 먹으면 점수가 올라가도록 만들었어요. 하지만, 퍼퍼 피그를 먹을 때마다 스톰트루퍼가 나타나도록 해서 어렵게 만들었습니다. 화면 전체가 퍼퍼 피그로 꽉 차 있고, 퍼퍼 피그를 10,000 마리 먹으면 이기게 됩니다."
      4:
        text: "[학생] 우리는 절대로 지지 않는 게임을 만들었어요. 뭐든지 잡으면 점수가 올라가요. 저는 방향키를 반대로 바꿔서 위를 누르면 아래로 가고, 아래를 누르면 위로, 왼쪽을 누르면 오른쪽으로 그렇게 반대로 이동하게 만들었어요. 진짜 어렵죠! 게임 개발자로서 공정하거나 그렇지 않거나 마음대로 할 수 있어요. 그렇죠? 오~예!"
      5:
        text: "게임을 다 만들고 나면, 친구들에게 전달하거나, 여러분의 스마트폰에서 게임을 할 수 있도록 공유를 해보세요. 즐거운 시간 보내세요!"
    mc_intro:
      1:
        text: "제 이름은 Jens Bergensten이지만 다들 Jeb이라고 부르죠. 제가 여기 스톡홀름 Mojang의 Minecraft 리드 개발자에요. 11살인가 12살 때 프로그래밍을 시작했던 것 같아요. 게임을 만들고 싶었거든요. 아버지 친구 중 한 분이 말해주셨는데 게임을 만들려면 프로그래밍을 배워야 한다고 하셨죠. 그렇게 시작하게 됐죠. 전 사물의 구성을 설계하고 계산하는 걸 좋아해요. 그게 바로 제가 Minecraft에서 좋아하는 점이죠."
      2:
        text: "앞으로 몇 시간에 걸쳐서 여러분은 Minecraft 월드를 재현한 곳에서 알렉스나 스티브를 움직이게 프로그래밍하면서 컴퓨터 공학의 기초를 배우게 될 거에요."
      3:
        text: "전통적인 프로그래밍은 보통 텍스트로 해요. 하지만 오늘 우리는 블록을 드래그 드롭하며 프로그램을 만드는 Blockly라는 시스템을 사용할 거에요. 모르는 사이에 여러분은 자바 스크립트 코드를 만들게 될 거에요."
      4:
        text: "여러분이 배울 개념은 컴퓨터 프로그래머들이 매일 사용하고 컴퓨터 공학에 기초가 되는 것이죠. Mojang에서 Minecraft를 만드는데 이것과 동일한 개념을 사용해요."
      5:
        text: "시작하기 전에 캐릭터를 고르세요. 전 알렉스를 고를 거에요. 알렉스가 화면에서 돌아다닐 수 있게 프로그램 코드를 만들어 볼까요."
      6:
        text: "화면은 세 개의 주요 부분들로 나뉘어 있어요. 왼쪽은 Minecraft 플레이 공간으로, 여러분의 프로그램이 실행되죠. 각 레벨에 대한 설명은 아래에 적혀있어요."
      7:
        text: "중간은 툴 박스인데, 이 블록들 각각은 알렉스의 행동을 지시하는 명령어에요."
      8:
        text: "오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다."
      9:
        text: "앞으로 이동 블록을 드래그해서 작업 공간에 놓고 실행하기를 클릭하면, 어떻게 되죠? 알렉스가 한 칸 앞으로 이동해요."
      10:
        text: "알렉스가 한 칸 앞으로 이동한 다음에 무언가를 하게 하려면 어떻게 할까요? 프로그램에 다른 블록을 추가하면 돼요. 전 오른쪽으로 돌기 블록을 선택할 거에요. 그걸 앞으로 이동 아래에 놓고, 주황색 선이 나타나면 내려놓으세요. 그러면 두 블록이 결합되죠. 실행하기를 다시 누르면, 알렉스가 작업 공간에 위에서부터 쌓여있는 명령어들을 수행할 거에요."
      11:
        text: "만약에 블록을 삭제하고 싶으면 그 블록을 끌어서 다시 툴 박스에 가져다 놓으면 돼요."
      12:
        text: "실행 취소를 하고 싶거나 레벨 시작 단계로 돌아가고 싶으면, 작업 공간 오른쪽 위에 있는 다시 시작 버튼을 사용하세요. 그리고 돌기 블록들에 있는 이 작은 삼각형 보이죠? 이런 삼각형이 보이면 다른 옵션을 고를 수 있다는 뜻이에요. 그럼, 코딩을 시작해 볼까요!"
    mc_repeat:
      1:
        text: "전 Mojang의 브랜드 디렉터 Lydia Winters에요. 우리가 Minecraft라는 작은 게임을 만들었죠."
      2:
        text: "Minecraft에서 제가 가장 좋아하는 건 탐험하는 거에요. 동굴 속에서 모험을 하고 제가 찾은걸 보는 걸 좋아하죠. 프로그래머가 아닌 입장에서 전 Minecraft 강의를 듣는 게 너무 신나요. 그리고 코딩을 직접 배운다는 것도 신나고요."
      3:
        text: "지난 레벨에서는 앞으로 이동 블록들이 많이 필요했어요. 컴퓨터에게 여러 번 반복해서 앞으로 이동하라고 말할 수 있으면 더 쉬울 거에요. 다행히도 컴퓨터는 반복문으로 명령을 반복하는 걸 아주 잘하죠."
      4:
        text: "Minecraft를 건설할 때 새로운 세계를 만들기 위해서 모든 기초 재료를 놓을 때 반복문을 사용해요. 엄청나게 많은 블록들이 되죠. 알렉스가 걸을 때 발이 앞뒤로 왔다 갔다 하게 만드는 것 같은 작은 활동에도 반복문을 써요. 반복문은 프로그래밍에서 굉장한 부분이에요."
      5:
        text: "밤이 됐으니 다음 레벨들에서는 안전하게 머물 집을 지어볼 거에요. 블록 반복하기를 사용해서 아주 쉽게 할거에요."
      6:
        text: "집에 벽을 쌓으려면 알렉스에게 앞으로 가서 목재를 4번 놓으라고 하거나 앞으로 가서 목재 한 개를 놓은 다음에 블록 반복하기를 써서 여러 번 행동을 수행하게 할 수 있어요. 이제 블록 반복하기를 클릭해서 몇 번을 반복하게 하고 싶은지 선택해봐요. 자, 이제 밤이 되기 전에 집을 만들어 볼까요! 재미있는 시간 되세요."
    mc_if_statements:
      1:
        text: "이번에는 if문(만약 블록)에 대해서 배워볼 거에요. if문은 프로그래밍의 기초가 되는 부분이에요. 컴퓨터가 결정을 하는 걸 도와주죠."
      2:
        text: "모든 컴퓨터는 if문을 사용해요. 제 스마트폰도 그렇죠. 예를 들어 제가 폰을 잠금 해제할 때, 폰은 어떤 코드를 실행시켜요. 정확한 비밀번호를 입력하면 폰을 잠금 해제하고, 그렇지 않으면 오류 메시지를 띄우죠."
      3:
        text: "코드에서 if문을 이용해서 스티브와 알렉스가 월드에서 본 것에 반응하게 만들 수 있어요. 예를 들어, 앞에 돌이 있을 때 왼쪽으로 돌 수 있죠. 아니면 나무를 만났을 때 오른쪽으로 돌거나요."
      4:
        text: "이때 용암에 빠지면 안되겠죠. 용암을 피하는 건 어렵지 않아요. 화면에서 볼 수 있죠. 그런데 돌 밑에 있어서 볼 수 없는 용암은 어떻게 할까요?"
      5:
        text: "돌을 채굴한 다음 확인해야 해요. 앞으로 이동하기 전에 그곳에 용암이 있는지를 말이죠. 용암이 있으면 앞으로 이동하기 전에 캐릭터 앞에 돌을 놓으세요. 그렇게 하면 안전하게 이동할 수 있어요. 채굴을 더 할 시간이에요! 발밑을 조심하려면 if문(만약 블록)을 사용하는 걸 잊지 마세요."
    mc_congrats_share:
      1:
        text: "축하해요! 지금까지 여러분은 컴퓨터 공학의 기본적인 것들 몇 개를 배웠어요."
      2:
        text: "이제 이 블록들을 이용해서 원하는 걸 만들 수 있어요. 더 이상 지시 사항이나 풀어야 할 퍼즐도 없어요. 여러분이 원하는 어떤 것이든 만들 수 있어요. 선택은 여러분에게 달렸어요."
      3:
        text: "[학생들] 거의 다 돼가요. 털 깎기. 전 횃불로 L자를 만들었어요. 전 자작나무 판자로 A자를 만들었어요. 돼요, 진짜 돼요. 우리는 양털로 집을 만들었어요!"
      4:
        text: "만들기가 끝나면 공유하기를 선택해서 친구들과 공유할 링크를 만드세요. 재미있는 시간 되세요!"
    mc_congrats_no_share:
      1:
        text: "축하해요! 지금까지 여러분은 컴퓨터 공학의 기본적인 것들 몇 개를 배웠어요."
      2:
        text: "이제 이 블록들을 이용해서 원하는 걸 만들 수 있어요. 더 이상 지시 사항이나 풀어야 할 퍼즐도 없어요. 여러분이 원하는 어떤 것이든 만들 수 있어요. 선택은 여러분에게 달렸어요."
      3:
        text: "[학생들] 거의 다 돼가요. 털 깎기. 전 횃불로 L자를 만들었어요. 전 자작나무 판자로 A자를 만들었어요. 돼요, 진짜 돼요. 우리는 양털로 집을 만들었어요!"
      4:
        text: "이제 여러분은 원하는 건 뭐든 만들 수 있어요. 마음껏 즐겨보세요!"
    gumball_intro:
      1:
        text: "만약 자신만의 게임을 만들고 싶다면 그것은 정말 쉽습니다. 기초적인 프로그래밍만으로 자신이 원하는 모든 것을 만들 수 있고, 자신이 만든 게임을 시작할 수 있습니다."
      2:
        text: "좋아하는 비디오 게임이 있나요? 우리는 Play Lab 에서 그런 게임을 만들기 위해서 한 단계씩 배워 나갈 것입니다. 좋은 게임들은 스토리가 있고, 모든 스토리에는 주인공 캐릭터들이 있습니다. 캐릭터들은 말하고, 이동하고, 다른 캐릭터들과 인터랙티브하게 상호작용합니다. 그리고 게임 스코어 포인트는 게임의 규칙에 따라 달라집니다. 오늘 우리는 스마트폰에서 실행되고 공유될 수 있는 게임을 한 단계씩 만들어 나가 볼 것입니다. 게임 속 재미있는 캐릭터들을 이용해 게임을 만들어보세요."
      3:
        text: "오늘 우리는 어떻게 이런 모든 일들을 할 수 있는지를, 재미있는 캐릭터들과 함께 하나 씩 하나 씩 배워나가게 될 것입니다. 그러고 난 후 스마트폰에서 재생되고 공유될 수 있는 게임을 제작해 보세요."
      4:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽은 프로그램이 실행되는 게임 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다."
      5:
        text: "가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 코드입니다."
      6:
        text: "오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다."
      7:
        text: "처음 시작하기 위해서, 사용할 블럭들을 실행하면 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다."
      8:
        text: "첫 번째 퍼즐에서 우리는 \"말하기\" 블록을 \"~할 때 실행\" 블록에 붙이고 메세지를 입력해서, 캐릭터가 무언가를 말하도록 만들 것입니다. 블록이 제 자리에 놓여지고 난 후, 프로그래밍 한 것을 보려면 실행 버튼을 누르세요."
      9:
        text: "시작하고나서 마지막 쯤에는, 가능한 캐릭터들을 이용해 게임을 만들고, 인터랙티브하게 움직이고, 점수를 올리거나, 발사체들을 던지고.. 서로 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요."
    gumball_events:
      1:
        text: "이제 우리는 모든 게임프로그래머들이 매일 사용하는 것에 대해서 배울 것입니다. 이벤트라고 하는 것들입니다. 하나의 이벤트는 프로그램이 어떤 사건이 일어났을 때, 어떻게 해야하는지 프로그램에게 알려줄 때 사용하는 것이라고 볼 수 있는데, 게임의 경우에는 어떤 동작을 하게 되는 것이라고 볼 수 있습니다."
      2:
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      3:
        text: "이제, 캐릭터를 클릭하면 뭔가 말하도록 해보세요. \"클릭하면\" 블록에 \"말하기\" 블록을 붙여 사용하면 됩니다. 플레이어가 클릭하면 이 블록에 붙여져 있는 모든 블록들이 실행될 것입니다."
      4:
        text: "화살표 블록들이 있습니다. 이 블록들에 이동하기 블록을 붙이면 방향키를 눌렀을 때, 위로, 아래로, 왼쪽으로, 오른쪽으로 이동시킬 수 있습니다. 한 단계씩 여러분이 만든 게임이 더 인터랙티브하게 변화해 갈 것입니다."
    gumball_repeat:
      1:
        text: "여러분들은 어떤 작업을 무한히 반복한다는 것을 상상해 본 적이 있나요? 다행히도 여러분은 전혀 그럴 필요가 없습니다. 컴퓨터들이 그렇게 반복하는 것을 아주 잘하기 때문입니다."
      2:
        text: "이것은 무한반복 블록입니다. 이 블록 안에 있는 어떤 것이든 이 게임 안에서 끝없이 실행됩니다. 만약에 게임을 하는 사람이 아무 것도 하지 않아도 주인공이 무언가를 반복적으로 하길 원한다면 우리는 그 블록들을 무한반복 블록 안에 넣으면 됩니다."
      3:
        text: "이 다음 퍼즐에서 우리의 목표는 주인공이 일을 계속하도록 돕는 것 입니다. 반복문이 어떻게 동작하는지에 대해 이해하게 되면, 게임을 만들 때 아주 많은 시간을 절약해 줄 것입니다."
    iceage_intro:
      1:
        text: "만약 자신만의 게임을 만들고 싶다면 그것은 정말 쉽습니다. 기초적인 프로그래밍만으로 자신이 원하는 모든 것을 만들 수 있고, 자신이 만든 게임을 시작할 수 있습니다."
      2:
        text: "좋아하는 비디오 게임이 있나요? 우리는 Play Lab 에서 그런 게임을 만들기 위해서 한 단계씩 배워 나갈 것입니다. 좋은 게임들은 스토리가 있고, 모든 스토리에는 주인공 캐릭터들이 있습니다. 캐릭터들은 말하고, 이동하고, 다른 캐릭터들과 인터랙티브하게 상호작용합니다. 그리고 게임 스코어 포인트는 게임의 규칙에 따라 달라집니다. 오늘 우리는 스마트폰에서 실행되고 공유될 수 있는 게임을 한 단계씩 만들어 나가 볼 것입니다. 게임 속 재미있는 캐릭터들을 이용해 게임을 만들어보세요."
      3:
        text: "오늘 우리는 어떻게 이런 모든 일들을 할 수 있는지를, 재미있는 캐릭터들과 함께 하나 씩 하나 씩 배워나가게 될 것입니다. 그러고 난 후 스마트폰에서 재생되고 공유될 수 있는 게임을 제작해 보세요."
      4:
        text: "화면은 3개의 부분으로 구분해 볼 수 있습니다. 왼쪽은 프로그램이 실행되는 게임 공간입니다. 각 단계에서 해결해야할 목표들은 그 아래에 작성되어있습니다."
      5:
        text: "가운데 영역은 도구 상자이고, 이 블록들 각각은 한 개의 코드입니다."
      6:
        text: "오른쪽의 흰색 공간은 작업 공간이라고 하며, 프로그램을 만드는 곳입니다."
      7:
        text: "처음 시작하기 위해서, 사용할 블럭들을 실행하면 이라는 주황색 블럭에 붙이면 됩니다. 필요한 여러개의 블럭들을 함께 사용하려면 드래그해서 노란색 줄이 보일 때까지 끌여당긴 후 붙이면 됩니다."
      8:
        text: "첫 번째 퍼즐에서 우리는 \"말하기\" 블록을 \"~할 때 실행\" 블록에 붙이고 메세지를 입력해서, 캐릭터가 무언가를 말하도록 만들 것입니다. 블록이 제 자리에 놓여지고 난 후, 프로그래밍 한 것을 보려면 실행 버튼을 누르세요."
      9:
        text: "시작하고나서 마지막 쯤에는, 가능한 캐릭터들을 이용해 게임을 만들고, 인터랙티브하게 움직이고, 점수를 올리거나, 발사체들을 던지고.. 서로 사라지게 할 수 있습니다. 게임을 어떻게 만들지는 여러분의 생각에 달려있습니다. 자유롭게 만들어보세요."
    iceage_events:
      1:
        text: "이제 우리는 모든 게임프로그래머들이 매일 사용하는 것에 대해서 배울 것입니다. 이벤트라고 하는 것들입니다. 하나의 이벤트는 프로그램이 어떤 사건이 일어났을 때, 어떻게 해야하는지 프로그램에게 알려줄 때 사용하는 것이라고 볼 수 있는데, 게임의 경우에는 어떤 동작을 하게 되는 것이라고 볼 수 있습니다."
      2:
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      3:
        text: "이제, 캐릭터를 클릭하면 뭔가 말하도록 해보세요. \"클릭하면\" 블록에 \"말하기\" 블록을 붙여 사용하면 됩니다. 플레이어가 클릭하면 이 블록에 붙여져 있는 모든 블록들이 실행될 것입니다."
      4:
        text: "화살표 블록들이 있습니다. 이 블록들에 이동하기 블록을 붙이면 방향키를 눌렀을 때, 위로, 아래로, 왼쪽으로, 오른쪽으로 이동시킬 수 있습니다. 한 단계씩 여러분이 만든 게임이 더 인터랙티브하게 변화해 갈 것입니다."
    iceage_repeat:
      1:
        text: "여러분들은 어떤 작업을 무한히 반복한다는 것을 상상해 본 적이 있나요? 다행히도 여러분은 전혀 그럴 필요가 없습니다. 컴퓨터들이 그렇게 반복하는 것을 아주 잘하기 때문입니다."
      2:
        text: "이것은 무한반복 블록입니다. 이 블록 안에 있는 어떤 것이든 이 게임 안에서 끝없이 실행됩니다. 만약에 게임을 하는 사람이 아무 것도 하지 않아도 주인공이 무언가를 반복적으로 하길 원한다면 우리는 그 블록들을 무한반복 블록 안에 넣으면 됩니다."
      3:
        text: "이 다음 퍼즐에서 우리의 목표는 주인공이 일을 계속하도록 돕는 것 입니다. 반복문이 어떻게 동작하는지에 대해 이해하게 되면, 게임을 만들 때 아주 많은 시간을 절약해 줄 것입니다."
    mc_2016_intro:
      1:
        text: "안녕하세요, 저는 Minecraft의 리드 크리에이티브 디자이너 젠스라고 합니다. 다음 시간에는 여러분이 직접 Minecraft 게임을 만들어 볼 텐데요. 이 화면은 Minecraft 같지만 게임 속 세상이 멈춰 있습니다. 양이 움직이지도, 닭이 알을 낳지도 않고 좀비들은 그냥 가만히 서 있기만 하죠. 여기에 코드를 추가해 움직이게 만드는 건 여러분께 달렸습니다."
      2:
        text: "My name is Melissa and I am a user researcher at Minecraft. What I'm really interested in is how people think and interact with technology and so this job is the perfect job for me to put together the computer engineering with the psychology: 사람들이 생각하고 행동하는 방식을 관찰할 수 있어요."
      3:
        text: "화면이 크게 세 부분으로 나눠진 게 보이시나요? 1) 왼쪽 부분은 Minecraft 게임입니다. 지금은 게임이 멈춰 있지만 코드를 추가해서 움직이게 할 거예요."
      4:
        text: "2) 여기 중간 부분은 도구 메뉴인데요. 이 블록들은 닭이나 양, 또는 크리처들이 이해할 수 있는 명령을 내려주죠."
      5:
        text: "3) 오른쪽 공간은 일명 '작업 공간'이고, 여기에서 프로그램을 짜게 될 거예요."
      6:
        text: "할 일을 잊어버리셨다면 화면 위쪽에서 각 레벨의 안내를 보실 수 있어요."
      7:
        text: "우선 닭을 프로그래밍하면서 시작해 보죠. \"앞으로 이동하기\" 명령을 작업 공간으로 드래그하세요. 여기서 \"실행\"을 누르면 닭이 한 걸음 앞으로 갑니다. 더 움직이게 하려면 첫 번째 \"앞으로 이동하기\" 블록 밑에 밝은 표시가 보일 때까지 \"앞으로 이동\" 블록을 하나 더 드래그하세요. 여기에 블록을 놓으면 블록 두 개가 달라붙죠. 이제 \"실행\"을 한 번 더 누르면 닭이 두 걸음을 움직입니다."
      8:
        text: "블록을 삭제하고 싶다면 그냥 드래그해서 도구 메뉴로 옮기면 됩니다."
      9:
        text: "\"실행\"을 누른 뒤에는 언제든지 \"초기화\" 버튼을 눌러서 게임을 처음 상태로 돌려놓을 수 있습니다. 이제는 여러분이 직접 Minecraft를 만들어 볼 차례군요. 재미있는 시간 되세요!"
    mc_2016_loops:
      1:
        text: "안녕하세요, 리사라고 합니다. 저는 Minecraft 소프트웨어 개발자고 게임에 나오는 동물이나 적 캐릭터들 몇 가지를 만들었어요. 제가 참여한 동물 중 하나는 오셀롯인데요. 오셀롯에게 물고기를 줘서 애완동물로 만들 수 있는 부분을 작업했죠."
      2:
        text: "사람은 같은 일을 계속해서 여러 번 반복하다 보면 누구나 지루함을 느끼게 되는데요. 컴퓨터의 장점은 그런 지루함 없이 똑같은 일을 수백만 번, 수십억 번도 계속 반복할 수 있다는 거죠. 이렇게 반복하는 것을 '루프'라고 하는데, Minecraft의 모든 크리처는 루프를 사용해요."
      3:
        text: "저번에는 닭이 화면에서 움직이게 했지만 금방 멈춰 섰었죠. 실제 Minecraft에서는 닭이 계속해서 화면 속을 돌아다닙니다. 도구 메뉴에서 \"영원히 수행\" 루프 명령을 사용해 닭이 계속해서 화면 속을 돌아다니도록 해보죠. 루프는 시간을 엄청나게 절약하도록 해 주고 직접 Minecraft를 만들면서 다양한 옵션을 사용하도록 도와준답니다."
    mc_2016_events:
      1:
        text: "이번 레벨에서는 스티브나 알렉스 중에 고를 수 있어요. 키보드 화살표를 눌러 위, 아래, 좌우로 움직여 보세요. 이제 레벨에서 마음대로 돌아다닐 수 있겠네요. 크리처를 이용하려면 크리처에게 걸어가서 스페이스바를 누르세요."
      2:
        text: "터치 스크린을 사용한다면 화면을 위, 아래, 좌우로 밀어서 움직일 수도 있어요. 그런 다음 화면을 터치하면 앞에 있는 아이템이나 크리처를 조작할 수 있죠."
      3:
        text: "그런데 이렇게 하면 어떤 일이 생길까요? 양을 건드리면 양털을 깎을 수 있고 소를 건드리면 때려서 도망가게 한답니다. 그리고 크리퍼는 가까이 다가가면 폭발하죠. 이런 반응은 '이벤트' 덕분에 생기는 것인데, 이벤트는 어떤 일이 일어났을 때 명령을 따르거나 기다리라고 프로그램에 알려줍니다. 이럴 때 정해져 있는 행동을 하게 되는 것이죠."
      4:
        text: "지금까지 이벤트 한 가지를 사용해 보았는데요. 크리처가 생기거나 게임이 시작될 때 작동되는 \"생성 시\" 슬롯이었죠. 다음 레벨들에서는 크리처를 건드렸을 때 작동하는 \"접촉 시\" 슬롯이나 크리처를 사용했을 때 작동하는 \"사용 시\" 슬롯을 알아볼게요. 만약 해가 떴을 때 좀비가 사라지게 하고 싶다면 \"낮일 때\" 슬롯에 넣으면 된답니다."
    mc_2016_spawn:
      1:
        text: "게임에서 '생성'이란' 만든다'는 의미입니다. 이번 레벨에선 해가 졌을 때 좀비가 생성되도록 해볼게요. \"밤일 때\" 블록을 사용할 겁니다."
      2:
        text: "좀비가 밤에 생성되도록 할 것이기 때문에, \"밤일 때\" 블록 아래에 \"좀비 생성\" 블록을 넣도록 하죠. 좀비들은 생성되자마자 \"생성 시\" 슬롯에 삽입한 코드를 사용해 움직입니다. 재미있게 만들어 보세요!"
    mc_2016_congrats:
      1:
        text: "축하합니다! Minecraft 월드에 생명을 불어넣는 컴퓨터 코드 사용법을 배우셨군요. 이제 여러분도 어엿한 개발자입니다. 이제 모든 명령과 크리처가 전부 개방되었으니 선택은 여러분께 달렸습니다."
      2:
        text: "게임을 완성하면 공유를 선택해 링크 주소를 만들고, 친구에게 보여주거나 만든 게임을 휴대폰에서 즐길 수 있습니다. 재미있는 시간 되세요! 여러분이 직접 만든 Minecraft를 기대해 보겠습니다."
    applab_intro_welcome:
      1:
        text: "제 이름은 메이라니입니다. 저는 code.org에서 인턴으로 근무하며 또한 컴퓨터 과학과 학생이기도 합니다. 저는 컴퓨터 과학이 정말로 창의적이기 때문에 좋아합니다. 저는 문제 해결사이자 제가 원하는 모든 기능을 만듭니다. 또한 디자이너이기도 합니다. 아티스트이면서 창의적인 측면의 모든 것을 선택합니다."
      2:
        text: "앱 랩을 사용하면 나만의 앱을 만드는 것이 쉬워집니다! 코딩 초보자이든 경험이 있든 상관 없습니다. 앱 랩은 새로운 앱을 구축하고 이를 친구들과 공유할 수 있는 훌륭한 도구입니다. "
      3:
        text: "이것은 앱 랩입니다. 왼쪽이 여러분의 앱입니다. 오른쪽은 그 앱을 실행하는 코드입니다. 툴박스에서 블록을 드래그하여 프로그램을 만듭니다. 처음에는 'setProperty'라고 불리는 블록 한 개가 있습니다. "
      4:
        text: "set property 블록은 화면의 요소 모양을 변경합니다. 버튼, 라벨 또는 심지어 화면 그자체를 변경합니다. 먼저 어느 요소를 변경하고 싶은지 결정해야 합니다. 앱에서 요소에 마우스를 갖다 대면 이름이나 ID를 여기에서 볼 수 있습니다. 그 다음 첫 번째 드롭 다운에서 해당 ID를 선택합니다."
      5:
        text: "요소에는 텍스트 색상, 배경색 또는 폰트 크기와 같이 변경할 수 있는 속성이 많습니다. 전체 목록을 보고 두 번째 드롭 다운에서 변경하고 싶은 속성을 선택합니다."
      6:
        text: "마지막 드롭 다운은 사용하고 싶은 값을 쓰는 곳입니다. 이 블록은 제안을 해줍니다. 하지만 언제든지 다른 색상이나 숫자를 직접 입력할 수 있습니다."
      7:
        text: "다 마치면, 블록은 문장 '버튼 1의 배경색을 녹색으로 설정하시오'와 같은 문장을 읽습니다. 실행을 눌러 코드 빌딩의 변경 사항을 보십시오. 재설정하면 더 많은 블록을 드래그하여 앱에 관한 다른 것들을 변경할 수 있습니다. 텍스트처럼요!"
      8:
        text: "이 튜토리얼에 대해 블록 모드로 작업하지만 앱 랩은 또한 텍스트 작업도 지원합니다."
      9:
        text: "어느 방법이든 웹의 언어인 자바스크립트로 프로그래밍하게 됩니다. 각 레벨에는 목표, 설명과 만들고자 하는 이미지가 있습니다. "
      10:
        text: "잘 안되면, 이 그림을 클릭하면 해당 레벨을 정확하게 완료하는 방법을 보여줍니다. 하지만 먼저 스스로 할 수 있는지 시도해 보십시오."
      11:
        text: "이 레벨의 목표를 완료하면 완료를 클릭하여 계속 진행합니다. 그러면 다 된 것입니다! 오렌지 색의 \"계속\" 버튼을 클릭하여 다른 레벨로 이동한 다음 앱 랩으로 어드벤처를 시작하십시오!"
    applab_intro_events:
      1:
        text: "일종의 자기 사업을 새로 시작하는 것 처럼 앱은 정말 신나죠, 일테면 여러분은 기초부터 모든 걸 직접 설계하고  모든 걸 관리해야 하며 코드로 이제 막 만든 이 작품의 소유자가 바로 당신입니다."
      2:
        text: "이제 앱의 모습을 변경할 수 있어요. 이벤트에 반응하게 인터랙티브하게 만들어 보세요! 이벤트는 버튼 클릭 또는 메뉴 스크롤링, 그림 위 호보링 등과 같은 사용자의 동작입니다. 인터랙티브 앱은 이 버튼을 눌렀을 때 소리를 내는 등 이벤트에 반응하는 방식이 있어야 합니다. 앱 랩에서 이를 위해, 'onEvent'라 부르는 새 블록을 사용해야 합니다."
      3:
        text: "이 프로그램은 화면을 파란색으로 설정합니다. 저는 이 버튼을 클릭했을 때 화면이 녹색으로 바뀌길 원해요. 먼저, onEvent 블록을 드래그해서 가져옵니다. 호버링하고, 버튼의 ID가 \"bigButton\"이란 걸 알기 때문에 첫 번째 드롭 다운에서 이걸 선택할 거예요."
      4:
        text: "다음 이벤트의 유형을 선택할거예요. 선택할 수 있는 옵션은 많이 있지만 지금 당장은 이걸 보통의 옛날 클릭으로 남겨 둘 거예요."
      5:
        text: "드디어, 코드를  onEvent 안에 넣어 화면의 배경색상을 변경할 거예요. 이 블록을 \"버튼이 클릭되는 이벤트 시 이 코드 모두를 실행\"이라는 문장으로 읽을 수 있습니다."
      6:
        text: "테스트해봐요.  onEvent 밖의 블록은 여전히 즉시 실행되어 화면은 파란색으로 시작합니다."
      7:
        text: "이 큰 버튼을 눌렀을 때,  onEvent 안에 있는 코드는 실행되고 화면은 녹색으로 변합니다. "
      8:
        text: "화면 위 텍스트 등 이벤트 후 더 많은 걸 바꾸고 싶으면,  onEvent에 더 많은 코드를 추가하세요. "
      9:
        text: "프로그램이 더 많은 이벤트에 반응하게 만들려면,  onEvent 블록을 더 추가하세요. 단, 서로의 안에는 넣지 마세요. 이제 여러분이 직접 해 볼 시간입니다. 재미있게 하세요!"
    applab_intro_sounds:
      1:
        text: "다음으로, 앱에 이미지와 사운드를 추가하는 방법에 대해 배울 것예요. 사운드 옵션을 확인해 보며 시작해 봐요. "
      2:
        text: "툴박스 안에서 \"playSound\"라 부르는 새 블록을 찾을 수 있을 거예요. 그것을 드래그해서 작업공간으로 가져오세요. 드롭 다운을 클릭하여 사운드를 선택하고 그 다음 \"선택\"을 클릭하세요."
      3:
        text: "여기서, 컴퓨터에 있는 사운드 파일을 업로드하거나 또는 사운드 라이브러리에서 사운드를 검색할 수 있습니다. 사운드 라이브러리에는 악기와 배경음악, 동물 등과 같은 많은 카테고리가 있습니다."
      4:
        text: "일단 원하는 사운드를 있으면, \"선택\"을 클릭하세요. 이 블럭이 실행되면, 선택한 사운드가 울릴 거예요."
      5:
        text: "이미지를 추가하고 싶으면, setProperty 블록을 사용할 수 있습니다. 두 번째 드롭 다운에서 이미지 속성을 선택하세요."
      6:
        text: "그 다음, 세 번째 드롭 다운에서 \"선택\"을 선택하세요."
      7:
        text: "여기서, 컴퓨터에 있는 이미지를 업로드하거나 또는 아이콘 라이브러리에서 엄청나게 많은 아이콘을 살펴 볼 수 있습니다."
      8:
        text: "코드 모드에서, \"setProperty\" 블록을 사용해 아이콘의 아이콘 색상을 변경할 수 있습니다. 일단 아이콘이 사용할 이미지를 선택하면, \"실행\"을 클릭하여 어떤 모습이 되는지 보세요."
      9:
        text: "자 이렇습니다! 이제 이미지와 사운드를 추가하기 시작하여 앱을 더 재미있고 역동적으로 만들 수 있습니다."
    applab_intro_designmode:
      1:
        text: "앱을 만들려면, 화면과 요소를 스케치하며 설계를 시작해야 합니다. 앱 랩은  설계 모드로 하는 이 작업을 쉽게 만듭니다. "
      2:
        text: "앱의 상단 스위치를 사용하여 설계 모드로 가세요."
      3:
        text: "새 요소를 드래그하여 화면으로 옮겨 추가할 수 있습니다. 그것들을 사방으로 움직여 여러 위치로 옮기고 우측하단 버튼을 드래그하여 크기를 변경할 수 있습니다."
      4:
        text: "요소의 속성을 변경하려면, 우측 컨트롤을 사용하세요. 예를 들어, 이 버튼의 텍스트, 색상, 폰트 크기를 변경하는 것은 정말 쉽습니다."
      5:
        text: "새 요소를 화면에 추가하면, 버튼 1과 같은 평범한 ID를 갖게 됩니다. 이 버튼의 ID를 뭔가 의미 있게 \"우측 버튼\" 등과 같이 변경하는 것도 좋은 생각입니다. 그래서 그 프로그램으로 갈 때, 어느 것이 무엇인지 알게 될 것입니다. "
      6:
        text: "실수로 어떤 요소를 앱에 추가할 경우, 그냥 그 요소를 드래그하여 밖으로 빼내거나 또는 삭제를 누르세요."
      7:
        text: "화면 요소를 드래그하여 안으로 넣어 완전히 새 화면을 앱에 추가할 수 있습니다."
      8:
        text: "상단의 드롭 다운에서 여러분이 만든 화면과 화면 사이를 빠르게 왔다갔다 할 수 있습니다."
      9:
        text: "앱 안에서, 화면을 전환시키는 방법이 필요할 것이며, 그래서 setScreen 블록이 툴박스에 추가되어 있습니다. \"onEvent\" 블록 안에 있는 \"setScreen\"을 사용하여 버튼 클릭으로 화면이 변경되게 하세요."
      10:
        text: "다음 몇 개의 레벨 동안, 한 가지 단일 프로젝트 작업을 할 것입니다. 먼저 버튼을 추가하고, 그 다음 새 화면을 추가하며 마지막으로 코드를 작성하여 버튼을 새 화면으로 바꿀 것입니다."
    applab_intro_share:
      1:
        text: "이제 버튼과 사운드, 이미지, 텍스트, 새 화면 추가 등 앱 랩의 기초 몇 가지를 배웠으며 그래서 모든 종류의 앱을 만들 수 있습니다."
      2:
        text: "이제 막 완성한 앱은 다음 레벨에서 찾을 수 있을 거예요. 약간의 창의성을 발휘하여 이것을 친구를 위한 성격 퀴즈, 가족과 공유할 수 있는 인사 카드 또는 '당신만의 모험을 선택하세요' 게임으로 바꿀 수 있습니다. 이러한 앱 모두는 이미 배웠던 스킬의 조합일 뿐이며 여러분은 당연히 이 보다 더 많이 생각해 낼 수 있습니다."
      3:
        text: "일단 앱을 완료했으면, 본인의 전화기로 전송하여 어떤 모습일지 볼 수 있습니다. \"공유\"를 클릭하고 여기에 전화번호를 입력하세요."
      4:
        text: "텍스트 메시지를 받게 되어 즉시 앱을 열어 볼 수 있을 것입니다."
      5:
        text: "또한 자신의 앱으로 가는 링크를  소셜 미디어 상에서 공유하거나 또는 앱을 code.org 공개 갤러리에 게시하여 다른 이들이 플레이하고 공유하게 할 수 있습니다. "
      6:
        text: "지금까지는 앱 랩이 할 수 있는 일의 표면만 건드렸을 뿐입니다. 앱 랩은 보다 앞선 사용자의 인터랙션과 새로운 화면 요소, 심지어 빌트인 데이터베이스로 구성되어 완전한 앱을 빠르게 만들 수 있습니다. 계속하길 원하면 \"code.org/applab\"에서 많은 툴과 아이디어를 찾을 수 있습니다. "
      7:
        text: "함께 해줘서 고마워요, 이제 여러분의 첫 번째 앱을 만들고 공유하고, 앱 랩으로 계속 앱을 만들어 보세요!"
    mc_2017_agent_intro:
      1:
        text: "Stacy: Stampy, Lizzy, Preston - 함께 와줘서 고마워요. 이 메사 고원을 보여주고 싶었어요. 아마 좋아할 거라 생각해요!"
      2:
        text: "잠깐 기다려 - 트랙 위에 구멍이 있어! (고함)"
      3:
        text: "다들 괜찮아? Stampy: 아, 여기 문제가 있어. 봐! 트랙 위에 구멍이 있었어. Stacy: 정말, Stampy? Lizzy: 아마도 우리 모두 블록을 모아 문제를 해결해야 할 것 같은데. Preston: 경기로 만들어 볼까. 제일 먼저 맨 위로 돌아온 사람이 이기는 거야. Stacy: 좋아, 준비, 땅, 시작, 가자! 좋았어, 난 그냥 이 테라코타 좀 모아봐야 겠어. 잠깜 기다려. 애들야, 팔 수가 없어! Preston: 마찬가지야. Lizzy: 나도 파지 못하겠어. Stacy: 그래 정말 이상하네. Stampy, 너는 어때? Stampy: 나도 못파겠어! Stacy: 좋아, 모두 진정해. Stampy: 그럼 게임이 중단된거야? Stacy: 만약 그렇다면, 어떻게 고칠 수 있지? Lizzy: 모르겠어. Stampy: 마인크래프트 코드를 어떻게 작성하는지 아는 사람 있어?"
      4:
        text: "(휙) Preston: 이게 뭐야? Stampy: 그런거 지금까지 한 번도 본 적 없는데. Lizzy: 정말 이쁘다! Stacy: 그거...그거 길들여질까? Preston: 좋아, 무슨 일이야? 누군가 실제 세상에 돌아가 이걸 고쳐야 해.  모두: 싫어! Stacy: 싫- (휴.) 좋아, 내가 갈께."
      5:
        text: "아, 오케이, 안녕, 난 지금 실제 세상에 있어. 마인크래프트 사무실을 찾으러 가려고 해. "
      6:
        text: "하지만, 너희 도움이 필요해. 튜토리얼을 하면서 시작하고, 코딩하는 법을 배우며 시작해, 몇 개 레벨을 통과한 후 너희들을 쫒아갈께. 괜찮지? 행운을 빌어줘! 내 생각에 이 길이 맞는거 같아. 오우! 선인장! 난 괜찮아!"
      7:
        text: "아워오브코드 도전을 완료하려면, 에이전트를 프로그래밍하는 코드를 작성해야 합니다. 앞으로 에이전트와 함께 해야 하며 에이전트가 길 위의 장애물을 제거하고 여러분은 여행에 필요할 아이템을 주을 것입니다. 에이전트만 블록을 놓고 떼어낼 수 있으며, 여러분은 아이템을 모으는 일만 할 수 있습니다. 화면은 세 개의 주요 부분으로 나눠져 있습니다. 좌측은 마인크래프트입니다."
      8:
        text: "가운데 영역은 에이전트가 이해할 수 있는 명령어로 구성된 툴박스입니다."
      9:
        text: "우측은 작업공간입니다. 거기에 명령어를 쌓아 에이전트를 컨트롤할 프로그램을 만듭니다."
      10:
        text: "에이전트는 걷고, 회전하고 압력판을 활성화할 수 있습니다. 또한 블록을 파괴하고 또한 블록을 놓을 수 있습니다. 블록을 이 마인카트 철로처럼 놓을 때, 자기 아래에 놓습니다."
      11:
        text: "할 일을 잊어버리셨다면 화면 위쪽에서 각 레벨의 안내를 보실 수 있어요."
      12:
        text: "다시 해보고 싶으면, 파란색 재설정 버튼을 눌러 모든 걸 처음 시작지점으로 되돌아 가게 하세요. 코드에서 블록을 삭제해야 하면, 코드를 작업공간에서 툴박스로 드래그합니다. 실행을 누르면 에이전트가 움직인다는 걸 기억하세요. 좋아요. 가서 처음 몇 개 레벨을 해 보세요. 행운을 빌어요!"
    mc_2017_repeat:
      1:
        text: "Stampy: Stacy가 뭘하고 있을지 궁금해?"
      2:
        text: "Stacy:와우, 내 생각엔 제대로 찾아 온것 같아. 정말 놀라워!"
      3:
        text: "다시 마인크래프트에 돌아온 것 같아! 저기요. 안녕하세요? 안녕?"
      4:
        text: "오, 저기 크리퍼가 저기 있어요. 아무 일도 안했지요, 그렇죠? Katie: Stacy? Stacy: 안녕하세요, Katie? Katie: 네, 마인크래프트에 온신 걸 환영합니다!"
      5:
        text: "Stacy: 이건 정말 놀라워요. 그래, 여기서 매일 개발자로 일하는 거예요. 맞아요? Katie: 넵, 정말 멋지죠. 저는 마인크래프트 마켓플레이스 팀 개발자예요. Stacy: 코딩 언어를 몇 개나 알고 있어요? Katie: 지금까지 일하며, 아마도 12개 이상 사용했을 거예요. Stacy: 12개요? Katie: 네. Stacy: 아 근데요, 스스로 에이전트라고 부르는 이 작은 괴물에 대해서는 모를 것 같은데요? Katie: 우리는 에이전트를 사용하여 용암을 가로 질러 가는 것과 같은 Steve 또는 Alex가 할 수 없는 일을 하게 합니다.  Stacy: 코딩하는 법을 배우고 싶고 그들도 배우고 싶어하는데 그래서 배울 때 알아야 하는 첫 번째 일 중 하나는 무엇이지요?"
      6:
        text: "Katie: 글쎄요, 루프 사용법을 배워야 해요. 루프는 개발자가 컴퓨터에게 계속해서 다시 실행하게 할 명령어를 주기 위해 작성하는 거예요. Stacy: 알겠어요. 그래서 저는 그것 중 일부가 앞에 있는 레벨에서 실제로 나올 거라고 생각해요. 어서 루프를 사용해 봐요."
      7:
        text: "다음 레벨에서, 루프를 사용하여 에이전트를 길을 따라 이동하게 할 수 있습니다. 반복 루프를 작업공간으로 드래그하여 반복 루프 안에 앞으로 이동 블록을 넣으세요. 이렇게 하면 여러 개의 블록을 작업공간으로 드래그할 필요 없이 컴퓨터가 동일한 일을 연속으로 여러 번 수행합니다. 반복 블록에 숫자를 올려 놓아 몇 번 반복할지 선택할 수 있습니다.  "
      8:
        text: "또한 회전과 복수의 명령어를 반복 블록 안에 넣을 수 있지만 지금은, 반복을 사용하여 에이전트를 앞으로 몇 발자국 이동하게 해보세요. 기억하세요. 만약 퍼즐에서 막히는 부분이 있으면 언제든 파란색 재설정 버튼을 눌러 다시 시도할 수 있습니다."
      9:
        text: "Katie 처럼 멋진 일자리를 갖고 싶다고 생각하면, 어서 가서 각 레벨이 끝날 때 코드 보기 버튼을 클릭하세요. 그러면 Katie와 같은 누군가가 실제로 프로그래밍할 때 사용하는 실제 자바스크립트 코드를 보여줄거예요. Katie: 넵, 모두에게 행운이 있기를!"
    mc_2017_functions:
      1:
        text: "Preston: 자랑하려고 그러는 거는 아닌데, 난 정말 파쿠르를 잘 해. Lizzy: 자자 내일은 Stacy가 돌아오는 날이야."
      2:
        text: "Stacy: 오, 친구들, 마인크래프트 사무실에서 지금 막 돌아 왔어. 내 생각엔 내가 문제를 푸는 방법을 알고 있고 이 게임 안에 들어 있어. 함수를 이용하면 될 거 같아. 내가 이걸 열어 볼께."
      3:
        text: "한 함수에는 어떤 일을 수행하기 위한 특정 지시사항이 들어  것으로 일종의 레시피랑 같아. 다음 몇 개의 레벨에서, 퍼즐을 푸는데 사용할 수 있는 함수에 접근할 수 있을 거야."
      4:
        text: "작업공간에 있는 함수 내 코드를 보고 무엇을 하라고 하는지 봐."
      5:
        text: "그 다음, 툴박스에 그 이름이 있는 블록을 찾아 툴박스에서 블록을 실행하는 곳으로 드래그해."
      6:
        text: "기억해, 다리 건설과 같이 뭔가를 하기위해 동일한 지시사항을 실행할 필요가 있을 때마다 동일한 함수를 사용할 수 있어. "
    mc_2017_congratulations:
      1:
        text: "Preston: 축하해!"
      2:
        text: "Lizzy: 축하해!"
      3:
        text: "Stampy: 축하해, 해냈어!"
      4:
        text: "Stacy:너희 모두 축하해, 너희가 그걸 완전히 흔들어 놨어! 아워오브코드를 완료했으니깐 마인크래프트로 코딩을 시작할 수 있어. 지금까지 루프와 함수, 소프트웨어 에이전트가 하는 일에 대해 배웠어."
      5:
        text: "이제, 플리플레이 레벨을 할 시간이고 거기서 너는 개발자가 역할을 하면 돼. 나머지 시간을 이용하여 탐구하고, 파고, 건설하기 위한 함수를 작성하봐."
      6:
        text: "이 레벨에서 작성한 코드를 마인크래프트: 교육 에디션 상의 마인크래프트 세계로 가져 갈 수 있어. \"마침\"을 클릭하고 지시사항에 따라 링크를 얻어 사용해 에이전트로 계속 코딩해. 재미 있게 하고 잘 해!"
      7:
        text: "Stacy: 나 돌아왔어! 애들아, 이건 에이전트야! 이게 무슨 일을 할 수 있는지 보여줄께. 봐, 이게 이 일을 하고 있어! 에이전트에게 이 테라코타 블록으로 계단을 만들라고 말했었는데 이제 우리는 이걸 사용할 수 있어. 그리고, 이건 단순히 계단이 아니야. 에이전트는 내가 원하는 일은 무엇이든 하고 나를 위해 앞으로 계속 그럴 거야."
      8:
        text: "Stampy: 어떻게 그렇게 해? Stacy: 사실 쉬워. 그냥 코드를 사용했을 뿐이야!"
    csd_concept_how_computers_work:
      1:
        text: "보이는 모든 곳에서 컴퓨터가 세상을 바꾸고 있어요. 데스트톱에 집에 주머니 안에 또는 그냥 어디에든 있습니다. 하지만 우리 대부분이 이 혁명적인 기술을 매일 사용하고 있지만, \"컴퓨터는 어떻게 작동하지?라는 질문은 자주 하지 않습니다. 이 시리즈에서는 컴퓨터가 정말 어떻게 작동하는지에 대해 배울 것이며 먼저 무엇이 컴퓨터를 컴퓨터로 만드는지로 시작합니다. 그 다음, 정보가 컴퓨터 안에서 도저히 상상도 안되는 속도로 계속해서 켜지고 꺼지는 작은 전기 신호를 사용하여 어떻게 표현되는 살펴봅니다."
      2:
        text: "그 다음, 컴퓨터가 간단한 수학부터 전체 가상세계 시뮬레이션까지 모든 것을 하기 위해 회로를 어떻게 사용하는지 배울 것입니다. 그 다음, 실제로 모든 정보를 인풋 및 아웃풋, 저장하는 컴퓨터의 여러 부분을 확대하여 살펴 볼 것입니다. 마지막으로, 코드란 실제 무엇이며 소프트웨어가 하드웨어를 어떻게 컨트롤하는지 살펴 볼 것입니다. 그래서 매일 사용하는 기기에 대한 호기심이 있어서든 아니면 미래의 혁신을 설계하길 원하든, 첫 번째 단계는 컴퓨터의 작동 방식을 배우는 것입니다. "
    csd_concept_computer:
      1:
        text: "제 이름은 May-Li Khoe이며 저는 설계자이자 발명가입니다. 제가 설계한  제품의 일부는 애플에 있으며 지금은 아동이 학교 생활을 더 쉽게 할 수 있도록 그들을 위한 제품을 설계하고 있습니다. 제는 이 밖에 디제잉과 댄스를 합니다."
      2:
        text: "컴퓨터는 어디에나 있습니다. 사람들 주머니 안에 또는 자동차 안에 있으며 손목에 차고 다니기도 합니다. 지금 여러분 베낭 안에도 있을 수 있습니다. 하지만 무엇이 컴퓨터를 컴퓨터로 만들까요? 무엇이 어쨌든 컴퓨터를 컴퓨터로 만들까요? 그리고, 심지어 그것은 어떻게 작동되는 것일까요?"
      3:
        text: "안녕하세요, 저는 Nat예요! 저는 Xbox의 최초 설계자 중 한 명이었습니다. 저는 아마도 7살 때부터 컴퓨터를 사용했으며 지금은 가상현실에 관한 일을 하고 있습니다. 인간으로서 우리는 항상 문제를 해결하는데 도움을 주는 도구를 만들어 왔습니다. 외바퀴 손수레와 망치 또는 인쇄기, 트랙터 트레일러 등과 같은 도구.  "
      4:
        text: "이러한 발명품 모두는 수작업으로 우리에게 도움을 주었습니다. 시간이 지나면서 사람들은 우리가 하는 생각하는 일, 가령 수식을 풀거나 또는 하늘의 별을 추적하는 일을 도와 줄 기계를 설계하고 만들 수 있지 않을까 의구심을 갖기 시작했습니다. 흙과 돌과 같은 물리적인 물체를 이동하거나 또는 조작하기 보다는 이러한 기계는 정보를 조작하도록 설계해야 합니다. 컴퓨터 과학의 선구자들은 생각하는 기계를 설계하는 방법을 탐구하며 그러한 기계는 네 가지 일을 수행할 수 있어야 한다는 점을 깨달았습니다. "
      5:
        text: "컴퓨터는 인풋을 받고 정보를 저장하고 처리하여 결과를 출력해야 합니다. 지금은 간단하게 들리지만 이러한 네 가지 일은 모든 컴퓨터에 공통됩니다. 그것이 컴퓨터를 컴퓨터로 만듭니다."
      6:
        text: "컴퓨터는 기초적인 계산기로서 시작했으며 당시에도 이미 정말로 멋지게 여겨졌으며 당시에는 숫자만을 조작하였습니다. 하지만 지금 우리는 컴퓨터를 사용해 서로 이야기를 할 수 있고 게임을 하고 로봇을 제어하고 상상해 낼 수 어떤 일도 기막히게 할 수 있습니다. 현대식 컴퓨터는 옛날의 투박한 컴퓨터와는 완전히 다르게 보이지만 위의 네 가지 일은 여전히 합니다. "
      7:
        text: "먼저, 인풋에 관해 이야기 할 거예요. 여러분은 키보드로 컴퓨터에게 해야 할 일을 말할 수 있고 또한 마우스로 컴퓨터에게 해야 할 일을 말하고, 마이크와 카메라로도 그렇게 하라고 말할 수 있습니다. 이러한 다양한 인풋 모두는 컴퓨터에게 정보를 주고 그러한 정보는 메모리에 저장됩니다. "
      8:
        text: "컴퓨터의 프로세서는 메모리에서 정보를 가져옵니다. 그리고 일련의 명령어인 알고리즘을 사용하여 정보를 조작하거나 변경합니다. 처리된 정보는 다시 전송되어 메모리에 저장됩니다. 이 과정은 처리된 정보가 출력될 준비가 될 때까지 계속됩니다."
      9:
        text: " 컴퓨터가 정보를 아웃풋하는 방식은 컴퓨터가 무엇을 하도록 설계되었는냐에 따라 결정됩니다. 컴퓨터 디스플레이는 텍스트 또는 사진, 비디오, 인터랙티브 게임, 심지어 가상현실을 보여줄 수 있습니다! 컴퓨터의 아웃풋에는 심지어 로봇을 제어하는 신호도 포함됩니다."
      10:
        text: "내일의 컴퓨터는 어떤 모습일지 누가 알겠습니까? 저는 여러분이 내일의 컴퓨터가 여러분이 원하는 모습으로 결정되는데 도움을 줄 수 있기를 바랍니다. 하지만 컴퓨터가 사용하는 여러 유형의 기술과 상관 없이, 모든 컴퓨터 전체에서 컴퓨터는 네 가지 공통된 일을 합니다. 정보를 받고, 그것을 데이터로서 저장하며 처리하고 결과를 아웃풋 합니다."
    csd_concept_binary_data:
      1:
        text: "안녕하세요! 제 이름은 Limor Fried이고, 여기 Adafruit Industries에서 일하는 엔지니어입니다. 그리고 이곳은 제가 엔지니어링과 설계를 하는 곳이고 저는 패션과 음악, 기술을 위한 회로를 설계합니다."
      2:
        text: "제 이름은 Federico Gomez Suarez이고 Microsoft Hack for Good의 소프트웨어 개발자입니다. 우리 시대의 큰 사회적 문제를 푸는 데 도움이 되는 기술에 대해 주의 깊게 살펴 보고 있습니다."
      3:
        text: "컴퓨터가 1과 0으로 작동된다는 말은 들어본 적이 있을 거예요. 하지만 오늘날 누구도 실제로 이 1과 0을 직접적으로 다뤄 보지는 않았을 거예요. 하지만 1과 0은 컴퓨터가 작동하는 데 그 안에서 큰 역할을 합니다."
      4:
        text: "컴퓨터 안에는 전선과 회로가 있으며 그 안에서 모든 정보가 운반됩니다. 전기를 사용해 정보를 어떻게 저장하거나 또는 나타냅니까?"
      5:
        text: "만약 한 개의 전선이 있고 그 안에 전기가 흐르면, 신호는 on 또는 off 중 하나가 될 수 있습니다. 선택의 여지가 많지 않지만 이것은 정말 중요한 출발점입니다. 한 개의 전선으로 네 또는 아니요 또는 참, 거짓, 1, 0 또는 두 가지 옵션만 있는 그 밖의 것을 나타낼 수 있습니다. 이 단일 전선의 on/off 상태는 비트라 부르고 컴퓨터가 저장할 수 있는 정보의 가장 적은 부분입니다. "
      6:
        text: "더 많은 전선을 사용하면 더 많은 비트: 더 많은 1과 0을 얻을 수 있습니다. 더 많은 비트로 더 복잡한 정보를 나타낼 수 있습니다. 하지만 이를 이해하기 위해, 바이너리 수체계를 배워야 합니다."
      7:
        text: "십진수 체계에서 우리는 0부터 9까지 10개의 수를 갖고 우리 모두는 수를 세는 법을 배웠습니다. 이진수 체계에서는 단지 두 개의 수 0과 1만 있습니다. 이 두 수로 우리는 아무 수나 모두 셀 수 있습니다. "
      8:
        text: "여기 그 작동 방식이 있습니다. 십진수 체계에서는 어느 한 숫자 내 각 자리에 다른 값이 들어 갑니다. 1의 자리가 있으며 10의 자리가 있고, 100의 자리 이런 식으로 계속 이어 집니다. 예를 들어 100의 자리에 9가 있으면 900이 됩니다. 이진수에서도 역시 각 위치에 값이 들어 갑니다. 하지만 매번 10으로 곱하는 대신 2로 곱합니다. 그래서 1의 자리, 2의 자리, 4의 자리, 8의 자리 이런 식으로 이어 집니다. 예를 들어 숫자 9는 이진수로 1001입니다. 값을 계산하기 위해, (1 곱하기 8) 더하기 (0 곱하기 4) 더하기 (0 곱하기 2) 더하기 (1곱하기 1)을 더합니다. 컴퓨터가 우리를 위해 이 계산을 하기 때문에 거의 어느 누구도 이 수학을 하지 않습니다. 중요한 것은 어느 수든 모두 1과 0으로만 또는 on 또는 off인 한 무더기의 전선으로 나타낼 수 있다는 점입니다. 8개의 전선으로 우리는 0부터 255까지의 숫자를 저장할 수 있습니다. 단지 8개 입니다. 32개의 전선으로는 0부터 40억 이상까지 숫자를 저장할 수 있습니다. 이진수 체계를 사용하면 좋아하는 어느 숫자든 나타낼 수 있습니다.  "
      9:
        text: "하지만, 다른 유형의 정보는 어떨까요? 텍스트 또는 이미지, 사운드 등? 이런 것 모두 마찬가지로 숫자로 나타낼 수 있습니다. 알파벳 문자를 생각해 볼까요. 숫자에 각 글자를 배정할 수 있습니다. A는 1이 될 수 있고 B는 2가 될 수 있습니다. 그 다음 숫자 순서로 단어 또는 구를 표현할 수 있습니다. 앞에서 봤듯이, 이러한 숫자는 on 또는 off 전기 신호로 저장할 수 있습니다. 각 웹페이지 또는 전화에서 보는 각 단어는 이와 같은 체계를 사용하여 나타낸 것입니다. "
      10:
        text: "이제, 사진과 비디오 또한 화면 상에서 보는 모든 그래픽에 대해 함께 생각해 봐요."
      11:
        text: "이러한 이미지 모두는 픽셀이라고 부르는 아주 작은 점으로 이루어 졌으며 각 픽셀에는 색상이 있습니다. 각 색상은 숫자로 나타낼 수 있습니다. 어느 한 전형적인 이미지에 수 백만의 픽셀이 있고 전형적인 비디오가 초당 30개의 이미지를 보여 준다고 생각할 때, 이제 우리는 여기서 많은 데이터에 대해 이야기하게 될 것입니다. "
      12:
        text: "각 사운드는 기본적으로 공기 중에서 나는 일련의 진동입니다. 진동은 그래픽적으로 파형으로 표현할 수 있습니다. 이 파형의 어느 한 점은 숫자로 나타낼 수 있습니다. 이 방식으로 사운드는 일련의 수들로 나눌 수 있습니다. 더 높은 질의 사운드를 원하면 32비트 오디오 또는 8비트 오디오를 선택할 수 있습니다. 더 많은 비트는 더 높은 범위의 수를 의미합니다.  "
      13:
        text: "컴퓨터를 사용해 코드를 작성하거나 또는 앱을 만들 때, 이러한 1과 0을 직접 다루지는 않습니다.하지만, 이미지 또는 사운드, 비디오는 다루게 됩니다. 그래서 컴퓨터가 그 안에서 작동하는 방식을 이해하길 원하면, 이 모두는 이 간단한 1과 0, 그 뒤에 있는 회로 내 전기 신호에서 비롯됩니다. "
    csd_concept_circuits_logic:
      1:
        text: "지금까지 제가 회로에서 발견했던 가장 멋진 것 중의 하나는 회로는 창의적인 아이디어만 있다면 예술 형식이 될 수 있고 또한 회로를 사용하여 그 창의적인 아이디어를 얻을 수 있다는 것입니다. 그래서 아이디어가 있으면, 기술을 활용하여 그 아이디어를 현실화시킬 수 있습니다."
      2:
        text: "컴퓨터의 각 인풋 또는 아웃풋은 효과적인 정보 유형이며, on 또는 off 전기 신호 또는 1과 0으로 표현할 수 있습니다."
      3:
        text: "인풋으로서 들어 온 정보를 처리하고 아웃풋인 정보를 만들기 위해 컴퓨터는 인풋 신호를 수정 및 결합해야 합니다. 이를 위해 컴퓨터는 수 백만의 작은 전자 구성요소를 사용하고, 이러한 구성요소는 함께 회로를 형성합니다."
      4:
        text: "회로가 1과 0으로 표현되는 정보를 수정 및 처리하는 방법을 더 자세히 살펴 보아요. 이것은 믿을 수 없을 정도로 간단한 회로예요. 전기 신호 on 또는 off 중 하나를 받고 그 다음 그것을 홱 뒤집습니다. 그래서, 여러분이 준 신호가 1이면, 회로는 여러분에게 0을 주고 회로가 0을 받으면 1을 줍니다. 들어 오는 신호는 내보내는 신호와 같지 않아 그래서 우리는 이것을 회로 NOT이라고 부릅니다. "
      5:
        text: "더 복잡한 회로는 복수의 신호를 받아 이를 결합하여 다른 결과를 내 보냅니다. 이 예에서, 회로는 두 개의 전기 신호를 받을 것이며 이제 이 각각은 1 또는 0이 될 수 있습니다. 들어 올 신호 중 하나가 0이면, 결과 역시 0이 됩니다. 첫 번째 신호와 두 번째 신호 모두 1이면, 이 회로는 여러분에게 1만 줄 것이고, 그래서 우리는 이 회로를 AND라고 부릅니다.  "
      6:
        text: "간단한 논리적 계산을 수행하는 이와 같은 작은 회로가 많이 있습니다. 이러한 회로를 서로 연결하여 더 복잡한 계산을 수행하는 더 복잡한 회로를 만들 수 있습니다."
      7:
        text: "예를 들어, 2비트를 서로 더하는 가산기라 부르는 회로를 만들 수 있습니다. 이 회로는 각각 1 또는 0 중 하나가 될 수 있는 두 개의 개별 비트를 가져와 서로 더해 합을 계산합니다. 합은 0 더하기 0은 1 또는 0 더하기 1은 1 또는 1 더하기 1은 2가 될 수 있습니다. 이 합을 나타내기 위해 최대 2개의 이진 숫자를 가져 올 수 있기 때문에 두 개의 전선을 가져 와야 합니다. 일단 정보 2개 비트를 더하기 위한 단일 가산기가 있으면, 복수의 가산기 회로를 서로 합쳐 더 큰 숫자들을 함께 더할 수 있습니다. "
      8:
        text: "예를 들어, 여기 8 피트 가산기가 숫자 25와 50을 더하는 방법이 있습니다. 각 숫자는 8 비트를 사용하여 표현되고 그 결과로 16개의 다른 전기 신호가 나오며 이러한 전기 신호는 회로로 들어 갑니다. 8 비트 가산기용 회로는 그 안에 많은 작은 가산기가 들어 있으며 모두 함께 합을 계산합니다.  "
      9:
        text: "다른 전기 회로는 뺄셈 또는 곱셈과 같은 다른 간단한 계산을 수행할 수 있습니다. 사실, 컴퓨터가 처리하는 모든 정보는 단지 아주 많은 작은 간단한 연산이 서로 합쳐져 있는 것입니다. 컴퓨터에 의해 수행된 각 개별 연산은 간단하여 인간이 할 수 있지만 컴퓨터 안의 이러한 회로는 훨씬 훨씬 더 빠릅니다. "
      10:
        text: "이러한 회로가 크고 조잡하며, 8 비트 가산기가 냉장고 만큼 컸던 날로 되돌아 가면, 이것들로 간단한 계산을 하는데만 몇 분이 걸릴 수 있습니다. 오늘날, 컴퓨터 회로는 크기가 미세하며 훨씬 더 빠릅니다. 왜 더 작은 컴퓨터가 더 빠를까요? 회로가 적을 수록 전기 신호가 가야 할 거리가 짧기 때문입니다. 전기는 거의 빛의 속도로 이동하며 이 때문에 현대식 회로는 초당 수 십억 개의 계산을 할 수 있습니다.  "
      11:
        text: "게임을 하건, 동영상을 녹화하건 또는 우주를 탐구하건 기술로 할 수 있는 모든 일은 매우 빠르게 처리해야 하는 아주 많은 정보를 요구합니다. 이러한 복잡성 밑에는 단지 아주 작은 회로가 있으며 이러한 회로는 바이너리 신호를 웹사이트와 비디오, 음악, 게임으로 바꿉니다. 회로는 심지어 DNA를 판독하여 질병을 진단하고 치료하는데 도움을 줄 수 있습니다. 이러한 회로로 무엇을 하고 싶으세요?"
    csd_concept_memory_cpu_input_output:
      1:
        text: "안녕하세요. 제 이름은 Madison Maxey입니다. 저는 Loomia 라는 회사를 갖고 있으며 우리는 스마트한 옷과 스마트한 부드러운 좋은 제품을 위한 스마트 섬유에 중점을 두고 있습니다. 직물에 있어서 그것의 한계는 없습니다."
      2:
        text: "제 이름은 Danielle Applestone이며 Othermachine Company의 CEO입니다. 우리는 탁상용 절삭기계를 제작합니다. 절삭기계에는 회전하는 절단공구가 달려 있고 이 공구를 움직여 재료를 가공하여 3D 공작물을 만듭니다."
      3:
        text: "모든 컴퓨터는 동일한 네 가지 기본적인 일을 합니다. 정보를 입력하고 저장하며 처리하고 그 다음 출력합니다.이러한 일 각각은 컴퓨터의 각기 다른 부분에서 수행됩니다."
      4:
        text: "외부 세상에서 인풋을 가져와 바이너리 정보로 전환하는 인풋 기기가 있습니다. 메모리는 이러한 정보를 저장합니다. 중앙처리장치 또는 CPU는 모든 계산이 수행되는 곳입니다. 마지막으로 정보를 가져가 물리적인 아웃풋으로 전환하는 아웃풋 기기가 있습니다. "
      5:
        text: "먼저 인풋에 관해 이야기 해봐요. 컴퓨터는 많은 여러 유형의 인풋, 가령 컴퓨터의 키보드, 폰의 터치 패드, 카메라, 마이크, GPS을 취할 수 있습니다. 하지만 자동차의 센서 또는 온도조절장치, 드론 역시 다른 인풋 기기입니다."
      6:
        text: "이제, 인풋이 컴퓨터를 통과해 아웃풋이 되는 방법의 간단한 예를 함께 봐요. 키보드 위에 어느 한 키 가령 \"B\"라는 글자를 누르면, 키보드는 그 글자를 숫자로 전환합니다. 그 숫자는 바이너리 즉 1과 0으로서 컴퓨터로 보내집니다. "
      7:
        text: "이 숫자로 시작하여, CPU는 글자 \"B\"를 픽셀 x 픽셀로 표시하는 방법을 계산합니다.CPU는 글자 \"B\"를 그리는 방법을 말해 주는 스텝 바이 스텝 설명을 메모리에게 요청합니다. CPU는 이러한 설명을 실행하고 결과를 픽셀로 메모리에 저장합니다. "
      8:
        text: "마지막으로 이 픽셀 정보를 바이너리로 화면에 전송합니다. 화면은 아웃풋 기기이며 바이너리 신호를 지금 보는 것과 같은 작은 빛과 색상으로 전환합니다."
      9:
        text: "이 모든 것은 매우 빠르게 일어나 순간적이라고 느껴지지만 각 글자를 표시하기 위해 컴퓨터는 키 포인트가 눌러진 순간부터 시작하여 수 천개의 지침을 실행합니다."
      10:
        text: "그 예에서, 아웃풋 기기는 화면이었지만 컴퓨터에서 바이너리 신호를 가져와 물리적 세계에서 무슨 일인가를 하는 여러 유형의 아웃풋이 많이 있습니다. 예를 들어, 스피커에서는 소리가 나오고 3D 프린터는 객체를 인쇄합니다. 아웃풋 기기는 또한 로봇 팔과 자동차 모터, 우리 회사가 만드는 절삭 기기의 절단기처럼 물리적 동작을 제어할 수 있습니다. 새로운 유형의 인풋과 아웃풋이 컴퓨터를 세상과 완전히 새로운 방식으로 상호 작용하게 만듭니다. 이는 메모리와 CPU의 속도 및 크기의 개선으로 이루어 지고 있습니다."
      11:
        text: "일이 더 복잡해지고 인풋 또는 아웃풋에 더 많은 정보가 있으면, 컴퓨터는 더 많은 처리 능력과 메모리를 필요로 합니다. 화면 상에 글자를 타이핑하는 것은 쉬울 수 있지만 복잡한 3D 그래픽을 입력하거나 또는 고화질 영화를 녹화하기 위해, 현대식 컴퓨터는 복수의 CPU로 그 같은 정보 모두를 처리하고 기가 바이트의 메모리로 저장합니다."
      12:
        text: "컴퓨터로 무슨 일을 하길 원하든, 모든 단일 동작은 물리적 세계에서 정보를 입력하여 그 정보를 저장 및 처리하여 물리적 세계로 다시 출력하는 것입니다."
    csd_concept_hardware_software:
      1:
        text: "안녕하세요, 제 이름은 Erica Gomez이고 Amazon.com의 엔지니어링 매니저 입니다. 기술분야 특히 Amazon에서 일할 때 가장 좋은 일 중 하나는 내가 키우는 개를 매일 직장에 데리고 올 수 있다는 겁니다. 제 일은 소프트웨어의 출시를 돕는 일이고 내 개가 하는 일은 내 책상 아래서 낮잠을 자며 매우 시끄럽게 코를 고는 것입니다."
      2:
        text: "제 이름은 Jerome Holman이고 Team Xbox의 프로그램 매니저이며 제 일은 정말 재미 있어요. 기본적으로 하드웨어와 소프트웨어를 하나로 합쳐 Xbox에서 여러분의 좋아하는 모든 게임을 여러분에게 제공합니다."
      3:
        text: "컴퓨팅 기기 내부를 보면 한 무더기의 회로와 칩, 전선, 스피커, 플러그, 모든 종류의 기타 물체들을 볼 수 있습니다. 이것들이 하드웨어입니다."
      4:
        text: "하지만 소프트웨어는 볼 수 없습니다. 소프트웨어는 이 기계에서 실행되고 있는 모든 컴퓨터 프로그램 또는 코드입니다. 소프트웨어는 웹에서의 모든 것과 웹페이지의 게임, 저와 제 팀이 아마존에서 고객의 행동양식을 이해하기 위해 사용하는 데이터 과학 소프트웨어가 될 수 있습니다."
      5:
        text: "하지만, 소프트웨어와 하드웨어가 서로 어떻게 상호작용할까요? 컴퓨터의 중앙처리장치 또는 CPU를 함께 살펴 보기 시작해요."
      6:
        text: "CPU는 컴퓨터의 기타 부품 모두를 제어하는 마스터 칩입니다. CPU는 여러 일을 해야 해서 그 안에 특정 과업을 취급하는 더 작고 더 간단한 부품이 들어 있습니다. 간단한 수학과 로직을 하는 회로를 갖고 있어요. 다른 회로는 정보를 컴퓨터의 다른 부품으로 또는 에서 정보를 보내고 받습니다."
      7:
        text: "CPU의 실제 마법은 어느 회로를 언제 사용해야 하는지 아는 것입니다. CPU는 어느 회로를 사용하여 특정 일을 수행하게 하라고 말하는 간단한 명령어를 수신합니다. 예를 들어, \"더하기\" 명령어는 CPU에게 외부 회로를 사용하여 새 숫자를 계산하라고 말합니다. 그 다음, \n\"저장\" 명령어는 CPU에게 다른 회로를 사용하여 그 결과를 메모리에 저장하라고 말합니다. "
      8:
        text: "숫자와 마찬가지로, 이러한 간단한 명령어 모두는 바이너리 1과 2로 또는 on과 off의 전기신호로 나타낼 수 있습니다. 바이너리 명령어는 메모리에 저장되고 CPU가 그것을 가져가 순서대로 한 개씩 실행합니다. 이 명령어 순서는 사실, 매우 간단한 컴퓨터 프로그램입니다.  "
      9:
        text: "바이너리 코드는 가장 기본적인 형태의 소프트웨어이며 컴퓨터의 모든 하드웨어를 제어합니다. 오늘날, 아무도 소프트웨어를 바이너리로 작성하지 않습니다. 시간이 꽤 걸릴 것 입니다!"
      10:
        text: "오늘날, 우리가 작성하는 소프트웨어는 이 (파이썬) 또는 이 (루비), 심지어 이 (블러클리)와 더 많이 비슷하게 보입니다. 이러한 프로그래밍 언어는 영어와 매우 비슷하게 보이는 명령어로 타이핑하여 입력합니다. "
      11:
        text: "화면에 직사각형을 그리려면, 단지 하나의 명령어만 필요합니다. 이 높은 수준의 명령어는 CPU가 이해하는 수 백개 또는 수 천개의 더 간단한 바이너리 명령어로 전환됩니다. 소프트웨어는 CPU에게 해야 할 일을 말하지만 여러분이 음악을 듣고, 웹을 둘러보고 친구와 채팅할 때 컴퓨터는 소프트웨어의 복수 부분을 모두 한꺼번에 실행시키고 있습니다."
      12:
        text: "그래서 이러한 프로그램 모두를 처음 컴퓨터 위에 어떻게 올려 놓으며 또한 CPU는 어떻게 이 모두를 한 번에 실행할 수 있을까요? 알아내려면, 운영체제를 살펴 봐야 합니다."
      13:
        text: "컴퓨터의 운영체제는 소프트웨어의 컴퓨터 하드웨어 사용 방식을 관리하는 마스터 프로그램입니다. 예를 들어, 저는 대부분의 퍼스널 컴퓨터 상에서 실행되는 윈도우즈 운영체제를 만드는데 도움을 줬습니다."
      14:
        text: "운영체제는 컴퓨터 상의 다른 소프트웨어를 제어하는 특수한 능력을 가진 프로그램입니다. 이것으로 새 프로그램을 컴퓨터의 메모리에 로딩하여 새 프로그램을 설치할 수 있습니다. 프로그램을 중앙처리장치에 의해 언제 실행할지 또한 그 프로그램이 컴퓨터의 인풋과 아웃풋 기기에 액세스할 수 있는지 여부를 결정합니다. 컴퓨터가 많은 프로그램을 동시에 한번에 실행하고 있음을 생각할 때, 현실적으로, 빠르게 여러 프로그램을 뒤바꾸고 그 CPU를 일 초의 일부분 동안 공유하는 것은 운영체체입니다.    "
      15:
        text: "각 컴퓨터 내부에는 컴퓨터의 하드웨어를 제어하는 소프트웨어를 관리하는 운영체계가 있습니다."
      16:
        text: "소프트웨어는 간단한 바이너리 코드로 구성된 일련의 명령어이고 그 바이너리 코드는 수 십억개의 작은 회로를 통과해 흐르는 전기 신호일 뿐입니다."
      17:
        text: "컴퓨터는 모든 종류의 놀라운 일을 할 수 있는 잠재력이 있습니다. 하지만 컴퓨터를 스마트하거나 또는 유용하게 만드는 유일한 것은 여러분입니다. 코딩을 배울 때, 여러분은 풀고자 원하는 문제를 정의하고 그러한 아이디어를 현실화하는 소프트웨어를 작성하게 됩니다."
    hoc_dance_warmup:
      1:
        text: "아워오브코드 | 댄스 파티: 워밍 업"
      2:
        text: "안녕하세요! 제 이름은 Miral Kotb이고 저는 댄서이고 소프트웨어 개발자이며 iLuminate 창안자입니다."
      3:
        text: "그래서, 컴퓨터는 수 많은 방식으로 창의력과 관련이 있습니다. 정말, 측정할 수 없습니다. 일단 아이디어를 무엇인가에 넣을 수 있는 소프트웨어를 작성하는 능력을 가지면, 라이트 슈츠 (light suits)로 그 일을 합니다. 일단 소프트웨어를 작성할 도구를 가지면 가능성은 정말 끝이 없습니다."
      4:
        text: "다음 시간 동안에는 자신의 댄스 파티를 프로그래밍함으로써 컴퓨터 과학을 시작할거예요! 우리는 이미 히트 뮤직 몇 곡을 선곡하고 훌륭한 댄서들로 구성된 팀을 꾸려 놓았습니다. "
      5:
        text: "코드 블록을 사용해 여러 댄서를 선택할 것이며 그들의 춤동작을 변경하고 동작을 음악에 맞추며 서로 인터랙티브하게 만들 것입니다."
      6:
        text: "화면이 크게 세 부분으로 나눠진 것을 보게 될 거예요. 왼쪽은 플레이 공간이예요. 여기에서 댄서가 나올 거예요."
      7:
        text: "이 중간 영역은 툴박스예요. 레슨이 진행되면서 새 코드 블록이 이 공간에서 나올 거예요. "
      8:
        text: "우측 공간은 작업공간이예요. 툴박스에서 블록을 드래거하여 작업공간에 놓아 프로그램을 만들 수 있습니다."
      9:
        text: "각 레벨의 설명은 페이지 상단 여기 위에 있을 거예요. 힌트가 필요하면 전구를 클릭하세요."
      10:
        text: "시작하기 위해, 이 빨간색 블록으로 새 댄서를 만들어 봅시다. 먼저, 툴박스에서 드래그해서 이 주황색 \"설정\"블록 아래에 놓아요. 이 댄서는 고양이이고 이름은 \"내_첫_댄서\"예요. 이름은 여기를 클릭하여 원하는 대로 변경할 수 있어요."
      11:
        text: "또한 댄서가 플레이 공간 내 나오는 지점도 이것으로 변경할 수 있어요."
      12:
        text: "플레이 공간 위에는 음악을 고를 수 있는 메뉴가 있어요. 수 많은 노래가 있어 좋아하는 노래를 찾는 재미가 있을 거예요. 플레이 공간 아래에는 실행 버튼이 있어요. 실행을 누르면, 프로그램의 댄서가 플레이 공간에 나오고 음악이 나옵니다. "
      13:
        text: "직접 해보세요! 잘 되지 않고 뭔가 막힌 것같은 느낌이 들어도 괜찮아요! 그냥 일어나 움직여요. 미처 깨닫기도 전에 여러분은 여러분 자신의 댄스 파티를 만들 거예요. 그래서, 뭘 만들거예요?  "
    hoc_dance_events:
      1:
        text: "아워오브코드 | 댄스 파티: 이벤트"
      2:
        text: "저는 Aloe Blacc이예요. 저는 가수이고 작곡가이며 엔터테이너예요. 컴퓨터는 미래이기 때문에 컴퓨터 과학을 배우는 건 정말 중요하다고 생각해요 그리고 사람들의 생활을 말 그대로 통제하고 있는 테크놀로지를 사람이 통제한다는 것은 중요하다고 생각해요. "
      3:
        text: "음악에 맞쳐 딱 맞는 시간에 여러 댄스 동작을 하게 만들기 위해, 이벤트라 불리는 무언가를 사용할 수 있습니다. 이벤트는 프로그램에게 뭔가가 일어나는지 듣고 있다가 들리면 바로 반응하라고 말합니다."
      4:
        text: "이벤트의 몇 가지 예는 마우스 클릭 또는 화살표 버튼, 화면 터치 듣기입니다. 지금 우리가 사용하려면 이벤트는 노래에서 변화되는 부분을 듣는 것입니다. 변화가 일어나면 댄서는 새로운 춤을 추기 시작합니다."
      5:
        text: "전문 댄서는 노래의 박자를 세며 안무를 연습합니다."
      6:
        text: "음악에서 마디는 일정 수의 박자를 지칭합니다. 대부분의 인기있는 노래에서 마디는 4박자 길이입니다.  "
      7:
        text: "댄서를 마음대로 돌아다니게 풀어주려면, 녹색 이벤트 블록이 필요할 거예요. 이 이벤트 블록은 \"4 마디 후\"라고 말합니다."
      8:
        text: "보라색의 \"무한 실시\" 블록을 드래그해서 가져오면, 댄서가 출 댄스를 선택할 수 있습니다. 이 블록이 \"4 마디 후\" 이벤트 블록 아래에 있기 때문에 댄서는 노래의 네 마디를 기다렸다가 댄스를 시작할 것입니다. "
      9:
        text: "디스플레이 영역 상단에서 마디 카운터를 지켜보세요."
      10:
        text: "댄스 코드를 시작시켜 줄 이벤트를 보고 들으세요. 그리고 큐에 오면, 댄서는 가기 시작합니다."
    hoc_dance_properties:
      1:
        text: "아워오브코드 | 댄스 파티: 속성"
      2:
        text: "제 이름은 Maria예요. 저는 워싱턴 대학교 3학년이고 Amazon의 미래 엔지니어입니다."
      3:
        text: "저는 컴퓨터 과학이 문제해결과 비판적 사고를 통합하고 몇 시간 몰두해서 일하면 정말 멋진 뭔가를 얻고 큰 보상을 받기 때문에 정말 컴퓨터 과학이 좋아요."
      4:
        text: "지금까지, 일부 다른 유형의 댄서로 플레이할 기회를 가졌고 그들에게 다른 유형의 댄스 동작을 하도록 프로그래밍했습니다. 하지만 어떻게 그러한 동작이 정말로 되게 만들었어요?"
      5:
        text: "각 댄스 동작은 프레임이라고 부르는 일련의 이미지로 이루어 집니다. 각 프레임은 그 전의 프레임과 약간 달라요. 프로그램을 실행할 때, 컴퓨터는 프레임을 하나 씩 순서대로 보여줍니다. 빠르게 보여주기 때문에 마치 댄서가 움직이는 것처럼 보여요. 이것이 모든 애니메이션 뒤에 숨어 있는 비밀이예요. "
      6:
        text: "댄서의 동작을 바꿀 수 있을 뿐 만 아니라 댄서의 속성도 바꿀 수 있어요. 속성은 댄서의 화면 위 위치, 댄서의 크기, 댄서의 색상 등과 같은 걸을 설명해요."
      7:
        text: "댄서의 속성을 변경하기 위해 여러분은 설정 블록을 사용할 거예요. 설정 블록을 사용해 댄서를 더 작게 보이게 만들어 봐요. 먼저, 설정 블록을 드래그해서 프로그램에 가져옵니다. 그 다음, 변경하고 싶은 댄서를 선택하고 화면 위에 나오는 크기를 타이핑하여 입력하세요."
      8:
        text: "전체 크기는 100입니다. 더 낮은 숫자를 선택하면 댄서는 더 작아질 거예요. 댄서가 더 작아지면, 댄서는 더 뒤에서 보이게 됩니다. 이런 방식으로 백업 댄서를 만드는 거예요."
      9:
        text: "설정 블록을 사용하여, 댄서의 규격과 회전, 위치, 색상을 변경할 수 있습니다. 이러한 속성을 가지고 이리저리 조작하면, 모든 종류의 변경을 만들어 내고 그것들을 노래의 다른 부분에 링크할 수 있습니다."
      10:
        text: "기억하세요. 이미 존재한 댄서의 속성만을 설정할 수 있습니다. 설정 블록은 \"새 댄서 만들기\" 블록 다음에 나오게 해야 합니다. 편안한 마음으로 창의력을 실험하고 재미있는 시간 보내세요."
    hoc_dance_congrats:
      1:
        text: "아워오브코드 | 댄스 파티: 파티 시작!"
      2:
        text: "축하합니다! 컴퓨터 과학의 기초를 배웠습니다. 이제 다음의 블록을 사용해 친구와 공유할 자신이 직접 설계한 댄스 파티를 만들 수 있습니다.  "
      3:
        text: "툴박스 안을 보면, 전에 보지 못했던 새 블록을 몇 개 찾을 수 있을 거예요. 예를 들어, 레이아웃 블록으로 댄서를 화면 위에서 여러 방식으로 정렬시킬 수 있습니다."
      4:
        text: "주위를 둘러보고 이 새 블록과 특징으로 실험해 보세요. 좋아하는 노래에 맞춰 세심한 안무로 된 댄스를 만들어 볼래요?"
      5:
        text: "아니면 친구와 자유롭게 추는 춤을 만들래요?"
      6:
        text: "또는 그 밖에 다른걸 만들래요?"
      7:
        text: "튜토리얼의 끝부분에서, 여러분의 작품 링크를 친구와 공유할 수 있습니다. 상상력을 펼치고 재미 있게 보내세요!"
    mc_2018_intro:
      1:
        text: "안녕하세요! 시간에 꼭 맞춰 왔네요. 보야지 아쿠아틱에 오신 걸 환영합니다. 저는 해저 숨겨져 있는 보물을 찾기 위한 퀘스트를 이제 막 착수하려 하고 제가 여러분을 도울 수 있게 되어 매우 기뻐요. 이 신비로 가득찬 해저에서 무엇을 만나게 될지 누가 알겠어요? 우리는 우리의 첫 번째 가이드를 이 도크 위에서 만나기로 했어요.  "
      2:
        text: "모험가 여러분 환영합니다! 보야지 아쿠아틱을 완료하려면, 코드를 사용하여 일련의 퍼즐을 풀어야 해요. 어떻게 하는지가 알려 드릴께요. 화면은 세 개의 주요 부분으로 나눠져 있어요."
      3:
        text: "좌측에서, 마인크래프트 세계를 보게 될거예요."
      4:
        text: "중간 영역은 툴박스이고 거기서 코딩 명령어를 찾을 수 있어요."
      5:
        text: "우측 가장 큰 영역이 작업공간입니다. 거기에서 명령어를 쌓아 프로그램을 만들고 움직임을 제어합니다."
      6:
        text: "각 레벨의 설명은 페이지 상단에 있어요. 플러스 기호를 클릭하면 긴 설명에서 짧은 설명 또는 그 반대로 변해요."
      7:
        text: "블록을 툴박스에서 작업공간으로 드래그 해서 옮기고, 블록을 쌓고 그 다음, 실행 버튼을 클릭해 명령을 실행해 보세요."
      8:
        text: "맞게 하기 위해 몇 번을 계속 시도해야 할 수도 있고 일부 퍼즐은 한 가지 이상의 솔루션을 갖고 있어 어떻게 되는지 실험할 수 있습니다."
      9:
        text: "다시 해보고 싶으면, 재설정 버튼을 클릭하여 시작했던 지점으로 되돌아 갑니다."
      10:
        text: "명령어를 삭제해야 하면, 그 블록을 작업공간에서 드래그해서 다시 툴박스에 가져다 놓습니다. 기억하세요. \"실행\"을 클릭하여 코드가 어떤 동작으로 나오는지 보세요. "
      11:
        text: "좋아요. 충분히 빈둥대었네요. 모험가님. 해저 보물을 찾기 위한 코딩을 시작해 볼까요."
    MC_2018_loops:
      1:
        text: "잘했어요! 대구를 잡았어요! 대구를 돌고래에게 먹이로 주면, 돌고래가 보물이 있을 수 있는 난파선으로 안내해 준다는 거 알고 있었어요? 더 가깝게 가야 해요. 다음 퍼즐 세트는 더 풀기 힘들거고 그래서 더 많은 코딩 기술을 배우는 게 나을 거예요. 이게 뭐예요? 동굴? "
      2:
        text: "모험가 여러분 환영합니다! 제 이름은 Squidd예요. 저는 여러분이 지난 퍼즐 몇 개에서 동일한 명령어 세트를 계속 반복해서 사용하고 있는 걸 발견했어요. 분명 약간 지겨웠을 거예요. 설거지 또는 양치질 처럼 계속 반복해서 해야 하는 일을 지겹거나 또는 지루하지 않게 하는 방법을 원했던 적 없어요? 그런 방법이 있으면 좋을 거예요."
      3:
        text: "컴퓨터는 정말 코딩 루프를 사용하여 동일한 일을 계속 반복해서 하는 걸 정말 잘해요. 프로그램이 동일한 일을 여러 번 하길 원할 때, 루프를 사용할 수 있어요! "
      4:
        text: "루프 블록에는 목표에 도달할 때까지 반복되는 지시사항이 들어 있어요. 일단 프로그램이 \"목표까지 반복\" 루프를 시작하면, 목표에 도달할 때까지 그 안에서 지시사항이 계속 반복될 거예요."
      5:
        text: "직접 해보세요! 반복하길 원하는 명령어를 \"목표까지 반복\" 블록 안에 넣고, \"실행\"을 클릭하고, 어떻게 되는지 보세요."
      6:
        text: "글쎄, 약간 이상했어요. 오징어가 코딩을 하는지 누가 알았겠어요? 심지어 오징어에 손가락이 있는지는 미처 생각 못했네요. 그래서 지금 우리는 루프에 대해 압니다. 그것을 사용해 더 많은 보물을 얻어 보아요."
    mc_2018_conditionals:
      1:
        text: "와! 또 다른 세 개의 퍼즐을 풀었어요! 그리고, 연어를....잡았어요. 금 무더기 만큼 흥분되지는 않지만 우리가 얻을 수 있는 것을 가져가게 될 거예요. 그리고 앵무조개 껍데기가 나중에 유용하게 쓰여질 것 같은 느낌이 들어요. 이 폐허 안에 무엇이 숨어 있을지 궁금하네요. 아마도 또 다른 힌트! 내부를을 살펴 봐요. "
      2:
        text: "제 이름은 Netty예요 이 폐허에 오신 걸 환영합니다. 우리는 항상 조건에 기초하여 결정을 내립니다. 비가 올거 같으면 우산을 집어 들거예요. 배고프면, 뭔가를 먹을 거예요. "
      3:
        text: "크리퍼를 보면, 반대 방향으로 도망갈 거예요. 컴퓨터 역시 이러한 유형의 결정을 내립니다. 실제 코딩을 사용하여 조건에 반응할 수 있습니다. "
      4:
        text: "코드 명령어를 사용하여 이와 같은 반응을 프로그래밍하기 위해, '경로가 있으면' 블록을 선택하세요.  "
      5:
        text: "명령어를 만들려면 드롭다운을 선택하세요."
      6:
        text: "예를 들어, \"오른쪽으로 가는 길이 있으면\" 명령어를 쓰고 그 조건 안에 우회전을 넣으면, 스티브는 우측으로 열린  길이 도달하면 그는 항상 우회전을 할 거예요. 우측으로 난 길이 없으면, 우회전을 하지 않을 거예요. 이 조건 만약 명령어는 해저 동굴 안 신비로운 폐허 등과 같은 예측할 수 없는 상황에서 코드를 실행할 때 유용합니다. "
      7:
        text: "If 블록을 사용하여 코드를 한번 만들어 보세요."
      8:
        text: "와우! Netty의 폐허는 정말 멋지네요. 전 정말 부모님 집에서 나와야 해요. 그래, 어떻게 생각해요? 조건이 우리가 이 최종 퍼즐을 완료하기에 맞나요? 한번 해봅시다."
    mc_2018_closing:
      1:
        text: "Amy Lee33: 축하해요! 해냈어요!"
      2:
        text: "Squid: 축하해요!"
      3:
        text: "Netty: 해냈어요! 축하해요!"
      4:
        text: "Tomohawk: 축하해요!"
      5:
        text: "정말 좋은 날이예요! 보석찾기가 우리를 마인크래프트 도관을 건설하고, 앵무조개 껍질을 찾게 하며, 보물상자를 발견하게 이끌었어요. 전 정말 바다의 색이 좋아요. 또한 루프와 조건으로 코딩하는 법을 배웠어요.  "
      6:
        text: "코딩에 대해 말하면, 이 퀘스트에는 한 개 레벨이 더 있어요. 모험가들, 해보겠어요?"
      7:
        text: "이건 프리 플레이 레벨이고 여러분의 코딩 기술을 발휘해 믿을 수 없는 무언가를 사용하고 만들 수 있어요."
      8:
        text: "흠...보석을 숨길 장소, 해저 기념관, 산호성? 아...아이디어가 너무 많아요. 루프를 사용해 반복 동작을 만들고 조건을 사용해 모든 예측하지 못했던 시나리오에 대비하세요."
      9:
        text: "여러분은 지금까지 두려움을 모르는 코더임을 스스로 확실하게 증명하고 있으며, 여러분이 무엇을 만들지 빨리 보고 싶어요. 코드를 갖고 하는 여러분의 모험이 여기서 끝나지 않길 희망해요. 즐거운 여행 되세요!"
    teaching_csf_how_it_works:
      1:
        image: 'notes/teaching_cs_fundamentals_1.png'
        text: "이 과정은 단계로 나눠져 있습니다."
      2:
        image: 'notes/teaching_cs_fundamentals_2.png'
        text: "처음 몇 개의 단계는 컴퓨터 과학이 무엇인지는 물론 주요 단어를 소개합니다."
      3:
        image: 'notes/teaching_cs_fundamentals_3.png'
        text: "다음, 여러분은 여러분의 학생이 배우게 될 방식과 동일한 방식으로 코딩하는 법을 배울 것입니다. 과정의 마지막 단계는 컴퓨터 과학을 교실에서 가르치기 위한 계획을 수립하는데 도움을 줄 것입니다. 과정 내내, 플러그드-또는 온라인-레슨은 물론 컴퓨터 없이 하는 언플러그드 레슨 두 가지 모두의 예를 보게 될 것입니다."
      4:
        image: 'notes/teaching_cs_fundamentals_4.png'
        text: "학습 플랫폼이 진도를 추적하기 떄문에 언제든 지난 번 진도 다음에서 다시 시작할 수 있습니다."
    what_is_cs:
      1:
        image: 'notes/what_is_cs.png'
        text: "코딩은 코더가 컴퓨터에게 내리는 여러 지시사항입니다. 컴퓨터 과학은 사람들이 컴퓨터의 힘을 사용하여 큰 문제를 해결하는 분야입니다. 컴퓨터 과학에는 코딩이 포함되지만 또한 인터넷 작동방식과 인터넷이 사회에 미치는 영향, 빅 데이터로 하는 일, 큰 문제를 해결하는 방법 등과 같은 다른 것들도 포함되어 있습니다. 컴퓨터 과학은 문제해결과 비판적 사고, 끈기에 관한 학문입니다."
    writing_first_program:
      1:
        image: 'notes/writing_first_program_1.png'
        text: "Code.org는 블러클리라고 부르는 시각적, 드래그 앤 드롭 프로그래밍 언어를 사용합니다. 블러클리는 블록이라 부르는 다채로운 색상의 지시사항을 사용하여 프로그램을 만들고 퍼즐을 풉니다."
      2:
        image: 'notes/writing_first_program_2.png'
        text: "각 퍼즐에는 네 개의 부분이 있습니다."
      3:
        image: 'notes/writing_first_program_3.png'
        text: "플레이 영역은 좌측에 있고 프로그램이 실행되는 곳입니다."
      4:
        image: 'notes/writing_first_program_4.png'
        text: "중앙은 툴박스 영역으로 필요한 블록이 모두 거기에 있습니다."
      5:
        image: 'notes/writing_first_program_5.png'
        text: "우측은 작업공간으로 블록을 드래그해서 가져와 프로그램을 만듭니다. "
      6:
        image: 'notes/writing_first_program_6.png'
        text: "작업공간 위에는 각 퍼즐의 사용 설명서가 있습니다."
      7:
        image: 'notes/writing_first_program_7.png'
        text: "툴박스에서 너무 많은 블록을 가져 왔으면 남는 블록은 다시 툴박스로 드래그하여 집어 넣습니다. 실행을 눌러 프로그램을 시작해 보고 재설정을 누르면 다시 시도됩니다."
    repeat_block:
      1:
        image: 'notes/repeat_block.png'
        text: "반복 블록은 그 안에 있는 코드를 지정한 횟수만큼 반복하여 실행합니다."
    what_is_an_event:
      1:
        image: 'notes/what_is_an_event.png'
        text: "이벤트는 프로그램에게 어떤 일이 일어났는지 들으라고 말합니다. 그 일이 일어났을 때 프로그램은 동작을 수행합니다. 컴퓨터는 마우스 클릭, 화살표 버튼 누르기, 화면 터치 등을 들을 것입니다."
    lesson_planning:
      1:
        image: 'notes/lesson_planning_1.png'
        text: "CS 기초 레슨은 레슨이 다룰 내용을 알려주기 위한 개론으로 시작합니다."
      2:
        image: 'notes/lesson_planning_2.png'
        text: "레슨은 워밍업과 활동, 마무리로 구성됩니다. 자신만의 레슨 계획을 만들고 싶으면, 다음의 팁을 명심해 두는 것도 괜찮습니다."
      3:
        image: 'notes/lesson_planning_3.png'
        text: "1. 나선형 커리큘럼 설계를 사용해 보세요. 개념을 한번 소개하고 그 다음 다시 되돌아와 살펴봅니다."
      4:
        image: 'notes/lesson_planning_4.png'
        text: "2.온라인 레슨과 언플러그드 레슨을 결합하여 혼합된 학습 경험을 창출하세요."
      5:
        image: 'notes/lesson_planning_5.png'
        text: "3. 커리큘럼을 더 작은 덩어리로 나눕니다."
      6:
        image: 'notes/lesson_planning_6.png'
        text: "4. 지역 기준과 대학 및 직업 준비 기술에 맞추도록 합니다."
    opd_closing:
      1:
        image: 'notes/opd_closing_1.png'
        text: "축하합니다! 컴퓨터 과학 원리 교습 온라인 과정을 모두 마치셨습니다. 이제 학생들의 미래를 준비하는 점점 성장하는 교사 커뮤티니의 일원이 되셨습니다."
      2:
        image: 'notes/opd_closing_2.png'
        text: "더 많은 지원이 필요하면 다음의 리소스를 확인하세요: 1. forum.code.org 2. @teachcode on Twitter 3. studio.code.org "
    hoc_dance_warmup_2019:
      1:
        text: "아워오브코드 | 댄스 파티: 워밍 업"
      2:
        text: "안녕하세요! 제 이름은 Miral Kotb이고 저는 댄서이고 소프트웨어 개발자이며 iLuminate 창안자입니다."
      3:
        text: "컴퓨터 과학은 수 많은 방식으로 창의력과 관련이 있습니다. 정말, 측정할 수 없습니다. 일단 아이디어를 무엇인가에 넣을 수 있는 소프트웨어를 작성하는 능력을 가지면, 라이트 슈츠 (light suits)로 그 일을 합니다. 일단 소프트웨어를 작성할 도구를 가지면 가능성은 정말 끝이 없습니다."
      4:
        text: "다음 시간 동안에는 자신의 댄스 파티를 프로그래밍함으로써 컴퓨터 과학을 시작할거예요! 우리는 이미 히트 뮤직 몇 곡을 선곡하고 훌륭한 댄서들로 구성된 팀을 꾸려 놓았습니다. "
      5:
        image: 'notes/hoc_dance_warmup_2019_5.png'
        text: "코드 블록을 사용해 여러 댄서를 선택할 것이며 그들의 춤동작을 변경하고 동작을 음악에 맞추며 서로 인터랙티브하게 만들 것입니다."
      6:
        image: 'notes/hoc_dance_warmup_2019_6.png'
        text: "화면이 크게 세 부분으로 나눠진 것을 보게 될 거예요. 왼쪽은 플레이 공간이예요. 여기에서 댄서가 나올 거예요."
      7:
        image: 'notes/hoc_dance_warmup_2019_7.png'
        text: "이 중간 영역은 툴박스예요. 레슨이 진행되면서 새 코드 블록이 이 공간에서 나올 거예요. "
      8:
        image: 'notes/hoc_dance_warmup_2019_8.png'
        text: "우측 공간은 작업공간이예요. 툴박스에서 블록을 드래거하여 작업공간에 놓아 프로그램을 만들 수 있습니다."
      9:
        image: 'notes/hoc_dance_warmup_2019_9.png'
        text: "각 레벨의 설명은 페이지 상단 여기 위에 있을 거예요. 힌트가 필요하면 전구를 클릭하세요."
      10:
        image: 'notes/hoc_dance_warmup_2019_10.png'
        text: "시작하기 위해, 이 빨간색 블록으로 새 댄서를 만들어 봅시다. 먼저, 툴박스에서 드래그해서 이 주황색 \"설정\"블록 아래에 놓아요. 이 댄서는 고양이예요."
      11:
        image: 'notes/hoc_dance_warmup_2019_11.png'
        text: "또한 댄서가 플레이 공간 내 나오는 지점도 이것으로 변경할 수 있어요."
      12:
        image: 'notes/hoc_dance_warmup_2019_12.png'
        text: "플레이 공간 위에는 음악을 고를 수 있는 메뉴가 있어요. 수 많은 노래가 있어 좋아하는 노래를 찾는 재미가 있을 거예요. 플레이 공간 아래에는 실행 버튼이 있어요. 실행을 누르면, 프로그램의 댄서가 플레이 공간에 나오고 음악이 나옵니다. "
      13:
        text: "직접 해보세요! 잘 되지 않고 뭔가 막힌 것같은 느낌이 들어도 괜찮아요! 그냥 일어나 움직여요. 미처 깨닫기도 전에 여러분은 여러분 자신의 댄스 파티를 만들 거예요. 그래서, 뭘 만들거예요?  "
    hoc_dance_events_2019:
      1:
        text: "아워오브코드 | 댄스 파티: 이벤트"
      2:
        image: 'notes/hoc_dance_events_2019_2.png'
        text: "제 이름은 Erin이고 여기 Code.org의 소프트웨어 엔지니어입니다. 저는 댄스 파티를 제작하는 일을 도왔습니다."
      3:
        image: 'notes/hoc_dance_events_2019_3.png'
        text: "음악에 맞쳐 딱 맞는 시간에 여러 댄스 동작을 하게 만들기 위해, 이벤트라 불리는 무언가를 사용할 수 있습니다. 이벤트는 프로그램에게 뭔가가 일어나는지 \"듣고\" 있다가 들리면 바로 반응하라고 말합니다."
      4:
        image: 'notes/hoc_dance_events_2019_4.png'
        text: "여러 가지 이벤트들 중 몇가지 예시는, 마우스 클릭, 방향 버튼, 화면 터치 등 입니다."
      5:
        image: 'notes/hoc_dance_events_2019_5.png'
        text: " 여기서 우리는 화면 위 화살표 버튼을 클릭하거나 또는 키보드 위 키를 누르면 댄서가 움직이도록 프로그래밍할 거예요. "
      6:
        image: 'notes/hoc_dance_events_2019_6.png'
        text: "\"위로 화살표 일때\" 이벤트 블록을 사용하고 \"한번 실행\"블록을 이것에 연결할 수 있습니다. 누군가 위로 화살표 키를 누룰 때, \"위로 화살표 일때\" 블록에 붙어 있는 코드가 실행됩니다. 어느 댄스 동작을 선택할래요?"
      7:
        image: 'notes/hoc_dance_events_2019_7.png'
        text: "선택한 댄스 유형은 \"설정\"블록 안에 있는 댄서 중 하나와 반드시 일치하여야 하며 그렇지 않으면 아무 일도 일어나지 않을 수 있습니다. "
      8:
        image: 'notes/hoc_dance_events_2019_8.png'
        text: "결국, 이와 같은 더 많은 이벤트를 만들어 키가 눌러졌을 때 댄서가 다른 동작을 하게 할 수 있습니다. 인터랙티브 댄스를 만들 수 있는 코드 몇 줄을 직접 작성해서 해 보세요."
    hoc_dance_measures_2019:
      1:
        image: 'notes/hoc_dance_measures_2019_1.png'
        text: "아워오브코드 | 댄스 파티: 마디"
      2:
        image: 'notes/hoc_dance_measures_2019_2.png'
        text: "저는 Aloe Blacc이예요. 저는 가수이고 작곡가이며 엔터테이너예요. 컴퓨터는 미래이기 때문에 컴퓨터 과학을 배우는 건 정말 중요하다고 생각해요 그리고 사람들의 생활을 말 그대로 통제하고 있는 테크놀로지를 사람이 통제한다는 것은 중요하다고 생각해요. "
      3:
        image: 'notes/hoc_dance_measures_2019_3.png'
        text: "지금 우리가 사용하려는 이벤트는 노래 속 변화를 들을 거예요. 이 변화가 감지되면 댄서는 다른 춤을 추게 될 거예요. "
      4:
        image: 'notes/hoc_dance_measures_2019_4.png'
        text: "전문 댄서는 노래의 박자를 세며 안무를 연습합니다. 음악에서 마디는 일정 수의 박자를 지칭합니다. 대부분의 인기있는 노래에서 마디는 4박자 길이입니다.  "
      5:
        image: 'notes/hoc_dance_measures_2019_5.png'
        text: "댄서를 마음대로 돌아다니게 풀어주려면, 녹색 이벤트 블록이 필요할 거예요. 이 이벤트 블록은 \"4 마디 후\"라고 말합니다."
      6:
        image: 'notes/hoc_dance_measures_2019_6.png'
        text: "보라색의 \"무한 실시\" 블록을 드래그해서 가져오면, 댄서가 출 댄스를 선택할 수 있습니다. 이 블록이 \"4 마디 후\" 이벤트 블록 아래에 있기 때문에 댄서는 노래의 네 마디를 기다렸다가 댄스를 시작할 것입니다. "
      7:
        image: 'notes/hoc_dance_measures_2019_7.png'
        text: "디스플레이 영역 상단에서 마디 카운터를 지켜보세요."
      8:
        image: 'notes/hoc_dance_measures_2019_8.png'
        text: "댄스 코드를 시작시켜 줄 이벤트를 보고 들으세요. 그리고 큐에 오면, 댄서는 가기 시작합니다."
    hoc_dance_properties_2019:
      1:
        text: "아워오브코드 | 댄스 파티: 속성"
      2:
        text: "제 이름은 Maria예요. 저는 워싱턴 대학교 3학년이고 Amazon의 미래 엔지니어입니다."
      3:
        text: "저는 컴퓨터 과학이 문제해결과 비판적 사고를 통합하고 몇 시간 몰두해서 일하면 정말 멋진 뭔가를 얻고 큰 보상을 받기 때문에 정말 컴퓨터 과학이 좋아요."
      4:
        text: "지금까지, 일부 다른 유형의 댄서로 플레이할 기회를 가졌고 그들에게 다른 유형의 댄스 동작을 하도록 프로그래밍했습니다. 하지만 어떻게 그러한 동작이 정말로 되게 만들었어요?"
      5:
        text: "각 댄스 동작은 프레임이라고 부르는 일련의 이미지로 이루어 집니다. 각 프레임은 그 전의 프레임과 약간 달라요. 프로그램을 실행할 때, 컴퓨터는 프레임을 하나 씩 순서대로 보여줍니다. 빠르게 보여주기 때문에 마치 댄서가 움직이는 것처럼 보여요. 이것이 모든 애니메이션 뒤에 숨어 있는 비밀이예요. "
      6:
        text: "댄서의 동작을 바꿀 수 있을 뿐 만 아니라 댄서의 속성도 바꿀 수 있어요. 속성은 댄서의 화면 위 위치, 댄서의 크기, 댄서의 색상 등과 같은 걸을 설명해요."
      7:
        image: 'notes/hoc_dance_properties_2019_7.png'
        text: "댄서의 속성을 변경하기 위해 여러분은 설정 블록을 사용할 거예요. 설정 블록을 사용해 댄서를 더 작게 보이게 만들어 봐요. 먼저, 설정 블록을 드래그해서 프로그램에 가져옵니다. "
      8:
        image: 'notes/hoc_dance_properties_2019_8.png'
        text: "그 다음, 변경하고 싶은 댄서를 선택하고 화면 위에 나오는 크기를 타이핑하여 입력하세요. 전체 크기는 100입니다. 더 낮은 숫자를 선택하면 댄서는 더 작아질 거예요. 댄서가 더 작아지면, 댄서는 더 뒤에서 보이게 됩니다. 이런 방식으로 백업 댄서를 만드는 거예요."
      9:
        image: 'notes/hoc_dance_properties_2019_9.png'
        text: "설정 블록을 사용하여, 댄서의 규격과 회전, 위치, 색상을 변경할 수 있습니다. 이러한 속성을 가지고 이리저리 조작하면, 모든 종류의 변경을 만들어 내고 그것들을 노래의 다른 부분에 링크할 수 있습니다."
      10:
        image: 'notes/hoc_dance_properties_2019_10.png'
        text: "기억하세요. 이미 존재한 댄서의 속성만을 설정할 수 있습니다. 설정 블록은 \"새 댄서 만들기\" 블록 다음에 나오게 해야 합니다. 편안한 마음으로 창의력을 실험하고 재미있는 시간 보내세요! "
    hoc_dance_congrats_2019:
      1:
        text: "아워오브코드 | 댄스 파티: 파티 시작!"
      2:
        text: "축하합니다! 컴퓨터 과학의 기초를 배웠습니다. 이제 다음의 블록을 사용해 친구와 공유할 자신이 직접 설계한 댄스 파티를 만들 수 있습니다.  "
      3:
        text: "툴박스 안을 보면, 전에 보지 못했던 새 블록을 몇 개 찾을 수 있을 거예요. 예를 들어, 레이아웃 블록으로 댄서를 화면 위에서 여러 방식으로 정렬시킬 수 있습니다."
      4:
        text: "주위를 둘러보고 이 새 블록과 특징으로 실험해 보세요. 좋아하는 노래에 맞춰 세심한 안무로 된 댄스를 만들어 볼래요?"
      5:
        text: "아니면 친구와 자유롭게 추는 춤을 만들래요?"
      6:
        text: "또는 그 밖에 다른걸 만들래요?"
      7:
        image: 'notes/hoc_dance_congrats_7.png'
        text: "튜토리얼의 끝부분에서, 여러분의 작품 링크를 친구와 공유할 수 있습니다. 상상력을 펼치고 재미 있게 보내세요!"
