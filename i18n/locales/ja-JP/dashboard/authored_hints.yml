zh-TW:
  data:
    authored_hints:
      2-3 Artist 1 new_authored_hint:
        2-3_Artist_1_new_a: 如果你使用`移動-向前 100 像素`這個積木，我就會向前移動並自動畫一條線啦。
        2-3_Artist_1_new_b: 要如何才能轉彎？試試`轉向-右方 90 度`積木。
      2-3 Artist 11_authored_hint:
        2-3_Artist_11_a: '遇到角度的問題了嗎？你需要轉 8 次才能圍成一圈，也就是 360 度，那麼 360 ÷ 8 是多少呢？ '
      2-3 Artist 12_authored_hint:
        2-3_Artist_12_a: 一圈共是 360 度，所以，如果小藝術家每次轉 1 度的話，就要重複做 360 次才會轉一圈。
      2-3 Artist 2 new_authored_hint:
        2-3_Artist_2_new_a: 小藝術家好像沒有按照正確的方向前進，你可以讓他在畫線之前轉個彎嗎？
      2-3 Artist 3new_authored_hint:
        2-3_Artist_3new_a: 100 - 70 是多少呢？依照問題的描述，就可以得出帽子的高度！
        2-3_Artist_3new_b: 小藝術家好像沒有按照正確的方向前進，你可以讓他在畫線之前轉個彎嗎？
      2-3 Artist 4_authored_hint:
        2-3_Artist_4_a: 要蓋出這個房子的話，我們需要畫個正方形！
      2-3 Artist 6_authored_hint:
        2-3_Artist_6_a: '如果要做出這些小小的角度，我們必須讓每次畫完正方形之後的轉向角度大一些。   '
        2-3_Artist_6_b: 因為我們已經面向右邊，所以最簡單的方式，就是先往前移動，再向左轉，就可以製作出這個三角形。
        2-3_Artist_6_c: 三角形的每個邊長和正方形的邊長一樣，都是 100 像素！
      2-3 Artist 7_authored_hint:
        2-3_Artist_7_a: 要解決這個關卡最簡單的方法就是，在畫完第一個正方形時，讓小畫家在面朝下方，接著再畫出第二個正方形。
      2-3 Artist 8_authored_hint:
        2-3_Artist_8_a: 如果把 200 分成兩半，每個正方形是多少像素？
      2-3 Artist 9 NEW_authored_hint:
        2-3_Artist_9_a: 這個菱形的邊實際上和正方形的邊一樣。
      2-3 Artist 9 REPLACEMENT_authored_hint:
        step_size: 每一步都是 100 像素寬跟 100 像素高。
      2-3 Artist 9_authored_hint:
        2-3_Artist_9_a: 這個菱形實際上只是正方形轉了 45 度。
        2-3_Artist_9_b: |-
          別忘了將藝術家向左轉 45 度再開始畫正方形！
          
          ![](https://images.code.org/47cc2474e533667101a2d73b98da204e-image-1467744539967.gif)
      2-3 Artist Debugging 10_authored_hint:
        2-3_Artist_Debugging_10_a: 記得，你想要讓控制面板 *寬* 10 像素......所以確保要 **增加** 10 到任何你想要改變的數字。
        2-3_Artist_Debugging_10_b: "**錯誤嘗試在這裡完全沒關係！**  \n\n可以從一次改變一個數字開始。\n\n每個數字會有什麼效果？\n\n如果你有點混淆了，只要按下「重新開始」，然後你的程式碼就會被重置。"
      2-3 Artist Debugging 2_authored_hint:
        2-3_Artist_Debugging_2_a: 提示：每個鬍鬚長度為 75 像素。
      2-3 Artist Debugging 3_authored_hint:
        2-3_Artist_Debugging_3_a: 其中的一個轉向角度太小，只有 15 度。
        2-3_Artist_Debugging_3_b: 如果程式運行太快，看不清楚發生了什麼，可以嘗試使用滑桿來降低運行的速度。
      2-3 Artist Debugging 7_authored_hint:
        2-3_Artist_Debugging_7_a: 如果你讓藝術家畫完第一條線之後就向後移動或跳躍的話，會發生什麼？
      2-3 Artist Debugging 8_authored_hint:
        2-3_Artist_Debugging_8_a: |-
          我的形狀重複了幾次？
          
          形狀 *應該* 要重複幾次？
          
          怎樣在你的程式裡做出對應的改變？
      2-3 Artist Debugging 9_authored_hint:
        2-3_Artist_Debugging_9_a: 藝術家必須要向左再轉 60 度之後才能開始繪畫！
        2-3_Artist_Debugging_9_b: 你不需要添加另一個積木才能轉整圈，只要在`轉向-左方`積木上增加 60 度就行了！
      2-3 Artist Functions 1_authored_hint:
        2-3_Artist_Functions_1_a: 正方形每邊都有 100 像素，這代表你需要向前移動 175 像素之後才能開始畫第二個正方形。
        2-3_Artist_Functions_1_b: 畫出眼鏡時可以讓你的兩條線重疊沒關係。
      2-3 Artist Functions 11_authored_hint:
        2-3_Artist_Functions_11_a: 你不只需要改變函式中的數字跟每個邊長的長度，還需要改變藝術家在每邊需要轉的角度。
      2-3 Artist Functions 12_authored_hint:
        2-3_Artist_Functions_12_a: 試著先運行程式碼，再看看你需要加些什麼。
      2-3 Artist Functions 2_authored_hint:
        2-3_Artist_Functions_2_a: |-
          你的程式應該要：
          - 使用函式
          - 向前移動 100 + 75 像素
          - 使用函式
      2-3 Artist Functions 3_authored_hint:
        2-3_Artist_Functions_3_a: "* * 115 + 45 = 160 * *"
      2-3 Artist Functions 4_authored_hint:
        2-3_Artist_Functions_4_a: 藝術家需要在每個正方形之間轉 120 度才能完成這個設計。
      2-3 Artist Loops New 11_authored_hint:
        2-3_Artist_Loops_New_11_a: |-
          記住上個關卡的程式：
          
          ![](https://images.code.org/15288d042780242ec5edeed5204c6ebb-image-1469640792081.png)
        2-3_Artist_Loops_New_11_b: 你的下一個轉彎動作應該要在迴圈中程式碼的**最後面**。
      2-3 Artist Loops New 12_authored_hint:
        2-3_Artist Loops_New_12_a: 開始畫菱形之前，藝術家需要向左轉 60 度才能夠朝向正確的路徑。
        2-3_Artist Loops_New_12_b: 在藝術家向前走 100 像素之後，他需要向右轉 120 度才能做出銳角。
        2-3_Artist Loops_New_12_c: 這個藝術家只需要向右轉 60 度就能創造出鈍角。
      2-3 Artist Loops New 13_authored_hint:
        2-3_Artist_Loops_New_13_a: "在畫出一個菱形之後，藝術家已經面對了開始下一個的方向。\n\n因為這樣，我們不需要增加額外的`轉向-左方`積木。"
        2-3_Artist_Loops_New_13_b: "要做出每個菱形，藝術家需要：\n- 移動\n- 向右轉 120 度\n- 移動\n- 向右轉 60 度\n\n然後再做一次相同的動作！"
      2-3 Artist Loops New 9_authored_hint:
        2-3_Artist_Loops_New_9_a: 這個藝術家需要向右轉 45 度之後才能開始繪畫。
        2-3_Artist_Loops_New_9_b: 這個 V 形，其實就只是半個正方形。怎樣的程式碼可以畫出半個正方形？
      2-3 Artist Nested Loops 1_authored_hint:
        2-3_Artist_Nested_Loops_1_a: 記得把灰化的所有積木放進你的迴圈中。
      2-3 Artist Nested Loops 3_authored_hint:
        2-3_Artist_Nested_Loops_3_a: "需要我幫你找到正確的角度嗎？\n**360 / 12 = 30**"
        2-3_Artist_Nested_Loops_3_b: 記得把灰化的程式，還有轉向積木放到迴圈裡頭。
      2-3 Artist Nested Loops 4_authored_hint:
        2-3_Artist_Nested_Loops_3_a: "需要我幫你找到正確的角度嗎？\n**360 / 12 = 30**"
      2-3 Artist Nested Loops 5_authored_hint:
        2-3_Artist_Nested_Loops_5_a: "試著用`跳躍-向前`積木，讓小藝術家在畫完一個正方形後，跳到下一個要開始的地方。\n\n如果你的正方形是 20 像素高，而且兩個正方形相隔 20 像素遠，你需要跳多遠？"
      2-3 Artist Nested Loops 7_authored_hint:
        2-3_Artist_Nested_Loops_7_a: "你需要在每次的循環轉幾度？\n\n360/10 是多少？"
      2-3 Artist Nested Loops 9_authored_hint:
        2-3_Artist_Nested_Loops_9_a: |-
          需要幫忙來找到正確的角度嗎？
          
          **360 / 12 = 30**
      2-3 Bee Conditionals 14_authored_hint:
        2-3_Bee_Conditionals_14_a: 想不到要如何減少積木的使用量？試著把用在紫花上的程式套用到紅花上。
        2-3_Bee_Conditionals_14_b: 如果紅花變成紫花，想一想，要怎麼另外使用`重複`迴圈來減少代碼的使用？
        2-3_Bee_Conditionals_14_c: "試試把它分成兩塊來完成：\n\n![](https://images.code.org/895a52f3febff9edb83979f7861cf67a-image-1469640892331.png)\n\n1) 收集花蜜 3 次\n - 向前移動 5 次\n - 檢查是否為花蜜，如果是就採集\n - 向左轉\n \n2) 釀造蜂蜜\n - 向前移動 1 認\n - 釀造 2 個蜂蜜"
      2-3 Bee Conditionals 15_authored_hint:
        2-3_Bee_Conditionals_15_a: 請記住：每次你運行程式後，紫花的花蜜數會變成 0 或 1！
      2-3 Bee Conditionals 3_authored_hint:
        2-3_Bee_Conditionals_3_a: 如果你用迴圈的方式，程式就會精簡許多。一個迴圈用來向前移動，另一個迴圈用來收集花蜜，再一個迴圈來釀造蜂蜜。
      2-3 Bee Conditionals 6_authored_hint:
        2-3_Bee_Conditionals_6_a: 請記住：當你運行程式後，紫花的花蜜數會變成 0 或 1！
      2-3 Bee Debugging 1_authored_hint:
        2-3_Bee_Debugging_1_a: 在你找到並修正了不正確的積木的過程中，有發現哪些地方可以用一個`重複`迴圈讓程式變得更簡單嗎？
      2-3 Bee Debugging 2_authored_hint:
        2-3_Bee_Debugging_2_a: 在你找到並修正了不正確的積木的過程中，有發現哪些地方可以用一個`重複`迴圈讓程式變得更簡單嗎？
      2-3 Bee Debugging 4_authored_hint:
        2-3_Bee_Debugging_4_a: 蜜蜂做的事情裡頭好像有些地方不大對勁？當你更改那個積木後會發生什麼事呢？
      2-3 Bee Functions 4_authored_hint:
        2-3_Bee_Functions_4_a: 你不需要使用在迴圈裡頭帶個函式。試著移動，然後使用函式，接著再移動，再使用函式一遍。
      2-3 Bee Functions 6_authored_hint:
        2-3_Bee_Functions_6_a: 你不需要使用在迴圈裡頭帶個函式。試著移動，然後使用函式，接著再移動，再使用函式一遍。
      2-3 Bee Functions 8_authored_hint:
        2-3_Bee_Functions_8_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！\n\n![](https://images.code.org/3875224b35889000a0998ca25cfa4ecf-image-1467996493914.gif)"
      2-3 Bee Functions 9_authored_hint:
        2-3_Bee_Functions_8_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        2-3_Bee_Functions_8_b: |-
          記得要在綠色的函式積木裡建置你的程式。
          
          ![](https://images.code.org/8fe1fae5caf4ede3a9c9bd9f26940cde-image-1467996837459.gif)
      2-3 Bee Loops 2_authored_hint:
        2-3_Bee_Loops_2_a: 你的迴圈中應該要有 4 個積木。
      2-3 Bee Loops 3_authored_hint:
        2-3_Bee_Loops_3_a: 你的迴圈中應該要有 6 個積木。
      2-3 Bee Loops 3B_authored_hint:
        2-3_Bee_Loops_3B_a: 你需要 2 個不同的`重複`迴圈，一個接著一個。
      2-3 Bee Loops 4_authored_hint:
        2-3_Bee_Loops_4_a: 你的迴圈中應該要有 5 個積木。
      2-3 Bee Loops 4A_authored_hint:
        2-3_Bee_Loops_4A_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_4A_b: 在迴圈之外的結尾處再加上一些程式就可以完成了。
        2-3_Bee_Loops_4A_c: 如果你還不能準確的使用迴圈，可以先用長串的指令，然後再找出有什麼地方是可以用`重複`迴圈來替代的。
      2-3 Bee Loops 5_authored_hint:
        2-3_Bee_Loops_5_a: 如果你不能馬上的就使用`重複`積木來寫出程式，可以先把一個個的指令寫出來，然後找出指令間共同的模式。
      2-3 Bee Loops 6_authored_hint:
        2-3_Bee_Loops_6_a: 如果你沒有辦法很快的分辨出要在`重複`迴圈中放些什麼積木，可以試著先按照順序拖曳出每個積木，並在拖曳過程中找出它們的規律。
        2-3_Bee_Loops_6_b: 你的`重複`迴圈裡應該要有 6 個積木才對。
      2-3 Bee Loops 7_authored_hint:
        2-3_Bee_Loops_7_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_7_b: '如果你實在無法從頭想像迴圈的內容，可以先把需要的指令寫成長一點的程式，然後從裡頭找出組合模式。  '
      2-3 Maze 1_authored_hint:
        2-3_Maze_1_a: 要使用`移動-向前`積木的方式是，從工具箱把它拖曳到工作區中，並把它連接在`當運行時`積木下方。
      2-3 Maze 16_authored_hint:
        2-3_Maze_16_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        2-3_Maze_16_b: "如果要在`重複`迴圈中放置多個積木，只要拖曳一個迴圈到工作區，然後再把工作區上的積木堆拖曳到裡面。\n\n把它們放到`當運行時`積木就大功告成囉！"
      2-3 Maze 6_authored_hint:
        2-3_Maze_6_a: 有 2 個方法可以完成這個關卡！
      2-3 Maze Loops 17_authored_hint:
        2-3_Maze_Loops_17_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        2-3_Maze_Loops_17_b: 你把預先建立好的程式給刪除了嗎？點擊`重新開始`按鈕把程式找回來吧！
      2-3 Maze Loops 18_authored_hint:
        2-3_Maze_Loops_18_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
      2-3 Maze Loops 19_authored_hint:
        2-3_Maze_Loops_19_a: 如果你卡關了，一開始先不要用迴圈，試著先寫出所有的程式，然後在裡頭找規律。
        2-3_Maze_Loops_19_b: 放一個重複迴圈到另一個裡頭，這可以減少積木的使用量。
      2-3 Maze Loops 20_authored_hint:
        2-3_Maze_Loops_20_a: 找找這個樓梯迷宮的組合模式，看看是不是有重複的部分可以用迴圈替代。
      2-3 Maze Loops 21_authored_hint:
        2-3_Maze_Loops_21_a: 如果你一時之間找不到樓梯的組合模式，試試用手蓋住被擋住的路徑。
      4-5 Artist 1_authored_hint:
        4-5_Artist_1_a: "![](https://images.code.org/e5a08f29a9c4e306de5553dafca9fb5d-image-1467913845542.gif)"
      4-5 Artist 11_authored_hint:
        4-5_Artist_11_a: 在你的迴圈裡，確定小藝術家在畫完每個線條之後有使用跳躍積木。
      4-5 Artist 3_authored_hint:
        4-5_Artist_3_a: |-
          如果花壇的周長 600 像素，其中的二邊是 200 像素，短邊的長度會是多少：
          
          **600 - 200 - 200 = 200**
          
          那表示二條短邊共是 200 像素長，那一條呢？
          
          **200 / 2 是多少呢？**
        4-5_Artist_3_b: 如果你無法直接用`重複`積木來建立迴圈，試著先把需要的積木一個個的貼合起來，然後找到它們之間的規律。
      4-5 Artist 4_authored_hint:
        4-5_Artist_4_a: "一圈共有 360 度！\n\n這就是你要重複這個程式的次數（因為每次只轉 1 度）！"
      4-5 Artist 5_authored_hint:
        4-5_Artist_5_a: |-
          錯中學、學中錯…要解決這個問題的話，可以把 90 度除以 3。
          
          **90 / 3 = _____**
      4-5 Artist 7_authored_hint:
        4-5_Artist_7_a: '哪個角度最小？小藝術家面對的角度是多少？ '
      4-5 Artist 8_authored_hint:
        4-5_Artist_8_a: "每個長邊為 240 像素，也就是說其他的 2 個短邊計算方式為：\n\n**800 - 240 - 240 = 320**\n\n**320/2** 是多少呢？ "
        4-5_Artist_8_b: "這個圖案可以用 2 個方式畫出來！\n- 畫出二個長方形，長是 **120** 高是 **160**，然後部分重疊在一塊。\n\n- 畫出一個長方式，長是 **240** 高是 **160** ，接著在中間加上一條線。"
      4-5 Artist 9_authored_hint:
        4-5_Artist_9_a: "當一個三角形是等邊時，所有的邊的長度和所有角的角度都會一樣。\n"
        4-5_Artist_9_b: 你需要畫出三相同尺寸的三角形，別忘了每畫完一個就要跳到下一個新的位置。
      4-5 Artist Assessment 1_authored_hint:
        4-5_Artist_Assessment_1_a: 你只要畫出外部的三角形就可以完成這關。
      4-5 Artist Patterns 11_authored_hint:
        4-5_Artist_Patterns_11_a: 如果有個 360 度角的圓形，每次循環小藝術家會轉 3 度，你需要循環幾次（轉多少次）才能畫出一個半圓？
      4-5 Artist Patterns 2_authored_hint:
        4-5_Artist_Patterns_2_a: 注意，由於正方形是 20 像素長，你需要跳躍 20 像素，在你開始你的下一個迴圈之前。
      4-5 Artist Patterns 3_authored_hint:
        4-5_Artist_Patterns_3_a: 每次你試新的積木時，在工具箱拖曳出來請小心別和當前程式攪和在一起。
        4-5_Artist_Patterns_3_b: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      4-5 Artist Patterns 5_authored_hint:
        4-5_Artist_Patterns_5_a: "現在，當小藝術家完成每個菱形時，他面對的方向和接著要畫下個圖形的方向是相反的。\n\n他要轉多少度才能夠面對正確的方向呢？"
      4-5 Bee Conditionals 4_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      4-5 Bee Conditionals 5_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      4-5 Bee Conditionals 6_authored_hint:
        4-5 Bee Conditionals 6_a: 你只可以用工作區所有的積木來完成關卡，要怎麼樣排列它們呢？
        4-5 Bee Conditionals 6_b: 請確定你檢查了花朵上是否有 **0** 個以上的花蜜，至少檢查 **3** 次才能完成這個關卡。
      4-5 Bee Debugging 1_authored_hint:
        4-5_Bee_Debugging_1_a: 如果你無法看出問題在哪，可以運行程式，看看是哪裡出錯了。
      4-5 Bee Nested Loops Rows_authored_hint:
        4-5_Bee_Nested_Loops_Rows_a: 這就像個長方形，蜜蜂要往前移動、向左轉，總共多少次才能走完這個圖形。
      4-5 Maze 10_authored_hint:
        4-5_Maze_10_a: |-
          如果你不是很了解怎樣利用迴圈解決問題，試著先寫出長一點的程式，接著從裡頭找尋模式。
          
          你應該在`重複`積木裡放什麼程式，才能讓程式變得比較短？
      4-5 Maze 4_authored_hint:
        4-5_Maze_4_a: 如果你很難一次就找出可以放進迴圈的程式，試試先把所有程式寫出來，然後從裡頭找規律。
      4-5 Maze 5_authored_hint:
        4-5_Maze_5_a: 每次你用了二次以上的`移動-向前`積木時，試著改用`重複`迴圈來取代這些步驟。
        4-5_Maze_5_b: 你可以在這個關卡中使用多個`重複`迴圈。
      4-5 Maze 6_authored_hint:
        4-5_Maze_6_a: "試著用手指在畫面上走看看。\n這是你可以找到的最短路徑嗎？"
      4-5 Maze 7_authored_hint:
        4-5_Maze_7_a: "**想要讓你的程式變得更精簡？**\n\n在你的程式積木裡找到匹配的模式，你看得出來哪個部分是重複的嗎？試著把那些重複的部分放到一個迴圈進執行！"
      4-5 Nested Loops 12_authored_hint:
        4-5_Nested_Loops_12_a: "**360 / 36 = ?**"
      4-5 Nested Loops 2_authored_hint: [ ]
      4-5 Nested Loops 6_authored_hint:
        4-5_Nested_Loops_6_a: |-
          別忘了在內部循環中加上轉向。
          
          在一圈 360 度裡要畫出 6 個三角形。
          
          **360 / 6 = ?**
      4-5 Nested Loops 7_authored_hint:
        4-5_Nested_Loops_7_a: |-
          這個圖案會循環 10 次，在一圈 360 度裡。
          
          **360 / 10 = ?**
      4-5 Nested Loops 8_authored_hint:
        4-5_Nested_Loops_8_a: |-
          你要重複畫這個圖形 6 次，在一圈 360 度內。
          
          **360 / 6 = ?**
      4-5 While Loops 8_authored_hint:
        4-5_While_Loops_8_a: 每個項目都需要有自己的`當…`迴圈。
      Artist Inspiration_authored_hint:
        brush_width: 在我們開始前，先將筆刷的寬度設為 1，顏色設為藍色。
        double_loop: 試著放置一個`計數迴圈`到`重複`積木裡頭。
        specifics: "畫出 6 個「花瓣」的這個`計數迴圈`，每一次都會從 3 開始執行到 17，而畫出的形狀的邊數都會是奇數。\n\n`設置透明度`的積木中用了計數器，當計數器的值愈高時，顏色會變得愈淡。"
        after: 當你完成每個「花瓣」時，請檢查是否在你轉彎 60 度之前`移動-向前`了 20 像素。
        solution: |-
          **解決方案：**
          
          
          ![Image of Solution Blocks](https://images.code.org/d85a18bd31a09f87b41a818fc8d6c1cc-image-1469641375258.png)
      Bergeron Robot Maze1_authored_hint:
        2-3_Maze_1_a: 要使用`移動-向前`積木的方式是，從工具箱把它拖曳到工作區中，並把它連接在`當運行時`積木下方。
      Course 4 Artist 11_authored_hint:
        Course_4_Artist_11_a: '這個半六邊形有一個**30 像素的邊**還有需要轉向**60 度**。  '
        Course_4_Artist_11_b: '這個 2/3 的三角形有一個**80 像素的邊**還有需要轉向**120 度**。 '
      Course 4 Artist 12_authored_hint:
        Course_4_Artist_12_a: '每個重複的圖形都是**半六邊形**的組合，跟著**2/3 三角形**。 '
        Course_4_Artist_12_b: '部分圖形和上個關卡有些類似，除了半六邊形大了一點以外。 '
        Course_4_Artist_12_c: "1) 開始的三個線段為 60 像素長，你需要轉向 60 度。\n2) 接著的二個線段為 80 像素長，你需要轉向 120 度。 "
        Course_4_Artist_12_d: |-
          **解決方案：**
          
          ![Image of Solution Blocks](https://images.code.org/03dfe3f862f4bdbee2a1f5865b7d9d50-image-1469641020695.png)
      Course 4 Artist 6_authored_hint:
        Course_4_Artist_6_a: 在一圈 360 度中共有 3 個三角形…360 除以 3 是多少？
      Course 4 Artist 7_authored_hint: [ ]
      Course 4 Artist 8a_authored_hint:
        Course_4_Artist_8a: |-
          想要知道轉向的角度嗎？
          
          一圈 360 度中有 3 個三角形。
          
          360 除以 3 是多少？
      Course 4 Artist 9_authored_hint:
        Course_4_Artist_9_a: "想知道要轉多少度嗎？\n\n360 除以 10 等於多少？"
      Course 4 Artist Binary Free Play 2b_authored_hint:
        Course_4_Artist_Binary_Free_Play_2b_a: 這個程式中使用了 2 個`計數迴圈`，第一個從 1 算到 8，另一個則是從 8 算到 1。
        Course_4_Artist_Binary_Free_Play_2b_b: 每個`計數迴圈`裡有 3 個`重複`積木，第一個畫出左半部、第二個畫出中間、第三個畫出右半部。
        Course_4_Artist_Binary_Free_Play_2b_c: 在每一次的循環裡，你需要為 1s 使用 `counter` 計數，還有為 0s 使用 `16-(2 x counter)` 來計數。
        Course_4_Artist_Binary_Free_Play_2b_d: |-
          **解決方案：**
          
          
          ![solution](https://images.code.org/b282dd6324910b7d604e24182cbbccbb-image-1469641477135.png)
      Course 4 Artist For Loops 11_authored_hint:
        Course_4_Artist_For_Loops_11_a: "每個圖形之後轉向的角度都會改變！\n\\r\n使用運算類別積木，並輸入 360 除以邊數來產生圖形要轉向的角度。 "
      Course 4 Artist For Loops 11a_authored_hint:
        Course_4_Artist_For_Loops_11a_a: '360 除以多邊形的邊數，就是你要轉向的度數。 '
        Course_4_Artist_For_Loops_11a_b: '每一次你需要向前移動，共 10 次。移動的長度相當於多邊形的邊數。 '
      Course 4 Artist For Loops 3_authored_hint:
        Course_4_Artist_For_Loops_3_a: 如果要使用`計數`迴圈來作為移動的依據，請檢查你是不是使用了`counter`當作距離。
      Course 4 Artist For Loops 4_authored_hint:
        Course_4_Artist_For_Loops_4_a: "**需要的數字至少要是多少？\n最大的數字又是多少？\n每循環一次要增加多少？**\n\n這些問題是你每次在使用`計數`迴圈要思考的。"
      Course 4 Artist For Loops Challenge_authored_hint:
        Course_4_Artist_For_Loops_Challenge_a: 最大的形狀有 19 個邊，最小的則只有 2 個邊。
        Course_4_Artist_For_Loops_Challenge_b: '`計數`迴圈會在每一次循環增加或減少數字。'
      Course 4 Artist For Loops Challenge_a_authored_hint:
        Course_4_Artist_For_Loops_Challenge_a: 最大的多邊形有 19 個邊。
        Course_4_Artist_For_Loops_Challenge_b: 每個多邊形都不完整，其中有一條邊會比原來的短。
      Course 4 Artist For Loops inspire_authored_hint:
        Course_4_Artist_For_Loops_inspire_a: 這個程式的基礎和上個挑戰關卡很像…有些地方改了就是。
        Course_4_Artist_For_Loops_inspire_b: 試試看這個`計數`迴圈，從 3 算到 10，每次增加 1。
        Course_4_Artist_For_Loops_inspire_c: 在這個`計數`迴圈裡用了二個`重複`積木，不過第二個會轉成相反的方向。
        Course_4_Artist_For_Loops_inspire_d: "**解決方案：**\n\n![Solution](https://images.code.org/418dfd57794706de541f1c162911a6e2-image-1469641233597.png)"
      Course 4 Artist Functions Inspiration_authored_hint:
        Course_4_Artist_Functions_Inspiration_a: 利用上個關卡的程式，再添加額外的`轉向-右方 3 度`積木到重複迴圈裡頭。
        Course_4_Artist_Functions_Inspiration_b: 試試把`重複迴圈`之外的轉向角度改成比 90 度大，轉向的指令還是要放在`計數迴圈`裡。
        Course_4_Artist_Functions_Inspiration_c: |-
          **解決方案：**
          ![Solution](https://images.code.org/0c94bcde33a00595aa099fea964ca80e-image-1469641309381.png)
      Course 4 Artist Functions challenge_authored_hint:
        Course_4_Artist_Functions_challenge_a: 要掌握函式的使用方式，就是確定出哪些是你需要的，哪些是你不需要的。
        Course_4_Artist_Functions_challenge_b: 使用一個`計數迴圈`，然後在巢狀式的`重複`迴圈裡頭，使用它的計數變數。
        Course_4_Artist_Functions_challenge_c: 每次的循環，你都要畫個正方形然後向前跳躍。
        Course_4_Artist_Functions_challenge_d: 你需要在`重複`積木的外面添加向左轉 90 度的指令，不過指令還是要在`計數迴圈`裡頭。
      Course 4 Artist Inspire_authored_hint:
        Course_4_Artist_Inspire_a: 在你完成一個正方形後（轉向製作下一個之前）向前跳躍，跳的距離是邊長的一半。
        Course_4_Artist_Inspire_b: 畫出一個正方形然後跳躍，共重複 4 次（每次之間又用了向左轉），就可以做出這個像風車一樣的圖案。
        Course_4_Artist_Inspire_c: 每個風車圖案也重複了 4 次，轉向的角度為 **360/sides**。
        Course_4_Artist_Inspire_d: |-
          **解決方案：**
          ![Blocks for solution](https://images.code.org/35fa852515d73aa8cf6c2bde4f2d46a3-image-1469641128278.png)
      Course 4 Artist Vars 13_authored_hint:
        Course_4_Artist_Vars_13_a: 你需要 2 個重複迴圈（一個包著一個），兩個都重複 `sides`次。
        Course_4_Artist_Vars_13_b: "裡面的重複迴圈畫出了一個八邊形（轉向左邊）。\n\n之後，你只需要在迴圈外層添加向前移動，然後向右轉的程式。"
        Course_4_Artist_Vars_13_c: 如果要在邊數改變的同時又保持圖形的尺寸，可以使用運算積木，將周長除以邊數。
      Course 4 Artist Vars 6_authored_hint:
        Course_4_Artist_Vars_6_a: 若要畫出一個正多邊形，可以在每一次循環轉 **360/邊數** 度。
      Course 4 Artist Vars 8_authored_hint:
        Course_4_Artist_Vars_8_a: 如果你將起始長邊除以側邊數，當側邊個數越大時，每個的長邊將會變短
      Course 4 Bee Params 7_authored_hint:
        notice_pattern: '你找到花蜜數量變化的模式了嗎？ '
        count_with_for: 注意花蜜數量變化的方式，哪個積木可以用來重複執行程式，同時又可以每次向上計數呢？
      Course 4 Bee Params 8_authored_hint:
        Course_4_Bee_Params_8_a: 可以試試在每次都去查詢蜂蜜或花蜜的數量，如果沒有的話，數量會是 0。
      Course 4 Play Lab Params 2_authored_hint:
        Course_4_Play_Lab_Params_2_a: 你必須在 jump（跳躍）函式上點擊「編輯」，然後更新它，讓它可以使用 `height`（高度）參數。
      Course 4 Play Lab Vars 2_authored_hint:
        Course_4_Play_Lab_Vars_2_a: 確定在 `dog_speed`（小狗的速度）上設定的數值要大於 `cat_speed`（小貓的速度）。
      Course 4 Play Labs For Loops 2_authored_hint:
        Course_4_Play_Labs_For_Loops_2_a: 在`計數`迴圈上每次要加多少，才可以跳過偶數？
      Course 4 Playlab For Loop Freeplay_authored_hint: [ ]
      Course 4 Playlab For Loops 4b_authored_hint:
        Course_4_Playlab_For_Loops_4b_a: 這個旗子離角色大概有 330 像素遠。
        Course_4_Playlab_For_Loops_4b_b: 在計數的起始數值和結束數值不同的情況下，你要怎麼樣才能讓每個角色都能移動 330 像素？
        Course_4_Playlab_For_Loops_4b_c: 記住，不管角色的最後一步移動距離多大，只要他能通過旗子就可以了。
      Course 4 Playlab For Loops 5b_authored_hint:
        Course_4_Playlab_For_Loops_5b_a: 這個角色離中心點大概有 175 像素遠。
        Course_4_Playlab_For_Loops_5b_b: 記住，一個角色的下個執行動作的時間，會比上一個還要長，因為 counter 會變得愈來愈大。
      Course 4 Playlab For Loops 6b_authored_hint: [ ]
      Course 4 SCF 1_authored_hint:
        Course_4_SCF_1_a: 每個六邊形的邊長都是 40 像素。
        Course_4_SCF_1_b: 每個六邊形之間的水平距離是 120 像素。
        Course_4_SCF_1_c: "在你畫出第二排的六邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 320 像素。"
        Course_4_SCF_1_d: "在你畫出第三排的多邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 440 像素（比你的函式 `shift down/forward` 還要多 120 像素）。 "
        Course_4_SCF_1_e: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/d64a0e22c1db1d98c35b243bca6460ab-image-1469727090121.png)
      Course 4 SCF 1a_authored_hint:
        Course_4_SCF_1a_a: 別忘了你在階段 16 建立過的函式。
        Course_4_SCF_1a_b: "觀察這個路徑，作為你的主要路線：\n\n![](https://images.code.org/1c3feab70af706409b3a05af4dc83c2e-image-1469726967858.png)"
        Course_4_SCF_1a_c: 請考慮使用一個`計數迴圈`，不是用在指令步驟，而是要用在函式的參數上。
        Course_4_SCF_1a_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/aa5a636a1d072e1449b481973ff27337-image-1469727008929.png)
      Course 4 SCF 1b_authored_hint:
        Course_4_SCF_1b_a: "注意，所有花蜜收集點的形狀是相同的 。\n\n這樣很適合使用函式！"
        Course_4_SCF_1b_b: "看看可行的移動方式：\n\n![](https://images.code.org/996ab4a2de6048cbb99b84c56cc4ad61-image-1469726859769.png)"
        Course_4_SCF_1b_c: 你應該思考一下如何使用一個`計數迴圈`來作為蜜蜂的移動依據。
        Course_4_SCF_1b_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/15ef56cd19a1efd510527345f077d6eb-image-1469726894398.png)
      Course 4 SCF 2_authored_hint:
        Course_4_SCF_2_a: 每個八邊形的邊長都是 40 像素。
        Course_4_SCF_2_b: 每個八邊形之間的水平距離是 136 像素。
        Course_4_SCF_2_c: "在你畫出第二排的八邊形之前，你需要向右轉 45 度，然後向前跳 96 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 408 像素。 "
        Course_4_SCF_2_d: "注意，因為在偶數列上的八邊形比較少，所以你不必再跳回奇數列的起始點。\n\n這表示你可以在所有橫列上使用相同的函式。"
        Course_4_SCF_2_e: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/de5a99b0fb4c079504ff7cca9a249f02-image-1469727175091.png)
      Course 4 SCF 3_authored_hint:
        Course_4_SCF_3_a: "![](https://images.code.org/9310e6352e85a8265b424c9d57ca28d1-image-1446239776339.gif)"
        Course_4_SCF_3_b: '這是一系列的八邊形，計數 `counter` 使用了 `sides` ，並當作每個形狀的邊長。 '
        Course_4_SCF_3_c: '每個八邊形都是由每次的循環構成，迴圈的計數方式是從 200 算到 2，間隔數是 2。 '
        Course_4_SCF_3_d: '別忘了在每個循環之後轉向 22.5 度。 '
        Course_4_SCF_3_e: 每個八邊形的顏色還有線條的寬度是利用 `counter` 變數來控制的。
        Course_4_SCF_3_f: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/a82cfea836b95ce6625b08afcc3b7b37-image-1469727289590.png)
      Course 4 SCFL 1_authored_hint:
        Course_4_SCFL_1_a: "看看可用的移動方式：\n\n![](https://images.code.org/07fa7bdbbaaae3ecf2663a360b3e87d7-image-1469726373660.png)"
        Course_4_SCFL_1_b: 試著使用 2 個`計數`迴圈：一個用來往上爬然後採集花蜜，另一個則是往下爬然後釀造蜂蜜。
        Course_4_SCFL_1_c: "注意一個`計數`迴圈裡頭需要數個規律的重複積木，以重複 `counter` 次來製作出樓梯的模式。\n\n其它的`計數`迴圈只需要一個普通的重複積木以收集到 `counter` 個蜂蜜。"
        Course_4_SCFL_1_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/1a61eae7e12742c8d850f2bf7e939f72-image-1469726415313.png)
      Course 4 SCFL 1a_authored_hint:
        Course_4_SCFL_1a_a: 盡可以減少積木的使用量，路還長得很呢！
        Course_4_SCFL_1a_b: "看看可用的移動方式：\n\n![](https://images.code.org/253d710ff7d1b494fe8fd20cfc92baaf-image-1469726263579.png)"
        Course_4_SCFL_1a_c: 一個`計數迴圈`能幫你執行一些相同模式的程式，但每次執行又可以有一些變化，注意變化的數字需要從 7 算到 5，間隔數是 1。
        Course_4_SCFL_1a_d: "**解決方案：**\n\n![Solution Blocks\\t](https://images.code.org/8742b441717ee3ab7cbc91d84f688dbb-image-1469726297064.png)"
      Course 4 SCFL 1b_authored_hint:
        Course_4_SCFL_1b_a: 試著使用一個`計數迴圈`。
        Course_4_SCFL_1b_b: "看看可用的移動方式：\n\n![](https://images.code.org/1957633c453f4025a3fd6ce0e201398b-image-1469642319721.png)"
        Course_4_SCFL_1b_c: |-
          **解決方案：**
          
          ![](https://images.code.org/349a0baf93e00a679cf7ed348f8309b4-image-1469642354856.png)
      Course 4 SCFL 2_authored_hint:
        Course_4_SCFL_2_a: "看看可用的移動方式：\n\n![](https://images.code.org/a69c63a039031254097f19231dd7bf95-image-1469726483169.png)"
        Course_4_SCFL_2_b: 注意，在`計數`迴圈中，每次的循環結束時都會有個停止的點，總共會有 3 個點。
        Course_4_SCFL_2_c: 在`計數`迴圈中，每一次的循環期間，每個物件的數字都會和 `counter` 變數有關。
        Course_4_SCFL_2_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/df47aa475c36d0c1664c2fdb16b5613c-image-1469726516185.png)
      Course 4 SCFL 3_authored_hint:
        Course_4_SCFL_3_a: '`pen width`（筆跡寬度）是 1。而第一個正方形的邊長是 50 像素，每個正方形之間的邊長差了 50 像素。'
        Course_4_SCFL_3_b: 筆刷的透明度固定都是 `counter`/2。
        Course_4_SCFL_3_c: 在你畫出一個正方形後，別忘了跳回去，轉向，再跳一次，再轉回去！
        Course_4_SCFL_3_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/7f14ddfa5cdcbfdfacd8b1e45511d583-image-1469726581880.png)
      Course 4 SCFL 4_authored_hint:
        Course_4_SCFL_4_a: 使用`設定顏色`積木，可以讓顏色改變，使用的是 RGB 顏色代碼。R（Red，紅）的值為 `counter`、G（Green，綠）的值為 `255 - counter`、B（Blue，藍）的值則固定為 255。
        Course_4_SCFL_4_b: 每個正方形的邊長為 `counter` 像素，從 5px 開始算到 200px，每次增加 5px。
        Course_4_SCFL_4_c: 小藝術家在每次畫出正万形後轉向 15 度。
        Course_4_SCFL_4_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/b85604648076fa7adfc7a30be41d13fa-image-1469726651617.png)
      Course 4 SCFL 6_authored_hint:
        Course_4_SCFL_6_a: 使用`設定顏色`積木，可以讓顏色改變，使用的是 Rgb 顏色代碼。R（Red，紅）的值固定為 255、G（Green，綠）的值為 `counter`、B（Blue，藍）的值為 `255 - counter`。
        Course_4_SCFL_6_b: 這個程式並沒有你想的這麼複雜，只需要設定好`計數迴圈`裡頭的顏色部分，然後向前移動，最後轉向。
        Course_4_SCFL_6_c: '這個`計數迴圈`是從 5 算到 250，間隔數是 2。 '
        Course_4_SCFL_6_d: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/a61c16d76d876d9c26ebcaebef3f97a2-image-1469726730055.png)
      Course 4 SCFL 7_authored_hint:
        Course_4_SCFL_7_a: 使用`設定顏色`積木，可以讓顏色改變，使用的是 Rgb 顏色代碼。R（Red，紅）的值為 `counter`、G（Green，綠）的值為 `255 - counter`、B（Blue，藍）的值則固定為 255。
        Course_4_SCFL_7_b: '這個圖案是用兩個類似的`計數迴圈`畫出來的。一個是從 5 算到 200，間隔數是 2；另一個則是從 200 算到 5，間隔數是 2。 '
        Course_4_SCFL_7_c: 在每個`計數迴圈`裡，你要在轉向 `360 / counter` 之前向前移動 5 像素。在運行前別忘了筆刷的寬度要設成 `counter`。
        Course_4_SCFL_7_d: 你需要在兩個`計數迴圈`之間向左轉 225 度。
        Course_4_SCFL_7_e: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/96adbffef5520417927b6129875e6125-image-1469726787490.png)
      Course 4 SCV 1_authored_hint:
        Course_4_SCV_1_a: '變數非常有用，因為你每循環一次就可以加一個數值上去。 '
        Course_4_SCV_1_b: 這個關卡有個畫出多邊形的迴圈，一個用來重複多邊形 `sides` 次，另一個在 `sides` 加上 5 以後再做一次。
        Course_4_SCV_1_c: 使用變數，`sides` 代表邊數，`length` 代表長度，用它們可以編寫出簡潔的程式，因為我們可以透過迴圈來執行相同的程式多次，這樣一來，模式相同但數字不同的程式就不需要編寫好多次。
        Course_4_SCV_1_d: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/311b4a946cb8f3b4144b5075be6460a3-image-1469641878222.png)
      Course 4 SCV 2_authored_hint:
        Course_4_SCV_2_a: "這個圖形是用 10 個這樣的「花朵」畫出來的：\n![](https://images.code.org/bac2a606dfa59c00409294499540267d-image-1469641972385.png)\n\n而「花朵」則是用 10 個這樣的「花瓣」畫出來的：\n![](https://images.code.org/1e15f278c9c1606f90a2490ec3a94eb4-image-1469642051512.png)"
        Course_4_SCV_2_b: '這個圖案使用了巢狀迴圈（三層）。所有的迴圈執行了 `sides` 次（sides 是個變數名稱，是邊數的意思）。 '
        Course_4_SCV_2_c: 小藝術家每畫出一個「花瓣」後就向左轉，但在另一個迴圈時又向右轉。
        Course_4_SCV_2_d: 如果要避免你的 10 個花都畫在同一個位置上，請在你轉向 360/`sides` 度之前向前跳，跳的距離為 360/`sides` 像素。
        Course_4_SCV_2_e: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/889fda43ab85f9972fdabe5bb968ff95-image-1469642093490.png)
      Course 4 SCV 3_authored_hint:
        Course_4_SCV_3_a: '在角色撞在一起時，使用運算積木來為 `points` 變數加分或是減分。 '
        Course_4_SCV_3_b: 在每次方向鍵點擊時，你可以將參數改成角色移動的距離。
        Course_4_SCV_3_c: |-
          **解決方案：**
          
          ![solution](https://images.code.org/8d4bcfb29308eabff39500ad9db813fd-image-1469641570287.png)
      Course 4 SCV 4_authored_hint:
        Course_4_SCV_4_a: 用 3 個變數來幫你解決。一個用來代表花蜜數、一個代表蜂蜜數、一個代表蜜蜂移動格數。
        Course_4_SCV_4_b: '在你的主迴圈裡頭再加上 3 個迴圈，程式就會變得很猛了。這 3 個迴圈中，一個用來向前移動、一個收集花蜜、一個收集蜂蜜。 '
        Course_4_SCV_4_c: "看看可用的移動方式：\n\n![](https://images.code.org/78f8fb83da67c5b80126555a362b8b20-image-1469641782259.png)"
        Course_4_SCV_4_d: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/c57fc9df2e24b1f8497b7e4ca9e1f568-image-1469641818826.png)
      Course 4 SCV 5_authored_hint:
        Course_4_SCV_5_a: |-
          看看可用的移動方式：
          
          ![](https://images.code.org/7f6f09c55cf9552a91fc1d33f44a7315-image-1469641639330.png)
        Course_4_SCV_5_b: 每次進入迴圈時，花會少兩份花蜜且蜜蜂要多做一份花蜜
        Course_4_SCV_5_c: 注意迴圈之外的開頭之處，蜜蜂移動的次數要和下一朵有花蜜的花的格數一樣。
        Course_4_SCV_5_d: |-
          **解決方案：**
          
          ![Image of Solution](https://images.code.org/831d8675f6551d79b212da594a9a73f0-image-1469641703833.png)
      Course 4 SCV 6_authored_hint:
        Course_4_SCV_6_a: |-
          看看怎樣用單個積木來完成圖形：.
          
          ![](https://images.code.org/9e30d3a87186cefe730984feee195806-image-1469642178866.png)
        Course_4_SCV_6_b: 用變數來處理會非常的有效率，你可以設定 8 個變數： red1, green1, blue1, red2, green2, blue2, length, sides。
        Course_4_SCV_6_c: 每個形狀的五個邊被分成`length`/`sides`，向左曲折的是青藍色 (rgb = 0,175,200) 以及向右曲折的是紫色 (rgb = 100, 50, 150)。
        Course_4_SCV_6_d: '要向左曲折的話，向左轉`360`/`sides`。要向右曲折的話，向右轉`360`/`sides`。'
        Course_4_SCV_6_e: '程式的其它部分很基礎，就是要在一個形狀上製作出一個 360 的迴轉，不同之處在於我們將這些形狀重疊一半，所以我們要向右轉 180 ÷ sides（邊數）度，意思是我們必須要比平常還要多 2 倍（sides*2 重複） '
        Course_4_SCV_6_f: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/72f0ce970999deffe87bd93af0db959f-image-1469642214408.png)
      Farmer for Authored Hint testing_authored_hint:
        first_hint: |-
          這是第一個提示。
          
          它有*某種* **基本的** `標記`
        second_hint: |-
          這是第二個提示，我們用圖來說明。
          
          ![](https://images.code.org/cab43107265a683a6216e18faab2353f-image-1452027548372.png)
        last_hint: 這是第三個提示，也是最後的提示了。它沒有什麼特別的東西。
      Farmer for TTS testing_authored_hint:
        first_hint: |-
          這是第一個提示。
          
          它有*某種* **基本的** `標記`
        second_hint: |-
          這是第二個提示，我們用圖來說明。
          
          ![](https://images.code.org/cab43107265a683a6216e18faab2353f-image-1452027548372.png)
        last_hint: 這是第三個提示，也是最後的提示了。它沒有什麼特別的東西。
      Harvesting_authored_hint:
        pointer_harvester_test: 哪種積木可以幫助我判斷（檢查還有做決定）？
      Inspirational Artwork_authored_hint:
        brush_width: 在我們開始前，先將筆刷的寬度設為 1，顏色設為藍色。
        double_loop: 試著放置一個`計數迴圈`到`重複`積木裡頭。
        specifics: "畫出 6 個「花瓣」的這個`計數迴圈`，每一次都會從 3 開始執行到 17，而畫出的形狀的邊數都會是奇數。\n\n`設置透明度`的積木中用了計數器，當計數器的值愈高時，顏色會變得愈淡。"
        after: 當你完成每個「花瓣」時，請檢查是否在你轉彎 60 度之前`移動-向前`了 20 像素。
        solution: |-
          **解決方案：**
          
          
          ![Image of Solution Blocks](https://images.code.org/d85a18bd31a09f87b41a818fc8d6c1cc-image-1469641375258.png)
      InspirationalArtwork_authored_hint: [ ]
      K2.0 sequence 1_authored_hint:
        K2.0_sequence_1_a: This program is missing one block. Can you figure out which one?
      K2.0 sequence 10_authored_hint:
        K2.0_sequence_10_a: If you're having trouble, try writing down the steps on a piece of paper first.
        K2.0_sequence_10_b: You will need three different kinds of arrows to solve this puzzle.
      K2.0 sequence 12_authored_hint:
        K2.0_sequence_12_a: If the pig isn't moving far enough, try adding another block.
      K2.0 sequence 2_authored_hint:
        K2.0_sequence_2_a: One of the blocks is moving the bird in the wrong direction. Can you figure out which one and replace it with the correct block?
      K2.0 sequence 3_authored_hint:
        K2.0_sequence_3_a: If you are having trouble, try to figure out what the correct path is and then remove the block that doesn't fit.
      K2.0 sequence 4_authored_hint:
        K2.0_sequence_4_a: Use 2 different arrow blocks to solve this puzzle!
      K2.0 sequence 5_authored_hint:
        K2.0_sequence_5: Your final code should have three movement blocks.
      K2.0 sequence 6_authored_hint:
        K2.0_sequence_6_a: There is 1 block that you need to add to move the bird to the pig.
        K2.0_sequence_6_b: If you can't figure out what to do, try drawing the puzzle on paper and use your finger to figure out which way to move.
      K2.0 sequence 7_authored_hint:
        K2.0_sequence_7_a: If you're stuck, try drawing the image on paper to see how the bird should move.
      K2.0 sequence 8_authored_hint:
        K2.0_sequence_8_a: Stuck? Try tracing the bird's path with your finger.
      K2.0 sequence 9_authored_hint:
        K2.0_sequence_9_a: If you're having trouble, try writing down the steps on a piece of paper first.
        K2.0_sequence_9_b: You will need to go three different directions to solve this puzzle.
      K2.0 sequence FP_authored_hint:
        K2.0_sequence_FP_a: If the path you need is unclear, use your finger to trace your way from the bird to the pig.
      K2.0 sequence pre_authored_hint:
        K2.0_sequence_pre_a: If you are having trouble getting the bird to move, make sure blocks are connected under `when run`.
      MikeStar_authored_hint:
        hint1: Don't give up!
      MikeStarHard_authored_hint:
        hint1: Don't give up!
      MikeStarNested_authored_hint:
        hint1: Don't give up!
      NEW Course 4 Artist Functions 13_authored_hint:
        NEW_Course_4_Artist_Functions_13_a: 試試修改 `draw a line of squares`（畫出方格邊）函式，這樣一來，你就不必呼叫它兩次。
        NEW_Course_4_Artist_Functions_13_c: 如果你要製作一個有規律線條的星星圖像，要編寫怎樣的程式碼呢？
      NEW Course 4 Artist Functions 4_authored_hint:
        NEW_Course_4_Artist_Functions_4_a: 你必須在畫出每個正方形之後使用 `轉向-右方 120 度`積木。
      NEW Course 4 Artist Functions 9_authored_hint:
        NEW_Course_4_Artist_Functions_9_a: 在你開始添加積木前，運行這個程式看看。是什麼地方讓圖案不大對勁？
        NEW_Course_4_Artist_Functions_9_b: 如果你不能明確的指出錯誤的地方，試著把滑桿往左調，讓程式的運行速度變慢。
      NEW Course 4 Artist Params 11_authored_hint:
        NEW_Course_4_Artist_Params_11_a: 只需要把函式裡頭的數字換成一個變數就可以了。
      NEW Course 4 Artist Params 13_authored_hint:
        NEW_Course_4_Artist_Params_13_a: '用 perimeter 除以 sides（周長除以邊數）的方式，就可以讓每個形狀都能有相同的尺寸。 '
      NEW Course 4 Artist Params 14_authored_hint:
        NEW_Course_4_Artist_Params_14_a: It's okay to run the program a few times to figure out how the function works with different parameters.
      NEW Course 4 Artist Params inspire_authored_hint:
        brush_width: 在我們開始前，先將筆刷的寬度設為 1，顏色設為藍色。
        double_loop: 試著放置一個`計數迴圈`到`重複`積木裡頭。
        specifics: "畫出 6 個「花瓣」的這個`計數迴圈`，每一次都會從 3 開始執行到 17，而畫出的形狀的邊數都會是奇數。\n\n`設置透明度`的積木中用了計數器，當計數器的值愈高時，顏色會變得愈淡。"
        after: 當你完成每個「花瓣」時，請檢查是否在你轉彎 60 度之前`移動-向前`了 20 像素。
        solution: |-
          **解決方案：**
          
          
          ![Image of Solution Blocks](https://images.code.org/d85a18bd31a09f87b41a818fc8d6c1cc-image-1469641375258.png)
      NEW Course 4 Bee For Loops 10a_authored_hint:
        NEW_Course_4_Bee_For_Loops_10a_a: Can you find a pattern between the number of steps you need to take and the number of nectars to gather?
        NEW_Course_4_Bee_For_Loops_10a_b: You'll need to have 2 repeats, one will use a math block.
      NEW Course 4 Bee For Loops 7_authored_hint:
        NEW_Course_4_Bee_For_Loops_7_a: |-
          Try doing some math with the counter variable.
          
          What do you have to do to the counter at each flower to equal the amount of nectar you need to collect?
      NEW Course 4 Bee For Loops 8_authored_hint:
        NEW_Course_4_Bee_For_Loops_8_a: "如果循環的數字是由小排到大，每次循環就會從計數器變量中加上間隔的值。\n\n如果要依序收集花蜜，間隔數需要設成多少？"
      Pattern Bee 1_authored_hint:
        conditional_pointer: |-
          先思考一下這個：每個步驟之間有什麼不同處？哪種積木可以幫你*判斷*你是在花朵還是在蜂窩上？
          
          ![](https://images.code.org/a4883ea91c2f879ca1bb281d7944ed87-image-1471477752512.48.07 PM.png)
        turn_at_honeycomb_pointer: 除了釀造蜂蜜，你看得出來在每個蜂窩上還要做些什麼嗎？
      Planning Farmer_authored_hint:
        conditional_pointer: |-
          先思考一下這個：每個步驟之間有什麼不同處？哪種積木可以幫你*判斷*你是在花朵還是在蜂窩上？
          
          ![](https://images.code.org/a4883ea91c2f879ca1bb281d7944ed87-image-1471477752512.48.07 PM.png)
        turn_at_honeycomb_pointer: 除了釀造蜂蜜，你看得出來在每個蜂窩上還要做些什麼嗎？
      Quantum Bee - Ryan_authored_hint:
        test_hint: 這是測試用提示。
      aE1_authored_hint: [ ]
      aE2_authored_hint:
        aE2_a: 注意，由於餐巾是 20 像素長，你需要跳躍 20 像素，在你開始你的下一個迴圈之前。
      aE3_authored_hint:
        aE3_a: 在運行你在上個關卡做的**巢狀迴圈**之後，你需要往後跳回起始處。
        aE3_b: "別忘了在你開始畫一列形狀前，先讓小藝術家向下移動！\n\n移動小藝術家，並讓他面對正確的方向：\n- 轉向 90 度（讓他面朝下）\n- 跳躍 20 像素（讓他到新的一列）\n- 轉回 90 度（讓他再次面朝右）"
        aE3_c: 當你都做完了，你的**巢狀迴圈**應該會有三層深。
        aE3_d: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      aE3alternate_authored_hint:
        aE3alternate_a: 在運行你在上個關卡做的**巢狀迴圈**之後，你需要往後跳回起始處。
        aE3alternate_b: "別忘了在你開始畫一列形狀前，先讓小藝術家向下移動！\n\n移動小藝術家，並讓他面對正確的方向：\n- 轉向 90 度（讓他面朝下）\n- 跳躍 20 像素（讓他到新的一列）\n- 轉回 90 度（讓他再次面朝右）"
        aE3alternate_c: 當你都做完了，你的**巢狀迴圈**應該會有三層深。
        aE3alternate_d: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      aE3alternateB_authored_hint:
        aE4alternateB_a: 在運行你在上個關卡做的**巢狀迴圈**之後，你需要往後跳回起始處。
        aE4alternateB_b: "別忘了在你開始畫一列形狀前，先讓小藝術家向下移動！\n\n移動小藝術家，並讓他面對正確的方向：\n- 轉向 90 度（讓他面朝下）\n- 跳躍 20 像素（讓他到新的一列）\n- 轉回 90 度（讓他再次面朝右）"
        aE4alternateB_c: 當你都做完了，你的**巢狀迴圈**應該會有三層深。
        aE4alternateB_d: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      aE4_authored_hint:
        aE4_a: 在運行你在上個關卡做的**巢狀迴圈**之後，你需要往後跳回起始處。
        aE4_b: "別忘了在你開始畫一列形狀前，先讓小藝術家向下移動！\n\n移動小藝術家，並讓他面對正確的方向：\n- 轉向 90 度（讓他面朝下）\n- 跳躍 20 像素（讓他到新的一列）\n- 轉回 90 度（讓他再次面朝右）"
        aE4_c: 當你都做完了，你的**巢狀迴圈**應該會有三層深。
        aE4_d: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      aE5_authored_hint: [ ]
      aE6_authored_hint:
        aE6_a: |-
          如果有個 180 度角的半圓形，每次循環小藝術家會轉 3 度，你需要循環幾次（轉多少次）才能畫出一個半圓？
          
          **180 ÷ 3 = ?**
      aE7_authored_hint:
        aE7_a: 畫出這個半圓的下半部，然後再畫出上半部，就可以製造出分割的圖形。
        aE7_b: 你需要 4 個來完成這個關卡。
      aE8_authored_hint:
        aE8_a: "要製作出一個正方形，你需要：\n- 畫出線條\n\n- 使用轉向來轉彎\n\n重複這些步驟 4 次。"
      artistDebugVideo1_authored_hint:
        courseA_artist_loops7_a: Can't figure out where to put the loop? Try writing the code step-by-step and look for a pattern.
      artistFunctionsVideo1_authored_hint: [ ]
      artistLoopsK2_authored_hint:
        artistLoopsK2_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      artistLoopsK2gradek_artist_loops3_authored_hint:
        artistLoopsK2_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      artistLoopsK3_authored_hint:
        artistLoopsK3_a: 試著用你學到的重複積木來完成這個關卡！
      artistLoopsK4_authored_hint:
        artistLoopsK4_a: 卡關了嗎？試試運行程式，看看哪個積木不正確。
      artistLoopsK5_authored_hint:
        artistLoopsK5_a: 開始的 4 個積木應該放到重複積木裡頭，這樣就可以完成關卡了。
      artistLoopsK6_authored_hint:
        artistLoopsK6_a: 試著運行它，看看哪裡有 bug。
      artistLoopsK7_authored_hint:
        artistLoopsK7_a: 要完成這個關卡所需要的積木通通都在工作區裡了！
      artistLoopsK8_authored_hint:
        artistLoopsK8_a: 試著運行它，看看哪裡有 bug。
      artistLoopsK9_authored_hint:
        artistLoopsK9_a: 這個挑戰用了 4 個迴圈，一個接著一個！
      artistLoopsKA_authored_hint:
        artistLoopsKA_a: 使用跳躍積木可以向前移動但不會畫線。
      artistLoopsKB_authored_hint:
        artistLoopsKB_a: 要完成關卡的話，你的迴圈裡應該要有 3 個積木。
      artistLoopsKFP_authored_hint: [ ]
      courseA_artist_loops10_authored_hint:
        courseA_artist_loops10_a: 使用跳躍積木可以向前移動但不會畫線。
      courseA_artist_loops11_authored_hint:
        courseA_artist_loops11_a: There should be 2 blocks inside of your loop to solve this puzzle.
      courseA_artist_loops11_predict2_authored_hint: [ ]
      courseA_artist_loops12_authored_hint: [ ]
      courseA_artist_loops2_authored_hint:
        courseA_artist_loops2_a: Can't figure out how to draw a line?  Start attaching blocks to the `when run` block to see what happens.
      courseA_artist_loops3_authored_hint:
        courseA_artist_loops3_a: Is something not quite right?  Trace slowly through the program with your finger to see where it goes wrong.
      courseA_artist_loops4_authored_hint:
        courseA_artist_loops4_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      courseA_artist_loops5_authored_hint:
        courseA_artist_loops5_a: 試著用你學到的重複積木來完成這個關卡！
      courseA_artist_loops6_authored_hint:
        courseA_artist_loops6_a: Can't figure out how to make the hill?  Try playing with the blocks a bit to see what each one draws.
      courseA_artist_loops7_authored_hint:
        courseA_artist_loops7_a: Can't figure out where to put the loop? Try writing the code step-by-step and look for a pattern.
      courseA_artist_loops8_authored_hint:
        courseA_artist_loops8_a: Try running the code to see what has been written for you.
        courseA_artist_loops8_b: How would you loop the code that has been given to you?
        courseA_artist_loops8_c: "What does the code do?  \nWhat is it supposed to do?  \nWhat does that tell you?"
      courseA_artist_loops9_authored_hint:
        courseA_artist_loops9_a: Add another block to the code you are given to draw the rest of the stairs.
      courseA_artist_loops_challenge1_authored_hint:
        courseA_artist_loops_challenge1_a: |+
          你可以使用像這樣的迴圈來創建圍牆和屋頂。試試重複不同的積木。
          
          ![](https://images.code.org/1581a2f599b501103064fc9864aa964d-image-1491863694560.png)
          
          自行設計或是點擊 ![](https://images.code.org/53090194cea5dbf35ce9e35205156f5d-image-1491864793265.png) 以獲得更多靈感！
        courseA_artist_loops_challenge1_b: "![](https://images.code.org/34f3bae38f77f07eaf455188c0b008e5-image-1491864823946.png)"
        courseA_artist_loops_challenge1_c: "![](https://images.code.org/24b208839971803f3f6cd6ae41da56df-image-1491864839734.png)"
        courseA_artist_loops_challenge1_d: "![](https://images.code.org/d3ccefffa0cc77bdd4a597cdb49fc85e-image-1491864847347.png)"
      courseA_artist_loops_challenge2_authored_hint:
        courseA_artist_loops_challenge2_a: 像這樣的程式積木：<xml>  <block type="simple_move_up_left"/></xml> 可以讓小藝術家斜著移動！
        courseA_artist_loops_challenge2_b: 當你完成了一個鳥屋時，`跳躍`到下一個！
        courseA_artist_loops_challenge2_c: 這一關的迴圈裡用到了「很多」的程式積木喔。
      courseA_artist_loops_challenge3_authored_hint:
        harvey_tictactoe: 你可以利用 `跳躍` 積木移動到其它的空格。
      courseA_collector_loops10_authored_hint:
        courseA_collector_loops10_a: If you can't figure out where to put the loops, try writing the code out step-by-step and look for a pattern.
      courseA_collector_loops11_authored_hint:
        courseA_collector_loops11_a: If you can't figure out where to put the loops, try writing your code step-by-step and look for patterns.
      courseA_collector_loops11_predict2_authored_hint: [ ]
      courseA_collector_loops3_authored_hint:
        courseA_collector_loops3: Try using a `repeat` loop to do the job!
      courseA_collector_loops3_predict1_authored_hint: [ ]
      courseA_collector_loops4_authored_hint:
        courseA_collector_loops4_a: To change how far the adventurer goes, change the number of times that the loop runs.
        courseA_collector_loops4_b: Don't forget that the adventurer needs to walk down and collect the treasure after she finishes the `repeat` loop!
      courseA_collector_loops5_authored_hint:
        courseA_collector_loops5_a: If you can't figure out the answer right away, try using a piece of paper to figure out what arrows you will need and look for a pattern.
      courseA_collector_loops6_authored_hint:
        courseA_collector_loops6_a: Can't figure out what's wrong? Try running the code a couple of times to see what happens.
      courseA_collector_loops7_authored_hint:
        courseA_collector_loops7_a: If you can't figure out what comes next, try running the code to see where Laurel ends up.
      courseA_collector_loops8_authored_hint:
        courseA_collector_loops8_a: If you are having trouble figuring this puzzle out, try writing the moves down on a piece of paper and looking for a pattern.
      courseA_collector_loops9_authored_hint:
        courseA_collector_loops9_a: 'If you can''t spot the best places to use loops, try coding it out step-by-step and look for a pattern. '
        courseA_collector_loops9_b: Does the code feel really long?  Try putting two of your `repeat` loops inside of another loop to make it much shorter!
      courseA_collector_loops_challenge1_authored_hint:
        courseA_collector_loops_challenge1_a: 如果出錯了，可以試試修改每個迴圈裡的數值。
        courseA_collector_loops_challenge1_b: 如果你只要執行某段指令一次，就不需要用到迴圈。
        courseA_collector_loops_challenge1_c: 右邊的洞穴有 6 個寶石，而你只需移動並收集 5 次，你知道怎麼做嗎？
      courseA_collector_loops_challenge2_authored_hint:
        courseA_collector_loops_challenge2_b: |+
          只要一個 ![](https://images.code.org/803e9ee8b5bc9311a26edf955cd3c03f-image-1491001702274.07.34 PM.png) 積木就可以解決囉！
        courseA_collector_loops_challenge2_a: |-
          在往南移動之前，你可以重複移動到相同路徑。
          
          ![](https://images.code.org/88c28c76dbea70e20253083d22b5f5fd-image-1491001404225.01.21 PM.png)
      courseA_forVideoTest_artist_authored_hint: [ ]
      courseA_maze_seq1_authored_hint:
        courseA_maze_seq1_a: If you are having trouble getting the bird to move, make sure blocks are clicked in under the `when run` event.
        courseA_maze_seq1_b: |-
          The bird will need to move West three times to get to the pig.
          <xml>
          <block type="maze_moveWest"/>
          </xml>
      courseA_maze_seq10_authored_hint:
        courseA_maze_seq10_a: If you're having trouble, try writing down the steps on a piece of paper first.
        courseA_maze_seq10_b: You will need to go three different directions to solve this puzzle.
      courseA_maze_seq11_authored_hint:
        courseA_maze_seq11_a: Use 2 different arrow blocks to solve this puzzle!
      courseA_maze_seq12_authored_hint:
        courseA_maze_seq12_a: If the pig isn't moving far enough, try adding another block.
      courseA_maze_seq12_predict2_authored_hint: [ ]
      courseA_maze_seq13_authored_hint:
        courseA_maze_seq13_a: If the path you need is unclear, use your finger to trace your way from the bird to the pig.
      courseA_maze_seq2_authored_hint:
        courseA_maze_seq2_a: This program is missing one block. Can you figure out which one?
      courseA_maze_seq2_predict1_authored_hint: [ ]
      courseA_maze_seq3_authored_hint:
        courseA_maze_seq3_a: One of the blocks is moving the bird in the wrong direction. Can you figure out which one and replace it with the correct block?
      courseA_maze_seq4_authored_hint:
        courseA_maze_seq4_a: If you are having trouble, try to figure out what the correct path is and then remove the block that doesn't fit.
      courseA_maze_seq4a_authored_hint:
        courseA_maze_seq4_a: If you are having trouble, try using your finger to figure out the correct path by pointing it out on the map. What moves did your finger make?
      courseA_maze_seq5_authored_hint:
        courseA_maze_seq5_a: Try writing down the steps on paper to find a solution!
      courseA_maze_seq6_authored_hint:
        courseA_maze_seq6_a: Your final code should have three movement blocks.
      courseA_maze_seq7_authored_hint:
        courseA_maze_seq7_a: There is 1 block that you need to add to move the bird to the pig.
        courseA_maze_seq7_b: If you can't figure out what to do, try drawing the puzzle on paper and use your finger to figure out which way to move.
      courseA_maze_seq8_authored_hint:
        courseA_maze_seq8_a: If you're stuck, try drawing the image on paper to see how the bird should move.
      courseA_maze_seq9_authored_hint:
        courseA_maze_seq9_a: Stuck? Try tracing the bird's path with your finger.
      courseA_maze_seq_challenge1_authored_hint:
        courseA_maze_seq_challenge1_a: 路上可能會碰上 TNT 炸藥。
      courseA_maze_seq_challenge2_authored_hint:
        courseA_maze_seq_challenge2_a: 試著用你的手指頭點出要移動的空格數（你站的那一格不要算！）
      courseA_playLab_events2_authored_hint:
        courseA_playLab_events2_a: "Here is the block you should connect to the `when run` block: \n\n![](https://images.code.org/ae72d1270ad210cd00fae7e0dfb3549a-image-1478144412134.png)"
      courseA_playLab_events3_authored_hint:
        courseA_playLab_events3_a: 'drag this block out ![](https://images.code.org/b3d6215901969328333d6393f8101c5b-image-1478142333199.png) and connect it to ![](https://images.code.org/4f2130b2a3053695414a02c3d39ef864-image-1478143461271.png)'
      courseA_playLab_events4_authored_hint:
        courseA_playLab_events4_a: |-
          Here is the event block that you will need to get Jorge to move right:
          
          ![](https://images.code.org/cfc4b696b1ad5762ff40c1c8a17a194d-image-1478141370249.png)
        courseA_playLab_events4_b: |-
          Here is the block you should connect to the `when right` event:
          
          ![](https://images.code.org/e5c559cc1deef643c8b997d17ecb78e3-image-1478141726783.png)
      courseA_playLab_events5_authored_hint:
        courseA_playLab_events5_a: "Here are the event blocks that you will need to use to move Jorge up and down:\n\n![](https://images.code.org/cf9a6992f7b4619dfb592fb6905effbb-image-1478140906017.png)\nand \n![](https://images.code.org/bb2a117cef485e79119a63e5d027968e-image-1478140979742.png)"
        courseA_playLab_events5_b: |-
          你知道嗎？點擊積木，你就可以修改方向鍵囉！
          
          ![](https://images.code.org/b010b6a8131689af53b33148753c15b4-image-1492639642316.gif)
      courseA_playLab_events6_authored_hint:
        courseA_playLab_events6_a: |-
          Here is the event block that you would use to have Jorge do something when clicked:
          
          ![](https://images.code.org/6e3a654378643fd0590307ec3a0e429c-image-1478140058859.png)
        courseA_playLab_events6_b: |-
          Here is the block you would use to change the background:
          
          ![](https://images.code.org/3f6d7a642b37c3abffe7b0de062ea076-image-1478140261440.png)
        courseA_playLab_events6_c: |-
          Here is the block you would use to play a random sound:
          
          ![](https://images.code.org/81a8ef4f64023039438199fef67bb56b-image-1478140125332.png)
      courseA_playlab_challengeTemplate_authored_hint: [ ]
      courseA_playlab_events_challenge1_authored_hint:
        courseA_playlab_events_challenge1_a: "Make Waddles the Penguin show when you click Robin!\n<xml> \n\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">2</title>\n    <next>\n      <block type=\"studio_setSprite\">\n        <title name=\"VALUE\">\"visible\"</title>\n        <title name=\"SPRITE\">3</title>\n      </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge1_b: "Make Boo the Ghost show when you click Waddles!\n<xml> \n\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">3</title>\n    <next>\n      <block type=\"studio_setSprite\">\n        <title name=\"VALUE\">\"visible\"</title>\n        <title name=\"SPRITE\">4</title>\n      </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge1_c: "Make Jayden the Fuzzy Monster show when you click Boo!\n<xml> \n\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">4</title>\n    <next>\n      <block type=\"studio_setSprite\">\n        <title name=\"VALUE\">\"visible\"</title>\n        <title name=\"SPRITE\">5</title>\n      </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge1_d: "Make Spiff the Robot show when you click the monster!\n<xml> \n\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">5</title>\n    <next>\n      <block type=\"studio_setSprite\">\n        <title name=\"VALUE\">\"visible\"</title>\n        <title name=\"SPRITE\">6</title>\n      </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge1_e: "Finally, make Wendel the Wizard show when you click on Spiff!\n<xml> \n\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">6</title>\n    <next>\n      <block type=\"studio_setSprite\">\n        <title name=\"VALUE\">\"visible\"</title>\n        <title name=\"SPRITE\">7</title>\n      </block>\n    </next>\n  </block></xml>"
      courseA_playlab_events_challenge1a_authored_hint:
        courseA_playlab_events_challenge1_a: "You can make a bird sing.\n<xml> \n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">2</title>\n    <next>\n\n          <block type=\"studio_saySprite\">\n            <title name=\"SPRITE\">2</title>\n            <title name=\"TEXT\">Tweet</title>\n          </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge1_b: "You can make a robot beep.\n<xml>\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">6</title>\n    <next>\n      \n          <block type=\"studio_playSound\">\n            <title name=\"SOUND\">winpoint</title>\n          </block>\n        </next>\n\n  </block></xml>"
        courseA_playlab_events_challenge1_c: |-
          You can make an angry monster growl.
          
          <xml>  <block type="studio_whenSpriteClicked">
          <title name="SPRITE">5</title>
          <next>
          <block type="studio_setSpriteEmotion">
          <title name="SPRITE">5</title>
          <title name="VALUE">2</title>
          <next>
          <block type="studio_saySprite">
          <title name="SPRITE">5</title>
          <title name="TEXT">Roar!</title>
          <next>
          <block type="studio_setSpriteEmotion">
          <title name="SPRITE">5</title>
          <title name="VALUE">0</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block></xml>
      courseA_playlab_events_challenge2_authored_hint:
        courseA_playlab_events_challenge2_a: "You can make a bird sing.\n<xml> \n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">2</title>\n    <next>\n\n          <block type=\"studio_saySprite\">\n            <title name=\"SPRITE\">2</title>\n            <title name=\"TEXT\">Tweet</title>\n          </block>\n    </next>\n  </block></xml>"
        courseA_playlab_events_challenge2_b: "You can make a robot beep.\n<xml>\n  <block type=\"studio_whenSpriteClicked\">\n    <title name=\"SPRITE\">6</title>\n    <next>\n      \n          <block type=\"studio_playSound\">\n            <title name=\"SOUND\">winpoint</title>\n          </block>\n        </next>\n\n  </block></xml>"
        courseA_playlab_events_challenge2_c: |-
          You can make an angry monster growl.
          
          <xml>  <block type="studio_whenSpriteClicked">
          <title name="SPRITE">5</title>
          <next>
          <block type="studio_setSpriteEmotion">
          <title name="SPRITE">5</title>
          <title name="VALUE">2</title>
          <next>
          <block type="studio_saySprite">
          <title name="SPRITE">5</title>
          <title name="TEXT">Roar!</title>
          <next>
          <block type="studio_setSpriteEmotion">
          <title name="SPRITE">5</title>
          <title name="VALUE">0</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block></xml>
      courseA_toMakeLoopsVideo_Collector_authored_hint: [ ]
      courseB_artist_loops10_authored_hint: [ ]
      courseB_artist_loops2_authored_hint:
        courseB_artist_loops2_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      courseB_artist_loops3_authored_hint:
        courseB_artist_loops3_a: Remember to use a `repeat` loop for better code!
      courseB_artist_loops4_authored_hint:
        courseB_artist_loops4_a: The jump block lets you move forward without drawing a line.
      courseB_artist_loops5_authored_hint:
        courseB_artist_loops5_a: Drag out a `repeat` loop, then put the other blocks inside of it. How many times do you need to repeat?
      courseB_artist_loops6_authored_hint: [ ]
      courseB_artist_loops7_authored_hint:
        courseB_artist_loops7_a: 這個挑戰用了 4 個迴圈，一個接著一個！
        courseB_artist_loops7_b: |-
          Notice that every loop makes a stair pattern that travels in a different direction.
          
          ![](https://images.code.org/7d08d5514766c5c15074e90731991505-image-1466705649513.gif)
        courseB_artist_loops7_c: "The loops should do this:\n- Loop 1\n  - Right\n  - Down\n  \n- Loop 2\n  - Right\n  - Up\n\n- Loop 3\n  - Left\n  - Up\n\n- Loop 4\n  - Left\n  - Down"
      courseB_artist_loops8_authored_hint:
        courseB_artist_loops8_a: How many times should you repeat the pattern to make the ladder?
      courseB_artist_loops8_predict1_authored_hint: [ ]
      courseB_artist_loops9_authored_hint:
        courseB_artist_loops9_a: Remember that the jump blocks can be used to move forward without drawing a line.
      courseB_artist_loops_challenge1_authored_hint:
        courseB_artist_loops_challenge1_a: 像這樣的積木：<xml>  <block type="simple_move_up_right"/></xml> 能讓你的角色斜向移動！
        courseB_artist_loops_challenge1_b: 當你完成了一個骰子時，`跳躍`到下一個！
        courseB_artist_loops_challenge1_c: '你需要在同一行上使用`移動`或`跳躍`兩次。'
      courseB_artist_loops_challenge2_authored_hint:
        harvey_tictactoe: 你可以利用 `跳躍` 積木移動到其它的空格。
      courseB_collector_loops1_authored_hint:
        courseB_collector_loops1_a: The `get treasure` block can be used to pick up treasure once you have moved to it.
      courseB_collector_loops10_authored_hint:
        courseB_collector_loops10_a: 你需要使用 3 個`重複`迴圈才能完成這個關卡。
      courseB_collector_loops3_authored_hint:
        courseB_collector_prog3_a: Try using a `repeat` block to collect your treasure.
      courseB_collector_loops3_predict1_authored_hint:
        courseB_collector_prog3_a: Try using a `repeat` block to collect your gold.
      courseB_collector_loops4_authored_hint:
        courseB_collector_loops4_a: Is something not right? Try using the step button to figure out where things go wrong.
      courseB_collector_loops5_authored_hint:
        courseB_collector_loops5_a: Try using more than one loop to get the job done.
      courseB_collector_loops6_authored_hint:
        courseB_collector_loops6_a: Can't figure out where things start going wrong? Use the "Step" button to run through your program one block at a time.
        courseB_collector_loops6_b: You can change the number of times the repeat loop runs by clicking on the "3" and choosing a different number of repetitions.
      courseB_collector_loops7_authored_hint:
        courseB_collector_loops7_a: If you are having a hard time with the puzzle, try drawing it on paper to help you figure it out.
      courseB_collector_loops8_authored_hint:
        courseB_collector_loops8_challenge_a: 'If you can''t figure out where to put the repeat loops, program it out step-by-step and look for a pattern. '
        courseB_collector_loops8_challenge_b: Does the code feel a little long?  You can make it much shorter by moving two of your `repeat` loops inside of another loop.
      courseB_collector_loops9_authored_hint:
        courseB_collector_loops9_a: |
          Does this seem too hard?  Break it up into 3 little problems to make it feel easier.
      courseB_collector_loops_challenge1_authored_hint:
        courseB_collector_loops_challenge1_b: |
          只要一個 ![](https://images.code.org/803e9ee8b5bc9311a26edf955cd3c03f-image-1491001702274.07.34 PM.png) 積木就可以解決囉！
        courseB_collector_loops_challenge1_a: |
          The north pattern is a little different than the south pattern.
          <xml>
          <block type="collector_collect"/><next>
          <block type="maze_moveNorth"/></next>next>
          </xml>
        courseB_collector_loops_challenge1_c: "只要 8 個積木就可以搞定！你必須把`重複`積木放到另一個`積木`裡。點擊以取得更多提示。\n<xml>\n<block type=\"controls_repeat_simplified\">\n        <title name=\"TIMES\">?</title>\n        <statement name=\"DO\">\n          \n              <block type=\"controls_repeat_simplified\">\n                <title name=\"TIMES\">?</title>\n                <statement name=\"DO\">\n                </statement></block><next><block type=\"controls_repeat_simplified\">\n                <title name=\"TIMES\">?</title>\n                <statement name=\"DO\">\n                </statement></block></next></statement></block></xml>"
        courseB_collector_loops_challenge1_d: |-
          試試這個！
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat_simplified">
          <title name="TIMES">5</title>
          <statement name="DO">
          <block type="maze_moveSouth">
          <next>
          <block type="controls_repeat_simplified">
          <title name="TIMES">5</title>
          <statement name="DO">
          <block type="collector_collect">
          <next>
          <block type="maze_moveEast"/>
          </next>
          </block>
          </statement>
          <next>
          <block type="controls_repeat_simplified">
          <title name="TIMES">5</title>
          <statement name="DO">
          <block type="maze_moveWest"/>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </xml>
      courseB_collector_loops_challenge2_authored_hint:
        courseB_collector_loops_challenge2_a: 如果出錯了，可以試試修改每個迴圈裡的數值。
        courseB_collector_loops_challenge2_b: |-
          如果你錯過了寶藏，你需要移動回西邊一格。
        courseB_collector_loops_challenge2_c: 別忘了使用迴圈來收集最後一堆寶藏！
        courseB_collector_loops_challenge2_d: |-
          Try this solution:
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat_simplified_dropdown">
          <title name="TIMES" config="3-10">4</title>
          <statement name="DO">
          <block type="maze_moveEast">
          <next>
          <block type="collector_collect">
          <next>
          <block type="maze_moveWest">
          <next>
          <block type="maze_moveWest">
          <next>
          <block type="maze_moveSouth"/>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="controls_repeat_simplified_dropdown">
          <title name="TIMES" config="3-10">6</title>
          <statement name="DO">
          <block type="collector_collect"/>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseB_collector_loops_challenge`_authored_hint:
        courseA_collector_loops_challenge2_b: |+
          只要一個 ![](https://images.code.org/803e9ee8b5bc9311a26edf955cd3c03f-image-1491001702274.07.34 PM.png) 積木就可以解決囉！
        courseA_collector_loops_challenge2_a: |-
          在往南移動之前，你可以重複移動到相同路徑。
          
          ![](https://images.code.org/88c28c76dbea70e20253083d22b5f5fd-image-1491001404225.01.21 PM.png)
      courseB_collector_prog3_authored_hint:
        courseB_collector_prog3_a: Try using a `repeat` block to collect your gold.
      courseB_maze_seq1_authored_hint:
        courseB_maze_seq1_a: |-
          拖曳三個往`南`移動的積木，然後把它們連接到`當運行時`積木下，讓憤怒鳥可以抓到這頭豬。
          
          <xml><block type="when_run" deletable="false" movable="false"><next><block type="maze_moveSouth"><next><block type="maze_moveSouth"><next><block type="maze_moveSouth"></block></next></block></next></block></next></block></xml>
      courseB_maze_seq10_authored_hint:
        courseB_maze_seq10_a: If you're having trouble, try writing down the steps on a piece of paper first.
      courseB_maze_seq10_predict1_authored_hint: [ ]
      courseB_maze_seq11_authored_hint:
        courseB_maze_seq11_a: If you're having trouble, try writing down the steps on a piece of paper first.
      courseB_maze_seq1_predict1_authored_hint: [ ]
      courseB_maze_seq2_authored_hint:
        courseB_maze_seq2_a: This program is missing one block. Can you figure out which one?
      courseB_maze_seq3_authored_hint:
        courseB_maze_seq3_a: One of the blocks is moving the bird in the wrong direction. Can you figure out which one and replace it with the correct block?
      courseB_maze_seq4_authored_hint:
        courseB_maze_seq4_a: Try adding one instruction at a time until you get to the pig.
      courseB_maze_seq5_authored_hint:
        courseB_maze_seq5_a: If you get stuck, try drawing out the path on paper.
      courseB_maze_seq6_authored_hint:
        courseB_maze_seq6_a: Your final code should have three movement blocks.
      courseB_maze_seq7_authored_hint:
        courseB_maze_seq7_a: There is 1 block that you need to add to move the bird to the pig.
      courseB_maze_seq8_authored_hint:
        courseB_maze_seq8_a: If you're stuck, try adding one block at a time until you solve the puzzle.
      courseB_maze_seq9_authored_hint:
        courseB_maze_seq9_a: If you're having trouble, try writing down the steps on a piece of paper first.
      courseB_maze_seq9_challenge1_authored_hint: [ ]
      courseB_maze_seqCold_authored_hint:
        courseB_maze_seqCold_a: Stuck? Try tracing the bird's path with your finger.
        courseB_maze_seqCold_b: 'The extra blocks need to be added before the last ![](https://images.code.org/145dfc20c086bc8fc265de47f3cfe4b0-image-1467848177684.35.51 PM.png )'
      courseB_maze_seqOld_authored_hint:
        courseB_maze_seqOld_a: If you're having trouble, try writing down the steps on a piece of paper first.
      courseB_maze_seq_challenge1_authored_hint:
        courseB_maze_seq_challenge1_a: 這次最短的路徑不管用囉！
        courseB_maze_seq_challenge1_b: 試試先向西邊移動。
      courseB_maze_seq_challenge2_authored_hint:
        courseB_maze_seq_challenge2_a: 這個關卡不需要添加或是移除任何的積木。
        courseB_maze_seq_challenge2_b: 重新排列積木，走中間那條路。
      courseB_playlab_challenge1_Template_authored_hint: [ ]
      courseB_playlab_events2_authored_hint:
        courseB_playlab_events2_a: |-
          This is the block to have Daisy say something:
          
          ![](https://images.code.org/6d8944bb38eac46c02a601660e8a3562-image-1475625777800.02.48.png)
      courseB_playlab_events3_authored_hint:
        courseB_playlab_events3_a: |-
          This is the block you should use to add the event:
          
          ![](https://images.code.org/5ccb483d5a5ccc80692716728d7a0e6e-image-1475698549442.03.08.png)
        courseB_playlab_events3_b: |-
          This is the block you need to switch Daisy's mood:
          
          ![](https://images.code.org/209bad7062fa2821a7dcf000072ec7bf-image-1475698952158.22.11.png)
      courseB_playlab_events4_authored_hint:
        courseB_playlab_events4_a: |-
          This is the block that makes the knight move left.
          
          ![](https://images.code.org/f6b9c780dc6ff97bad485553e0aced26-image-1475692773359.38.51.png)
      courseB_playlab_events5_authored_hint:
        courseB_playlab_events5_a: "This is the event block that controls the right arrow: \n\n![](https://images.code.org/d14e2a6cdf78c4ae7d2010113ea8d321-image-1475695765628.29.00.png)"
        courseB_playlab_events5_b: "This is the block that makes the knight run away. \n\n![](https://images.code.org/2e4f0701a371a9932a37853294a170fe-image-1475695777801.29.09.png)"
      courseB_playlab_events6_authored_hint:
        courseB_playlab_events6_a: |-
          You will need these event blocks:
          
          ![](https://images.code.org/02dcc4efc752dfa4187d0b1268427100-image-1475707266348.40.55.png)
      courseB_playlab_events7_authored_hint:
        courseB_playlab_events7_a: |-
          This is the event block that you will need:
          
          ![](https://images.code.org/2ed42b3a3108c6affdfc866de57f2eec-image-1475624565390.42.18.png)
        courseB_playlab_events7_b: |-
          This is the block you need to play a sound.
          
          ![](https://images.code.org/58e9b9a146a4ca3a8eee25845110b805-image-1475624550269.42.00.png)
        courseB_playlab_events7_c: |-
          This is the block you need to make the knight vanish:
          
          ![](https://images.code.org/f468611cbe51e1cb35531334f625395a-image-1475624478204.41.02.png)
      courseB_playlab_eventsTemplate_authored_hint: [ ]
      courseB_playlab_eventsToolbox_authored_hint:
        courseB_playlab_events7_a: |-
          This is the event block that you will need:
          
          ![](https://images.code.org/2ed42b3a3108c6affdfc866de57f2eec-image-1475624565390.42.18.png)
        courseB_playlab_events7_b: |-
          This is the block you need to play a sound.
          
          ![](https://images.code.org/58e9b9a146a4ca3a8eee25845110b805-image-1475624550269.42.00.png)
        courseB_playlab_events7_c: |-
          This is the block you need to make the knight vanish:
          
          ![](https://images.code.org/f468611cbe51e1cb35531334f625395a-image-1475624478204.41.02.png)
      courseB_playlab_events_challenge1_authored_hint:
        courseB_playlab_events_challenge1_a: "使用`▼`讓其他的動物往下移動\n<xml>\n  <block type=\"studio_whenArrow\" movable=\"false\">\n    <title name=\"VALUE\">down</title>\n  </block>\n</xml>"
        courseB_playlab_events_challenge1_b: |
          利用這個程式積木改變動物的速度
          <xml>
          <block type="studio_setSpriteSpeed">
          <title name="SPRITE">0</title>
          <title name="VALUE">Studio.SpriteSpeed.NORMAL</title>
          </block></xml>
        courseB_playlab_events_challenge1_c: |-
          當比賽結束時，大家會說些什麼？讓牠們說些話吧：
          <xml>
          <block type="studio_whenSpriteClicked">
          <title name="SPRITE">2</title>
          <next>
          <block type="studio_saySpriteChoices">
          <title name="SPRITE">2</title>
          <title name="VALUE">Woo hoo!</title>
          </block>
          </next>
          </block>
          </xml>
      courseB_playlab_events_challenge2_authored_hint:
        courseB_playlab_events_challenge2_a: 遊戲中的動物在被觸碰後會消失，它們應該要在一或二秒之後再出現！
        courseB_playlab_events_challenge2_b: |-
          使用其他的事件類型積木來讓其他的動物消失！
          <xml>
          <block type="studio_whenSpriteClicked">
          <title name="SPRITE">1</title>
          </block>
          </xml>
        courseB_playlab_events_challenge2_c: |-
          當你點擊動物時，使用其他的指令來播放音樂或紀錄得分！
          <xml>
          <block type="studio_playSound">
          <title name="SOUND">slap</title>
          </block>
          <block type="studio_changeScore"/></xml>
        courseB_playlab_events_challenge2_d: |-
          改編一下！
          
          讓某些動物得到的分數比其他的動物還高。
          使用不同的音效。
          改變動物的表情！
      courseB_playlab_events_challenge2_embed_authored_hint:
        courseB_playlab_events_challenge2_a: 遊戲中的動物在被觸碰後會消失，它們應該要在一或二秒之後再出現！
        courseB_playlab_events_challenge2_b: |-
          使用其他的事件類型積木來讓其他的動物消失！
          <xml>
          <block type="studio_whenSpriteClicked">
          <title name="SPRITE">1</title>
          </block>
          </xml>
        courseB_playlab_events_challenge2_c: |-
          當你點擊動物時，使用其他的指令來播放音樂或紀錄得分！
          <xml>
          <block type="studio_playSound">
          <title name="SOUND">slap</title>
          </block>
          <block type="studio_changeScore"/></xml>
        courseB_playlab_events_challenge2_d: |-
          改編一下！
          
          讓某些動物得到的分數比其他的動物還高。
          使用不同的音效。
          改變動物的表情！
      courseB_playlab_events_challenge2_template_authored_hint:
        courseB_playlab_events_challenge2_a: 遊戲中的動物在被觸碰後會消失，它們應該要在一或二秒之後再出現！
        courseB_playlab_events_challenge2_b: |-
          使用其他的事件類型積木來讓其他的動物消失！
          <xml>
          <block type="studio_whenSpriteClicked">
          <title name="SPRITE">1</title>
          </block>
          </xml>
        courseB_playlab_events_challenge2_c: |-
          當你點擊動物時，使用其他的指令來播放音樂或紀錄得分！
          <xml>
          <block type="studio_playSound">
          <title name="SOUND">slap</title>
          </block>
          <block type="studio_changeScore"/></xml>
        courseB_playlab_events_challenge2_d: |-
          改編一下！
          
          讓某些動物得到的分數比其他的動物還高。
          使用不同的音效。
          改變動物的表情！
      courseB_starWars_prog10_authored_hint: [ ]
      courseB_starWars_prog11_authored_hint: [ ]
      courseB_starWars_prog8_authored_hint:
        courseB_starWars_prog8_a: 沒關係，走過的路可以再走。
        courseB_starWars_prog8_b: |-
          試試使用`重複`積木，看看在裡頭放些程式，會發生什麼事。
          
          <xml>
          <block type="controls_repeat_simplified">
          <title name="TIMES">3</title>
          </block>
          </xml>
      courseB_starWars_prog9_authored_hint: [ ]
      courseC_PlayLab_events3_authored_hint:
        courseC_PlayLab_events3_a: You only need to move Jorge to the right by about 25 pixels to solve this puzzle.
      courseC_PlayLab_events4_authored_hint:
        courseC_PlayLab_events4_b: Jorge needs to move right 100 pixels to reach the cat.
        courseC_PlayLab_events4_a: You will need to attach a block to the `when actor touches` event to solve this puzzle.
      courseC_PlayLab_events5_authored_hint:
        courseC_PlayLab_events5_a: You will need to click the dropdown menu in the `actor say` block to find the text "What's new?"
      courseC_PlayLab_events7_authored_hint:
        courseC_PlayLab_events7_a: 'Use both the `move actor 2 up 400 pixels` block and the `move actor 2 down 400 pixels` block inside the `repeat forever` loop to solve this puzzle. '
      courseC_PlayLab_events8_authored_hint:
        courseC_PlayLab_events8_a: You will need to connect blocks to the `when actor touches` block to make this happen correctly.
        courseC_PlayLab_events8_b: The `actor say` and `play sound` blocks in the toolbox should help you out!
      courseC_PlayLab_events9_authored_hint:
        courseC_PlayLab_events9_a: The `score point` block will help you to solve this puzzle.
      courseC_PlayLab_eventsA_authored_hint:
        courseC_PlayLab_eventsA_a: Use the `set background` block and the `set actor to a ____ speed` block to solve this puzzle.
      courseC_PlayLab_eventsFP_authored_hint:
        idea1: |-
          *Need an idea?*
          
          **Who's there?** Make characters appear with random images, so no one knows who's showing up next.
          
          ![](https://images.code.org/a56e03479801995d93ad5a4e4384a79e-image-1475340154498.gif)
        idea2: |-
          *Need an idea?*
          
          **Going on an Adventure** - Change the background, then have the characters talk about where they are now.
          
          ![](https://images.code.org/010c4d919f841d6049caf9211ab65ccc-image-1475340583052.gif)
        idea3: |-
          *Need an idea?*
          
          **Pinball** - Make one character move using the arrow keys (use `when up arrow`, `when down arrow` blocks), then play random sounds when it collides with other characters on the screen.
      courseC_PlayLab_events_challenge1_authored_hint:
        courseC_PlayLab_events_challenge_a: 試試當它碰到其他的角色時，使用`設置角色 1 到左中方`。這會將遊戲重置，玩家就可以繼續嘗試用其他的方法。
      courseC_PlayLab_events_challenge1_xy_blocks_authored_hint:
        courseC_PlayLab_events_challenge_a: 在積木上的這二個值可以讓你將角色在舞台間移動，你可以輸入 0 到 400 間的數字。
        courseC_PlayLab_events_challenge_b: |-
          You can decide which numbers to use, by thinking about how far over from the top left corner you'd like to move. The first number is the number of pixels from the left. The second number is the number of pixels from the top.
          <xml><block type="studio_setSpriteXY" inline="true">
          <value name="SPRITE">
          <block type="math_number" movable="false">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="XPOS">
          <block type="math_number" movable="false">
          <title name="NUM">37</title>
          </block>
          </value>
          <value name="YPOS">
          <block type="math_number" movable="false">
          <title name="NUM">187</title>
          </block>
          </value>
          </block></xml>
          ![](https://images.code.org/b1559bf476ceb59f880c43271c5e10b2-image-1494111787192.59.49 PM.png)
      courseC_artist_loops5_authored_hint:
        courseC_artist_loops5_a: |-
          試試使用`移至`積木，讓小藝術家返回中間位置：
          
          <xml>
          <block type="jump_to_xy">
          <title name="XPOS">100</title>
          <title name="YPOS">100</title>
          </block>
          </xml>
      courseC_artist_loops6_authored_hint:
        courseC_artist_loops6_a: |
          試試這朵三角形樣式的花朵：
          <img src="https://images.code.org/4248a974a7631c4240effba06fdee731-image-1495821015097.49.18.png" width="150px" />
          
          或是一隻小小小綠蟲：
          <img src="https://images.code.org/b9454d6f1159e19c58d9f5b5b37fd156-image-1495821067980.52.43.png" width="150px" />
      courseC_artist_prog1_authored_hint: [ ]
      courseC_artist_prog2_authored_hint:
        courseC_artist_prog2_a: 如果你使用`移動-向前 100 像素`這個積木，我就會向前移動並自動畫一條線啦。
        courseC_artist_prog2_b: 要如何才能轉彎？試試`轉向-右方 90 度`積木。
      courseC_artist_prog3_authored_hint:
        courseC_artist_prog3_a: |-
          To create this window, just draw a square with 100 pixel sides.
          
          - move forward
          - turn
          - move forward
          - turn
          - move forward
          - turn
          - move forward
      courseC_artist_prog4_authored_hint:
        courseC_artist_prog4_a: To finish the rocket, just draw the triangle on top!
      courseC_artist_prog5_authored_hint:
        courseC_artist_prog5_a: Use the "Step" button to run your code line by line to see where things go wrong.
      courseC_artist_prog6_authored_hint:
        courseC_artist_prog6_a: The artist is already facing the correct way to draw his first line.
        courseC_artist_prog6_b: This diamond is really just a square that's standing on its corner.
        courseC_artist_prog6_c: Since this diamond is also a square, be sure to turn 90 degrees at the corners.
      courseC_artist_prog6_predict1_authored_hint: [ ]
      courseC_artist_prog7_authored_hint:
        courseC_artist_prog7_a: Every angle is either 45 or 90 degrees.
        courseC_artist_prog7_b: "Does it work at the first step?  \nHow about the second?  \nWhere does it go wrong?"
      courseC_artist_prog8_authored_hint:
        courseC_artist_prog7_a: The exterior angles on this triangle are 120 degrees each.
      courseC_artist_prog_challenge1-doghouse_authored_hint:
        courseC_artist_prog7_a: 使用 60 度來做出這個屋頂。
      courseC_artist_prog_challenge1_authored_hint:
        courseC_artist_prog_challenge1_a: '這個矩形的寬是 200 像素，高是 100 像素。'
      courseC_artist_prog_challenge2_authored_hint:
        courseC_artist_prog_challenge2_a: "You can put commands inside `repeat` block to loop them over and over. Try it!\n<xml>\n  \n          <block type=\"controls_repeat\">\n            <title name=\"TIMES\">6</title>\n            <statement name=\"DO\">\n              <block type=\"draw_move_by_constant_dropdown\">\n                <title name=\"DIR\">moveForward</title>\n                <title name=\"VALUE\" config=\"25,50,100,150,200,300\">25</title>\n                <next>\n                  <block type=\"jump_by_constant_dropdown\">\n                    <title name=\"DIR\">jumpForward</title>\n                    <title name=\"VALUE\" config=\"25,50,100,150,200,300\">25</title>\n                  </block>\n                </next>\n              </block>\n              </statement></block></xml>"
      courseC_collector_loops_challenge2_authored_hint:
        courseC_maze_loops_challenge2_a: The original code would work great - if there was only one piece of treasure in each pile!
        courseC_maze_loops_challenge2_b: Use loops so you don't run out of `collect` blocks!
      courseC_collector_prog2_authored_hint:
        courseC_collector_prog2_a: You can use four `move forward` blocks or use the `repeat 4 times` block to make your program shorter.
      courseC_collector_prog3_authored_hint:
        courseC_collector_prog3_a: The program will only run the blocks that are connected to the `when run` block.
        courseC_collector_prog3_b: Try using the "Step" button to run your code one line at a time.  Do you see where the code goes wrong?
      courseC_collector_prog4_authored_hint:
        courseC_collector_prog4_a: If you get stuck, try writing out the steps on a piece of paper.
      courseC_collector_prog5_authored_hint:
        courseC_collector_prog5_a: "Where does this program go wrong?\n\n- Does it work at the first step?\n- Does it work at the second step? \n- Where do things go wrong?"
        courseC_collector_prog5_b: If you fixed one bug and the program still doesn't work, use the steps above to find more bugs.
      courseC_collector_prog6_authored_hint:
        courseC_collector_prog6_a: "Can you figure out what is going wrong?  \n\nTry using the \"Step\" button to find errors by running your code line by line."
      courseC_collector_prog7_authored_hint:
        courseC_collector_prog7_a: 'There is already a lot of great code in the workspace.  You don''t need to delete any of it to solve this puzzle.  '
        courseC_collector_prog7_b: Don't see the block you need to get the adventurer moving in the right direction?  Pull one from the toolbox.
      courseC_collector_prog9_authored_hint:
        courseC_collector_prog9_a: If you're having a hard time, try saying the steps you need to take outloud first.
      courseC_collector_progA_authored_hint:
        courseC_collector_progA_a: Try using the "Step" button to go through your code line by line.
      courseC_collector_prog_challenge1_authored_hint:
        courseC_collector_prog_challenge1_a: You can use the `collect` command more often to collect the extra treasure.
      courseC_collector_prog_challenge2_authored_hint:
        courseC_collector_prog_challenge1_a: You can use the `collect` command more often to collect the extra treasure.
      courseC_external_events_authored_hint: [ ]
      courseC_harvester_loops1_authored_hint:
        courseC_harvester_loops1_a: Once you have moved to a pumpkin, use `pick pumpkin` to collect it.
      courseC_harvester_loops2_authored_hint:
        courseC_harvester_loops2_a: If you get stuck, try writing the steps on paper and looking for repeating patterns.
      courseC_harvester_loops5_authored_hint:
        courseC_harvester_loops5_a: If you get stuck, try drawing the entire program and then looking for repeating patterns.
      courseC_harvester_loops6_authored_hint:
        courseC_harvester_loops6: Remember you can put multiple blocks in one repeat loop.
      courseC_harvester_loops_challenge1_authored_hint:
        courseC_harvester_loops_challenge1_a: 不用迴圈是不可能達成目標的！
        courseC_harvester_loops_challenge1_b: 你可以重複執行`移動-向前`和`收集玉木`到你想要的次數，然後在每次要轉向時使用`轉向-右邊`積木。
        courseC_harvester_loops_challenge1_c: |-
          要收集一開始的四個玉米，最好的方式是在一個`重複`積木裡頭使用另一個`重複`積木。你可以用這個模式來解決後面的關卡！
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat">
          <title name="TIMES">2</title>
          <statement name="DO">
          <block type="controls_repeat">
          <title name="TIMES">2</title>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="harvester_corn"/>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </statement>
          </block></next></block></xml>
      courseC_harvester_loops_challenge2_authored_hint:
        courseC_harvester_loops_challenge2_a: One way to solve this looks like a zig-zag. Another way looks like a spiral! There are lots of different solutions to a puzzle like this. Be persistent!
        courseC_harvester_loops_challenge2_b: 你可以重複執行`移動-向前`和`收集生菜`到你想要的次數，然後在每次要轉向時使用轉向積木。
        courseC_harvester_loops_challenge2_c: |
          This zig-zag pattern can be repeated twice to finish the puzzle with just 20 blocks!
          
          ![](https://images.code.org/26cfaf6fe4a275e266b51e9ef3711171-image-1493502306380.18.52 PM copy.png)
        courseC_harvester_loops_challenge2_d: |-
          This spiral pattern can be coded with just 18 blocks!
          
          ![](https://images.code.org/0bfc0a0ed6783fae908368a6e6d12c02-image-1493501358990.18.52 PM.png)
      courseC_maze_debugging1_authored_hint:
        courseC_maze_debugging1_a: |-
          - Does everything work after the first step?
          - Does it still work after the second?
          - Where does it go wrong?
      courseC_maze_debugging2_authored_hint:
        courseC_maze_debugging2_a: There is a lot of valuable code in the workspace.  Don't just delete it all and start over!
        courseC_maze_debugging2_b: |-
          - Does everything work after the first step?
          - Does it still work after the second?
          - Where does it go wrong?
      courseC_maze_debugging3_authored_hint:
        courseC_maze_debugging3_a: |-
          To remove a block, pull the other blocks aside to get to the one you're trying to delete, then drag that one off to the trash.
          
          Don't forget to put your other blocks back!
          
          ![](https://images.code.org/bbafa5a100505b2b99a3f43ad3195471-image-1479933232821.gif)
      courseC_maze_debugging4_authored_hint:
        courseC_maze_debugging4_a: Use the "Step" button to run through the instructions one at a time.  Does that help you find the line where things go wrong?
      courseC_maze_debugging5_authored_hint:
        courseC_maze_debugging5_a: "There are lots of helpful blocks in the workspace already.  Don't delete them all! \n\nUse the \"Step\" button to go through and figure out where the code goes wrong."
        courseC_maze_debugging5_b: Try saying what Scrat should do out loud.  Is it the same as the code in the workspace?  What goes wrong?
      courseC_maze_debugging6_authored_hint:
        courseC_maze_debugging6_a: |-
          - What is Scrat supposed to do?
          - What does Scrat do?
          - What does that tell you?
        courseC_maze_debugging6_b: |-
          Once you've found and fixed the first bug, go through the debugging process again to find the second one.
          
          Repeat the process until the program works!
      courseC_maze_debugging7_authored_hint:
        courseC_maze_debugging7_a: |-
          - Does everything work at the first step?
          - How about the second step?
          - Where does it go wrong?
        courseC_maze_debugging7_b: Don't forget to use the "Step" button to run the program line by line!
        courseC_maze_debugging7_c: |-
          After you find and fix the first bug, make sure to use the debugging process again to find the next one.
          
          Repeat the debugging process until the program works!
      courseC_maze_debugging8_authored_hint:
        courseC_maze_debugging8_a: |-
          - What is Scrat supposed to do?
          - What does Scrat do?
          - What does that tell you?
      courseC_maze_debugging8_predict1_authored_hint: [ ]
      courseC_maze_debugging9_authored_hint:
        courseC_maze_debugging9_a: |-
          - What is Scrat supposed to do?
          - What does Scrat do?
          - What does that tell you?
      courseC_maze_debugging_challenge1_authored_hint:
        courseC_maze_debugging_challenge1_a: 左邊還是右邊？你決定就好！
        courseC_maze_debugging_challenge1_b: 鼠奎特走的路徑是個四邊形！所以每次都轉向同要是同一邊！
        courseC_maze_debugging_challenge1_c: If you are getting stuck, you can always start over, or remove all the code and find your own way!
      courseC_maze_debugging_challenge2_authored_hint:
        courseC_maze_debugging_challenge2_a: 有個解法，就是在每次轉向時添加更多的移動積木。
        courseC_maze_debugging_challenge2_b: 如果你卡關了，你可以重頭開始，或者移除所有的程式碼後再試試別的方法！
        courseC_maze_debugging_challenge2_c: |-
          There are two different paths you can follow just using `move forward`, and only four turns. If you find a way to use the `repeat` block, there may be even more!
          
          ![](https://images.code.org/8a4665671cda35fea1f629a5bcc39e26-image-1493502743154.48.05 PM.png)
      courseC_maze_loops10_authored_hint: [ ]
      courseC_maze_loops10_predict2_authored_hint: [ ]
      courseC_maze_loops11_authored_hint: [ ]
      courseC_maze_loops2_authored_hint:
        courseC_maze_loops2_a: You can solve this puzzle with just three blocks, including `when run`.
        courseC_maze_loops2_b: Try putting the `move forward` block inside of a `repeat` block to create a loop.
        courseC_maze_loops2_c: You need to repeat the `move forward` command 5 times to solve this puzzle.
      courseC_maze_loops2_predict1_authored_hint:
        courseC_maze_loops2_a: You can solve this puzzle with just three blocks, including `when run`.
        courseC_maze_loops2_b: Try putting the `move forward` block inside of a `repeat` block to create a loop.
        courseC_maze_loops2_c: You need to repeat the `move forward` command 5 times to solve this puzzle.
      courseC_maze_loops3_authored_hint:
        courseC_maze_loops3_a: This puzzle is very similar to the last one.
        courseC_maze_loops3_b: Use a `repeat 5 times` block to create the loop.
      courseC_maze_loops4_authored_hint:
        courseC_maze_loops4_a: Not all command blocks should be repeated.
        courseC_maze_loops4_b: Use two `repeat` blocks set to different numbers.
        courseC_maze_loops4_c: "`Turn right` once between the two loops."
      courseC_maze_loops5_authored_hint:
        courseC_maze_loops5_a: The best solution uses two `move forward` commands and one loop.
      courseC_maze_loops6_authored_hint:
        courseC_maze_loops6_a: If the pattern is hard to see, try coding it all out first and see what repeats over and over before you put the loops in.
        courseC_maze_loops6_b: "如果要在`重複`迴圈中放置多個積木，只要拖曳一個迴圈到工作區，然後再把工作區上的積木堆拖曳到裡面。\n\n把它們放到`當運行時`積木就大功告成囉！"
      courseC_maze_loops7_authored_hint:
        courseC_maze_loops7_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
      courseC_maze_loops8_authored_hint:
        courseC_puppy_loops8courseC_maze_loops8_a: Try thinking about this problem in small parts. Take your time. You don't need to solve it on the first try!
        courseC_puppy_loops8courseC_maze_loops8_b: The first half of this path is similar to the stairs from the last puzzle, but it goes in a different direction.
        courseC_puppy_loops8courseC_maze_loops8_c: "There are different ways to solve this. \n\nYou will want to use at least two loops, and repeat a set of actions in the first one, then a single `move forward` in the other."
      courseC_maze_loops9_authored_hint:
        courseC_maze_loops9_1: 'If you''re having trouble finding where the code should repeat, try writing it down on a piece of paper and looking for a pattern. '
      courseC_maze_loops_challenge1_authored_hint:
        courseC_maze_loops_challenge1_a: Think about this path as being three different pieces. Each one has a pattern you can repeat.
        courseC_maze_loops_challenge1_b: In between each `repeat` block, you will need to `turn left` or `turn right` to get ready Scrat for the next pattern.
        courseC_maze_loops_challenge1_c: |-
          If you make it this far, you just need to `turn left` then `move forward` a few times. Don't give up!
          
          ![](https://images.code.org/7696c5c16b8ddf1d53436cdc7fb6346d-image-1494101728016.14.34 PM.png)
      courseC_maze_loops_challenge2_authored_hint:
        courseC_maze_loops_challenge2_a: The original code would work great - if there was only one piece of treasure in each pile!
        courseC_maze_loops_challenge2_b: Use loops so you don't run out of `collect` blocks!
      courseC_maze_programming1_authored_hint:
        courseC_maze_programming1_0: If the bird isn't getting to the pig, make sure all three of the blocks have been fully clicked together, then click "Run" again.
      courseC_maze_programming2_authored_hint:
        courseC_maze_programming2_a: To use a `move forward` block, drag it from the toolbox out into the workspace and connect it to the `when run` block.
      courseC_maze_programming3_authored_hint:
        courseC_maze_programming3_a: "![](https://images.code.org/afddde0e99d5d270c658de0c03dd6e2c-image-1481174000309.gif)\n\nTo delete a block from the middle of your code, drag all of the blocks underneath it away to the right and let them sit in the workspace for a while.  \n\nClick on the block you want to delete, and drag it back to the toolbox.\n\nFinally, put your other blocks back in place where they belong.\n"
      courseC_maze_programming4_authored_hint:
        courseC_maze_programming4_a: You can turn right or left from the bird's point of view. If you are facing right, turning right will make you point downwards.
        courseC_maze_programming4_b: To follow the path, move forward and turn one way, then move again and turn the opposite way. Move forward one more time to reach the pig.
      courseC_maze_programming5_authored_hint:
        courseC_maze_programming5_a: Try using the "Step" button to run your code line by line. Can you figure out what you need to do next?
      courseC_maze_programming6_authored_hint:
        courseC_maze_programming6_a: 有 2 個方法可以完成這個關卡！
        courseC_maze_programming6_b: Follow your finger from the bird to the pig, which steps did you take?
        courseC_maze_programming6_c: Remember you have to turn first, since the bird starts facing a wall.
      courseC_maze_programming7_authored_hint:
        courseC_maze_programming7_a: Don't forget to use the "Step" button to go through block by block and look for errors.
      courseC_maze_programming8_authored_hint:
        courseC_maze_programming8_a: Remember you can use the step button to look through your code line by line if you get stuck.
      courseC_maze_programming8_predict1_authored_hint: [ ]
      courseC_maze_programming9_authored_hint: [ ]
      courseC_maze_programming_challenge1_authored_hint: [ ]
      courseC_maze_programming_challenge2_authored_hint:
        courseC_maze_programming_challenge2_a: "*If you send me backwards, be extra careful that I turn the correct way!*"
        courseC_maze_programming_challenge2_b: The shortest solution use only 5 blocks, but it uses the `repeat` block!
      courseC_playLab_embedded_authored_hint: [ ]
      courseC_puppy_loops10_authored_hint:
        courseC_puppy_loops9_1: I need to move two or three time between each turn.
      courseC_puppy_loops11_authored_hint: [ ]
      courseC_puppy_loops8_authored_hint:
        2-3_Maze_Loops_17_a: Try thinking about this problem in small parts. Take your time. You don't need to solve it on the first try!
        2-3_Maze_Loops_17_b: The first half of this path is similar to the stair step from the last puzzle, but it goes a different direction.
        courseC_puppy_loops8_c: There are different ways to solve this. You will want to use at least two loops, and repeat either a set of actions or a single movement.
      courseC_puppy_loops8courseC_maze_loops8_authored_hint:
        courseC_puppy_loops8courseC_maze_loops8_a: Try thinking about this problem in small parts. Take your time. You don't need to solve it on the first try!
        courseC_puppy_loops8courseC_maze_loops8_b: The first half of this path is similar to the stairs from the last puzzle, but it goes in a different direction.
        courseC_puppy_loops8courseC_maze_loops8_c: "There are different ways to solve this. \n\nYou will want to use at least two loops, and repeat a set of actions in the first one, then a single `move forward` in the other."
      courseC_puppy_loops9_authored_hint:
        courseC_puppy_loops9_1: If you repeat the first few actions, you can get me to the pig with just four more blocks!
      courseC_starWars_loops10_authored_hint: [ ]
      courseC_starWars_loops10_predict2_authored_hint: [ ]
      courseC_starWars_loops11_authored_hint: [ ]
      courseC_starWars_loops2_authored_hint:
        courseC_starWars_loops2_a: You can solve this puzzle with just three blocks, including `when run`.
        courseC_starWars_loops2_b: You need to repeat the a move up command 5 times to solve this puzzle.
      courseC_starWars_loops4_authored_hint:
        courseC_starWars_loops4_a: Use two `repeat` blocks set to different numbers.
      courseC_starWars_loops5_authored_hint:
        courseC_starWars_loops5_b: To move down, you have to turn and then move forward.
        courseC_starWars_loops5_a: The best solution uses one move down and one loop filled with another move command.
      courseC_starWars_loops6_authored_hint:
        courseC_starWars_loops6_a: If the pattern is hard to see, try coding it all out first and see what repeats over and over before you put the loops in.
      courseC_starWars_loops7_authored_hint: [ ]
      courseC_starWars_loops8_authored_hint:
        course_starWars_loops8_a: Try thinking about this problem in small parts. Take your time. You don't need to solve it on the first try!
        course_starWars_loops8_b: The first half of this path is similar to the stairs from the last puzzle, but it goes in a different direction.
      courseC_starWars_loops9_authored_hint:
        course_starWars_loops9_a: |-
          You are doing great! Keep it up!
          
          If you're having trouble finding where the code should repeat, try writing it down on a piece of paper and looking for a pattern.
      courseD_artist_functions10_authored_hint:
        courseD_artist_functions10_b: This drawing is a lot like the last one, except the function draws a different kind of line.
        courseD_artist_functions10_a: To get around using multiple `move forward` blocks, create a `draw hexagon` function and call that multiple times.
      courseD_artist_functions2_authored_hint:
        courseD_artist_functions2_a: |-
          你的程式應該要：
          - 使用函式
          - 向前移動 100 + 75 像素
          - 使用函式
      courseD_artist_functions3_authored_hint:
        courseD_artist_functions3_a: |-
          To solve this puzzle, you just need to add a  loop that repeats the starter code 8 times.
          
          If you can't remember what the starter code was, click "start over" in the upper right corner of the workspace.
      courseD_artist_functions4_authored_hint:
        courseD_artist_functions4_a: Try using a function!
      courseD_artist_functions5_authored_hint:
        courseD_artist_functions5_a: Don't give up!  Remember what you have been learning.
        courseD_artist_functions5_b: Functions make it easy to call saved code at any time, not just from inside a loop!
      courseD_artist_functions6_authored_hint:
        grade4_artist_functions_windows0_a: Focus only on making one window for now.  We'll create a function for it in the next puzzle.
        grade4_artist_functions_windows0_b: Try using nested loops, where the inner loop makes the square and the outer loop rotates the square four times.
      courseD_artist_functions7_authored_hint:
        courseD_artist_functions7_a: Try creating your function first then adding in windows one at a time.
        courseD_artist_functions7_b: You shouldn't need to add any extra repeat loops.  Just jump the artist 100 pixels forward for each top window, and 150 pixels down to get the bottom windows.
      courseD_artist_functions8_authored_hint:
        courseD_artist_functions8_a: |-
          Start by making a function for a square, then try making a function for a line of squares.
          
          How would you use the `draw a line of squares` function to make this image?
        courseD_artist_functions8_b: After your first line of squares, you need to move the artist down and back before you start your second line of squares.
        courseD_artist_functions8_c: You should move the artist back a different number of pixels for even lines than for odd ones.
      courseD_artist_functions9_authored_hint:
        courseD_artist_functions9_a: To get around the need to have multiple `move forward` blocks, create a `draw triangle` function and call that multiple times.
        courseD_artist_functions9_b: This drawing is made by creating a line of triangles and turning either 60 or 120 degrees after each time you draw the triangle line.
      courseD_artist_nestedLoops1_authored_hint:
        courseD_artist_nestedLoops1_a: The easiest way to draw this is to move forward and use right turns.
      courseD_artist_nestedLoops10_authored_hint:
        courseD_artist_nestedLoops10_a: To start this pattern, reuse the code from the first half of the last puzzle.
        courseD_artist_nestedLoops10_c: Remember, each square has a side length of 50 pixels.
        courseD_artist_nestedLoops10_b: Make sure the outer loop of the code is set to run 7 times and remove the outer turn.
      courseD_artist_nestedLoops1a_authored_hint:
        courseD_artist_nestedLoops1a_a: |-
          You will need to draw a total of 6 triangles, each rotated 60 degrees.
          
          ![](https://images.code.org/ad6c6d98298df9f4e3cea5bbe5ec776e-image-1497476332024.2_solution2.gif)
      courseD_artist_nestedLoops2_authored_hint:
        courseD_artist_nestedLoops2_a: Nest your loops by surrounding your triangle code with another `repeat` loop.
      courseD_artist_nestedLoops3_authored_hint:
        courseD_artist_nestedLoops3_a: "試著用`跳躍-向前`積木，讓小藝術家在畫完一個正方形後，跳到下一個要開始的地方。\n\n如果你的正方形是 20 像素高，而且兩個正方形相隔 20 像素遠，你需要跳多遠？"
        courseD_artist_nestedLoops3_b: 'Don''t forget to use a nested loop to solve this puzzle quickly. '
        courseD_artist_nestedLoops3_c: 'Start by using a `repeat` loop to make one square.  Next, repeat that square 8 times, jumping 40 pixels in between. '
      courseD_artist_nestedLoops4_authored_hint:
        courseD_artist_nestedLoops4_a: |-
          To make a circle:
          - Repeat 360 times
          - Move forward 1 pixel
          - Turn left 1 degree
        courseD_artist_nestedLoops4_b: Don't forget to jump forward by 50 pixels between circles.
        courseD_artist_nestedLoops4_c: Use a nested loop to draw your circles 4 times.
      courseD_artist_nestedLoops5_authored_hint:
        courseD_artist_nestedLoops5_a: |-
          To do this easily:
          
          - repeat 4 times
          - make a cirlce
          - jump forward 50 pixels
          - turn right 90 degrees
        courseD_artist_nestedLoops5_b: To make a circle set a repeat loop to repeat 360 times. Inside the loop, move forward 1 pixel and turn by 1 degree.
      courseD_artist_nestedLoops6_authored_hint:
        courseD_artist_nestedLoops6_a: You'll need to repeat your outer loop 6 times now, instead of only 4.
        courseD_artist_nestedLoops6_b: 'Now that you''re breaking 360 degrees into six pieces instead of only four, you will only need to turn 60 degrees between circles. '
      courseD_artist_nestedLoops7_authored_hint:
        courseD_artist_nestedLoops7_a: You'll need to use nested loops here. First, make a loop to draw a square. What will the outer loop need to be if the inner loop is to draw a square?
        courseD_artist_nestedLoops7_b: |-
          Use a nested loop, where the inner loop is the code for a square.
          
          - repeat 6 times
          - make square
          - jump forward by **50 pixels**
          - turn **60 degrees**
      courseD_artist_nestedLoops8_authored_hint:
        courseD_artist_nestedLoops8_a: To have 8 hexagons in your drawing, you'll need to turn **45 degrees** between each of them. Why? Because 360 degrees (a full turn around) divided by 8 (the number of hexagons) is 45 degrees.
        courseD_artist_nestedLoops8_b: If you're stuck, start by looking at the last puzzle, then change the things that are different.
        courseD_artist_nestedLoops8_c: |-
          Use a nested loop:
          
          - Repeat 8 times
          - draw a hexagon
          - jump forward 50 pixels
          - turn right 45 degrees
      courseD_artist_nestedLoops9_authored_hint:
        courseD_artist_nestedLoops9_a: Start by using a nested loop like you had before, but this time, make it with squares.
        courseD_artist_nestedLoops9_b: Add a second set of nested loops to the end of the first set, but this time use triangles.
        courseD_artist_nestedLoops9_c: |-
          Use two nested loops:
          - Repeat 8 times
          - draw a square
          - jump forward 50 pixels
          - turn right by 45 degrees
          - Repeat 8 times
          - draw a triangle
          - jump forward 50 pixels
          - turn right by 45 degrees
      courseD_artist_nestedLoops9_predict1_authored_hint:
        courseD_artist_nestedLoops9_a: Start by using a nested loop like you had before, but this time, make it with squares.
        courseD_artist_nestedLoops9_b: Add a second set of nested loops to the end of the first set, but this time use triangles.
      courseD_artist_nestedLoopsFP_authored_hint:
        courseD_artist_nestedLoopsFP_a: |-
          <img src="https://images.code.org/9257cbf61f238f5a749a949059731934-image-1478732674615.02.25.png" width="200px"/>
          
          This image was made using a single nested loop that repeats a hexagon (with 50px sides) 15 times using a 48 degree turn.
        courseD_artist_nestedLoopsFP_b: |
          <img src="https://images.code.org/31a85d4e5be5209240195d34b17a177b-image-1478732674613.32.53.png" width="200px"/>
          
          This image was made using similar code to other levels in this series, but with circles (repeat 360 times: move forward 1, turn 1 degree).
        courseD_artist_nestedLoopsFP_c: |-
          <img src="https://images.code.org/f654f1512860c6c8cf6795c961a8959c-image-1478732674616.02.58.png" width="200px"/>
          
          This image was made using a single nested loop that repeats a pentagon (with 50px sides) 15 times using a 48 degree turn.
      courseD_artist_nestedLoopsPre1_authored_hint: [ ]
      courseD_artist_nestedLoops_challenge1_authored_hint:
        courseD_artist_nestedLoops_challenge1_a: Start by making a nested loop to create four octagons. Turn 45 degrees to make the octagon. Jump, then turn 90 degrees after each one.
        courseD_artist_nestedLoops_challenge1_b: Add code to draw a triangle inside of your nested loop. Use 120 degree turns for your triangle.
        courseD_artist_nestedLoops_challenge1_c: |-
          Use a nested loop:
          - Repeat 8 times
          - draw an octagon
          - draw a triangle
          - jump forward 50 pixels
          - turn right by 90 degrees
      courseD_artist_nestedLoops_challenge2_authored_hint:
        courseD_artist_nestedLoops_challenge2_a: To draw a regular octagon, the artist needs to turn 45 degrees at a time.
        courseD_artist_nestedLoops_challenge2_b: To draw a regular hexagon, the artist needs to turn 60 degrees at a time.
      courseD_artist_project1_authored_hint: [ ]
      courseD_artist_project1a_authored_hint:
        courseD_artist_project1a_a: |
          This stair step uses a 76 degree turn and repeats 4 times.
          
          <img src="https://images.code.org/73b1310fca6cf884ec8fb8b026210212-image-1495839168718.16.10.png" width="200px" />
      courseD_artist_project2_authored_hint: [ ]
      courseD_artist_project2Template_authored_hint: [ ]
      courseD_artist_project2a_authored_hint:
        courseD_artist_project2a_a: |
          This drawing was made by nesting a loop of 4 stairs and a `turn right 180 degrees` block inside of a `repeat 2 times` block.
          
          <img src="https://images.code.org/bb24f9acee8afed2e119c1e920cb43f6-image-1495834479042.16.27.png" width="200px" />
      courseD_artist_project3_authored_hint:
        courseD_artist_project3_a: "Try nested loops!\n\nUse the code that you created to draw a line of shapes and nest it inside of another loop.  At the bottom, before the outside loop ends, add a block that will turn Elsa around.  \n\n- Try 72 degrees if you are repeating the outer loop 5 times\n- Try 60 degrees if you are repeating the outer loop 6 times"
      courseD_artist_project3a_authored_hint: [ ]
      courseD_artist_project4_authored_hint:
        courseD_artist_project4_a: |
          Here is the pentagon snowflake with a turn of 36 degrees before a triangle snowflake:
          
          <img src="https://images.code.org/2ba023db9404f948fab655bfa7923160-image-1495822526223.14.13.png" width="200px" />
          
          
          Here's a set of hexagons with squares:
          
          <img src="https://images.code.org/4d77462f3d07df6f1f5f2dc25e5d2b70-image-1495822526224.15.08.png" width="200px" />
      courseD_artist_project4a_authored_hint:
        courseD_artist_project4a_a: |
          Here are two different lengths of snowflake, drawn one after another (with a 30 degree turn in between.)
          
          <img src="https://images.code.org/45dedb51d89d3e5d0a88fe65ecbd7d7b-image-1495833855890.22.39.png" width="200px" />
      courseD_artist_project5_authored_hint:
        courseD_artist_project4_a: |
          Lines of 2 hexagons and 4 triangles:
          
          <img src="https://images.code.org/37ca9779bafd2ccc5cc801f82358008e-image-1495823683964.34.09.png" width="200px" />
      courseD_artist_projectTemplate_authored_hint: [ ]
      courseD_artist_ramp11_authored_hint:
        courseD_artist_ramp11a: 若要繪製一條邊，請用`移動向前 100 像素`積木，並把 100 改成 200。
        courseD_artist_ramp11b: |-
          若要畫出 4 條邊，可以把`移動-向前 200 像素`積木放到重複迴圈裡，並設定重複次數為 4 次。
      courseD_artist_ramp12_authored_hint:
        courseD_artist_ramp12_a: 你也可以先畫出正方形，然後再畫三角形。調換畫的順序也可以！
      courseD_bee_conditionals1_authored_hint:
        courseD_bee_conditionals1_a: You will need to use an `if` block to check to see if there is a flower beneath the cloud before you try to get nectar.
      courseD_bee_conditionals1_predict1_authored_hint:
        courseD_bee_conditionals1_a: You will need to use an `if` block to check to see if there is a flower beneath the cloud before you try to get nectar.
      courseD_bee_conditionals2_authored_hint:
        courseD_bee_conditionals2_a: Sometimes a flower will be there, sometimes it won't.  If you want your code to run in both cases, make sure to use an `if` statement.
      courseD_bee_conditionals3_authored_hint:
        courseD_bee_conditionals3_a: Be sure to use an `if` statement to check each space to see if it has either a flower or nothing.
      courseD_bee_conditionals4_authored_hint:
        courseD_bee_conditionals4_a: You can still treat every space as if there is a cloud over it, even though you can see the whole path.
        courseD_bee_conditionals4_b: 'Use an `if` statement inside your loop to check each space for nectar. '
        courseD_bee_conditionals4_c: Using the block `while there is a path ahead`, you should `move forward` and check for a flower. `if there is a flower` what should the bee do?
      courseD_bee_conditionals5_authored_hint:
        courseD_bee_conditionals5_a: Think of every side of the rectangular path as a path by itself. Set up a nested loop with a `repeat` block on the outside and a `while there is a path ahead` on the inside. How many paths does the bee need to buzz down if the bee needs to buzz every side with a flower?
        courseD_bee_conditionals5_b: Inside the `while there is a path ahead` block, you will need to move forward and check for a flower. How do you check if there is a flower? What do you do if there is a flower?
        courseD_bee_conditionals5_c: There are 3 sides of the rectangle with flowers, so the code needs to `repeat 3 times`. In every repeat, the bee will need to continue along the path, `while there is a path ahead`. To continue down the path, the bee will need to `move forward`. While on the path, the bee needs to check for a flower. `if there is a flower`, the bee should `get nectar`.
      courseD_bee_conditionals6_authored_hint:
        courseD_bee_conditionals6_a: Make sure to use an `if` statement to check for honeycomb beneath each cloud.
      courseD_bee_conditionals7_authored_hint:
        courseD_bee_conditionals7_a: "**Remember:** This puzzle changes each time it's run.  \n\nYou'll want to use a conditional block (`if/else`) to solve the challenge."
      courseD_bee_conditionals7_predict2_authored_hint:
        courseD_bee_conditionals7_a: "**Remember:** This puzzle changes each time it's run.  \n\nYou'll want to use a conditional block (`if/else`) to solve the challenge."
      courseD_bee_conditionals8_authored_hint:
        courseD_bee_conditionals8_a: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
        courseD_bee_conditionals8_b: |-
          This puzzle is tricky, because you can't check blank squares, nectar, *and* honey with just one single conditional.
          
          Only check for nectar and honey at the end of your path.
      courseD_bee_conditionals9_authored_hint:
        courseD_bee_conditionals9_a: In this puzzle, you know that each square has either a flower or a honeycomb.  That means you can repeat your `if/else` conditional at each square.
      courseD_bee_conditionals_challenge1_authored_hint:
        courseD_bee_conditionals_challenge1_a: In this puzzle, each space could have a flower, a honey comb, or nothing.  That means you can repeat your `if/else` conditional at each square.
      courseD_bee_conditionals_challenge2_authored_hint:
        courseD_bee_conditionals_challenge1_b: |-
          Just like the `if at flower` blocks, the code inside a `while nectar > 0` will only run if the bee is at a flower. The main differences is that the code inside will run repetitively until there is no nectar left.  Try this pattern:
          
          <xml>  <block type="bee_whileNectarAmount">
          <title name="ARG1">nectarRemaining</title>
          <title name="OP">&gt;</title>
          <title name="ARG2">0</title>                    <statement name="DO">
          <block type="maze_nectar"/>
          </statement>
          </block></xml>
      courseD_bee_conditionals_challenge3_authored_hint:
        courseD_bee_conditionals_challenge1_b: |-
          Just like the `if at flower` blocks, the code inside a `while nectar > 0` will only run if the bee is at a flower. The main differences is that the code inside will run repetitively until there is no nectar left.  Try this pattern:
          
          <xml>  <block type="bee_whileNectarAmount">
          <title name="ARG1">nectarRemaining</title>
          <title name="OP">&gt;</title>
          <title name="ARG2">0</title>                    <statement name="DO">
          <block type="maze_nectar"/>
          </statement>
          </block></xml>
      courseD_bee_debugging1_authored_hint:
        courseD_bee_debugging1_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_bee_debugging1_b: Do you see any patterns that could be made more simple using a `repeat` loop?
      courseD_bee_debugging2_authored_hint:
        courseD_bee_debugging2_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_bee_debugging2_b: Do you see a pattern?  Try using nested loops to solve this puzzle.
      courseD_bee_debugging3_authored_hint:
        courseD_bee_debugging3_a: Is there any place where the bee does something that doesn't make sense? What happens when you change those blocks?
        courseD_bee_debugging3_b: Try simplifying the code using nested loops.
      courseD_bee_debugging4_authored_hint:
        courseD_bee_debugging4_a: "Try using the debugging process a couple of times in a row. \n\nWhat causes the first problem?\n\nOnce that problem is fixed, what goes wrong?"
        courseD_bee_debugging4_b: "If you're having a hard time figuring out how to make the stair step pattern, try tracing it with your finger and saying the commands out loud. \n\nDon't forget to point out the direction of the turns!"
      courseD_bee_debugging5_authored_hint:
        courseD_bee_debugging5_a: |-
          Start by looking at just the first loop.
          
          What does it do?
          
          What is it supposed to do?
          
          What does that tell you?
        courseD_bee_debugging5_b: Once you have the first loop the way you want it, what is left over in your code?
        courseD_bee_debugging5_c: |-
          Try wrapping the leftover loop around the rest of your completed code.  Does is work now?
          
          If not, what is still going wrong?
      courseD_bee_debugging6_authored_hint:
        courseD_bee_debugging6_a: |-
          Try running through the code using the "Step" button.  Is everything good at the first step?
          
          How about the second?
          
          Where do things go wrong?
        courseD_bee_debugging6_b: It looks like all of the right steps are here, you just need more of them.  How can you repeat the `get nectar` and `make honey` actions multiple times?
      courseD_bee_debugging7_authored_hint:
        courseD_bee_debugging7_a: "Try using the \"Step\" button.  Is everything right at the first step?  \n\nHow about the second?  \n\nWhere does it go wrong?  "
        courseD_bee_debugging7_b: If something needs to happen several times, try adding a `repeat` loop.
      courseD_bee_debugging8_authored_hint:
        courseD_bee_debugging8_a: Do you see a pattern that you can simplify with a loop?
        courseD_bee_debugging8_b: Try using a nested loop to make this code shorter.
      courseD_bee_debugging9_authored_hint:
        courseD_bee_debugging9_a: There are several ways to solve this problem...but they all involve turns!
        courseD_bee_debugging9_b: Figure out how you would solve the puzzle, then move step-by-step to try to make the code match what is in your head.
      courseD_bee_debugging9_predict1_authored_hint: [ ]
      courseD_bee_debugging_challenge1_authored_hint:
        courseD_bee_debugging_challenge1_a: Why the first half of this program work? Think about why the bee needs to move backward. How much nectar does the bee collect each time it moves over a flower?
        courseD_bee_debugging_challenge1_b: On the way back, have the bee follow the same pattern. How much honey does the bee need to make each time it moves over a honey comb?
        courseD_bee_debugging_challenge1_c: |-
          After the bee makes it to the bottom row, have it repeat these commands:
          
          * Repeat 2 times:
          * Move forward
          * Make 3 honey
          * Move backward
      courseD_bee_debugging_challenge2_authored_hint:
        courseD_bee_debugging_challenge1_a: Why the first half of this program work? Think about why the bee needs to move backward. How much nectar does the bee collect each time it moves over a flower?
        courseD_bee_debugging_challenge1_b: On the way back, have the bee follow the same pattern. How much honey does the bee need to make each time it moves over a honey comb?
        courseD_bee_debugging_challenge1_c: |-
          After the bee makes it to the bottom row, have it repeat these commands:
          
          * Repeat 2 times:
          * Move forward
          * Make 3 honey
          * Move backward
      courseD_bee_nestedLoops1_authored_hint:
        courseD_bee_nestedLoops1_a: Not working?  Try using the "Step" button to see what happens line by line.
      courseD_bee_nestedLoops2_authored_hint:
        courseD_bee_nestedLoops2_a: To solve this puzzle, you will need to nest one `repeat` loop inside of another.
      courseD_bee_nestedLoops2_predict1_authored_hint: [ ]
      courseD_bee_nestedLoops3_authored_hint:
        grade4_bee_nestedLoops1_a: If you don't understand how to use nested loops here, try writing out the instructions step by step on a piece of paper.  Circle the patterns that you see.
      courseD_bee_nestedLoops5_authored_hint:
        grade4_bee_nestedLoops4_a: Try building your code line by line and see if you can spot the places where a repeat will make the code shorter!
        grade4_bee_nestedLoops4_b: |-
          You will need a nested loop to move forward and get nectar, but only a single loop to collect honey at the end.
          
          Altogether, you should be using 3 loops.
      courseD_bee_nestedLoops6_authored_hint: [ ]
      courseD_bee_nestedLoops7_authored_hint:
        courseD_bee_nestedLoops7_a: You will need to repeat `get nectar` inside of another `repeat` that also has the `move forward` block inside of it.
        courseD_bee_nestedLoops7_b: You will need to use all three of the available `repeat` blocks to solve this puzzle.
        courseD_bee_nestedLoops7_c: |
          Nest your blocks three deep, like this:
          
          - repeat 3
          - turn right
          - repeat 3
          - repeat 12
          - get nectar
          - move forward
      courseD_bee_nestedLoops8_authored_hint:
        courseD_bee_nestedLoops8_a: Try building your code line by line and see if you can spot the places where a repeat will make the code shorter!
        courseD_bee_nestedLoops8_b: |-
          You will need a nested loop to move forward and get nectar, but only a single loop to collect honey at the end.
          
          Altogether, you should be using 3 loops.
      courseD_bee_nestedLoops9_authored_hint: [ ]
      courseD_bee_nestedLoops9_predict2_authored_hint: [ ]
      courseD_bee_nested_loops_challenge1_authored_hint:
        courseD_bee_nested_loops_challenge2_a: Don't forget that you can `repeat` a single command or a longer pattern. You can even `repeat` a `repeat` block!
        courseD_bee_nested_loops_challenge2_b: To get all 4 gems, first use a loop to move away from the center. Turn left or right, then use a nested loop to move from the first pile of treasure to the second. If you repeat the nested loop enough times, the collector will move around the *entire* cave!
        courseD_bee_nested_loops_challenge2_c: The shortest program that reaches all the treasure uses only one `collect` block and two turns.
      courseD_bee_nested_loops_challenge2_authored_hint:
        courseD_bee_nested_loops_challenge2_a: Don't forget that you can `repeat` a single command or a longer pattern. You can even `repeat` a `repeat` block!
        courseD_bee_nested_loops_challenge2_b: To get all 4 gems, first use a loop to move away from the center. Turn left or right, then use a nested loop to move from the first pile of treasure to the second. If you repeat the nested loop enough times, the collector will move around the *entire* cave!
        courseD_bee_nested_loops_challenge2_c: The shortest program that reaches all the treasure uses only one `collect` block and two turns.
      courseD_collector_debugging1_authored_hint:
        courseD_collector_debugging1_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_collector_debugging1_b: Do you see any patterns that could be made more simple using a `repeat` loop?
      courseD_collector_debugging10_predict1_authored_hint:
        courseD_collector_debugging9_a: There are several ways to solve this problem...but they all involve turns!
        courseD_collector_debugging9_b: Figure out how you would solve the puzzle, then move step-by-step to try to make the code match what is in your head.
      courseD_collector_debugging2_authored_hint:
        courseD_collector_debugging2_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_collector_debugging2_b: Do you see any patterns that could be made more simple using a `repeat` loop?
      courseD_collector_debugging3_authored_hint:
        courseD_collector_debugging3_a: Is there any place where Laurel does something that doesn't make sense? What happens when you change those blocks?
        courseD_collector_debugging3_b: Try simplifying the code using nested loops.
      courseD_collector_debugging4_authored_hint:
        courseD_collector_debugging4_a: "Try using the debugging process a couple of times in a row. \n\nWhat causes the first problem?\n\nOnce that problem is fixed, what goes wrong?"
        courseD_collector_debugging4_b: "If you're having a hard time figuring out how to make the stair step pattern, try tracing it with your finger and saying the commands out loud. \n\nDon't forget to point out the direction of the turns!"
      courseD_collector_debugging5_authored_hint:
        courseD_collector_debugging5_a: |-
          Start by looking at just the first loop.
          
          What does it do?
          
          What is it supposed to do?
          
          What does that tell you?
        courseD_collector_debugging5_b: Once you have the first loop the way you want it, what is left over in your code?
        courseD_collector_debugging5_c: |-
          Try wrapping the leftover loop around the rest of your completed code.  Does is work now?
          
          If not, what is still going wrong?
      courseD_collector_debugging6_authored_hint:
        courseD_collector_debugging6_a: |-
          Try running through the code using the "Step" button.  Is everything good at the first step?
          
          How about the second?
          
          Where do things go wrong?
        courseD_collector_debugging6_b: It looks like all of the right steps are here, you just need more of them.  How can you repeat the `collect` action multiple times?
      courseD_collector_debugging7_authored_hint:
        courseD_collector_debugging7_a: |-
          Try running through the code using the "Step" button.  Is everything good at the first step?
          
          How about the second?
          
          Where do things go wrong?
        courseD_collector_debugging7_b: If something needs to happen several times, try adding a `repeat` loop.
      courseD_collector_debugging8_authored_hint:
        courseD_collector_debugging8_a: Do you see a pattern that you can simplify with a loop?
        courseD_collector_debugging8_b: Try using a nested loop to make this code shorter.
      courseD_collector_debugging9_authored_hint:
        courseD_collector_debugging9_a: There are several ways to solve this problem...but they all involve turns!
        courseD_collector_debugging9_b: Figure out how you would solve the puzzle, then move step-by-step to try to make the code match what is in your head.
      courseD_collector_debugging_challenge2_authored_hint:
        courseD_collector_debugging_challenge2_a: "Start by focusing on collect TWO gems from each of the first two piles.\n\n![](https://images.code.org/8493c16a5b913b91e28b36eb2b280b8c-image-1494775939149.25.04 AM copy.png)\nUse these blocks.\n\n<xml>\n<block type=\"collector_collect\"></block>\n<block type=\"controls_repeat\" limit=\"2\">\n    <title name=\"TIMES\">2</title>\n  </block>\n<block type=\"maze_move\" x=\"175px\" y=\"17px\">\n                    <title name=\"DIR\">moveForward</title>\n\n                  </block>\n                  \n \n   <block type=\"controls_repeat\" limit=\"2\" x=\"175px\" y=\"56px\">\n    <title name=\"TIMES\">2</title>\n  </block>\n\n\n\n</xml>"
        courseD_collector_debugging_challenge2_b: "Next, collect the remaining gems in this row.\n\n![](https://images.code.org/22fff9fb20a50beaf4800aa022a5deb0-image-1494775944657.25.04 AM.png)\nAdd these blocks to your program.\n\n<xml><block type=\"maze_move\">\n                    <title name=\"DIR\">moveBackward</title>\n                  </block>\n<block type=\"controls_repeat\">\n        <title name=\"TIMES\">4</title>\n        <statement name=\"DO\">\n          \n        </statement>\n      </block>\n</xml>"
        courseD_collector_debugging_challenge2_c: "Finally, collect the remaining treasure. Add these blocks to your program.\n\n<xml>\n  <block type=\"maze_turn\">\n                <title name=\"DIR\">turnRight</title>\n              </block>\n      <block type=\"controls_repeat\">\n        <title name=\"TIMES\">4</title>\n        <statement name=\"DO\">\n          \n        </statement>\n      </block>\n\n</xml>"
        courseD_collector_debugging_challenge2_d: |-
          Here is the complete solution for this puzzle.
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat">
          <title name="TIMES">4</title>
          <statement name="DO">
          <block type="controls_repeat">
          <title name="TIMES">4</title>
          <statement name="DO">
          <block type="controls_repeat">
          <title name="TIMES">2</title>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="controls_repeat">
          <title name="TIMES">2</title>
          <statement name="DO">
          <block type="collector_collect"/>
          </statement>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_move">
          <title name="DIR">moveBackward</title>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </xml>
      courseD_collector_nested_loops_challenge2_authored_hint:
        courseD_bee_nested_loops_challenge2_a: Don't forget that you can `repeat` a single command or a longer pattern. You can even `repeat` a `repeat` block!
        courseD_bee_nested_loops_challenge2_b: To get all 4 gems, first use a loop to move away from the center. Turn left or right, then use a nested loop to move from the first pile of treasure to the second. If you repeat the nested loop enough times, the collector will move around the *entire* cave!
        courseD_bee_nested_loops_challenge2_c: The shortest program that reaches all the treasure uses only one `collect` block and two turns.
        courseD_bee_nested_loops_challenge2_d: |-
          **Solution:**
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat_dropdown">
          <title name="TIMES" config="3-10">3</title>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_repeat_dropdown">
          <title name="TIMES" config="3-10">3</title>
          <statement name="DO">
          <block type="collector_collect">
          <next>
          <block type="controls_repeat_dropdown">
          <title name="TIMES" config="3-10">3</title>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_repeat_dropdown">
          <title name="TIMES" config="3-10">3</title>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseD_collector_ramp10_authored_hint:
        courseD_artist_ramp10_a: |-
          替換掉使用四個`移動-向前`積木的方式，改成把`移動-向前`積木放進`重複`迴圈，像這樣：
          <xml><block type="controls_repeat">
          <title name="TIMES">4</title>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          </block></xml>
        courseD_artist_ramp10_b: 別忘了要收集寶藏後，再後在每步之後轉向！
      courseD_collector_until_challenge1_authored_hint: [ ]
      courseD_debugging_1_authored_hint:
        courseD_debugging_1_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_debugging_1_b: Do you see any patterns that could be made more simple using a `repeat` loop?
      courseD_debugging_2_authored_hint:
        courseD_debugging_2_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        courseD_debugging_2_b: Do you see a pattern?  Try using nested loops to solve this puzzle.
      courseD_debugging_3_authored_hint:
        courseD_debugging_3_a: Is there any place where the bee does something that doesn't make sense? What happens when you change those blocks?
        courseD_debugging_3_b: Try simplifying the code using nested loops.
      courseD_debugging_4_authored_hint:
        courseD_debugging_4_a: "Try using the debugging process a couple of times in a row. \n\nWhat causes the first problem?\n\nOnce that problem is fixed, what goes wrong?"
        courseD_debugging_4_b: "If you're having a hard time figuring out how to make the stair step pattern, try tracing it with your finger and saying the commands out loud. \n\nDon't forget to point out the direction of the turns!"
      courseD_debugging_5_authored_hint:
        courseD_debugging_5_a: |-
          Start by looking at just the first loop.
          
          What does it do?
          
          What is it supposed to do?
          
          What does that tell you?
        courseD_debugging_5_b: Once you have the first loop the way you want it, what is left over in your code?
        courseD_debugging_5_c: |-
          Try wrapping the leftover loop around the rest of your completed code.  Does is work now?
          
          If not, what is still going wrong?
      courseD_debugging_6_authored_hint:
        courseD_debugging_6_a: |-
          Try running through the code using the "Step" button.  Is everything good at the first step?
          
          How about the second?
          
          Where do things go wrong?
        courseD_debugging_6_b: It looks like all of the right steps are here, you just need more of them.  How can you repeat the `get nectar` and `make honey` actions multiple times?
      courseD_external_cond_authored_hint: [ ]
      courseD_farmer_condLoops1_authored_hint:
        courseD_farmer_condLoops1_a: You will need to look for corn 5 times, using a repeat loop.
        courseD_farmer_condLoops1_b: Make sure to use an `if at corn` block or you might try to pick something that's not there!
      courseD_farmer_condLoops2_authored_hint:
        courseD_farmer_condLoops2_a: 'The best way to do this is to nest `if` statements by placing one inside of the other.  '
        courseD_farmer_condLoops2_b: For this puzzle, you should have one `if/else` statement and one plain `if` statement.
      courseD_farmer_condLoops3_authored_hint:
        courseD_farmer_condLoops3_a: |-
          To get all of the items, try nesting `if` statements three deep.
          
          This means you should put one `if` statement inside of another, then put a third `if` statement inside the second one.
        courseD_farmer_condLoops3_b: For this puzzle, you should have two `if/else` statements and one plain `if` statement.
      courseD_farmer_condLoops4_authored_hint:
        grade3_RunningFarm_4courseD_farmer_condLoops4: |-
          No one knows how many heads of lettuce will grow from each sprout.
          
          Use a `while there is lettuce` loop to keep picking until each piece has been gathered.
      courseD_farmer_condLoops4a_authored_hint:
        grade3_RunningFarm_4courseD_farmer_condLoops4: |-
          No one knows how many heads of lettuce will grow from each sprout.
          
          Use a `while there is lettuce` loop to keep picking until each piece has been gathered.
      courseD_farmer_condLoops5_authored_hint:
        courseD_farmer_condLoops5_a: You will need to check for each type of crop that the farmer can pick.  Try using two `if/else` statements and one  `if` block.
      courseD_farmer_condLoops6_authored_hint:
        courseD_farmer_condLoops6_a: Use a `while path ahead` loop to move the farmer down each piece of the spiral.
        courseD_farmer_condLoops6_b: You only need to check for corn during most of the harvest.  Just pick one pumpkin at the very end of your program.
      courseD_farmer_condLoops7_authored_hint:
        courseD_farmer_condLoops7_a: |-
          Notice that the easiest path to get to all of the crops is still a spiral.
          
          ![](https://images.code.org/ba8b8c624f21ade9ac823b045085c435-image-1479364378437.png)
        courseD_farmer_condLoops7_b: Try using `when path ahead` to keep the farmer moving the right number of steps.
        courseD_farmer_condLoops7_c: 'Use nested `if` statements and `while there is` loops to check each space for corn and lettuce, then pick only a single pumpkin at the end. '
      courseD_farmer_condLoops8_authored_hint:
        courseD_farmer_condLoops8_a: This puzzle uses almost the exact same code as the last level, except you only need to repeat 4 times.
      courseD_farmer_condLoops9_authored_hint:
        courseD_farmer_condLoops9_a: You shouldn't need the `while path ahead` loop this time.
      courseD_farmer_condLoops9_predict1_authored_hint:
        courseD_farmer_condLoops9_a: You shouldn't need the `while path ahead` loop this time.
      courseD_farmer_condLoops_challenge1_authored_hint: [ ]
      courseD_farmer_condLoops_challenge2_authored_hint: [ ]
      courseD_farmer_condLoops_challenge2_clone_authored_hint: [ ]
      courseD_farmer_conditionals10_authored_hint: [ ]
      courseD_farmer_conditionals4_authored_hint:
        courseD_farmer_conditionals4_a: Instead of using a `repeat` loop, use a `while` loop to keep digging until the pile is gone.
      courseD_farmer_conditionals5_authored_hint:
        courseD_farmer_conditionals5a: Try nesting a `while` loop inside of a `repeat` loop.
      courseD_farmer_conditionals6_authored_hint:
        courseD_farmer_conditionals6_a: Make sure you're using the `while` loop to figure out how many times to fill each hole.
        courseD_farmer_conditionals6_b: Notice that the farmer needs to move forward and down several times in a stair-step pattern.
      courseD_farmer_conditionals7_authored_hint:
        courseD_farmer_conditionals8_a: The `while path ahead` block lets you keep going, even if you don't know how many squares are in a path.
      courseD_farmer_conditionals8_authored_hint:
        courseD_farmer_conditionals8_a: You are going to need to use more than one `while` loop.
        courseD_farmer_conditionals8_b: Every hole is at the end of a path, so use `while path ahead` before using `while there is a hole`.
        courseD_farmer_conditionals8_c: Notice that you need to repeat the `while path ahead`, `while there is a hole` code six times.
      courseD_farmer_conditionals9_authored_hint: [ ]
      courseD_farmer_until_challenge2_authored_hint: [ ]
      courseD_farmer_while10_authored_hint: [ ]
      courseD_farmer_while10_predict2_authored_hint: [ ]
      courseD_farmer_while4_authored_hint:
        courseD_farmer_conditionals4_a: Instead of using a `repeat` loop, use a `while` loop to keep digging until the pile is gone.
      courseD_farmer_while4_predict1_authored_hint: [ ]
      courseD_farmer_while5_authored_hint:
        courseD_farmer_conditionals5a_a: Try nesting a `while` loop inside of a `repeat` loop.
        courseD_farmer_conditionals5a_b: The farmer needs to move forward a total of five times to get to the end of the row. What else does the farmer need to do?
        courseD_farmer_conditionals5a_c: Move forward 5 times. Each time you move forward, remove the pile of dirt by using the `while there is a pile` block.
      courseD_farmer_while6_authored_hint:
        courseD_farmer_conditionals6_a: Make sure you're using the `while` loop to figure out how many times to fill each hole.
        courseD_farmer_conditionals6_b: Notice that the farmer needs to move forward and down several times in a stair-step pattern.
        courseD_farmer_conditionals6_c: |-
          The stair step pattern uses the following blocks
          - move forward
          - fill hole
          - turn right
          - move forward
          - fill hole
          - turn left
          
          How many times do you need to use this stair step pattern?
          
          Make sure you are using the `while there is a hole` to fill the hole.
      courseD_farmer_while7_authored_hint:
        courseD_farmer_conditionals8_a: The `while path ahead` block lets you keep going, even if you don't know how many squares are in a path.
      courseD_farmer_while8_authored_hint:
        courseD_farmer_conditionals8_a: You are going to need to use more than one `while` loop.
        courseD_farmer_conditionals8_b: Every hole is at the end of a path, so use `while path ahead` before using `while there is a hole`.
        courseD_farmer_conditionals8_c: Notice that you need to repeat the `while path ahead`, `while there is a hole` code six times.
      courseD_farmer_while9_authored_hint: [ ]
      courseD_farmer_while_challenge1_authored_hint:
        courseD_farmer_while_challenge1_a: Each hole or pile is located one space **backward** from the end of the path.
        courseD_farmer_while_challenge1_b: If you use a `while` loop, you can tell the farmer to remove a pile or fill a hole, even if one isn't there. That means you can program her to remove any dirt and fill any hole, while standing in the same place.
        courseD_farmer_conditionals8_c: It is possible to solve this without using any `repeat` loops. To do this, you will need to use four `while` loops.
      courseD_farmer_while_challenge2_authored_hint:
        courseD_farmer_while_challenge1_a: Each hole or pile is located one space **backward** from the end of the path.
        courseD_farmer_while_challenge1_b: If you use a `while` loop, you can tell the farmer to remove a pile or fill a hole, even if one isn't there. That means you can program her to remove any dirt and fill any hole, while standing in the same place.
        courseD_farmer_conditionals8_c: It is possible to solve this without using any `repeat` loops. To do this, you will need to use four `while` loops.
      courseD_harvester_nested_loops_challenge1-broken_authored_hint:
        courseD_harvester_nested_loops_challenge1_a: You have probably already used a loop to create a zig-zag pattern. If you remember that algorithm, you can make a few additions to it here.
      courseD_harvester_nested_loops_challenge1_authored_hint:
        courseD_harvester_nested_loops_challenge1_a: You have probably already used a loop to create a zig-zag pattern. If you remember that algorithm, you can make a few additions to it here.
      courseD_maze_loops_challenge1_authored_hint:
        courseD_bee_nested_loops_challenge1_a: Don't forget that you can `repeat` a single command or a longer pattern. You can even `repeat` a `repeat` block!
        courseD_bee_nested_loops_challenge1_b: To get all 4 gems, first use a loop to move away from the center. Turn left or right, then use a nested loop to move from the first pile of treasure to the second. If you repeat the nested loop enough times, the collector will move around the *entire* cave!
        courseD_bee_nested_loops_challenge1_c: The shortest program that reaches all the treasure uses only one `collect` block and two turns.
      courseD_maze_nestedLoops3_authored_hint:
        courseD_maze_nestedLoops3_a: To solve this puzzle, you will need to "nest" one `repeat` loop inside of another `repeat` loop.
      courseD_maze_nestedLoops4_authored_hint:
        courseD_maze_nestedLoops4_a: |-
          Try using this path through the maze.
          
          ![](https://images.code.org/6a8b4b97a8eef813d8a827b0b7b2d36b-image-1480446509692.05.22.png)
        courseD_maze_nestedLoops4_b: If the loop pattern is hard to see, try coding it all out first and see what things repeat over and over before you put the loops in.
        courseD_maze_nestedLoops4_c: Try using one `repeat` loop inside of another to cut down on the amount of code you need.
      courseD_maze_nestedLoops5_authored_hint:
        courseD_maze_nestedLoops5_a: Look for a stair-step pattern in this maze to find where a nested loop can be used.
      courseD_maze_nestedLoops6_authored_hint:
        courseD_maze_nestedLoops6_a: If you are stuck, try writing out the code out on paper without loops first and look for patterns.
        courseD_maze_nestedLoops6_b: Nesting `repeat` loops can help decrease the number of blocks used.
        courseD_maze_nestedLoops6_c: It will take two sets of nested `repeat` loops to solve this puzzle.
      courseD_maze_ramp1_authored_hint:
        courseC_maze_programming1_0: If the bird isn't getting to the pig, make sure all three of the blocks have been fully clicked together, then click "Run" again.
      courseD_maze_ramp2_authored_hint:
        courseC_maze_programming2_a: To use a `move forward` block, drag it from the toolbox out into the workspace and connect it to the `when run` block.
      courseD_maze_ramp3_authored_hint:
        courseC_maze_programming3_a: "![](https://images.code.org/afddde0e99d5d270c658de0c03dd6e2c-image-1481174000309.gif)\n\nTo delete a block from the middle of your code, drag all of the blocks underneath it away to the right and let them sit in the workspace for a while.  \n\nClick on the block you want to delete, and drag it back to the toolbox.\n\nFinally, put your other blocks back in place where they belong.\n"
      courseD_maze_ramp4_authored_hint:
        courseC_maze_programming4_a: You can turn right or left from the bird's point of view. If you are facing right, turning right will make you point downwards.
        courseC_maze_programming4_b: To follow the path, move forward and turn one way, then move again and turn the opposite way. Move forward one more time to reach the pig.
      courseD_maze_ramp5_authored_hint:
        courseC_maze_programming5_a: Try using the "Step" button to run your code line by line. Can you figure out what you need to do next?
      courseD_maze_ramp6_authored_hint:
        courseC_maze_programming6_a: 有 2 個方法可以完成這個關卡！
        courseC_maze_programming6_b: The bird starts facing a wall, so remember to turn before you move.
      courseD_maze_ramp7_authored_hint:
        courseD_maze_ramp7_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseD_maze_ramp7_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseD_maze_until10_authored_hint: [ ]
      courseD_maze_until10_predict2_authored_hint: [ ]
      courseD_maze_until2_authored_hint:
        courseD_maze_until2_a: An `until pig` loop will help you keep going until you succeed!
      courseD_maze_until2_predict1_authored_hint: [ ]
      courseD_maze_until3_authored_hint:
        courseD_maze_until3_a: |-
          - What does your code do?
          - What is it supposed to do?
          - What does that tell you?
        courseD_maze_until3_b: If you are getting stuck, try writing out the steps on a piece of paper and looking for places where they repeat.
      courseD_maze_until4_authored_hint:
        courseD_maze_until4_a: |-
          Use the "Step" button to go through your code line by line.
          
          - Does everything work at the first step?
          - Does everything work at the second step?
          - Where does it go wrong?
      courseD_maze_until5_authored_hint:
        courseD_maze_until5_a: Don't forget to use `if path to the left` to keep the zombie checking for a place to turn.
      courseD_maze_until6_authored_hint:
        courseD_maze_until6_a: This time, try the `if path to the right` to keep the zombie on track.
      courseD_maze_until7_authored_hint:
        courseD_maze_until7_a: You don't need your code to be any longer, just because the maze is!
      courseD_maze_until8_authored_hint:
        courseD_maze_until8_a: Make sure you're using an `if/else` block to keep the zombie headed the right direction.
      courseD_maze_until9_authored_hint:
        courseD_maze_until8_a: Using `if path ahead` will keep you going forward whenever possible, helping you miss the paths with chompers.
      courseD_maze_until_challenge_authored_hint: [ ]
      courseD_maze_until_challenge1-delete-this-copy_authored_hint: [ ]
      courseD_maze_until_challenge1_authored_hint: [ ]
      courseD_maze_until_challenge2_authored_hint: [ ]
      courseD_playLab_cond1_authored_hint:
        courseD_playLab_cond1_a: To solve this challenge, attach the `move actor 1 up` block to the `when up arrow` event, then do the same for every other direction.
      courseD_playLab_cond2_authored_hint:
        courseD_playLab_cond2_a: To succeed with this puzzle, use the `score point` block beneath the `when actor 1 touches actor 2` event.
      courseD_playLab_cond3_authored_hint:
        courseD_playLab_cond3_a: You will need to add two blocks to your `repeat forever` loop.  One will choose a random emotion for the dragon (actor 2) and the other will wait 1 second before going through the loop again.
        courseD_playLab_cond3_b: 'You will need to use an `if / else` block for the second half of this challenge. '
        courseD_playLab_cond3_c: "`If` the dragon is happy `score point`, `score point`.\n<br/>\n \n`Else` `score point`."
      courseD_playLab_cond3b_authored_hint:
        courseD_playLab_cond3b_a: You will need to add blocks to your `repeat forever` loop to make the dragon continue to move up and down
      courseD_playLab_cond4_authored_hint:
        courseD_playLab_cond4_a: You will want to use the `when run` event to get the ninja to chase the pirate.
        courseD_playLab_cond4_b: There is a special block called `set every masked ninja to chase actor` that will keep the ninja hot on the pirate's trail!
        courseD_playLab_cond4_c: Put the `end game as a loss` block underneath the `when actor 1 touches actor 3` event.
      courseD_playLab_cond5_authored_hint:
        courseD_playLab_cond5_a: Use an `if` statement that compares whether `score` is `>` 5 to solve this challenge.
      courseD_playLab_cond6_authored_hint:
        courseD_playLab_cond6_a: Add the `set masked ninja speed` block to the beginning of the program to help slow the ninja down.
        courseD_playLab_cond6_b: You will need to use an `if actor 1 y position > 255` block inside of a `repeat forever` block to always check if the pirate is below the octopuses.
        courseD_playLab_cond6_c: Add a `wait 1 second` block to the top of the `repeat forever` loop that checks the pirate position (but not inside the `if` statement) to keep points from being removed too quickly.
      courseD_playLab_cond6cloneForTest_authored_hint:
        courseD_playLab_cond6_a: Add the `set masked ninja speed` block to the beginning of the program to help slow the ninja down.
        courseD_playLab_cond6_b: You will need to use an `if actor 1 y position > 255` block inside of a `repeat forever` block to always check if the pirate is below the octopuses.
        courseD_playLab_cond6_c: Add a `wait 1 second` block to the top of the `repeat forever` loop that checks the pirate position (but not inside the `if` statement) to keep points from being removed too quickly.
      courseD_playLab_embedded_authored_hint: [ ]
      courseE_artist_concept1_authored_hint:
        courseE_artist_concept1_a: The hexagons have 50 pixel sides and 60 degree turns to the right.
        courseE_artist_concept1_b: Try using a function here so you don't have to write the code for a hexagon over and over again.
      courseE_artist_concept4_authored_hint:
        courseE_artist_concept4_a: There are several ways to solve this puzzle. Can you make a plan?
        courseE_artist_concept4_b: Try creating one square. Then make a line of squares.  What comes next?
        courseE_artist_concept4_c: After drawing a line of squares, you can either turn around and draw another line of squares going left, or you can jump back to the left side of the figure to draw another line of squares going right. Which do you prefer?
      courseE_artist_functions1_authored_hint:
        courseE_artist_functions1_a: 正方形每邊都有 100 像素，這代表你需要向前移動 175 像素之後才能開始畫第二個正方形。
        courseE_artist_functions1_b: 畫出眼鏡時可以讓你的兩條線重疊沒關係。
      courseE_artist_functions10_authored_hint:
        courseD_artist_functions10_b: This drawing is a lot like the last one, except the function draws a different kind of line.
        courseD_artist_functions10_a: To get around using multiple `move forward` blocks, create a `draw hexagon` function and call that multiple times.
        courseD_artist_functions10_c: |-
          Do you see where this drawing could use a function called `line of hexagons`?
          
          ![](https://images.code.org/904e0f38232fd9c15a3d2d172e7dde0b-image-1493140714580.gif)
      courseE_artist_functions2_authored_hint:
        courseD_artist_functions2_a: |-
          你的程式應該要：
          - 使用函式
          - 向前移動 100 + 75 像素
          - 使用函式
      courseE_artist_functions3_authored_hint:
        courseD_artist_functions3_a: |-
          To solve this puzzle, you just need to add a  loop that repeats the starter code 8 times.
          
          If you can't remember what the starter code was, click "start over" in the upper right corner of the workspace.
      courseE_artist_functions4_authored_hint:
        courseD_artist_functions4_a: Try using a function!
      courseE_artist_functions5_authored_hint:
        courseD_artist_functions5_a: Don't give up!  Remember what you have been learning.
        courseD_artist_functions5_b: Functions make it easy to call saved code at any time, not just from inside a loop!
      courseE_artist_functions6_authored_hint:
        grade4_artist_functions_windows0_a: Focus only on making one window for now.  We'll create a function for it in the next puzzle.
        grade4_artist_functions_windows0_b: Try using nested loops, where the inner loop makes the square and the outer loop rotates the square four times.
      courseE_artist_functions7_authored_hint:
        courseD_artist_functions7_a: Try creating your function first then adding in windows one at a time.
        courseD_artist_functions7_b: You shouldn't need to add any extra repeat loops.  Just jump the artist 100 pixels forward for each top window, and 150 pixels down to get the bottom windows.
      courseE_artist_functions8_authored_hint:
        courseD_artist_functions8_f: You only need one `move forward` block, but you will need quite a few `jump forward` and/or `jump backward` blocks!
        courseD_artist_functions8_a: |-
          Start by making a function for a square, then try making a function for a line of squares.
          
          How would you use the `draw a line of squares` function to make this image?
        courseD_artist_functions8_d: |-
          To make a line of squares,
          - repeat 3 times
          - draw a square with a side length of **50 pixels**
          - jump forward **100 pixels**
        courseD_artist_functions8_b: |-
          Think of each row in this picture as a line of 3 squares. How many lines of squares are there and where do you start drawing each of them?
          
          ![](https://images.code.org/22a6f5cc5551371057244eee01955f8e-image-1493135135468.4.10 Hint Drawing.png)
        courseD_artist_functions8_c: At the end of each line of squares, the artist will need to jump down and backward before he draws the next line of squares.
        courseD_artist_functions8_g: "![](https://images.code.org/c5b48a0db328c6cb32a024d2bf9c00af-image-1493139855549.gif)"
      courseE_artist_functions9_authored_hint:
        courseD_artist_functions9_e: |-
          Can you spot all four places that the `line of triangles` can be used in this drawing?
          
          ![](https://images.code.org/130e1040ecca7186dea87f42666f5620-image-1493140373966.gif)
        courseD_artist_functions9_a: |-
          This puzzle can be broken into three parts:
          - draw a triangle
          - draw a line of triangles
          - draw the diamond made up of lines of triangles
        courseD_artist_functions9_b: This drawing is made by drawing a line of triangles 4 times and turning either 60 or 120 degrees before you draw the next triangle line.
        courseD_artist_functions9_c: |-
          To draw a line of triangles:
          - repeat 4 times
          - draw a triangle
          - jump forward 50 pixels
        courseD_artist_functions9_d: |-
          To draw the diamond:
          - repeat 2 times
          - draw a line of triangles
          - turn 120 degrees
          - draw a line of triangles
          - turn 60 degrees
      courseE_artist_functions_challenge_authored_hint:
        courseE_artist_functions_challenge_a: If you call the function one more time, you can create the same design in the final corner. You can also `jump to` other positions or change the whole thing around however you want!
      courseE_artist_functions_challenge1_authored_hint:
        courseE_artist_functions_challenge1_a: If you call the function one more time, you can create the same design in the final corner. You can also `jump to` other positions or change the whole thing around however you want!
      courseE_artist_functions_challenge2_authored_hint:
        courseE_artist_functions_challenge1_a: "<xml>\n\n  <block type=\"jump_to_xy\">\n    <title name=\"XPOS\">350</title>\n    <title name=\"YPOS\">200</title>\n  </block>\n  </xml>\n  \nThis `jump to` block lets you move the zombie artist to any pixel on the grid, whenever you want. It works by moving him a number of pixels over to the right and a number of pixels down. This is always counted from the top left corner, which it means it doesn't matter where the zombie artist is *before* the command is run!\n\n![](https://images.code.org/b90fdddc778a27e199221271ce91307a-image-1496450976440.png)"
      courseE_artist_functions_predict1_authored_hint: [ ]
      courseE_artist_functions_predict2_authored_hint: [ ]
      courseE_artist_predict1_authored_hint: [ ]
      courseE_artist_ramp10_authored_hint:
        courseD_artist_ramp10_a: 別忘了在每個三角形畫完後轉向 60 度，你要在迴圈裡放置哪些程式積木呢？
      courseE_artist_ramp11_authored_hint:
        courseD_artist_ramp11a: 若要繪製一條邊，請用`移動向前 100 像素`積木，並把 100 改成 200。
        courseD_artist_ramp11b: |-
          若要畫出 4 條邊，可以把`移動-向前 100 像素`積木放到重複迴圈裡，並設定重複次數為 4 次。
      courseE_artist_ramp12_authored_hint:
        courseD_artist_ramp12_a: 你也可以先畫出正方形，然後再畫三角形。調換畫的順序也可以！
      courseE_artist_ramp8_authored_hint:
        courseE_artist_ramp8_a: 若要繪製一條邊，請用`移動向前 100 像素`積木，並把 100 改成 200。
        courseE_artist_ramp8_b: |-
          若要畫出 4 條邊，可以把`移動-向前 100 像素`積木放到重複迴圈裡，並設定重複次數為 4 次。
      courseE_artist_ramp9_authored_hint:
        courseD_artist_ramp12_a: 這和正方形有什麼類似的地方？又有哪些不同呢？
      courseE_bee_concept1_authored_hint:
        courseE_bee_concept1_a: If you don't understand how to use nested loops here, try writing out the instructions step by step on a piece of paper.  Circle the patterns that you see.
      courseE_bee_concept2_authored_hint:
        courseE_bee_concept2_a: An `if` block will help you out in this puzzle.
        courseE_bee_concept2_b: Remember there could be more than one honeycomb under a cloud.
      courseE_bee_concept3_authored_hint:
        courseE_bee_concept3a_a: Try using nested `repeat` loops to solve this puzzle.
      courseE_bee_concept4_authored_hint:
        courseE_bee_concept4_a: An `if/else` statement could really help you out here.
      courseE_bee_concept5_authored_hint:
        courseE_bee_concept5_a: The flowers follow a rectangular path.  You can trace that rectangle using `while path ahead` even with a different number of squares per side.
        courseE_bee_concept5_c: |-
          Here's a picture of a rectangular path the bee could take.
          
          ![](https://images.code.org/b0ab0f9ec823fd8fbc9b032d68fd69d0-image-1493152066638.7.8 Hint Drawing.png)
        courseE_bee_concept5_b: You can check every square for a flower using the `if` block, even if you already know there's not one there.
      courseE_bee_functions1_authored_hint:
        courseE_bee_functions1_a: There is more than one right answer to this puzzle.
      courseE_bee_functions2_authored_hint:
        courseE_bee_functions2_a: The function has been written for you, but you will need to call it at each flower.
      courseE_bee_functions3_authored_hint:
        courseE_bee_functions3_a: 'Your function for this puzzle only needs to collect nectar, it shouldn''t have any `move forward` or `turn` blocks in it. '
      courseE_bee_functions4_authored_hint:
        courseE_bee_functions4_a: Your function will already travel down the side paths and return the bee back to the main road.  You don't need to add that part to your program.
      courseE_bee_functions5_authored_hint:
        courseE_bee_functions5_a: Edit the function so that it solves the puzzle without having to change the main program.
        courseE_bee_functions5_b: "Your function should make the bee: \n- turn\n- move forward\n- collect all of the nectar\n- turn around\n- move back to the main path\n- turn back to the direction that the bee started from"
      courseE_bee_functions6_authored_hint:
        courseE_bee_functions6_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！\n\n![](https://images.code.org/3875224b35889000a0998ca25cfa4ecf-image-1467996493914.gif)"
      courseE_bee_functions7_authored_hint:
        courseE_bee_functions7_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        courseE_bee_functions7_b: |-
          記得要在綠色的函式積木裡建置你的程式。
          
          ![](https://images.code.org/8fe1fae5caf4ede3a9c9bd9f26940cde-image-1467996837459.gif)
        courseE_bee_functions7_c: This function should turn the bee to head him down the path, collect the nectar, make the honey, then turn the bee around and bring him back.
      courseE_bee_functions8_authored_hint:
        courseE_bee_functions8_a: Your function will only need to collect nectar... but this time, you will need to use a `while` loop instead of a `repeat` loop.
        courseE_bee_functions8_b: Use `while nectar > 0` to make sure you get all of the nectar.
      courseE_bee_functions9_authored_hint:
        courseE_bee_functions9_a: You can use the exact same function for this puzzle as you did in the last puzzle.  All you need to do is create a function that collects all of the nectar when you get to each flower.
      courseE_bee_ramp14_authored_hint:
        courseE_bee_ramp14_a: The bee works just like the farmer in the previous puzzle. Buzz along the path and collect nectar if there is nectar, otherwise make honey!
      courseE_bee_ramp17_authored_hint:
        courseE_bee_ramp17_a: Because we don't have a repeat block to do something a certain number of times, what block should we use to get us along the path?
        courseE_bee_ramp17: If you were to solve this puzzle without a while block, where would you see repeated code? How can you use this repeated code to shape how you must use a while block to solve the problem?
      courseE_collector_ramp10_authored_hint:
        courseD_artist_ramp10_a: |-
          替換掉使用四個`移動-向前`積木的方式，改成把`移動-向前`積木放進`重複`迴圈，像這樣：
          <xml><block type="controls_repeat">
          <title name="TIMES">4</title>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          </block></xml>
        courseD_artist_ramp10_b: 別忘了要收集寶藏後，再後在每步之後轉向！
      courseE_farmer_concept1_authored_hint:
        courseE_farmer_concept1_a: A `while there is a hole` block will help you fill any hole until it's flat.
      courseE_farmer_concept2_authored_hint:
        courseE_farmer_concept2_a: The paths are all the same length, but they are a different number of squares apart.  A loop isn't ideal here. Try a function.
      courseE_farmer_concept3_authored_hint:
        grade3_robotFarmer_ConditionalsIntro_8_a: The `while path ahead` block lets you keep going, even if you don't know how many squares are in a path.
      courseE_farmer_concept4_authored_hint:
        4-5_Artist_Patterns_3_a: 每次你試新的積木時，在工具箱拖曳出來請小心別和當前程式攪和在一起。
        4-5_Artist_Patterns_3_b: 如果你的程式變得太雜亂，你可以點擊「重新開始」恢復成原狀，然後重新再一次！
      courseE_farmer_functions10_authored_hint: [ ]
      courseE_farmer_functions10b_authored_hint: [ ]
      courseE_farmer_functions11_predict_authored_hint: [ ]
      courseE_farmer_functions1a_authored_hint:
        courseE_farmer_functions1a_a: Nested `if` and `if/else` statements will really help you out here.
      courseE_farmer_functions2a_authored_hint: [ ]
      courseE_farmer_functions2aALT_authored_hint: [ ]
      courseE_farmer_functions2b_authored_hint:
        courseE_farmer_functions2b_a: Nested `if` and `if/else` statements will  help you out.
        courseE_farmer_functions2b_b: "To check what kind of plant is in the farmer's space, use\n\nif at corn\n - pick corn\n \nelse\n - if at lettuce\n    - pick lettuce\n - else\n    - if there are pumpkins\n       - pick pumpkin"
        courseE_farmer_functions2b_c: You can repeat the code to check the squares for crops in two different `while path ahead` loops.
        courseE_farmer_functions2b_d: |-
          Repeat using a  `while path ahead` for the first 3 paths. Then get to the fourth path and use another `while path ahead` block for the last path.
          
          Remember: you need to move forward and check for plants in your `while path ahead` block.
        courseE_farmer_functions2b_e: |-
          To complete this puzzle use the following blocks:
          
          repeat 3 times
          - while path ahead
          - move forward
          - check for plants (see second hint)
          - turn left
          
          turn right
          
          turn right
          
          while path ahead
          - move forward
          - check for plants (see second hint)
      courseE_farmer_functions3_authored_hint:
        courseE_farmer_functions3_a: Try using a `while path ahead` loop to get you where you need to be.
      courseE_farmer_functions3b_authored_hint:
        courseE_farmer_functions1a_a: Nested `if` and `if/else` statements will really help you out here.
      courseE_farmer_functions3c_authored_hint:
        courseE_farmer_functions3c_a: You will be able to replace TWO sets of code with calls to your `check and pick` function if you build it well.
        courseE_farmer_functions3c_b: |-
          If you're having trouble figuring out what goes into the function, use the "Step" button to run through the code until you get to the first line that checks to see if there's corn.
          
          Drag that conditional (and all of the code inside) into your function definition.
      courseE_farmer_functions4_authored_hint:
        courseE_farmer_functions4_a: Drag all of the code out of your `repeat` loop and into the `go get pumpkins` function.
        courseE_farmer_functions4_b: Don't forget to put the block that calls the `go get pumpkins` functions inside your loop before you run your code.
      courseE_farmer_functions4b_authored_hint: [ ]
      courseE_farmer_functions5_authored_hint: [ ]
      courseE_farmer_functions5a_authored_hint: [ ]
      courseE_farmer_functions5b_authored_hint:
        courseE_farmer_functions5b_a: You will need to use a `while corn` loop, a `while lettuce` and a `while pumpkin` to make sure you get everything.
      courseE_farmer_functions5c_authored_hint:
        courseE_farmer_functions5c_a: A staircase pattern will be helpful here!
      courseE_farmer_functions6_authored_hint: [ ]
      courseE_farmer_functions6b_authored_hint: [ ]
      courseE_farmer_functions6c_authored_hint: [ ]
      courseE_farmer_functions7_authored_hint: [ ]
      courseE_farmer_functions7b_authored_hint:
        courseE_farmer_functions7b_a: You will want to use the `check and pick` function inside your new function to collect all of the produce.
        courseE_farmer_functions7b_b: Each of the side paths are to the left. Your function to take the farmer down these paths will involve checking if there is a path to the left, turning to the left, checking for plants along the path, then turning around and getting back on the main path.
        courseE_farmer_functions7b_c: Once the farmer reaches the end of one of the side paths, she will need to return to the main path. To do this, turn right twice, move to the main path using a `while path ahead` block, then turn to the left to face the right way on the main path.
        courseE_farmer_functions7b_d: To move along the main path, use the `while path ahead` block. Inside this loop, `move forward` and use your function to harvest side paths if there is a path to the left.
      courseE_farmer_functions8_authored_hint:
        courseE_farmer_functions8_a: Create a function that takes the farmer to the corn, gets all of the corn, then turns around and comes back.
      courseE_farmer_functions8b_authored_hint:
        courseE_farmer_functions8b_a: The farmer will reach the pumpkin at the very end of this puzzle, so using the `repeat until at pumpkin` block will be helpful.
        courseE_farmer_functions8b_b: |-
          Just like the last puzzle, think of a main path and side paths. Below is a picture where the main path is the yellow blocks and the side paths are the blue blocks.
          
          ![](https://images.code.org/9b544ac0fca84eead7a0952286284c7b-image-1493151031070.6.10 Hint Drawing.png)
          
          Because all of the side paths are to the left, you can use a function like the one you made from the last puzzle.
        courseE_farmer_functions8b_c: "To finish this puzzle, use the following blocks.\n\nrepeat until at pumpkin\n - while path ahead\n    - move forward\n    - harvest path\n - turn right\n \nHarvest path references the function you made in the last puzzle."
      courseE_farmer_functions9_authored_hint:
        courseE_farmer_functions8_a: Create a function that takes the farmer to the corn, gets all of the corn, then turns around and comes back.
      courseE_farmer_functions9b_authored_hint: [ ]
      courseE_farmer_predict1_authored_hint:
        courseE_farmer_ramp12a: Feel free to go back to the last puzzle if you need a reminder of how to pick produce only **while** there is produce to pick.
      courseE_farmer_predict2_authored_hint: [ ]
      courseE_farmer_ramp11_authored_hint:
        courseE_farmer_ramp11_a: 如果你在編寫迴圈程式時有困難，可以試試先把所有的程式寫出來，然後找找裡面有哪些地方是重複執行的，找到模式（Pattern）把它放到迴圈裡。
        courseE_farmer_ramp11_b: 除了用 5 個`收集生菜`積木之外，要怎麼使用`重複`迴圈來收成生菜呢？
        courseE_farmer_ramp11_c: 你不必用 5 個重複迴圈來收集所有的生菜。我們可以把收集生菜的迴圈（連同`移動-向前`積木一起）放到另一個迴圈裡頭。
      courseE_farmer_ramp11a_authored_hint:
        courseE_farmer_ramp12_a: '除了用`重複`迴圈來告訴農夫要收集生菜多少次，現在我們還可以用`當有生菜時`積木來讓關卡順利完成。'
      courseE_farmer_ramp12_authored_hint:
        courseE_farmer_ramp12_a: '除了用`重複`迴圈來告訴農夫要收集生菜多少次，現在我們還可以用`當有生菜時`積木來讓關卡順利完成。'
        courseE_farmer_ramp12_b: 你還是需要用一個`重複`迴圈包在外面，這樣一來農夫才知道要執行向前走並收集生菜的指令多少次。
      courseE_farmer_ramp12a_authored_hint:
        courseE_farmer_ramp12a: Feel free to go back to the last puzzle if you need a reminder of how to pick produce only **while** there is produce to pick.
      courseE_farmer_ramp13_authored_hint: [ ]
      courseE_farmer_ramp15_authored_hint:
        courseE_farmer_ramp15_a: Use the 'repeat until at pumpkin' block to make it to the end of the path.
        courseE_farmer_ramp15_b: 要沿著路徑移動到南瓜那兒，還需要怎麼做？
      courseE_farmer_ramp16_authored_hint:
        courseE_farmer_ramp16_a: 如果我們要沿著路徑走到南瓜那，我們要重複做什麼？什麼時候要停止重複？
      courseE_maze_predict1_authored_hint: [ ]
      courseE_maze_ramp1_authored_hint:
        courseC_maze_programming1_0: If the bird isn't getting to the pig, make sure all three of the blocks have been fully clicked together, then click "Run" again.
      courseE_maze_ramp13_authored_hint:
        courseD_maze_ramp11_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseD_maze_ramp11_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseE_maze_ramp2_authored_hint:
        courseC_maze_programming2_a: To use a `move forward` block, drag it from the toolbox out into the workspace and connect it to the `when run` block.
      courseE_maze_ramp3_authored_hint:
        courseC_maze_programming3_a: "![](https://images.code.org/afddde0e99d5d270c658de0c03dd6e2c-image-1481174000309.gif)\n\nTo delete a block from the middle of your code, drag all of the blocks underneath it away to the right and let them sit in the workspace for a while.  \n\nClick on the block you want to delete, and drag it back to the toolbox.\n\nFinally, put your other blocks back in place where they belong.\n"
      courseE_maze_ramp4_authored_hint:
        courseC_maze_programming4_a: You can turn right or left from the bird's point of view. If you are facing right, turning right will make you point downwards.
        courseC_maze_programming4_b: To follow the path, move forward and turn one way, then move again and turn the opposite way. Move forward one more time to reach the pig.
      courseE_maze_ramp5_authored_hint:
        courseC_maze_programming5_a: Try using the "Step" button to run your code line by line. Can you figure out what you need to do next?
      courseE_maze_ramp6_authored_hint:
        courseC_maze_programming6_a: 有 2 個方法可以完成這個關卡！
        courseC_maze_programming6_b: Remember to turn first before moving, since the bird starts facing a wall.
      courseE_maze_ramp7_authored_hint:
        courseD_maze_ramp7_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseD_maze_ramp7_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseE_maze_ramp_predict1_authored_hint: [ ]
      courseE_multi_maze_ramp5_authored_hint:
        courseC_maze_programming5_a: Try using the "Step" button to run your code line by line. Can you figure out what you need to do next?
      courseE_playLab_scaffold1_authored_hint:
        courseE_playLab_scaffold1_a: The `set actor 1 to ??? image` block can be used to add an actor to the stage.
      courseE_playLab_scaffold2_authored_hint:
        courseE_playLab_scaffold1_a: Pull on the dropdown menu of the `when ____ arrow` event to change the direction the block controls.
      courseE_playLab_scaffold3_authored_hint:
        courseE_playLab_scaffold3_a: Use a `repeat forever` loop to have extra actors patrol up and down, or left and right for the entire game.
        courseE_playLab_scaffold3_b: If both of your new actors are jumping to random places on the screen, the puzzle may not mark as complete. Try setting one to chase another, or move up and down repeatedly.
      courseF_artist_for1_authored_hint:
        courseF_artist_for1_a: |-
          Can you draw something like this:
          
          ![](https://images.code.org/80ae9ab3e449db1ed4e13c86239f7617-image-1475906794954.06.12.png)
      courseF_artist_for10_authored_hint:
        courseF_artist_for10_a: The image in the drawing was made using a counter for the `set alpha` and `counter` / 10 as a brush size.
        courseF_artist_for10_b: The image in the drawing uses a turn of 61 degrees.
        courseF_artist_for10_c: |-
          Want to know how the sample image was done?
          
          ![](https://images.code.org/fdc5d6c15b357ba9763ac9ea914967a9-image-1475911612774.23.51.png)
      courseF_artist_for10_predict1_authored_hint: [ ]
      courseF_artist_for2_authored_hint:
        courseF_artist_for2_a: |-
          Use `counter` for the length of your triangles inside your `repeat` loop.
          
          ![](https://images.code.org/5e9465321a0b7a4d791848a79f3e6715-image-1475908305872.31.26.png)
        courseF_artist_for2_b: Remember to count by 10 within your for loop.
      courseF_artist_for3_authored_hint:
        courseF_artist_for3_a: |-
          To have the `for` loop drive your movement, make sure that you're using `counter` as your distance in the `move forward` block.
          
          ![](https://images.code.org/15e87fc7fe408cbf1b63e0e8e69b7ffe-image-1475908502078.31.26.png)
      courseF_artist_for4_authored_hint:
        courseF_artist_for4_a: "**需要的數字至少要是多少？\n最大的數字又是多少？\n每循環一次要增加多少？**\n\n這些問題是你每次在使用`計數`迴圈要思考的。"
      courseF_artist_for5_authored_hint:
        courseF_artist_for5_a: You don't need the `repeat` loop inside when making this spiral!
      courseF_artist_for7_authored_hint:
        courseF_artist_for7_a: The pen is thinner in this puzzle. You will need to set it to `1` before you start.
        courseF_artist_for7_b: Notice that this spiral turns right instead of left!
        courseF_artist_for7_c: 這個關卡的`計數迴圈`是從 15 到 300，間隔數為 2。
        courseF_artist_for7_d: 這個圖案是用轉向 89 度做出來的。
      courseF_artist_for8_authored_hint: [ ]
      courseF_artist_for9_authored_hint: [ ]
      courseF_artist_for_challenge1_authored_hint:
        courseF_artist_for_challenge1_a: '`pen width`（筆跡寬度）是 1。而第一個正方形的邊長是 50 像素，每個正方形之間的邊長差了 50 像素。'
        courseF_artist_for_challenge1_b: 筆刷的透明度固定都是 `counter`/2。
        courseF_artist_for_challenge1_c: 在你畫出一個正方形後，別忘了跳回去，轉向，再跳一次，再轉回去！
        courseF_artist_for_challenge1_d: |-
          **Solution:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="draw_width" inline="false">
          <value name="WIDTH">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <next>
          <block type="draw_colour" inline="true" id="draw-color">
          <value name="COLOUR">
          <block type="colour_picker">
          <title name="COLOUR">#0000cd</title>
          </block>
          </value>
          <next>
          <block type="controls_for_counter" inline="true">
          <mutation counter="counter"/>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">50</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">350</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">50</title>
          </block>
          </value>
          <statement name="DO">
          <block type="alpha" inline="true" id="alpha">
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">DIVIDE</title>
          <value name="A">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          </block>
          </value>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="math_number">
          <title name="NUM">4</title>
          </block>
          </value>
          <statement name="DO">
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnRight</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="jump" inline="true">
          <title name="DIR">jumpBackward</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnRight</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          <next>
          <block type="jump" inline="true">
          <title name="DIR">jumpBackward</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnLeft</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseF_artist_for_challenge2_authored_hint:
        courseF_artist_for_challenge2_a: 使用`設定顏色`積木，可以讓顏色改變，使用的是 Rgb 顏色代碼。R（Red，紅）的值固定為 255、G（Green，綠）的值為 `counter`、B（Blue，藍）的值為 `255 - counter`。
        courseF_artist_for_challenge2_b: 這個程式並沒有你想的這麼複雜，只需要設定好`計數迴圈`裡頭的顏色部分，然後向前移動，最後轉向。
        courseF_artist_for_challenge2_c: '這個`計數迴圈`是從 5 算到 250，間隔數是 2。 '
        courseF_artist_for_challenge2_d: |-
          **Solution:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="draw_width" inline="false">
          <value name="WIDTH">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <next>
          <block type="controls_for_counter" inline="true">
          <mutation counter="counter"/>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">5</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">250</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <statement name="DO">
          <block type="draw_colour" inline="true" id="draw-color">
          <value name="COLOUR">
          <block type="colour_rgb" inline="false">
          <value name="RED">
          <block type="math_number">
          <title name="NUM">255</title>
          </block>
          </value>
          <value name="GREEN">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <value name="BLUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">MINUS</title>
          <value name="A">
          <block type="math_number">
          <title name="NUM">255</title>
          </block>
          </value>
          <value name="B">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          </block>
          </value>
          </block>
          </value>
          <next>
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnRight</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">80</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
          
          ![](https://images.code.org/4ce89e8d907f670408c3705f040e8677-image-1497728974326.49.09 PM.png)
      courseF_artist_fwp1_authored_hint:
        courseF_artist_fwp1_c: Put all of the code for drawing a square inside the function editor.
        courseF_artist_fwp1_a: Remember, you need to turn 90 degrees to draw a square.
        courseF_artist_fwp1_b: You only need to repeat as many times as the number of sides in a square.
      courseF_artist_fwp2_authored_hint:
        courseF_artist_fwp2_a: You need to click the "edit" button to get into the function.  Once you're there, add a parameter called `length` and use it inside your `move forward` block!
        courseF_artist_fwp2_b: When calling your function, use a `for loop` for the best possible code!
      courseF_artist_fwp2_predict1_authored_hint: [ ]
      courseF_artist_fwp3_authored_hint:
        courseF_artist_fwp3_a: This gets easier if you put it all in a `for` loop.
        courseF_artist_fwp3_b: |-
          Be sure to turn 90 degrees between each square!
          
          ![](https://images.code.org/97bd8eded03c5aa39740876c8e9f7ff8-image-1469224745277.gif)
      courseF_artist_fwp4_authored_hint:
        courseF_artist_fwp4_b: Remember to **add** a parameter.  Don't remove the one that is already there!
      courseF_artist_fwp5_authored_hint:
        courseF_artist_fwp5_a: The length of sides for each shape is 7 times the number of sides it has.
        courseF_artist_fwp5_b: Don't forget to jump 100 pixels between shapes.
        courseF_artist_fwp5_c: You will need to edit the function a little bit, since your previous function turned the artist to the right after each side, and this image needs a turn to the left.
      courseF_artist_fwp6_authored_hint:
        courseF_artist_fwp6_a: It's okay to run the program a few times to figure out how the function works with different parameters.
        courseF_artist_fwp6_b: You don't need to add any `move` or `turn` blocks to finish this code.
      courseF_artist_fwp7_authored_hint:
        courseF_artist_fwp7_a: 'Did the code get so scrambled up that it''s no longer recognizable?  Try clicking the "Start over" button in the upper right-hand corner. '
        courseF_artist_fwp7_b: Your new `min` variable should go in the first slot in your `for` loop, inside the function.
      courseF_artist_fwp8_authored_hint:
        courseF_artist_fwp8_a: If your function is correct, you shouldn't need to change it for this puzzle.
        courseF_artist_fwp8_b: The only thing you should need to do between function calls is change the color of the line.
      courseF_artist_fwp9_authored_hint:
        courseF_artist_fwp9_a: |-
          試試底下的這些圖案。
          ![](https://images.code.org/eae6d52956c2bc06b90db3693037df36-image-1493739069435.9.13 hints.png)
      courseF_artist_fwp_challenge1_authored_hint: [ ]
      courseF_artist_fwp_challenge2_authored_hint:
        courseF_artist_fwp_challenge1_a: "![](https://images.code.org/9310e6352e85a8265b424c9d57ca28d1-image-1446239776339.gif)"
        courseF_artist_fwp_challenge1_b: '這是一系列的八邊形，計數 `counter` 使用了 `sides` ，並當作每個形狀的邊長。 '
        courseF_artist_fwp_challenge1_c: '每個八邊形都是由每次的循環構成，迴圈的計數方式是從 200 算到 2，間隔數是 2。 '
        courseF_artist_fwp_challenge1_d: '別忘了在每個循環之後轉向 22.5 度。 '
        courseF_artist_fwp_challenge1_e: 每個八邊形的顏色還有線條的寬度是利用 `counter` 變數來控制的。
        courseF_artist_fwp_challenge1_f: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/a82cfea836b95ce6625b08afcc3b7b37-image-1469727289590.png)
      courseF_artist_predict1_authored_hint: [ ]
      courseF_artist_ramp10_authored_hint:
        courseF_artist_ramp10_a: 別忘了在每個三角形畫完後轉向 60 度，你要在迴圈裡放置哪些程式積木呢？
      courseF_artist_ramp8_authored_hint:
        courseF_artist_ramp8_a: 若要繪製一條邊，請用`移動向前 100 像素`積木，並把 100 改成 200。
        courseF_artist_ramp8_b: |-
          若要畫出 4 條邊，可以把`移動-向前 100 像素`積木放到重複迴圈裡，並設定重複次數為 4 次。
      courseF_artist_ramp9_authored_hint:
        courseF_artist_ramp9_a: 這和正方形有什麼類似的地方？又有哪些不同呢？
      courseF_artist_variables2_authored_hint:
        courseF_artist_variables2_a: Remember to move forward after drawing each triangle.
      courseF_artist_variables4_authored_hint:
        courseF_artist_variables4_a: Your code won't be much different than it was in the last puzzle, except that you will need to turn the artist to jump down, then turn him back to get ready to jump forward again.
        courseF_artist_variables4_b: "![](https://images.code.org/fc31a4b60dc86d7b820c2d242f83e6ed-image-1477533361197.gif)"
      courseF_artist_variables5_authored_hint:
        courseF_artist_variables5_a: The second half of your code should look almost the same as the first half, except you will be turning *left*, jumping, then turning *right*.
      courseF_artist_variables6_authored_hint:
        courseF_artist_variables6_a: Thanks to variables, you only need to change one number at the top to make this work.
      courseF_artist_variables6a_authored_hint:
        courseF_artist_variables6a_a: Remember to use the variable `length` instead of an actual number to solve this puzzle.
      courseF_artist_variables8_authored_hint:
        courseF_artist_variables8_a: |
          Try putting the set of ![](https://images.code.org/6525bebee31ee15b84a48761b2866f53-image-1477531948829.31.37.png) blocks inside your loop at the end.
      courseF_artist_variablesFP_authored_hint:
        courseF_artist_variablesFP_a: |-
          試試下方的三個圖案。
          ![](https://images.code.org/f0bac32182162bd26a8031f5aa4364ef-image-1493738360437.3.15 hints.png)
      courseF_artist_variables_4_authored_hint:
        courseF_artist_variables_4_a: Your code won't be much different than it was in the last puzzle, except that you will need to turn the artist to move down, then turn him back to get ready to move forward again.
        courseF_artist_variables_4_b: "![](https://images.code.org/fc31a4b60dc86d7b820c2d242f83e6ed-image-1477533361197.gif)"
      courseF_artist_variables_6_authored_hint:
        courseF_artist_variables_6_a: Thanks to variables, you only need to change one number at the top to make this work.
      courseF_artist_variables_6a_authored_hint:
        courseF_artist_variables6a_a: Remember to use the variable `length` instead of an actual number to solve this puzzle.
      courseF_artist_variables_8_authored_hint:
        courseF_artist_variables_8_a: |
          Try putting the set of ![](https://images.code.org/6525bebee31ee15b84a48761b2866f53-image-1477531948829.31.37.png) blocks inside your loop at the end.
      courseF_artist_variables_challenge1_authored_hint:
        courseF_artist_variables_challenge1_a: Each vertical line has a length of `10`. Each horizontal line should have a length of `length`.
        courseF_artist_variables_challenge1_b: You will want to increase the value of `length` by 10 **twice** inside the loop.
        courseF_artist_variables_challenge1_c: To complete the pattern you will need to turn left twice, turn right twice, and move forward a total of four times.
        courseF_artist_variables_challenge1_d: |-
          This puzzle just uses one loop. Without any variables, a similar path might just be a zig-zag.
          
          ![](https://images.code.org/664fdd219502d004fb07886f834fa3d5-image-1496868743379.51.36 PM.png)
          
          If you are having trouble, start by creating this image, then try to see where you can use variables to change the length of the horizontal lines.
        courseF_artist_variables_challenge1_e: |-
          Here is the solution.
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="variables_set" inline="false">
          <title name="VAR">length</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="math_number">
          <title name="NUM">18</title>
          </block>
          </value>
          <statement name="DO">
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnRight</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          <next>
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="variables_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <next>
          <block type="variables_set" inline="false">
          <title name="VAR">length</title>
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">ADD</title>
          <value name="A">
          <block type="variables_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnLeft</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          <next>
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnLeft</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          <next>
          <block type="draw_move" inline="true">
          <title name="DIR">moveForward</title>
          <value name="VALUE">
          <block type="variables_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <next>
          <block type="variables_set" inline="false">
          <title name="VAR">length</title>
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">ADD</title>
          <value name="A">
          <block type="variables_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          </block>
          </value>
          <next>
          <block type="draw_turn" inline="true">
          <title name="DIR">turnRight</title>
          <value name="VALUE">
          <block type="math_number">
          <title name="NUM">90</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseF_artist_variables_challenge1a_authored_hint:
        courseF_artist_variables_challenge1_a: '變數非常有用，因為你每循環一次就可以加一個數值上去。 '
        courseF_artist_variables_challenge1_b: 這個關卡有個畫出多邊形的迴圈，一個用來重複多邊形 `sides` 次，另一個在 `sides` 加上 5 以後再做一次。
        courseF_artist_variables_challenge1_c: 使用變數，`sides` 代表邊數，`length` 代表長度，用它們可以編寫出簡潔的程式，因為我們可以透過迴圈來執行相同的程式多次，這樣一來，模式相同但數字不同的程式就不需要編寫好多次。
        courseF_artist_variables_challenge1_d: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/311b4a946cb8f3b4144b5075be6460a3-image-1469641878222.png)
      courseF_artist_variables_challenge2_authored_hint:
        courseF_artist_variables_challenge2_a: '變數非常有用，因為你每循環一次就可以加一個數值上去。 '
        courseF_artist_variables_challenge2_b: 這個關卡有個畫出多邊形的迴圈，一個用來重複多邊形 `sides` 次，另一個在 `sides` 加上 5 以後再做一次。
        courseF_artist_variables_challenge2_c: 使用變數，`sides` 代表邊數，`length` 代表長度，用它們可以編寫出簡潔的程式，因為我們可以透過迴圈來執行相同的程式多次，這樣一來，模式相同但數字不同的程式就不需要編寫好多次。
        courseF_artist_variables_challenge2_d: |-
          **解決方案：**
          
          ![Solution](https://images.code.org/311b4a946cb8f3b4144b5075be6460a3-image-1469641878222.png)
      courseF_bee_conditionals1_predict1_authored_hint: [ ]
      courseF_bee_conditionals2_authored_hint:
        courseF_bee_conditionals2_a: Sometimes a flower will be there, sometimes it won't.  If you want your code to run in both cases, make sure to use an `if` statement.
      courseF_bee_conditionals3_authored_hint:
        courseF_bee_conditionals3_a: Be sure to use an `if` statement to check each space to see if it has either a flower or nothing.
      courseF_bee_conditionals4_authored_hint:
        courseD_bee_conditionals4_a: You can still treat every space as if there is a cloud over it, even though you can see the whole path.
        courseF_bee_conditionals4_b: 'Use an `if` statement inside your loop to check each space for nectar. '
        courseF_bee_conditionals4_c: Using the block `while there is a path ahead`, you should `move forward` and check for a flower. `if there is a flower` what should the bee do?
      courseF_bee_conditionals5_authored_hint:
        courseF_bee_conditionals5_a: Think of every side of the rectangular path as a path by itself. Set up a nested loop with a `repeat` block on the outside and a `while there is a path ahead` on the inside. How many paths does the bee need to buzz down if the bee needs to buzz every side with a flower?
        courseF_bee_conditionals5_b: Inside the `while there is a path ahead` block, you will need to move forward and check for a flower. How do you check if there is a flower? What do you do if there is a flower?
        courseF_bee_conditionals5_c: There are 3 sides of the rectangle with flowers, so the code needs to `repeat 3 times`. In every repeat, the bee will need to continue along the path, `while there is a path ahead`. To continue down the path, the bee will need to `move forward`. While on the path, the bee needs to check for a flower. `if there is a flower`, the bee should `get nectar`.
      courseF_bee_conditionals7_predict2_authored_hint: [ ]
      courseF_bee_conditionals8_authored_hint:
        courseF_bee_conditionals8_a: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
        courseF_bee_conditionals8_b: |-
          This puzzle is tricky, because you can't check blank squares, nectar, *and* honey with just one single conditional.
          
          Only check for nectar and honey at the end of your path.
      courseF_bee_for1_authored_hint:
        courseF_bee_for1_a: A loop will help you here.
      courseF_bee_for10_authored_hint:
        courseF_bee_for10_a: Can you find a pattern between the number of steps you need to take and the number of nectars to gather?
        courseF_bee_for10_b: The first set of flowers has a total of **14 flowers**. To get to this first set, the bee must buzz down 7 squares, or **14 divided by 2 squares**. How many flowers are in the next set and how many squares will be the bee have to travel to get there?
        courseF_bee_for10_c: "In the puzzle, the first set of flowers has **14** flowers, the second set has **10** flowers, third set has **6** flowers, and the fourth set has **2** flowers.\n\nIn this drawing, notice there are **7** red squares, **5** orange squares, **3** green squares, and **1** blue block. \n\n![](https://images.code.org/602ce14659299af6a59a79ebd0bdb9d4-image-1493221855089.6.11 Hint Drawing.png)\n\nHow do the numbers relate?"
        courseF_bee_for10_d: You'll need to have 2 repeats, one will use a math block.
      courseF_bee_for11_authored_hint:
        courseF_bee_for11_a: "How much less is 12 than 15?  \nHow much less is 9 than 12?\n\nDo you see a pattern?"
      courseF_bee_for2_authored_hint:
        courseF_bee_for2_a: You'll need to use at least three loops (one after another) to solve this puzzle.
      courseF_bee_for3_authored_hint:
        courseF_bee_for3_a: 'Use the `counter` variable inside the `repeat` loop where nectar is gathered to solve this puzzle. '
        courseF_bee_for3_b: Your `for` loop will need to count from 1 to 5 with an increment of 1.
      courseF_bee_for3_predict1_authored_hint: [ ]
      courseF_bee_for4_authored_hint:
        courseF_bee_for4_a: Use a `for` loop that goes from 1 to 7 with an increment of 1 to solve this puzzle.
        courseF_bee_for4_b: Make sure to use the `counter` variable inside your nested `repeat` loop to get enough nectar!
      courseF_bee_for5_authored_hint:
        courseF_bee_for5_a: This time, your `move forward` block and your `get nectar` block will need to be in separate `repeat` loops, both inside the same `for` loop.
      courseF_bee_for6_authored_hint:
        courseF_bee_for6_a: Don't forget to use a `counter` variable inside your `repeat` loop.
      courseF_bee_for7_authored_hint:
        courseF_bee_for7_a: Your `for` loop will need to count from 1 to 7 by 2.
      courseF_bee_for8_authored_hint:
        courseF_bee_for8_a: "If your loop is counting up, the increment is added to your counter variable each time through. \n\nWhat do you need to add to each number to get the next amount of nectar?"
      courseF_bee_for9_authored_hint:
        courseF_bee_for9_a: |-
          Try doing some math with the counter variable.
          
          What do you have to do to the counter at each flower to equal the amount of nectar you need to collect?
        courseF_bee_for9_c: It looks like you will need to turn the bee at the beginning of each loop iteration if you want to solve the puzzle.
        courseF_bee_for9_b: "**Remember:** If your loop is counting up, the increment is added to your `counter` variable each time through."
      courseF_bee_for_challenge1_authored_hint: [ ]
      courseF_bee_for_challenge2_authored_hint:
        courseF_bee_for_challenge2_a: "看看可用的移動方式：\n\n![](https://images.code.org/07fa7bdbbaaae3ecf2663a360b3e87d7-image-1469726373660.png)"
        courseF_bee_for_challenge2_b: 試著使用 2 個`計數`迴圈：一個用來往上爬然後採集花蜜，另一個則是往下爬然後釀造蜂蜜。
        courseF_bee_for_challenge2_c: "注意一個`計數`迴圈裡頭需要數個規律的重複積木，以重複 `counter` 次來製作出樓梯的模式。\n\n其它的`計數`迴圈只需要一個普通的重複積木以收集到 `counter` 個蜂蜜。"
        courseF_bee_for_challenge2_d: |-
          **Solution:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">3</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_nectar"/>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward">
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="maze_moveForward">
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_honey"/>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseF_bee_for_challenge3_authored_hint:
        courseF_bee_for_challenge2_a: "看看可用的移動方式：\n\n![](https://images.code.org/07fa7bdbbaaae3ecf2663a360b3e87d7-image-1469726373660.png)"
        courseF_bee_for_challenge2_b: 試著使用 2 個`計數`迴圈：一個用來往上爬然後採集花蜜，另一個則是往下爬然後釀造蜂蜜。
        courseF_bee_for_challenge2_c: "注意一個`計數`迴圈裡頭需要數個規律的重複積木，以重複 `counter` 次來製作出樓梯的模式。\n\n其它的`計數`迴圈只需要一個普通的重複積木以收集到 `counter` 個蜂蜜。"
        courseF_bee_for_challenge2_d: |-
          **Solution:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">3</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_nectar"/>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward"/>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">10</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_moveForward">
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="maze_moveForward">
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_honey"/>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </xml>
      courseF_bee_functions2_authored_hint:
        courseF_bee_functions2_a: The function has been written for you, but you will need to call it at each flower.
      courseF_bee_functions3_authored_hint:
        courseF_bee_functions3_a: 'Your function for this puzzle only needs to make honey, it shouldn''t have any `move forward` or `turn` blocks in it. '
      courseF_bee_functions3a_authored_hint:
        courseF_bee_functions3a_a: 'Your function for this puzzle only needs to get nectar or make honey, it shouldn''t have any `move forward` or `turn` blocks in it. '
        courseF_bee_functions3a_b: Use a stairstep pattern to check the first four clouds.
      courseF_bee_functions4_authored_hint:
        courseF_bee_functions4_a: Your function should travel down the side paths and return the bee back to the main road.  You don't need to add that part to your main program.
      courseF_bee_functions5_authored_hint:
        courseE_bee_functions5_a: Edit the function so that it solves the puzzle without having to change the main program.
        courseE_bee_functions5_b: "Your function should make the bee: \n- turn\n- move forward\n- collect all of the nectar\n- turn around\n- move back to the main path\n- turn back to the direction that the bee started from"
      courseF_bee_functions5a_authored_hint:
        courseF_bee_functions5a_a: "Your function should check if there's a path to the right, and if there is, travel down the side paths and return the bee back to the main road.  \n\nYou don't need to add that part to your main program."
      courseF_bee_functions6_authored_hint:
        courseF_bee_functions6_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！\n\n![](https://images.code.org/3875224b35889000a0998ca25cfa4ecf-image-1467996493914.gif)"
      courseF_bee_functions7_authored_hint:
        courseF_bee_functions7_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        courseF_bee_functions7_b: |-
          記得要在綠色的函式積木裡建置你的程式。
          
          ![](https://images.code.org/8fe1fae5caf4ede3a9c9bd9f26940cde-image-1467996837459.gif)
        courseF_bee_functions7_c: This function should turn the bee to head him down the path, collect the nectar, make the honey, then turn the bee around and bring him back.
      courseF_bee_functions8a_authored_hint:
        courseF_bee_functions8a_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        courseF_bee_functions8a_b: |+
          Remember to build code inside of the function editor.
      courseF_bee_functions_challenge1_authored_hint:
        courseF_bee_functions_challenge1_a: You can use the functions in the tool box to help you. You can call a function inside of another function's definition!
      courseF_bee_functions_challenge2_authored_hint:
        courseF_bee_functions_challenge2_a: |-
          If there is a path to the right, you should do the following:
          * Get any nectar or make any honey.
          * Turn right towards the side path.
          * Move to the end of the side path.
          * Turn right.
          
          If you repeat the above actions twice, you will be ready to move back down the main path.
          
          **Only click for another hint if you want to see the full solution!**
        courseF_bee_functions_challenge2_b: |-
          **Solution:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="math_number">
          <title name="NUM">4</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_untilBlocked">
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="maze_if">
          <title name="DIR">isPathRight</title>
          <statement name="DO">
          <block type="procedures_callnoreturn" id="function">
          <mutation name="move and check"/>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          <block type="procedures_defnoreturn" editable="false" usercreated="true">
          <mutation/>
          <title name="NAME">check nectar or honey</title>
          <statement name="STACK">
          <block type="bee_ifElseFlower">
          <title name="LOC">atFlower</title>
          <statement name="DO">
          <block type="bee_whileNectarAmount">
          <title name="ARG1">nectarRemaining</title>
          <title name="OP">&gt;</title>
          <title name="ARG2">0</title>
          <statement name="DO">
          <block type="maze_nectar"/>
          </statement>
          </block>
          </statement>
          <statement name="ELSE">
          <block type="bee_whileNectarAmount">
          <title name="ARG1">honeyAvailable</title>
          <title name="OP">&gt;</title>
          <title name="ARG2">0</title>
          <statement name="DO">
          <block type="maze_honey"/>
          </statement>
          </block>
          </statement>
          </block>
          </statement>
          </block>
          <block type="procedures_defnoreturn" deletable="false" movable="false" editable="false">
          <mutation/>
          <title name="NAME">move and check</title>
          <statement name="STACK">
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="math_number">
          <title name="NUM">2</title>
          </block>
          </value>
          <statement name="DO">
          <block type="procedures_callnoreturn">
          <mutation name="check nectar or honey"/>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          <next>
          <block type="maze_untilBlocked">
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </statement>
          </block>
          </xml>
      courseF_bee_functions_challenge2_recursion_authored_hint:
        courseF_bee_functions8a_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        courseF_bee_functions8a_b: |+
          Remember to build code inside of the function editor.
      courseF_bee_fwp1_authored_hint:
        courseF_bee_fwp1_a: Use `if` statements to make sure you're only getting nectar from a flower.
        courseF_bee_fwp1_b: Continue along the path using a `repeat` block. Make sure you are using a `move forward` block and checking if there is a flower using a `if` statement.
      courseF_bee_fwp2_authored_hint:
        courseF_bee_fwp2_a: "To turn this into a function, simply drag the code into the existing function block.  \n\n\n![](https://images.code.org/4d918c677ecb9f1618c1556566805b32-image-1477621874625.gif)"
        courseF_bee_fwp2_b: Don't forget to connect the `rowOfNectar` block to `when run` to call the function that you just built.
      courseF_bee_fwp3_authored_hint:
        courseF_bee_fwp3_a: Your function will run no matter which direction you're facing.
        courseF_bee_fwp3_b: There are 3 rows of nectar, what kind of turns and movements do you need to make between each row?
        courseF_bee_fwp3_c: To solve this puzzle, you'll need to call your function 3 times. In between each call, you need to `turn right`, `move forward` 2 times, then `turn right` again. OR, you need to `turn left`, `move forward` 2 times, then `turn left` again.
      courseF_bee_fwp4_authored_hint:
        courseF_bee_fwp4_a: You will need to add a parameter and use the resulting variable in your loop.
        courseF_bee_fwp4_b: The parameter you create for your function will be used to in the repeat loop to determine how many times the bee will move forward and check for nectar.
      courseF_bee_fwp5_authored_hint:
        courseF_bee_fwp5_a: Count the number of spaces you need to check in each stretch and use those numbers as your parameters to the function call.
      courseF_bee_fwp6_authored_hint:
        courseF_bee_fwp6_a: Which block automatically increments a variable that you could use as a parameter?
        courseF_bee_fwp6_b: Try using a `for` loop to solve this puzzle.
      courseF_bee_fwp7_authored_hint:
        courseF_bee_fwp7_a: You don't need a second parameter for this function, only a second `if` statement.
        courseF_bee_fwp7_b: Add an `if` statement in your function so the bee checks for both honeycombs and flowers.
      courseF_bee_fwp8_authored_hint:
        courseF_bee_fwp8_a: How could a `for` loop help in this puzzle?
      courseF_bee_fwp9_authored_hint: [ ]
      courseF_bee_fwp9_predict1_authored_hint: [ ]
      courseF_bee_fwp_challenge1_authored_hint:
        courseF_bee_fwp_challenge1_a: |-
          The main program should look something like this:
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="procedures_callnoreturn" inline="false">
          <mutation name="pick row">
          <arg name="length"/>
          </mutation>
          <value name="ARG0">
          <block type="math_number">
          <title name="NUM">3</title>
          </block>
          </value>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="procedures_callnoreturn" inline="false">
          <mutation name="pick row">
          <arg name="length"/>
          </mutation>
          <value name="ARG0">
          <block type="math_number">
          <title name="NUM">5</title>
          </block>
          </value>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="procedures_callnoreturn" inline="false">
          <mutation name="pick row">
          <arg name="length"/>
          </mutation>
          <value name="ARG0">
          <block type="math_number">
          <title name="NUM">6</title>
          </block>
          </value>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="procedures_callnoreturn" inline="false">
          <mutation name="pick row">
          <arg name="length"/>
          </mutation>
          <value name="ARG0">
          <block type="math_number">
          <title name="NUM">4</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block></xml>
        courseF_bee_fwp_challenge1_b: |-
          Look at how much corn is available to harvest in each space. Do you see the counter pattern? The `length` parameter should be used to set the maximum value in the `for loop`.
          
          Don't forget to have the farmer move back to the main path after harvesting!
        courseF_bee_fwp_challenge1_c: |-
          Place a `for loop` inside a function and set it to count from `1` to `length` by `1`.
          Inside this loop, you should move forward and pick all of the corn.
          
          <xml>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="parameters_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          </statement>
          </block></xml>
        courseF_bee_fwp_challenge1_d: |-
          Inside the `for loop` you will want to `move forward` then `get nectar` **counter times**.
          After the `for loop` you can just `move backward` **length times**.
          
          You may need to read this hint several times to understand it. The part in **bold** is a hint about how to use the two `repeat` loops you will need.
        courseF_bee_fwp_challenge1_e: |
          **Here is the solution:**
          
          <xml>
          <block type="procedures_defnoreturn" editable="false" usercreated="true">
          <mutation>
          <arg name="length"/>
          </mutation>
          <title name="NAME">pick row</title>
          <statement name="STACK">
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="parameters_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="harvester_corn"/>
          </statement>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="parameters_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveBackward</title>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block></xml>
      courseF_bee_fwp_challenge2_authored_hint:
        courseF_bee_fwp_challenge2_a: |-
          Start by making sure you understand how this function is *supposed* to work. As the farmer moves down each path, she will only try to collect corn. Instead, how can you make her check for each of the 3 vegetables and pick only the one she finds?
          
          Add conditional statements to the function to check for corn, pumpkins, and lettuce.
        courseF_bee_fwp_challenge2_b: "Are you running out of `move forward` blocks?\nTry using a *second* `for loop` in your main program. \n\n**Note:** Be careful not to confuse `counter` with `counter2` in your code."
        courseF_bee_fwp_challenge2_c: |-
          **Here is what your function should look like:**
          
          <xml><block type="procedures_defnoreturn" deletable="false" movable="false" editable="false" usercreated="true">
          <mutation>
          <arg name="length"/>
          </mutation>
          <title name="NAME">pick row</title>
          <statement name="STACK">
          <block type="maze_turn">
          <title name="DIR">turnLeft</title>
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="parameters_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="variables_get">
          <title name="VAR">counter</title>
          </block>
          </value>
          <statement name="DO">
          <block type="harvester_ifAtCrop">
          <title name="LOC">Corn</title>
          <statement name="DO">
          <block type="harvester_corn"/>
          </statement>
          <next>
          <block type="harvester_ifAtCrop">
          <title name="LOC">Pumpkin</title>
          <statement name="DO">
          <block type="harvester_pumpkin"/>
          </statement>
          <next>
          <block type="harvester_ifAtCrop">
          <title name="LOC">Lettuce</title>
          <statement name="DO">
          <block type="harvester_lettuce"/>
          </statement>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block>
          </statement>
          <next>
          <block type="controls_repeat_ext" inline="true">
          <value name="TIMES">
          <block type="parameters_get">
          <title name="VAR">length</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveBackward</title>
          </block>
          </statement>
          <next>
          <block type="maze_turn">
          <title name="DIR">turnRight</title>
          </block>
          </next>
          </block>
          </next>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </xml>
        courseF_bee_fwp_challenge2_d: |
          **Here is what your main program should look like:**
          
          <xml>
          <block type="when_run" deletable="false" movable="false">
          <next>
          <block type="controls_for" inline="true">
          <title name="VAR">counter2</title>
          <value name="FROM">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TO">
          <block type="math_number">
          <title name="NUM">6</title>
          </block>
          </value>
          <value name="BY">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <statement name="DO">
          <block type="maze_move">
          <title name="DIR">moveForward</title>
          <next>
          <block type="procedures_callnoreturn" inline="false">
          <mutation name="pick row">
          <arg name="length"/>
          </mutation>
          <value name="ARG0">
          <block type="variables_get">
          <title name="VAR">counter2</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          </statement>
          </block>
          </next>
          </block></xml>
      courseF_farmer_ramp11_authored_hint:
        courseF_farmer_ramp11_a: 如果你在編寫迴圈程式時有困難，可以試試先把所有的程式寫出來，然後找找裡面有哪些地方是重複執行的，找到模式（Pattern）把它放到迴圈裡。
        courseF_farmer_ramp11_b: 除了用 5 個`收集生菜`積木之外，要怎麼使用`重複`迴圈來收成生菜呢？
        courseF_farmer_ramp11_c: 你不必用 5 個重複迴圈來收集所有的生菜。我們可以把收集生菜的迴圈（連同`移動-向前`積木一起）放到另一個迴圈裡頭。
      courseF_maze_predict1_authored_hint: [ ]
      courseF_maze_ramp1_authored_hint:
        courseF_maze_ramp1_a: If the bird isn't getting to the pig, make sure all of the blocks have been fully clicked together, then click "Run" again.
      courseF_maze_ramp13_authored_hint:
        courseF_maze_ramp13_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseF_maze_ramp13_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseF_maze_ramp15_authored_hint:
        courseF_maze_ramp7_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseF_maze_ramp7_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseF_maze_ramp2_authored_hint:
        courseF_maze_ramp2_a: To use a new block, drag it from the toolbox out into the workspace and connect it to the program that is attached to the `when run` block.
      courseF_maze_ramp4_authored_hint:
        courseF_maze_ramp4_a: You can turn right or left from the bird's point of view. If you are facing right, turning right will make you point downwards.
        courseF_maze_ramp4_b: To follow the path, move forward and turn one way, then move three times before turning the opposite way. Move forward one more time to reach the pig.
      courseF_maze_ramp5_authored_hint:
        courseF_maze_ramp5_a: Try using the "Step" button to run your code line by line. Can you figure out what you need to do next?
      courseF_maze_ramp6_authored_hint:
        courseF_maze_ramp6_a: 有 2 個方法可以完成這個關卡！
      courseF_maze_ramp7_authored_hint:
        courseF_maze_ramp7_b: Don't forget to use the "Step" button to go through block by block and look for errors.
        courseF_maze_ramp7_a: 使用重複積木來不停的運作同一個或是多個指令。
      courseF_playlab_variables1a_authored_hint:
        courseF_playlab_variables1a_a: Put the word "Goal!" inside the green block that is connected to the purple `set shout to` block.
      courseF_playlab_variables3b_authored_hint:
        courseF_playlab_variables3b_a: The variable blocks are already in the workspace.  All you have to do is put them where they belong!
      courseF_playlab_variables3bEdit_authored_hint:
        courseF_playlab_variables3b_a: The variable blocks are already in the workspace.  All you have to do is put them where they belong!
      courseF_playlab_variables3b_josh_authored_hint:
        courseF_playlab_variables3b_a: The variable blocks are already in the workspace.  All you have to do is put them where they belong!
      courseF_playlab_variables7b_authored_hint:
        courseF_playlab_variables7b_a: Have a cat and a dog talk about their favorite foods. Use the ask block to find out the favorite food, then display the text to the screen!
        courseF_playlab_variables7b_b: Have your favorite character ask if you want to hear a joke. If the answer is yes, display a joke to the screen.
      courseF_playlab_variables_challenge1_authored_hint:
        courseF_playlab_variables_challenge1_a: |-
          You will need additional blocks from the tool box to get the actors to talk.
          <xml><block type="studio_saySpriteParamsTime" inline="true">
          <value name="SPRITE">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          <value name="TEXT">
          <block type="text">
          <title name="TEXT">Knock knock.</title>
          </block>
          </value>
          <value name="TIME">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          </block></xml>
      courseF_playlab_variables_challenge2_authored_hint:
        courseF_playlab_variables_challenge2_a: 'Add and subtract points to the `score` variable when sprites collide. '
        courseF_playlab_variables_challenge2_b: 在每次方向鍵點擊時，你可以將參數改成角色移動的距離。
        courseF_playlab_variables_challenge2_c: |-
          **Solution:**
          
          <xml>
          <block type="studio_whenArrow">
          <title name="VALUE">up</title>
          <next>
          <block type="studio_moveDistanceParams" inline="true">
          <title name="SPRITE">0</title>
          <title name="DIR">1</title>
          <value name="DISTANCE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenArrow">
          <title name="VALUE">down</title>
          <next>
          <block type="studio_moveDistanceParams" inline="true">
          <title name="SPRITE">0</title>
          <title name="DIR">4</title>
          <value name="DISTANCE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenArrow">
          <title name="VALUE">left</title>
          <next>
          <block type="studio_moveDistanceParams" inline="true">
          <title name="SPRITE">0</title>
          <title name="DIR">8</title>
          <value name="DISTANCE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenArrow">
          <title name="VALUE">right</title>
          <next>
          <block type="studio_moveDistanceParams" inline="true">
          <title name="SPRITE">0</title>
          <title name="DIR">2</title>
          <value name="DISTANCE">
          <block type="math_number">
          <title name="NUM">25</title>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenSpriteCollided">
          <title name="SPRITE1">0</title>
          <title name="SPRITE2">1</title>
          <next>
          <block type="studio_setScore" inline="false">
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">ADD</title>
          <value name="A">
          <block type="studio_getScore"/>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">3</title>
          </block>
          </value>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenSpriteCollided">
          <title name="SPRITE1">0</title>
          <title name="SPRITE2">2</title>
          <next>
          <block type="studio_setScore" inline="false">
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">ADD</title>
          <value name="A">
          <block type="studio_getScore"/>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">3</title>
          </block>
          </value>
          </block>
          </value>
          </block>
          </next>
          </block>
          <block type="studio_whenSpriteCollided">
          <title name="SPRITE1">1</title>
          <title name="SPRITE2">2</title>
          <next>
          <block type="studio_setScore" inline="false">
          <value name="VALUE">
          <block type="math_arithmetic" inline="true">
          <title name="OP">MINUS</title>
          <value name="A">
          <block type="studio_getScore"/>
          </value>
          <value name="B">
          <block type="math_number">
          <title name="NUM">1</title>
          </block>
          </value>
          </block>
          </value>
          </block>
          </next>
          </block>
          </xml>
      coursef_maze_ramp3_authored_hint:
        courseF_maze_ramp3_a: "![](https://images.code.org/afddde0e99d5d270c658de0c03dd6e2c-image-1481174000309.gif)\n\nTo delete a block from the middle of your code, drag all of the blocks underneath it away to the right and let them sit in the workspace for a while.  \n\nClick on the block you want to delete, and drag it back to the toolbox.\n\nFinally, put your other blocks back in place where they belong.\n"
      drawings!_authored_hint:
        triangle_geometry_hint: 請記住：一個正三角形有 3 條等長的邊，每個角是 60 度！
        repeat_pointer: 你要畫出一條邊，然後轉向，共做 3 次…要執行一連串的指令多次，可以用什麼積木呢？
        repeat_bottom_out: 使用一個`重複 3 次`積木！
      grade1_adventurer_loops10_authored_hint:
        grade1_adventurer_loops10_a: 你需要使用 3 個`重複`迴圈才能完成這個關卡。
      grade1_adventurer_loops2_authored_hint:
        grade1_adventurer_loops2_a: Try using a `repeat` block to collect your gold.
      grade1_adventurer_loops3_authored_hint:
        grade1_adventurer_loops3_a: Is something not right? Try using the step button to figure out where things go wrong.
      grade1_adventurer_loops4_authored_hint:
        grade1_adventurer_loops4_a: Try using more than one loop to get the job done.
      grade1_adventurer_loops5_authored_hint:
        grade1_adventurer_loops5_a: Can't figure out where things start going wrong? Use the "Step" button to run through your program one block at a time.
      grade1_adventurer_loops6_authored_hint:
        grade1_adventurer_loops6_a: If you are having a hard time with the puzzle, try drawing it on paper to help you figure it out.
      grade1_adventurer_loops7_challenge_authored_hint:
        grade1_adventurer_loops7_challenge_a: 'If you can''t figure out where to put the repeat loops, program it out step-by-step and look for a pattern. '
        grade1_adventurer_loops7_challenge_b: Does the code feel a little long?  You can make it much shorter by moving two of your `repeat` loops inside of another loop.
      grade1_adventurer_loops8_challenge_authored_hint:
        grade1_adventurer_loops8_challenge_a: Can you find a pattern in the steps?  Where can you use a repeat?
      grade1_adventurer_loops9_authored_hint:
        grade1_adventurer_loops9_a: |
          Does this seem too hard?  Break it up into 4 little problems to make it feel easier.
      grade1_artist_loops1_authored_hint:
        grade1_artist_loops1_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      grade1_artist_loops2_authored_hint:
        grade1_artist_loops2_a: Remember to use a `repeat` loop for better code!
      grade1_artist_loops3_authored_hint: [ ]
      grade1_artist_loops4_authored_hint:
        grade1_artist_loops4_a: Drag out a `repeat` loop, then put the other blocks inside of it. How many times do you need to repeat?
      grade1_artist_loops5_authored_hint: [ ]
      grade1_artist_loops6_authored_hint:
        grade1_artist_loops6_a: 這個挑戰用了 4 個迴圈，一個接著一個！
        grade1_artist_loops6_b: |-
          Notice that every loop makes a stair pattern that travels in a different direction.
          
          ![](https://images.code.org/7d08d5514766c5c15074e90731991505-image-1466705649513.gif)
        grade1_artist_loops6_c: "The loops should do this:\n- Loop 1\n  - Right\n  - Down\n  \n- Loop 2\n  - Right\n  - Up\n\n- Loop 3\n  - Left\n  - Up\n\n- Loop 4\n  - Left\n  - Down"
      grade1_artist_loops7_authored_hint: [ ]
      grade1_artist_loops7a_authored_hint:
        artistLoopsK9_a: 這個挑戰用了 4 個迴圈，一個接著一個！
        artistLoopsK9_b: |-
          Notice that every loop makes a stair pattern that travels in a different direction.
          
          ![](https://images.code.org/7d08d5514766c5c15074e90731991505-image-1466705649513.gif)
        artistLoopsK9_c: "The loops should do this:\n- Loop 1\n  - Right\n  - Down\n  \n- Loop 2\n  - Right\n  - Up\n\n- Loop 3\n  - Left\n  - Up\n\n- Loop 4\n  - Left\n  - Down"
      grade1_artist_loops7b_authored_hint:
        grade1_artist_loops7b_a: How many times should you repeat the pattern to make the ladder?
      grade1_artist_loops8_authored_hint: [ ]
      grade1_artist_loops9_authored_hint: [ ]
      grade1_artist_loopsFP_authored_hint: [ ]
      grade1_maze_sequence1_authored_hint:
        grade1_maze_sequence1_a: This program is missing one block. Can you figure out which one?
      grade1_maze_sequence10_authored_hint:
        grade1_maze_sequence10_a: If you're having trouble, try writing down the steps on a piece of paper first.
      grade1_maze_sequence2_authored_hint:
        grade1_maze_sequence2_a: One of the blocks is moving the bird in the wrong direction. Can you figure out which one and replace it with the correct block?
      grade1_maze_sequence3_authored_hint:
        grade1_maze_sequence3_a: Try adding one instruction at a time until you get to the pig.
      grade1_maze_sequence5_authored_hint:
        K2.0_sequence_5: Your final code should have three movement blocks.
      grade1_maze_sequence6_authored_hint:
        K2.0_sequence_6_a: There is 1 block that you need to add to move the bird to the pig.
      grade1_maze_sequence7_authored_hint:
        grade1_maze_sequence7a: If you're stuck, try adding one block at a time until you solve the puzzle.
      grade1_maze_sequence8_authored_hint:
        grade1_maze_sequence8_a: Stuck? Try tracing the bird's path with your finger.
        grade1_maze_sequence8_b: 'The extra blocks need to be added before the last ![](https://images.code.org/145dfc20c086bc8fc265de47f3cfe4b0-image-1467848177684.35.51 PM.png )'
      grade1_maze_sequence9_authored_hint:
        grade1_maze_sequence9_a: If you're having trouble, try writing down the steps on a piece of paper first.
      grade1_maze_sequenceA_authored_hint:
        grade1_maze_sequence10_a: If you're having trouble, try writing down the steps on a piece of paper first.
      grade1_maze_sequenceB_authored_hint:
        grade1_maze_sequenceB_a: If you're having trouble, try writing down the steps on a piece of paper first.
      grade1_maze_sequenceC_authored_hint:
        grade1_maze_sequenceC_a: If you're having trouble, try writing down the steps on a piece of paper first.
      grade2_CaringForNewPet_0_authored_hint:
        grade2_CaringForNewPet_0: If the bird isn't getting to the pig, make sure all three of the blocks have been fully clicked together, then click "Run" again.
      grade2_CaringForNewPet_1_authored_hint:
        2-3_Maze_1_a: To use a `move forward` block, drag it from the toolbox out into the workspace and connect it to the `when run` block.
      grade2_CaringForNewPet_11_authored_hint: [ ]
      grade2_CaringForNewPet_2courseC_maze_programming3_authored_hint:
        courseC_maze_programming3_a: "![](https://images.code.org/afddde0e99d5d270c658de0c03dd6e2c-image-1481174000309.gif)\n\nTo delete a block from the middle of your code, drag all of the blocks underneath it away to the right and let them sit in the workspace for a while.  \n\nClick on the block you want to delete, and drag it back to the toolbox.\n\nFinally, put your other blocks back in place where they belong.\n"
      grade2_CaringForNewPet_3_authored_hint:
        hint1: You can turn right or left from the bird's point of view. If you are facing right, turning right will make you point downwards.
        hint2: This path is a zig-zag. You need to move forward 3 times and turn 2 times.
        hint3: To follow the path, move forward and turn one way, then move again and turn the opposite way. Move forward one more time to reach the pig.
      grade2_CaringForNewPet_3D_authored_hint: [ ]
      grade2_CaringForNewPet_4_authored_hint:
        2-3_Maze_6_a: 有 2 個方法可以完成這個關卡！
      grade2_CaringForNewPet_5_authored_hint:
        grade2_CaringForNewPet_5_a: If you can't quite see what you need to do, try saying the steps that your bird will take out loud one-by-one and see if they match the blocks in the workspace.
      grade2_CaringForNewPet_6_authored_hint:
        grade2_CaringForNewPet_6_a: You don't have to code the whole solution at once!  Try running the code as you go to make sure it works at each step.
      grade2_CaringForNewPet_7D_authored_hint:
        grade2_CaringForNewPet_7D_a: Don't forget to use the "Step" button to go through block by block and look for errors.
      grade2_MakeDogTag_1_authored_hint:
        2-3_Artist_1_new_a: 如果你使用`移動-向前 100 像素`這個積木，我就會向前移動並自動畫一條線啦。
        2-3_Artist_1_new_b: 要如何才能轉彎？試試`轉向-右方 90 度`積木。
      grade2_MakeDogTag_2_authored_hint:
        2-3_Artist_2_new_a: To create this window, just draw a square with 100 pixel sides.
      grade2_MakeDogTag_3_authored_hint:
        2-3_Artist_4_a: To finish the rocket, just draw the triangle on top!
      grade2_MakeDogTag_4_authored_hint: [ ]
      grade2_MakeDogTag_5_authored_hint:
        grade2_MakeDogTag_5a: The artist is already facing the correct way to draw his first line.
        grade2_MakeDogTag_5b: This diamond is really just a square that's standing on its corner.
        grade2_MakeDogTag_5c: Since this diamond is also a square, be sure to turn 90 degrees at the corners.
      grade2_MakeDogTag_6_authored_hint:
        grade2_MakeDogTag_6a: Every angle is either 45 or 90 degrees.
        grade2_MakeDogTag_6b: "Does it work at the first step?  \nHow about the second?  \nWhere does it go wrong?"
      grade2_MakeDogTag_7_authored_hint:
        2-3_Artist_11_a: The exterior angles on this triangle are 120 degrees each.
      grade2_MakeDogTag_9_authored_hint:
        2-3_Artist_Loops_New_11_a: |-
          Remember that the code from the last puzzle was:
          
          ![](https://images.code.org/e5c7492f509dd41efe2888c7e7895c28-image-1461177002636.29.02.png)
        2-3_Artist_Loops_New_11_b: 你的下一個轉彎動作應該要在迴圈中程式碼的**最後面**。
      grade2_MakeDogTag_BFP_authored_hint: [ ]
      grade2_PuppyLoops_10_authored_hint:
        2-3_Artist_Debugging_8_a: |-
          我的形狀重複了幾次？
          
          形狀 *應該* 要重複幾次？
          
          怎樣在你的程式裡做出對應的改變？
      grade2_PuppyLoops_3_authored_hint:
        hint1: This puzzle is very similar to the last one.
        hint2: Use a `repeat 5 times` block to create the loop.
        hint3: Place a `move forward` block inside the `repeat block`.
      grade2_PuppyLoops_5_authored_hint:
        hint1: The best solution uses two `move forward` commands and one loop.
      grade2_PuppyLoops_6_authored_hint:
        2-3_Maze_16_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        2-3_Maze_16_b: "如果要在`重複`迴圈中放置多個積木，只要拖曳一個迴圈到工作區，然後再把工作區上的積木堆拖曳到裡面。\n\n把它們放到`當運行時`積木就大功告成囉！"
      grade2_PuppyLoops_7_authored_hint:
        2-3_Maze_Loops_17_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        2-3_Maze_Loops_17_b: 你把預先建立好的程式給刪除了嗎？點擊`重新開始`按鈕把程式找回來吧！
      grade2_PuppyLoops_8_authored_hint:
        2-3_Artist_Debugging_2_a: 提示：每個鬍鬚長度為 75 像素。
      grade2_PuppyLoops_9_authored_hint:
        2-3_Artist_Debugging_7_a: 如果你讓藝術家畫完第一條線之後就向後移動或跳躍的話，會發生什麼？
      grade2_collector_2_authored_hint:
        hint1: You can use four `move forward` blocks or use the `repeat 4 times` block to make your program shorter.
      grade2_maze_debuggingFP_authored_hint: [ ]
      grade2_maze_intro4_authored_hint:
        hint_1: Connect a "move forward" block to the bottom of the program.
      grade2_playlab_project_6_authored_hint:
        idea1: |-
          *Need an idea?*
          
          **Who's there?** Make characters appear with random images, so no one knows who's showing up next.
          
          ![](https://images.code.org/a56e03479801995d93ad5a4e4384a79e-image-1475340154498.gif)
        idea2: |-
          *Need an idea?*
          
          **Going on an Adventure** - Change the background, then have the characters talk about where they are now.
          
          ![](https://images.code.org/010c4d919f841d6049caf9211ab65ccc-image-1475340583052.gif)
        idea3: |-
          *Need an idea?*
          
          **Pinball** - Make one character move using the arrow keys (use `when up arrow`, `when down arrow` blocks), then play random sounds when it collides with other characters on the screen.
      grade2_puppy_loops2_authored_hint:
        hint1: You can solve this puzzle with just three blocks, including `when run`.
        hint2: Try putting the `move forward` block inside of a `repeat` block to create a loop.
        hint3: You need to repeat the `move forward` command 5 times to solve this puzzle.
      grade2_puppy_loops3_authored_hint:
        hint1: This puzzle is very similar to the last one.
        hint2: Use a `repeat 5 times` block to create the loop.
        hint3: Place a `move forward` block inside the `repeat block`.
      grade2_puppy_loops4_authored_hint:
        hint1: Not all command blocks should be repeated.
        hint2: Use two `repeat` blocks set to different numbers.
        hint3: "`Turn right` once between the two loops."
      grade2_puppy_loops5_authored_hint:
        hint1: The best solution uses two `move forward` commands and one loop.
      grade2_puppy_loops6_authored_hint:
        2-3_Maze_16_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        2-3_Maze_16_b: "如果要在`重複`迴圈中放置多個積木，只要拖曳一個迴圈到工作區，然後再把工作區上的積木堆拖曳到裡面。\n\n把它們放到`當運行時`積木就大功告成囉！"
      grade2_puppy_loops7_authored_hint:
        2-3_Maze_Loops_17_a: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
      grade3_ConditionalsElse_4_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      grade3_ConditionalsElse_5_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      grade3_ConditionalsElse_TeacherIDo_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      grade3_Conditionals_10 BAD_authored_hint:
        4-5_Bee_Nested_Loops_Rows_a: 這就像個長方形，蜜蜂要往前移動、向左轉，總共多少次才能走完這個圖形。
      grade3_Conditionals_11_authored_hint:
        2-3_Bee_Conditionals_14_a: 想不到要如何減少積木的使用量？試著把用在紫花上的程式套用到紅花上。
        2-3_Bee_Conditionals_14_b: 如果紅花變成紫花，想一想，要怎麼另外使用`重複`迴圈來減少代碼的使用？
        2-3_Bee_Conditionals_14_c: "Try breaking this up into two separate chunks:  \n\n![](https://images.code.org/670ac0889a8f523865ff4099b4c54844-image-1463445460440.36.42.png)\n\n1) Gather nectar 3 times\n  - Move forward 5 times\n  - Check to see if nectar, if so: get it\n  - Turn left\n  \n2) Make honey \n  - Move forward one time\n  - Make two honey"
      grade3_Conditionals_12_authored_hint:
        2-3_Bee_Conditionals_15_a: 請記住：每次你運行程式後，紫花的花蜜數會變成 0 或 1！
      grade3_Conditionals_2_authored_hint:
        2-3_Bee_Conditionals_3_a: 如果你用迴圈的方式，程式就會精簡許多。一個迴圈用來向前移動，另一個迴圈用來收集花蜜，再一個迴圈來釀造蜂蜜。
      grade3_Conditionals_4_authored_hint:
        2-3_Bee_Conditionals_6_a: 請記住：當你運行程式後，紫花的花蜜數會變成 0 或 1！
      grade3_Conditionals_TeacherIDo_authored_hint:
        2-3_Bee_Conditionals_6_a: 請記住：當你運行程式後，紫花的花蜜數會變成 0 或 1！
      grade3_Debugging_1_authored_hint:
        2-3_Bee_Debugging_1_a: 在你找到並修正了不正確的積木的過程中，有發現哪些地方可以用一個`重複`迴圈讓程式變得更簡單嗎？
      grade3_Debugging_10_authored_hint:
        grade3_Debugging_10_a: |-
          Start by looking at just the first loop.
          
          What does it do?
          
          What is it supposed to do?
          
          What does that tell you?
        grade3_Debugging_10_b: Once you have the first loop the way you want it, what is left over in your code?
        grade3_Debugging_10_c: |-
          Try wrapping the leftover loop around the rest of your completed code.  Does is work now?
          
          If not, what is still going wrong?
      grade3_Debugging_11_authored_hint:
        grade3_Debugging_11_a: |-
          Try running through the code using the "Step" button.  Is everything good at the first step?
          
          How about the second?
          
          Where do things go wrong?
        grade3_Debugging_11_b: It looks like all of the right steps are here, you just need more of them.  How can you repeat the `get nectar` and `make honey` actions multiple times?
      grade3_Debugging_2_authored_hint:
        grade3_Debugging_2_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        grade3_Debugging_2_b: Do you see any patterns that could be made more simple using a `repeat` loop?
      grade3_Debugging_3_authored_hint:
        grade3_Debugging_3_a: |-
          Use the "Step" button to see if everything is right at the first step.
          
          How about the second?
          
          Where does it go wrong?
        grade3_Debugging_3_b: Do you see a pattern?  Try using nested loops to solve this puzzle.
      grade3_Debugging_4_authored_hint:
        grade3_Debugging_4_a: Is there any place where the bee does something that doesn't make sense? What happens when you change those blocks?
        grade3_Debugging_4_b: Try simplifying the code using nested loops.
      grade3_Debugging_8_authored_hint:
        grade3_Debugging_8_a: "Try using the debugging process a couple of times in a row. \n\nWhat causes the first problem?\n\nOnce that problem is fixed, what goes wrong?"
        grade3_Debugging_8_b: "If you're having a hard time figuring out how to make the stair step pattern, try tracing it with your finger and saying the commands out loud. \n\nDon't forget to point out the direction of the turns!"
      grade3_Debugging_TeacherIDo_authored_hint:
        2-3_Bee_Debugging_4_a: 蜜蜂做的事情裡頭好像有些地方不大對勁？當你更改那個積木後會發生什麼事呢？
      grade3_Loops_10_authored_hint:
        2-3_Bee_Loops_4_a: 你的迴圈中應該要有 5 個積木。
      grade3_Loops_11_authored_hint:
        2-3_Bee_Loops_5_a: 如果你不能馬上的就使用`重複`積木來寫出程式，可以先把一個個的指令寫出來，然後找出指令間共同的模式。
      grade3_Loops_12_authored_hint:
        2-3_Bee_Loops_6_a: 如果你沒有辦法很快的分辨出要在`重複`迴圈中放些什麼積木，可以試著先按照順序拖曳出每個積木，並在拖曳過程中找出它們的規律。
        2-3_Bee_Loops_6_b: 你的`重複`迴圈裡應該要有 6 個積木才對。
      grade3_Loops_4_authored_hint:
        2-3_Bee_Loops_3B_a: 你需要 2 個不同的`重複`迴圈，一個接著一個。
      grade3_Loops_5_authored_hint:
        2-3_Bee_Loops_7_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_7_b: '如果你實在無法從頭想像迴圈的內容，可以先把需要的指令寫成長一點的程式，然後從裡頭找出組合模式。  '
      grade3_Loops_6_authored_hint:
        2-3_Bee_Loops_4A_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_4A_b: 在迴圈之外的結尾處再加上一些程式就可以完成了。
        2-3_Bee_Loops_4A_c: 如果你還不能準確的使用迴圈，可以先用長串的指令，然後再找出有什麼地方是可以用`重複`迴圈來替代的。
      grade3_Loops_8_authored_hint:
        2-3_Bee_Loops_2_a: 你的迴圈中應該要有 4 個積木。
      grade3_Loops_9_authored_hint:
        2-3_Bee_Loops_3_a: 你的迴圈中應該要有 6 個積木。
      grade3_RunningFarm_1_authored_hint:
        grade3_RunningFarm_1_a: You will need to look for corn 5 times, using a repeat loop.
        grade3_RunningFarm_1_b: Make sure to use an `if at corn` block or you might try to pick something that's not there!
      grade3_RunningFarm_10_authored_hint:
        grade3_RunningFarm_10_a: This puzzle uses almost the exact same code as the last level, except you only need to repeat 4 times.
      grade3_RunningFarm_11a_authored_hint:
        grade3_RunningFarm_11a_a: You shouldn't need the `while path ahead` loop this time.
      grade3_RunningFarm_2_authored_hint:
        grade3_RunningFarm_2_a: 'The best way to do this is to nest `if` statements by placing one inside of the other.  '
        grade3_RunningFarm_2_b: For this puzzle, you should have one `if/else` statement and one plain `if` statement.
      grade3_RunningFarm_3_authored_hint:
        grade3_RunningFarm_3_a: |-
          To get all of the items, try nesting `if` statements three deep.
          
          This means you should put one `if` statement inside of another, then put a third `if` statement inside the second one.
        grade3_RunningFarm_3_b: For this puzzle, you should have two `if/else` statements and one plain `if` statement.
      grade3_RunningFarm_4_authored_hint:
        grade3_RunningFarm_4_a: |-
          No one knows how many heads of lettuce will grow from each sprout.
          
          Use a `while there is lettuce` loop to keep picking until each piece has been gathered.
      grade3_RunningFarm_5_authored_hint:
        grade3_RunningFarm_5_a: You will need to check for each type of crop that the farmer can pick.  Try using two `if/else` statements and one  `if` block.
      grade3_RunningFarm_6_authored_hint:
        grade3_RunningFarm_6_a: Use a `while path ahead` loop to move the farmer down each piece of the spiral.
        grade3_RunningFarm_6_b: You only need to check for corn during most of the harvest.  Just pick one pumpkin at the very end of your program.
      grade3_RunningFarm_7_authored_hint:
        grade3_RunningFarm_7_a: |-
          Notice that the easiest path to get to all of the crops is still a spiral.
          
          ![](https://images.code.org/ba8b8c624f21ade9ac823b045085c435-image-1479364378437.png)
        grade3_RunningFarm_7_b: Try using `when path ahead` to keep the farmer moving the right number of steps.
        grade3_RunningFarm_7_c: 'Use nested `if` statements and `while there is` loops to check each space for corn and lettuce, then pick only a single pumpkin at the end. '
      grade3_bee_Conditionals_new4_authored_hint:
        grade3_bee_Conditionals_new4_a: Don't forget that you can use loops for shorter code!
      grade3_bee_conditionals_new1a_authored_hint:
        grade3_bee_conditionals_new1a_a: Be sure to use an `if` statement to check each space to see if it has a flower or nothing.
      grade3_bee_conditionals_new2a_authored_hint:
        grade3_bee_conditionals_new2a_a: You can still treat every space as if there is a cloud over it, even though you can see the whole path.
        grade3_bee_conditionals_new2a_b: 'Use an `if` statement inside your loop to check each space. '
      grade3_bee_conditionals_new3a_authored_hint:
        grade3_bee_conditionals_new3a_a: In this puzzle, you know that each square has either a flower or a honeycomb.  That means you can repeat your `if/else` conditional at each square.
      grade3_bee_conditionals_quantum1_authored_hint:
        grade3_bee_conditionals_quantum1_a: You will need to use an `if` block to check to see if there is a flower beneath the cloud before you try to get nectar.
      grade3_bee_conditionals_quantum2_authored_hint:
        grade3_bee_conditionals_quantum2_a: Sometimes a flower will be there, sometimes it won't.  If you want your code to run in both cases, make sure to use an `if` statement.
      grade3_bee_conditionals_quantum3_authored_hint:
        grade3_bee_conditionals_quantum3: Make sure to use an `if` statement to check for honeycomb beneath each cloud.
      grade3_bee_conditionals_quantum4_authored_hint:
        remember_quantum: "**Remember:** This puzzle changes each time it's run.  \n\nYou'll want to use a conditional block (`if/else`) to solve the challenge."
      grade3_bee_conditionals_quantum5_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
        grade3_bee_conditionals_quantum5_a: This puzzle is tricky, because you can't check blank squares, nectar *and* honey with a single conditional.
      grade3_maze_loops1_authored_hint:
        grade3_maze_loops1_a: Try using the "Step" button to find errors.
      grade3_maze_loops2_authored_hint:
        grade3_maze_loops2_a: |-
          Try using this path through the maze.
          
          ![](https://images.code.org/6a8b4b97a8eef813d8a827b0b7b2d36b-image-1480446509692.05.22.png)
        grade3_maze_loops2_b: 如果很難去找到匹配的模式，試試先一點一點的把指令全寫出來，然後看看哪些部分是重複的，最後把這些重複的部分放進迴圈裡。
        grade3_maze_loops2_c: Try using one `repeat` loop inside of another to cut down on the amount of code you need.
      grade3_maze_loops2a_authored_hint:
        grade3_maze_loops2a_a: To solve this puzzle, you will need to "nest" one `repeat` loop inside of another `repeat` loop.
      grade3_maze_loops3_authored_hint:
        2-3_Maze_Loops_19_a: If you are stuck, try writing out the code out on paper without loops first and look for patterns.
        2-3_Maze_Loops_19_b: Nesting `repeat` loops can help decrease the number of blocks used.
        2-3_Maze_Loops_19_c: It will take two sets of nested `repeat` loops to solve this puzzle.
      grade3_maze_loops4_authored_hint:
        2-3_Maze_Loops_20_a: Look for a stair-step pattern in this maze to find where a nested loop can be used.
      grade3_maze_loops5_authored_hint:
        2-3_Maze_Loops_21_a: 如果你一時之間找不到樓梯的組合模式，試試用手蓋住被擋住的路徑。
      grade3_robotFarmer_ConditionalsIntro_10a_authored_hint: [ ]
      grade3_robotFarmer_ConditionalsIntro_11a_authored_hint: [ ]
      grade3_robotFarmer_ConditionalsIntro_5_authored_hint:
        grade3_robotFarmer_ConditionalsIntro_5a: Try nesting a `while` loop inside of a `repeat` loop.
      grade3_robotFarmer_ConditionalsIntro_7_authored_hint:
        grade3_robotFarmer_ConditionalsIntro_7_a: Make sure you're using the `while` loop to figure out how many times to fill each hole.
        grade3_robotFarmer_ConditionalsIntro_7_b: Notice that the farmer needs to move forward and down several times in a stair-step pattern.
      grade3_robotFarmer_ConditionalsIntro_8_authored_hint:
        grade3_robotFarmer_ConditionalsIntro_8_a: The `while path ahead` block lets you keep going, even if you don't know how many squares are in a path.
      grade3_robotFarmer_ConditionalsIntro_9_authored_hint:
        grade3_robotFarmer_ConditionalsIntro_9_a: You are going to need to use more than one `while` loop.
        grade3_robotFarmer_ConditionalsIntro_9_b: Every hole is at the end of a path, so use `while path ahead` before using `while there is a hole`.
        grade3_robotFarmer_ConditionalsIntro_9_c: Notice that you need to repeat the `while path ahead`, `while there is a hole` code six times.
      grade4_arist_nested_loop_polygons1_authored_hint:
        4-5_Nested_Loops_7_a: |-
          這個圖案會循環 10 次，在一圈 360 度裡。
          
          **360 / 10 = ?**
      grade4_arist_nested_loop_polygons2_authored_hint:
        4-5_Nested_Loops_8_a: |-
          你要重複畫這個圖形 6 次，在一圈 360 度內。
          
          **360 / 6 = ?**
      grade4_arist_nested_loop_triangles2_authored_hint: [ ]
      grade4_arist_nested_loop_triangles3_authored_hint:
        4-5_Nested_Loops_6_a: |-
          別忘了在內部循環中加上轉向。
          
          在一圈 360 度裡要畫出 6 個三角形。
          
          **360 / 6 = ?**
      grade4_arist_nested_loop_triangles6_authored_hint:
        4-5_Nested_Loops_12_a: "**360 / 36 = ?**"
      grade4_artist_functions1_authored_hint:
        2-3_Artist_Functions_1_a: 正方形每邊都有 100 像素，這代表你需要向前移動 175 像素之後才能開始畫第二個正方形。
        2-3_Artist_Functions_1_b: 畫出眼鏡時可以讓你的兩條線重疊沒關係。
      grade4_artist_functions2_authored_hint:
        2-3_Artist_Functions_2_a: |-
          你的程式應該要：
          - 使用函式
          - 向前移動 100 + 75 像素
          - 使用函式
      grade4_artist_functions2a_authored_hint:
        grade4_artist_functions2a_a: To get around using multiple `move forward` blocks, create a `draw triangle` function and call that multiple times.
      grade4_artist_functions3a_authored_hint:
        grade4_artist_functions2a_a: To get around using multiple `move forward` blocks, create a `draw triangle` function and call that multiple times.
      grade4_artist_functions3b_authored_hint:
        grade4_artist_functions2a_a: To get around using multiple `move forward` blocks, create a `draw hexagon` function and call that multiple times.
      grade4_artist_functionsChallenge0_authored_hint:
        grade4_artist_functionsChallenge0_a: |-
          Start by making a function for a square, then try making a function for a line of squares.
          
          How would you use the `draw a line of squares` function to make this image?
        grade4_artist_functionsChallenge0_b: After your first line of squares, you need to move the artist down and back before you start your second line of squares.
        grade4_artist_functionsChallenge0_c: You should move the artist back a different number of pixels for even lines than for odd ones.
      grade4_artist_functions_challenge_authored_hint:
        Course_4_SCF_1_a: 每個六邊形的邊長都是 40 像素。
        Course_4_SCF_1_b: 每個六邊形之間的水平距離是 120 像素。
        Course_4_SCF_1_c: "在你畫出第二排的六邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 320 像素。"
        Course_4_SCF_1_d: "在你畫出第三排的多邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 440 像素（比你的函式 `shift down/forward` 還要多 120 像素）。 "
        Course_4_SCF_1_e: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/d64a0e22c1db1d98c35b243bca6460ab-image-1469727090121.png)
      grade4_artist_functions_challenge2_authored_hint:
        Course_4_SCF_1_a: 每個六邊形的邊長都是 40 像素。
        Course_4_SCF_1_b: 每個六邊形之間的水平距離是 120 像素。
        Course_4_SCF_1_c: "在你畫出第二排的六邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 320 像素。"
        Course_4_SCF_1_d: "在你畫出第三排的多邊形之前，你需要向右轉 60 度，然後向前跳 40 像素。\n\n在你到了正確的垂直位置後，你必須讓小藝術家再轉過頭來，然後向前跳 440 像素（比你的函式 `shift down/forward` 還要多 120 像素）。 "
        Course_4_SCF_1_e: |-
          **解決方案：**
          
          ![Solution Blocks](https://images.code.org/d64a0e22c1db1d98c35b243bca6460ab-image-1469727090121.png)
      grade4_artist_functions_stars0_authored_hint:
        grade4_artist_functions_stars0_a: |-
          To solve this puzzle, you just need to add a  loop that repeats the starter code 8 times.
          
          If you can't remember what the starter code was, click "start over" in the upper right corner of the workspace.
      grade4_artist_functions_stars1_authored_hint:
        grade4_artist_functions_stars1_a: Try using a function!
      grade4_artist_functions_stars2_authored_hint:
        grade4_artist_functions_stars2_a: Don't give up!  Remember what you have been learning.
        grade4_artist_functions_stars2_b: Functions make it easy to call saved code at any time, not just from inside a loop!
      grade4_artist_functions_stars3_authored_hint:
        hint1: Don't give up!
      grade4_artist_functions_windows0_authored_hint:
        grade4_artist_functions_windows0_a: Focus only on making one window for now.  We'll create a function for it in the next puzzle.
        grade4_artist_functions_windows0_b: Try using nested loops, where the inner loop makes the square and the outer loop rotates the square four times.
      grade4_artist_functions_windows2_authored_hint:
        grade4_artist_functions_windows2_a: Try creating your function first then adding in windows one at a time.
        grade4_artist_functions_windows2_b: You shouldn't need to add any extra repeat loops.  Just jump the artist 100 pixels forward for each top window, and 150 pixels down to get the bottom windows.
      grade4_artist_nestedLoops_challenge2_authored_hint:
        Course_4_Artist_11_a: '這個半六邊形有一個**30 像素的邊**還有需要轉向**60 度**。  '
        Course_4_Artist_11_b: '這個 2/3 的三角形有一個**80 像素的邊**還有需要轉向**120 度**。 '
      grade4_artist_nested_loop_polygons1_authored_hint:
        4-5_Nested_Loops_7_a: |-
          這個圖案會循環 10 次，在一圈 360 度裡。
          
          **360 / 10 = ?**
      grade4_artist_nested_loop_polygons2_authored_hint:
        4-5_Nested_Loops_8_a: |-
          你要重複畫這個圖形 6 次，在一圈 360 度內。
          
          **360 / 6 = ?**
      grade4_artist_nested_loop_triangles2_authored_hint: [ ]
      grade4_artist_nested_loop_triangles3_authored_hint:
        4-5_Nested_Loops_6_a: |-
          Don't forget to make a turn after your inner loop.
          
          You'll be looping 6 triangles over 360 degrees.
          
          **6 x ? = 360**
      grade4_artist_nested_loop_triangles6_authored_hint:
        4-5_Nested_Loops_12_a: "**360 / 36 = ?**"
      grade4_bee_conditionals_new1a_authored_hint:
        grade4_bee_conditionals_new1a_a: An `if` block will help you out in this puzzle.
      grade4_bee_conditionals_new2_authored_hint:
        grade4_bee_conditionals_new2_a: 'The flowers follow a rectangular path.  You can trace that rectangle using `while path ahead` even with a different number of squares per side. '
        grade4_bee_conditionals_new2_b: You can check every square for a flower using the `if` block, even if you already know there's not one there.
      grade4_bee_conditionals_new3b_authored_hint:
        grade4_bee_conditionals_new3b_a: An `if/else` statement could really help you out here.
      grade4_bee_conditionals_quantum4_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      grade4_bee_conditionals_quantum5_authored_hint:
        remember_quantum: "**記住：**這個關卡在每次運行時都會有變化。\n\n你會需要一個條件判斷的積木（`如果`或是`如果…否則`）來完成這個挑戰。"
      grade4_bee_functions1_authored_hint:
        grade4_bee_functions1_a: There is more than one right answer to this puzzle.
      grade4_bee_functions10_authored_hint:
        grade4_bee_functions10_a: You can use the exact same function for this puzzle as you did in the last puzzle.  All you need to do is create a function that collects all of the nectar when you get to each flower.
      grade4_bee_functions2_authored_hint:
        grade4_bee_functions2_a: The function has been written for you, but you will need to call it at each flower.
      grade4_bee_functions3_authored_hint:
        grade4_bee_functions3_a: 'Your function for this puzzle only needs to collect nectar, it shouldn''t have any `move forward` or `turn` blocks in it. '
      grade4_bee_functions4_authored_hint:
        grade4_bee_functions4_a: Your function will travel down the side paths and return the bee back to the main road.  You don't need to add that part to your program.
      grade4_bee_functions6_authored_hint:
        grade4_bee_functions6_a: Edit the function so that it solves the puzzle without having to change the main program.
        grade4_bee_functions6_b: "Your function should make the bee: \n- turn\n- move forward\n- collect all of the nectar\n- turn around\n- move back to the main path\n- turn back to the direction that the bee started from"
      grade4_bee_functions7_authored_hint:
        2-3_Bee_Functions_8_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！\n\n![](https://images.code.org/3875224b35889000a0998ca25cfa4ecf-image-1467996493914.gif)"
      grade4_bee_functions8_authored_hint:
        2-3_Bee_Functions_8_a: "如果碰到了難度很高的關卡，試著花些時間建構出函式來利用。\n\n添加一些積木到裡頭，然後試試看，接著再添加一些，再試試，最後，你就可以找到答案！"
        2-3_Bee_Functions_8_b: |-
          記得要在綠色的函式積木裡建置你的程式。
          
          ![](https://images.code.org/8fe1fae5caf4ede3a9c9bd9f26940cde-image-1467996837459.gif)
        2-3_Bee_Functions_8_c: This function should turn the bee to head him down the path, collect the nectar, make the honey, then turn the bee around and bring him back.
      grade4_bee_functions9_authored_hint:
        grade4_bee_functions9_a: Your function will only need to collect nectar... but this time, you will need to use a `while` loop instead of a `repeat` loop.
        grade4_bee_functions9_b: Use `while nectar > 0` to make sure you get all of the nectar.
      grade4_bee_nestedLoops1_authored_hint:
        grade4_bee_nestedLoops1_a: If you don't understand how to use nested loops here, try writing out the instructions step by step on a piece of paper.  Circle the patterns that you see.
      grade4_bee_nestedLoops2_authored_hint:
        grade4_bee_nestedLoops2_a: You will need to repeat `get nectar` inside of another `repeat` that also has the `move forward` block inside of it.
        grade4_bee_nestedLoops2_b: You will need to use all three of the available `repeat` blocks to solve this puzzle.
        grade4_bee_nestedLoops2_c: |-
          Nest your blocks three deep, like this:
          
          - repeat 3
          - repeat 3
          - move forward
          - repeat 12
          - get nectar
          - turn right
      grade4_bee_nestedLoops2a_authored_hint:
        grade4_bee_nestedLoops2a_a: Try using nested `repeat` loops to solve this puzzle.
      grade4_bee_nestedLoops4_authored_hint:
        grade4_bee_nestedLoops4_a: Try building your code line by line and see if you can spot the places where a repeat will make the code shorter!
        grade4_bee_nestedLoops4_b: |-
          You will need a nested loop to move forward and get nectar, but only a single loop to collect honey at the end.
          
          Altogether, you should be using 3 loops.
      grade4_bee_nestedLoops5_authored_hint:
        grade4_bee_nestedLoops5_a: You will need 4 repeat blocks!
      grade4_review_artist1_authored_hint:
        2-3_Artist_1_new_a: 如果你使用`移動-向前 100 像素`這個積木，我就會向前移動並自動畫一條線啦。
        2-3_Artist_1_new_b: 要如何才能轉彎？試試`轉向-右方 90 度`積木。
      grade4_review_artist2_authored_hint:
        2-3_Artist_6_a: '如果要做出這些小小的角度，我們必須讓每次畫完正方形之後的轉向角度大一些。   '
        2-3_Artist_6_b: 因為我們已經面向右邊，所以最簡單的方式，就是先往前移動，再向左轉，就可以製作出這個三角形。
        2-3_Artist_6_c: 三角形的每個邊長和正方形的邊長一樣，都是 100 像素！
      grade4_review_bee1_authored_hint:
        2-3_Bee_Loops_3B_a: 你需要 2 個不同的`重複`迴圈，一個接著一個。
      grade4_review_bee2_authored_hint:
        2-3_Bee_Loops_3_a: 你的迴圈中應該要有 6 個積木。
      grade4_review_bee3_authored_hint:
        2-3_Bee_Loops_4_a: 你的迴圈中應該要有 5 個積木。
      grade5_artist_binary10_authored_hint:
        Course_4_Artist_Binary_Free_Play_2b_a: 這個程式中使用了 2 個`計數迴圈`，第一個從 1 算到 8，另一個則是從 8 算到 1。
        Course_4_Artist_Binary_Free_Play_2b_b: 每個`計數迴圈`裡有 3 個`重複`積木，第一個畫出左半部、第二個畫出中間、第三個畫出右半部。
        Course_4_Artist_Binary_Free_Play_2b_c: 在每一次的循環裡，你需要為 1s 使用 `counter` 計數，還有為 0s 使用 `16-(2 x counter)` 來計數。
        Course_4_Artist_Binary_Free_Play_2b_d: |-
          **Solution:**
          ![solution](https://images.code.org/866a92e042a546de3afcf462a8b5c695-image-1444438735003.58.28.png)
      grade5_artist_for_loops1_authored_hint:
        grade5_artist_for_loops1_a: |-
          If you use this `for` loop, it will run just like a `repeat 3 times` loop.
          
          ![](https://images.code.org/585d2e24f3021ac2561aec6e96dde430-image-1475906135993.54.11.png)
      grade5_artist_for_loops10_authored_hint:
        Course_4_Artist_For_Loops_Challenge_a: 最大的多邊形有 19 個邊。
        Course_4_Artist_For_Loops_Challenge_b: 每個多邊形都不完整，其中有一條邊會比原來的短。
      grade5_artist_for_loops1b_authored_hint:
        grade5_artist_for_loops1b_a: |-
          Can you draw something like this:
          
          ![](https://images.code.org/80ae9ab3e449db1ed4e13c86239f7617-image-1475906794954.06.12.png)
      grade5_artist_for_loops2_authored_hint:
        grade5_artist_for_loops2_a: |-
          Use `counter` for the length of your triangles inside your `repeat` loop.
          
          ![](https://images.code.org/5e9465321a0b7a4d791848a79f3e6715-image-1475908305872.31.26.png)
      grade5_artist_for_loops3_authored_hint:
        Course_4_Artist_For_Loops_3_a: |-
          To have the `for` loop drive your movement, make sure that you're using `counter` as your distance in the `move forward` block.
          
          ![](https://images.code.org/15e87fc7fe408cbf1b63e0e8e69b7ffe-image-1475908502078.31.26.png)
      grade5_artist_for_loops4_authored_hint:
        Course_4_Artist_For_Loops_4_a: "**需要的數字至少要是多少？\n最大的數字又是多少？\n每循環一次要增加多少？**\n\n這些問題是你每次在使用`計數`迴圈要思考的。"
      grade5_artist_for_loops5_authored_hint:
        grade5_artist_for_loops5_a: You don't need the traditional repeat loop when making this spiral!
      grade5_artist_for_loops7_authored_hint:
        grade5_artist_for_loops7_a: The pen is thinner in this puzzle. You will need to set it to `1` before you start.
        grade5_artist_for_loops7_b: Notice that this spiral turns right instead of left!
      grade5_artist_for_loops7a_authored_hint: [ ]
      grade5_artist_for_loops7b_authored_hint: [ ]
      grade5_artist_for_loops8_authored_hint:
        Course_4_Artist_For_Loops_11_a: "每個圖形之後轉向的角度都會改變！\n\\r\n使用運算類別積木，並輸入 360 除以邊數來產生圖形要轉向的角度。 "
      grade5_artist_for_loops9_authored_hint:
        Course_4_Artist_For_Loops_11a_a: '360 除以多邊形的邊數，就是你要轉向的度數。 '
        Course_4_Artist_For_Loops_11a_b: '每一次你需要向前移動，共 10 次。移動的長度相當於多邊形的邊數。 '
      grade5_artist_for_loopsfreeplay11_authored_hint:
        Course_4_Artist_For_Loops_inspire_a: 這個程式的基礎和上個挑戰關卡很像…有些地方改了就是。
        Course_4_Artist_For_Loops_inspire_b: 試試看這個`計數`迴圈，從 3 算到 10，每次增加 1。
        Course_4_Artist_For_Loops_inspire_c: 在這個`計數`迴圈裡用了二個`重複`積木，不過第二個會轉成相反的方向。
        Course_4_Artist_For_Loops_inspire_d: "**Solution:**  ![Solution](https://images.code.org/d619892fc17ff491c201d86bb917e523-image-1441005190828.12.30.png) "
      grade5_artist_for_loopsfreeplay12_authored_hint:
        grade5_artist_for_loopsfreeplay12_a: The image in the drawing was made using a counter for the `set alpha` and `counter` / 10 as a brush size.
        grade5_artist_for_loopsfreeplay12_b: The image in the drawing uses a turn of 61 degrees.
        grade5_artist_for_loopsfreeplay12_c: |-
          Want to know how the sample image was done?
          
          ![](https://images.code.org/fdc5d6c15b357ba9763ac9ea914967a9-image-1475911612774.23.51.png)
      grade5_artist_functionparameters10_authored_hint:
        brush_width: 在我們開始前，先將筆刷的寬度設為 1，顏色設為藍色。
        double_loop: 試著放置一個`計數迴圈`到`重複`積木裡頭。
        specifics: "畫出 6 個「花瓣」的這個`計數迴圈`，每一次都會從 3 開始執行到 17，而畫出的形狀的邊數都會是奇數。\n\n`設置透明度`的積木中用了計數器，當計數器的值愈高時，顏色會變得愈淡。"
        after: 當你完成每個「花瓣」時，請檢查是否在你轉彎 60 度之前`移動-向前`了 20 像素。
        solution: |-
          **Solution**
          
          ![](https://images.code.org/7e9f4be39d45726d537fe8e6e9147986-image-1456445254361.png)
      grade5_artist_functionparameters8_authored_hint:
        NEW_Course_4_Artist_Params_13_a: The length of sides for each shape is 7 times the number of sides it has.
      grade5_artist_functionparameters9_authored_hint:
        NEW_Course_4_Artist_Params_14_a: It's okay to run the program a few times to figure out how the function works with different parameters.
        grade5_artist_functionparameters9_b: You don't need to add any `move` or `turn` blocks to finish this code.
      grade5_artist_functionparameters9a_authored_hint:
        grade5_artist_functionparameters9a_a: 'Did the code get so scrambled up that it''s no longer recognizable?  Try clicking the "Start over" button in the upper righthand corner. '
        grade5_artist_functionparameters9a_b: Your new `min` variable should go in the first slot in your `for` loop, inside the function.
      grade5_artist_functionparameters9b_authored_hint:
        grade5_artist_functionparameters9b_a: If your function is correct, you shouldn't need to change it for this puzzle.
        grade5_artist_functionparameters9b_b: The only thing you should need to do between function calls is change the color of the line.
      grade5_artist_functionparameters_6_authored_hint:
        grade5_artist_functionparameters_6_a: Use a `for` loop to get the code as smooth as you can.
        grade5_artist_functionparameters_6_b: Remember to **add** a parameter.  Don't remove the one that is already there!
      grade5_artist_parameters_squares1a_authored_hint:
        grade5_artist_parameters_squares1a_a: Remember, you need to turn 90 degrees to draw a square.
        grade5_artist_parameters_squares1a_b: You only need to repeat as many times as the number of sides in a square.
      grade5_artist_parameters_squares2_authored_hint:
        grade5_artist_parameters_squares2_a: This gets easier if you put it all in a `for` loop.
        grade5_artist_parameters_squares2_b: |-
          Be sure to turn 90 degrees between each square!
          
          ![](https://images.code.org/97bd8eded03c5aa39740876c8e9f7ff8-image-1469224745277.gif)
      grade5_artist_parameters_squares2a_authored_hint:
        grade5_artist_parameters_squares2a_a: You need to click the "edit" button to get into the function.  Once you're there, add a parameter called `length` and use it inside your `move forward` block!
        grade5_artist_parameters_squares2a_b: When calling your function, use a `for loop` for the best possible code!
      grade5_artist_parameters_stars1_authored_hint:
        hint1: Don't give up!
      grade5_artist_variables_freeplay10_authored_hint:
        Course_4_Artist_Vars_8_a: 如果你將起始長邊除以側邊數，當側邊個數越大時，每個的長邊將會變短
      grade5_artist_variables_freeplay15_authored_hint:
        Course_4_Artist_Inspire_a: 在你完成一個正方形後（轉向製作下一個之前）向前跳躍，跳的距離是邊長的一半。
        Course_4_Artist_Inspire_b: 畫出一個正方形然後跳躍，共重複 4 次（每次之間又用了向左轉），就可以做出這個像風車一樣的圖案。
        Course_4_Artist_Inspire_c: 每個風車圖案也重複了 4 次，轉向的角度為 **360/sides**。
        Course_4_Artist_Inspire_d: |-
          **Solution:**
          ![Blocks for solution](https://images.code.org/1865aaf1b4a8ba84a5e8a7408401092d-image-1440060930335.43.39.png)
      grade5_artist_variables_octagons13_authored_hint:
        Course_4_Artist_Vars_13_a: 你需要 2 個重複迴圈（一個包著一個），兩個都重複 `sides`次。
        Course_4_Artist_Vars_13_b: "裡面的重複迴圈畫出了一個八邊形（轉向左邊）。\n\n之後，你只需要在迴圈外層添加向前移動，然後向右轉的程式。"
        Course_4_Artist_Vars_13_c: 如果要在邊數改變的同時又保持圖形的尺寸，可以使用運算積木，將周長除以邊數。
      grade5_artist_variables_square7_authored_hint:
        Course_4_Artist_Vars_6_a: 若要畫出一個正多邊形，可以在每一次循環轉 **360/邊數** 度。
      grade5_artist_variables_triangles1_authored_hint:
        grade5_artist_variables_triangles1_a: To make an internal angle of 60 degrees in this triangle, remember to turn the artist 120 degrees.
      grade5_bee_for_loops10_authored_hint:
        grade5_bee_for_loops10_a: "How much less is 12 than 15?  \nHow much less is 9 than 12?\n\nDo you see a pattern?"
      grade5_bee_for_loops11_authored_hint:
        NEW_Course_4_Bee_For_Loops_10a_a: Can you find a pattern between the number of steps you need to take and the number of nectars to gather?
        NEW_Course_4_Bee_For_Loops_10a_b: You'll need to have 2 repeats, one will use a math block.
      grade5_bee_for_loops3_authored_hint:
        grade5_bee_for_loops3_a: 'Use the `counter` variable inside the `repeat` loop where nectar is gathered to solve this puzzle. '
        grade5_bee_for_loops3_b: Your `for` loop will need to count from 1 to 5 with an increment of 1.
      grade5_bee_for_loops4_authored_hint:
        grade5_bee_for_loops4_a: Use a `for` loop that goes from 1 to 7 with an increment of 1 to solve this puzzle.
        grade5_bee_for_loops4_b: Make sure to use the `counter` variable inside your nested `repeat` loop to get enough nectar!
      grade5_bee_for_loops5_authored_hint:
        grade5_bee_for_loops5_a: This time, your `move forward` block and your `get nectar` block will need to be in separate `repeat` loops.
      grade5_bee_for_loops6_authored_hint:
        grade5_bee_for_loops6_a: Don't forget to use a `counter` variable inside your `repeat` loop.
      grade5_bee_for_loops7_authored_hint:
        grade5_bee_for_loops7_a: Your `for` loop will need to count from 1 to 7 by 2.
      grade5_bee_for_loops8_authored_hint:
        NEW_Course_4_Bee_For_Loops_8_a: "If your loop is counting up, the increment is added to your counter variable each time through. \n\nWhat do you need to add to each number to get the next amount of nectar?"
      grade5_bee_for_loops9_authored_hint:
        NEW_Course_4_Bee_For_Loops_7_a: |-
          Try doing some math with the counter variable.
          
          What do you have to do to the counter at each flower to equal the amount of nectar you need to collect?
        NEW_Course_4_Bee_For_Loops_7_b: 'Remember: If your loop is counting up, the increment is added to your `counter` variable each time through.'
      grade5_bee_parameters_new1_authored_hint:
        grade5_bee_parameters_new1_a: Use `if` statements to make sure you're only getting nectar from a flower.
      grade5_bee_parameters_new2_authored_hint:
        grade5_bee_parameters_new2_a: "To turn this into a function, simply drag the code into the existing function block.  \n\n\n![](https://images.code.org/4d918c677ecb9f1618c1556566805b32-image-1477621874625.gif)"
        grade5_bee_parameters_new2_b: Don't forget to connect the `rowOfNectar` block to `when run` to call the function that you just built.
      grade5_bee_parameters_new3_authored_hint:
        grade5_bee_parameters_new3_a: Your function will run no matter which direction you're facing.
      grade5_bee_parameters_new4_authored_hint:
        grade5_bee_parameters_new4_a: You will need to add a parameter and use the resulting variable in your loop.
      grade5_bee_parameters_new5_authored_hint:
        grade5_bee_parameters_new5_a: Count the number of spaces you need to check in each stretch and use those numbers as your parameters to the function call.
      grade5_bee_parameters_new6_authored_hint:
        grade5_bee_parameters_new6_a: Which block automatically increments a variable that you could use as a parameter?
      grade5_bee_parameters_new7_authored_hint:
        grade5_bee_parameters_new7_a: You don't need a second parameter for this function, only a second `if` statement.
      grade5_bee_parameters_new8a_authored_hint:
        grade5_bee_parameters_new8a_a: This spiral can be simplified with a `for` loop.
      grade5_bee_parameters_new9a_authored_hint:
        grade5_bee_parameters_new9a_a: A `for` loop can help you with this stair step pattern, too!
        grade5_bee_parameters_new9a_b: For each stair, you'll need to call the function once, turn right, call the function again, then turn left.
      grade5_playlab_variables2_authored_hint:
        Course_4_Play_Lab_Vars_2_a: 確定在 `dog_speed`（小狗的速度）上設定的數值要大於 `cat_speed`（小貓的速度）。
      gradeK_sequence_4_authored_hint:
        gradeK_sequence_4_a: Try writing down the steps on paper to find a solution!
      gradek_adventurer_loops3_authored_hint:
        gradek_adventurer_loops3_a: To change how far the adventurer goes, change the number of times that the loop runs.
        gradek_adventurer_loops3_b: Don't forget that the adventurer needs to walk down and collect gold after she finishes the `repeat` loop!
      gradek_adventurer_loops4_authored_hint:
        gradek_adventurer_loops4_a: If you can't figure out the answer right away, try using a piece of paper to figure out what arrows you will need and look for a pattern.
      gradek_adventurer_loops4a_authored_hint:
        gradek_adventurer_loops4a_a: Can't figure out what's wrong? Try running the code to see what happens.
      gradek_adventurer_loops5_authored_hint:
        gradek_adventurer_loops5_a: If you can't figure out what comes next, try running the code to see where Laurel ends up.
      gradek_adventurer_loops6_authored_hint:
        gradek_adventurer_loops6_a: If you are having trouble figuring this puzzle out, try writing the moves down on a piece of paper and look for a pattern.
      gradek_adventurer_loops7_challenge_authored_hint:
        gradek_adventurer_loops7_challenge_a: Does the code feel really long?  Try putting two of your `repeat` loops inside of another loop to make it much shorter!
      gradek_adventurer_loops8_authored_hint:
        gradek_adventurer_loops8_a: If you can't figure out where to put the loops, try writing the code out step-by-step and look for a pattern.
      gradek_adventurer_loops9_authored_hint:
        gradek_adventurer_loops9_a: If you can't figure out where to put the loops, try writing your code step-by-step and look for patterns.
      gradek_artist_loops1_authored_hint:
        gradek_artist_loops1_a: Can't figure out how to draw a line?  Start attaching blocks to the `when run` block to see what happens.
      gradek_artist_loops2_authored_hint:
        gradek_artist_loops2_a: Is something not quite right?  Use the "Step" button to see where things go wrong.
      gradek_artist_loops3_authored_hint:
        artistLoopsK2_a: 如果你想要重複程式 4 次以上，你可以修改積木上的數字。
      gradek_artist_loops4_authored_hint:
        artistLoopsK3_a: 試著用你學到的重複積木來完成這個關卡！
      gradek_artist_loops5_authored_hint:
        gradek_artist_loops5_a: Can't figure out how to make the hill?  Try playing with the blocks a bit to see what each one draws.
      gradek_artist_loops6_authored_hint:
        gradek_artist_loops6_a: Can't figure out where to put the loop? Try writing the code step-by-step and look for a pattern.
      gradek_artist_loops7_authored_hint:
        gradek_artist_loops7_a: Try running the code to see what has been written for you.
        gradek_artist_loops7_b: How would you loop the code that has been given to you?
        gradek_artist_loops7_c: "What does the code do?  \nWhat is it supposed to do?  \nWhat does that tell you?"
      gradek_artist_loops8_authored_hint:
        gradek_artist_loops8_a: 'You don''t have to delete everything!  Some of the code is good. Use it to build the rest of the stairs. '
      gradek_artist_loops9_authored_hint:
        artistLoopsKA_a: 使用跳躍積木可以向前移動但不會畫線。
      gradek_artist_loopsA_authored_hint:
        artistLoopsKB_a: There should be 2 blocks inside of your loop to solve this puzzle.
      gradek_artist_loopsFP_authored_hint: [ ]
      gradek_playlab_events1a_authored_hint:
        gradek_playlab_events1a_a: Attach the `move up` block to the `when click` event so that the cat moves up when the "up" button is pressed.
      gradek_playlab_events1c_authored_hint:
        gradek_playlab_events1c_a: "Here is the block you should connect to the `when run` block: \n\n![](https://images.code.org/ae72d1270ad210cd00fae7e0dfb3549a-image-1478144412134.png)"
      gradek_playlab_events2c_authored_hint:
        gradek_playlab_events2c_a: 'drag this block out ![](https://images.code.org/b3d6215901969328333d6393f8101c5b-image-1478142333199.png) and connect it to ![](https://images.code.org/4f2130b2a3053695414a02c3d39ef864-image-1478143461271.png)'
      gradek_playlab_events3c_authored_hint:
        gradek_playlab_events3c_a: |-
          Here is the event block that you will need to get Jorge to move right:
          
          ![](https://images.code.org/cfc4b696b1ad5762ff40c1c8a17a194d-image-1478141370249.png)
        gradek_playlab_events3c_b: |-
          Here is the block you should connect to the `when right` event:
          
          ![](https://images.code.org/e5c559cc1deef643c8b997d17ecb78e3-image-1478141726783.png)
      gradek_playlab_events4c_authored_hint:
        gradek_playlab_events4c_a: "Here are the event blocks that you will need to use to move Jorge up and down:\n\n![](https://images.code.org/cf9a6992f7b4619dfb592fb6905effbb-image-1478140906017.png)\nand \n![](https://images.code.org/bb2a117cef485e79119a63e5d027968e-image-1478140979742.png)"
      gradek_playlab_events5c_authored_hint:
        gradek_playlab_events5c_a: |-
          Here is the event block that you would use to have Jorge do something when clicked:
          
          ![](https://images.code.org/6e3a654378643fd0590307ec3a0e429c-image-1478140058859.png)
        gradek_playlab_events5c_b: |-
          Here is the block you would use to change the background:
          
          ![](https://images.code.org/3f6d7a642b37c3abffe7b0de062ea076-image-1478140261440.png)
        gradek_playlab_events5c_c: |-
          Here is the block you would use to play a random sound:
          
          ![](https://images.code.org/81a8ef4f64023039438199fef67bb56b-image-1478140125332.png)
      gradek_playlab_eventsA_authored_hint:
        gradek_playlab_eventsA_a: |-
          If this seems like too much to do, try breaking it down into steps:
          
          1)  Have the actor change to a random size on click.
          2) Play a random sound when you click the actor.
          
          Now, make sure both of those actions are attached underneath the same event!
      harvey_tictactoe_authored_hint:
        harvey_tictactoe: 你可以利用 `跳躍` 積木移動到其它的空格。
      level 'grade3_Loops_10_authored_hint:
        2-3_Bee_Loops_4_a: 你的迴圈中應該要有 5 個積木。
      level 'grade3_Loops_11_authored_hint:
        2-3_Bee_Loops_5_a: 如果你不能馬上的就使用`重複`積木來寫出程式，可以先把一個個的指令寫出來，然後找出指令間共同的模式。
      level 'grade3_Loops_12_authored_hint:
        2-3_Bee_Loops_6_a: 如果你沒有辦法很快的分辨出要在`重複`迴圈中放些什麼積木，可以試著先按照順序拖曳出每個積木，並在拖曳過程中找出它們的規律。
        2-3_Bee_Loops_6_b: 你的`重複`迴圈裡應該要有 6 個積木才對。
      level 'grade3_Loops_4_authored_hint:
        2-3_Bee_Loops_3B_a: 你需要 2 個不同的`重複`迴圈，一個接著一個。
      level 'grade3_Loops_5_authored_hint:
        2-3_Bee_Loops_7_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_7_b: '如果你實在無法從頭想像迴圈的內容，可以先把需要的指令寫成長一點的程式，然後從裡頭找出組合模式。  '
      level 'grade3_Loops_6_authored_hint:
        2-3_Bee_Loops_4A_a: 第一個動作是轉向，而不是移動。
        2-3_Bee_Loops_4A_b: 在迴圈之外的結尾處再加上一些程式就可以完成了。
        2-3_Bee_Loops_4A_c: 如果你還不能準確的使用迴圈，可以先用長串的指令，然後再找出有什麼地方是可以用`重複`迴圈來替代的。
      level 'grade3_Loops_8_authored_hint:
        2-3_Bee_Loops_2_a: 你的迴圈中應該要有 4 個積木。
      level 'grade3_Loops_9_authored_hint:
        2-3_Bee_Loops_3_a: 你的迴圈中應該要有 6 個積木。
      playLabDebugVideo1_authored_hint:
        courseA_playLab_events2_a: "Here is the block you should connect to the `when run` block: \n\n![](https://images.code.org/ae72d1270ad210cd00fae7e0dfb3549a-image-1478144412134.png)"
      sample3_authored_hint:
        sample3_a: |-
          Try writing the code once and looping it seven times:
          
          ![](https://images.code.org/2a116e75e31ee3a8a8683349c9460286-image-1464307689813.gif)
      sample5_authored_hint:
        sample5_a: Did you know that you can put as many blocks inside of a repeat loop as you want to?
        sample5_b: |-
          The bee is looping these actions over and over again:
          - move forward
          - make honey
          - turn left
          - move forward
          - turn right
      sample6_authored_hint:
        sample6_a: Did you know that you can use more than one repeat loop in a puzzle?
        sample6_b: Sometimes repeat loops have lots of blocks inside, and sometimes they might only have one!
      sample7assessment_authored_hint: [ ]
