# Secrets

We use a custom process (see [#30036](https://github.com/code-dot-org/code-dot-org/pull/30036)) for storing and using secrets within our application, using a custom `!Secret` YAML tag. This tag marks certain keys as Secrets to be lazy-loaded from the [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/) service through calls to the [`GetSecretValue`](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html) API.

We provision AWS Secrets for specific environment types (`adhoc`, `staging`, `test`, `levelbuilder`, `production`, etc.) so that `CDO.foo_api_key` is potentially populated by a different AWS Secret (`production/cdo/foo_api_key`, `test/cdo/foo_api_key`, etc.) on different systems. This requires all systems of a specific type to share the same secret value. For example all adhoc environments have to use the same AWS Secret `adhoc/cdo/foo_api_key`. Pull Request [#48809](https://github.com/code-dot-org/code-dot-org/pull/48809) adds the ability for a `CDO.` configuration setting to be populated from an AWS Secret that is provisioned exclusively for a single deployment of our application. Use the `!StackSecret` directive and provision the AWS Secret in the [CloudFormation template that provisions our system](https://github.com/code-dot-org/code-dot-org/blob/staging/aws/cloudformation/cloud_formation_stack.yml.erb). WARNING: Due to a circular dependency between our Ruby application and our CloudFormation template, you must deploy a new AWS Secret in the `CfnStack/[stack name]/` namespace in a Pull Request to all managed environments (staging/test/levelbuilder/production), before merging a follow on Pull Request that declares and populates a CDO configuration setting via `!StackSecret` from that new AWS Secret.

### Referencing a secret
`!Secret`-tagged config keys (e.g.: `my_secret: !Secret`) are all mapped onto the `CDO` application-config namespace as usual, so you can reference a secret using `CDO.my_secret` in application code.

* Secrets are lazy-loaded, so the call to `GetSecretValue` will only take place when the secret is referenced.
  * An exception is running the application-server (in non-`development` environments), where all secrets are explicitly eager-loaded (before the application-server forks multiple processes), and will fail with an exception if the API fails or any expected secrets are not found.
* Secrets are cached in-memory once fetched to ensure only one API call per secret when the application is running.
* Secrets are stored and fetched separately based on the environment, so referencing `CDO.my_secret` actually fetches the secret named `staging/cdo/my_secret`, `production/cdo/my_secret`, etc depending on the environment.
* AWS access permissions are tuned so that the application has read-only access to secrets in its own environment (e.g., a `staging` application can't read `production` secrets), for security purposes.
  * The `Developer` role is also prevented from reading secrets outside of the `development` environment for a better security posture.
* Certain environments (`development`, `adhoc`, and `test`-unit_test/CI) include a `<%= clear_secrets %>` line in their environment-specific config, which disables _all_ globally-defined secrets by default for that environment. These environments generally should not require secrets to function, since AWS credentials are not guaranteed. To add an exception, you can opt-in to a specific secret by re-defining it below the `clear_secrets` line. (Make sure the secret is really necessary and the usage scope limited, since use of the secret will require AWS credentials!)

### Creating/updating a secret
* Create a `config/secrets.yml` file (see [`secrets.yml.template`](secrets.yml.template) as a reference) containing the configuration for the secrets you wish to create/update, then run the [`bin/update_secrets`](../bin/update_secrets) helper script to apply the changes.
* Update the application configuration files (`config.yml.erb` / `config/[env].yml.erb`) with `!Secret` tags for each environment where the secret now exists.
* Remember that all secrets (except those in `development`) are write-only by developers for security reasons- you shouldn't ever need to read a secret's actual value once written (leave that to the environment-specific application).