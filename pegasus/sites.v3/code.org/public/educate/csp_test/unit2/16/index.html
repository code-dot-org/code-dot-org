<!doctype html>
<html lang="en">


<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="">
    <meta name="description" content="In this lesson, students examine a classic problem in computer science, the Traveling Salesperson Problem (TSP). Students solve small instances of the problem, try to formulate algorithms to solve it, and discuss why these algorithms take a long time for computers (and humans) to compute. Students see how the TSP grows in size much faster than the problem of adding characters to a password. Even though we use encryption to motivate a desire to learn about computationally hard problems, they are valuable to know about, in and of themselves. This lesson covers some territory about how we reason formally and mathematically about algorithms and figuring out how “hard” something is for a computer to do.">
    <title>Algorithms Detour - Hard Problems - Traveling Salesperson Problem</title>
    <link rel="shortcut icon" href="https://cdo-curriculum.s3.amazonaws.com/static/img/favicon.ico">

    

    
        <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/bootstrap.css">
        <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/mezzanine.css">
        <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/bootstrap-theme.css">
        <!--<link rel="stylesheet" href="https://code.org/style.css">-->
        <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/codeorg.css">
        <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/common.css">
        
    <link rel="stylesheet" href="https://cdo-curriculum.s3.amazonaws.com/static/css/commonlesson.css">

    

    
        <script src="https://cdo-curriculum.s3.amazonaws.com/static/mezzanine/js/jquery-1.8.3.min.js"></script>
        <script src="https://cdo-curriculum.s3.amazonaws.com/static/js/bootstrap.js"></script>
        <script src="https://cdo-curriculum.s3.amazonaws.com/static/js/bootstrap-extras.js"></script>
        
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
    <script src="https://cdo-curriculum.s3.amazonaws.com/static/js/toc.js"></script>
    <script src="https://cdo-curriculum.s3.amazonaws.com/static/js/jquery.details.min.js"></script>
    <script type="text/javascript">
    </script>

    


    

    <!--[if lt IE 9]>
<script src="https://cdo-curriculum.s3.amazonaws.com/static/js/html5shiv.js"></script>
<script src="https://cdo-curriculum.s3.amazonaws.com/static/js/respond.min.js"></script>
<![endif]-->

    
</head>

<body id="body">


    <div id="admin_edit">
    
    <button type="button" class="togglesay btn btn-success">Don't tell me what to say!</button>
    <button type="button" class="togglesay btn btn-danger" style="display:none;">Help, what should I say?</button>
    </div>



<div class="container">
    <div class="header printbackground">
        <div class="headercontent">
            <div class="top">
                <div class="logo">
                    <img src="https://cdo-curriculum.s3.amazonaws.com/static/images/logo.png">
                </div>
                
    <div class="unitnumber"><span class="h2">Unit</span><span class="h1">2</span></div>

    <div class="lessons">
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/1" data-pdf-link="#unit2lesson1">
        1
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/2" data-pdf-link="#unit2lesson2">
        2
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/3" data-pdf-link="#unit2lesson3">
        3
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/4" data-pdf-link="#unit2lesson4">
        4
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/5" data-pdf-link="#unit2lesson5">
        5
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/6" data-pdf-link="#unit2lesson6">
        6
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/7" data-pdf-link="#unit2lesson7">
        7
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/8" data-pdf-link="#unit2lesson8">
        8
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/9" data-pdf-link="#unit2lesson9">
        9
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/10" data-pdf-link="#unit2lesson10">
        10
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/11" data-pdf-link="#unit2lesson11">
        11
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/12" data-pdf-link="#unit2lesson12">
        12
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/13" data-pdf-link="#unit2lesson13">
        13
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/14" data-pdf-link="#unit2lesson14">
        14
    </a>
    </div>
    
        
            <div class="lesson finished">
        
    <a href="/educate/csp_test/unit2/15" data-pdf-link="#unit2lesson15">
        15
    </a>
    </div>
    
        
            <div class="lesson current">
        
    <a href="/educate/csp_test/unit2/16" data-pdf-link="#unit2lesson16">
        16
    </a>
    </div>
    
        
            <div class="lesson unfinished">
        
    <a href="/educate/csp_test/unit2/17" data-pdf-link="#unit2lesson17">
        17
    </a>
    </div>
    
        
            <div class="lesson unfinished">
        
    <a href="/educate/csp_test/unit2/18" data-pdf-link="#unit2lesson18">
        18
    </a>
    </div>
    
        
            <div class="lesson unfinished">
        
    <a href="/educate/csp_test/unit2/19" data-pdf-link="#unit2lesson19">
        19
    </a>
    </div>
    
        
            <div class="lesson unfinished">
        
    <a href="/educate/csp_test/unit2/20" data-pdf-link="#unit2lesson20">
        20
    </a>
    </div>
    
</div>


            </div>
            <div class="bottom">
            

            </div>
        </div>
    </div>
    <div class="content">
        

    <div class="together" id="unit2lesson16">
        
            <h1>Lesson 16: Algorithms Detour - Hard Problems - Traveling Salesperson Problem</h1>
        
    </div>

    <div class="together overview-page row">

        <div class="col-sm-7 left-col">
            <h2>Overview</h2>
            
                <p>In this lesson, students examine a classic problem in computer science, the Traveling Salesperson Problem (TSP). Students solve small instances of the problem, try to formulate algorithms to solve it, and discuss why these algorithms take a long time for computers (and humans) to compute. Students see how the TSP grows in size much faster than the problem of adding characters to a password.  Even though we use encryption to motivate a desire to learn about computationally hard problems, they are valuable to know about, in and of themselves.  This lesson covers some territory about how we reason formally and mathematically about algorithms and figuring out how “hard” something is for a computer to do.</p>
            

            
                <h2>Purpose</h2>
                
                    <p>In this final algorithm detour, students are introduced to the Traveling Salesperson Problem, a classic problem in computer science for which there is no known algorithm to solve it, other than brute force.  The number of possible solutions grows extremely fast, even for small inputs, and quickly becomes “unreasonable” to solve, making it a computationally hard problem. The ideas of computationally hard problems are leveraged for encryption to make ciphers that take an unreasonable amount of time to crack (as in thousands of trillions of years), but computationally hard problems are also important in their own right. There are many problems for which we wish we had reasonable algorithmic solutions - especially in medical fields - and we’re still on the hunt to find them.  No one has yet mathematically proven whether or not the problems we currently think are “hard” actually are.</p>
                
            

            <h2>Agenda</h2>
            <div class="toc" id="tocalgorithms-detour-hard-problems-traveling-salesperson-problem">
                
                    <h3>Getting Started</h3>
                
                    <h3>Activity</h3>
                
                    <h3>Wrap-up</h3>
                
                    <h3>Extended Learning</h3>
                
                    <h3>Assessment</h3>
                
            </div>

        </div>

        <div class="col-sm-5 right-col">

            

            
                <h2>Objectives</h2>
                <h3>Students will be able to:</h3>
                <ul>
                    
                        <li>Describe the TSP.</li>
                    
                        <li>Explain why TSP is computationally hard.</li>
                    
                        <li>Solve the TSP on small graphs.</li>
                    
                        <li>Connect the properties of computationally hard problems with desirable properties for encryption.</li>
                    
                </ul>
            

            
                <h2>Preparation</h2>
                <div class="prep">
                
                    <ul>
<li><a href="http://forum.code.org/c/csp-unit2/lesson16" target="_blank">Forum</a></li>
<li>Note that Wrap-up for this lesson is more extensive than usual. Some preparation to familiarize yourself with the ideas is recommended.</li>
<li>(Optional) Copies of the Worksheet for each student</li>
</ul>
                
                </div>
            

            
                <h2>Links</h2>
                
                    
                    
                        <h3>For the Students</h3>
                        <ul>
                            
                                <li>
                                    <a href='https://docs.google.com/document/d/1hSuSothXeTbKRRZeXx8CSL-DXl6BmnKzDnIYdM_lpDA/edit' target='_blank' class='print_link'>Introduction to the Traveling Salesperson Problem</a> - Worksheet (<a href='https://docs.google.com/document/d/1hSuSothXeTbKRRZeXx8CSL-DXl6BmnKzDnIYdM_lpDA/export?format=pdf' class='print_link'>download</a>)
                                </li>
                            
                        </ul>
                    
                
            

            

        </div>
    </div>

    <div id="algorithms-detour-hard-problems-traveling-salesperson-problemcontent">

        <h1>Teaching Guide</h1>

        
            <div class="activity">
                
                    <h2>Getting Started</h2>
                    <p><strong>Recall:</strong> Say: In a previous lesson we looked at the problem of trying to crack passwords and learned it would take a computer a very long time to try every possible combination of letters.  We learned that the longer a password is, the harder it is to crack. This is because every character you add multiplies the number of possible passwords by the number of possibilities for that character. That’s pretty fast growth.</p>
<p><em>Say:</em> <strong>Computationally Hard Problems</strong> are problems that force a computer to run through many possibilities to find the right answer.  In cryptography, our desire is to have an encryption function that is easy compute if you have the key, but really hard if you don’t. </p>
<p><strong>Transition:</strong> Today we’re going to look at one of the most famous problems that is thought to be computationally hard.  We’ll see if we can find an algorithm to solve it, and along the way, we’ll get a better sense of what “computationally hard” really means.</p>
                
            </div>
        
            <div class="activity">
                
                    <h2>Activity</h2>
                    <h3 id="introduce-the-traveling-salesperson-problem">Introduce the traveling salesperson problem.</h3>
<p>Distribute the <a href="Introduction to the Traveling Salesperson Problem" target="_blank">Worksheet - Introduction to the Traveling Salesperson Problem</a>. </p>
<ul>
<li>Give individual students time to work on finding the shortest routes for the small examples in the worksheet.</li>
<li>Make sure that students to compare their answers.<ul>
<li>If two partners disagree, they should resolve it to find the shortest tour.</li>
</ul>
</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Teaching Tips</p>
<p><strong>Note:</strong> This problem at first might seem like the Shortest Path problem we looked at in a previous lesson, but it’s actually a much, much harder problem to solve with an algorithm. In fact there is <strong>no known algorithm to solve the TSP, other than by “brute force”</strong> – trying every single possible tour of the nodes and then picking the one that gives the shortest possible tour.</p>
</div>
<p>If you ask students how they arrived at their solutions they might say, “I tried a bunch of different paths and kept track of the shortest.” Or some form of greedy algorithm: “I want to avoid that large edge” or “I want to use that small edge.”  These are good strategies, but they can always be thwarted with the question, “How do you know for sure it’s the shortest?” </p>
<h3 id="discuss">Discuss.</h3>
<p><strong>Goal:</strong> The goal of the discussion is to bring out the fact that this would be a much harder problem for computers to solve than the shortest path problem or minimum spanning tree problem. “Hard” means that there is no known way to find the correct answer without generating ALL possible answers.  Connect this problem to our desire to understand problems that are computationally hard for computers for encryption.  </p>
<p><em>Prompts:</em></p>
<ul>
<li>What makes this problem harder than the shortest path problem?<ul>
<li>First of all you need to make a closed path (route) of all vertices without revisiting vertices. This is a harder thing to do than just finding a path from one vertex to another. Just constructing a valid route is difficult.</li>
<li>Second, you don’t know where to start.  Any edge could be part of the shortest tour. And once you pick an edge to start with, you still have no way to choose the next one. There is no way to eliminate possibilities from the start or as you go.  </li>
</ul>
</li>
<li>What kinds of algorithms did you think about in trying to solve the problem?<ul>
<li>Students might suggest strategies that leverage what they know about solving the minimum spanning tree and shortest path problems from previous lessons, such as starting with the least-cost edge in the graph, and then “greedily” connecting nodes by picking subsequent least-cost edges.</li>
<li>This is a good heuristic and might yield a tour that is better than the worst possible tour, but there is no guarantee it’s the best.</li>
<li>The only algorithm that is known to find the absolute shortest tour every time is brute force,  generating every possible tour and comparing them.</li>
</ul>
</li>
</ul>
                
            </div>
        
            <div class="activity">
                
                    <h2>Wrap-up</h2>
                    <div class="admonition tip">
<p class="admonition-title">Teaching Tips</p>
<p>This is a fairly extended wrap-up that asks the teacher to lead students through some reasoning about the traveling salesperson problem.  Some preparation is recommended.</p>
<p>The entire section below could serve as a script for the session.</p>
</div>
<p><em>Say:</em> </p>
<p>If I told you that we could make an encryption scheme that was as hard to crack as it is to solve the traveling salesperson problem, would you feel reasonably assured of your security?</p>
<p>To answer that, let’s figure out just how hard TSP is.</p>
<h3 id="explain-exponential-growth-how-many-possible-tours-are-there">Explain Exponential Growth - How many possible tours are there?</h3>
<p>Many people for many years have tried to design an algorithm that works in all cases to find the exact optimum route for the traveling salesperson problem, with no success. So there is currently no algorithm to find the exact answer besides “brute force,” trying all the possibilities. </p>
<p>Since we have to calculate the distances of all the tours anyway, we might as well <strong>count how many tours there are in the first place, just so we know how many calculations we have to perform.</strong></p>
<p>For this demonstration, let’s also consider a version of the problem faced by, say, an airline.  For an airline, there are cities all over the world, and you can fly from any one directly to any other. So for an airline, there is a possible path that connects every possible node; we say the graph is “fully connected.” </p>
<p>Let’s see how the problem grows very quickly, by constructing all the possible tours for larger and larger numbers of nodes.</p>
<p><strong>Let’s start with 3 nodes.</strong> There is only one possible tour.  Easy.</p>
<p><img alt="" src="https://code.org/educate/docs/csp/U2L16-tsp-1.png"></p>
<p>With 4 nodes, there are only 3 possible tours. Not bad.</p>
<p><img alt="" src="https://code.org/educate/docs/csp/U2L16-tsp-2.png"></p>
<p>Here’s where it starts to get crazy.  <strong>With 5 nodes</strong> there are 12 possible tours. How can you figure this out?  The way shown below was to reason that a 5th node could be added between each pair of nodes for every possible 4-node tour.  Here, the actual distances don’t matter because we’re just trying to count the number of tours.   </p>
<p><img alt="" src="https://code.org/educate/docs/csp/U2L16-tsp-3.png"></p>
<p>Below is another view of the same thing.  In this version we took each 4-node tour and “broke” one of the edges, connecting it to the new 5th node.  Just a different way to think about it.</p>
<p><img alt="" src="https://code.org/educate/docs/csp/U2L16-tsp-4.png"></p>
<p><strong>For 6 nodes</strong> we could repeat the process: add a node to every possible edge of the 12 solutions 5-node solutions.  Since each of 12 solutions above has 5 edges, it means we have 12*5 = 60 tours!</p>
<p><strong>Notice how fast this grows:</strong> between a graph with 3 nodes and a graph of 6 nodes, our total number of possible tours grew from 1 to 60.  This problem grows very quickly!</p>
<p>With just <strong>10 nodes</strong>, this grows to about <strong>181,440 possible tours.</strong></p>
<p>With just <strong>26 nodes</strong>, this grows to a 25-digit number: <strong>7,755,605,021,665,492,992,000,000</strong>.
(By comparison, the width of the <strong><em>entire observable universe(!!!!)</em></strong> in miles is roughly a 25-digit number.)</p>
<p>With <strong>100</strong> nodes you’re up to a roughly a 155-digit number. </p>
<p><strong>The math:</strong> With n nodes there are (n-1)!/2 (“n-1 factorial divided by 2”) possible tours. 
n! (or “n factorial”) is n<em>(n-1)</em>(n-2)<em>(n-3)…(2)</em>(1).   So for example 10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.
You can confirm the formula with the examples above: 5 nodes = (5-1)! / 2 = 12.</p>
<h3 id="reasonable-or-unreasonable-time">Reasonable or Unreasonable Time</h3>
<p>Computers work fast, but they have limits. In computer science, we have an actual mathematical hard line between reasonable and unreasonable runtimes. </p>
<p><strong>“Reasonable”</strong> means the number of things the computer has to do is proportional to the size of the input to the problem.  For example, the Minimum Spanning Tree and Shortest Path Problems are “reasonable” because they had algorithms that solved them by considering every edge in the graph once.  The amount of time it takes is proportional to the number of edges.  If the number of edges is n, even if there was an algorithm that had to look at the edge n^2 times, or n^3 times, that’s still reasonable.</p>
<p><strong>“Unreasonable”</strong> means the number of things the computer has to do grows as an exponent of the size of the input.  So if you discovered that an algorithm made the computer do 2^n things, that’s not reasonable, because it means every time the size of the input (n) gets bigger, the solution gets massively further out of reach.   n! is another running time that is considered unreasonable.  In real life, “unreasonable” problems would take a modern computer trillions and trillions of years to churn through all the possibilities.</p>
<p>So the brute force solution to TSP is unreasonable – at least as far as we know!  In fact, it’s an open question how to solve this problem efficiently.  If anyone finds a solution that runs in a reasonable time, a lot of security and encryption algorithms are in trouble, because many are based on the fact that this (and related problems) are unreasonable to solve.</p>
<p>So now we know what “hard” is for a computer. And in the next lesson, we’ll discuss how to leverage hard problems like this one to create public keys that are tough for computers to crack.</p>
                
            </div>
        
            <div class="activity">
                
                    <h2>Extended Learning</h2>
                    <ul>
<li>On Traveling Salesperson (https://preview.c9users.io/bfranke/cspdashboard/Graph/TSP.html), practice finding TSP solutions on random graphs.</li>
<li>If you do a quick Google search on the Traveling Salesperson Problem, you will find many many interesting resources. For example, here is a two-minute video (https://www.youtube.com/watch?v=SC5CX8drAtU) that shows a nice visualization of some heuristics for TSP that give pretty good tours, but still not optimal, because there are just too many possibilities to consider. </li>
</ul>
                
            </div>
        
            <div class="activity">
                
                    <h2>Assessment</h2>
                    <p><strong>Questions:</strong></p>
<p>1) Describe what it means for a problem to be “computationally hard.”</p>
<p>2) What strategies do people use to solve large computationally hard problems?</p>
<p>3) Why are computationally hard problems important in encryption strategies?</p>
                
            </div>
        
    </div>

    <div class="standards">
        <h2>Standards Alignment</h2>
        

    <div class="framework">
        <h4>CSTA K-12 Computer Science Standards</h4>
        
            
            
                <details class="standard">
                    <summary><strong>CT</strong> - Computational Thinking</summary>
                    <ul>
                        
                            <li><strong>CT.L3B:1</strong> - Classify problems as tractable, intractable, or computationally unsolvable.</li>
                        
                            <li><strong>CT.L3B:2</strong> - Explain the value of heuristic algorithms to approximate solutions for intractable problems.</li>
                        
                            <li><strong>CT.L3B:3</strong> - Critically examine classical algorithms and implement an original algorithm.</li>
                        
                            <li><strong>CT.L3B:4</strong> - Evaluate algorithms by their efficiency, correctness, and clarity.</li>
                        
                    </ul>
                </details>
            
        
    </div>

    <div class="framework">
        <h4>Computer Science Principles</h4>
        
            
            
                <details class="standard">
                    <summary><strong>4.2</strong> - Algorithms can solve many but not all computational problems.</summary>
                    
                    
                        <details class="standard">
                            <summary><strong>4.2.1</strong> - Explain the difference between algorithms that run in a reasonable time and those that do not run in a reasonable time. [P1]</summary>
                            <ul>
                                
                                    <li><strong>4.2.1A</strong> - Many problems can be solved in a reasonable time.</li>
                                
                                    <li><strong>4.2.1B</strong> - Reasonable time means that as the input size grows, the number of steps the algorithm takes is proportional to the square (or cube, fourth power, fifth power, etc.) of the size of the input. </li>
                                
                                    <li><strong>4.2.1C</strong> - Some problems cannot be solved in a reasonable time, even for small input sizes.</li>
                                
                                    <li><strong>4.2.1D</strong> - Some problems can be solved but not in a reasonable time. In these cases, heuristic approaches may be helpful to find solutions in reasonable time.</li>
                                
                            </ul>
                        </details>
                    
                        <details class="standard">
                            <summary><strong>4.2.3</strong> - Explain the existence of undecidable problems in computer science. [P1]</summary>
                            <ul>
                                
                                    <li><strong>4.2.3A</strong> - An undecidable problem may have instances that have an algorithmic solution, but there is no algorithmic solution that solves all instances of the problem.</li>
                                
                            </ul>
                        </details>
                    
                        <details class="standard">
                            <summary><strong>4.2.4</strong> - Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]</summary>
                            <ul>
                                
                                    <li><strong>4.2.4A</strong> - Determining an algorithmâ€™s efficiency is done by reasoning formally or mathematically about the algorithm.</li>
                                
                                    <li><strong>4.2.4B</strong> - Empirical analysis of an algorithm is done by implementing the algorithm and running it on different inputs.</li>
                                
                                    <li><strong>4.2.4C</strong> - The correctness of an algorithm is determined by reasoning formally or mathematically about the algorithm, not by testing an implementation of the algorithm.</li>
                                
                            </ul>
                        </details>
                    
                </details>
            
        
    </div>

    </div>


    



    <script type="text/javascript">
        $('#tocalgorithms-detour-hard-problems-traveling-salesperson-problem').toc({
            'selectors': 'h2,h3', //elements to use as headings
            'container': '#algorithms-detour-hard-problems-traveling-salesperson-problemcontent', //element to find all selectors in
            'smoothScrolling': false, //enable or disable smooth scrolling on click
            'prefix': 'algorithms-detour-hard-problems-traveling-salesperson-problem', //prefix for anchor tags and class names
            'onHighlight': function(el) {}, //called when a new section is highlighted
            'highlightOnScroll': true, //add class to heading that is currently in focus
            'highlightOffset': 100, //offset to trigger the next headline
            'anchorName': function(i, heading, prefix) { //custom function for anchor name
                return prefix+i;
            },
            'headerText': function(i, heading, $heading) { //custom function building the header-item text
                return $heading.text();
            },
            'itemClass': function(i, heading, $heading, prefix) { // custom function for item class
                return $heading[0].tagName.toLowerCase();
            }
        });
        $(function(){
            $('.togglesay').live('click', function() {
                $('.say').slideToggle();
                $('.togglesay').toggle();
            });
        });
        $(document).ready(function () {
            // add checkboxes to lists in the prep section
            var count = 1;
            //$('<input type="checkbox" class="todo" name="' + (count++) + '"/>').prependTo(".prep ul li");
            $(".prep ul li:visible").each(function(li) {
                $(this).prepend('<input type="checkbox" class="todo" name="' + (count++) + '"/>');
            });
            // read the current/previous setting
            $("input.todo").each(function() {
                var mycookie = $.cookie($(this).attr('name'));
                if (mycookie && mycookie == "true") {
                    $(this).prop('checked', mycookie);
                }
            });
            $("input.todo").change(function() {
                $.cookie($(this).attr("name"), $(this).prop('checked'), {
                    path: '/',
                    expires: 365
                });
            });
            // Add tooltip toggles to vocab
            $('.vocab').each(function() {
                $(this).attr('data-toggle', 'tooltip');
                $(this).attr('data-placement', 'bottom');
            });
            $(function () {
                $('[data-toggle="tooltip"]').tooltip()
            });
        });
    </script>

    <!--<script type="text/javascript">
        jQuery(function ($) {
            $('body').annotator();
        });
    </script>-->

    <!--<script type="text/javascript">
        $(function() {
            // Add conditional classname based on support
            $('html').addClass($.fn.details.support ? 'details' : 'no-details');
            // Emulate <details> where necessary and enable open/close event handlers
            $('details').details();
            // Bind some example event handlers
            $('details').on({
                'open.details': function() {
                    console.log('opened');
                },
                'close.details': function() {
                    console.log('closed');
                }
            });
        });
    </script>-->


    </div>
</div>
<footer>
    <div class="container">
        <div class="row">
            <a href="http://creativecommons.org/"><img src="http://www.thinkersmith.org/images/creativeCommons.png" border="0"></a>
        </div>
    </div>
</footer>
<div id="print_trigger"></div>
<script type="text/javascript">
    var vars = [], hash;
        var q = document.URL.split('?')[1];
        if(q != undefined){
            q = q.split('&');
            for(var i = 0; i < q.length; i++){
                hash = q[i].split('=');
                vars.push(hash[1]);
                vars[hash[0]] = hash[1];
            }
    }

    if (vars['pdf']) {
        jQuery(function () {
            $('a[data-pdf-link]').each(function () {
                this.href = $(this).attr('data-pdf-link');
            });
        });
    }
</script>







<script>

</script>

<!--<script async defer src="https://factlink.com/lib/dist/factlink_loader.min.js"></script>-->
</body>
</html>
