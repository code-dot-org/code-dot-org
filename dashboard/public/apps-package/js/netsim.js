require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/trevor/code-dot-org/apps/build/js/netsim/main.js":[function(require,module,exports){
'use strict';

var appMain = require('../appMain');
var studioApp = require('../StudioApp').singleton;
var NetSim = require('./netsim');

var levels = require('./levels');
var skins = require('./skins');

window.netsimMain = function (options) {
  options.skinsModule = skins;
  options.isEditorless = true;

  var netSim = new NetSim();
  netSim.injectStudioApp(studioApp);
  appMain(netSim, levels, options);
};

},{"../StudioApp":"/home/trevor/code-dot-org/apps/build/js/StudioApp.js","../appMain":"/home/trevor/code-dot-org/apps/build/js/appMain.js","./levels":"/home/trevor/code-dot-org/apps/build/js/netsim/levels.js","./netsim":"/home/trevor/code-dot-org/apps/build/js/netsim/netsim.js","./skins":"/home/trevor/code-dot-org/apps/build/js/netsim/skins.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/skins.js":[function(require,module,exports){
'use strict';

var skinBase = require('../skins');

exports.load = function (assetUrl, id) {
  var skin = skinBase.load(assetUrl, id);
  return skin;
};

},{"../skins":"/home/trevor/code-dot-org/apps/build/js/skins.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/netsim.js":[function(require,module,exports){
/**
 * @overview Internet Simulator app for Code.org.
 *           This file is the main entry point for the Internet Simulator.
 */

/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
*/
/* global -Blockly */
/* global sendReport */
/* global confirm */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var ObservableEvent = require('../ObservableEvent');
var RunLoop = require('../RunLoop');
var page = require('./page.html.ejs');
var NetSimAlert = require('./NetSimAlert');
var NetSimConstants = require('./NetSimConstants');
var NetSimUtils = require('./NetSimUtils');
var DashboardUser = require('./DashboardUser');
var NetSimBitLogPanel = require('./NetSimBitLogPanel');
var NetSimLobby = require('./NetSimLobby');
var NetSimLocalClientNode = require('./NetSimLocalClientNode');
var NetSimLogger = require('./NetSimLogger');
var NetSimLogPanel = require('./NetSimLogPanel');
var NetSimRouterLogModal = require('./NetSimRouterLogModal');
var NetSimRouterNode = require('./NetSimRouterNode');
var NetSimSendPanel = require('./NetSimSendPanel');
var NetSimShard = require('./NetSimShard');
var NetSimStatusPanel = require('./NetSimStatusPanel');
var NetSimTabsComponent = require('./NetSimTabsComponent');
var NetSimVisualization = require('./NetSimVisualization');

var DnsMode = NetSimConstants.DnsMode;
var MessageGranularity = NetSimConstants.MessageGranularity;

var logger = NetSimLogger.getSingleton();
var NetSimGlobals = require('./NetSimGlobals');

/**
 * The top-level Internet Simulator controller.
 * @param {StudioApp} studioApp The studioApp instance to build upon.
 */
var NetSim = module.exports = function () {
  /**
   * @type {Object}
   */
  this.skin = null;

  /**
   * @type {NetSimLevelConfiguration}
   */
  this.level = {};

  /**
   * @type {number}
   */
  this.heading = 0;

  /**
   * Current user object which asynchronously grabs the current user's
   * info from the dashboard API.
   * @type {DashboardUser}
   * @private
   */
  this.currentUser_ = DashboardUser.getCurrentUser();

  /**
   * Accessor object for select simulation shard's tables, where an shard
   * is a group of tables shared by a group of users, allowing them to observe
   * a common network state.
   *
   * See en.wikipedia.org/wiki/Instance_dungeon for a popular example of this
   * concept.
   *
   * @type {NetSimShard}
   * @private
   */
  this.shard_ = null;

  /**
   * The local client's node representation within the shard.
   * @type {NetSimLocalClientNode}
   */
  this.myNode = null;

  /**
   * Tick and Render loop manager for the simulator
   * @type {RunLoop}
   * @private
   */
  this.runLoop_ = new RunLoop();

  /**
   * Current chunk size (bytesize)
   * @type {number}
   * @private
   */
  this.chunkSize_ = 8;

  /**
   * The "my device" bitrate in bits per second
   * @type {number}
   * @private
   */
  this.myDeviceBitRate_ = Infinity;

  /**
   * Currently enabled encoding types.
   * @type {EncodingType[]}
   * @private
   */
  this.enabledEncodings_ = [];

  /**
   * Current dns mode.
   * @type {DnsMode}
   * @private
   */
  this.dnsMode_ = DnsMode.NONE;

  // -- Components --
  /**
   * @type {INetSimLogPanel}
   * @private
   */
  this.receivedMessageLog_ = null;

  /**
   * @type {INetSimLogPanel}
   * @private
   */
  this.sentMessageLog_ = null;

  /**
   * Event: Connected to, or disconnected from, a shard.
   * Specifically, added or removed our client node from the shard's node table.
   * @type {ObservableEvent}
   */
  this.shardChange = new ObservableEvent();
  this.shardChange.register(this.onShardChange_.bind(this));

  /**
   * Untyped storage for information about which events we have currently bound.
   * @type {Object}
   */
  this.eventKeys = {};
};

NetSim.prototype.injectStudioApp = function (studioApp) {
  this.studioApp_ = studioApp;
};

/**
 * Called on page load.
 * @param {Object} config
 * @param {Object} config.skin
 * @param {NetSimLevelConfiguration} config.level
 * @param {string} config.rackEnv - development/production/etc.
 * @param {boolean} config.enableShowCode - Always false for NetSim
 * @param {function} config.loadAudio
 * @param {string} config.html - rendered markup to be created inside this method
 */
NetSim.prototype.init = function (config) {
  if (!this.studioApp_) {
    throw new Error("NetSim requires a StudioApp");
  }

  // Set up global singleton for easy access to simulator-wide settings
  NetSimGlobals.setRootControllers(this.studioApp_, this);

  // Remove icon from all NetSim instructions dialogs
  config.skin.staticAvatar = null;
  config.skin.smallStaticAvatar = null;
  config.skin.failureAvatar = null;
  config.skin.winAvatar = null;

  /**
   * Skin for the loaded level
   * @type {Object}
   */
  this.skin = config.skin;

  /**
   * Configuration for the loaded level
   * @type {NetSimLevelConfiguration}
   */
  this.level = NetSimUtils.scrubLevelConfiguration_(config.level);

  /**
   * Current operating environment, used to drive certain configuration.
   * @type {string} one of "development"|"staging"|"test"|"production"
   */
  this.environment = config.rackEnv;

  /**
   * Whether NetSim should subscribe to events using Pusher.
   * @type {boolean}
   */
  this.usePusher = config.usePusher;

  /**
   * The public application key for the Pusher service. (Not used if not using
   * Pusher).
   * @type {string}
   */
  this.pusherApplicationKey = config.pusherApplicationKey;

  /**
   * The strict maximum number of routers per shard.  Note the real maximum
   * may be lower if bounded by addressable space.
   * @type {number}
   */
  this.globalMaxRouters = config.netsimMaxRouters;

  /**
   * Configuration for reporting level completion
   * @type {Object}
   */
  this.reportingInfo_ = config.report;

  config.html = page({
    assetUrl: this.studioApp_.assetUrl,
    data: {
      visualization: '',
      localeDirection: this.studioApp_.localeDirection(),
      controls: require('./controls.html.ejs')({ assetUrl: this.studioApp_.assetUrl })
    },
    hideRunButton: true
  });

  config.enableShowCode = false;
  config.pinWorkspaceToBottom = true;
  config.loadAudio = this.loadAudio_.bind(this);

  // Override certain StudioApp methods - netsim does a lot of configuration
  // itself, because of its nonstandard layout.
  this.studioApp_.configureDom = NetSim.configureDomOverride_.bind(this.studioApp_);
  this.studioApp_.onResize = NetSim.onResizeOverride_.bind(this.studioApp_);

  this.studioApp_.init(config);

  // Create netsim lobby widget in page
  this.currentUser_.whenReady((function () {
    this.initWithUser_(this.currentUser_);
  }).bind(this));

  // Begin the main simulation loop
  this.runLoop_.tick.register(this.tick.bind(this));
  this.runLoop_.begin();
};

/**
 * @param {RunLoop.Clock} clock
 */
NetSim.prototype.tick = function (clock) {
  if (this.isConnectedToShard()) {
    this.myNode.tick(clock);
    this.shard_.tick(clock);
  }
};

/**
 * Pull an identifier from the URL that separates this level's shard from others.
 * @returns {string}
 */
NetSim.prototype.getUniqueLevelKey = function () {
  return location.pathname.substr(1).replace(/\W/g, '-');
};

/**
 * Extracts query parameters from a full URL and returns them as a simple
 * object.
 * @returns {*}
 */
NetSim.prototype.getOverrideShardID = function () {
  var parts = location.search.split('?');
  if (parts.length === 1) {
    return undefined;
  }

  var shardID;
  parts[1].split('&').forEach(function (param) {
    var sides = param.split('=');
    if (sides.length > 1 && sides[0] === 's') {
      shardID = sides[1];
    }
  });
  return shardID;
};

/**
 * @returns {boolean} TRUE if the level is configured to show any tabs.
 */
NetSim.prototype.shouldShowAnyTabs = function () {
  return this.level.showTabs.length > 0;
};

/**
 * Initialization that can happen once we have a user name.
 * Could collapse this back into init if at some point we can guarantee that
 * user name is available on load.
 * @param {DashboardUser} user
 * @private
 */
NetSim.prototype.initWithUser_ = function (user) {
  this.mainContainer_ = $('#netsim');

  // Create log panels according to level configuration
  if (this.level.messageGranularity === MessageGranularity.PACKETS) {
    this.receivedMessageLog_ = new NetSimLogPanel($('#netsim-received'), {
      logTitle: i18n.receivedMessageLog(),
      isMinimized: false,
      hasUnreadMessages: true,
      packetSpec: this.level.clientInitialPacketHeader
    });

    this.sentMessageLog_ = new NetSimLogPanel($('#netsim-sent'), {
      logTitle: i18n.sentMessageLog(),
      isMinimized: true,
      hasUnreadMessages: false,
      packetSpec: this.level.clientInitialPacketHeader
    });
  } else if (this.level.messageGranularity === MessageGranularity.BITS) {
    this.receivedMessageLog_ = new NetSimBitLogPanel($('#netsim-received'), {
      logTitle: i18n.receiveBits(),
      isMinimized: false,
      netsim: this,
      showReadWireButton: true
    });

    this.sentMessageLog_ = new NetSimBitLogPanel($('#netsim-sent'), {
      logTitle: i18n.sentBitsLog(),
      isMinimized: false,
      netsim: this
    });
  }

  this.statusPanel_ = new NetSimStatusPanel($('#netsim-status'), {
    disconnectCallback: this.disconnectFromRemote.bind(this, function () {})
  });

  this.routerLogModal_ = new NetSimRouterLogModal($('#router-log-modal'));

  this.visualization_ = new NetSimVisualization($('#netsim-visualization'), this.runLoop_);

  // Lobby panel: Controls for picking a remote node and connecting to it.
  this.lobby_ = new NetSimLobby($('.lobby-panel'), this, {
    user: user,
    levelKey: this.getUniqueLevelKey(),
    sharedShardSeed: this.getOverrideShardID()
  });

  // Tab panel - contains instructions, my device, router, dns
  if (this.shouldShowAnyTabs()) {
    this.tabs_ = new NetSimTabsComponent($('#netsim-tabs'), this.runLoop_, {
      chunkSizeSliderChangeCallback: this.setChunkSize.bind(this),
      myDeviceBitRateChangeCallback: this.setMyDeviceBitRate.bind(this),
      encodingChangeCallback: this.changeEncodings.bind(this),
      routerBandwidthSliderChangeCallback: this.setRouterBandwidth.bind(this),
      routerBandwidthSliderStopCallback: this.changeRemoteRouterBandwidth.bind(this),
      routerMemorySliderChangeCallback: this.setRouterMemory.bind(this),
      routerMemorySliderStopCallback: this.changeRemoteRouterMemory.bind(this),
      dnsModeChangeCallback: this.changeRemoteDnsMode.bind(this),
      becomeDnsCallback: this.becomeDnsNode.bind(this)
    });
    this.tabs_.attachToRunLoop(this.runLoop_);
  }

  this.sendPanel_ = new NetSimSendPanel($('#netsim-send'), this.level, this);

  this.changeEncodings(this.level.defaultEnabledEncodings);
  this.setChunkSize(this.level.defaultChunkSizeBits);
  this.setMyDeviceBitRate(this.level.defaultBitRateBitsPerSecond);
  this.setRouterBandwidth(this.level.defaultRouterBandwidth);
  this.setRouterMemory(this.level.defaultRouterMemory);
  this.setDnsMode(this.level.defaultDnsMode);
  this.render();

  // Try and gracefully disconnect when closing the window
  window.addEventListener('beforeunload', this.onBeforeUnload_.bind(this));
  window.addEventListener('unload', this.onUnload_.bind(this));
  window.addEventListener('resize', _.debounce(this.updateLayout.bind(this), 250));
};

/**
 * Before-unload handler, used to warn the user (if necessary) of what they
 * are abandoning if they navigate away from the page.
 *
 * This event has some weird special properties and inconsistent behavior
 * across browsers
 *
 * See:
 * https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload
 * http://www.zachleat.com/web/dont-let-the-door-hit-you-onunload-and-onbeforeunload/
 * http://www.hunlock.com/blogs/Mastering_The_Back_Button_With_Javascript
 *
 * @param {Event} event
 * @returns {string|undefined} If we want to warn the user before they leave
 *          the page, this method will return a warning string, which may or
 *          may not actually be used by the browser to present a warning.  If
 *          we don't want to warn the user, this method doesn't return anything.
 * @private
 */
NetSim.prototype.onBeforeUnload_ = function (event) {
  if (window.__TestInterface && window.__TestInterface.ignoreOnBeforeUnload) {
    return;
  }

  // No need to warn about navigating away if the student is not connected,
  // or is still in the lobby.
  if (this.isConnectedToRemote()) {
    event.returnValue = i18n.onBeforeUnloadWarning();
    return i18n.onBeforeUnloadWarning();
  }
};

/**
 * Unload handler.  Used to attempt a clean disconnect from the simulation
 * using synchronous AJAX calls to remove our own rows from remote storage.
 *
 * See:
 * https://developer.mozilla.org/en-US/docs/Web/Events/unload
 *
 * @private
 */
NetSim.prototype.onUnload_ = function () {
  if (this.isConnectedToShard()) {
    this.synchronousDisconnectFromShard_();
  }
};

/**
 * Whether we are currently connected to a netsim shard
 * @returns {boolean}
 */
NetSim.prototype.isConnectedToShard = function () {
  return null !== this.myNode;
};

/**
 * Whether we are currently connected to a shard with the given ID
 * @param {string} shardID
 * @returns {boolean}
 */
NetSim.prototype.isConnectedToShardID = function (shardID) {
  return this.isConnectedToShard() && this.shard_.id === shardID;
};

/**
 * Establishes a new connection to a netsim shard, closing the old one
 * if present.
 * @param {!string} shardID
 * @param {!string} displayName
 */
NetSim.prototype.connectToShard = function (shardID, displayName) {
  if (this.isConnectedToShard()) {
    logger.warn("Auto-closing previous connection...");
    this.disconnectFromShard(this.connectToShard.bind(this, shardID, displayName));
    return;
  }

  this.shard_ = new NetSimShard(shardID, NetSimGlobals.getPubSubConfig());
  this.createMyClientNode_(displayName, (function (err, myNode) {
    this.myNode = myNode;
    this.shardChange.notifyObservers(this.shard_, this.myNode);
  }).bind(this));
};

/**
 * Given a lobby table has already been configured, connects to that table
 * by inserting a row for ourselves into that table and saving the row ID.
 * @param {!string} displayName
 * @param {!NodeStyleCallback} onComplete - result is new local node
 * @private
 */
NetSim.prototype.createMyClientNode_ = function (displayName, onComplete) {
  NetSimLocalClientNode.create(this.shard_, displayName, (function (err, node) {
    if (err) {
      logger.error("Failed to create client node; " + err.message);
      NetSimAlert.error(i18n.createMyClientNodeError());
      onComplete(err, null);
      return;
    }

    node.setLostConnectionCallback((function () {
      NetSimAlert.warn(i18n.alertConnectionReset());
      this.disconnectFromShard();
    }).bind(this));
    node.initializeSimulation(this.sentMessageLog_, this.receivedMessageLog_);
    onComplete(err, node);
  }).bind(this));
};

/**
 * Synchronous disconnect, for use when navigating away from the page
 * @private
 */
NetSim.prototype.synchronousDisconnectFromShard_ = function () {
  this.myNode.stopSimulation();
  this.myNode.synchronousDestroy();
  this.myNode = null;
  // Don't notify observers, this should only be used when navigating away
  // from the page.
};

/**
 * Ends the connection to the netsim shard.
 * @param {NodeStyleCallback} [onComplete]
 */
NetSim.prototype.disconnectFromShard = function (onComplete) {
  onComplete = onComplete || function () {};

  if (!this.isConnectedToShard()) {
    logger.warn("Redundant disconnect call.");
    onComplete(null, null);
    return;
  }

  if (this.isConnectedToRemote()) {
    // Disconnect, from the remote node, and try this again on completion.
    this.disconnectFromRemote(this.disconnectFromShard.bind(this, onComplete));
    return;
  }

  this.myNode.stopSimulation();
  this.myNode.destroy((function (err, result) {
    if (err) {
      logger.warn('Error destroying node:' + err.message);
      // Don't stop disconnecting on an error here; we make a good-faith
      // effort to clean up after ourselves, and let the cleaning system take
      // care of the rest.
    }

    this.myNode = null;
    this.shard_.disconnect();
    this.shard_ = null;
    this.shardChange.notifyObservers(null, null);
    onComplete(err, result);
  }).bind(this));
};

/**
 * @returns {boolean} Whether the local client is connected to a remote node
 */
NetSim.prototype.isConnectedToRemote = function () {
  return this.isConnectedToClient() || this.isConnectedToRouter();
};

/**
 * @returns {NetSimNode} the remote node our client is connected to, or null if
 *          not connected
 */
NetSim.prototype.getConnectedRemoteNode = function () {
  var client = this.getConnectedClient();
  var router = this.getConnectedRouter();
  return client ? client : router;
};

/**
 * @returns {boolean} Whether the local client has a mutual P2P connection to
 *          another client.
 */
NetSim.prototype.isConnectedToClient = function () {
  return !!this.getConnectedClient();
};

/**
 * @returns {NetSimClientNode} the client node our client is connected to, or
 *          null if not connected to another client.
 */
NetSim.prototype.getConnectedClient = function () {
  if (this.isConnectedToShard()) {
    return this.myNode.myRemoteClient;
  }
  return null;
};

/**
 * Whether our client node is connected to a router node.
 * @returns {boolean}
 */
NetSim.prototype.isConnectedToRouter = function () {
  return !!this.getConnectedRouter();
};

/**
 * @returns {NetSimRouterNode} the router node our client is connected to, or
 *          null if not connected to a router.
 */
NetSim.prototype.getConnectedRouter = function () {
  if (this.isConnectedToShard()) {
    return this.myNode.getMyRouter();
  }
  return null;
};

/**
 * Establish a connection between the local client and the given
 * simulated router.
 * @param {number} routerID
 * @param {NodeStyleCallback} onComplete
 */
NetSim.prototype.connectToRouter = function (routerID, onComplete) {
  if (this.isConnectedToRemote()) {
    // Disconnect and try to connect again when we're done.
    logger.warn("Auto-disconnecting from previous router.");
    this.disconnectFromRemote(this.connectToRouter.bind(this, routerID, onComplete));
    return;
  }

  var self = this;
  NetSimRouterNode.get(routerID, this.shard_, function (err, router) {
    if (err) {
      logger.warn('Failed to find router with ID ' + routerID + '; ' + err.message);
      onComplete(err);
      return;
    }

    self.myNode.connectToRouter(router, function (err) {
      if (err) {
        logger.warn('Failed to connect to ' + router.getDisplayName() + '; ' + err.message);
      }
      onComplete(err, router);
    });
  });
};

/**
 * Disconnects our client node from the currently connected remote node.
 * Destroys the shared wire.
 * @param {NodeStyleCallback} [onComplete] optional function to call when
 *        disconnect is complete
 */
NetSim.prototype.disconnectFromRemote = function (onComplete) {
  onComplete = utils.valueOr(onComplete, function () {});
  this.myNode.disconnectRemote(onComplete);
};

/**
 * Asynchronous fetch of the latest message shared between the local
 * node and its connected remote.
 * Used only in simplex & bit-granular mode.
 * @param {!NodeStyleCallback} onComplete
 */
NetSim.prototype.receiveBit = function (onComplete) {
  this.myNode.getLatestMessageOnSimplexWire(onComplete);
};

/**
 * Update encoding-view setting across the whole app.
 *
 * Propagates the change down into relevant child components, possibly
 * including the control that initiated the change; in that case, re-setting
 * the value should be a no-op and safe to do.
 *
 * @param {EncodingType[]} newEncodings
 */
NetSim.prototype.changeEncodings = function (newEncodings) {
  this.enabledEncodings_ = newEncodings;
  if (this.tabs_) {
    this.tabs_.setEncodings(newEncodings);
  }
  this.receivedMessageLog_.setEncodings(newEncodings);
  this.sentMessageLog_.setEncodings(newEncodings);
  this.sendPanel_.setEncodings(newEncodings);
  this.visualization_.setEncodings(newEncodings);
  this.updateLayout();
};

/**
 * Get the currently enabled encoding types.
 * @returns {EncodingType[]}
 */
NetSim.prototype.getEncodings = function () {
  return this.enabledEncodings_;
};

/**
 * Update chunk-size/bytesize setting across the whole app.
 *
 * Propagates the change down into relevant child components, possibly
 * including the control that initiated the change; in that case, re-setting
 * the value should be a no-op and safe to do.
 *
 * @param {number} newChunkSize
 */
NetSim.prototype.setChunkSize = function (newChunkSize) {
  this.chunkSize_ = newChunkSize;
  if (this.tabs_) {
    this.tabs_.setChunkSize(newChunkSize);
  }
  this.receivedMessageLog_.setChunkSize(newChunkSize);
  this.sentMessageLog_.setChunkSize(newChunkSize);
  this.sendPanel_.setChunkSize(newChunkSize);
};

/**
 * Update bitrate for the local device, which affects send-animation speed.
 * @param {number} newBitRate in bits per second
 */
NetSim.prototype.setMyDeviceBitRate = function (newBitRate) {
  this.myDeviceBitRate_ = newBitRate;
  if (this.tabs_) {
    this.tabs_.setMyDeviceBitRate(newBitRate);
  }
  this.sendPanel_.setBitRate(newBitRate);
};

/** @param {number} creationTimestampMs */
NetSim.prototype.setRouterCreationTime = function (creationTimestampMs) {
  if (this.tabs_) {
    this.tabs_.setRouterCreationTime(creationTimestampMs);
  }
};

/**
 * Update router bandwidth across the app.
 *
 * Propagates the change down into relevant child components, possibly including
 * the control that initiated the change; in that case, re-setting the value
 * should be a no-op and safe to do.
 *
 * @param {number} newBandwidth in bits/second
 */
NetSim.prototype.setRouterBandwidth = function (newBandwidth) {
  if (this.tabs_) {
    this.tabs_.setRouterBandwidth(newBandwidth);
  }
};

/**
 * Sets router bandwidth across the simulation, proagating the change to other
 * clients.
 * @param {number} newBandwidth in bits/second
 */
NetSim.prototype.changeRemoteRouterBandwidth = function (newBandwidth) {
  this.setRouterBandwidth(newBandwidth);
  if (this.isConnectedToRouter()) {
    this.getConnectedRouter().setBandwidth(newBandwidth);
  }
};

/**
 * Update router memory across the app.
 *
 * Propagates the change down into relevant child components, possibly including
 * the control that initiated the change; in that case, re-setting the value
 * should be a no-op and safe to do.
 *
 * @param {number} newMemory in bits
 */
NetSim.prototype.setRouterMemory = function (newMemory) {
  if (this.tabs_) {
    this.tabs_.setRouterMemory(newMemory);
  }
};

/**
 * Sets router memory capacity across the simulation, propagating the change
 * to other clients.
 * @param {number} newMemory in bits
 */
NetSim.prototype.changeRemoteRouterMemory = function (newMemory) {
  this.setRouterMemory(newMemory);
  if (this.isConnectedToRouter()) {
    this.getConnectedRouter().setMemory(newMemory);
  }
};

/**
 * Update DNS mode across the whole app.
 *
 * Propagates the change down into relevant child components, possibly
 * including the control that initiated the change; in that case, re-setting
 * the value should be a no-op and safe to do.
 *
 * @param {DnsMode} newDnsMode
 */
NetSim.prototype.setDnsMode = function (newDnsMode) {
  this.dnsMode_ = newDnsMode;
  if (this.tabs_) {
    this.tabs_.setDnsMode(newDnsMode);
  }
  this.visualization_.setDnsMode(newDnsMode);
};

/**
 * Get current DNS mode.
 * @returns {DnsMode}
 */
NetSim.prototype.getDnsMode = function () {
  return this.dnsMode_;
};

/**
 * Sets DNS mode across the whole simulation, propagating the change
 * to other clients.
 * @param {DnsMode} newDnsMode
 */
NetSim.prototype.changeRemoteDnsMode = function (newDnsMode) {
  this.setDnsMode(newDnsMode);
  if (this.isConnectedToRouter()) {
    this.getConnectedRouter().setDnsMode(newDnsMode);
  }
};

/**
 * @param {boolean} isDnsNode
 */
NetSim.prototype.setIsDnsNode = function (isDnsNode) {
  if (this.tabs_) {
    this.tabs_.setIsDnsNode(isDnsNode);
  }

  if (this.isConnectedToRouter()) {
    this.setDnsTableContents(this.getConnectedRouter().getAddressTable());
  }
};

/**
 * @param {number} dnsNodeID
 */
NetSim.prototype.setDnsNodeID = function (dnsNodeID) {
  this.visualization_.setDnsNodeID(dnsNodeID);
};

/**
 * Tells simulation that we want to become the DNS node for our
 * connected router.
 */
NetSim.prototype.becomeDnsNode = function () {
  this.setIsDnsNode(true);
  if (this.myNode && this.myNode.getMyRouter()) {
    // STATE IS THE ROOT OF ALL EVIL
    var myNode = this.myNode;
    var router = myNode.getMyRouter();
    router.dnsNodeID = myNode.entityID;
    router.update();
  }
};

/**
 * @param {Array} tableContents
 */
NetSim.prototype.setDnsTableContents = function (tableContents) {
  if (this.tabs_) {
    this.tabs_.setDnsTableContents(tableContents);
  }
};

/**
 * @param {Array} logData
 */
NetSim.prototype.setRouterLogData = function (logData) {
  if (this.tabs_) {
    this.tabs_.setRouterLogData(logData);
  }
};

/**
 * @param {number} queuedPacketCount
 * @private
 */
NetSim.prototype.setRouterQueuedPacketCount_ = function (queuedPacketCount) {
  if (this.tabs_) {
    this.tabs_.setRouterQueuedPacketCount(queuedPacketCount);
  }
};

/**
 * @param {number} usedMemoryInBits
 * @private
 */
NetSim.prototype.setRouterMemoryInUse_ = function (usedMemoryInBits) {
  if (this.tabs_) {
    this.tabs_.setRouterMemoryInUse(usedMemoryInBits);
  }
};

/**
 * @param {number} dataRateBitsPerSecond
 * @private
 */
NetSim.prototype.setRouterDataRate_ = function (dataRateBitsPerSecond) {
  if (this.tabs_) {
    this.tabs_.setRouterDataRate(dataRateBitsPerSecond);
  }
};

/**
 * Load audio assets for this app
 * TODO (bbuchanan): Ought to pull this into an audio management module
 * @private
 */
NetSim.prototype.loadAudio_ = function () {};

/**
 * Replaces StudioApp.configureDom.
 * Should be bound against StudioApp instance.
 * @param {Object} config Should at least contain
 *   containerId: ID of a parent DOM element for app content
 *   html: Content to put inside #containerId
 * @private
 */
NetSim.configureDomOverride_ = function (config) {
  var container = document.getElementById(config.containerId);
  container.innerHTML = config.html;

  var vizHeight = this.MIN_WORKSPACE_HEIGHT;
  var visualizationColumn = document.getElementById('netsim-leftcol');

  if (config.pinWorkspaceToBottom) {
    document.body.style.overflow = "hidden";
    container.className = container.className + " pin_bottom";
    visualizationColumn.className = visualizationColumn.className + " pin_bottom";
  } else {
    visualizationColumn.style.minHeight = vizHeight + 'px';
    container.style.minHeight = vizHeight + 'px';
  }
};

/**
 * Resize the left column so it pins above the footer.
 */
function resizeLeftColumnToSitAboveFooter() {
  var pinnedLeftColumn = document.querySelector('#netsim-leftcol.pin_bottom');
  if (!pinnedLeftColumn) {
    return;
  }

  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');

  var bottom = 0;
  if (smallFooter) {
    var codeApp = $('#codeApp');
    bottom += $(smallFooter).outerHeight(true);
    // Footer is relative to the document, not codeApp, so we need to
    // remove the codeApp bottom offset to get the correct margin.
    bottom -= parseInt(codeApp.css('bottom'), 10);
  }

  pinnedLeftColumn.style.bottom = bottom + 'px';
}

function resizeFooterToFitToLeftOfContent() {
  var leftColumn = document.querySelector('#netsim-leftcol.pin_bottom');
  var instructions = document.querySelector('.instructions');
  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');

  if (!smallFooter) {
    return;
  }

  var padding = parseInt(window.getComputedStyle(smallFooter)["padding-left"]);

  var boundingWidth;
  if (leftColumn && $(leftColumn).is(':visible')) {
    boundingWidth = leftColumn.getBoundingClientRect().right;
  } else if (instructions && $(instructions).is(':visible')) {
    boundingWidth = instructions.getBoundingClientRect().right;
  }

  smallFooter.style.maxWidth = boundingWidth ? boundingWidth - padding + 'px' : null;
}

var netsimDebouncedResizeFooter = _.debounce(function () {
  resizeFooterToFitToLeftOfContent();
  resizeLeftColumnToSitAboveFooter();
}, 10);

/**
 * Replaces StudioApp.onResize
 * Should be bound against StudioApp instance.
 * @private
 */
NetSim.onResizeOverride_ = function () {
  var div = document.getElementById('appcontainer');
  var divParent = div.parentNode;
  var parentStyle = window.getComputedStyle(divParent);
  var parentWidth = parseInt(parentStyle.width, 10);
  div.style.top = divParent.offsetTop + 'px';
  div.style.width = parentWidth + 'px';

  netsimDebouncedResizeFooter();
};

/**
 * Passthrough to local "static" netsimDebounceResizeFooter method
 */
NetSim.prototype.debouncedResizeFooter = function () {
  netsimDebouncedResizeFooter();
};

/**
 * Re-render parts of the page that can be re-rendered in place.
 */
NetSim.prototype.render = function () {
  if (this.isConnectedToRemote()) {
    var myAddress = this.myNode.getAddress();

    // Swap in 'connected' div
    this.mainContainer_.find('#netsim-disconnected').hide();
    this.mainContainer_.find('#netsim-connected').show();

    // Render right column
    this.sendPanel_.setFromAddress(myAddress);

    // Render left column
    if (this.statusPanel_) {
      this.statusPanel_.render({
        myHostname: this.myNode.getHostname(),
        myAddress: myAddress,
        remoteNodeName: this.getConnectedRemoteNode().getDisplayName(),
        shareLink: this.lobby_.getShareLink()
      });
    }
  } else {
    // Swap in 'disconnected' div
    this.mainContainer_.find('#netsim-disconnected').show();
    this.mainContainer_.find('#netsim-connected').hide();

    // Render lobby
    this.lobby_.render();
  }

  if (this.routerLogModal_) {
    this.routerLogModal_.render();
  }

  this.updateLayout();
};

/**
 * Called whenever the connection notifies us that we've connected to,
 * or disconnected from, a shard.
 * @param {NetSimShard} shard - null if disconnected.
 * @param {NetSimLocalClientNode} localNode - null if disconnected
 * @private
 */
NetSim.prototype.onShardChange_ = function (shard, localNode) {
  // Unregister old handlers
  if (this.eventKeys.registeredWithLocalNode) {
    this.eventKeys.registeredWithLocalNode.remoteChange.unregister(this.eventKeys.remoteChange);
    this.eventKeys.registeredWithLocalNode = null;
  }

  // Register new handlers
  if (localNode) {
    this.eventKeys.remoteChange = localNode.remoteChange.register(this.onRemoteChange_.bind(this));
    this.eventKeys.registeredWithLocalNode = localNode;
  }

  // Update the log viewer's shard reference so it can get current data.
  if (this.routerLogModal_) {
    this.routerLogModal_.setShard(shard);
  }

  // Shard changes almost ALWAYS require a re-render
  this.visualization_.setShard(shard);
  this.visualization_.setLocalNode(localNode);
  this.render();
};

/**
 * Called whenever the local node notifies that we've been connected to,
 * or disconnected from, a router.
 * @param {NetSimWire} wire - null if disconnected.
 * @param {NetSimNode} remoteNode - null if disconnected
 * @private
 */
NetSim.prototype.onRemoteChange_ = function (wire, remoteNode) {
  var routerConnectEvent = remoteNode && remoteNode instanceof NetSimRouterNode;
  var routerDisconnectEvent = !remoteNode && this.eventKeys.registeredWithRouter;

  // Unhook old handlers
  if (this.eventKeys.registeredWithRouter) {
    this.eventKeys.registeredWithRouter.stateChange.unregister(this.eventKeys.routerStateChange);
    this.eventKeys.registeredWithRouter.statsChange.unregister(this.eventKeys.routerStatsChange);
    this.eventKeys.registeredWithRouter.wiresChange.unregister(this.eventKeys.routerWiresChange);
    this.eventKeys.registeredWithRouter.logChange.unregister(this.eventKeys.routerLogChange);
    this.eventKeys.registeredWithRouter = null;
  }

  // Hook up new handlers
  if (routerConnectEvent) {
    this.eventKeys.routerStateChange = remoteNode.stateChange.register(this.onRouterStateChange_.bind(this));
    this.eventKeys.routerStatsChange = remoteNode.statsChange.register(this.onRouterStatsChange_.bind(this));
    this.eventKeys.routerWiresChange = remoteNode.wiresChange.register(this.onRouterWiresChange_.bind(this));
    this.eventKeys.routerLogChange = remoteNode.logChange.register(this.onRouterLogChange_.bind(this));
    this.eventKeys.registeredWithRouter = remoteNode;
  }

  this.render();

  if (routerConnectEvent) {
    this.onRouterConnect_(remoteNode);
  } else if (routerDisconnectEvent) {
    this.onRouterDisconnect_();
  }
};

/**
 * Steps to take when we were not connected to a router and now we are.
 * @param {NetSimRouterNode} router that we are now connected to
 * @private
 */
NetSim.prototype.onRouterConnect_ = function (router) {
  this.onRouterStateChange_(router);
  this.onRouterStatsChange_(router);
  this.setRouterLogData(router.getLog());
  this.routerLogModal_.setRouter(router);
};

/**
 * Steps to take when we were connected to a router and now we are not.
 * @private
 */
NetSim.prototype.onRouterDisconnect_ = function () {
  this.setRouterCreationTime(0);
  this.setRouterQueuedPacketCount_(0);
  this.setRouterMemoryInUse_(0);
  this.setRouterDataRate_(0);
  this.setRouterLogData([]);
  this.routerLogModal_.setRouter(null);
};

/**
 * Local response to router state changing, which may have been triggered
 * locally or remotely.
 * @param {NetSimRouterNode} router
 * @private
 */
NetSim.prototype.onRouterStateChange_ = function (router) {
  var myNode = {};
  if (this.myNode) {
    myNode = this.myNode;
  }

  this.setRouterCreationTime(router.creationTime);
  this.setRouterBandwidth(router.bandwidth);
  this.setRouterMemory(router.memory);
  this.setDnsMode(router.dnsMode);
  this.setDnsNodeID(router.dnsMode === DnsMode.NONE ? undefined : router.dnsNodeID);
  this.setIsDnsNode(router.dnsMode === DnsMode.MANUAL && router.dnsNodeID === myNode.entityID);
};

/**
 * Isolates updates that we should do when a router's stats change, since
 * these happen a lot more often.
 * @param {NetSimRouterNode} router
 * @private
 */
NetSim.prototype.onRouterStatsChange_ = function (router) {
  this.setRouterQueuedPacketCount_(router.getQueuedPacketCount());
  this.setRouterMemoryInUse_(router.getMemoryInUse());
  this.setRouterDataRate_(router.getCurrentDataRate());
};

/**
 * What to do when our connected router's local network changes.
 * @private
 */
NetSim.prototype.onRouterWiresChange_ = function () {
  if (this.isConnectedToRouter()) {
    this.setDnsTableContents(this.getConnectedRouter().getAddressTable());
  }
};

/**
 * What to do when our connected router's logs change.
 * @private
 */
NetSim.prototype.onRouterLogChange_ = function () {
  if (this.isConnectedToRouter()) {
    this.setRouterLogData(this.getConnectedRouter().getLog());
  }
};

/**
 * Kick off an animation that shows the local node setting the state of a
 * simplex wire.
 * @param {"0"|"1"} newState
 */
NetSim.prototype.animateSetWireState = function (newState) {
  this.visualization_.animateSetWireState(newState);
};

/**
 * Kick off an animation that shows the local node reading the state of a
 * simplex wire.
 * @param {"0"|"1"} newState
 */
NetSim.prototype.animateReadWireState = function (newState) {
  this.visualization_.animateReadWireState(newState);
};

/**
 * Specifically, update the layout of the right column when connected,
 * and change how the three panels there (received log, sent log, send controls)
 * share the current vertical space in the viewport.
 *
 * We're trying to use the following rules:
 *
 * 1. The send controls panel is fixed to the bottom of the viewport, and will
 *    size upwards to fit its contents up to a maximum height.
 * 2. The log widgets use the remaining vertical space
 *    a) If only one log widget is open, it fills the vertical space (except
 *       leaves enough room to see the other header)
 *    b) If both log widgets are open, they share the vertical space 50/50
 *    c) If both log widgets are closed, they float at the top of the space.
 */
NetSim.prototype.updateLayout = function () {
  var rightColumn = $('#netsim-rightcol');
  var sendPanel = $('#netsim-send');
  var logWrap = $('#netsim-logs');

  netsimDebouncedResizeFooter();

  if (this.lobby_) {
    this.lobby_.updateLayout();
  }

  if (!rightColumn.is(':visible')) {
    return;
  }

  // Right column wrapper and the send panel are both sized by CSS
  var rightColumnHeight = rightColumn.height();
  var sendPanelHeight = sendPanel.height();
  var logsSharedVerticalSpace = rightColumnHeight - sendPanelHeight;

  var showingSent = !this.sentMessageLog_.isMinimized();
  var showingReceived = !this.receivedMessageLog_.isMinimized();
  if (showingReceived && showingSent) {
    var halfHeight = Math.floor(logsSharedVerticalSpace / 2);
    this.receivedMessageLog_.setHeight(halfHeight);
    this.sentMessageLog_.setHeight(halfHeight);
  } else if (showingReceived) {
    this.receivedMessageLog_.setHeight(Math.floor(logsSharedVerticalSpace - this.sentMessageLog_.getHeight()));
  } else if (showingSent) {
    this.sentMessageLog_.setHeight(Math.floor(logsSharedVerticalSpace - this.receivedMessageLog_.getHeight()));
  }

  // Manually adjust the logwrap to the remaining height
  logWrap.css('height', rightColumnHeight - sendPanelHeight);
};

/**
 * Appropriate steps for when the student hits the "Continue to next level"
 * button.  Should mark the level as complete and navigate to the next level.
 */
NetSim.prototype.completeLevelAndContinue = function () {
  if (this.isConnectedToRemote() && !confirm(i18n.onBeforeUnloadWarning())) {
    return;
  }

  // Avoid multiple simultaneous submissions.
  $('.submitButton').attr('disabled', true);

  sendReport({
    fallbackResponse: this.reportingInfo_.fallback_response,
    callback: this.reportingInfo_.callback,
    app: 'netsim',
    level: this.level.id,
    result: true,
    testResult: 100,
    onComplete: (function (serverResponse) {

      // Re-enable submit button, in case there's nowhere to go.
      $('.submitButton').attr('disabled', false);

      // If there's somewhere to go, disconnect and go!
      if (serverResponse.redirect) {
        if (this.isConnectedToRemote()) {
          this.disconnectFromRemote(function () {
            window.location.href = serverResponse.redirect;
          });
        } else {
          window.location.href = serverResponse.redirect;
        }
      }
    }).bind(this)
  });
};

/**
 * Attempt to reset the simulation shard, kicking all users out and resetting
 * all data.
 */
NetSim.prototype.resetShard = function () {
  if (this.shard_ && confirm(i18n.shardResetConfirmation())) {
    this.shard_.resetEverything((function (err) {
      if (err) {
        logger.error(err);
        NetSimAlert.error(i18n.shardResetError());
        return;
      }
    }).bind(this));
  }
};

},{"../ObservableEvent":"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js","../RunLoop":"/home/trevor/code-dot-org/apps/build/js/RunLoop.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DashboardUser":"/home/trevor/code-dot-org/apps/build/js/netsim/DashboardUser.js","./NetSimAlert":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.js","./NetSimBitLogPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitLogPanel.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLobby":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLobby.js","./NetSimLocalClientNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLocalClientNode.js","./NetSimLogPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPanel.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimRouterLogModal":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterLogModal.js","./NetSimRouterNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js","./NetSimSendPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSendPanel.js","./NetSimShard":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShard.js","./NetSimStatusPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimStatusPanel.js","./NetSimTabsComponent":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTabsComponent.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./NetSimVisualization":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVisualization.js","./controls.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/controls.html.ejs","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","./page.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/page.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/page.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var msg = require('../locale');
; buf.push('\n\n<div id="rotateContainer" style="background-image: url(', escape((5,  assetUrl('media/turnphone_horizontal.png') )), ')">\n  <div id="rotateText">\n    <p>', escape((7,  msg.rotateText() )), '<br>', escape((7,  msg.orientationLock() )), '</p>\n  </div>\n</div>\n\n');11; var instructions = function() {; buf.push('  <div id="bubble" class="clearfix">\n    <table id="prompt-table">\n      <tr>\n        <td id="prompt-icon-cell">\n          <img id="prompt-icon"/>\n        </td>\n        <td id="prompt-cell">\n          <p id="prompt">\n          </p>\n        </td>\n      </tr>\n    </table>\n    <div id="ani-gif-preview-wrapper">\n      <div id="ani-gif-preview">\n      </div>\n    </div>\n  </div>\n');28; };; buf.push('\n<div id="appcontainer">\n  <!-- Should disable spell-check on all netsim elements -->\n  <div id="netsim" autocapitalize="false" autocorrect="false" autocomplete="false" spellcheck="false">\n\n    <div id="netsim-disconnected">\n      <div class="lobby-panel"></div>\n    </div>\n\n\n    <div id="netsim-connected">\n      <div id="netsim-leftcol">\n        <div class="column-width-limiter">\n\n          <div id="netsim-status"></div>\n\n          <div id="netsim-visualization"></div>\n\n          <div id="netsim-tabs"></div>\n\n        </div>\n      </div>\n\n      <div id="netsim-rightcol">\n        <div id="netsim-logs">\n          <div id="netsim-received"></div>\n          <div id="netsim-sent"></div>\n        </div>\n        <div id="netsim-send"></div>\n      </div>\n    </div>\n\n    <div id="router-log-modal" class="modal fade"></div>\n\n  </div>\n  <div id="footers" dir="', escape((63,  data.localeDirection )), '">\n  </div>\n  <div class="hidden">\n    ');66; instructions(); ; buf.push('\n  </div>\n</div>\n\n<div class="clear"></div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/trevor/code-dot-org/apps/build/js/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/levels.js":[function(require,module,exports){
/*jshint multistr: true */
/**
 * @overview Type documentation for a NetSim level configuration object,
 *           and default values for that object.
 */

'use strict';

var NetSimConstants = require('./NetSimConstants');
var Packet = require('./Packet');
var BITS_PER_NIBBLE = NetSimConstants.BITS_PER_NIBBLE;
var MessageGranularity = NetSimConstants.MessageGranularity;
var DnsMode = NetSimConstants.DnsMode;
var EncodingType = NetSimConstants.EncodingType;
var NetSimTabType = NetSimConstants.NetSimTabType;

/**
 * A level configuration that can be used by NetSim
 * @typedef {Object} NetSimLevelConfiguration
 *
 * @property {string} instructions - Inherited from blockly level configuration.
 *
 * @property {boolean} showClientsInLobby - Whether client nodes should appear
 *           in the lobby list at all.
 *
 * @property {boolean} showRoutersInLobby - Whether router nodes should appear
 *           in the lobby list at all.
 *
 * @property {boolean} canConnectToClients - Whether client nodes are selectable
 *           and can be connected to
 *
 * @property {boolean} canConnectToRouters - Whether router nodes are selectable
 *           and can be connected to
 *
 * @property {boolean} showAddRouterButton - Whether the "Add Router" button
 *           should appear above the lobby list.
 *
 * @property {boolean} showLogBrowserButton - Whether the "Log Browser" is
 *           available in the lobby.
 *
 * @property {MessageGranularity} messageGranularity - Whether the simulator
 *           puts a single bit into storage at a time, or a whole packet.
 *           Should use 'bits' for variant 1 (levels about the coordination
 *           problem), and 'packets' for levels where the coordination problem
 *           is abstracted away.
 *
 * @property {boolean} automaticReceive - Whether the local node will
 *           automatically pick up messages to itself from the message table,
 *           and dump them to the received message log.  If false, some other
 *           method must be used for receiving messages.
 *
 * @property {boolean} broadcastMode - Enabling this option turns "routers"
 *           into "rooms" and makes it so every message sent in the room
 *           will be received by every other person in that room.
 *
 * @property {boolean} connectedRouters - When false (default), each router or
 *           room exists in isolation and will have no contact with other routers
 *           or rooms.  When true, it is possible for messages to travel between
 *           routers, connecting the whole shard.
 *
 * @property {number} minimumExtraHops - Fewest non-destination routers an
 *           inter-router message should try to visit before going to its
 *           destination router.  Number of hops can be lower if network
 *           conditions don't allow it.
 *
 * @property {number} maximumExtraHops - Most non-destination routers an
 *           inter-router message should try to visit before going to its
 *           destination router.
 *
 * @property {AddressHeaderFormat} addressFormat - Specify how many bits wide
 *           an address is within the simulation and how it should be divided
 *           up into a hierarchy. Format resembles IPv4 dot-decimal notation,
 *           but the numbers specify the number of bits for each section.
 *           Examples:
 *           "8.8" - 16-bit address, represented as two 8-bit integers.
 *           "4" - 4 bit address represented as one 4-bit integer.
 *           "8.4" - 12-bit address, represented as an 8-bit integer followed
 *                   by a 4-bit integer
 *            This format will be applied to any "fromAddress" or "toAddress"
 *            header fields in the packet specification, and will determine
 *            how routers assign addresses.
 *
 * @property {number} packetCountBitWidth - How many bits should be allocated
 *           for any "packetIndex" or "packetCount" fields in the packet
 *           specification.
 *
 * @property {Packet.HeaderType[]} routerExpectsPacketHeader - The header format
 *           the router uses to parse incoming packets and figure out where
 *           to route them.
 *
 * @property {Packet.HeaderType[]} clientInitialPacketHeader - The header format
 *           used by the local client node when generating/parsing packets,
 *           which affects the layout of the send panel and log panels.
 *
 * @property {boolean} showHostnameInGraph - If false, student display name
 *           is used in the network graph.  If true, their generated hostname
 *           is displayed.
 *
 * @property {boolean} showAddPacketButton - Whether the "Add Packet" button
 *           should appear in the send widget.
 *
 * @property {boolean} showPacketSizeControl - Whether the packet size slider
 *           should appear in the send widget.
 *
 * @property {number} defaultPacketSizeLimit - Initial maximum packet size.
 *
 * @property {NetSimTabType[]} showTabs - Which tabs should appear beneath the
 *           network visualization.  Does not determine tab order; tabs always
 *           appear in the order "Instructions, My Device, Router, DNS."
 *
 * @property {number} defaultTabIndex - The zero-based index of the tab
 *           that should be active by default, which depends on which tabs
 *           you have enabled.
 *
 * @property {boolean} showPulseRateSlider - Whether the pulse rate slider
 *           is visible on the "My Device" tab.  This control is a different
 *           view on the bitrate, given in seconds-per-pulse; in fact, if both
 *           this and the bitrate slider are visible, dragging one will change
 *           the other.
 *
 * @property {boolean} showMetronome - Whether the metronome should show up on
 *           the "My Device" tab.
 *
 * @property {EncodingType[]} showEncodingControls - Which encodings, (ASCII,
 *           binary, etc.) should have visible controls on the "My Device" tab.
 *
 * @property {EncodingType[]} defaultEnabledEncodings - Which encodings should
 *           be enabled on page load.  Note: An encoding enabled here but not
 *           included in the visible controls will be enabled and cannot be
 *           disabled by the student.
 *
 * @property {boolean} showBitRateControl - Whether the bit rate slider should
 *           be displayed on the "My Device" tab.
 *
 * @property {boolean} lockBitRateControl - Whether the bit rate slider should
 *           be adjustable by the student.
 *
 * @property {number} defaultBitRateBitsPerSecond - Default bit rate on level
 *           load.  Also sets the pulse rate for levels with the metronome.
 *
 * @property {boolean} showChunkSizeControl - Whether the chunk size slider
 *           should be displayed on the "My Device" tab.
 *
 * @property {boolean} lockChunkSizeControl - Whether the chunk size slider
 *           should be adjustable by the student.
 *
 * @property {number} defaultChunkSizeBits- Default chunk size on level load.
 *
 * @property {boolean} showRouterBandwidthControl - Whether students should be
 *           able to see and manipulate the slider that adjusts the router's
 *           max throughput speed.
 *
 * @property {number} defaultRouterBandwidth - How fast the router should be
 *           able to process packets, on initial level load.
 *
 * @property {boolean} showRouterMemoryControl - Whether students should be
 *           able to see and manipulate the slider that adjusts the router's
 *           maximum queue memory.
 *
 * @property {number} defaultRouterMemory - How much data the router packet
 *           queue is able to hold before it starts dropping packets, in bits.
 *
 * @property {number} defaultRandomDropChance - Odds that the router will drop
 *           the packet for no reason while routing it.  Value in range
 *           0 (no drops) to 1 (drop everything)
 *
 * @property {boolean} showDnsModeControl - Whether the DNS mode controls will
 *           be available to the student.
 *
 * @property {DnsMode} defaultDnsMode - Which DNS mode the simulator should
 *           initialize into.
 */

/*
 * Configuration for all levels.
 */
var levels = module.exports = {};

/**
 * A default level configuration so that we can define the others by delta.
 * This default configuration enables everything possible, so other configs
 * should start with this one and disable features.
 * @type {NetSimLevelConfiguration}
 */
levels.custom = {

  // Lobby configuration
  showClientsInLobby: false,
  showRoutersInLobby: false,
  canConnectToClients: false,
  canConnectToRouters: false,
  showAddRouterButton: false,
  showLogBrowserButton: false,

  // Simulator-wide setup
  messageGranularity: MessageGranularity.BITS,
  automaticReceive: false,
  broadcastMode: false,
  connectedRouters: false,
  minimumExtraHops: 0,
  maximumExtraHops: 0,

  // Packet header specification
  addressFormat: '4',
  packetCountBitWidth: 4,
  routerExpectsPacketHeader: [],
  clientInitialPacketHeader: [],

  // Visualization configuration
  showHostnameInGraph: false,

  // Send widget configuration
  showAddPacketButton: false,
  showPacketSizeControl: false,
  defaultPacketSizeLimit: 8192,

  // Tab-panel control
  showTabs: [],
  defaultTabIndex: 0,

  // Instructions tab and its controls
  // Note: Uses the blockly-standard level.instructions value, which should
  //       be localized by the time it gets here.

  // "My Device" tab and its controls
  showPulseRateSlider: false,
  showMetronome: false,
  showEncodingControls: [],
  defaultEnabledEncodings: [],
  showBitRateControl: false,
  lockBitRateControl: false,
  defaultBitRateBitsPerSecond: Infinity,
  showChunkSizeControl: false,
  lockChunkSizeControl: false,
  defaultChunkSizeBits: 8,

  // Router tab and its controls
  showRouterBandwidthControl: false,
  defaultRouterBandwidth: Infinity,
  showRouterMemoryControl: false,
  defaultRouterMemory: Infinity,
  defaultRandomDropChance: 0,

  // DNS tab and its controls
  showDnsModeControl: false,
  defaultDnsMode: DnsMode.NONE
};

/**
 * Special level configuration for use with 'grunt dev' standalone mode.
 * Never used when serving NetSim levels through dashboard.
 * @type {NetSimLevelConfiguration}
 */
levels.playground = {

  // Lobby configuration
  showClientsInLobby: false,
  showRoutersInLobby: true,
  canConnectToClients: false,
  canConnectToRouters: true,
  showAddRouterButton: true,
  showLogBrowserButton: true,

  // Simulator-wide setup
  messageGranularity: MessageGranularity.PACKETS,
  automaticReceive: true,
  broadcastMode: false,
  connectedRouters: false,
  minimumExtraHops: 0,
  maximumExtraHops: 0,

  // Packet header specification
  addressFormat: '4',
  packetCountBitWidth: 4,
  routerExpectsPacketHeader: ['toAddress', 'fromAddress'],
  clientInitialPacketHeader: ['toAddress', 'fromAddress'],

  // Visualization configuration
  showHostnameInGraph: false,

  // Send widget configuration
  showAddPacketButton: false,
  showPacketSizeControl: false,
  defaultPacketSizeLimit: 8192,

  // Tab-panel control
  showTabs: ['instructions', 'my_device', 'router', 'dns'],
  defaultTabIndex: 0,

  // Instructions tab and its controls
  // Note: Uses the blockly-standard level.instructions value, which should
  //       be localized by the time it gets here.

  // "My Device" tab and its controls
  showPulseRateSlider: false,
  showMetronome: false,
  showEncodingControls: ['a_and_b', 'binary', 'hexadecimal', 'decimal', 'ascii'],
  defaultEnabledEncodings: ['a_and_b', 'binary', 'hexadecimal', 'decimal', 'ascii'],
  showBitRateControl: true,
  lockBitRateControl: false,
  defaultBitRateBitsPerSecond: Infinity,
  showChunkSizeControl: true,
  lockChunkSizeControl: false,
  defaultChunkSizeBits: 8,

  // Router tab and its controls
  showRouterBandwidthControl: true,
  defaultRouterBandwidth: Infinity,
  showRouterMemoryControl: true,
  defaultRouterMemory: Infinity,
  defaultRandomDropChance: 0,

  // DNS tab and its controls
  showDnsModeControl: true,
  defaultDnsMode: DnsMode.NONE
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/controls.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div id="slider-cell">\n  <img id="spinner" style="visibility: hidden;" src="', escape((2,  assetUrl('media/netsim/loading.gif') )), '" height=15 width=15>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVisualization.js":[function(require,module,exports){
/**
 * @overview Top-level controller for the network visualization.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var visualizationMarkup = require('./NetSimVisualization.html.ejs');
var NetSimNodeFactory = require('./NetSimNodeFactory');
var NetSimWire = require('./NetSimWire');
var NetSimVizAutoDnsNode = require('./NetSimVizAutoDnsNode');
var NetSimVizNode = require('./NetSimVizNode');
var NetSimVizSimulationNode = require('./NetSimVizSimulationNode');
var NetSimVizSimulationWire = require('./NetSimVizSimulationWire');
var NetSimVizWire = require('./NetSimVizWire');
var NetSimGlobals = require('./NetSimGlobals');
var tweens = require('./tweens');
var NetSimConstants = require('./NetSimConstants');
var DnsMode = NetSimConstants.DnsMode;
var NodeType = NetSimConstants.NodeType;

/**
 * Whether the blurred visualization background should be shown.
 * @const {boolean}
 */
var SHOW_BACKGROUND = false;

/**
 * Top-level controller for the network visualization.
 *
 * For the most part, the visualization attaches to the raw network state
 * representation (the storage tables) and updates to reflect that state,
 * independent of the rest of the controls on the page.  This separation means
 * that the visualization always has one canonical state to observe.
 *
 * @param {jQuery} rootDiv - The <div> tag within which the visualization
 *        will be created.
 * @param {RunLoop} runLoop - Loop providing tick and render events that the
 *        visualization can hook up to and respond to.
 * @constructor
 */
var NetSimVisualization = module.exports = function (rootDiv, runLoop) {
  /**
   * @private {jQuery}
   */
  this.rootDiv_ = rootDiv;

  // Immediately, drop our SVG canvas and basic groups into the DOM
  this.rootDiv_.html(visualizationMarkup({
    showBackground: SHOW_BACKGROUND
  }));

  /**
   * @private {jQuery}
   */
  this.svgRoot_ = this.rootDiv_.find('svg');

  /**
   * Background group never goes away, so search for it once and cache
   * it here.
   * @private {jQuery}
   */
  this.backgroundGroup_ = this.svgRoot_.find('#background-group');

  /**
   * Foreground group never goes away, so search for it once and cache
   * it here.
   * @private {jQuery}
   */
  this.foregroundGroup_ = this.svgRoot_.find('#foreground-group');

  /**
   * The shard currently being represented.
   * We don't have a shard now, but we register with the connection manager
   * to find out when we have one.
   * @private {NetSimShard}
   */
  this.shard_ = null;

  /**
   * List of VizEntities, which are all the elements that will actually show up
   * in our visualization.
   * @private {NetSimVizElement[]}
   */
  this.elements_ = [];

  /**
   * Reference to the local node viz element, the anchor for the visualization.
   * @type {NetSimVizSimulationNode}
   */
  this.localNode = null;

  /**
   * Width (in svg-units) of visualization
   * @type {number}
   */
  this.visualizationWidth = 300;

  /**
   * Height (in svg-units) of visualization
   * @type {number}
   */
  this.visualizationHeight = 300;

  /**
  * Last known DNS mode, so that new elements can be created with the
  * correct default
  * @type {DnsMode}
  */
  this.dnsMode_ = null;

  /**
   * Reference to visualized auto-DNS node, a fake node (not mapped to the
   * simulation in a normal way) that also lives in our elements_ collection.
   * @type {NetSimVizAutoDnsNode}
   * @private
   */
  this.autoDnsNode_ = null;

  /**
   * Reference to wire between the auto-DNS node and the foreground router.
   * Managed manually so we keep a handle on it, but also lives in the elements_
   * collection.
   * @type {NetSimVizWire}
   * @private
   */
  this.autoDnsWire_ = null;

  /**
   * Event registration information
   * @type {Object}
   */
  this.eventKeys = {};

  /**
   * Last known encodings set, so that new elements can be created with
   * the correct default
   * @type {EncodingType[]}
   */
  this.encodings_ = [];

  // Hook up tick and render methods
  runLoop.tick.register(this.tick.bind(this));
  runLoop.render.register(this.render.bind(this));
};

/**
 * Tick: Update all vizentities, giving them an opportunity to recalculate
 *       their internal state, and remove any dead entities from the
 *       visualization.
 * @param {RunLoop.Clock} clock
 */
NetSimVisualization.prototype.tick = function (clock) {
  // Everyone gets an update
  this.elements_.forEach(function (element) {
    element.tick(clock);
  });

  // Tear out dead entities.
  this.elements_ = this.elements_.filter(function (element) {
    if (element.isDead()) {
      element.getRoot().remove();
      return false;
    }
    return true;
  });
};

/**
 * Render: Let all vizentities "redraw" (or in our case, touch the DOM)
 * @param {RunLoop.Clock} clock
 */
NetSimVisualization.prototype.render = function (clock) {
  this.elements_.forEach(function (element) {
    element.render(clock);
  });
};

/**
 * Change the shard this visualization will source its data from.
 * Re-attaches table change listeners for all the tables we need to monitor.
 * @param {?NetSimShard} newShard - null if disconnected
 */
NetSimVisualization.prototype.setShard = function (newShard) {
  this.shard_ = newShard;

  // If we were registered for shard events, unregister old handlers.
  if (this.eventKeys.registeredWithShard) {
    this.eventKeys.registeredWithShard.nodeTable.tableChange.unregister(this.eventKeys.nodeTable);
    this.eventKeys.registeredWithShard.wireTable.tableChange.unregister(this.eventKeys.wireTable);
    this.eventKeys.registeredWithShard = null;
  }

  // If we have a new shard, register new handlers.
  if (newShard) {
    this.eventKeys.nodeTable = newShard.nodeTable.tableChange.register(this.onNodeTableChange_.bind(this));
    this.eventKeys.wireTable = newShard.wireTable.tableChange.register(this.onWireTableChange_.bind(this));
    this.eventKeys.registeredWithShard = newShard;
  }
};

/**
 * Change which node we consider the 'local node' in the visualization.
 * We go through a special creation process for this node, so that it
 * looks and behaves differently.
 * @param {?NetSimLocalClientNode} newLocalNode - null if disconnected
 */
NetSimVisualization.prototype.setLocalNode = function (newLocalNode) {
  // Unregister old handlers
  if (this.eventKeys.registeredWithLocalNode) {
    this.eventKeys.registeredWithLocalNode.remoteChange.unregister(this.eventKeys.remoteChange);
    this.eventKeys.registeredWithLocalNode = null;
  }

  // Register new handlers
  if (newLocalNode) {
    this.eventKeys.remoteChange = newLocalNode.remoteChange.register(this.onRemoteChange_.bind(this));
    this.eventKeys.registeredWithLocalNode = newLocalNode;
  }

  // Create viznode for local node
  if (newLocalNode) {
    if (this.localNode) {
      this.localNode.configureFrom(newLocalNode);
    } else {
      this.localNode = new NetSimVizSimulationNode(newLocalNode, SHOW_BACKGROUND);
      this.elements_.push(this.localNode);
      this.backgroundGroup_.append(this.localNode.getRoot());
    }
    this.localNode.setIsLocalNode();
  } else {
    if (this.localNode) {
      this.localNode.kill();
      this.localNode = null;
    }
  }
  this.pullElementsToForeground();
};

/**
 * Called whenever the local node notifies that we've been connected to,
 * or disconnected from, a router.
 * @private
 */
NetSimVisualization.prototype.onRemoteChange_ = function () {
  this.pullElementsToForeground();
  this.distributeForegroundNodes();
};

/**
 * Find a particular VizElement in the visualization, by type and ID.
 * @param {function} elementType - constructor of element we're looking for
 * @param {number} entityID - ID, with corresponds to NetSimEntity.entityID
 * @returns {NetSimVizElement} or undefined if not found
 */
NetSimVisualization.prototype.getElementByEntityID = function (elementType, entityID) {
  return _.find(this.elements_, function (element) {
    return element instanceof elementType && element.getCorrespondingEntityId && element.getCorrespondingEntityId() === entityID;
  });
};

/**
 * Gets the set of VizWires directly attached to the given VizNode on
 * the local end for which there are also corresponding VizWires coming
 * from the opposite end. Note that if the VizNode is a router, we
 * consider all attached wires to be reciprocated.
 * @param {NetSimVizSimulationNode} vizNode
 * @returns {Array.<NetSimVizSimulationWire>} the attached wires
 */
NetSimVisualization.prototype.getReciprocatedWiresAttachedToNode = function (vizNode) {

  if (vizNode.isRouter) {
    return this.getWiresAttachedToNode(vizNode);
  }

  var localWires = this.getLocalWiresAttachedToNode(vizNode);

  return localWires.filter(function (localWire) {

    if (localWire.remoteVizNode.isRouter) {
      return true;
    }

    return this.getWiresAttachedToNode(localWire.remoteVizNode).some(function (wire) {
      return wire.remoteVizNode === vizNode;
    });
  }, this);
};

/**
 * Gets the set of VizWires directly attached to the given VizNode on the local end
 * @param {NetSimVizSimulationNode} vizNode
 * @returns {Array.<NetSimVizSimulationWire>} the attached wires
 */
NetSimVisualization.prototype.getLocalWiresAttachedToNode = function (vizNode) {
  return this.elements_.filter(function (element) {
    return element instanceof NetSimVizWire && element.localVizNode === vizNode;
  });
};

/**
 * Gets the set of VizWires directly attached to the given VizNode, (either
 * on the local end or remote end)
 * @param {NetSimVizSimulationNode} vizNode
 * @returns {Array.<NetSimVizSimulationWire>} the attached wires
 */
NetSimVisualization.prototype.getWiresAttachedToNode = function (vizNode) {
  return this.elements_.filter(function (element) {
    return element instanceof NetSimVizWire && (element.localVizNode === vizNode || element.remoteVizNode === vizNode);
  });
};

/**
 * Handle notification that node table contents have changed.
 * @private
 */
NetSimVisualization.prototype.onNodeTableChange_ = function () {
  // Convert rows to correctly-typed objects
  var tableNodes = NetSimNodeFactory.nodesFromRows(this.shard_, this.shard_.nodeTable.readAll());

  // Update collection of VizNodes from source data
  this.updateVizEntitiesOfType_(NetSimVizSimulationNode, tableNodes, (function (node) {
    var newVizNode = new NetSimVizSimulationNode(node, SHOW_BACKGROUND);
    newVizNode.setDnsMode(this.dnsMode_);
    newVizNode.snapToPosition(Math.random() * this.visualizationWidth - this.visualizationWidth / 2, Math.random() * this.visualizationHeight - this.visualizationHeight / 2);
    return newVizNode;
  }).bind(this));
};

/**
 * Handle notification that wire table contents have changed.
 * @private
 */
NetSimVisualization.prototype.onWireTableChange_ = function () {
  // Convert rows to correctly-typed objects
  var tableWires = this.shard_.wireTable.readAll().map(function (row) {
    return new NetSimWire(this.shard_, row);
  }, this);

  // Update collection of VizWires from source data
  this.updateVizEntitiesOfType_(NetSimVizSimulationWire, tableWires, (function (wire) {
    var newVizWire = new NetSimVizSimulationWire(wire, this.getElementByEntityID.bind(this));
    newVizWire.setEncodings(this.encodings_);
    return newVizWire;
  }).bind(this));

  // In broadcast mode we hide the real wires and router, and overlay a set
  // of fake wires showing everybody connected to everybody else.
  if (NetSimGlobals.getLevelConfig().broadcastMode) {
    this.updateBroadcastModeWires_();
  }

  // Since the wires table determines simulated connectivity, we trigger a
  // recalculation of which nodes are in the local network (should be in the
  // foreground) and then re-layout the foreground nodes.
  this.pullElementsToForeground();
  this.distributeForegroundNodes();
};

/**
 * Based on new connectivity information, recalculate which 'fake' connections
 * we need to display to show all nodes in a 'room' having direct wires to
 * one another.
 * @private
 */
NetSimVisualization.prototype.updateBroadcastModeWires_ = function () {
  // Kill all fake wires
  this.elements_.forEach(function (vizElement) {
    if (vizElement instanceof NetSimVizWire && !(vizElement instanceof NetSimVizSimulationWire)) {
      vizElement.kill();
    }
  }, this);

  // Generate new wires
  var connections = this.generateBroadcastModeConnections_();
  connections.forEach(function (connectedPair) {
    var newFakeWire = new NetSimVizWire(connectedPair.nodeA, connectedPair.nodeB);
    this.addVizElement_(newFakeWire);
  }, this);
};

/**
 * Using the cached node and wire data, generates the set of all node pairs (A,B)
 * on the shard such that both A and B are client nodes, and A is reachable
 * from B.
 * @returns {Array.<{nodeA:{number}, nodeB:{number}}>}
 * @private
 */
NetSimVisualization.prototype.generateBroadcastModeConnections_ = function () {
  var nodeRows = this.shard_.nodeTable.readAll();
  var wireRows = this.shard_.wireTable.readAll();
  var nodeCount = nodeRows.length;

  // Generate a reverse mapping for lookups
  var nodeIDToIndex = {};
  for (var matrixIndex = 0; matrixIndex < nodeCount; matrixIndex++) {
    nodeIDToIndex[nodeRows[matrixIndex].id] = matrixIndex;
  }

  // Generate empty graph matrix initialized with no connections.
  var graph = new Array(nodeCount);
  for (var x = 0; x < nodeCount; x++) {
    graph[x] = new Array(nodeCount);
    for (var y = 0; y < nodeCount; y++) {
      graph[x][y] = false;
    }
  }

  // Apply real connections (wires) to the graph matrix
  wireRows.forEach(function (wireRow) {
    var localNodeIndex = nodeIDToIndex[wireRow.localNodeID];
    var remoteNodeIndex = nodeIDToIndex[wireRow.remoteNodeID];
    if (localNodeIndex !== undefined && remoteNodeIndex !== undefined) {
      graph[localNodeIndex][remoteNodeIndex] = true;
      graph[remoteNodeIndex][localNodeIndex] = true;
    }
  });

  // Use simple Floyd-Warshall to complete the transitive closure graph
  for (var k = 0; k < nodeCount; k++) {
    for (var i = 0; i < nodeCount; i++) {
      for (var j = 0; j < nodeCount; j++) {
        if (graph[i][k] && graph[k][j]) {
          graph[i][j] = true;
        }
      }
    }
  }

  // Now, generate unique pairs doing lookup on our transitive closure graph
  var connections = [];
  for (var from = 0; from < nodeCount - 1; from++) {
    for (var to = from + 1; to < nodeCount; to++) {
      // leave router connections out of this list
      var clientToClient = nodeRows[from].type === NodeType.CLIENT && nodeRows[to].type === NodeType.CLIENT;
      // Must be reachable
      var reachable = graph[from][to];
      if (clientToClient && reachable) {
        connections.push({
          nodeA: this.getElementByEntityID(NetSimVizSimulationNode, nodeRows[from].id),
          nodeB: this.getElementByEntityID(NetSimVizSimulationNode, nodeRows[to].id)
        });
      }
    }
  }
  return connections;
};

/**
 * Compares VizEntities of the given type that are currently in the
 * visualization to the source data given, and creates/updates/removes
 * VizEntities so that the visualization reflects the new source data.
 *
 * @param {function} vizElementType
 * @param {Array.<NetSimEntity>} entityCollection
 * @param {function} creationMethod
 * @private
 */
NetSimVisualization.prototype.updateVizEntitiesOfType_ = function (vizElementType, entityCollection, creationMethod) {

  // 1. Kill VizEntities that are no longer in the source data
  this.killVizEntitiesOfTypeMissingMatch_(vizElementType, entityCollection);

  entityCollection.forEach(function (entity) {
    var vizElement = this.getElementByEntityID(vizElementType, entity.entityID);
    if (vizElement) {
      // 2. Update existing VizEntities from their source data
      vizElement.configureFrom(entity);
    } else {
      // 3. Create new VizEntities for new source data
      this.addVizElement_(creationMethod(entity));
    }
  }, this);
};

/**
 * Call kill() on any vizentities that match the given type and don't map to
 * a NetSimEntity in the provided collection.
 * @param {function} vizElementType
 * @param {Array.<NetSimEntity>} entityCollection
 * @private
 */
NetSimVisualization.prototype.killVizEntitiesOfTypeMissingMatch_ = function (vizElementType, entityCollection) {
  this.elements_.forEach(function (vizElement) {
    var isCorrectType = vizElement instanceof vizElementType;
    var foundMatch = entityCollection.some(function (entity) {
      return vizElement.representsEntity && vizElement.representsEntity(entity);
    });

    if (isCorrectType && !foundMatch) {
      vizElement.kill();
    }
  });
};

/**
 * Adds a VizElement to the visualization.
 * @param {NetSimVizElement} vizElement
 * @private
 */
NetSimVisualization.prototype.addVizElement_ = function (vizElement) {
  this.elements_.push(vizElement);
  this.backgroundGroup_.prepend(vizElement.getRoot());
};

/**
 * If we do need a DOM change, detach the element and reattach it to the new
 * layer. Special rule (for now): Prepend wires so that they show up behind
 * nodes.  Will need a better solution for this if/when the viz gets more
 * complex.
 * @param {NetSimVizElement} vizElement
 * @param {jQuery} newParent
 */
var moveVizElementToGroup = function moveVizElementToGroup(vizElement, newParent) {
  vizElement.getRoot().detach();
  if (vizElement instanceof NetSimVizWire) {
    vizElement.getRoot().prependTo(newParent);
  } else {
    vizElement.getRoot().appendTo(newParent);
  }
};

/**
 * Recalculate which nodes should be in the foreground layer by doing a full
 * traversal starting with the local node.  In short, everything reachable
 * from the local node belongs in the foreground.
 */
NetSimVisualization.prototype.pullElementsToForeground = function () {
  // Begin by marking all entities background (unvisited)
  this.elements_.forEach(function (vizElement) {
    vizElement.visited = false;
  });

  var toExplore = [];
  if (this.localNode) {
    toExplore.push(this.localNode);
  }

  // While there are still nodes that need visiting,
  // visit the next node, marking it as "foreground/visited" and
  // pushing all of its unvisited connections onto the stack.
  var currentVizElement;
  while (toExplore.length > 0) {
    currentVizElement = toExplore.pop();
    currentVizElement.visited = true;
    toExplore = toExplore.concat(this.getUnvisitedNeighborsOf_(currentVizElement));
  }

  // Now, visited nodes belong in the foreground.
  // Move all nodes to their new, correct layers
  // Possible optimization: Can we do this with just one operation on the live DOM?
  var foreground = this.foregroundGroup_;
  var background = this.backgroundGroup_;
  this.elements_.forEach(function (vizElement) {
    var isForeground = $.contains(foreground[0], vizElement.getRoot()[0]);

    // Check whether a change should occur.  If not, we leave
    // newParent undefined so that we don't make unneeded DOM changes.
    if (vizElement.visited && !isForeground) {
      moveVizElementToGroup(vizElement, foreground);
      vizElement.onDepthChange(true);
    } else if (!vizElement.visited && isForeground) {
      moveVizElementToGroup(vizElement, background);
      vizElement.onDepthChange(false);
    }
  }, this);

  this.updateAutoDnsNode();
};

/**
 * Visit method for pullElementsToForeground, not used anywhere else.
 * Notes that the current element is should be foreground when we're all done,
 * finds the current element's unvisited connections,
 * pushes those connections onto the stack.
 * @param {NetSimVizSimulationNode|NetSimVizSimulationWire} vizElement
 * @returns {Array.<NetSimVizElement>}
 * @private
 */
NetSimVisualization.prototype.getUnvisitedNeighborsOf_ = function (vizElement) {
  // Find new entities to explore based on node type and connections
  var neighbors = [];

  if (vizElement instanceof NetSimVizSimulationNode) {

    // In broadcast mode we display "fake," unidirectional wires. In
    // regular mode, we only want to display wires connecting us to
    // nodes that are also connected back.
    if (NetSimGlobals.getLevelConfig().broadcastMode) {
      neighbors = this.getWiresAttachedToNode(vizElement);
    } else {
      neighbors = this.getReciprocatedWiresAttachedToNode(vizElement);
    }

    // Special case: The DNS node fake is a neighbor of a visited router
    if (vizElement.isRouter && this.autoDnsNode_) {
      neighbors.push(this.autoDnsNode_);
      neighbors.push(this.autoDnsWire_);
    }
  } else if (vizElement instanceof NetSimVizWire) {
    if (vizElement.localVizNode) {
      neighbors.push(vizElement.localVizNode);
    }

    if (vizElement.remoteVizNode) {
      neighbors.push(vizElement.remoteVizNode);
    }
  }

  return neighbors.filter(function (vizElement) {
    return !vizElement.visited;
  });
};

/**
 * Explicitly control VizNodes in the foreground, moving them into a desired
 * configuration based on their number and types.  Nodes are given animation
 * commands (via tweenToPosition) so that they interpolate nicely to their target
 * positions.
 *
 * Configurations:
 * One node (local node): Centered on the screen.
 *   |  L  |
 *
 * Two nodes: Local node on left, remote node on right, nothing in the middle.
 *   | L-R |
 *
 * Three or more nodes: Local node on left, router in the middle, other
 * nodes distributed evenly around the router in a circle
 * 3:         4:    O    5:  O      6:O   O    7:O   O
 *                 /         |         \ /        \ /
 *   L-R-0      L-R        L-R-O      L-R        L-R-O
 *                 \         |         / \        / \
 *                  O        O        O   O      O   O
 */
NetSimVisualization.prototype.distributeForegroundNodes = function () {
  if (NetSimGlobals.getLevelConfig().broadcastMode) {
    this.distributeForegroundNodesForBroadcast_();
    return;
  }

  /** @type {Array.<NetSimVizSimulationNode>} */
  var foregroundNodes = this.elements_.filter(function (element) {
    return element instanceof NetSimVizNode && element.isForeground;
  });

  // Sometimes, there's no work to do.
  if (foregroundNodes.length === 0) {
    return;
  }

  // One node: Centered on screen
  if (foregroundNodes.length === 1) {
    foregroundNodes[0].tweenToPosition(0, 0, 600, tweens.easeOutQuad);
    return;
  }

  var myNode;

  // Two nodes: Placed across from each other, local node on left
  if (foregroundNodes.length === 2) {
    myNode = this.localNode;
    var otherNode = _.find(foregroundNodes, function (node) {
      return node !== myNode;
    });
    myNode.tweenToPosition(-75, 0, 400, tweens.easeOutQuad);
    otherNode.tweenToPosition(75, 0, 600, tweens.easeOutQuad);
    return;
  }

  // Three or more nodes:
  // * Local node on left
  // * Router in the middle
  // * Other nodes evenly distributed in a circle
  myNode = this.localNode;
  var routerNode = _.find(foregroundNodes, function (node) {
    return node.isRouter;
  });
  var otherNodes = foregroundNodes.filter(function (node) {
    return node !== myNode && node !== routerNode;
  });

  myNode.tweenToPosition(-100, 0, 400, tweens.easeOutQuad);
  routerNode.tweenToPosition(0, 0, 500, tweens.easeOutQuad);
  var radiansBetweenNodes = 2 * Math.PI / (otherNodes.length + 1); // Include myNode!
  for (var i = 0; i < otherNodes.length; i++) {
    // sin(rad) = o/h
    var h = 100;
    // Extra Math.PI here puts 0deg on the left.
    var rad = Math.PI + (i + 1) * radiansBetweenNodes;
    var x = Math.cos(rad) * h;
    var y = Math.sin(rad) * h;
    otherNodes[i].tweenToPosition(x, y, 600, tweens.easeOutQuad);
  }
};

/**
 * Explicitly control VizNodes in the foreground, moving them into a desired
 * configuration based on their number and types.  Nodes are given animation
 * commands (via tweenToPosition) so that they interpolate nicely to their target
 * positions.
 *
 * Configurations:
 * One node (local node): Centered on the screen.
 *   |  L  |
 *
 * Two nodes: Local node on left, remote node on right, nothing in the middle.
 *   | L-R |
 *
 * Three or more nodes: Distributed around center of frame
 * 3:    O    4:  O      5: O  O    6: O O
 *   L          L   O      L          L   O
 *       O        O         O  O       O O
 */
NetSimVisualization.prototype.distributeForegroundNodesForBroadcast_ = function () {
  /** @type {Array.<NetSimVizSimulationNode>} */
  var foregroundNodes = this.elements_.filter(function (element) {
    return element instanceof NetSimVizSimulationNode && element.isForeground && !element.isRouter;
  });

  // Sometimes, there's no work to do.
  if (foregroundNodes.length === 0) {
    return;
  }

  // One node: Centered on screen
  if (foregroundNodes.length === 1) {
    foregroundNodes[0].tweenToPosition(0, 0, 600, tweens.easeOutQuad);
    return;
  }

  var myNode;

  // Two nodes: Placed across from each other, local node on left
  if (foregroundNodes.length === 2) {
    myNode = this.localNode;
    var otherNode = _.find(foregroundNodes, function (node) {
      return node !== myNode;
    });
    myNode.tweenToPosition(-75, 0, 400, tweens.easeOutQuad);
    otherNode.tweenToPosition(75, 0, 600, tweens.easeOutQuad);
    return;
  }

  // Three or more nodes:
  // * Local node on left
  // * Other nodes evenly distributed in a circle
  myNode = this.localNode;
  var otherNodes = foregroundNodes.filter(function (node) {
    return node !== myNode;
  });

  myNode.tweenToPosition(-100, 0, 400, tweens.easeOutQuad);
  var radiansBetweenNodes = 2 * Math.PI / (otherNodes.length + 1); // Include myNode!
  for (var i = 0; i < otherNodes.length; i++) {
    // sin(rad) = o/h
    var h = 100;
    // Extra Math.PI here puts 0deg on the left.
    var rad = Math.PI + (i + 1) * radiansBetweenNodes;
    var x = Math.cos(rad) * h;
    var y = Math.sin(rad) * h;
    otherNodes[i].tweenToPosition(x, y, 600, tweens.easeOutQuad);
  }
};

/**
 * @param {DnsMode} newDnsMode
 */
NetSimVisualization.prototype.setDnsMode = function (newDnsMode) {

  this.dnsMode_ = newDnsMode;

  // Show/hide the auto-DNS node according to the new state
  if (newDnsMode === DnsMode.AUTOMATIC) {
    this.makeAutoDnsNode();
  } else {
    this.destroyAutoDnsNode();
  }

  // Tell all nodes about the new DNS mode, so they can decide whether to
  // show or hide their address.
  this.elements_.forEach(function (vizElement) {
    if (vizElement instanceof NetSimVizSimulationNode) {
      vizElement.setDnsMode(newDnsMode);
    }
  });

  // Update layering and layout since we just added/removed a node.
  this.pullElementsToForeground();
  this.distributeForegroundNodes();
};

/**
 * If it doesn't already exist, create an auto-DNS node and corresponding
 * wire.
 */
NetSimVisualization.prototype.makeAutoDnsNode = function () {
  if (!this.autoDnsNode_) {
    this.autoDnsNode_ = new NetSimVizAutoDnsNode(SHOW_BACKGROUND);
    this.addVizElement_(this.autoDnsNode_);

    this.autoDnsWire_ = new NetSimVizWire(this.autoDnsNode_, null);
    this.addVizElement_(this.autoDnsWire_);
  }
};

/**
 * Manually update the auto-DNS node and wire to match the foreground router.
 */
NetSimVisualization.prototype.updateAutoDnsNode = function () {
  if (!this.autoDnsNode_) {
    return;
  }

  var foregroundRouterNode = _.find(this.elements_, function (element) {
    return element instanceof NetSimVizSimulationNode && element.isRouter && element.isForeground;
  });

  // Update address to match foreground router
  if (foregroundRouterNode) {
    this.autoDnsNode_.setAddress(foregroundRouterNode.autoDnsAddress);
  }

  // Update wire endpoints
  this.autoDnsWire_.localVizNode = this.autoDnsNode_;
  this.autoDnsWire_.remoteVizNode = foregroundRouterNode;
};

/**
 * Remove the auto-DNS node and wire.
 */
NetSimVisualization.prototype.destroyAutoDnsNode = function () {
  if (this.autoDnsNode_) {
    this.autoDnsNode_.kill();
    this.autoDnsNode_ = null;
  }

  if (this.autoDnsWire_) {
    this.autoDnsWire_.kill();
    this.autoDnsWire_ = null;
  }
};

/**
 * @param {number} dnsNodeID
 */
NetSimVisualization.prototype.setDnsNodeID = function (dnsNodeID) {
  this.elements_.forEach(function (vizElement) {
    if (vizElement instanceof NetSimVizSimulationNode) {
      vizElement.setIsDnsNode(vizElement.getCorrespondingEntityId() === dnsNodeID);
    }
  });
};

/**
 * Update encoding-view setting across the visualization.
 *
 * @param {EncodingType[]} newEncodings
 */
NetSimVisualization.prototype.setEncodings = function (newEncodings) {
  this.encodings_ = newEncodings;
  this.elements_.forEach(function (vizElement) {
    if (vizElement instanceof NetSimVizSimulationWire) {
      vizElement.setEncodings(newEncodings);
    }
  });
};

/**
 * Kick off an animation that will show the state of the simplex wire being
 * set by the local node.
 * @param {"0"|"1"} newState
 */
NetSimVisualization.prototype.animateSetWireState = function (newState) {
  // Assumptions - we are talking about the wire between the local node
  // and its remote partner.
  // This only gets used in peer-to-peer mode, so there should be an incoming
  // wire too, which we should hide.
  // This is a no-op if no such wire exists.
  // We can stop any previous animation on the wire if this is called

  var vizWire = this.getVizWireToRemote();
  var incomingWire = this.getVizWireFromRemote();
  if (!(vizWire && incomingWire)) {
    return;
  }

  // Hide the incoming wire because we are in simplex mode.
  incomingWire.hide();
  // Animate the outgoing wire
  vizWire.animateSetState(newState);
};

/**
 * Kick off an animation that will show the state of the simplex wire being
 * read by the local node.
 * @param {"0"|"1"} newState
 */
NetSimVisualization.prototype.animateReadWireState = function (newState) {
  // Assumes we are in simplex P2P mode and talking about the wire between
  // the local node and its remote partner.  This is a no-op if no such wire
  // exists.  We can stop any previous animation on the wire if this is called.

  var vizWire = this.getVizWireToRemote();
  var incomingWire = this.getVizWireFromRemote();
  if (!(vizWire && incomingWire)) {
    return;
  }

  // Hide the incoming wire because we are in simplex mode.
  incomingWire.hide();
  // Animate the outgoing wire
  vizWire.animateReadState(newState);
};

/**
 * Find the outgoing wire from the local node to a remote node.
 * @returns {NetSimVizSimulationWire|null} null if no outgoing connection is established.
 */
NetSimVisualization.prototype.getVizWireToRemote = function () {
  if (!this.localNode) {
    return null;
  }

  var outgoingWires = this.elements_.filter(function (element) {
    return element instanceof NetSimVizSimulationWire && element.localVizNode === this.localNode;
  }, this);

  if (outgoingWires.length === 0) {
    return null;
  }

  return outgoingWires[0];
};

/**
 * Find the incoming wire from a remote node to the local node.
 * @returns {NetSimVizSimulationWire|null} null if no incoming connection is established.
 */
NetSimVisualization.prototype.getVizWireFromRemote = function () {
  if (!this.localNode) {
    return null;
  }

  var incomingWires = this.elements_.filter(function (element) {
    return element instanceof NetSimVizSimulationWire && element.remoteVizNode === this.localNode;
  }, this);

  if (incomingWires.length === 0) {
    return null;
  }

  return incomingWires[0];
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimNodeFactory":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNodeFactory.js","./NetSimVisualization.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVisualization.html.ejs","./NetSimVizAutoDnsNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizAutoDnsNode.js","./NetSimVizNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizNode.js","./NetSimVizSimulationNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizSimulationNode.js","./NetSimVizSimulationWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizSimulationWire.js","./NetSimVizWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizWire.js","./NetSimWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimWire.js","./tweens":"/home/trevor/code-dot-org/apps/build/js/netsim/tweens.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizSimulationWire.js":[function(require,module,exports){
/**
 * @overview Wires in the visualization that map to simulation entities.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimGlobals = require('./NetSimGlobals');
var NetSimVizNode = require('./NetSimVizNode');
var NetSimVizWire = require('./NetSimVizWire');

/**
 * @param {NetSimWire} sourceWire
 * @param {function} getElementByEntityID - Allows this wire to search
 *        for other entities in the simulation
 * @constructor
 * @augments NetSimVizWire
 */
var NetSimVizSimulationWire = module.exports = function (sourceWire, getElementByEntityId) {
  var localNode = getElementByEntityId(NetSimVizNode, sourceWire.localNodeID);
  var remoteNode = getElementByEntityId(NetSimVizNode, sourceWire.remoteNodeID);
  NetSimVizWire.call(this, localNode, remoteNode);

  /**
   * ID of the NetSimWire that this NetSimVizSimulationWire maps to.
   * @type {number}
   */
  this.correspondingWireId_ = sourceWire.entityID;

  /**
   * UUID of the NetSimWire that this NetSimVizSimulationWire maps to.
   * @type {number}
   */
  this.correspondingWireUuid_ = sourceWire.uuid;

  /**
   * Bound getElementByEntityId method from vizualization controller;
   * we hold on to this so that calls to configureFrom can find nodes later.
   * @type {Function}
   * @private
   */
  this.getElementByEntityId_ = getElementByEntityId;

  this.configureFrom(sourceWire);
  this.render();
};
NetSimVizSimulationWire.inherits(NetSimVizWire);

/**
 * Configuring a wire means looking up the viz nodes that will be its endpoints.
 * @param {NetSimWire} sourceWire
 */
NetSimVizSimulationWire.prototype.configureFrom = function (sourceWire) {
  this.correspondingWireId_ = sourceWire.entityID;
  this.correspondingWireUuid_ = sourceWire.uuid;

  this.localVizNode = this.getElementByEntityId_(NetSimVizNode, sourceWire.localNodeID);
  this.remoteVizNode = this.getElementByEntityId_(NetSimVizNode, sourceWire.remoteNodeID);

  if (this.localVizNode) {
    this.localVizNode.setAddress(sourceWire.localAddress);
  }

  if (this.remoteVizNode) {
    this.remoteVizNode.setAddress(sourceWire.remoteAddress);
  }

  if (NetSimGlobals.getLevelConfig().broadcastMode) {
    this.getRoot().css('display', 'none');
  }
};

/**
 * ID of the NetSimEntity that maps to this visualization element.
 * @returns {number}
 */
NetSimVizSimulationWire.prototype.getCorrespondingEntityId = function () {
  return this.correspondingWireId_;
};

/**
 * @param {NetSimEntity} entity
 * @returns {boolean} TRUE if this VizElement represents the given NetSimEntity.
 */
NetSimVizSimulationWire.prototype.representsEntity = function (entity) {
  return this.correspondingWireId_ === entity.entityID && this.correspondingWireUuid_ === entity.uuid;
};

/**
 * Killing a visualization node removes its ID so that it won't conflict with
 * another viznode of matching ID being added, and begins its exit animation.
 * @override
 */
NetSimVizSimulationWire.prototype.kill = function () {
  NetSimVizSimulationWire.superPrototype.kill.call(this);
  this.correspondingWireId_ = undefined;
  this.correspondingWireUuid_ = undefined;
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimVizNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizNode.js","./NetSimVizWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizWire.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizWire.js":[function(require,module,exports){
/**
 * @overview Wires in the visualization.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var jQuerySvgElement = require('./NetSimUtils').jQuerySvgElement;
var NetSimVizElement = require('./NetSimVizElement');
var tweens = require('./tweens');
var DataConverters = require('./DataConverters');
var NetSimConstants = require('./NetSimConstants');

var EncodingType = NetSimConstants.EncodingType;

var binaryToAB = DataConverters.binaryToAB;

/**
 * How far the flying label should rest above the wire.
 * @type {number}
 * @const
 */
var TEXT_FINAL_VERTICAL_OFFSET = -10;

/**
 * @param {NetSimVizNode} localNode
 * @param {NetSimVizNode} remoteNode
 * @constructor
 * @augments NetSimVizElement
 */
var NetSimVizWire = module.exports = function (localNode, remoteNode) {
  NetSimVizElement.call(this);

  var root = this.getRoot();
  root.addClass('viz-wire');

  /**
   * @type {jQuery} wrapped around a SVGPathElement
   * @private
   */
  this.line_ = jQuerySvgElement('path').appendTo(root);

  /**
   * @type {jQuery} wrapped around a SVGTextElement
   * @private
   */
  this.questionMark_ = jQuerySvgElement('text').text('?').addClass('question-mark').appendTo(root);

  /**
   * @type {jQuery} wrapped around a SVGTextElement
   * @private
   */
  this.text_ = jQuerySvgElement('text').addClass('state-label').appendTo(root);

  /**
   * X-coordinate of text label, for animation.
   * @type {number}
   * @private
   */
  this.textPosX_ = 0;

  /**
   * Y-coordinate of text label, for animation.
   * @type {number}
   * @private
   */
  this.textPosY_ = 0;

  /**
   * Flag that allows us to force an update of the text position; used
   * when we move text without tweens because that method prevents us
   * from being able to detect normally that something has changed
   * @type {boolean}
   * @private
   */
  this.forceTextPosRender_ = false;

  /**
   * SVG Path Description of this.line_, for animation
   * @type {string}
   * @private
   */
  this.pathData_ = '';

  /**
   * `TEXT_FINAL_VERTICAL_OFFSET`-offset X and Y coordinates for the
   * center of the wire; used for positioning the question mark
   * @type {{x:number, y:number}}
   * @private
   */
  this.wireCenter_ = { x: 0, y: 0 };

  /**
   * Enabled encoding types.
   * @type {EncodingType[]}
   * @private
   */
  this.encodings_ = [];

  this.localVizNode = localNode;
  this.remoteVizNode = remoteNode;

  this.render();
};
NetSimVizWire.inherits(NetSimVizElement);

/**
 * Update path data for wire if we can detect pending changes
 * @param {RunLoop.Clock} [clock] - somtimes omitted during setup
 */
NetSimVizWire.prototype.render = function (clock) {

  // Cache the local position values here, so we can check later if
  // anything has changed before making an expensive `.attr` call
  var textPosX = this.textPosX_;
  var textPosY = this.textPosY_;
  var pathData = this.pathData_;
  var wireCenter = this.wireCenter_;

  // Make the call to super to update everything we can, then
  // recalculate the values of ours that are dependent on the movement
  // of our connected nodes
  NetSimVizWire.superPrototype.render.call(this, clock);

  if (this.localVizNode && this.remoteVizNode) {
    this.pathData_ = ['M', this.localVizNode.posX, this.localVizNode.posY, 'L', this.remoteVizNode.posX, this.remoteVizNode.posY].join(' ');
    this.wireCenter_ = this.getWireCenterPosition();
  }

  // Finally, if and only if any of the values we care about have
  // changed, update our element in the DOM
  if (this.forceTextPosRender_ || textPosX !== this.textPosX_ || textPosY !== this.textPosY_) {
    this.text_.attr('x', this.textPosX_).attr('y', this.textPosY_);
    this.forceTextPosRender_ = false;
  }
  if (pathData !== this.pathData_) {
    this.line_.attr('d', this.pathData_);
  }
  if (wireCenter.x !== this.wireCenter_.x || wireCenter.y !== this.wireCenter_.y) {
    this.questionMark_.attr('x', this.wireCenter_.x).attr('y', this.wireCenter_.y);
  }
};

/**
 * Hide this wire - used to hide the incoming wire when we're trying to show
 * simplex mode.
 */
NetSimVizWire.prototype.hide = function () {
  this.getRoot().addClass('hidden-wire');
};

/**
 * Killing a visualization node removes its ID so that it won't conflict with
 * another node of matching ID being added, and begins its exit animation.
 * @override
 */
NetSimVizWire.prototype.kill = function () {
  NetSimVizWire.superPrototype.kill.call(this);
  this.localVizNode = null;
  this.remoteVizNode = null;
};

/**
 * Update encoding-view settings.  Determines how bit sets/reads are
 * displayed when animating above the wire.
 *
 * @param {EncodingType[]} newEncodings
 */
NetSimVizWire.prototype.setEncodings = function (newEncodings) {
  this.encodings_ = newEncodings;
};

/**
 * Kick off an animation of the wire state being set by the local viznode.
 * @param {"0"|"1"} newState
 */
NetSimVizWire.prototype.animateSetState = function (newState) {
  if (!(this.localVizNode && this.remoteVizNode)) {
    return;
  }

  var flyOutMs = 300;
  var holdPositionMs = 300;

  this.stopAllAnimation();
  this.setWireClasses_(newState);
  this.text_.text(this.getDisplayBit_(newState));
  this.snapTextToPosition(this.getLocalNodePosition());
  this.tweenTextToPosition(this.getWireCenterPosition(), flyOutMs, tweens.easeOutQuad);
  this.doAfterDelay(flyOutMs + holdPositionMs, (function () {
    this.setWireClasses_('unknown');
  }).bind(this));
};

/**
 * Kick off an animation of the wire state being read by the local viznode.
 * @param {"0"|"1"} newState
 */
NetSimVizWire.prototype.animateReadState = function (newState) {
  if (!(this.localVizNode && this.remoteVizNode)) {
    return;
  }

  var holdPositionMs = 300;
  var flyToNodeMs = 300;

  this.stopAllAnimation();
  this.setWireClasses_(newState);
  this.text_.text(this.getDisplayBit_(newState));
  this.snapTextToPosition(this.getWireCenterPosition());
  this.doAfterDelay(holdPositionMs, (function () {
    this.tweenTextToPosition(this.getLocalNodePosition(), flyToNodeMs, tweens.easeOutQuad);
    this.setWireClasses_('unknown');
  }).bind(this));
};

/**
 * Adds/removes classes from the SVG root according to the given wire state.
 * Passing anything other than "1" or "0" will put the wire in an "unknown"
 * state, which begins a CSS transition fade back to gray.
 * @param {"0"|"1"|*} newState
 * @private
 */
NetSimVizWire.prototype.setWireClasses_ = function (newState) {
  var stateOff = newState === '0';
  var stateOn = !stateOff && newState === '1';
  var stateUnknown = !stateOff && !stateOn;

  this.getRoot().toggleClass('state-on', stateOn);
  this.getRoot().toggleClass('state-off', stateOff);
  this.getRoot().toggleClass('state-unknown', stateUnknown);
};

/**
 * Get an appropriate "display bit" to show above the wire, given the
 * current enabled encodings (should match the "set wire" button label)
 * @param {"0"|"1"} wireState
 * @returns {string} a display bit appropriate to the enabled encodings.
 * @private
 */
NetSimVizWire.prototype.getDisplayBit_ = function (wireState) {
  if (this.isEncodingEnabled_(EncodingType.A_AND_B) && !this.isEncodingEnabled_(EncodingType.BINARY)) {
    wireState = binaryToAB(wireState);
  }
  return wireState;
};

/**
 * Check whether the given encoding is currently displayed by the panel.
 * @param {EncodingType} queryEncoding
 * @returns {boolean}
 * @private
 */
NetSimVizWire.prototype.isEncodingEnabled_ = function (queryEncoding) {
  return this.encodings_.some(function (enabledEncoding) {
    return enabledEncoding === queryEncoding;
  });
};

/**
 * Creates an animated motion from the text's current position to the
 * given coordinates.
 * @param {{x:number, y:number}} destination
 * @param {number} [duration=600] in milliseconds
 * @param {TweenFunction} [tweenFunction=linear]
 */
NetSimVizWire.prototype.tweenTextToPosition = function (destination, duration, tweenFunction) {
  if (duration > 0) {
    this.tweens_.push(new tweens.TweenValueTo(this, 'textPosX_', destination.x, duration, tweenFunction));
    this.tweens_.push(new tweens.TweenValueTo(this, 'textPosY_', destination.y, duration, tweenFunction));
  } else {
    this.textPosX_ = destination.x;
    this.textPosY_ = destination.y;
    this.forceTextPosRender_ = true;
  }
};

/**
 * Snaps the text to the given position.
 * @param {{x:number, y:number}} destination
 */
NetSimVizWire.prototype.snapTextToPosition = function (destination) {
  this.tweenTextToPosition(destination, 0);
};

/**
 * @returns {{x:number, y:number}}
 */
NetSimVizWire.prototype.getLocalNodePosition = function () {
  return {
    x: this.localVizNode.posX,
    y: this.localVizNode.posY
  };
};

/**
 * @returns {{x:number, y:number}}
 */
NetSimVizWire.prototype.getWireCenterPosition = function () {
  return {
    x: (this.remoteVizNode.posX - this.localVizNode.posX) / 2 + this.localVizNode.posX,
    y: (this.remoteVizNode.posY - this.remoteVizNode.posY) / 2 + this.localVizNode.posY + TEXT_FINAL_VERTICAL_OFFSET
  };
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./NetSimVizElement":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizElement.js","./tweens":"/home/trevor/code-dot-org/apps/build/js/netsim/tweens.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizSimulationNode.js":[function(require,module,exports){
/**
 * @overview Nodes in the visualization that map to simulation entities.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimConstants = require('./NetSimConstants');
var NetSimVizNode = require('./NetSimVizNode');

var NodeType = NetSimConstants.NodeType;

var NetSimGlobals = require('./NetSimGlobals');

/**
 * @param {NetSimNode} sourceNode
 * @param {boolean} useBackgroundAnimation - changes the behavior of this node
 *        when it's in the background layer
 * @constructor
 * @augments NetSimVizNode
 */
var NetSimVizSimulationNode = module.exports = function (sourceNode, useBackgroundAnimation) {
  NetSimVizNode.call(this, useBackgroundAnimation);

  /**
   * ID of the NetSimNode that this NetSimVizSimulationNode represents.
   * @type {number}
   */
  this.correspondingNodeID_ = sourceNode.entityID;

  /**
   * UUID of the NetSimNode that this NetSimVizSimulationNode represents.
   * @type {string}
   */
  this.correspondingNodeUuid_ = sourceNode.uuid;

  /**
   * If we end up representing a router, we may need to hold the auto-dns address
   * to pass to a fake auto-dns node.
   * @type {string}
   */
  this.autoDnsAddress = undefined;

  this.configureFrom(sourceNode);
  this.render();
};
NetSimVizSimulationNode.inherits(NetSimVizNode);

/**
 *
 * @param {NetSimNode} sourceNode
 */
NetSimVizSimulationNode.prototype.configureFrom = function (sourceNode) {
  this.correspondingNodeId_ = sourceNode.entityID;
  this.correspondingNodeUuid_ = sourceNode.uuid;

  var levelConfig = NetSimGlobals.getLevelConfig();
  if (levelConfig.showHostnameInGraph) {
    this.setName(sourceNode.getHostname());
  } else {
    this.setName(sourceNode.getShortDisplayName());
  }

  if (sourceNode.getNodeType() === NodeType.ROUTER) {
    this.isRouter = true;
    this.getRoot().addClass('router-node');
    this.autoDnsAddress = sourceNode.getAutoDnsAddress();
    if (levelConfig.broadcastMode) {
      this.getRoot().css('display', 'none');
    }
  }
};

/**
 * ID of the simulation entity that maps to this one.
 * @returns {number}
 */
NetSimVizSimulationNode.prototype.getCorrespondingEntityId = function () {
  return this.correspondingNodeId_;
};

/**
 * @param {NetSimEntity} entity
 * @returns {boolean} TRUE of this VizElement represents the given Entity.
 */
NetSimVizSimulationNode.prototype.representsEntity = function (entity) {
  return this.correspondingNodeId_ === entity.entityID && this.correspondingNodeUuid_ === entity.uuid;
};

/**
 * Killing a visualization node removes its ID so that it won't conflict with
 * another node of matching ID being added, and begins its exit animation.
 * @override
 */
NetSimVizSimulationNode.prototype.kill = function () {
  NetSimVizSimulationNode.superPrototype.kill.call(this);
  this.correspondingNodeId_ = undefined;
  this.correspondingNodeUuid_ = undefined;
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimVizNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizNode.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizAutoDnsNode.js":[function(require,module,exports){
/**
 * @overview Visualization auto-dns node.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimGlobals = require('./NetSimGlobals');
var NetSimVizNode = require('./NetSimVizNode');

/**
 * @param {boolean} useBackgroundAnimation - changes the behavior of this node
 *        when it's in the background layer
 * @constructor
 * @augments NetSimVizNode
 */
var NetSimVizAutoDnsNode = module.exports = function (useBackgroundAnimation) {
  NetSimVizNode.call(this, useBackgroundAnimation);

  this.getRoot().addClass('auto-dns-node');

  var levelConfig = NetSimGlobals.getLevelConfig();
  if (levelConfig.showHostnameInGraph) {
    this.setName('dns');
  } else {
    this.setName('DNS');
  }

  this.setIsDnsNode(true);
  this.render();
};
NetSimVizAutoDnsNode.inherits(NetSimVizNode);

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimVizNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizNode.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizNode.js":[function(require,module,exports){
/**
 * @overview Nodes in the visualization.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimConstants = require('./NetSimConstants');
var jQuerySvgElement = require('./NetSimUtils').jQuerySvgElement;
var NetSimVizElement = require('./NetSimVizElement');
var tweens = require('./tweens');

var DnsMode = NetSimConstants.DnsMode;

var NetSimGlobals = require('./NetSimGlobals');

/**
 * The narrowest that a text bubble is allowed to be.
 * @type {number}
 * @const
 */
var TEXT_MIN_WIDTH = 30;

/**
 * Width to add to the bubble beyond the width of the student's name.
 * @type {number}
 * @const
 */
var TEXT_PADDING_X = 20;

/**
 * Height to add to the bubble beyond the height of the student's name.
 * @type {number}
 * @const
 */
var TEXT_PADDING_Y = 10;

/**
 * @param {boolean} useBackgroundAnimation - changes the behavior of this node
 *        when it's in the background layer.
 * @constructor
 * @augments NetSimVizElement
 */
var NetSimVizNode = module.exports = function (useBackgroundAnimation) {
  NetSimVizElement.call(this);

  /**
   * @private {string}
   */
  this.address_ = undefined;

  /**
   * @private {DnsMode}
   */
  this.dnsMode_ = undefined;

  /**
   * Whether to start or update any tweens while the node is in the background
   * layer.
   * @private {boolean}
   */
  this.useBackgroundAnimation_ = useBackgroundAnimation;

  /**
   * @type {boolean}
   */
  this.isRouter = false;

  /**
   * @type {boolean}
   */
  this.isLocalNode = false;

  /**
   * @type {boolean}
   */
  this.isDnsNode = false;

  // Give our root node a useful class
  var root = this.getRoot();
  root.addClass('viz-node');

  // Going for a diameter of _close_ to 75
  var radius = 37;
  var textVerticalOffset = 4;

  /**
   *
   * @type {jQuery}
   * @private
   */
  jQuerySvgElement('circle').attr('cx', 0).attr('cy', 0).attr('r', radius).appendTo(root);

  this.nameGroup_ = jQuerySvgElement('g').attr('transform', 'translate(0,0)').appendTo(root);

  this.displayName_ = jQuerySvgElement('text').attr('x', 0).attr('y', textVerticalOffset);

  this.nameBox_ = jQuerySvgElement('rect').addClass('name-box');

  this.nameGroup_.append(this.nameBox_).append(this.displayName_);

  this.addressGroup_ = jQuerySvgElement('g').attr('transform', 'translate(0,30)').hide().appendTo(root);

  this.addressBox_ = jQuerySvgElement('rect').addClass('address-box').appendTo(this.addressGroup_);

  this.addressText_ = jQuerySvgElement('text').addClass('address-box').attr('x', 0).attr('y', textVerticalOffset).text('?').appendTo(this.addressGroup_);

  // Set an initial default tween for zooming in from nothing.
  if (this.useBackgroundAnimation_) {
    this.snapToScale(0);
    this.tweenToScale(0.5, 800, tweens.easeOutElastic);
  } else {
    this.snapToScale(0.5);
  }
};
NetSimVizNode.inherits(NetSimVizElement);

/**
 * Flag this viz node as the simulation local node.
 */
NetSimVizNode.prototype.setIsLocalNode = function () {
  this.isLocalNode = true;
  this.getRoot().addClass('local-node');
};

/**
 * Change the display name of the viz node
 * @param {string} newName
 */
NetSimVizNode.prototype.setName = function (newName) {
  this.displayName_.text(newName);
  this.resizeNameBox_();
};

/** @private */
NetSimVizNode.prototype.resizeNameBox_ = function () {
  this.resizeRectToText_(this.nameBox_, this.displayName_);
};

/** @private */
NetSimVizNode.prototype.resizeAddressBox_ = function () {
  this.resizeRectToText_(this.addressBox_, this.addressText_);
};

/**
 * Utility for resizing a background rounded-rect to fit the given text element.
 * @param {jQuery} rect
 * @param {jQuery} text
 * @private
 */
NetSimVizNode.prototype.resizeRectToText_ = function (rect, text) {
  try {
    var box = text[0].getBBox();
    var width = Math.max(TEXT_MIN_WIDTH, box.width + TEXT_PADDING_X);
    var height = box.height + TEXT_PADDING_Y;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    rect.attr('x', -halfWidth).attr('y', -halfHeight).attr('rx', halfHeight).attr('ry', halfHeight).attr('width', width).attr('height', height);
  } catch (e) {
    // Just allow this to be a no-op if it fails.  In some browsers,
    // getBBox will throw if the element is not yet in the DOM.
  }
};

/**
 * Killing a visualization node removes its ID so that it won't conflict with
 * another node of matching ID being added, and begins its exit animation.
 * @override
 */
NetSimVizNode.prototype.kill = function () {
  NetSimVizNode.superPrototype.kill.call(this);
  this.stopAllAnimation();
  this.tweenToScale(0, 200, tweens.easeInQuad);
};

/**
 * Provides drifting animation for nodes in the background.
 * @param {RunLoop.Clock} clock
 */
NetSimVizNode.prototype.tick = function (clock) {
  NetSimVizNode.superPrototype.tick.call(this, clock);

  // Trigger a new drift if we're in the background and the last one finished.
  if (this.useBackgroundAnimation_ && !this.isForeground && this.tweens_.length === 0) {
    var randomX = 300 * Math.random() - 150;
    var randomY = 300 * Math.random() - 150;
    this.tweenToPosition(randomX, randomY, 20000, tweens.easeInOutQuad);
  }
};

/**
 * When visible, runs every frame
 * @param {RunLoop.Clock} [clock]
 */
NetSimVizNode.prototype.render = function (clock) {
  NetSimVizNode.superPrototype.render.call(this, clock);

  // If currently animating, adjust text box sizes to match
  if (this.isForeground && this.tweens_.length > 0) {
    this.resizeNameBox_();
    this.resizeAddressBox_();
  }
};

/**
 * @param {boolean} isForeground
 */
NetSimVizNode.prototype.onDepthChange = function (isForeground) {
  NetSimVizNode.superPrototype.onDepthChange.call(this, isForeground);

  // Don't add tweens if this node has been killed
  if (this.isDying() || this.isDead()) {
    return;
  }

  this.tweens_.length = 0;
  if (isForeground) {
    this.tweenToScale(1, 600, tweens.easeOutElastic);
  } else if (this.useBackgroundAnimation_) {
    this.tweenToScale(0.5, 600, tweens.easeOutElastic);
  } else {
    this.snapToScale(0.5);
  }
};

/**
 * @param {string} address
 */
NetSimVizNode.prototype.setAddress = function (address) {
  this.address_ = address;
  this.updateAddressDisplay();
};

/**
 * @param {DNSMode} newDnsMode
 */
NetSimVizNode.prototype.setDnsMode = function (newDnsMode) {
  this.dnsMode_ = newDnsMode;
  this.updateAddressDisplay();
};

/**
 * @param {boolean} isDnsNode
 */
NetSimVizNode.prototype.setIsDnsNode = function (isDnsNode) {
  this.isDnsNode = isDnsNode;
  this.updateAddressDisplay();
};

NetSimVizNode.prototype.updateAddressDisplay = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  // If we are never assigned an address, don't try to show one.
  // In broadcast mode we will be assigned addresses but never use them, so
  //   they should be hidden.
  // Routers never show their address.
  if (this.address_ === undefined || levelConfig.broadcastMode || this.isRouter) {
    this.addressGroup_.hide();
    return;
  }

  this.addressGroup_.show();
  if (this.dnsMode_ === DnsMode.NONE) {
    this.addressText_.text(this.address_ !== undefined ? this.address_ : '?');
  } else {
    this.addressText_.text(this.isLocalNode || this.isDnsNode ? this.address_ : '?');
  }
  this.resizeAddressBox_();
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./NetSimVizElement":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizElement.js","./tweens":"/home/trevor/code-dot-org/apps/build/js/netsim/tweens.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVizElement.js":[function(require,module,exports){
/**
 * @overview Base type for visible elements in the visualization.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var jQuerySvgElement = require('./NetSimUtils').jQuerySvgElement;
var tweens = require('./tweens');

/**
 * A VizElement is an object that  has a representation in the network
 * visualization.  Its role is to maintain that visual representation.
 * A VizElement has helpers for positioning, scaling and tweening.
 * Every VizElement has a root element which is a <g> tag, an SVG "group"
 * that contains the other components that will actually draw.
 *
 * @constructor
 */
var NetSimVizElement = module.exports = function () {
  /**
   * @type {number}
   */
  this.posX = 0;

  /**
   * @type {number}
   */
  this.posY = 0;

  /**
   * @type {number}
   */
  this.scale = 1;

  /**
   * @type {boolean}
   */
  this.isForeground = false;

  /**
   * Root SVG <g> (group) element for this object.
   * @type {jQuery}
   * @private
   */
  this.rootGroup_ = jQuerySvgElement('g');

  /**
   * Set of tweens we should currently be running on this node.
   * Processed by tick()
   * @type {Array.<exports.TweenValueTo>}
   * @private
   */
  this.tweens_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.isDead_ = false;
};

/**
 * @returns {jQuery} wrapper around root <g> element
 */
NetSimVizElement.prototype.getRoot = function () {
  return this.rootGroup_;
};

/**
 * Begins the process of destroying this VizElement.  Once started, this
 * process cannot be stopped.
 * This method can be overridden to trigger an "on-death" animation.
 */
NetSimVizElement.prototype.kill = function () {
  this.isDead_ = true;
};

/**
 * @returns {boolean} whether this entity is done with its death animation
 *          and is ready to be cleaned up by the visualization manager.
 *          The default implementation here returns TRUE as soon as kill()
 *          is called and all animations are completed.
 */
NetSimVizElement.prototype.isDead = function () {
  return this.isDead_ && this.tweens_.length === 0;
};

/**
 * @returns {boolean} whether this entity is playing its final animation
 *          and will be ready to be cleaned up by the visualization manager
 *          soon.
 */
NetSimVizElement.prototype.isDying = function () {
  return this.isDead_ && this.tweens_.length > 0;
};

/**
 * Update all of the tweens currently running on this VizElement (which will
 * probably modify its properties) and then remove any tweens that are completed
 * from the list.
 */
NetSimVizElement.prototype.tick = function () {};

/**
 * Update the root group's properties to reflect our current position
 * and scale.
 * @param {RunLoop.Clock} [clock] - sometimes omitted during setup
 */
NetSimVizElement.prototype.render = function (clock) {
  if (!clock) {
    return;
  }

  // cache initial settings here; we check them later to see if anything
  // has actually changed
  var posX = this.posX;
  var posY = this.posY;
  var scale = this.scale;

  // Update tweens in the render loop so they are very smooth
  this.tweens_.forEach(function (tween) {
    tween.tick(clock);
  });
  this.tweens_ = this.tweens_.filter(function (tween) {
    return !tween.isFinished;
  });

  // If nothing has changed, don't bother to update transform
  if (posX !== this.posX || posY !== this.posY || scale !== this.scale) {
    var transform = 'translate(' + this.posX + ' ' + this.posY + ')' + ' scale(' + this.scale + ')';
    this.rootGroup_.attr('transform', transform);
  }
};

/**
 * @param {boolean} isForeground
 */
NetSimVizElement.prototype.onDepthChange = function (isForeground) {
  this.isForeground = isForeground;
};

/**
 * Throw away all existing tweens on this object.
 */
NetSimVizElement.prototype.stopAllAnimation = function () {
  this.tweens_.length = 0;
};

/**
 * Stops any existing motion animation and begins an animated motion to the
 * given coordinates.  Note: This animates the VizElement's root group.
 * @param {number} newX given in SVG points
 * @param {number} newY given in SVG points
 * @param {number} [duration=600] in milliseconds
 * @param {TweenFunction} [tweenFunction=linear]
 */
NetSimVizElement.prototype.tweenToPosition = function (newX, newY, duration, tweenFunction) {
  // Don't accept new animation commands if we've already been killed
  if (this.isDying() || this.isDead()) {
    return;
  }

  // Remove any existing tweens controlling posX or posY
  this.removeAllTweensOnProperties(['posX', 'posY']);

  // Add two new tweens, one for each axis
  if (duration > 0) {
    this.tweens_.push(new tweens.TweenValueTo(this, 'posX', newX, duration, tweenFunction));
    this.tweens_.push(new tweens.TweenValueTo(this, 'posY', newY, duration, tweenFunction));
  } else {
    this.posX = newX;
    this.posY = newY;
  }
};

/**
 * Alias for calling tweenToPosition with a zero duration
 * @param {number} newX given in SVG points
 * @param {number} newY given in SVG points
 */
NetSimVizElement.prototype.snapToPosition = function (newX, newY) {
  this.tweenToPosition(newX, newY, 0);
};

/**
 * Stops any existing animation of the entity's scale and begins an animated
 * change to the given target scale value.  Note: this animates the VizElement's
 * root group.
 * @param {number} newScale where 1.0 is 100% (unscaled)
 * @param {number} [duration=600] in milliseconds
 * @param {TweenFunction} [tweenFunction=linear]
 */
NetSimVizElement.prototype.tweenToScale = function (newScale, duration, tweenFunction) {
  // Remove existing scale tweens
  this.removeAllTweensOnProperty('scale');

  // On nonzero duration, add tween to target scale.  Otherwise just set it.
  if (duration > 0) {
    this.tweens_.push(new tweens.TweenValueTo(this, 'scale', newScale, duration, tweenFunction));
  } else {
    this.scale = newScale;
  }
};

NetSimVizElement.prototype.doAfterDelay = function (delay, callback) {
  if (delay > 0) {
    this.tweens_.push(new tweens.DoAfterDelay(this, delay, callback));
  } else {
    callback();
  }
};

/**
 * Remove (stop) all active tweens that control the given property on this
 * visualization entity.
 * @param {string} propertyName
 */
NetSimVizElement.prototype.removeAllTweensOnProperty = function (propertyName) {
  this.removeAllTweensOnProperties([propertyName]);
};

/**
 * Remove (stop) all active tweens that control any of the given properties
 * on this visualization entity.
 * @param {string[]} propertyNames
 */
NetSimVizElement.prototype.removeAllTweensOnProperties = function (propertyNames) {
  this.tweens_ = this.tweens_.filter(function (tween) {
    var targetsThisEntity = tween.target === this;
    var isRemovableProperty = propertyNames.some(function (name) {
      return tween.propertyName === name;
    });

    // Invert for filter() because we want to keep everything BUT the matched
    // properties
    return !(targetsThisEntity && isRemovableProperty);
  }, this);
};

/**
 * Alias for calling tweenToScale with a zero duration.
 * @param {number} newScale where 1.0 is 100% (unscaled)
 */
NetSimVizElement.prototype.snapToScale = function (newScale) {
  this.tweenToScale(newScale, 0);
};

},{"./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./tweens":"/home/trevor/code-dot-org/apps/build/js/netsim/tweens.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/tweens.js":[function(require,module,exports){
/**
 * @overview Tween functions used to animate visualization elements.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var valueOr = require('../utils').valueOr;

/**
 * Default tween duration in milliseconds
 * @type {number}
 * @const
 */
var DEFAULT_TWEEN_DURATION = 600;

/**
 * A four-arg interpolation function.
 *
 * @typedef {function} TweenFunction
 * @param {number} t - current Time, in milliseconds since tween began
 * @param {number} b - Begin value
 * @param {number} c - final Change in value
 * @param {number} d - total tween Duration
 * @returns {number} the interpolated value for the current time
 */

/**
 * Interpolates with a little back-and-forth over the target value at the end.
 * @type {TweenFunction}
 */
exports.easeOutElastic = function (t, b, c, d) {
  var s, p, a;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) {
    return b;
  }
  if ((t /= d) === 1) {
    return b + c;
  }
  if (!p) {
    p = d * 0.3;
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
};

/**
 * Interpolates, accelerating as it goes.
 * @type {TweenFunction}
 */
exports.easeInQuad = function (t, b, c, d) {
  return c * (t /= d) * t + b;
};

/**
 * Interpolates, decelerating as it goes.
 * @type {TweenFunction}
 */
exports.easeOutQuad = function (t, b, c, d) {
  return -c * (t /= d) * (t - 2) + b;
};

exports.easeInOutQuad = function (t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t + b;
  }
  return -c / 2 * (--t * (t - 2) - 1) + b;
};

/**
 * Linear interpolation
 * @type {TweenFunction}
 */
exports.linear = function (t, b, c, d) {
  return c * (t / d) + b;
};

/**
 * Wraps a tween method with the state it needs to animate a property.
 * On creation, assumes that property's current value for start values.
 * Must be ticked to progress toward completion.
 *
 * @param {!Object} target - The object owning the property we want to animate
 * @param {!string} propertyName - Must be a valid property on target
 * @param {!number} endValue - The desired final value of the property
 * @param {number} [duration] - How long the tween should take in milliseconds,
 *        default 600ms
 * @param {TweenFunction} [tweenFunction] - A tween function, default linear
 * @constructor
 */
exports.TweenValueTo = function (target, propertyName, endValue, duration, tweenFunction) {
  /**
   * Will be set to TRUE when tween is completed.
   * @type {boolean}
   */
  this.isFinished = false;

  /**
   * Will be set on our first tick.
   * @type {number}
   * @private
   */
  this.startTime_ = undefined;

  /**
   * @type {Object}
   */
  this.target = target;

  /**
   * @type {string}
   * @private
   */
  this.propertyName = propertyName;

  /**
   * @type {TweenFunction}
   * @private
   */
  this.tweenFunction_ = valueOr(tweenFunction, exports.linear);

  /**
   * @type {number}
   * @private
   */
  this.startValue_ = target[propertyName];

  /**
   * @type {number}
   * @private
   */
  this.deltaValue_ = endValue - this.startValue_;

  /**
   * Duration of tween in milliseconds
   * @type {number}
   * @private
   */
  this.duration_ = valueOr(duration, DEFAULT_TWEEN_DURATION);
};

/**
 * @param {RunLoop.clock} clock
 */
exports.TweenValueTo.prototype.tick = function (clock) {
  if (this.startTime_ === undefined) {
    this.startTime_ = clock.time;
  }

  var timeSinceStart = clock.time - this.startTime_;

  if (this.deltaValue_ !== 0) {
    this.target[this.propertyName] = this.tweenFunction_(timeSinceStart, this.startValue_, this.deltaValue_, this.duration_);
  }

  if (timeSinceStart >= this.duration_) {
    this.target[this.propertyName] = this.startValue_ + this.deltaValue_;
    this.isFinished = true;
  }
};

exports.DoAfterDelay = function (target, duration, callback) {
  /**
   * Will be set to TRUE when tween is completed.
   * @type {boolean}
   */
  this.isFinished = false;

  /**
   * Will be set on our first tick.
   * @type {number}
   * @private
   */
  this.startTime_ = undefined;

  /**
   * @type {Object}
   */
  this.target = target;

  /**
   * @type {string}
   * @private
   */
  this.propertyName = null;

  /**
   * Duration of tween in milliseconds
   * @type {number}
   * @private
   */
  this.duration_ = duration;

  /**
   * Function to call when the duration has elapsed.
   * @type {function}
   */
  this.callback_ = callback;
};

/**
 * @param {RunLoop.clock} clock
 */
exports.DoAfterDelay.prototype.tick = function (clock) {
  if (this.startTime_ === undefined) {
    this.startTime_ = clock.time;
  }

  var timeSinceStart = clock.time - this.startTime_;
  if (timeSinceStart >= this.duration_) {
    this.callback_();
    this.isFinished = true;
  }
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimVisualization.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
/**
 * Whether the blurred background layer should be visible.
 * @name showBackground
 * @type {boolean}
 */
; buf.push('\n<svg version="1.1" width="298" height="298" xmlns="http://www.w3.org/2000/svg">\n\n  ');10; if (showBackground) { ; buf.push('\n    <filter id="backgroundBlur">\n      <feGaussianBlur in="SourceGraphic" stdDeviation="5" />\n      <feComponentTransfer>\n        <feFuncA slope="0.5" type="linear"></feFuncA>\n      </feComponentTransfer>\n    </filter>\n  ');17; } ; buf.push('\n\n  <g id="centered-group" transform="translate(150,150)">\n    <g id="background-group"\n       ');21; if (showBackground) { ; buf.push('\n         filter="url(#backgroundBlur)"\n       ');23; } else { ; buf.push('\n         visibility="hidden"\n       ');25; } ; buf.push('\n        ></g>\n\n    <g id="foreground-group"></g>\n  </g>\n</svg>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTabsComponent.js":[function(require,module,exports){
/**
 * @overview UI controller for tabs area in left column
 *           Directly controls the instructions tab, others are delegated.
 * @see NetSimMyDeviceTab
 * @see NetSimRouterTab
 * @see NetSimDnsTab
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var buildMarkup = require('./NetSimTabsComponent.html.ejs');
var NetSimRouterTab = require('./NetSimRouterTab');
var NetSimMyDeviceTab = require('./NetSimMyDeviceTab');
var NetSimDnsTab = require('./NetSimDnsTab');
var NetSimTabType = require('./NetSimConstants').NetSimTabType;
var shouldShowTab = require('./NetSimUtils').shouldShowTab;
var NetSimGlobals = require('./NetSimGlobals');

/**
 * Wrapper component for tabs panel on the right side of the page.
 * @param {jQuery} rootDiv
 * @param {RunLoop} runLoop
 * @param {Object} callbacks
 * @param {function} callbacks.chunkSizeSliderChangeCallback
 * @param {function} callbacks.myDeviceBitRateChangeCallback
 * @param {function} callbacks.encodingChangeCallback
 * @param {function} callbacks.routerBandwidthSliderChangeCallback
 * @param {function} callbacks.routerBandwidthSliderStopCallback
 * @param {function} callbacks.routerMemorySliderChangeCallback
 * @param {function} callbacks.routerMemorySliderStopCallback
 * @param {function} callbacks.dnsModeChangeCallback
 * @param {function} callbacks.becomeDnsCallback
 * @constructor
 */
var NetSimTabsComponent = module.exports = function (rootDiv, runLoop, callbacks) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {RunLoop}
   * @private
   */
  this.runLoop_ = runLoop;

  /**
   * @type {function}
   * @private
   */
  this.chunkSizeSliderChangeCallback_ = callbacks.chunkSizeSliderChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.myDeviceBitRateChangeCallback_ = callbacks.myDeviceBitRateChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.encodingChangeCallback_ = callbacks.encodingChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.routerBandwidthSliderChangeCallback_ = callbacks.routerBandwidthSliderChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.routerBandwidthSliderStopCallback_ = callbacks.routerBandwidthSliderStopCallback;

  /**
   * @type {function}
   * @private
   */
  this.routerMemorySliderChangeCallback_ = callbacks.routerMemorySliderChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.routerMemorySliderStopCallback_ = callbacks.routerMemorySliderStopCallback;

  /**
   * @type {function}
   * @private
   */
  this.dnsModeChangeCallback_ = callbacks.dnsModeChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.becomeDnsCallback_ = callbacks.becomeDnsCallback;

  /**
   * @type {NetSimRouterTab}
   * @private
   */
  this.routerTab_ = null;

  /**
   * @type {NetSimMyDeviceTab}
   * @private
   */
  this.myDeviceTab_ = null;

  /**
   * @type {NetSimDnsTab}
   * @private
   */
  this.dnsTab_ = null;

  // Initial render
  this.render();
};

/**
 * @param {RunLoop} runLoop
 */
NetSimTabsComponent.prototype.attachToRunLoop = function (runLoop) {
  if (this.routerTab_) {
    this.routerTab_.attachToRunLoop(runLoop);
  }
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimTabsComponent.prototype.render = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();
  // Clone the reference area (with handlers) before we re-render
  var referenceArea = $('#reference_area').first().clone(true);

  // Remove the instructions area, to reattach in a minute.
  var instructionsArea = $('#bubble').first().detach();

  var rawMarkup = buildMarkup({
    level: levelConfig
  });
  var jQueryWrap = $(rawMarkup);
  this.rootDiv_.html(jQueryWrap);

  this.rootDiv_.find('.netsim-tabs').tabs({
    active: levelConfig.defaultTabIndex
  });

  if (shouldShowTab(levelConfig, NetSimTabType.INSTRUCTIONS) && referenceArea) {
    var instructionsTab = this.rootDiv_.find('#tab_instructions').first();
    instructionsArea.appendTo(instructionsTab);
    referenceArea.appendTo(instructionsTab);
  }

  if (shouldShowTab(levelConfig, NetSimTabType.MY_DEVICE)) {
    this.myDeviceTab_ = new NetSimMyDeviceTab(this.rootDiv_.find('#tab_my_device'), this.runLoop_, {
      chunkSizeChangeCallback: this.chunkSizeSliderChangeCallback_,
      bitRateChangeCallback: this.myDeviceBitRateChangeCallback_,
      encodingChangeCallback: this.encodingChangeCallback_
    });
  }

  if (shouldShowTab(levelConfig, NetSimTabType.ROUTER)) {
    this.routerTab_ = new NetSimRouterTab(this.rootDiv_.find('#tab_router'), {
      bandwidthSliderChangeCallback: this.routerBandwidthSliderChangeCallback_,
      bandwidthSliderStopCallback: this.routerBandwidthSliderStopCallback_,
      memorySliderChangeCallback: this.routerMemorySliderChangeCallback_,
      memorySliderStopCallback: this.routerMemorySliderStopCallback_
    });
  }

  if (shouldShowTab(levelConfig, NetSimTabType.DNS)) {
    this.dnsTab_ = new NetSimDnsTab(this.rootDiv_.find('#tab_dns'), this.dnsModeChangeCallback_, this.becomeDnsCallback_);
  }
};

/** @param {number} newChunkSize */
NetSimTabsComponent.prototype.setChunkSize = function (newChunkSize) {
  if (this.myDeviceTab_) {
    this.myDeviceTab_.setChunkSize(newChunkSize);
  }
};

/** @param {number} newBitRate in bits per second */
NetSimTabsComponent.prototype.setMyDeviceBitRate = function (newBitRate) {
  if (this.myDeviceTab_) {
    this.myDeviceTab_.setBitRate(newBitRate);
  }
};

/** @param {EncodingType[]} newEncodings */
NetSimTabsComponent.prototype.setEncodings = function (newEncodings) {
  if (this.myDeviceTab_) {
    this.myDeviceTab_.setEncodings(newEncodings);
  }
};

/** @param {number} creationTimestampMs */
NetSimTabsComponent.prototype.setRouterCreationTime = function (creationTimestampMs) {
  if (this.routerTab_) {
    this.routerTab_.setRouterCreationTime(creationTimestampMs);
  }
};

/** @param {number} newBandwidth in bits/second */
NetSimTabsComponent.prototype.setRouterBandwidth = function (newBandwidth) {
  if (this.routerTab_) {
    this.routerTab_.setBandwidth(newBandwidth);
  }
};

/** @param {number} newMemory in bits */
NetSimTabsComponent.prototype.setRouterMemory = function (newMemory) {
  if (this.routerTab_) {
    this.routerTab_.setMemory(newMemory);
  }
};

/**
 * @param {number} queuedPacketCount
 */
NetSimTabsComponent.prototype.setRouterQueuedPacketCount = function (queuedPacketCount) {
  if (this.routerTab_) {
    this.routerTab_.setRouterQueuedPacketCount(queuedPacketCount);
  }
};

/** @param {number} usedMemoryInBits */
NetSimTabsComponent.prototype.setRouterMemoryInUse = function (usedMemoryInBits) {
  if (this.routerTab_) {
    this.routerTab_.setMemoryInUse(usedMemoryInBits);
  }
};

NetSimTabsComponent.prototype.setRouterDataRate = function (dataRateBitsPerSecond) {
  if (this.routerTab_) {
    this.routerTab_.setDataRate(dataRateBitsPerSecond);
  }
};

/** @param {string} newDnsMode */
NetSimTabsComponent.prototype.setDnsMode = function (newDnsMode) {
  if (this.dnsTab_) {
    this.dnsTab_.setDnsMode(newDnsMode);
  }
};

/** @param {boolean} isDnsNode */
NetSimTabsComponent.prototype.setIsDnsNode = function (isDnsNode) {
  if (this.dnsTab_) {
    this.dnsTab_.setIsDnsNode(isDnsNode);
  }
};

/** @param {Array} tableContents */
NetSimTabsComponent.prototype.setDnsTableContents = function (tableContents) {
  if (this.dnsTab_) {
    this.dnsTab_.setDnsTableContents(tableContents);
  }
};

/** @param {Array} logData */
NetSimTabsComponent.prototype.setRouterLogData = function (logData) {
  if (this.routerTab_) {
    this.routerTab_.setRouterLogData(logData);
  }
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimDnsTab":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTab.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimMyDeviceTab":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMyDeviceTab.js","./NetSimRouterTab":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterTab.js","./NetSimTabsComponent.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTabsComponent.html.ejs","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTabsComponent.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var i18n = require('./locale');

  var shouldShowTab = require('./NetSimUtils').shouldShowTab;
  var NetSimTabType = require('./NetSimConstants').NetSimTabType;

  var showInstructions = shouldShowTab(level, NetSimTabType.INSTRUCTIONS);
  var showMyDevice = shouldShowTab(level, NetSimTabType.MY_DEVICE);
  var showRouter = shouldShowTab(level, NetSimTabType.ROUTER);
  var showDns = shouldShowTab(level, NetSimTabType.DNS);
; buf.push('\n<div class="netsim-tabs">\n  <ul>\n    ');14; if (showInstructions) { ; buf.push('\n    <li><a href="#tab_instructions">', escape((15,  i18n.instructions() )), '</a></li>\n    ');16; } ; buf.push('\n    ');17; if (showMyDevice) { ; buf.push('\n      <li><a href="#tab_my_device">', escape((18,  i18n.myDevice() )), '</a></li>\n    ');19; } ; buf.push('\n    ');20; if (showRouter) { ; buf.push('\n      <li><a href="#tab_router">', escape((21,  i18n.router() )), '</a></li>\n    ');22; } ; buf.push('\n    ');23; if (showDns) { ; buf.push('\n      <li><a href="#tab_dns">', escape((24,  i18n.dns() )), '</a></li>\n    ');25; } ; buf.push('\n  </ul>\n  ');27; if (showInstructions) { ; buf.push('\n    <div id="tab_instructions"></div>\n  ');29; } ; buf.push('\n  ');30; if (showMyDevice) { ; buf.push('\n    <div id="tab_my_device"></div>\n  ');32; } ; buf.push('\n  ');33; if (showRouter) { ; buf.push('\n    <div id="tab_router"></div>\n  ');35; } ; buf.push('\n  ');36; if (showDns) { ; buf.push('\n    <div id="tab_dns"></div>\n  ');38; } ; buf.push('\n</div>'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimStatusPanel.js":[function(require,module,exports){
/**
 * @overview UI component: The small expandable box above the visualization,
 *           used to show debug and diagnostic information.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils'); // For Function.prototype.inherits()
var i18n = require('./locale');
var markup = require('./NetSimStatusPanel.html.ejs');
var NetSimPanel = require('./NetSimPanel.js');
var NetSimUtils = require('./NetSimUtils');

/**
 * Generator and controller for connection status panel
 * in left column, displayed while connected.
 * @param {jQuery} rootDiv
 * @param {Object} callbacks
 * @param {function} callbacks.disconnectCallback - method to call when disconnect button
 *        is clicked.
 * @constructor
 * @augments NetSimPanel
 */
var NetSimStatusPanel = module.exports = function (rootDiv, callbacks) {
  /**
   * @type {function}
   * @private
   */
  this.disconnectCallback_ = callbacks.disconnectCallback;

  // Superclass constructor
  NetSimPanel.call(this, rootDiv, {
    className: 'netsim_status_panel',
    panelTitle: 'Status',
    userToggleable: false,
    beginMinimized: true
  });
};
NetSimStatusPanel.inherits(NetSimPanel);

/**
 * @param {Object} [data]
 * @param {string} [data.remoteNodeName] - Display name of remote node.
 * @param {string} [data.myHostname] - Hostname of local node
 * @param {number} [data.myAddress] - Local node address assigned by router
 * @param {string} [data.shareLink] - URL for sharing private shard
 */
NetSimStatusPanel.prototype.render = function (data) {
  data = data || {};

  // Capture title before we render the wrapper panel.
  this.setPanelTitle(data.remoteNodeName);

  // Render boilerplate panel stuff
  NetSimStatusPanel.superPrototype.render.call(this);

  // Put our own content into the panel body
  var newMarkup = $(markup({
    myHostname: data.myHostname,
    myAddress: data.myAddress,
    shareLink: data.shareLink
  }));
  this.getBody().html(newMarkup);

  // Add a button to the panel header
  this.addButton(i18n.disconnectButton({ caret: '<i class="fa fa-caret-left"></i>' }), this.disconnectCallback_);

  // Button that takes you to the next level.
  NetSimUtils.makeContinueButton(this);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimPanel.js":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./NetSimStatusPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimStatusPanel.html.ejs","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimStatusPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var i18n = require('./locale');
; buf.push('\n<div class="content-wrap">\n  ');5; if (myHostname) { ; buf.push('\n  <p>My hostname: ', escape((6,  myHostname )), '</p>\n  ');7; } ; buf.push('\n\n  ');9; if (myAddress) { ; buf.push('\n  <p>My address: ', escape((10,  myAddress )), '</p>\n  ');11; } ; buf.push('\n\n  ');13; if (shareLink) { ; buf.push('\n  <p><a href="', escape((14,  shareLink )), '">', escape((14,  i18n.shareThisNetwork() )), '</a></p>\n  ');15; } ; buf.push('\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShard.js":[function(require,module,exports){
/**
 * @overview Represents a collection of tables that map to a particular
 *           class section's simulation, isolated from other class sections.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var NetSimTable = require('./NetSimTable');
var PubSubService = require('./PubSubService');

/**
 * PubSub event key for events invalidating all tables.
 * @const {string}
 */
var WHOLE_SHARD_EVENT = 'all_tables';

/**
 * A shard is an isolated, complete simulation state shared by a subset of
 * users.  It's made of a set of storage tables set apart by a particular
 * shard ID in their names.  We use shards to allow students to interact only
 * with their particular class while still storing all NetSim tables under
 * the same App ID.
 *
 * @param {!string} shardID
 * @param {!PubSubConfig} pubSubConfig
 * @constructor
 */
var NetSimShard = module.exports = function (shardID, pubSubConfig) {
  /** @type {string} */
  this.id = shardID;

  /** @type {PubSubService} */
  this.pubSub = PubSubService.create(pubSubConfig);

  /** @type {PubSubChannel} */
  this.pubSubChannel = this.pubSub.subscribe(this.id);
  this.pubSubChannel.subscribe(WHOLE_SHARD_EVENT, NetSimShard.prototype.onPubSubEvent_.bind(this));

  /**
   * Collection of client (user) nodes and router nodes on the shard.
   * Each client node corresponds to a user (or browser tab, to be specific).
   * Router nodes are not associated with a particular user.
   *
   * All entities in this table descend from NetSimNode, and can be deserialized
   * via utilities in NetSimNodeFactory
   *
   * Rows in this table are
   * - inserted when a node is created (such as when a user connects)
   * - updated for certain changes to node status or router configuration
   * - deleted when a node is destroyed (such as when a user disconnects)
   *
   * @type {NetSimTable}
   * @see {NetSimNode}
   * @see {NetSimClientNode}
   * @see {NetSimRouterNode}
   * @see {NetSimLocalClientNode}
   * @see {NetSimNodeFactory}
   */
  this.nodeTable = new NetSimTable(this.pubSubChannel, shardID, 'n');

  /**
   * Collection of wires on the shard.  Wires document the connections between
   * nodes and certain node metadata, like hostnames and addresses.  Wires
   * reference node IDs, and are therefore referentially dependent on the node
   * table.
   *
   * All entities in this table deserialize into NetSimWire.
   *
   * Rows in this table are
   * - inserted when two nodes are connected
   * - updated when assigning an address
   * - deleted when two nodes are disconnected
   *
   * @type {NetSimTable}
   * @see {NetSimWire}
   */
  this.wireTable = new NetSimTable(this.pubSubChannel, shardID, 'w');

  /**
   * Collection of messages (enqueued or in-flight) on the shard.  Messages
   * reference node IDs, and are therefore referentially dependent on the node
   * table.
   *
   * All entities in this table deserialize into NetSimMessage.
   *
   * Rows in this table are
   * - inserted when a message is sent
   * - never updated
   * - deleted when a message is received
   *
   * @type {NetSimTable}
   * @see {NetSimMessage}
   */
  this.messageTable = new NetSimTable(this.pubSubChannel, shardID, 'm');

  /**
   * Collection of log entries for nodes on the shard.  Logs reference node IDs,
   * and are therefore referentially dependent on the node table (but we should
   * change this).channel
   *
   * All entities in this table deserialize into NetSimLogEntry.
   *
   * Rows in this table are
   * - inserted when a router routes or drops a message
   * - never updated
   * - never deleted
   *
   * @type {NetSimTable}
   * @see {NetSimLogEntry}
   */
  this.logTable = new NetSimTable(this.pubSubChannel, shardID, 'l', {
    // This is only safe to do because we never update or delete rows in this table.
    useIncrementalRefresh: true
  });
  this.logTable.unsubscribe();
};

/**
 * Necessary tear-down for shard.  In particular, disconnecting
 * from pubsub service.
 */
NetSimShard.prototype.disconnect = function () {
  this.nodeTable.unsubscribe();
  this.wireTable.unsubscribe();
  this.messageTable.unsubscribe();
  this.logTable.unsubscribe();
  this.pubSubChannel.unsubscribe(WHOLE_SHARD_EVENT);
  this.pubSubChannel = null;
  this.pubSub.unsubscribe(this.id);
};

/**
 * This tick allows our tables to poll the server for changes.
 * @param {!RunLoop.Clock} clock
 */
NetSimShard.prototype.tick = function (clock) {
  this.nodeTable.tick(clock);
  this.wireTable.tick(clock);
  this.messageTable.tick(clock);
  this.logTable.tick(clock);
};

/**
 * The "panic button" option - clears all data on the shard, kicking all
 * users out and starting over.
 * @param {NodeStyleCallback} onComplete
 */
NetSimShard.prototype.resetEverything = function (onComplete) {
  $.ajax({
    url: '/v3/netsim/' + this.id,
    type: 'delete',
    contentType: 'application/json; charset=utf-8',
    dataType: "json"
  }).done(function () {
    onComplete(null, true);
  }).fail(function (request, status, error) {
    var err = new Error('status: ' + status + '; error: ' + error);
    onComplete(err, false);
  });
};

/**
 * Called when the PubSub service fires an event that applies to all tables
 * @private
 */
NetSimShard.prototype.onPubSubEvent_ = function () {
  // Right now, the only all_tables event is the shard reset.
  // Refreshing the node table informs our node that a reset has occurred.
  // TODO: Use a "disconnect from shard" callback instead here.
  this.nodeTable.refresh();
};

},{"./NetSimTable":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTable.js","./PubSubService":"/home/trevor/code-dot-org/apps/build/js/netsim/PubSubService.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/PubSubService.js":[function(require,module,exports){
/**
 * @overview Wrapped pub/sub service client APIs (like Pusher)
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
/* global Pusher */
'use strict';

var PubSubChannel = require('./PubSubChannel');

/**
 * JavaScript interface for a publish/subscribe service provider.
 * @param {string} applicationKey
 * @interface
 */
var PubSubService = exports;

/**
 * @typedef {Object} PubSubConfig
 * @property {boolean} usePusher - Whether to use Pusher's API, or a null
 *           implementation.
 * @property {string} pusherApplicationKey - If using Pusher, the public key
 *           required to initialize the Pusher API.
 */

/**
 * Create an API instance appropriate to the current configuration.
 * @param {!PubSubConfig} pubSubConfig
 * @returns {PubSubService}
 */
PubSubService.create = function (pubSubConfig) {
  if (pubSubConfig.usePusher) {
    return new PubSubService.PusherService(pubSubConfig.pusherApplicationKey);
  }

  return new PubSubService.NullService();
};

/**
 * @function
 * @name PubSubService#subscribe
 * @param {string} channelID - Channel to which we subscribe.
 * @returns {PubSubChannel}
 */

/**
 * @function
 * @name PubSubService#unsubscribe
 * @param {string} channelID - Channel from which we unsubscribe.
 */

/**
 * Stub implementation of PubSub API.
 * @constructor
 * @implements PubSubService
 */
// Disable "unused variable" errors for null implementation declarations
/* jshint unused:false */
PubSubService.NullService = function () {};

/**
 * Subscribe to events on a particular channel.
 * @param {string} channelID
 * @returns {PubSubChannel}
 */
PubSubService.NullService.prototype.subscribe = function (channelID) {
  return new PubSubChannel.NullChannel();
};

/**
 * Unsubscribe from events on a particular channel.
 * @param {string} channelID
 */
PubSubService.NullService.prototype.unsubscribe = function (channelID) {};

// Re-enable "unused variable" error
/* jshint unused:true */

/**
 * Wrapped Pusher.com API.
 * @param {string} applicationKey
 * @constructor
 * @implements PubSubService
 */
PubSubService.PusherService = function (applicationKey) {
  /**
   * Instance of actual Pusher JavaScript API.
   * @type {Pusher}
   * @private
   */
  this.api_ = new Pusher(applicationKey, { encrypted: true });
};

/**
 * Subscribe to events on a particular channel.
 * @param {string} channelID
 * @returns {PubSubChannel}
 */
PubSubService.PusherService.prototype.subscribe = function (channelID) {
  return new PubSubChannel.PusherChannel(this.api_.subscribe(channelID));
};

/**
 * Unsubscribe from events on a particular channel.
 * @param {string} channelID
 */
PubSubService.PusherService.prototype.unsubscribe = function (channelID) {
  this.api_.unsubscribe(channelID);
};

},{"./PubSubChannel":"/home/trevor/code-dot-org/apps/build/js/netsim/PubSubChannel.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/PubSubChannel.js":[function(require,module,exports){
/**
 * @overview Wrapped pub/sub service channel APIs (like Pusher's Channel)
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

/**
 * Javascript interface for a publish/subscribe channel.
 * @interface
 */
var PubSubChannel = exports;

/**
 * Subscribe to an event, so that the given callback is called when the
 * event occurs.
 * @function
 * @name PubSubChannel#subscribe
 * @param {string} eventName - The name of the event to bind to.
 * @param {function} callback - A function to be called whenever the event is
 *        triggered.
 */

// Disable "unused variable" errors for null implementation declarations
/* jshint unused:false */

/**
 * @constructor
 * @implements PubSubChannel
 */
PubSubChannel.NullChannel = function () {};

/**
 * Subscribe to an event so the given callback is called when the event occurs.
 * @param {string} eventName - The name of the event to bind to.
 * @param {function} callback - A function to be called whenever the event is
 *        triggered.
 */
PubSubChannel.NullChannel.prototype.subscribe = function (eventName, callback) {};

/**
 * Unsubscribe a given callback from a given event
 * @param {string} eventName
 */
PubSubChannel.NullChannel.prototype.unsubscribe = function (eventName) {};

// Re-enable "unused variable" error
/* jshint unused:true */

/**
 * @constructor
 * @implements PubSubChannel
 */
PubSubChannel.PusherChannel = function (pusherApiChannel) {
  /**
   * The actual Pusher API's channel.
   * @private {Channel}
   */
  this.pusherChannel_ = pusherApiChannel;

  /**
   * Cache provided callbacks for easy unsubscribe.
   * Maps event name to callback.
   * @type {Object}
   * @private
   */
  this.callbacks_ = {};
};

/**
 * Subscribe to an event so the given callback is called when the event occurs.
 * @param {string} eventName
 * @param {function()} callback
 * @throws {Error} on double-subscribe.
 */
PubSubChannel.PusherChannel.prototype.subscribe = function (eventName, callback) {
  this.pusherChannel_.bind(eventName, callback);
  if (this.callbacks_[eventName] !== undefined) {
    throw new Error("Already subscribed to event " + eventName);
  }
  this.callbacks_[eventName] = callback;
};

/**
 * Unsubscribe a given callback from a given event
 * @param {string} eventName
 */
PubSubChannel.PusherChannel.prototype.unsubscribe = function (eventName) {
  this.pusherChannel_.unbind(eventName, this.callbacks_[eventName]);
  delete this.callbacks_[eventName];
};

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimTable.js":[function(require,module,exports){
/**
 * @overview Wraps remote storage interface and polling behavior.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 4,
 maxstatements: 200
 */
'use strict';

var _ = require('../utils').getLodash();
var ObservableEvent = require('../ObservableEvent');
var NetSimApi = require('./NetSimApi');
var NetSimGlobals = require('./NetSimGlobals');
var ArgumentUtils = require('./ArgumentUtils');

/**
 * Maximum time (in milliseconds) that tables should wait between full cache
 * updates from the server.
 * @type {number}
 */
var DEFAULT_POLLING_DELAY_MS = 10000;

/**
 * Minimum time (in ms) to wait after an invalidation event before attempting
 * to trigger a refresh request.  This produces a window in which clustered
 * invalidations can be captured and coalesced together.
 * @type {number}
 */
var DEFAULT_MINIMUM_DELAY_BEFORE_REFRESH_MS = 250;

/**
 * Maximum additional random delay (in ms) to add before the refresh request.
 * Helps spread out requests from different clients responding to the same
 * invalidation events.
 * @type {number}
 */
var DEFAULT_MAXIMUM_DELAY_JITTER_MS = 200;

/**
 * Minimum time (in ms) to wait between refresh requests, regardless of how
 * many invalidation events occur.
 * @type {number}
 */
var DEFAULT_MINIMUM_DELAY_BETWEEN_REFRESHES_MS = 2500;

/**
 * Wraps the app storage table API in an object with local
 * caching and callbacks, which provides a notification API to the rest
 * of the NetSim code.
 * @param {!PubSubChannel} channel - The pubsub channel used to listen
 *        for changes to the table.cellPadding
 * @param {!string} shardID - The shard ID specific to this class' NetSim instance.
 * @param {!string} tableName - The name of the remote storage table to wrap.
 * @param {Object} [options] - Additional table configuration options
 * @param {boolean} [options.useIncrementalRefresh] - defaults to FALSE.  If
 *        TRUE, this table will only request content that is new since its
 *        last refresh, not the entire table contents.  Currently this option
 *        is not safe to use if you care about updates or deletes in the table.
 * @param {number} [options.minimumDelayBeforeRefresh] - Minimum time (in ms)
 *        to wait after an invalidation event before attempting to trigger a
 *        refresh request.  This produces a window in which clustered
 *        invalidations can be captured and coalesced together.
 * @param {number} [options.maximumJitterDelay] - Maximum additional random
 *        delay (in ms) to add before the refresh request.  Helps spread out
 *        requests from different clients responding to the same invalidation
 *        events.
 * @param {number} [options.minimumDelayBetweenRefreshes] - Minimum time (in ms)
 *        to wait between refresh requests, regardless of how many invalidation
 *        events occur.
 * @constructor
 * @throws {Error} if wrong number of arguments are provided.
 * @throws {TypeError} if invalid types are passed in the options object.
 */
var NetSimTable = module.exports = function (channel, shardID, tableName, options) {
  ArgumentUtils.validateRequired(channel, 'channel');
  ArgumentUtils.validateRequired(shardID, 'shardID', ArgumentUtils.isString);
  ArgumentUtils.validateRequired(tableName, 'tableName', ArgumentUtils.isString);
  options = ArgumentUtils.extendOptionsObject(options);

  /**
   * @private {string}
   */
  this.tableName_ = tableName;

  /**
   * @private {PubSubChannel}
   */
  this.channel_ = channel;
  this.subscribe();

  /**
   * API object for making remote calls
   * @type {NetSimApi}
   * @private
   */
  this.api_ = NetSimApi.makeTableApi(shardID, tableName);

  /**
   * Event that fires when full table updates indicate a change,
   * when rows are added, or when rows are removed, or when rows change.
   * @type {ObservableEvent}
   */
  this.tableChange = new ObservableEvent();

  /**
   * Store table contents locally, so we can detect when changes occur.
   * @private {Object}
   */
  this.cache_ = {};

  /**
   * The row ID of the most recently inserted row retrieved from remote storage.
   * @type {number}
   * @private
   */
  this.latestRowID_ = 0;

  /**
   * Unix timestamp for last time this table's cache contents were fully
   * updated.  Used to determine when to poll the server for changes.
   * @private {number}
   */
  this.lastRefreshTime_ = 0;

  /**
   * If TRUE, will only request deltas from remote storage.  Currently
   * unsafe if we care about more than inserts to the table.
   * @type {boolean}
   * @private
   */
  this.useIncrementalRefresh_ = options.get('useIncrementalRefresh', ArgumentUtils.isBoolean, false);

  /**
   * Minimum time (in ms) to wait after an invalidation event before attempting
   * to trigger a refresh request.  This produces a window in which clustered
   * invalidations can be captured and coalesced together.
   * @private {number}
   */
  this.minimumDelayBeforeRefresh_ = options.get('minimumDelayBeforeRefresh', ArgumentUtils.isPositiveNoninfiniteNumber, DEFAULT_MINIMUM_DELAY_BEFORE_REFRESH_MS);

  /**
   * Maximum additional random delay (in ms) to add before the refresh request.
   * Helps spread out requests from different clients responding to the same
   * invalidation events.
   * @private {number}
   */
  this.maximumJitterDelay_ = options.get('maximumJitterDelay', ArgumentUtils.isPositiveNoninfiniteNumber, DEFAULT_MAXIMUM_DELAY_JITTER_MS);

  /**
   * Minimum time (in ms) to wait between refresh requests, regardless of how
   * many invalidation events occur.
   * @private {number}
   */
  this.minimumDelayBetweenRefreshes_ = options.get('minimumDelayBetweenRefreshes', ArgumentUtils.isPositiveNoninfiniteNumber, DEFAULT_MINIMUM_DELAY_BETWEEN_REFRESHES_MS);

  /**
   * Minimum time (in milliseconds) to wait between pulling full table contents
   * from remote storage.
   * @private {number}
   */
  this.pollingInterval_ = DEFAULT_POLLING_DELAY_MS;

  /**
   * Throttled version (specific to this instance) of the refresh operation,
   * used to coalesce refresh requests.
   * @private {function}
   */
  this.refreshTable_ = this.makeThrottledRefresh_();
};

/**
 * @returns {string} the configured table name.
 */
NetSimTable.prototype.getTableName = function () {
  return this.tableName_;
};

/**
 * Subscribes this table's onPubSubEvent method to events for this table
 * on our local channel.
 */
NetSimTable.prototype.subscribe = function () {
  this.channel_.subscribe(this.tableName_, NetSimTable.prototype.onPubSubEvent_.bind(this));
};

/**
 * Unubscribes the saved callback from events for this table on our
 * local channel.
 */
NetSimTable.prototype.unsubscribe = function () {
  this.channel_.unsubscribe(this.tableName_);
};

/**
 * Asynchronously retrieve new/updated table content from the server, using
 * whatever method is most appropriate to this table's configuration.
 * When done, updates the local cache and hits the provided callback to
 * indicate completion.
 * @param {NodeStyleCallback} [callback] - indicates completion of the operation.
 * @returns {jQuery.Promise} Guaranteed to resolve after the cache update,
 *          so .done() operations can interact with the cache.
 */
NetSimTable.prototype.refresh = function (callback) {
  callback = callback || function () {};
  var deferred = $.Deferred();

  // Which API call to make
  var apiCall = this.useIncrementalRefresh_ ? this.api_.allRowsFromID.bind(this.api_, this.latestRowID_ + 1) : this.api_.allRows.bind(this.api_);

  // How to update the cache (depends on what we expect to get back)
  var cacheUpdate = this.useIncrementalRefresh_ ? this.incrementalCacheUpdate_.bind(this) : this.fullCacheUpdate_.bind(this);

  // What should happen when the API call completes.
  var apiCallCallback = function apiCallCallback(err, data) {
    if (err) {
      callback(err, data);
      deferred.reject(err);
    } else {
      cacheUpdate(data);
      callback(err, data);
      deferred.resolve();
    }
  };

  // Do we fire the API call now, or after a random delay?
  if (this.maximumJitterDelay_ === 0) {
    apiCall(apiCallCallback);
  } else {
    var jitterTime = NetSimGlobals.randomIntInRange(0, this.maximumJitterDelay_);
    setTimeout(apiCall.bind(this, apiCallCallback), jitterTime);
  }

  return deferred.promise();
};

/**
 * Generate throttled refresh function which will generate actual server
 * requests at the maximum given rate no matter how fast it is called. This
 * allows us to coalesce refreshAll events and reduce server load.
 *
 * How this works:
 * Wraps a longer throttle with leading and trailing events in a shorter debounce
 * with a maximum wait time.  This gives grouped events a chance to coalesce
 * without triggering an unneeded trailing event on the longer throttle.
 *
 * Here are some examples of what's going on, if using a 1000ms throttle
 * wrapped in a 250ms debounce.
 *
 * In low traffic we collapse two groups of events to just two events.
 *
 * original events   :   || |                     | |
 * debounced         :   -250>|                   -250>|
 * then throttled    :        |--------------1000->    |--------------1000->
 *
 * In higher traffic we collapse the groups but still keep events at least
 * one second apart.
 *
 * original events   :   || |        |     |      | |
 * debounced         :   -250>|      -250>|-250>| -250>|
 * then throttled    :        |--------------1000->|--------------1000->|
 *
 * @returns {function()}
 * @private
 */
NetSimTable.prototype.makeThrottledRefresh_ = function () {
  var throttledRefresh = _.throttle(this.refresh.bind(this), this.minimumDelayBetweenRefreshes_);
  return _.debounce(throttledRefresh, this.minimumDelayBeforeRefresh_, { maxWait: this.minimumDelayBeforeRefresh_ });
};

/**
 * @returns {Array} all locally cached table rows
 */
NetSimTable.prototype.readAll = function () {
  return this.arrayFromCache_();
};

/**
 * @param {!number} firstRowID
 * @returns {Array} all locally cached table rows having row ID >= firstRowID
 */
NetSimTable.prototype.readAllFromID = function (firstRowID) {
  return this.arrayFromCache_(function (key) {
    return key >= firstRowID;
  });
};

/**
 * @param {!number} id
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype.read = function (id, callback) {
  this.api_.fetchRow(id, (function (err, data) {
    if (err === null) {
      this.updateCacheRow_(id, data);
    }
    callback(err, data);
  }).bind(this));
};

/**
 * @param {Object} value
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype.create = function (value, callback) {
  this.api_.createRow(value, (function (err, data) {
    if (err === null) {
      this.addRowToCache_(data);
    }
    callback(err, data);
  }).bind(this));
};

/**
 * @param {Object[]} values
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype.multiCreate = function (values, callback) {
  this.api_.createRow(values, (function (err, datas) {
    if (err === null) {
      datas.forEach(function (data) {
        this.addRowToCache_(data);
      }, this);
    }
    callback(err, datas);
  }).bind(this));
};

/**
 * @param {!number} id
 * @param {Object} value
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype.update = function (id, value, callback) {
  this.api_.updateRow(id, value, (function (err, success) {
    if (err === null) {
      this.updateCacheRow_(id, value);
    }
    callback(err, success);
  }).bind(this));
};

/**
 * @param {!number} id
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype['delete'] = function (id, callback) {
  this.deleteMany([id], callback);
};

/**
 * Deletes multiple rows from the table.
 * @param {!number[]} ids
 * @param {!NodeStyleCallback} callback
 */
NetSimTable.prototype.deleteMany = function (ids, callback) {
  this.api_.deleteRows(ids, (function (err, success) {
    if (err === null) {
      this.removeRowsFromCache_(ids);
    }
    callback(err, success);
  }).bind(this));
};

/**
 * Delete a row using a synchronous call. For use when navigating away from
 * the page; most of the time an asynchronous call is preferred.
 * @param {!number} id
 */
NetSimTable.prototype.synchronousDelete = function (id) {
  var async = false; // Force synchronous request
  this.api_.deleteRows([id], (function (err) {
    if (err) {
      // Nothing we can really do with the error, as we're in the process of
      // navigating away. Throw so that high incidence rates will show up in
      // new relic.
      throw err;
    }
    this.removeRowsFromCache_([id]);
  }).bind(this), async);
};

/**
 * @param {Array} allRows
 * @private
 */
NetSimTable.prototype.fullCacheUpdate_ = function (allRows) {
  // Rebuild entire cache
  var maxRowID = 0;
  var newCache = allRows.reduce(function (prev, currentRow) {
    prev[currentRow.id] = currentRow;
    if (currentRow.id > maxRowID) {
      maxRowID = currentRow.id;
    }
    return prev;
  }, {});

  // Check for changes, if anything changed notify all observers on table.
  if (!_.isEqual(this.cache_, newCache)) {
    this.cache_ = newCache;
    this.latestRowID_ = maxRowID;
    this.tableChange.notifyObservers();
  }

  this.lastRefreshTime_ = Date.now();
};

/**
 * Add and update rows in the local cache from the given set of new rows
 * (probably retrieved from the server).
 * @param {Array} newRows
 * @private
 */
NetSimTable.prototype.incrementalCacheUpdate_ = function (newRows) {
  if (newRows.length > 0) {
    var maxRowID = 0;
    newRows.forEach(function (row) {
      this.cache_[row.id] = row;
      maxRowID = Math.max(maxRowID, row.id);
    }, this);
    this.latestRowID_ = maxRowID;
    this.tableChange.notifyObservers();
  }

  this.lastRefreshTime_ = Date.now();
};

/**
 * @param {!Object} row
 * @param {!number} row.id
 * @private
 */
NetSimTable.prototype.addRowToCache_ = function (row) {
  this.cache_[row.id] = row;
  this.tableChange.notifyObservers();
};

/**
 * @param {!number[]} ids
 * @private
 */
NetSimTable.prototype.removeRowsFromCache_ = function (ids) {
  var cacheChanged = false;
  ids.forEach(function (id) {
    if (this.cache_[id] !== undefined) {
      delete this.cache_[id];
      cacheChanged = true;
    }
  }, this);

  if (cacheChanged) {
    this.tableChange.notifyObservers();
  }
};

/**
 * @param {!number} id
 * @param {!Object} row
 * @private
 */
NetSimTable.prototype.updateCacheRow_ = function (id, row) {
  var oldRow = this.cache_[id];
  var newRow = row;

  // Manually apply IDs which should be present in row.
  newRow.id = id;
  newRow.uuid = oldRow.uuid;

  if (!_.isEqual(oldRow, newRow)) {
    this.cache_[id] = newRow;
    this.tableChange.notifyObservers();
  }
};

/**
 * @param {function(key, value)} [predicate] - A condition on returning the row.
 * @returns {Array}
 * @private
 */
NetSimTable.prototype.arrayFromCache_ = function (predicate) {
  predicate = predicate || function () {
    return true;
  };
  var result = [];
  for (var k in this.cache_) {
    if (this.cache_.hasOwnProperty(k) && predicate(k, this.cache_[k])) {
      result.push(this.cache_[k]);
    }
  }
  return result;
};

/**
 * Changes how often this table fetches a full table update from the
 * server.
 * @param {number} intervalMs - milliseconds of delay between updates.
 */
NetSimTable.prototype.setPollingInterval = function (intervalMs) {
  this.pollingInterval_ = intervalMs;
};

/**
 * Change the maximum rate at which the refresh operation for this table
 * will _actually_ be executed, no matter how fast we receive invalidations.
 * @param {number} delayMs - Minimum number of milliseconds
 *        between invalidation-triggered requests to the server.
 */
NetSimTable.prototype.setMinimumDelayBetweenRefreshes = function (delayMs) {
  // To do this, we just replace the throttled refresh function with a new one.
  this.minimumDelayBetweenRefreshes_ = delayMs;
  this.refreshTable_ = this.makeThrottledRefresh_();
};

/**
 * Change the minimum time (in ms) to wait after an invalidation event before
 * attempting to trigger a refresh request.  This produces a window in which
 * clustered invalidations can be captured and coalesced together.
 * @param {number} delayMs - Minimum number of milliseconds between first
 *        invalidation and request to server.
 */
NetSimTable.prototype.setMinimumDelayBeforeRefresh = function (delayMs) {
  // To do this, we just replace the throttled refresh function with a new one.
  this.minimumDelayBeforeRefresh_ = delayMs;
  this.refreshTable_ = this.makeThrottledRefresh_();
};

/**
 * Change the Maximum additional random delay (in ms) to add before the refresh
 * request.  Helps spread out requests from different clients responding to the
 * same events.
 * @param {number} delayMs - Maximum number of milliseconds to add before
 *        refresh request fires.
 */
NetSimTable.prototype.setMaximumJitterDelay = function (delayMs) {
  // To do this, we just replace the throttled refresh function with a new one.
  this.maximumJitterDelay_ = delayMs;
};

/** Polls server for updates, if it's been long enough. */
NetSimTable.prototype.tick = function () {
  var now = Date.now();
  if (now - this.lastRefreshTime_ >= this.pollingInterval_) {
    this.lastRefreshTime_ = now;
    this.refreshTable_();
  }
};

/**
 * Called when the PubSub service fires an event that this table is subscribed to.
 * @private
 */
NetSimTable.prototype.onPubSubEvent_ = function () {
  this.refreshTable_();
};

},{"../ObservableEvent":"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./ArgumentUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/ArgumentUtils.js","./NetSimApi":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimApi.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSendPanel.js":[function(require,module,exports){
/**
 * @overview UI controller for the send panel (the bottom panel on the right)
 *           which is used to transmit packets.
 * @see NetSimPacketEditor which is used extensively here.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var i18n = require('./locale');
var markup = require('./NetSimSendPanel.html.ejs');
var NetSimPanel = require('./NetSimPanel');
var NetSimPacketEditor = require('./NetSimPacketEditor');
var NetSimPacketSizeControl = require('./NetSimPacketSizeControl');
var Packet = require('./Packet');
var DataConverters = require('./DataConverters');
var NetSimConstants = require('./NetSimConstants');
var NetSimGlobals = require('./NetSimGlobals');

var EncodingType = NetSimConstants.EncodingType;
var MessageGranularity = NetSimConstants.MessageGranularity;
var BITS_PER_BYTE = NetSimConstants.BITS_PER_BYTE;

var binaryToAB = DataConverters.binaryToAB;

var logger = require('./NetSimLogger').getSingleton();

/**
 * Generator and controller for message sending view.
 * @param {jQuery} rootDiv
 * @param {NetSimLevelConfiguration} levelConfig
 * @param {NetSim} netsim
 * @constructor
 * @augments NetSimPanel
 */
var NetSimSendPanel = module.exports = function (rootDiv, levelConfig, netsim) {

  /**
   * @type {NetSimLevelConfiguration}
   * @private
   */
  this.levelConfig_ = levelConfig;

  /**
   * @type {Packet.HeaderType[]}
   * @private
   */
  this.packetSpec_ = levelConfig.clientInitialPacketHeader;

  /**
   * Connection that owns the router we will represent / manipulate
   * @type {NetSim}
   * @private
   */
  this.netsim_ = netsim;

  /**
   * List of controllers for packets currently being edited.
   * @type {NetSimPacketEditor[]}
   * @private
   */
  this.packets_ = [];

  /**
   * Our local node's address, zero until assigned by a router.
   * @type {number}
   * @private
   */
  this.fromAddress_ = 0;

  /**
   * Maximum packet length configurable by slider.
   * @type {number}
   * @private
   */
  this.maxPacketSize_ = levelConfig.defaultPacketSizeLimit;

  /**
   * Byte-size used for formatting binary and for interpreting it
   * to decimal or ASCII.
   * @type {number}
   * @private
   */
  this.chunkSize_ = BITS_PER_BYTE;

  /**
   * Local device bitrate in bits-per-second, which affects send animation
   * speed.
   * @type {number}
   * @private
   */
  this.bitRate_ = Infinity;

  /**
   * What encodings are currently selected and displayed in each
   * packet and packet editor.
   * @type {EncodingType[]}
   * @private
   */
  this.enabledEncodings_ = levelConfig.defaultEnabledEncodings;

  /**
   * Reference to parent div of packet editor list, for adding and
   * removing packet editors.
   * @type {jQuery}
   * @private
   */
  this.packetsDiv_ = null;

  /**
   * @type {NetSimPacketSizeControl}
   * @private
   */
  this.packetSizeControl_ = null;

  /**
   * Flag for whether this panel is in "sending" mode, non-interactive while
   * it animates the send process for the current message.
   * @type {boolean}
   * @private
   */
  this.isPlayingSendAnimation_ = false;

  var panelTitle = levelConfig.messageGranularity === MessageGranularity.PACKETS ? i18n.sendAMessage() : i18n.sendBits();

  // TODO: Bad private member access
  this.netsim_.runLoop_.tick.register(this.tick.bind(this));

  NetSimPanel.call(this, rootDiv, {
    className: 'netsim-send-panel',
    panelTitle: panelTitle
  });
};
NetSimSendPanel.inherits(NetSimPanel);

/**
 * Puts send panel in a "sending packets" noninteractive state and begins
 * sending packets to remote.
 * @private
 */
NetSimSendPanel.prototype.beginSendingPackets_ = function () {
  if (0 === this.packets_.length) {
    return;
  }

  this.isPlayingSendAnimation_ = true;
  this.disableEverything();
  this.packets_[0].beginSending(this.netsim_.myNode);
};

/**
 * Callback for when an individual packet finishes its send animation.
 * Most of the time the packet gets removed and the next packet begins its
 * animation.
 * If it's the last packet, we finish sending and perform a packet editor
 * reset instead.
 * @param {NetSimPacketEditor} packet
 * @private
 */
NetSimSendPanel.prototype.doneSendingPacket_ = function (packet) {
  // If it's the last packet, we're done sending altogether.
  if (1 === this.packets_.length) {
    this.resetPackets_();
    this.enableEverything();
    this.packets_[0].getFirstVisibleMessageBox().focus();
    this.isPlayingSendAnimation_ = false;
    return;
  }

  // Remove the completed packet and start sending the next one.
  this.removePacket_(packet);
  this.packets_[0].beginSending(this.netsim_.myNode);
};

/**
 * Send panel uses its tick to "send" packets at different bitrates, animating
 * the binary draining out of the widget and actually posting each packet
 * to storage as it completes.
 * @param {RunLoop.Clock} clock
 */
NetSimSendPanel.prototype.tick = function (clock) {
  if (this.isPlayingSendAnimation_ && this.packets_.length > 0) {
    this.packets_[0].tick(clock);
  }
};

/** Replace contents of our root element with our own markup. */
NetSimSendPanel.prototype.render = function () {
  // Render boilerplate panel stuff
  NetSimSendPanel.superPrototype.render.call(this);

  // Put our own content into the panel body
  var newMarkup = $(markup({
    level: this.levelConfig_
  }));
  this.getBody().html(newMarkup);

  // Add packet size slider control
  if (this.levelConfig_.showPacketSizeControl) {
    var level = NetSimGlobals.getLevelConfig();
    var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, this.packetSpec_);
    this.packetSizeControl_ = new NetSimPacketSizeControl(this.rootDiv_.find('.packet-size'), this.packetSizeChangeCallback_.bind(this), {
      minimumPacketSize: encoder.getHeaderLength(),
      sliderStepValue: 1
    });
    this.packetSizeControl_.setValue(this.maxPacketSize_);
  }

  // Bind useful elements and add handlers
  this.packetsDiv_ = this.getBody().find('.send-panel-packets');
  this.getBody().find('#add-packet-button').click(this.onAddPacketButtonPress_.bind(this));
  // TODO: NetSim buttons in this panel need to do nothing if disabled!
  this.getBody().find('#send-button').click(this.onSendEventTriggered_.bind(this));
  this.getBody().find('#set-wire-button').click(this.onSendEventTriggered_.bind(this));

  // Note: At some point, we might want to replace this with something
  // that nicely re-renders the contents of this.packets_... for now,
  // we only call render for set-up, so it's okay.
  this.resetPackets_();
};

/**
 * Add a new, blank packet to the set of packets being edited.
 * @private
 */
NetSimSendPanel.prototype.addPacket_ = function () {
  var newPacketCount = this.packets_.length + 1;

  // Update the total packet count on all existing packets
  this.packets_.forEach(function (packetEditor) {
    packetEditor.setPacketCount(newPacketCount);
  });

  // Copy the to address of the previous packet if it exists. Otherwise
  // use the last address sent.
  // TODO: Do we need to lock the toAddress for all of these packets together?
  var newPacketToAddress;
  if (this.packets_.length > 0) {
    newPacketToAddress = this.packets_[this.packets_.length - 1].toAddress;
  } else {
    newPacketToAddress = '0';
  }

  // Create a new packet
  var newPacket = new NetSimPacketEditor({
    messageGranularity: this.levelConfig_.messageGranularity,
    packetSpec: this.packetSpec_,
    toAddress: newPacketToAddress,
    fromAddress: this.fromAddress_,
    packetIndex: newPacketCount,
    packetCount: newPacketCount,
    maxPacketSize: this.maxPacketSize_,
    chunkSize: this.chunkSize_,
    bitRate: this.bitRate_,
    enabledEncodings: this.enabledEncodings_,
    removePacketCallback: this.removePacket_.bind(this),
    doneSendingCallback: this.doneSendingPacket_.bind(this),
    contentChangeCallback: this.onContentChange_.bind(this),
    enterKeyPressedCallback: this.onSendEventTriggered_.bind(this)
  });

  // Attach the new packet to this SendPanel
  var updateLayout = this.netsim_.updateLayout.bind(this.netsim_);
  newPacket.getRoot().appendTo(this.packetsDiv_);
  newPacket.getRoot().hide().slideDown('fast', function () {
    newPacket.getFirstVisibleMessageBox().focus();
    updateLayout();
  });
  this.packets_.push(newPacket);
};

/**
 * Remove a packet from the send panel, and adjust other packets for
 * consistency.
 * @param {NetSimPacketEditor} packet
 * @private
 */
NetSimSendPanel.prototype.removePacket_ = function (packet) {
  // Remove from DOM
  var updateLayout = this.netsim_.updateLayout.bind(this.netsim_);
  packet.getRoot().slideUp('fast', function () {
    $(this).remove();
    updateLayout();
  });

  // Remove from internal collection
  this.packets_ = this.packets_.filter(function (packetEditor) {
    return packetEditor !== packet;
  });

  // Adjust numbering of remaining packets if we're not mid-send
  if (!this.isPlayingSendAnimation_) {
    var packetCount = this.packets_.length;
    var packetIndex;
    for (var i = 0; i < packetCount; i++) {
      packetIndex = i + 1;
      this.packets_[i].setPacketIndex(packetIndex);
      this.packets_[i].setPacketCount(packetCount);
    }
  }
};

/**
 * Reset the editor to its 'empty' state: Remove all but the first packet,
 * and reset the first packet to empty.
 * @private
 */
NetSimSendPanel.prototype.resetPackets_ = function () {
  if (this.packets_.length > 0) {
    this.packetsDiv_.children().slice(1).remove();
    this.packets_.length = Math.min(1, this.packets_.length);
    this.packets_[0].resetPacket();
  } else {
    this.addPacket_();
  }
};

/**
 * When any packet editor's binary content changes, we may want
 * to update UI wrapper elements (like the "set next bit" button)
 * in response
 * @private
 */
NetSimSendPanel.prototype.onContentChange_ = function () {
  var nextBit = this.getNextBit_();

  if (nextBit === undefined) {
    // If there are no bits queued up, disable the button
    this.getSetWireButton().text(i18n.setWire());
    this.conditionallyToggleSetWireButton();
  } else {
    // Special case: If we have the "A/B" encoding enabled but _not_ "Binary",
    // format this button label using the "A/B" convention
    if (this.isEncodingEnabled_(EncodingType.A_AND_B) && !this.isEncodingEnabled_(EncodingType.BINARY)) {
      nextBit = binaryToAB(nextBit);
    }

    this.getSetWireButton().text(i18n.setWireToValue({ value: nextBit }));
    this.conditionallyToggleSetWireButton();
  }
};

/**
 * Check whether the given encoding is currently displayed by the panel.
 * @param {EncodingType} queryEncoding
 * @returns {boolean}
 * @private
 */
NetSimSendPanel.prototype.isEncodingEnabled_ = function (queryEncoding) {
  return this.enabledEncodings_.some(function (enabledEncoding) {
    return enabledEncoding === queryEncoding;
  });
};

/**
 * Update from address for the panel, update all the packets to reflect this.
 * @param {number} [fromAddress] default zero
 */
NetSimSendPanel.prototype.setFromAddress = function (fromAddress) {
  // fromAddress can be undefined for other parts of the sim, but within
  // the send panel we just set it to zero.
  this.fromAddress_ = utils.valueOr(fromAddress, 0);

  this.packets_.forEach((function (packetEditor) {
    packetEditor.setFromAddress(this.fromAddress_);
  }).bind(this));
};

/**
 * @param {Event} jQueryEvent
 * @private
 */
NetSimSendPanel.prototype.onAddPacketButtonPress_ = function (jQueryEvent) {
  var thisButton = $(jQueryEvent.target);
  if (thisButton.is('[disabled]')) {
    return;
  }

  this.addPacket_();

  // Scroll to end of packet area
  var scrollingArea = this.getBody().find('.send-panel-packets');
  scrollingArea.animate({ scrollTop: scrollingArea[0].scrollHeight }, 'fast');
};

/**
 * Send message to connected remote
 * @param {Event} jQueryEvent
 * @private
 */
NetSimSendPanel.prototype.onSendEventTriggered_ = function (jQueryEvent) {
  var triggeringTarget = $(jQueryEvent.target);
  if (triggeringTarget.is('[disabled]')) {
    return;
  }

  var level = NetSimGlobals.getLevelConfig();
  if (level.messageGranularity === MessageGranularity.PACKETS) {
    this.beginSendingPackets_();
  } else if (level.messageGranularity === MessageGranularity.BITS) {
    this.sendOneBit_();
  }
};

/**
 * Send a single bit, manually 'setting the wire state'.
 * @private
 */
NetSimSendPanel.prototype.sendOneBit_ = function () {
  var myNode = this.netsim_.myNode;
  if (!myNode) {
    throw new Error("Tried to set wire state when no connection is established.");
  }

  // Find the first bit of the first packet. Disallow setting the wire
  // if there is no first bit.
  var nextBit = this.getNextBit_();
  if (nextBit === undefined) {
    throw new Error("Tried to set wire state when no bit is queued.");
  } else {
    this.disableEverything();
    this.netsim_.animateSetWireState(nextBit);
    myNode.setSimplexWireState(nextBit, (function (err) {
      if (err) {
        logger.warn(err.message);
        return;
      }

      this.consumeFirstBit();
      this.enableEverything();
      this.conditionallyToggleSetWireButton();
    }).bind(this));
  }
};

/**
 * Get the next bit that would be sent, if sending the entered message one
 * bit at a time.
 * @returns {string|undefined} single bit as a "0" or "1" if there are
 * bits to be sent, or undefined otherwise
 * @private
 */
NetSimSendPanel.prototype.getNextBit_ = function () {
  return this.packets_.length > 0 ? this.packets_[0].getFirstBit() : undefined;
};

/** Disable all controls in this panel, usually during network activity. */
NetSimSendPanel.prototype.disableEverything = function () {
  this.getBody().find('input, textarea').prop('disabled', true);
  this.getBody().find('.netsim-button').attr('disabled', 'disabled');
  if (this.packetSizeControl_) {
    this.packetSizeControl_.disable();
  }
};

/**
 * Finds the button used to set the wire state
 * @returns {jQuery}
 */
NetSimSendPanel.prototype.getSetWireButton = function () {
  return this.getBody().find('#set-wire-button');
};

/** Enables the setWireButton if there is another bit in the queue,
 * disables it otherwise.
 * @returns {jQuery}
 */
NetSimSendPanel.prototype.conditionallyToggleSetWireButton = function () {
  var setWireButton = this.getSetWireButton();
  if (this.getNextBit_() === undefined) {
    setWireButton.attr('disabled', 'disabled');
  } else {
    setWireButton.removeAttr('disabled');
  }
  return setWireButton;
};

/** Enable all controls in this panel, usually after network activity. */
NetSimSendPanel.prototype.enableEverything = function () {
  this.getBody().find('input, textarea').prop('disabled', false);
  this.getBody().find('.netsim-button').removeAttr('disabled');
  if (this.packetSizeControl_) {
    this.packetSizeControl_.enable();
  }
};

/**
 * Remove the first bit of the first packet, usually because we just sent
 * a single bit in variant 1.
 */
NetSimSendPanel.prototype.consumeFirstBit = function () {
  if (this.packets_.length > 0) {
    this.packets_[0].consumeFirstBit();
    if (this.packets_[0].getPacketBinary() === '' && this.packets_.length > 1) {
      this.removePacket_(this.packets_[0]);
    }
  }
};

/**
 * Show or hide parts of the send UI based on the currently selected encoding
 * mode.
 * @param {EncodingType[]} newEncodings
 */
NetSimSendPanel.prototype.setEncodings = function (newEncodings) {
  this.enabledEncodings_ = newEncodings;
  this.packets_.forEach(function (packetEditor) {
    packetEditor.setEncodings(newEncodings);
  });
  this.onContentChange_();
};

/**
 * Change how data is interpreted and formatted by this component, triggering
 * an update of all input fields.
 * @param {number} newChunkSize
 */
NetSimSendPanel.prototype.setChunkSize = function (newChunkSize) {
  this.chunkSize_ = newChunkSize;
  this.packets_.forEach(function (packetEditor) {
    packetEditor.setChunkSize(newChunkSize);
  });
};

/**
 * Change the local device bitrate which affects send animation speed.
 * @param {number} newBitRate in bits per second
 */
NetSimSendPanel.prototype.setBitRate = function (newBitRate) {
  this.bitRate_ = newBitRate;
  this.packets_.forEach(function (packetEditor) {
    packetEditor.setBitRate(newBitRate);
  });
};

/**
 * Callback passed down into packet size control, called when packet size
 * is changed by the user.
 * @param {number} newPacketSize
 * @private
 */
NetSimSendPanel.prototype.packetSizeChangeCallback_ = function (newPacketSize) {
  this.maxPacketSize_ = newPacketSize;
  this.packets_.forEach(function (packetEditor) {
    packetEditor.setMaxPacketSize(newPacketSize);
  });
};

/**
 * After toggling panel visibility, trigger a layout update so send/log panel
 * space is shared correctly.
 * @private
 * @override
 */
NetSimSendPanel.prototype.onMinimizerClick_ = function () {
  NetSimSendPanel.superPrototype.onMinimizerClick_.call(this);
  this.netsim_.updateLayout();
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimPacketEditor":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketEditor.js","./NetSimPacketSizeControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketSizeControl.js","./NetSimPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./NetSimSendPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSendPanel.html.ejs","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSendPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var i18n = require('./locale');
  var MessageGranularity = require('./NetSimConstants').MessageGranularity;
; buf.push('\n<div class="send-panel-packets"></div>\n<div class="panel-footer">\n  <div class="right-side-controls">\n    ');8; if (level.showAddPacketButton) { ; buf.push('\n      <span class="netsim-button secondary large-button" id="add-packet-button">', escape((9,  i18n.addPacket() )), '</span>\n    ');10; } ; buf.push('\n    ');11; if (level.messageGranularity === MessageGranularity.PACKETS) { ; buf.push('\n      <span class="netsim-button large-button" id="send-button">', escape((12,  i18n.send() )), '</span>\n    ');13; } else if (level.messageGranularity === MessageGranularity.BITS) { ; buf.push('\n      <span class="netsim-button large-button" id="set-wire-button">', escape((14,  i18n.setWire() )), '</span>\n    ');15; } ; buf.push('\n  </div>\n  <div class="packet-size"></div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterTab.js":[function(require,module,exports){
/**
 * @overview UI controller for the "Router" tab in the left column.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimRouterTab.html.ejs');
var NetSimBandwidthControl = require('./NetSimBandwidthControl');
var NetSimMemoryControl = require('./NetSimMemoryControl');
var NetSimRouterStatsTable = require('./NetSimRouterStatsTable');
var NetSimGlobals = require('./NetSimGlobals');

/**
 * Generator and controller for router information view.
 * @param {jQuery} rootDiv - Parent element for this component.
 * @param {Object} callbacks
 * @param {function} callbacks.bandwidthSliderChangeCallback
 * @param {function} callbacks.bandwidthSliderStopCallback
 * @param {function} callbacks.memorySliderChangeCallback
 * @param {function} callbacks.memorySliderStopCallback
 * @constructor
 */
var NetSimRouterTab = module.exports = function (rootDiv, callbacks) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {function}
   * @private
   */
  this.bandwidthSliderChangeCallback_ = callbacks.bandwidthSliderChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.bandwidthSliderStopCallback_ = callbacks.bandwidthSliderStopCallback;

  /**
   * @type {function}
   * @private
   */
  this.memorySliderChangeCallback_ = callbacks.memorySliderChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.memorySliderStopCallback_ = callbacks.memorySliderStopCallback;

  /**
   * @type {NetSimRouterStatsTable}
   * @private
   */
  this.routerStatsTable_ = null;

  /**
   * @type {NetSimBandwidthControl}
   * @private
   */
  this.bandwidthControl_ = null;

  /**
   * @type {NetSimMemoryControl}
   * @private
   */
  this.memoryControl_ = null;

  // Initial render
  this.render();
};

/**
 * @param {RunLoop} runLoop
 */
NetSimRouterTab.prototype.attachToRunLoop = function (runLoop) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.attachToRunLoop(runLoop);
  }
};

/**
 * Fill the root div with new elements reflecting the current state.
 */
NetSimRouterTab.prototype.render = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  var renderedMarkup = $(markup({
    level: levelConfig
  }));
  this.rootDiv_.html(renderedMarkup);
  this.routerStatsTable_ = new NetSimRouterStatsTable(this.rootDiv_.find('.router-stats'));
  if (levelConfig.showRouterBandwidthControl) {
    this.bandwidthControl_ = new NetSimBandwidthControl(this.rootDiv_.find('.bandwidth-control'), this.bandwidthSliderChangeCallback_, this.bandwidthSliderStopCallback_);
  }
  if (levelConfig.showRouterMemoryControl) {
    this.memoryControl_ = new NetSimMemoryControl(this.rootDiv_.find('.memory-control'), this.memorySliderChangeCallback_, this.memorySliderStopCallback_);
  }
};

/**
 * @param {NetSimLogEntry[]} logData
 */
NetSimRouterTab.prototype.setRouterLogData = function (logData) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setRouterLogData(logData);
  }
};

/** @param {number} creationTimestampMs */
NetSimRouterTab.prototype.setRouterCreationTime = function (creationTimestampMs) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setRouterCreationTime(creationTimestampMs);
  }
};

/**
 * @param {number} newBandwidth in bits/second
 */
NetSimRouterTab.prototype.setBandwidth = function (newBandwidth) {
  if (this.bandwidthControl_) {
    this.bandwidthControl_.setValue(newBandwidth);
  }
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setBandwidth(newBandwidth);
  }
};

/** @param {number} newMemory in bits/second */
NetSimRouterTab.prototype.setMemory = function (newMemory) {
  if (this.memoryControl_) {
    this.memoryControl_.setValue(newMemory);
  }
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setTotalMemory(newMemory);
  }
};

/**
 * @param {number} queuedPacketCount
 */
NetSimRouterTab.prototype.setRouterQueuedPacketCount = function (queuedPacketCount) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setRouterQueuedPacketCount(queuedPacketCount);
  }
};

/** @param {number} usedMemoryInBits */
NetSimRouterTab.prototype.setMemoryInUse = function (usedMemoryInBits) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setMemoryInUse(usedMemoryInBits);
  }
};

/** @param {number} dataRateBitsPerSecond */
NetSimRouterTab.prototype.setDataRate = function (dataRateBitsPerSecond) {
  if (this.routerStatsTable_) {
    this.routerStatsTable_.setDataRate(dataRateBitsPerSecond);
  }
};

},{"./NetSimBandwidthControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBandwidthControl.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimMemoryControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMemoryControl.js","./NetSimRouterStatsTable":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterStatsTable.js","./NetSimRouterTab.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterTab.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterTab.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var i18n = require('./locale');
; buf.push('\n<div class="netsim-router-tab">\n  <h1>', escape((5,  i18n.routerTab_stats() )), '</h1>\n  <div class="router-stats"></div>\n  ');7; if (level.showRouterBandwidthControl) { ; buf.push('\n    <h1>', escape((8,  i18n.routerTab_bandwidth() )), '</h1>\n    <div class="bandwidth-control"></div>\n  ');10; } ; buf.push('\n  ');11; if (level.showRouterMemoryControl) { ; buf.push('\n    <h1>', escape((12,  i18n.routerTab_memory() )), '</h1>\n    <div class="memory-control"></div>\n  ');14; } ; buf.push('\n  <h1>', escape((15,  i18n.routerTab_logs() )), '</h1>\n  <span class="secondary netsim-button large-button" id="show-router-log-modal-two" data-toggle="modal" data-target="#router-log-modal">', escape((16,  i18n.logBrowserButton() )), '</span>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterStatsTable.js":[function(require,module,exports){
/**
 * @overview UI component displaying router stats on the "Router" tab.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimRouterStatsTable.html.ejs');
var NetSimUtils = require('./NetSimUtils');
var NetSimLogEntry = require('./NetSimLogEntry');

/**
 * Render every half-second, minimum.
 * @type {number}
 * @const
 */
var MAX_RENDER_DELAY_MS = 500;

/**
 * @type {number}
 * @const
 */
var MILLIS_PER_SECOND = 1000;

/**
 * @type {number}
 * @const
 */
var SECONDS_PER_MINUTE = 60;

/**
 * @type {number}
 * @const
 */
var MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;

/**
 * @type {number}
 * @const
 */
var MINUTES_PER_HOUR = 60;

/**
 * @type {number}
 * @const
 */
var MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;

/**
 * Generator and controller for DNS network lookup table component.
 * Shows different amounts of information depending on the DNS mode.
 *
 * @param {jQuery} rootDiv
 * @constructor
 */
var NetSimRouterStatsTable = module.exports = function (rootDiv) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * Last render time, in simulation-time.
   * @type {number}
   * @private
   */
  this.lastRenderTime_ = null;

  /**
   * Unix timestamp (local) of router creation time
   * @type {number}
   * @private
   */
  this.routerCreationTime_ = 0;

  /**
   * Total count of packets this router has received.
   * @type {number}
   * @private
   */
  this.totalPackets_ = 0;

  /**
   * Total count of packets this router has successfully processed.
   * @type {number}
   * @private
   */
  this.successfulPackets_ = 0;

  /**
   * Total size of all packets received by this router, in bits.
   * @type {number}
   * @private
   */
  this.totalData_ = 0;

  /**
   * Total size of all packets successfully processed by this router, in bits.
   * @type {number}
   * @private
   */
  this.successfulData_ = 0;

  /**
   * Maximum rate of data transfer (in bits per second)
   * @type {number}
   * @private
   */
  this.bandwidthLimit_ = 0;

  /**
   * Average rate of data transfer (in bits per second) over the last
   * DATA_RATE_WINDOW_MS milliseconds.
   * @type {number}
   * @private
   */
  this.dataRate_ = 0;

  /**
   * Router's total memory capacity, in bits.
   * @type {number}
   * @private
   */
  this.totalMemory_ = 0;

  /**
   * Number of packets in the router's queue.
   * @type {number}
   * @private
   */
  this.queuedPackets_ = 0;

  /**
   * Current size of the router's packet queue, in bits.
   * @type {number}
   * @private
   */
  this.usedMemory_ = 0;

  this.render({});
};

/**
 * @param {RunLoop} runLoop
 */
NetSimRouterStatsTable.prototype.attachToRunLoop = function (runLoop) {
  runLoop.render.register(this.render.bind(this));
};

/**
 * Fill the root div with new elements reflecting the current state
 * @param {RunLoop.Clock} clock
 */
NetSimRouterStatsTable.prototype.render = function (clock) {
  if (!this.needsRender(clock)) {
    return;
  }

  var renderedMarkup = $(markup({
    uptime: this.getLocalizedUptime(),
    queuedPackets: this.queuedPackets_,
    totalPackets: this.totalPackets_,
    successfulPackets: this.successfulPackets_,
    totalData: this.totalData_,
    successfulData: this.successfulData_,
    bandwidthLimit: this.bandwidthLimit_,
    dataRate: this.dataRate_,
    totalMemory: this.totalMemory_,
    usedMemory: this.usedMemory_
  }));
  this.rootDiv_.html(renderedMarkup);
  this.lastRenderTime_ = clock.time;
};

/**
 * @param {RunLoop.Clock} clock
 * @returns {boolean} whether a render operation is needed.
 */
NetSimRouterStatsTable.prototype.needsRender = function (clock) {
  return !this.lastRenderTime_ || clock.time - this.lastRenderTime_ > MAX_RENDER_DELAY_MS;
};

/**
 * Mark the router log data dirty, so that it will re-render on the
 * next frame.
 */
NetSimRouterStatsTable.prototype.setNeedsRender = function () {
  this.lastRenderTime_ = null;
};

/**
 * Get a duration string for the current router uptime.
 * @returns {string}
 */
NetSimRouterStatsTable.prototype.getLocalizedUptime = function () {
  var hoursUptime = 0;
  var minutesUptime = 0;
  var secondsUptime = 0;
  if (this.routerCreationTime_ > 0) {
    var millisecondsUptime = Date.now() - this.routerCreationTime_;
    hoursUptime = Math.floor(millisecondsUptime / MILLIS_PER_HOUR);
    millisecondsUptime -= hoursUptime * MILLIS_PER_HOUR;
    minutesUptime = Math.floor(millisecondsUptime / MILLIS_PER_MINUTE);
    millisecondsUptime -= minutesUptime * MILLIS_PER_MINUTE;
    secondsUptime = Math.floor(millisecondsUptime / MILLIS_PER_SECOND);
  }
  return hoursUptime.toString() + ':' + NetSimUtils.zeroPadLeft(minutesUptime, 2) + ':' + NetSimUtils.zeroPadLeft(secondsUptime, 2);
};

/**
 * @param {NetSimLogEntry[]} logEntries
 * @returns {number} total data size, in bits, of packets represented by the
 *          given log entries.
 */
var totalSizeOfPackets = function totalSizeOfPackets(logEntries) {
  return logEntries.reduce(function (prev, cur) {
    return prev + cur.binary.length;
  }, 0);
};

/**
 * @param {NetSimLogEntry[]} logData
 */
NetSimRouterStatsTable.prototype.setRouterLogData = function (logData) {
  var successLogs = logData.filter(function (logEntry) {
    return logEntry.status === NetSimLogEntry.LogStatus.SUCCESS;
  });

  this.totalPackets_ = logData.length;
  this.successfulPackets_ = successLogs.length;

  this.totalData_ = totalSizeOfPackets(logData);
  this.successfulData_ = totalSizeOfPackets(successLogs);

  this.setNeedsRender();
};

/** @param {number} creationTimestampMs */
NetSimRouterStatsTable.prototype.setRouterCreationTime = function (creationTimestampMs) {
  this.routerCreationTime_ = creationTimestampMs;
  this.setNeedsRender();
};

/** @param {number} newBandwidth in bits per second */
NetSimRouterStatsTable.prototype.setBandwidth = function (newBandwidth) {
  this.bandwidthLimit_ = newBandwidth;
  this.setNeedsRender();
};

/** @param {number} totalMemoryInBits */
NetSimRouterStatsTable.prototype.setTotalMemory = function (totalMemoryInBits) {
  this.totalMemory_ = totalMemoryInBits;
  this.setNeedsRender();
};

/**
 * @param {number} queuedPacketCount
 */
NetSimRouterStatsTable.prototype.setRouterQueuedPacketCount = function (queuedPacketCount) {
  this.queuedPackets_ = queuedPacketCount;
  this.setNeedsRender();
};

/** @param {number} usedMemoryInBits */
NetSimRouterStatsTable.prototype.setMemoryInUse = function (usedMemoryInBits) {
  this.usedMemory_ = usedMemoryInBits;
  this.setNeedsRender();
};

/** @param {number} dataRateBitsPerSecond */
NetSimRouterStatsTable.prototype.setDataRate = function (dataRateBitsPerSecond) {
  this.dataRate_ = dataRateBitsPerSecond;
  this.setNeedsRender();
};

},{"./NetSimLogEntry":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogEntry.js","./NetSimRouterStatsTable.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterStatsTable.html.ejs","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterStatsTable.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var utils = require('../utils');
  var NetSimUtils = require('./NetSimUtils');

  /**
   * Write a stats row with the given title and value.
   * @param {string} title - localized name of the statistic (the header column contents)
   * @param {*} statValue - the value of the statistic
   */
  var writeStatRow = function (title, statValue) {
    ; buf.push('\n      <tr>\n        <th nowrap>', escape((13,  title )), '</th>\n        <td>', escape((14,  statValue )), '</td>\n      </tr>\n    ');16;
  };

  /**
   * Write a stats row that displays a fraction and also its percentage form.
   * @param {string} title - localized name of the statistic (the header column contents)
   * @param {number} partValue - numerator of the stat
   * @param {number} totalValue - denominator of the stat
   * @param {function} [toStringFunction] method for converting numerator and denominator to display format
   */
  var fractionStatRow = function (title, partValue, totalValue, toStringFunction) {
    toStringFunction = utils.valueOr(toStringFunction, function (x) { return x; });
    var valueString = toStringFunction(partValue) + ' / ' + toStringFunction(totalValue);
    if (totalValue > 0 && totalValue < Infinity) {
      valueString += ' (' + Math.round(100 * partValue / totalValue) + '%)';
    }
    writeStatRow(title, valueString);
  };
; buf.push('\n<table>\n  <tbody>\n    ');37; writeStatRow('Uptime', uptime); ; buf.push('\n    ');38; writeStatRow('Queued Packets', queuedPackets); ; buf.push('\n    ');39; fractionStatRow('Memory Use', usedMemory, totalMemory, NetSimUtils.bitsToLocalizedRoundedBytesize); ; buf.push('\n    ');40; fractionStatRow('Throughput', dataRate, bandwidthLimit, NetSimUtils.bitrateToLocalizedRoundedBitrate); ; buf.push('\n    ');41; fractionStatRow('Routed Packets', successfulPackets, totalPackets); ; buf.push('\n    ');42; fractionStatRow('Routed Data', successfulData, totalData, NetSimUtils.bitsToLocalizedRoundedBytesize); ; buf.push('\n  </tbody>\n</table>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterLogModal.js":[function(require,module,exports){
/**
 * @overview a modal dialog showing the union of all router logs for the
 *           current shard.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var i18n = require('./locale');
var NetSimLogEntry = require('./NetSimLogEntry');
var Packet = require('./Packet');
var markup = require('./NetSimRouterLogModal.html.ejs');
var NetSimGlobals = require('./NetSimGlobals');

/** @const {string} */
var LOG_ENTRY_DATA_KEY = 'LogEntry';

/** @const {number} */
var MAXIMUM_ROWS_IN_FULL_RENDER = 500;

/**
 * Generator and controller for contents of modal dialog that reveals
 * all router logs together, in a searchable/sortable/filterable manner.
 *
 * @param {jQuery} rootDiv
 * @constructor
 */
var NetSimRouterLogModal = module.exports = function (rootDiv) {

  /**
   * Component root, which we fill whenever we call render()
   * @private {jQuery}
   */
  this.rootDiv_ = rootDiv;

  /**
   * Hidden by default.
   * @private {boolean}
   */
  this.isVisible_ = false;

  // Attach handlers for showing and hiding the modal
  this.rootDiv_.on('shown.bs.modal', this.onShow_.bind(this));
  this.rootDiv_.on('hidden.bs.modal', this.onHide_.bind(this));

  /**
   * @private {NetSimShard}
   */
  this.shard_ = null;

  /**
   * @private {NetSimRouterNode}
   */
  this.router_ = null;

  /**
   * @private {NetSimLogEntry}
   */
  this.logEntries_ = [];

  /**
   * The highest log row ID stored in logEntries_, used to only retrieve new
   * log rows, we don't need to retrieve everything.
   * @private {number}
   */
  this.latestRowID_ = 0;

  /**
   * Tracking information for which events we're registered to, so we can
   * perform cleanup as needed.
   * @private {Object}
   */
  this.eventKeys_ = {};

  /**
   * Sorting key, changed by user interaction, which determines which sort
   * we use on render.
   * @private {string}
   */
  this.sortBy_ = 'timestamp';

  /**
   * Whether currently using a descending sort.
   * @private {boolean}
   */
  this.sortDescending_ = true;

  /**
   * Whether we are currently in "All-Router" mode or dealing with a
   * single router.  Always initializes to true because we never initialize
   * connected to a single router.
   * @private {boolean}
   */
  this.isAllRouterLogMode_ = true;

  this.render();
};

/**
 * Create a comparator function that can be used to sort log entries, configured
 * to sort according to the log browser's current configuration.
 * @returns {function(NetSimLogEntry, NetSimLogEntry)} compares two log entries,
 *          returns -1 if the first one belongs before the second one, 1 if
 *          the first one belongs after the second one, and 0 if they have the
 *          same sort position.
 * @private
 */
NetSimRouterLogModal.prototype.getSortComparator_ = function () {
  var getSortValue = NetSimRouterLogModal.sortKeyToSortValueGetterMap[this.sortBy_];
  var invertMultiplier = this.sortDescending_ ? -1 : 1;
  return function (a, b) {
    var x = getSortValue(a);
    var y = getSortValue(b);
    return (x < y ? -1 : x > y ? 1 : 0) * invertMultiplier;
  };
};

NetSimRouterLogModal.sortKeyToSortValueGetterMap = {

  'timestamp': function timestamp(logEntry) {
    return logEntry.timestamp;
  },

  'logged-by': function loggedBy(logEntry) {
    var originNode = logEntry.getOriginNode();
    if (originNode) {
      return originNode.getDisplayName();
    }
    return logEntry.nodeID.toString(10);
  },

  'status': function status(logEntry) {
    return logEntry.getLocalizedStatus();
  },

  'from-address': function fromAddress(logEntry) {
    return logEntry.getHeaderField(Packet.HeaderType.FROM_ADDRESS);
  },

  'to-address': function toAddress(logEntry) {
    return logEntry.getHeaderField(Packet.HeaderType.TO_ADDRESS);
  },

  'packet-info': function packetInfo(logEntry) {
    return logEntry.getLocalizedPacketInfo();
  },

  'message': function message(logEntry) {
    return logEntry.getMessageAscii();
  }

};

/**
 * State changes that occur when shoing the log.
 * @private
 */
NetSimRouterLogModal.prototype.onShow_ = function () {
  if (this.shard_) {
    this.shard_.logTable.subscribe();
  }
  this.isVisible_ = true;
  this.render();
};

/**
 * State changes that occur when hiding the log.
 * @private
 */
NetSimRouterLogModal.prototype.onHide_ = function () {
  if (this.shard_) {
    this.shard_.logTable.unsubscribe();
  }
  this.isVisible_ = false;
};

/**
 * @returns {boolean} TRUE if the modal is currently showing.
 */
NetSimRouterLogModal.prototype.isVisible = function () {
  return this.isVisible_;
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimRouterLogModal.prototype.render = function () {
  // Be lazy, don't render if not visible.
  if (!this.isVisible()) {
    return;
  }

  // Re-render entire log browser UI
  var renderedMarkup = $(markup({
    isAllRouterLogMode: this.isAllRouterLogMode_,
    canToggleRouterLogMode: this.canToggleRouterLogMode_(),
    sortBy: this.sortBy_,
    sortDescending: this.sortDescending_
  }));
  this.rootDiv_.html(renderedMarkup);

  // Add input handlers
  this.getRouterLogToggleButton().one('click', (function () {
    this.toggleRouterLogMode_();
    this.render();
  }).bind(this));

  this.rootDiv_.find('th').click((function (event) {
    this.onSortHeaderClick_($(event.target).attr('data-sort-key'));
  }).bind(this));

  // Add rows to the table
  var rows = this.getSortedFilteredLogEntries(this.logEntries_).slice(0, MAXIMUM_ROWS_IN_FULL_RENDER).map(this.makeTableRow_.bind(this));
  this.rootDiv_.find('tbody').append(rows);

  if (rows.length === MAXIMUM_ROWS_IN_FULL_RENDER) {
    var maxRenderedWarning = document.createElement('div');
    maxRenderedWarning.className = 'log-browser-limit-message';
    maxRenderedWarning.textContent = i18n.showingFirstXLogEntries({
      x: MAXIMUM_ROWS_IN_FULL_RENDER
    });
    this.rootDiv_.find('table').after(maxRenderedWarning);
  }
};

/**
 * Convert the given set of log entries to table rows and insert them
 * into the DOM, instead of re-rendering the whole table.
 * @param {!NetSimLogEntry[]} newEntries
 * @private
 */
NetSimRouterLogModal.prototype.renderNewLogEntries_ = function (newEntries) {
  // Be lazy, don't render at all if not visible.
  if (!this.isVisible() || newEntries.length === 0) {
    return;
  }

  /** @type {jQuery} Table body element. */
  var tbody = this.rootDiv_.find('tbody');

  // Get existing table row elements, which are already sorted and filtered.
  var oldRows = tbody.find('tr');

  // Sort and filter the new entries, and generate DOM rows for them.
  newEntries = this.getSortedFilteredLogEntries(newEntries);
  var newRows = $(newEntries.map(this.makeTableRow_.bind(this)));

  // Walk both collections to merge new rows into the DOM
  var nextOld = getNextInfo(oldRows, 0);
  var nextNew = getNextInfo(newRows, 0);
  var comparator = this.getSortComparator_();
  while (nextNew.index < newRows.length && nextOld.index < oldRows.length) {
    if (comparator(nextNew.logEntry, nextOld.logEntry) <= 0) {
      nextNew.tableRow.insertBefore(nextOld.tableRow);
      nextNew = getNextInfo(newRows, nextNew.index + 1);
    } else {
      nextOld = getNextInfo(oldRows, nextOld.index + 1);
    }
  }

  // Put whatever's left on the end of the table
  tbody.append(newRows.slice(nextNew.index));
};

/**
 * Generates a helper object for performing the log row merge.
 * @param {jQuery} rows - Wrapped collection of table rows.
 * @param {!number} atIndex - Index into `rows` at which info should be generated.
 * @returns {{index: number, tableRow: jQuery, logEntry: NetSimLogEntry}}
 */
function getNextInfo(rows, atIndex) {
  var row = rows.eq(atIndex);
  return {
    index: atIndex,
    tableRow: row,
    logEntry: row.length > 0 ? row.data(LOG_ENTRY_DATA_KEY) : {}
  };
}

/**
 * @param {!NetSimLogEntry[]} logEntries
 * @returns {NetSimLogEntry[]} subset of logEntries, sorted and filtered
 *          according to the log browser's current settings.
 */
NetSimRouterLogModal.prototype.getSortedFilteredLogEntries = function (logEntries) {
  // Filter entries to current log browser filter mode
  var filteredLogEntries = this.isAllRouterLogMode_ ? logEntries : logEntries.filter(function (entry) {
    return entry.nodeID === this.router_.entityID;
  }, this);

  return filteredLogEntries.sort(this.getSortComparator_());
};

/**
 * Given a log entry, generate a table row that can be added to the log modal.
 * @param {!NetSimLogEntry} logEntry
 * @returns {Element} a tr element.
 * @private
 */
NetSimRouterLogModal.prototype.makeTableRow_ = function (logEntry) {
  var headerFields = NetSimGlobals.getLevelConfig().routerExpectsPacketHeader;

  var showToAddress = headerFields.indexOf(Packet.HeaderType.TO_ADDRESS) > -1;

  var showFromAddress = headerFields.indexOf(Packet.HeaderType.FROM_ADDRESS) > -1;

  var showPacketInfo = headerFields.indexOf(Packet.HeaderType.PACKET_INDEX) > -1 && headerFields.indexOf(Packet.HeaderType.PACKET_COUNT) > -1;

  var originNode = logEntry.getOriginNode();

  var row = document.createElement('tr');

  // Store the actual logEntry on the row for sorting/merging later.
  $(row).data(LOG_ENTRY_DATA_KEY, logEntry);

  row.appendChild(makeCell(logEntry.getTimeString()));

  row.appendChild(makeCell(originNode ? originNode.getDisplayName() : logEntry.nodeID));

  row.appendChild(makeCell(logEntry.getLocalizedStatus()));

  if (showFromAddress) {
    row.appendChild(makeCell(logEntry.getHeaderField(Packet.HeaderType.FROM_ADDRESS)));
  }

  if (showToAddress) {
    row.appendChild(makeCell(logEntry.getHeaderField(Packet.HeaderType.TO_ADDRESS)));
  }

  if (showPacketInfo) {
    row.appendChild(makeCell(logEntry.getLocalizedPacketInfo()));
  }

  var tdMessageBody = makeCell(logEntry.getMessageAscii());
  tdMessageBody.className = 'message';
  row.appendChild(tdMessageBody);

  return row;
};

/**
 * @param {!string} text
 * @returns {HTMLElement} the new TD element.
 */
function makeCell(text) {
  var td = document.createElement('td');
  td.style.whiteSpace = 'nowrap';
  td.textContent = text;
  return td;
}

/**
 * Change the sort settings and re-render the log table.
 * @param {!string} sortKey
 * @private
 */
NetSimRouterLogModal.prototype.onSortHeaderClick_ = function (sortKey) {
  if (!sortKey) {
    return;
  }

  if (this.sortBy_ === sortKey) {
    this.sortDescending_ = !this.sortDescending_;
  } else {
    this.sortBy_ = sortKey;
    this.sortDescending_ = false;
  }
  this.render();
};

/**
 * Called by the sumulation's onRouterConnect and onRouterDisconnect
 * methods, this locally remembers the current router state and triggers
 * a rerender
 * @param {NetSimRouterNode} router
 */
NetSimRouterLogModal.prototype.setRouter = function (router) {
  this.router_ = router;
  this.isAllRouterLogMode_ = !this.hasLocalRouter_();
  this.render();
};

/**
 * Whether we are currently capable of logging all routers or not.
 * Is always true if we are in a level with connected routers.
 * Otherwise, is only true if we are not locally connected to a router.
 * @returns {boolean}
 * @private
 */
NetSimRouterLogModal.prototype.canLogAllRouters_ = function () {
  return NetSimGlobals.getLevelConfig().connectedRouters || !this.hasLocalRouter_();
};

/**
 * Returns true iff we are locally connected to a router.
 * @returns {boolean}
 * @private
 */
NetSimRouterLogModal.prototype.hasLocalRouter_ = function () {
  return !!this.router_;
};

/**
 * Whether or not we can switch between all-router and single-router log
 * mode. We can switch to single-router iff we have a local router, and
 * we can switch to all-router iff we are capable of logging all routers
 * @returns {boolean}
 * @private
 */
NetSimRouterLogModal.prototype.canToggleRouterLogMode_ = function () {
  if (this.isAllRouterLogMode_) {
    return this.hasLocalRouter_();
  } else {
    return this.canLogAllRouters_();
  }
};

/**
 * Toggles this.isAllRouterLogMode_ between `true` and `false`
 * @private
 */
NetSimRouterLogModal.prototype.toggleRouterLogMode_ = function () {
  this.isAllRouterLogMode_ = !this.isAllRouterLogMode_;
};

/**
 * Finds the button used to toggle between router log modes
 * @returns {jQuery}
 * @private
 */
NetSimRouterLogModal.prototype.getRouterLogToggleButton = function () {
  return this.rootDiv_.find('button#routerlog-toggle');
};

/**
 * Give the log browser a reference to the shard, so that it can query the
 * log table.  Or, pass null when disconnecting from a shard.
 * @param {NetSimShard|null} newShard
 */
NetSimRouterLogModal.prototype.setShard = function (newShard) {

  if (this.eventKeys_.registeredWithShard) {
    this.eventKeys_.registeredWithShard.logTable.tableChange.unregister(this.eventKeys_.logTableChange);
    this.eventKeys_.registeredWithShard = null;
  }

  if (newShard) {
    this.eventKeys_.logTableChange = newShard.logTable.tableChange.register(this.onLogTableChange_.bind(this));
    this.eventKeys_.registeredWithShard = newShard;
  }

  // When changing shards, reset log so we fetch the whole thing next time.
  this.logEntries_.length = 0;
  this.latestRowID_ = 0;
  this.shard_ = newShard;
};

/**
 * Handle log table changes.
 * @private
 */
NetSimRouterLogModal.prototype.onLogTableChange_ = function () {
  var headerSpec = NetSimGlobals.getLevelConfig().routerExpectsPacketHeader;
  var newRows = this.shard_.logTable.readAllFromID(this.latestRowID_ + 1);
  var newLogEntries = newRows.map(function (row) {
    this.latestRowID_ = Math.max(row.id, this.latestRowID_);
    return new NetSimLogEntry(this.shard_, row, headerSpec);
  }, this);
  // Modify this.logEntries_ in-place, appending new log entries
  Array.prototype.push.apply(this.logEntries_, newLogEntries);
  this.renderNewLogEntries_(newLogEntries);
};

},{"./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogEntry":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogEntry.js","./NetSimRouterLogModal.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterLogModal.html.ejs","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterLogModal.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var Packet = require('./Packet');
var i18n = require('./locale');
var NetSimGlobals = require('./NetSimGlobals');

var headerFields = NetSimGlobals.getLevelConfig().routerExpectsPacketHeader;

/** @type {boolean} */
var showToAddress = headerFields.indexOf(Packet.HeaderType.TO_ADDRESS) > -1;

/** @type {boolean} */
var showFromAddress = headerFields.indexOf(Packet.HeaderType.FROM_ADDRESS) > -1;

/** @type {boolean} */
var showPacketInfo = headerFields.indexOf(Packet.HeaderType.PACKET_INDEX) > -1 &&
    headerFields.indexOf(Packet.HeaderType.PACKET_COUNT) > -1;

/**
 * @name isAllRouterLogMode
 * @type {boolean}
 */

/**
 * @name sortBy
 * @type {string}
 */

/**
 * @name sortDescending
 * @type {boolean}
 */

function sortMarkupFor(sortKey) {
  if (sortKey === sortBy) {
    if (sortDescending) {
      return '<i class="fa fa-sort-desc"></i>';
    } else {
      return '<i class="fa fa-sort-asc"></i>';
    }
  }
  return '';
}
; buf.push('\n<div class="modal-dialog modal-lg">\n    <div class="modal-header">\n      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n\n      ');48; if (canToggleRouterLogMode) { ; buf.push('\n        <button type="button" id="routerlog-toggle" class="pull-right btn btn-primary btn-mini">', escape((49,  (isAllRouterLogMode) ? i18n.logBrowserHeader_toggleMine() : i18n.logBrowserHeader_toggleAll() )), '</button>\n      ');50; } ; buf.push('\n\n      ');52; if (isAllRouterLogMode) { ; buf.push('\n        <h4 class="modal-title">', escape((53,  i18n.logBrowserHeader_all() )), '</h4>\n      ');54; } else { ; buf.push('\n        <h4 class="modal-title">', escape((55,  i18n.logBrowserHeader_mine() )), '</h4>\n      ');56; } ; buf.push('\n    </div>\n    <div class="modal-body">\n      <table>\n        <thead>\n          <tr>\n            <th nowrap data-sort-key="timestamp">', escape((62,  i18n.time() )), ' ', (62,  sortMarkupFor('timestamp') ), '</th>\n            <th nowrap data-sort-key="logged-by">', escape((63,  i18n.loggedByNode() )), ' ', (63,  sortMarkupFor('logged-by') ), '</th>\n            <th nowrap data-sort-key="status">', escape((64,  i18n.status() )), ' ', (64,  sortMarkupFor('status') ), '</th>\n            ');65; if (showFromAddress) { ; buf.push('\n              <th nowrap data-sort-key="from-address">', escape((66,  i18n.from() )), ' ', (66,  sortMarkupFor('from-address') ), '</th>\n            ');67; } ; buf.push('\n            ');68; if (showToAddress) { ; buf.push('\n              <th nowrap data-sort-key="to-address">', escape((69,  i18n.to() )), ' ', (69,  sortMarkupFor('to-address') ), '</th>\n            ');70; } ; buf.push('\n            ');71; if (showPacketInfo) { ; buf.push('\n              <th nowrap data-sort-key="packet-info">', escape((72,  i18n.packet() )), ' ', (72,  sortMarkupFor('packet-info') ), '</th>\n            ');73; } ; buf.push('\n            <th nowrap data-sort-key="message">', escape((74,  i18n.message() )), ' ', (74,  sortMarkupFor('message') ), '</th>\n          </tr>\n        </thead>\n        <tbody>\n        </tbody>\n      </table>\n    </div>\n    <div class="modal-footer">\n      <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n    </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketSizeControl.js":[function(require,module,exports){
/**
 * @overview UI slider used to change maximum packet length.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var i18n = require('./locale');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for packet size slider/selector
 * @param {jQuery} rootDiv
 * @param {function} packetSizeChangeCallback
 * @param {Object} options
 * @param {number} options.minimumPacketSize
 * @constructor
 * @augments NetSimSlider
 */
var NetSimPacketSizeControl = module.exports = function (rootDiv, packetSizeChangeCallback, options) {
  NetSimSlider.call(this, rootDiv, {
    onChange: packetSizeChangeCallback,
    min: options.minimumPacketSize,
    max: 8192,
    upperBoundInfinite: false
  });

  // Auto-render, unlike our base class
  this.render();
};
NetSimPacketSizeControl.inherits(NetSimSlider);

/**
 * Get localized packet size description for the given packet size.
 * @param {number} packetSize
 * @returns {string}
 */
NetSimPacketSizeControl.prototype.getPacketSizeText = function (packetSize) {
  return i18n.numBitsPerPacket({ numBits: packetSize });
};

/**
 * Converts a numeric value (in bits) into a compact localized string
 * representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimPacketSizeControl.prototype.valueToLabel = function (val) {
  if (val === Infinity) {
    return i18n.unlimited();
  }
  return i18n.numBitsPerPacket({ numBits: val });
};

/**
 * Get labels for end sliders
 * @param {number} val
 * @returns {string}
 * @override
 */
NetSimPacketSizeControl.prototype.valueToShortLabel = function (val) {
  if (val === Infinity) {
    return i18n.unlimited();
  }
  return val;
};

},{"./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketEditor.js":[function(require,module,exports){
/**
 * @overview UI controller for the packet editor which allows editing multiple
 *           encodings at once and lives inside the send panel.
 * @see NetSimSendPanel for how this is used.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

require('../utils'); // For Function.prototype.inherits()
var netsimMsg = require('./locale');
var markup = require('./NetSimPacketEditor.html.ejs');
var KeyCodes = require('../constants').KeyCodes;
var NetSimEncodingControl = require('./NetSimEncodingControl');
var NetSimLogPanel = require('./NetSimLogPanel');
var Packet = require('./Packet');
var DataConverters = require('./DataConverters');
var NetSimConstants = require('./NetSimConstants');
var NetSimGlobals = require('./NetSimGlobals');

var EncodingType = NetSimConstants.EncodingType;
var BITS_PER_BYTE = NetSimConstants.BITS_PER_BYTE;

var minifyBinary = DataConverters.minifyBinary;
var formatAB = DataConverters.formatAB;
var formatBinary = DataConverters.formatBinary;
var formatHex = DataConverters.formatHex;
var alignDecimal = DataConverters.alignDecimal;
var abToBinary = DataConverters.abToBinary;
var abToInt = DataConverters.abToInt;
var binaryToAB = DataConverters.binaryToAB;
var binaryToHex = DataConverters.binaryToHex;
var binaryToInt = DataConverters.binaryToInt;
var binaryToDecimal = DataConverters.binaryToDecimal;
var binaryToAscii = DataConverters.binaryToAscii;
var hexToBinary = DataConverters.hexToBinary;
var intToAB = DataConverters.intToAB;
var intToBinary = DataConverters.intToBinary;
var intToHex = DataConverters.intToHex;
var decimalToBinary = DataConverters.decimalToBinary;
var asciiToBinary = DataConverters.asciiToBinary;

/**
 * Type for tructured access to jQuery-wrapped DOM elements.  Two layers deep;
 * can be used for quick access to one of the fields in the packet editor grid
 * by referencing via row and column.
 *
 * Map keys at the first layer correspond to NetSimConstants.EncodingType.
 * Map keys at the second layer correspond to Packet.HeaderType, plus the
 *   'message' field.
 *
 * Usage:
 *   map.binary.fromAddress
 *   map['binary']['fromAddress']
 *   map[EncodingType.BINARY][Packet.HeaderType.FROM_ADDRESS]
 *
 * @typedef {Object} UIMap
 * @property {UIRowMap} a_and_b
 * @property {UIRowMap} binary
 * @property {UIRowMap} hexadecimal
 * @property {UIRowMap} decimal
 * @property {UIRowMap} ascii
 */

/**
 * @typedef {Object} UIRowMap
 * @property {jQuery} toAddress
 * @property {jQuery} fromAddress
 * @property {jQuery} packetIndex
 * @property {jQuery} packetCount
 * @property {jQuery} message
 */

/**
 * Generator and controller for message sending view.
 * @param {Object} initialConfig
 * @param {MessageGranularity} initialConfig.messageGranularity
 * @param {Packet.HeaderType[]} initialConfig.packetSpec
 * @param {number} [initialConfig.toAddress]
 * @param {number} [initialConfig.fromAddress]
 * @param {number} [initialConfig.packetIndex]
 * @param {number} [initialConfig.packetCount]
 * @param {string} [initialConfig.message]
 * @param {number} [initialConfig.maxPacketSize]
 * @param {number} [initialConfig.chunkSize]
 * @param {number} [initialConfig.bitRate]
 * @param {EncodingType[]} [initialConfig.enabledEncodings]
 * @param {function} initialConfig.removePacketCallback
 * @param {function} initialConfig.doneSendingCallback
 * @param {function} initialConfig.contentChangeCallback
 * @param {function} initialConfig.enterKeyPressedCallback
 * @constructor
 */
var NetSimPacketEditor = module.exports = function (initialConfig) {
  var level = NetSimGlobals.getLevelConfig();

  /**
   * @type {RowType[]}
   * @const
   */
  this.ROW_TYPES = [{
    typeName: EncodingType.A_AND_B,
    addressFieldAllowedCharacters: /[AB\s]/i,
    addressFieldConversion: function addressFieldConversion(abString) {
      return DataConverters.binaryToAddressString(DataConverters.abToBinary(abString), level.addressFormat);
    },
    shortNumberAllowedCharacters: /[AB]/i,
    shortNumberConversion: truncatedABToInt,
    messageAllowedCharacters: /[AB\s]/i,
    messageConversion: abToBinary
  }, {
    typeName: EncodingType.BINARY,
    addressFieldAllowedCharacters: /[01\s]/i,
    addressFieldConversion: function addressFieldConversion(binaryString) {
      return DataConverters.binaryToAddressString(binaryString, level.addressFormat);
    },
    shortNumberAllowedCharacters: /[01]/,
    shortNumberConversion: truncatedBinaryToInt,
    messageAllowedCharacters: /[01\s]/,
    messageConversion: minifyBinary
  }, {
    typeName: EncodingType.HEXADECIMAL,
    addressFieldAllowedCharacters: /[0-9a-f\s]/i,
    addressFieldConversion: function addressFieldConversion(hexString) {
      return DataConverters.binaryToAddressString(DataConverters.hexToBinary(hexString), level.addressFormat);
    },
    shortNumberAllowedCharacters: /[0-9a-f]/i,
    shortNumberConversion: truncatedHexToInt,
    messageAllowedCharacters: /[0-9a-f\s]/i,
    messageConversion: hexToBinary
  }, {
    typeName: EncodingType.DECIMAL,
    addressFieldAllowedCharacters: /[0-9.\s]/i,
    addressFieldConversion: cleanAddressString,
    shortNumberAllowedCharacters: /[0-9]/,
    shortNumberConversion: truncatedDecimalToInt,
    messageAllowedCharacters: /[0-9\s]/,
    messageConversion: (function (decimalString) {
      return decimalToBinary(decimalString, this.currentChunkSize_);
    }).bind(this)
  }, {
    typeName: EncodingType.ASCII,
    addressFieldAllowedCharacters: /[0-9.\s]/i,
    addressFieldConversion: cleanAddressString,
    shortNumberAllowedCharacters: /[0-9]/,
    shortNumberConversion: truncatedDecimalToInt,
    messageAllowedCharacters: /./,
    messageConversion: (function (asciiString) {
      return asciiToBinary(asciiString, this.currentChunkSize_);
    }).bind(this)
  }];

  /**
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = $('<div>').addClass('netsim-packet');

  /**
   * @type {MessageGranularity}
   * @private
   */
  this.messageGranularity_ = initialConfig.messageGranularity;

  /**
   * @type {Packet.HeaderType[]}
   * @private
   */
  this.packetSpec_ = initialConfig.packetSpec;

  /** @type {string} */
  this.toAddress = initialConfig.toAddress || DataConverters.binaryToAddressString('0', level.addressFormat);

  /** @type {string} */
  this.fromAddress = initialConfig.fromAddress || DataConverters.binaryToAddressString('0', level.addressFormat);

  /** @type {number} */
  this.packetIndex = initialConfig.packetIndex !== undefined ? initialConfig.packetIndex : 1;

  /** @type {number} */
  this.packetCount = initialConfig.packetCount !== undefined ? initialConfig.packetCount : 1;

  /**
   * Binary string of message body, live-interpreted to other values.
   * @type {string}
   */
  this.message = initialConfig.message || '';

  /**
   * Maximum packet length configurable by slider.
   * @type {Number}
   * @private
   */
  this.maxPacketSize_ = initialConfig.maxPacketSize || 8192;

  /**
   * Bits per chunk/byte for parsing and formatting purposes.
   * @type {number}
   * @private
   */
  this.currentChunkSize_ = initialConfig.chunkSize || BITS_PER_BYTE;

  /**
   * Local device bitrate (bps), which affects send-animation speed.
   * @type {number}
   * @private
   */
  this.bitRate_ = initialConfig.bitRate || Infinity;

  var encodings = initialConfig.enabledEncodings || [];
  /**
   * Which encodings should be visible in the editor.
   * @type {Object.<EncodingType, boolean>}
   * @private
   */
  this.enabledEncodingsHash_ = NetSimEncodingControl.encodingsAsHash(encodings);

  /**
   * Method to call in order to remove this packet from its parent.
   * Function should take this PacketEditor as an argument.
   * @type {function}
   * @private
   */
  this.removePacketCallback_ = initialConfig.removePacketCallback;

  /**
   * Method to call when this packet is done playing its sending animation.
   * Function should take this PacketEditor as an argument.
   * @type {function}
   * @private
   */
  this.doneSendingCallback_ = initialConfig.doneSendingCallback;

  /**
   * Method to notify our parent container that the packet's binary
   * content has changed.
   * @type {function}
   * @private
   */
  this.contentChangeCallback_ = initialConfig.contentChangeCallback;

  /**
   * Method to notify our parent container that the enter key has been
   * pressed
   * @type {function}
   * @private
   */
  this.enterKeyPressedCallback_ = initialConfig.enterKeyPressedCallback;

  /**
   * @type {jQuery}
   * @private
   */
  this.removePacketButton_ = null;

  /**
   * @type {jQuery}
   * @private
   */
  this.bitCounter_ = null;

  /**
   * Flag noting whether this packet editor is in a non-interactive mode
   * where it animates bits draining/being sent.
   * @type {boolean}
   * @private
   */
  this.isPlayingSendAnimation_ = false;

  /**
   * Flag for whether this editor is in the middle of an async send command.
   * @type {boolean}
   * @private
   */
  this.isSendingPacketToRemote_ = false;

  /**
   * Reference to local client node, used for sending messages.
   * @type {NetSimLocalClientNode}
   * @private
   */
  this.myNode_ = null;

  /**
   * Capture packet binary before the send animation begins so that we can
   * send the whole packet to remote storage when the animation is done.
   * @type {string}
   * @private
   */
  this.originalBinary_ = '';

  /**
   * Index into original binary indicating how many bits have been 'sent'
   * in the animation.
   * @type {number}
   * @private
   */
  this.sendAnimationIndex_ = 0;

  /**
   * Simulation-time timestamp (ms) of the last bit-send animation.
   * @type {number}
   * @private
   */
  this.lastBitSentTime_ = undefined;

  /**
   * Map of bound UI elements manipulated by this editor.  Provides quick
   * access to input elements in the editor grid.  See type notes for usage.
   *
   * Populated dynamically in `bindElements_` during `render`.  May not include
   * all fields, as we try to optimize and omit fields not enabled in the level.
   *
   * @type {UIMap}
   * @private
   */
  this.ui_ = {};

  this.render();
};

/**
 * Return root div, for hooking up to a parent element.
 * @returns {jQuery}
 */
NetSimPacketEditor.prototype.getRoot = function () {
  return this.rootDiv_;
};

/**
 * Clear the packet payload and put the editor back in a state where it's
 * ready for composing a new packet.
 * Intentionally preserves toAddress and fromAddress.
 */
NetSimPacketEditor.prototype.resetPacket = function () {
  this.message = '';
  this.packetIndex = 1;
  this.packetCount = 1;
  this.originalBinary_ = '';
  this.sendAnimationIndex_ = 0;
  this.lastBitSentTime_ = undefined;
  this.updateFields_();
  this.updateRemoveButtonVisibility_();
};

/**
 * Returns the first visible message box, so that we can focus() on it
 * @returns {jQuery}
 */
NetSimPacketEditor.prototype.getFirstVisibleMessageBox = function () {
  return this.getRoot().find('textarea.message:visible').first();
};

/** Replace contents of our root element with our own markup. */
NetSimPacketEditor.prototype.render = function () {
  var newMarkup = $(markup({
    messageGranularity: this.messageGranularity_,
    packetSpec: this.packetSpec_,
    enabledEncodingsHash: this.enabledEncodingsHash_
  }));
  this.rootDiv_.html(newMarkup);
  this.bindElements_();
  this.updateFields_();
  this.updateRemoveButtonVisibility_();
  NetSimLogPanel.adjustHeaderColumnWidths(this.rootDiv_);
  NetSimEncodingControl.hideRowsByEncoding(this.rootDiv_, Object.keys(this.enabledEncodingsHash_));
};

/**
 * Put this packet in a mode where it's not editable.  Instead, it will drain
 * its binary at the current bitrate and call the given callback when all
 * of the binary has been drained/"sent"
 * @param {NetSimLocalClientNode} myNode
 */
NetSimPacketEditor.prototype.beginSending = function (myNode) {
  this.isPlayingSendAnimation_ = true;
  this.originalBinary_ = this.getPacketBinary().substr(0, this.maxPacketSize_);
  this.sendAnimationIndex_ = 0;
  this.myNode_ = myNode;

  // Finish now if the packet is empty.
  if (0 === this.originalBinary_.length) {
    this.finishSending();
  }
};

/**
 * Kick off the async send-to-remote operation for the original packet binary.
 * When it's done, remove this now-empty packet.
 */
NetSimPacketEditor.prototype.finishSending = function () {
  this.isPlayingSendAnimation_ = false;
  this.isSendingPacketToRemote_ = true;
  this.myNode_.sendMessage(this.originalBinary_, (function () {
    this.isSendingPacketToRemote_ = false;
    this.doneSendingCallback_(this);
  }).bind(this));
};

/**
 * @returns {boolean} TRUE if this packet is currently being sent.
 */
NetSimPacketEditor.prototype.isSending = function () {
  return this.isPlayingSendAnimation_ || this.isSendingPacketToRemote_;
};

/**
 * Packet Editor tick is called (manually by the NetSimSendPanel) to advance
 * its sending animation.
 * @param {RunLoop.Clock} clock
 */
NetSimPacketEditor.prototype.tick = function (clock) {
  // Before we start animating, or after we are done animating, do nothing.
  if (!this.isPlayingSendAnimation_ || this.isSendingPacketToRemote_) {
    return;
  }

  if (!this.lastBitSentTime_) {
    this.lastBitSentTime_ = clock.time;
  }

  // How many characters should be consumed this tick?
  var msPerBit = 1000 * (1 / this.bitRate_);
  var maxBitsToSendThisTick = Infinity;
  if (msPerBit > 0) {
    var msSinceLastBitConsumed = clock.time - this.lastBitSentTime_;
    maxBitsToSendThisTick = Math.floor(msSinceLastBitConsumed / msPerBit);
  }

  if (maxBitsToSendThisTick > 0) {
    this.lastBitSentTime_ = clock.time;
    this.sendAnimationIndex_ += maxBitsToSendThisTick;
    this.updateForAnimation_();
    if (this.sendAnimationIndex_ >= this.originalBinary_.length) {
      this.finishSending();
    }
  }
};

/**
 * Focus event handler.  If the target element has a 'watermark' class then
 * it contains text we intend to clear before any editing occurs.  This
 * handler clears that text and removes the class.
 * @param focusEvent
 */
var removeWatermark = function removeWatermark(focusEvent) {
  var target = $(focusEvent.target);
  if (target.hasClass('watermark')) {
    target.val('');
    target.removeClass('watermark');
  }
};

/**
 * Helper method for determining if a given keyPress event represents a
 * CLEAN enter press. As in, one without the Shift or Control modifiers.
 * @param {Event} jqueryEvent
 * @returns {boolean} true iff the given event represents a clean enter
 */
var isUnmodifiedEnterPress = function isUnmodifiedEnterPress(jqueryEvent) {
  return jqueryEvent.keyCode === KeyCodes.ENTER && !(jqueryEvent.ctrlKey || jqueryEvent.shiftKey);
};

/**
 * Creates a keyPress handler that allows only the given characters to be
 * typed into a text field.
 * @param {RegExp} whitelistRegex
 * @return {function} appropriate to pass to .keypress()
 */
var makeKeypressHandlerWithWhitelist = function makeKeypressHandlerWithWhitelist(whitelistRegex) {
  /**
   * A keyPress handler that blocks all visible characters except those
   * matching the whitelist.  Passes through invisible characters (backspace,
   * delete) and control combinations (copy, paste).
   *
   * @param keyEvent
   * @returns {boolean} - Whether to propagate this event.  Should return
   *          FALSE if we handle the event and don't want to pass it on, TRUE
   *          if we are not handling the event.
   */
  return function (keyEvent) {

    // Don't block control combinations (copy, paste, etc.)
    if (keyEvent.metaKey || keyEvent.ctrlKey) {
      return true;
    }

    // Don't block invisible characters; we want to allow backspace, delete, etc.
    if (keyEvent.which < KeyCodes.SPACE || keyEvent.which >= KeyCodes.DELETE) {
      return true;
    }

    // At this point, if the character doesn't match, we should block it.
    var key = String.fromCharCode(keyEvent.which);
    if (!whitelistRegex.test(key)) {
      keyEvent.preventDefault();
      return false;
    }
  };
};

/**
 * Generate a jQuery-appropriate keyup handler for a text field.
 * Grabs the new value of the text field, runs it through the provided
 * converter function, sets the result on the SendWidget's internal state
 * and triggers a field update on the widget that skips the field being edited.
 *
 * Similar to makeBlurHandler, but does not update the field currently
 * being edited.
 *
 * @param {string} fieldName - name of internal state field that the text
 *        field should update.
 * @param {function} converterFunction - Takes the text field's value and
 *        converts it to a format appropriate to the internal state field.
 * @param {number} [fieldWidth] - maximum number of bits for field, passed
 *        through as second argument to converter function.
 * @returns {function} that can be passed to $.keyup()
 */
NetSimPacketEditor.prototype.makeKeyupHandler = function (fieldName, converterFunction, fieldWidth) {
  return (function (jqueryEvent) {
    var newValue = converterFunction(jqueryEvent.target.value, fieldWidth);
    if (typeof newValue === 'string' || !isNaN(newValue)) {
      this[fieldName] = newValue;
      this.updateFields_(jqueryEvent.target);
    }
  }).bind(this);
};

/**
 * Generate a jQuery-appropriate blur handler for a text field.
 * Grabs the new value of the text field, runs it through the provided
 * converter function, sets the result on the SendWidget's internal state
 * and triggers a full field update of the widget (including the field that was
 * just edited).
 *
 * Similar to makeKeyupHandler, but also updates the field that was
 * just edited.
 *
 * @param {string} fieldName - name of internal state field that the text
 *        field should update.
 * @param {function} converterFunction - Takes the text field's value and
 *        converts it to a format appropriate to the internal state field.
 * @param {number} [fieldWidth] - maximum number of bits for field, passed
 *        through as second argument to converter function.
 * @returns {function} that can be passed to $.blur()
 */
NetSimPacketEditor.prototype.makeBlurHandler = function (fieldName, converterFunction, fieldWidth) {
  return (function (jqueryEvent) {
    var newValue = converterFunction(jqueryEvent.target.value, fieldWidth);
    if (typeof newValue === 'number' && isNaN(newValue)) {
      newValue = converterFunction('0');
    }
    this[fieldName] = newValue;
    this.updateFields_();
  }).bind(this);
};

/**
 * Specification for an encoding row in the editor, which designates character
 * whitelists to limit typing in certain fields, and rules for intepreting the
 * field from binary.
 * @typedef {Object} RowType
 * @property {EncodingType} typeName
 * @property {RegExp} addressFieldAllowedCharacters - Whitelist of characters
 *           that may be typed into an address field.
 * @property {function} addressFieldConversion - How to convert from binary
 *           to an address string in this row when the binary is updated.
 * @property {RegExp} shortNumberAllowedCharacters - Whitelist of characters
 *           that may be typed into a header field.
 * @property {function} shortNumberConversion - How to convert from binary
 *           to a header value in this row when the binary is updated.
 * @property {RegExp} messageAllowedCharacters - Whitelist of characters
 *           that may be typed into the message field.
 * @property {function} messageConversion - How to convert from binary to
 *           the message value in this row when the binary is updated.
 */

/**
 * Convert binary to an integer, intentionally limiting the binary width so
 * that overflow can occur.
 * @param {string} binaryString (interpreted as unsigned)
 * @param {number} maxWidth in bits
 * @returns {number}
 */
var truncatedBinaryToInt = function truncatedBinaryToInt(binaryString, maxWidth) {
  return binaryToInt(binaryString.substr(-maxWidth));
};

/**
 * Convert ABs to an integer, intentionally limiting the width so that overflow
 * can occur (analagous to truncatedBinaryToInt).  A is treated as zero, B as
 * one.
 * @param {string} abString
 * @param {number} maxWidth in bits
 * @returns {number}
 */
var truncatedABToInt = function truncatedABToInt(abString, maxWidth) {
  return abToInt(abString.substr(-maxWidth));
};

/**
 * Convert a hexadecimal string to a single integer, intentionally limiting
 * the bit-width to so that overflow can occur.
 * @param {string} hexString
 * @param {number} maxWidth in bits
 * @returns {number}
 */
var truncatedHexToInt = function truncatedHexToInt(hexString, maxWidth) {
  return truncatedBinaryToInt(hexToBinary(hexString), maxWidth);
};

/**
 * Convert a decimal string to an integer, intentionally limiting the bit-width
 * so that overflow can occur.
 * @param {string} decimalString
 * @param {number} maxWidth in bits
 * @returns {number}
 */
var truncatedDecimalToInt = function truncatedDecimalToInt(decimalString, maxWidth) {
  return truncatedBinaryToInt(intToBinary(parseInt(decimalString, 10)), maxWidth);
};

/**
 * Convert an address string to binary and back using the level's address
 * format, which coerces it to the exact format the level wants.
 * @param {string} originalString
 * @returns {string}
 */
var cleanAddressString = function cleanAddressString(originalString) {
  var level = NetSimGlobals.getLevelConfig();
  var binaryForm = DataConverters.addressStringToBinary(originalString, level.addressFormat);
  return DataConverters.binaryToAddressString(binaryForm, level.addressFormat);
};

/**
 * Helper method to filter this.ROW_TYPES by enabled encodings
 * @private
 * @returns {RowType[]}
 */
NetSimPacketEditor.prototype.getEnabledRowTypes_ = function () {
  return this.ROW_TYPES.filter(function (rowType) {
    return this.isEncodingEnabled_(rowType.typeName);
  }, this);
};

/**
 * Get relevant elements from the page and bind them to local variables.
 * @private
 */
NetSimPacketEditor.prototype.bindElements_ = function () {
  var level = NetSimGlobals.getLevelConfig();
  var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, this.packetSpec_);
  var rootDiv = this.rootDiv_;

  this.getEnabledRowTypes_().forEach(function (rowType) {
    var tr = rootDiv.find('tr.' + rowType.typeName);
    this.ui_[rowType.typeName] = {};
    var rowFields = this.ui_[rowType.typeName];

    // We attach focus (sometimes) to clear the field watermark, if present
    // We attach keypress to block certain characters
    // We attach keyup to live-update the widget as the user types
    // We attach blur to reformat the edited field when the user leaves it,
    //    and to catch non-keyup cases like copy/paste.

    this.packetSpec_.forEach(function (fieldSpec) {
      /** @type {Packet.HeaderType} */
      var fieldName = fieldSpec;
      /** @type {number} */
      var fieldWidth = encoder.getFieldBitWidth(fieldName);

      var allowedCharacterFunction, conversionFunction;
      if (Packet.isAddressField(fieldName)) {
        allowedCharacterFunction = rowType.addressFieldAllowedCharacters;
        conversionFunction = rowType.addressFieldConversion;
      } else {
        allowedCharacterFunction = rowType.shortNumberAllowedCharacters;
        conversionFunction = rowType.shortNumberConversion;
      }

      rowFields[fieldName] = tr.find('input.' + fieldName);
      rowFields[fieldName].keypress(makeKeypressHandlerWithWhitelist(allowedCharacterFunction));
      rowFields[fieldName].keyup(this.makeKeyupHandler(fieldName, conversionFunction, fieldWidth));
      rowFields[fieldName].blur(this.makeBlurHandler(fieldName, conversionFunction, fieldWidth));
    }, this);

    rowFields.message = tr.find('textarea.message');
    rowFields.message.focus(removeWatermark);
    rowFields.message.keypress(makeKeypressHandlerWithWhitelist(rowType.messageAllowedCharacters));
    rowFields.message.keydown((function (jqueryEvent) {
      if (isUnmodifiedEnterPress(jqueryEvent)) {
        this.enterKeyPressedCallback_(jqueryEvent);
      }
    }).bind(this));
    rowFields.message.keyup(this.makeKeyupHandler('message', rowType.messageConversion));
    rowFields.message.blur(this.makeBlurHandler('message', rowType.messageConversion));
  }, this);

  this.removePacketButton_ = rootDiv.find('.remove-packet-button');
  this.removePacketButton_.click(this.onRemovePacketButtonClick_.bind(this));
  this.bitCounter_ = rootDiv.find('.bit-counter');
};

/**
 * Special update method called during send animation that changes the editor
 * display to show each field left-truncated at an appropriate amount for the
 * simulated send progress.
 *
 * This works differently for different fields:
 *  - Binary and A/B fields send a single bit at a time.
 *  - Hex sends a single hex digit at a time, but at the correct slower rate.
 *  - Decimal and ASCII send one chunk at a time, which depends on the current
 *    chunk size, and is adjusted to the correct slower rate as well.  For
 *    ASCII this maps to one character at a time.  For decimal, it's one
 *    whitespace-delimited number.
 *
 * This avoids the jumbled effect of reinterpreting nonbinary fields using
 * misaligned binary, and communicates in a visual way that it takes longer to
 * send a single character than it does to send a single bit.
 *
 * This method is also designed to send the packet header fields in sequence
 * before sending the packet body.  Body binary is never seen in the header
 * fields, each field is treated as an independent space.
 * @private
 */
NetSimPacketEditor.prototype.updateForAnimation_ = function () {
  var chunkSize = this.currentChunkSize_;
  var liveFields = [];

  // There may be potential for performance optimization here, but it's not
  // particularly high on our perf list right now.

  var level = NetSimGlobals.getLevelConfig();
  var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, this.packetSpec_);

  var fieldStart = 0;

  this.packetSpec_.forEach(function (fieldSpec) {
    /** @type {Packet.HeaderType} */
    var fieldName = fieldSpec;
    /** @type {number} */
    var fieldWidth = encoder.getFieldBitWidth(fieldName);

    if (this.sendAnimationIndex_ < fieldStart + fieldWidth) {
      // Either we haven't reached this field yet or we're currently animating
      // through it; don't do anything to the more complex fields, and animate
      // the binary appropriately.
      var fieldBinary = this.originalBinary_.substr(fieldStart, fieldWidth);
      var truncatedBits = Math.max(0, this.sendAnimationIndex_ - fieldStart);

      if (this.isEncodingEnabled_(EncodingType.A_AND_B)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.A_AND_B][fieldName],
          newValue: binaryToAB(fieldBinary).substr(truncatedBits)
        });
      }

      if (this.isEncodingEnabled_(EncodingType.BINARY)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.BINARY][fieldName],
          newValue: fieldBinary.substr(truncatedBits)
        });
      }

      if (this.isEncodingEnabled_(EncodingType.HEXADECIMAL)) {
        var truncatedHexDigits = Math.floor(truncatedBits / 4);
        liveFields.push({
          inputElement: this.ui_[EncodingType.HEXADECIMAL][fieldName],
          newValue: binaryToHex(fieldBinary).substr(truncatedHexDigits)
        });
      }
    } else {
      // We're past this field - it should be blank
      if (this.isEncodingEnabled_(EncodingType.A_AND_B)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.A_AND_B][fieldName],
          newValue: ''
        });
      }

      if (this.isEncodingEnabled_(EncodingType.BINARY)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.BINARY][fieldName],
          newValue: ''
        });
      }

      if (this.isEncodingEnabled_(EncodingType.HEXADECIMAL)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.HEXADECIMAL][fieldName],
          newValue: ''
        });
      }

      if (this.isEncodingEnabled_(EncodingType.DECIMAL)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.DECIMAL][fieldName],
          newValue: ''
        });
      }

      if (this.isEncodingEnabled_(EncodingType.ASCII)) {
        liveFields.push({
          inputElement: this.ui_[EncodingType.ASCII][fieldName],
          newValue: ''
        });
      }
    }

    // Advance to the next field
    fieldStart += fieldWidth;
  }, this);

  var bodyBinary = this.originalBinary_.substr(fieldStart);
  var truncatedBits = Math.max(0, this.sendAnimationIndex_ - fieldStart);
  var truncatedChunks = Math.floor(truncatedBits / chunkSize);
  var partialBinaryAtChunkSize = bodyBinary.substr(truncatedChunks * chunkSize);

  if (this.isEncodingEnabled_(EncodingType.A_AND_B)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.A_AND_B].message,
      newValue: formatAB(binaryToAB(bodyBinary).substr(truncatedBits), chunkSize, -truncatedBits),
      watermark: netsimMsg.a_and_b()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.BINARY)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.BINARY].message,
      newValue: formatBinary(bodyBinary.substr(truncatedBits), chunkSize, -truncatedBits),
      watermark: netsimMsg.binary()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.HEXADECIMAL)) {
    var truncatedHexDigits = Math.floor(truncatedBits / 4);
    liveFields.push({
      inputElement: this.ui_[EncodingType.HEXADECIMAL].message,
      newValue: formatHex(binaryToHex(bodyBinary).substr(truncatedHexDigits), chunkSize, -truncatedHexDigits),
      watermark: netsimMsg.hexadecimal()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.DECIMAL)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.DECIMAL].message,
      newValue: alignDecimal(binaryToDecimal(partialBinaryAtChunkSize, chunkSize)),
      watermark: netsimMsg.decimal()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.ASCII)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.ASCII].message,
      newValue: binaryToAscii(partialBinaryAtChunkSize, chunkSize),
      watermark: netsimMsg.ascii()
    });
  }

  liveFields.forEach(function (field) {
    if (field.watermark && field.newValue === '') {
      field.inputElement.val(field.watermark);
      field.inputElement.addClass('watermark');
    } else {
      field.inputElement.val(field.newValue);
      field.inputElement.removeClass('watermark');
    }
  });
};

/**
 * Update send widget display
 * @param {HTMLElement} [skipElement] - A field to skip while updating,
 *        because we don't want to transform content out from under the
 *        user's cursor.
 * @private
 */
NetSimPacketEditor.prototype.updateFields_ = function (skipElement) {
  var chunkSize = this.currentChunkSize_;
  var liveFields = [];

  var level = NetSimGlobals.getLevelConfig();
  var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, this.packetSpec_);

  this.packetSpec_.forEach(function (fieldSpec) {
    /** @type {Packet.HeaderType} */
    var fieldName = fieldSpec;
    /** @type {number} */
    var fieldWidth = encoder.getFieldBitWidth(fieldName);

    var abConverter, binaryConverter, hexConverter, decimalConverter, asciiConverter;
    if (Packet.isAddressField(fieldName)) {
      abConverter = function (addressString) {
        return DataConverters.binaryToAB(DataConverters.addressStringToBinary(addressString, level.addressFormat));
      };
      binaryConverter = function (addressString) {
        return DataConverters.formatBinaryForAddressHeader(DataConverters.addressStringToBinary(addressString, level.addressFormat), level.addressFormat);
      };
      hexConverter = function (addressString) {
        return DataConverters.binaryToHex(DataConverters.addressStringToBinary(addressString, level.addressFormat));
      };
      decimalConverter = cleanAddressString;
      asciiConverter = cleanAddressString;
    } else {
      abConverter = intToAB;
      binaryConverter = intToBinary;
      hexConverter = intToHex;
      decimalConverter = function (val) {
        return val.toString(10);
      };
      asciiConverter = decimalConverter;
    }

    if (this.isEncodingEnabled_(EncodingType.A_AND_B)) {
      liveFields.push({
        inputElement: this.ui_[EncodingType.A_AND_B][fieldName],
        newValue: abConverter(this[fieldName], fieldWidth)
      });
    }

    if (this.isEncodingEnabled_(EncodingType.BINARY)) {
      liveFields.push({
        inputElement: this.ui_[EncodingType.BINARY][fieldName],
        newValue: binaryConverter(this[fieldName], fieldWidth)
      });
    }

    if (this.isEncodingEnabled_(EncodingType.HEXADECIMAL)) {
      liveFields.push({
        inputElement: this.ui_[EncodingType.HEXADECIMAL][fieldName],
        newValue: hexConverter(this[fieldName], Math.ceil(fieldWidth / 4))
      });
    }

    if (this.isEncodingEnabled_(EncodingType.DECIMAL)) {
      liveFields.push({
        inputElement: this.ui_[EncodingType.DECIMAL][fieldName],
        newValue: decimalConverter(this[fieldName], fieldWidth)
      });
    }

    if (this.isEncodingEnabled_(EncodingType.ASCII)) {
      liveFields.push({
        inputElement: this.ui_[EncodingType.ASCII][fieldName],
        newValue: asciiConverter(this[fieldName], fieldWidth)
      });
    }
  }, this);

  if (this.isEncodingEnabled_(EncodingType.A_AND_B)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.A_AND_B].message,
      newValue: formatAB(binaryToAB(this.message), chunkSize),
      watermark: netsimMsg.a_and_b()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.BINARY)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.BINARY].message,
      newValue: formatBinary(this.message, chunkSize),
      watermark: netsimMsg.binary()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.HEXADECIMAL)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.HEXADECIMAL].message,
      newValue: formatHex(binaryToHex(this.message), chunkSize),
      watermark: netsimMsg.hexadecimal()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.DECIMAL)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.DECIMAL].message,
      newValue: alignDecimal(binaryToDecimal(this.message, chunkSize)),
      watermark: netsimMsg.decimal()
    });
  }

  if (this.isEncodingEnabled_(EncodingType.ASCII)) {
    liveFields.push({
      inputElement: this.ui_[EncodingType.ASCII].message,
      newValue: binaryToAscii(this.message, chunkSize),
      watermark: netsimMsg.ascii()
    });
  }

  liveFields.forEach(function (field) {
    if (field.inputElement[0] !== skipElement) {
      if (field.watermark && field.newValue === '') {
        field.inputElement.val(field.watermark);
        field.inputElement.addClass('watermark');
      } else {
        field.inputElement.val(field.newValue);
        field.inputElement.removeClass('watermark');
      }
    }
  });

  this.updateBitCounter();
  this.contentChangeCallback_();
};

/**
 * If there's only one packet, applies "display: none" to the button so the
 * last packet can't be removed.  Otherwise, clears the CSS property override.
 * @private
 */
NetSimPacketEditor.prototype.updateRemoveButtonVisibility_ = function () {
  this.removePacketButton_.css('display', this.packetCount === 1 ? 'none' : '');
};

/**
 * Produces a single binary string in the current packet format, based
 * on the current state of the widget (content of its internal fields).
 * @returns {string} - binary representation of packet
 * @private
 */
NetSimPacketEditor.prototype.getPacketBinary = function () {
  var level = NetSimGlobals.getLevelConfig();
  var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, this.packetSpec_);
  return encoder.concatenateBinary(encoder.makeBinaryHeaders({
    toAddress: this.toAddress,
    fromAddress: this.fromAddress,
    packetIndex: this.packetIndex,
    packetCount: this.packetCount
  }), this.message);
};

/**
 * Sets editor fields from a complete packet binary, according to
 * the configured header specification.
 * @param {string} rawBinary
 */
NetSimPacketEditor.prototype.setPacketBinary = function (rawBinary) {
  var packet = new Packet(this.packetSpec_, rawBinary);

  if (this.specContainsHeader_(Packet.HeaderType.TO_ADDRESS)) {
    this.toAddress = packet.getHeaderAsAddressString(Packet.HeaderType.TO_ADDRESS);
  }

  if (this.specContainsHeader_(Packet.HeaderType.FROM_ADDRESS)) {
    this.fromAddress = packet.getHeaderAsAddressString(Packet.HeaderType.FROM_ADDRESS);
  }

  if (this.specContainsHeader_(Packet.HeaderType.PACKET_INDEX)) {
    this.packetIndex = packet.getHeaderAsInt(Packet.HeaderType.PACKET_INDEX);
  }

  if (this.specContainsHeader_(Packet.HeaderType.PACKET_COUNT)) {
    this.packetCount = packet.getHeaderAsInt(Packet.HeaderType.PACKET_COUNT);
  }

  this.message = packet.getBodyAsBinary();

  // Re-render all encodings
  this.updateFields_();
};

/**
 * @param {Packet.HeaderType} headerKey
 * @returns {boolean}
 * @private
 */
NetSimPacketEditor.prototype.specContainsHeader_ = function (headerKey) {
  return this.packetSpec_.some(function (headerSpec) {
    return headerSpec === headerKey;
  });
};

/**
 * Get just the first bit of the packet binary if it exists, for
 * single-bit sending mode.
 * @returns {string|undefined} a single bit if it exists, as "0" or "1",
 * or undefined if none does.
 */
NetSimPacketEditor.prototype.getFirstBit = function () {
  var binary = this.getPacketBinary();
  return binary.length > 0 ? binary.substr(0, 1) : undefined;
};

/** @param {number} fromAddress */
NetSimPacketEditor.prototype.setFromAddress = function (fromAddress) {
  this.fromAddress = fromAddress;
  this.updateFields_();
};

/** @param {number} packetIndex */
NetSimPacketEditor.prototype.setPacketIndex = function (packetIndex) {
  this.packetIndex = packetIndex;
  this.updateFields_();
};

/** @param {number} packetCount */
NetSimPacketEditor.prototype.setPacketCount = function (packetCount) {
  this.packetCount = packetCount;
  this.updateFields_();
  this.updateRemoveButtonVisibility_();
};

/** @param {number} maxPacketSize */
NetSimPacketEditor.prototype.setMaxPacketSize = function (maxPacketSize) {
  this.maxPacketSize_ = maxPacketSize;
  this.updateBitCounter();
};

/**
 * Show or hide parts of the send UI based on the currently selected encoding
 * mode.
 * @param {EncodingType[]} newEncodings
 */
NetSimPacketEditor.prototype.setEncodings = function (newEncodings) {
  this.enabledEncodingsHash_ = NetSimEncodingControl.encodingsAsHash(newEncodings);
  NetSimEncodingControl.hideRowsByEncoding(this.rootDiv_, newEncodings);
  this.render();
};

/**
 * Helper method that checks this.enabledEncodingsHash_ to see if the given
 * encoding is enabled
 * @param {EncodingType} queryEncoding
 * @returns {boolean} whether or not the given encoding is enabled
 * @private
 */
NetSimPacketEditor.prototype.isEncodingEnabled_ = function (queryEncoding) {
  return this.enabledEncodingsHash_[queryEncoding] === true;
};

/**
 * Change how data is interpreted and formatted by this component, triggering
 * an update of all input fields.
 * @param {number} newChunkSize
 */
NetSimPacketEditor.prototype.setChunkSize = function (newChunkSize) {
  this.currentChunkSize_ = newChunkSize;
  this.updateFields_();
};

/**
 * Change local device bitrate which changes send animation speed.
 * @param {number} newBitRate in bits per second
 */
NetSimPacketEditor.prototype.setBitRate = function (newBitRate) {
  this.bitRate_ = newBitRate;
};

/**
 * Update the visual state of the bit counter to reflect the current
 * message binary length and maximum packet size.
 */
NetSimPacketEditor.prototype.updateBitCounter = function () {
  var size = this.getPacketBinary().length;
  var maxSize = this.maxPacketSize_;
  this.bitCounter_.html(netsimMsg.bitCounter({
    x: size,
    y: maxSize
  }));

  this.bitCounter_.toggleClass('oversized', size > this.maxPacketSize_);
};

/**
 * Handler for the "Remove Packet" button. Calls handler provided by
 * parent, passing self, so that parent can remove this packet.
 * @param {Event} jQueryEvent
 * @private
 */
NetSimPacketEditor.prototype.onRemovePacketButtonClick_ = function (jQueryEvent) {
  var thisButton = $(jQueryEvent.target);
  // We also check parent elements here, because this button uses a font-awesome
  // glyph that can receive the event instead of the actual button.
  if (thisButton.is('[disabled]') || thisButton.parents().is('[disabled]')) {
    return;
  }

  this.removePacketCallback_(this);
};

/**
 * Remove the first bit of the packet binary, used when sending one bit
 * at a time.
 */
NetSimPacketEditor.prototype.consumeFirstBit = function () {
  this.setPacketBinary(this.getPacketBinary().substr(1));
};

},{"../constants":"/home/trevor/code-dot-org/apps/build/js/constants.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEncodingControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPanel.js","./NetSimPacketEditor.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketEditor.html.ejs","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPacketEditor.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var i18n = require('./locale');
  var NetSimConstants = require('./NetSimConstants');
  var NetSimUtils = require('./NetSimUtils');
  var Packet = require('./Packet');

  var EncodingType = NetSimConstants.EncodingType;
  var MessageGranularity = NetSimConstants.MessageGranularity;
  var PacketUIColumnType = NetSimConstants.PacketUIColumnType;

  var getEncodingLabel = NetSimUtils.getEncodingLabel;
  var forEachEnumValue = NetSimUtils.forEachEnumValue;

  /**
  * @name enabledEncodingsHash
  * @type {Object}
  */

  function isEncodingEnabled(queryEncoding) {
    return enabledEncodingsHash[queryEncoding] === true;
  }

  /** @type {Packet.HeaderType[]} */
  var headerFields = packetSpec;

  /** @type {boolean} */
  var showToAddress = headerFields.indexOf(Packet.HeaderType.TO_ADDRESS) > -1;

  /** @type {boolean} */
  var showFromAddress = headerFields.indexOf(Packet.HeaderType.FROM_ADDRESS) > -1;

  /** @type {boolean} */
  var showPacketInfo = headerFields.indexOf(Packet.HeaderType.PACKET_INDEX) > -1 &&
      headerFields.indexOf(Packet.HeaderType.PACKET_COUNT) > -1;

  /** @type {boolean} */
  var usePacketGranularity = (messageGranularity === MessageGranularity.PACKETS);

  /**
   * Write the table header to the page, with the appropriate packet-header columns enabled.
   */
  function tableHeader() {
    ; buf.push('\n      <thead>\n        <tr>\n          <th nowrap class="', escape((46,  PacketUIColumnType.ENCODING_LABEL )), '"></th>\n          ');47; if (showToAddress) { ; buf.push('\n          <th nowrap class="', escape((48,  PacketUIColumnType.TO_ADDRESS )), '">', escape((48,  i18n.to() )), '</th>\n          ');49; } ; buf.push('\n          ');50; if (showFromAddress) { ; buf.push('\n          <th nowrap class="', escape((51,  PacketUIColumnType.FROM_ADDRESS )), '">', escape((51,  i18n.from() )), '</th>\n          ');52; } ; buf.push('\n          ');53; if (showPacketInfo) { ; buf.push('\n          <th nowrap class="', escape((54,  PacketUIColumnType.PACKET_INFO )), '">', escape((54,  i18n.packet() )), '</th>\n          ');55; } ; buf.push('\n          <th class="', escape((56,  PacketUIColumnType.MESSAGE )), '">\n            ', escape((57,  i18n.message() )), '\n            <div class="packet-controls">\n              <span class="netsim-button secondary remove-packet-button" title="', escape((59,  i18n.removePacket() )), '"><i class="fa fa-times"></i></span>\n            </div>\n          </th>\n        </tr>\n      </thead>\n    ');64;
  }

  /**
   * Write a table row to the page for the given data encoding.
   * @param {EncodingType} encodingType
   */
  function editorRow(encodingType) {
    ; buf.push('\n      <tr class="', escape((73,  encodingType )), '">\n        <th nowrap class="', escape((74,  PacketUIColumnType.ENCODING_LABEL )), '">', escape((74,  getEncodingLabel(encodingType) )), '</th>\n        ');75; if (showToAddress) { ; buf.push('\n        <td nowrap class="', escape((76,  PacketUIColumnType.TO_ADDRESS )), '"><input type="text" class="', escape((76,  Packet.HeaderType.TO_ADDRESS )), '" /></td>\n        ');77; } ; buf.push('\n        ');78; if (showFromAddress) { ; buf.push('\n        <td nowrap class="', escape((79,  PacketUIColumnType.FROM_ADDRESS )), '"><input type="text" readonly class="', escape((79,  Packet.HeaderType.FROM_ADDRESS )), '" /></td>\n        ');80; } ; buf.push('\n        ');81; if (showPacketInfo) { ; buf.push('\n        <td nowrap class="', escape((82,  PacketUIColumnType.PACKET_INFO )), '"><input type="text" readonly class="', escape((82,  Packet.HeaderType.PACKET_INDEX )), '" />', escape((82,  i18n._of_() )), '<input type="text" readonly class="', escape((82,  Packet.HeaderType.PACKET_COUNT )), '" /></td>\n        ');83; } ; buf.push('\n        <td class="', escape((84,  PacketUIColumnType.MESSAGE )), '"><div><textarea class="message"></textarea></div></td>\n      </tr>\n    ');86;
  }
; buf.push('\n<table>\n  ');90;
    // Only write the header row if we are using packets
    if (usePacketGranularity) {
      tableHeader();
    }
  ; buf.push('\n  <tbody>\n    ');97;
      // Write a body row for every packet encoding; we hide some of them post-render.
      forEachEnumValue(EncodingType, function (encodingType) {
        if (isEncodingEnabled(encodingType)) {
          editorRow(encodingType);
        }
      });
    ; buf.push('\n  </tbody>\n</table>\n\n');108; if (usePacketGranularity) { ; buf.push('\n  <div class="bit-counter"></div>\n');110; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMyDeviceTab.js":[function(require,module,exports){
/**
 * @overview UI controller for the "My Device" tab in the left column.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimMyDeviceTab.html.ejs');
var NetSimBitRateControl = require('./NetSimBitRateControl');
var NetSimPulseRateControl = require('./NetSimPulseRateControl');
var NetSimChunkSizeControl = require('./NetSimChunkSizeControl');
var NetSimEncodingControl = require('./NetSimEncodingControl');
var NetSimMetronome = require('./NetSimMetronome');
var NetSimGlobals = require('./NetSimGlobals');

/**
 * Generator and controller for "My Device" tab.
 * @param {jQuery} rootDiv
 * @param {RunLoop} runLoop
 * @param {Object} callbacks
 * @param {function} callbacks.chunkSizeChangeCallback
 * @param {function} callbacks.bitRateChangeCallback
 * @param {function} callbacks.encodingChangeCallback
 * @constructor
 */
var NetSimMyDeviceTab = module.exports = function (rootDiv, runLoop, callbacks) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {RunLoop}
   * @private
   */
  this.runLoop_ = runLoop;

  /**
   * Frequency of metronome pulses, in pulses per second
   * @type {number}
   * @private
   */
  this.bitsPerSecond_ = 1;

  /**
   * @type {function}
   * @private
   */
  this.chunkSizeSliderChangeCallback_ = callbacks.chunkSizeChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.bitRateChangeCallback_ = callbacks.bitRateChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.encodingChangeCallback_ = callbacks.encodingChangeCallback;

  /**
   * @type {NetSimMetronome}
   * @private
   */
  this.metronome_ = null;

  /**
   * @type {NetSimPulseRateControl}
   * @private
   */
  this.pulseRateControl_ = null;

  /**
   * @type {NetSimBitRateControl}
   * @private
   */
  this.bitRateControl_ = null;

  /**
   * @type {NetSimChunkSizeControl}
   * @private
   */
  this.chunkSizeControl_ = null;

  /**
   * @type {NetSimEncodingControl}
   * @private
   */
  this.encodingControl_ = null;

  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimMyDeviceTab.prototype.render = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  var renderedMarkup = $(markup({
    level: levelConfig
  }));
  this.rootDiv_.html(renderedMarkup);

  if (levelConfig.showMetronome) {
    this.metronome_ = new NetSimMetronome(this.rootDiv_.find('.metronome'), this.runLoop_);
    this.metronome_.setFrequency(this.bitsPerSecond_);
  }

  if (levelConfig.showPulseRateSlider) {
    this.pulseRateControl_ = new NetSimPulseRateControl(this.rootDiv_.find('.pulse-rate'), 1 / this.bitsPerSecond_, (function (secondsPerBit) {
      this.bitRateChangeCallback_(1 / secondsPerBit);
    }).bind(this));
  }

  if (levelConfig.showBitRateControl) {
    this.bitRateControl_ = new NetSimBitRateControl(this.rootDiv_.find('.bitrate'), this.bitsPerSecond_, this.bitRateChangeCallback_);
    if (levelConfig.lockBitRateControl) {
      this.bitRateControl_.disable();
    }
  }

  if (levelConfig.showChunkSizeControl) {
    this.chunkSizeControl_ = new NetSimChunkSizeControl(this.rootDiv_.find('.chunk-size'), this.chunkSizeSliderChangeCallback_);
    if (levelConfig.lockChunkSizeControl) {
      this.chunkSizeControl_.disable();
    }
  }

  if (levelConfig.showEncodingControls.length > 0) {
    this.encodingControl_ = new NetSimEncodingControl(this.rootDiv_.find('.encoding'), levelConfig, this.encodingChangeCallback_);
  }
};

/**
 * Handler for changing the position of the pulse-rate slider
 * @param {number} secondsPerPulse in seconds per pulse
 * @private
 */
NetSimMyDeviceTab.prototype.pulseRateSliderChange_ = function (secondsPerPulse) {
  this.setBitRate(1 / secondsPerPulse);
};

/**
 * @param {number} bitsPerSecond
 */
NetSimMyDeviceTab.prototype.setBitRate = function (bitsPerSecond) {
  this.bitsPerSecond_ = bitsPerSecond;

  if (this.metronome_) {
    this.metronome_.setFrequency(bitsPerSecond);
  }

  if (this.bitRateControl_) {
    this.bitRateControl_.setValue(bitsPerSecond);
  }

  if (this.pulseRateControl_ && bitsPerSecond < Infinity) {
    this.pulseRateControl_.setValue(1 / bitsPerSecond);
  }
};

/**
 * Update the slider and its label to display the provided value.
 * @param {number} newChunkSize
 */
NetSimMyDeviceTab.prototype.setChunkSize = function (newChunkSize) {
  if (this.chunkSizeControl_) {
    this.chunkSizeControl_.setValue(newChunkSize);
  }
};

/**
 * @param {EncodingType[]} newEncodings
 */
NetSimMyDeviceTab.prototype.setEncodings = function (newEncodings) {
  if (this.encodingControl_) {
    this.encodingControl_.setEncodings(newEncodings);
  }
};

},{"./NetSimBitRateControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitRateControl.js","./NetSimChunkSizeControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimChunkSizeControl.js","./NetSimEncodingControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimMetronome":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMetronome.js","./NetSimMyDeviceTab.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMyDeviceTab.html.ejs","./NetSimPulseRateControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPulseRateControl.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPulseRateControl.js":[function(require,module,exports){
/**
 * @overview UI slider for changing the pulse rate (bitrate) of the local device.
 *           Differs from the bitrate slider in its scale and units.
 * @see NetSimBitRateControl
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

// Utils required only for Function.prototype.inherits()
require('../utils');
var i18n = require('./locale');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for packet size slider/selector
 * @param {jQuery} rootDiv
 * @param {number} initialValue - in seconds per pulse
 * @param {function} sliderChangeCallback
 * @constructor
 */
var NetSimPulseRateControl = module.exports = function (rootDiv, initialValue, sliderChangeCallback) {
  NetSimSlider.DecimalPrecisionSlider.call(this, rootDiv, {
    onChange: sliderChangeCallback,
    value: initialValue,
    min: 0.5,
    max: 5.0,
    step: -0.25
  });

  // Auto-render, unlike our base class
  this.render();
};
NetSimPulseRateControl.inherits(NetSimSlider.DecimalPrecisionSlider);

/**
 * Converts a numeric rate value (in seconds per pulse) into a
 * localized string representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimPulseRateControl.prototype.valueToLabel = function (val) {
  var rounded = Math.floor(val * 100) / 100;
  if (rounded === 1) {
    return i18n.xSecondPerPulse({ x: rounded });
  }
  return i18n.xSecondsPerPulse({ x: rounded });
};

/**
 * Converts a numeric rate value (in seconds per pulse) into a compact
 * localized string representation of that value, used for ends of the slider.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimPulseRateControl.prototype.valueToShortLabel = function (val) {
  return val;
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMyDeviceTab.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="netsim-my-device-tab">\n\n  ');3; if (level.showMetronome) { ; buf.push('\n    <div class="metronome"></div>\n  ');5; } ; buf.push('\n\n  ');7; if (level.showPulseRateSlider) { ; buf.push('\n    <h1>Pulse rate</h1>\n    <div class="pulse-rate"></div>\n  ');10; } ; buf.push('\n\n  ');12; if (level.showBitRateControl) { ; buf.push('\n    <h1>Bitrate</h1>\n    <div class="bitrate"></div>\n  ');15; } ; buf.push('\n\n  ');17; if (level.showChunkSizeControl) { ; buf.push('\n    <h1>Chunk size</h1>\n    <div class="chunk-size"></div>\n  ');20; } ; buf.push('\n\n  ');22; if (level.showEncodingControls.length > 0) { ; buf.push('\n    <div class="encoding"></div>\n  ');24; } ; buf.push('\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMetronome.js":[function(require,module,exports){
/**
 * @overview UI component: An animated SVG metronome.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimMetronome.html.ejs');

/**
 * An SVG "metronome", in the form of a radial meter that fills and resets
 * at a regular interval.
 *
 * @param {jQuery} rootDiv
 * @param {RunLoop} runLoop
 * @constructor
 */
var NetSimMetronome = module.exports = function (rootDiv, runLoop) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * Time of last pulse, in RunLoop simulation time
   * @type {number}
   * @private
   */
  this.lastPulseTime_ = undefined;

  /**
   * Milliseconds between metronome pulses
   * @type {number}
   * @private
   */
  this.pulseIntervalMillis_ = 0;

  /**
   * Normalized progress toward the next pulse, from 0.0 to 1.0
   * @type {number}
   * @private
   */
  this.progress_ = 0;

  /**
   * How long it's been since the last pulse in ms
   * @type {number}
   * @private
   */
  this.pulseAge_ = 0;

  // Register with run loop
  runLoop.render.register(this.render.bind(this));
};

/**
 * Fill the root div with new elements reflecting the current state
 * @param {RunLoop.Clock} clock
 */
NetSimMetronome.prototype.render = function (clock) {
  if (!this.lastPulseTime_) {
    this.lastPulseTime_ = clock.time;
  }

  // An infinite interval means we're effectively paused, so snap to zero
  // progress (visualized as an "empty" meter)
  if (this.pulseIntervalMillis_ === Infinity) {
    this.progress_ = 0;
    this.pulseAge_ = Infinity;
  } else {
    // For a non-infinite interval, update the meter progress value according
    // to the current time.
    this.pulseAge_ = clock.time - this.lastPulseTime_;
    this.progress_ = Math.min(this.pulseAge_ / this.pulseIntervalMillis_, 1);

    if (this.pulseAge_ >= this.pulseIntervalMillis_) {
      // Pulse
      var minimumLastPulseTime = clock.time - this.pulseIntervalMillis_;
      while (this.lastPulseTime_ < minimumLastPulseTime) {
        this.lastPulseTime_ += this.pulseIntervalMillis_;
      }
    }
  }

  var renderedMarkup = $(markup({
    progress: this.progress_,
    pulseAge: this.pulseAge_
  }));
  this.rootDiv_.html(renderedMarkup);
};

/**
 * Change the metronome speed
 * @param {number} pulsesPerSecond
 */
NetSimMetronome.prototype.setFrequency = function (pulsesPerSecond) {
  if (pulsesPerSecond === 0 || pulsesPerSecond === Infinity) {
    this.pulseIntervalMillis_ = Infinity;
    return;
  }
  this.pulseIntervalMillis_ = 1000 / pulsesPerSecond;
};

},{"./NetSimMetronome.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMetronome.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMetronome.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  function moveCommand(x, y) {
    return 'M' + x + ' ' + y;
  }

  function lineCommand(x, y) {
    return 'L ' + x + ' ' + y;
  }

  function arcCommand(rX, rY, rot, largeArcFlag, sweepFlag, finalX, finalY) {
    return 'A ' + rX + ' ' + rY + ', ' + rot + ', ' + largeArcFlag + ', ' + sweepFlag + ', ' + finalX + ' ' + finalY;
  }

  function closeShapeCommand() {
    return 'Z';
  }

  /**
   * Outer radius of progress meter
   * @type {number}
   * @const
   */
  var OUTER_RADUS = 45;

  /**
   * Inner radius of progress meter, and maximum radius of pulse dot
   * @type {number}
   * @const
   */
  var INNER_RADIUS = 30;

  /**
   * How long (in ms) it takes the pulse circle to shrink back to nothing after it appears
   * @type {number}
   * @const
   */
  var PULSE_FALLOFF_MS = 500;

  /**
   * Radius of the inner pulse dot, based on the pulse age.  Starts full size, then shrinks
   * to r=0 over PULSE_FALLOFF_MS.
   * @type {number}
   */
  var pulseFalloffNormalizedProgress = Math.min(pulseAge/ PULSE_FALLOFF_MS, 1);
  var pulseDotRadius = INNER_RADIUS * (1 - pulseFalloffNormalizedProgress);


  /**
   * Given a certain percentage (as a value in the range [0.0-1.0]) this
   * generates a data string for a "path" svg object that draws a partially-filled arc
   * sweeping the appropriate percentage of a circle.
   * Progress begins its sweep at "east" and proceeds clockwise.
   * @param {number} normalizedProgress - number from 0.0 to 1.0
   * @returns {string} data string of commands for SVG path
   */
  function progressMeterSvgPathData(normalizedProgress) {
    var terminalRadians = 2 * Math.PI * normalizedProgress
    var largeArc = (normalizedProgress >= 0.5) ? 1 : 0;
    var sinAngle = Math.sin(terminalRadians);
    var cosAngle = Math.cos(terminalRadians);
    var outerTerminalX = OUTER_RADUS * cosAngle;
    var outerTerminalY = OUTER_RADUS * sinAngle;
    var innerTerminalX = INNER_RADIUS * cosAngle;
    var innerTerminalY = INNER_RADIUS * sinAngle;
    return [
      moveCommand(OUTER_RADUS, 0),
      arcCommand(OUTER_RADUS, OUTER_RADUS, 0, largeArc, 1, outerTerminalX, outerTerminalY),
      lineCommand(innerTerminalX, innerTerminalY),
      arcCommand(INNER_RADIUS, INNER_RADIUS, 0, largeArc, 0, INNER_RADIUS, 0),
      closeShapeCommand()
    ].join(' ');
  }
; buf.push('\n<div class="netsim-metronome">\n  <svg version="1.1" width="100" height="100" xmlns="http://www.w3.org/2000/svg">\n    <g id="centered-group" transform="translate(50,50)">\n      <circle r="48" cx="0" cy="0" fill="darkgray"></circle>\n      <circle r="48" cx="-1" cy="1" fill="lightgray"></circle>\n      <circle r="46" cx="0" cy="0" fill="#f5f5f5"></circle>\n      <circle class="pulse-dot" r="', escape((80,  pulseDotRadius )), '" cx="0" cy="0"></circle>\n      <g transform="rotate(-90)">\n        <path class="progress-meter" d="', escape((82,  progressMeterSvgPathData(progress) )), '"></path>\n      </g>\n    </g>\n  </svg>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMemoryControl.js":[function(require,module,exports){
/**
 * @overview UI slider used to control router memory size.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimConstants = require('./NetSimConstants');
var NetSimUtils = require('./NetSimUtils');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for packet size slider/selector
 * @param {jQuery} rootDiv
 * @param {function} sliderChangeCallback
 * @param {function} sliderStopCallback
 * @constructor
 */
var NetSimMemoryControl = module.exports = function (rootDiv, sliderChangeCallback, sliderStopCallback) {
  NetSimSlider.LogarithmicSlider.call(this, rootDiv, {
    onChange: sliderChangeCallback,
    onStop: sliderStopCallback,
    value: Infinity,
    min: NetSimConstants.BITS_PER_BYTE,
    max: NetSimConstants.BITS_PER_MEGABYTE,
    upperBoundInfinite: true
  });

  // Auto-render, unlike our base class
  this.render();
};
NetSimMemoryControl.inherits(NetSimSlider.LogarithmicSlider);

/**
 * Converts a numeric memory value (in bits) into a compact localized string
 * representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimMemoryControl.prototype.valueToLabel = function (val) {
  return NetSimUtils.bitsToLocalizedRoundedBytesize(val);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPanel.js":[function(require,module,exports){
/**
 * @overview UI component, a log panel (used as "Sent Packets" and
 *           "Received Packets") that is used in the packet-sending
 *           configurations of the simulator.
 *
 * @see INetSimLogPanel for the interface implemented here.
 * @see NetSimBitLogPanel for the component used in bit-sending mode.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var i18n = require('./locale');
var markup = require('./NetSimLogPanel.html.ejs');
var Packet = require('./Packet');
var packetMarkup = require('./NetSimLogPacket.html.ejs');
var NetSimPanel = require('./NetSimPanel');
var NetSimEncodingControl = require('./NetSimEncodingControl');
var NetSimGlobals = require('./NetSimGlobals');

/**
 * How long the "entrance" animation for new messages lasts, in milliseconds.
 * @type {number}
 * @const
 */
var MESSAGE_SLIDE_IN_DURATION_MS = 400;

/**
 * How many packets the log may keep in its history (and in the DOM!)
 * @type {number}
 * @const
 */
var DEFAULT_MAXIMUM_LOG_PACKETS = 50;

/**
 * Object that can be sent data to be browsed by the user at their discretion
 * @interface
 * @name INetSimLogPanel
 */

/**
 * Put data into the log
 * @function
 * @name INetSimLogPanel#log
 * @param {string} binary
 */

/**
 * Show or hide parts of the log based on the currently selected encoding mode.
 * @function
 * @name INetSimLogPanel#setEncodings
 * @param {EncodingType[]} newEncodings
 */

/**
 * Change how binary input in interpreted and formatted in the log.
 * @function
 * @name INetSimLogPanel#setChunkSize
 * @param {number} newChunkSize
 */

/**
 * @function
 * @name INetSimLogPanel#getHeight
 * @returns {number} vertical space that panel currently consumes (including
 *          margins) in pixels.
 */

/**
 * Sets the vertical space that this log panel should consume (including margins)
 * @function
 * @name INetSimLogPanel#setHeight
 * @param {number} heightPixels
 */

/**
 * Generator and controller for message log.
 * @param {jQuery} rootDiv
 * @param {Object} options
 * @param {string} options.logTitle
 * @param {boolean} [options.isMinimized] defaults to FALSE
 * @param {boolean} [options.hasUnreadMessages] defaults to FALSE
 * @param {Packet.HeaderType[]} options.packetSpec
 * @param {number} [options.maximumLogPackets] How many packets the log will
 *        keep before it starts dropping the oldest ones.  Defaults to
 *        DEFAULT_MAXIMUM_LOG_PACKETS.
 * @constructor
 * @augments NetSimPanel
 * @implements INetSimLogPanel
 */
var NetSimLogPanel = module.exports = function (rootDiv, options) {
  /**
   * @type {Packet.HeaderType[]}
   * @private
   */
  this.packetSpec_ = options.packetSpec;

  /**
   * List of controllers for currently displayed packets.
   * @type {Array.<NetSimLogPacket>}
   * @private
   */
  this.packets_ = [];

  /**
   * A message encoding (display) setting.
   * @type {string}
   * @private
   */
  this.currentEncodings_ = [];

  /**
   * Current chunk size (bytesize) for interpreting binary in the log.
   * @type {number}
   * @private
   */
  this.currentChunkSize_ = 8;

  /**
   * Localized panel title
   * @type {string}
   * @private
   */
  this.logTitle_ = options.logTitle;

  /**
   * Whether newly logged messages in this log should be marked as unread
   * @type {boolean}
   * @private
   */
  this.hasUnreadMessages_ = !!options.hasUnreadMessages;

  /**
   * The maximum number of packets this log panel will keep in its memory
   * and in the DOM, so we don't have a forever-growing log.
   * @type {number}
   * @private,,
   */
  this.maximumLogPackets_ = utils.valueOr(options.maximumLogPackets, DEFAULT_MAXIMUM_LOG_PACKETS);

  // Initial render
  NetSimPanel.call(this, rootDiv, {
    className: 'netsim-log-panel',
    panelTitle: options.logTitle,
    beginMinimized: options.isMinimized
  });
};
NetSimLogPanel.inherits(NetSimPanel);

NetSimLogPanel.prototype.render = function () {
  // Create boilerplate panel markup
  NetSimLogPanel.superPrototype.render.call(this);

  // Add our own content markup
  var newMarkup = $(markup({}));
  this.getBody().html(newMarkup);

  // Add a clear button to the panel header
  this.addButton(i18n.clear(), this.onClearButtonPress_.bind(this));

  // Bind reference to scrollArea for use when logging.
  this.scrollArea_ = this.getBody().find('.scroll-area');

  this.updateUnreadCount();
};

/**
 * Remove all packets from the log, resetting its state.
 * @private
 */
NetSimLogPanel.prototype.onClearButtonPress_ = function () {
  this.scrollArea_.empty();
  this.packets_.length = 0;

  this.updateUnreadCount();
};

/**
 * Put a message into the log.
 * @param {string} packetBinary
 * @param {number} packetID
 */
NetSimLogPanel.prototype.log = function (packetBinary, packetID) {

  var packetAlreadyInLog = this.packets_.some(function (packet) {
    return packet.packetID === packetID;
  });

  if (packetAlreadyInLog) {
    return;
  }

  // Remove all packets that are beyond our maximum size
  this.packets_.splice(this.maximumLogPackets_ - 1, this.packets_.length).forEach(function (packet) {
    packet.getRoot().remove();
  });

  var newPacket = new NetSimLogPacket(packetBinary, packetID, {
    packetSpec: this.packetSpec_,
    encodings: this.currentEncodings_,
    chunkSize: this.currentChunkSize_,
    isUnread: this.hasUnreadMessages_,
    markAsReadCallback: this.updateUnreadCount.bind(this)
  });

  newPacket.getRoot().prependTo(this.scrollArea_);

  var scrollTop = this.scrollArea_.scrollTop();

  if (scrollTop === 0) {
    // If scrolled to the top, animate a pretty slidedown
    newPacket.getRoot().hide();
    newPacket.getRoot().slideDown(MESSAGE_SLIDE_IN_DURATION_MS);
  } else {
    // If we're somewhere in the middle of the messages, scroll "down"
    // to maintain our place relative to the messages we're looking at

    // Scrolling only takes the bottom margin into account, not top
    var packetHeight = newPacket.getRoot().outerHeight() + parseInt(newPacket.getRoot().css('marginBottom'));

    this.scrollArea_.scrollTop(scrollTop + packetHeight);
  }

  this.packets_.unshift(newPacket);

  this.updateUnreadCount();
};

NetSimLogPanel.prototype.updateUnreadCount = function () {
  var unreadCount = this.packets_.reduce(function (prev, cur) {
    return prev + (cur.isUnread ? 1 : 0);
  }, 0);

  if (unreadCount > 0) {
    this.setPanelTitle(i18n.appendCountToTitle({
      title: this.logTitle_,
      count: unreadCount
    }));
  } else {
    this.setPanelTitle(this.logTitle_);
  }
};

/**
 * Show or hide parts of the send UI based on the currently selected encoding
 * mode.
 * @param {EncodingType[]} newEncodings
 */
NetSimLogPanel.prototype.setEncodings = function (newEncodings) {
  this.currentEncodings_ = newEncodings;
  this.packets_.forEach(function (packet) {
    packet.setEncodings(newEncodings);
  });
};

/**
 * Change how binary input in interpreted and formatted in the log.
 * @param {number} newChunkSize
 */
NetSimLogPanel.prototype.setChunkSize = function (newChunkSize) {
  this.currentChunkSize_ = newChunkSize;
  this.packets_.forEach(function (packet) {
    packet.setChunkSize(newChunkSize);
  });
};

/**
 * A component/controller for display of an individual packet in the log.
 * @param {string} packetBinary - raw packet data
 * @param {Object} options
 * @param {Packet.HeaderType[]} options.packetSpec
 * @param {EncodingType[]} options.encodings - which display style to use initially
 * @param {number} options.chunkSize - (or bytesize) to use when interpreting and
 *        formatting the data.
 * @param {boolean} options.isUnread - whether this packet should be styled
 *        as "unread" and have a "mark as read" button
 * @param {function} options.markAsReadCallback
 * @constructor
 */
var NetSimLogPacket = function NetSimLogPacket(packetBinary, packetID, options) {

  /**
   * @type {number}
   */
  this.packetID = packetID;

  /**
   * @type {string}
   * @private
   */
  this.packetBinary_ = packetBinary;

  /**
   * @type {Packet.HeaderType[]}
   * @private
   */
  this.packetSpec_ = options.packetSpec;

  /**
   * @type {EncodingType[]}
   * @private
   */
  this.encodings_ = options.encodings;

  /**
   * @type {number}
   * @private
   */
  this.chunkSize_ = options.chunkSize;

  /**
   * @type {boolean}
   */
  this.isUnread = options.isUnread;

  /**
   * @type {boolean}
   */
  this.isMinimized = false;

  /**
   * @type {function}
   * @private
   */
  this.markAsReadCallback_ = options.markAsReadCallback;

  /**
   * Wrapper div that we create once, and fill repeatedly with render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = $('<div>').addClass('packet');
  this.rootDiv_.click(this.markAsRead.bind(this));

  // Initial content population
  this.render();
};

/**
 * Re-render div contents to represent the packet in a different way.
 */
NetSimLogPacket.prototype.render = function () {
  var encodingsHash = NetSimEncodingControl.encodingsAsHash(this.encodings_);
  var rawMarkup = packetMarkup({
    packetBinary: this.packetBinary_,
    packetSpec: this.packetSpec_,
    enabledEncodingsHash: encodingsHash,
    chunkSize: this.chunkSize_,
    isMinimized: this.isMinimized
  });
  var jQueryWrap = $(rawMarkup);
  NetSimLogPanel.adjustHeaderColumnWidths(jQueryWrap);
  NetSimEncodingControl.hideRowsByEncoding(jQueryWrap, this.encodings_);
  this.rootDiv_.html(jQueryWrap);
  this.rootDiv_.find('.expander').click(this.toggleMinimized.bind(this));
  this.rootDiv_.toggleClass('unread', this.isUnread);
};

/**
 * Return root div, for hooking up to a parent element.
 * @returns {jQuery}
 */
NetSimLogPacket.prototype.getRoot = function () {
  return this.rootDiv_;
};

/**
 * Beneath the given root element, adjust widths of packet header columns
 * and fields to match the level's configured packet format.
 * @param {jQuery} rootElement
 */
NetSimLogPanel.adjustHeaderColumnWidths = function (rootElement) {
  var level = NetSimGlobals.getLevelConfig();
  var encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, level.clientInitialPacketHeader);
  var addressBitWidth = encoder.getFieldBitWidth(Packet.HeaderType.TO_ADDRESS);
  var packetInfoBitWidth = encoder.getFieldBitWidth(Packet.HeaderType.PACKET_COUNT);

  // Adjust width of address columns
  // For columns, 50px is sufficient for 4 bits
  var PX_PER_BIT = 50 / 4;
  var addressColumnWidthInPx = PX_PER_BIT * addressBitWidth;

  // Adjust width of address columns
  rootElement.find('td.toAddress, th.toAddress, td.fromAddress, th.fromAddress').css('width', addressColumnWidthInPx + 'px');

  // Adjust width of address input fields
  // For inputs, 3em is sufficient for 4 bits
  var EMS_PER_BIT = 3 / 4;
  var addressFieldWidthInEms = EMS_PER_BIT * addressBitWidth;
  rootElement.find('td.toAddress input, td.fromAddress input').css('width', addressFieldWidthInEms + 'em');

  // Adjust width of packet info column
  // Packet info column uses two fields and an extra 21px for " of "
  var packetInfoColumnWidthInPx = 2 * PX_PER_BIT * packetInfoBitWidth + 21;
  rootElement.find('td.packetInfo, th.packetInfo').css('width', packetInfoColumnWidthInPx + 'px');

  // Adjust width of packet info fields
  var packetInfoFieldWidthInEms = EMS_PER_BIT * packetInfoBitWidth;
  rootElement.find('td.packetInfo input').css('width', packetInfoFieldWidthInEms + 'em');
};

/**
 * Change encoding-display setting and re-render packet contents accordingly.
 * @param {EncodingType[]} newEncodings
 */
NetSimLogPacket.prototype.setEncodings = function (newEncodings) {
  this.encodings_ = newEncodings;
  this.render();
};

/**
 * Change chunk size for interpreting data and re-render packet contents
 * accordingly.
 * @param {number} newChunkSize
 */
NetSimLogPacket.prototype.setChunkSize = function (newChunkSize) {
  this.chunkSize_ = newChunkSize;
  this.render();
};

/**
 * Mark the packet as read, changing its style and removing the "mark as read"
 * button.
 */
NetSimLogPacket.prototype.markAsRead = function () {
  if (this.isUnread) {
    this.isUnread = false;
    this.render();
    this.markAsReadCallback_();
  }
};

NetSimLogPacket.prototype.toggleMinimized = function () {
  this.isMinimized = !this.isMinimized;
  this.render();
};

/**
 * Sets the vertical space that this log panel should consume (including margins)
 * @param {number} heightPixels
 */
NetSimLogPanel.prototype.setHeight = function (heightPixels) {
  var root = this.getRoot().find('.netsim-panel');
  var panelHeader = root.find('h1');
  var panelBody = root.find('.panel-body');

  var panelMargins = parseFloat(root.css('margin-top')) + parseFloat(root.css('margin-bottom'));
  var headerHeight = panelHeader.outerHeight(true);
  var panelBorders = parseFloat(panelBody.css('border-top-width')) + parseFloat(panelBody.css('border-bottom-width'));
  var scrollMargins = parseFloat(this.scrollArea_.css('margin-top')) + parseFloat(this.scrollArea_.css('margin-bottom'));

  // We set the panel height by fixing the size of its inner scrollable
  // area.
  var newScrollViewportHeight = heightPixels - (panelMargins + headerHeight + panelBorders + scrollMargins);
  this.scrollArea_.height(Math.floor(newScrollViewportHeight));
};

/**
 * @returns {number} vertical space that panel currently consumes (including
 *          margins) in pixels.
 */
NetSimLogPanel.prototype.getHeight = function () {
  return this.getRoot().find('.netsim-panel').outerHeight(true);
};

/**
 * After toggling panel visibility, trigger a layout update so send/log panel
 * space is shared correctly.
 * @private
 * @override
 */
NetSimLogPanel.prototype.onMinimizerClick_ = function () {
  NetSimLogPanel.superPrototype.onMinimizerClick_.call(this);
  NetSimGlobals.updateLayout();
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimEncodingControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogPacket.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPacket.html.ejs","./NetSimLogPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPanel.html.ejs","./NetSimPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="scroll-area">\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogPacket.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var NetSimConstants = require('./NetSimConstants');
  var NetSimGlobals = require('./NetSimGlobals');
  var DataConverters = require('./DataConverters');
  var i18n = require('./locale');
  var getEncodingLabel = require('./NetSimUtils').getEncodingLabel;
  var Packet = require('./Packet');

  var level = NetSimGlobals.getLevelConfig();

  var EncodingType = NetSimConstants.EncodingType;
  var PacketUIColumnType = NetSimConstants.PacketUIColumnType;

  var formatAB = DataConverters.formatAB;
  var formatBinary = DataConverters.formatBinary;
  var formatHex = DataConverters.formatHex;
  var alignDecimal = DataConverters.alignDecimal;
  var binaryToAB = DataConverters.binaryToAB;
  var binaryToInt = DataConverters.binaryToInt;
  var binaryToHex = DataConverters.binaryToHex;
  var binaryToDecimal = DataConverters.binaryToDecimal;
  var binaryToAscii = DataConverters.binaryToAscii;
  var binaryToAddressString = function (binaryString) {
    return DataConverters.binaryToAddressString(binaryString, level.addressFormat);
  };
  var formatBinaryForAddressHeader = function (binaryString) {
    return DataConverters.formatBinaryForAddressHeader(binaryString, level.addressFormat);
  };

  /** @type {Packet} */
  var packet = new Packet(packetSpec, packetBinary);

  /** @type {Packet.HeaderType[]} */
  var headerFields = packetSpec;

  var showToAddress = headerFields.indexOf(Packet.HeaderType.TO_ADDRESS) > -1;
  var showFromAddress = headerFields.indexOf(Packet.HeaderType.FROM_ADDRESS) > -1;
  var showPacketInfo = headerFields.indexOf(Packet.HeaderType.PACKET_INDEX) > -1 &&
      headerFields.indexOf(Packet.HeaderType.PACKET_COUNT) > -1;

  /**
  * @name enabledEncodingsHash
  * @type {Object}
  */

  function isEncodingEnabled(queryEncoding) {
    return enabledEncodingsHash[queryEncoding] === true;
  }

  /**
   * Packet one-line summary should only use the highest-level enabled encoding.
   */
  function getOneLinePacketSummary() {
    var messageBinary = packet.getBodyAsBinary();
    if (isEncodingEnabled(EncodingType.ASCII)) {
      return binaryToAscii(messageBinary, chunkSize);
    } else if (isEncodingEnabled(EncodingType.DECIMAL)) {
      return alignDecimal(binaryToDecimal(messageBinary, chunkSize));
    } else if (isEncodingEnabled(EncodingType.HEXADECIMAL)) {
      return formatHex(binaryToHex(messageBinary), chunkSize);
    } else if (isEncodingEnabled(EncodingType.BINARY)) {
      return formatBinary(messageBinary, chunkSize);
    } else if (isEncodingEnabled(EncodingType.A_AND_B)) {
      return formatAB(binaryToAB(messageBinary), chunkSize);
    }
    return messageBinary;
  }

  /**
   * @param {EncodingType} encodingType
   * @param {string} toAddress
   * @param {string} fromAddress
   * @param {string} packetInfo
   * @param {string} message
   */
  function logRowIfEncodingEnabled(encodingType, toAddress, fromAddress, packetInfo, message) {
    if (isEncodingEnabled(encodingType)) {
      ; buf.push('\n        <tr class="', escape((79,  encodingType )), '">\n          <th nowrap class="', escape((80,  PacketUIColumnType.ENCODING_LABEL )), '">', escape((80,  getEncodingLabel(encodingType) )), '</th>\n          ');81; if (showToAddress) { ; buf.push('\n            <td nowrap class="', escape((82,  PacketUIColumnType.TO_ADDRESS )), '">', escape((82,  toAddress )), '</td>\n          ');83; } ; buf.push('\n          ');84; if (showFromAddress) { ; buf.push('\n            <td nowrap class="', escape((85,  PacketUIColumnType.FROM_ADDRESS )), '">', escape((85,  fromAddress )), '</td>\n          ');86; } ; buf.push('\n          ');87; if (showPacketInfo) { ; buf.push('\n            <td nowrap class="', escape((88,  PacketUIColumnType.PACKET_INFO )), '">', escape((88,  packetInfo )), '</td>\n          ');89; } ; buf.push('\n          <td class="', escape((90,  PacketUIColumnType.MESSAGE )), '">', escape((90,  message )), '</td>\n        </tr>\n    ');92;
    }
  }
 ; buf.push('\n  ');96;
    var toAddress = showToAddress ? packet.getHeaderAsBinary(Packet.HeaderType.TO_ADDRESS) : '';
    var fromAddress = showFromAddress ? packet.getHeaderAsBinary(Packet.HeaderType.FROM_ADDRESS) : '';
    var packetIndex = showPacketInfo ? packet.getHeaderAsBinary(Packet.HeaderType.PACKET_INDEX) : '';
    var packetCount = showPacketInfo ? packet.getHeaderAsBinary(Packet.HeaderType.PACKET_COUNT) : '';
    var message = packet.getBodyAsBinary();
  ; buf.push('\n  ');103; if (isMinimized) { ; buf.push('\n      <div class="minimized-packet single-line-with-ellipsis user-data">\n        <i class="fa fa-plus-square expander"></i>\n        ', escape((106,  getOneLinePacketSummary() )), '\n      </div>\n  ');108; } else { ; buf.push('\n    <table class="maximized-packet">\n      <thead>\n        <tr>\n          <th nowrap class="', escape((112,  PacketUIColumnType.ENCODING_LABEL )), '">\n            <i class="fa fa-minus-square expander"></i>\n          </th>\n          ');115; if (showToAddress) { ; buf.push('\n            <th nowrap class="', escape((116,  PacketUIColumnType.TO_ADDRESS )), '">', escape((116,  i18n.to() )), '</th>\n          ');117; } ; buf.push('\n          ');118; if (showFromAddress) { ; buf.push('\n            <th nowrap class="', escape((119,  PacketUIColumnType.FROM_ADDRESS )), '">', escape((119,  i18n.from() )), '</th>\n          ');120; } ; buf.push('\n          ');121; if (showPacketInfo) { ; buf.push('\n            <th nowrap class="', escape((122,  PacketUIColumnType.PACKET_INFO )), '">', escape((122,  i18n.packet() )), '</th>\n          ');123; } ; buf.push('\n          <th class="', escape((124,  PacketUIColumnType.MESSAGE )), '">\n            ', escape((125,  i18n.message() )), '\n          </th>\n        </tr>\n      </thead>\n      <tbody>\n      ');130;
        logRowIfEncodingEnabled(EncodingType.ASCII,
            binaryToAddressString(toAddress),
            binaryToAddressString(fromAddress),
            i18n.xOfYPackets({
              x: binaryToInt(packetIndex),
              y: binaryToInt(packetCount)
            }),
            binaryToAscii(message, chunkSize));

        logRowIfEncodingEnabled(EncodingType.DECIMAL,
            binaryToAddressString(toAddress),
            binaryToAddressString(fromAddress),
            i18n.xOfYPackets({
              x: binaryToInt(packetIndex),
              y: binaryToInt(packetCount)
            }),
            alignDecimal(binaryToDecimal(message, chunkSize)));

        logRowIfEncodingEnabled(EncodingType.HEXADECIMAL,
            binaryToHex(toAddress),
            binaryToHex(fromAddress),
            i18n.xOfYPackets({
              x: binaryToHex(packetIndex),
              y: binaryToHex(packetCount)
            }),
            formatHex(binaryToHex(message), chunkSize));

        logRowIfEncodingEnabled(EncodingType.BINARY,
            formatBinaryForAddressHeader(toAddress, 4),
            formatBinaryForAddressHeader(fromAddress, 4),
            formatBinary(packetIndex + packetCount, level.packetCountBitWidth),
            formatBinary(message, chunkSize));

        logRowIfEncodingEnabled(EncodingType.A_AND_B,
            binaryToAB(toAddress),
            binaryToAB(fromAddress),
            formatAB(binaryToAB(packetIndex + packetCount), level.packetCountBitWidth),
            formatAB(binaryToAB(message), chunkSize));
       ; buf.push('\n      </tbody>\n    </table>\n  ');172; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLocalClientNode.js":[function(require,module,exports){
/**
 * @overview Simulation entity controller reserved for the local client's
 *           simulation node.
 * @see NetSimClientNode for the controller used for other client nodes
 *      in the simulation.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimClientNode = require('./NetSimClientNode');
var NetSimEntity = require('./NetSimEntity');
var NetSimAlert = require('./NetSimAlert');
var NetSimMessage = require('./NetSimMessage');
var NetSimLogger = require('./NetSimLogger');
var NetSimRouterNode = require('./NetSimRouterNode');
var ObservableEvent = require('../ObservableEvent');

var logger = NetSimLogger.getSingleton();
var NetSimConstants = require('./NetSimConstants');
var NetSimGlobals = require('./NetSimGlobals');

var MessageGranularity = NetSimConstants.MessageGranularity;

/**
 * Client model of node being simulated on the local client.
 *
 * Provides special access for manipulating the locally-owned client node in
 * ways that you aren't allowed to manipulate other client nodes.
 *
 * @param {!NetSimShard} shard
 * @param {Object} [clientRow] - Lobby row for this router.
 * @constructor
 * @augments NetSimClientNode
 */
var NetSimLocalClientNode = module.exports = function (shard, clientRow) {
  NetSimClientNode.call(this, shard, clientRow);

  // TODO (bbuchanan): Consider:
  //      Do we benefit from inheritance here?  Would it be cleaner to make this
  //      not-an-entity that manipulates a stock NetSimClientNode?  Will another
  //      developer find it easy to understand how this class works?

  /**
   * Client nodes can be connected to other clients.
   * @type {NetSimClientNode}
   */
  this.myRemoteClient = null;

  /**
   * ID of the router this client node is connected to.  Undefined if
   * not connected to a router.
   * @type {number|undefined}
   * @private
   */
  this.myRouterID_ = undefined;

  /**
   * Set of router controllers enabled for simulation by this node.
   * @type {NetSimRouterNode[]}
   * @private
   */
  this.routers_ = [];

  /**
   * Widget where we will post sent messages.
   * @type {NetSimLogPanel}
   * @private
   */
  this.sentLog_ = null;

  /**
   * Widget where we will post received messages
   * @type {NetSimLogPanel}
   * @private
   */
  this.receivedLog_ = null;

  /**
   * Change event others can observe, which we will fire when we
   * connect or disconnect from a router or remote client
   * @type {ObservableEvent}
   */
  this.remoteChange = new ObservableEvent();

  /**
   * Callback for when something indicates that this node has been
   * disconnected from the instance.
   * @type {function}
   * @private
   */
  this.onNodeLostConnection_ = function () {};

  /**
   * Event registration information
   * @type {Object}
   */
  this.eventKeys = {};
};
NetSimLocalClientNode.inherits(NetSimClientNode);

/**
 * Static async creation method. See NetSimEntity.create().
 * @param {!NetSimShard} shard
 * @param {string} displayName
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        created entity, or null if entity creation failed.
 */
NetSimLocalClientNode.create = function (shard, displayName, onComplete) {
  // TODO (bbuchanan): Modify and return the template node instead of
  // making two in this method.
  var templateNode = new NetSimLocalClientNode(shard);
  templateNode.displayName_ = displayName;
  templateNode.getTable().create(templateNode.buildRow(), function (err, row) {
    if (err) {
      onComplete(err, null);
      return;
    }

    var newNode = new NetSimLocalClientNode(shard, row);
    onComplete(null, newNode);
  });
};

/** Set node's display name.  Does not trigger an update! */
NetSimLocalClientNode.prototype.setDisplayName = function (displayName) {
  this.displayName_ = displayName;
};

/**
 * Configure this node controller to actively simulate, and to post sent and
 * received messages to the given log widgets.
 * @param {!NetSimLogPanel} sentLog
 * @param {!NetSimLogPanel} receivedLog
 */
NetSimLocalClientNode.prototype.initializeSimulation = function (sentLog, receivedLog) {
  this.sentLog_ = sentLog;
  this.receivedLog_ = receivedLog;

  // Subscribe to table changes
  this.eventKeys.nodeTable = this.shard_.nodeTable.tableChange.register(this.onNodeTableChange_.bind(this));
  this.eventKeys.wireTable = this.shard_.wireTable.tableChange.register(this.onWireTableChange_.bind(this));
  this.eventKeys.messageTable = this.shard_.messageTable.tableChange.register(this.onMessageTableChange_.bind(this));
  this.eventKeys.registeredOnShard = this.shard_;

  // Set up initial state from cached rows
  this.onNodeTableChange_();
};

/**
 * Gives the simulating node a chance to unregister from anything it was
 * observing.
 */
NetSimLocalClientNode.prototype.stopSimulation = function () {
  if (this.eventKeys.registeredOnShard) {
    this.eventKeys.registeredOnShard.nodeTable.tableChange.unregister(this.eventKeys.nodeTable);
    this.eventKeys.registeredOnShard.wireTable.tableChange.unregister(this.eventKeys.wireTable);
    this.eventKeys.registeredOnShard.messageTable.tableChange.unregister(this.eventKeys.messageTable);
    this.eventKeys.registeredOnShard = null;
  }
};

/**
 * Ticks the simulation routers
 * @param {!RunLoop.Clock} clock
 */
NetSimLocalClientNode.prototype.tick = function (clock) {
  // TODO (bbuchanan): Move the router collection and ticking the
  // routers up to netsim.js (or elsewhere)
  this.routers_.forEach(function (router) {
    router.tick(clock);
  });
};

/**
 * Give this node an action to take if it detects that it is no longer part
 * of the shard.
 * @param {function} onNodeLostConnection
 */
NetSimLocalClientNode.prototype.setLostConnectionCallback = function (onNodeLostConnection) {
  this.onNodeLostConnection_ = onNodeLostConnection;
};

/**
 * If a client update fails, should attempt an automatic reconnect.
 * @param {NodeStyleCallback} [onComplete]
 */
NetSimLocalClientNode.prototype.update = function (onComplete) {
  onComplete = onComplete || function () {};

  var self = this;
  NetSimLocalClientNode.superPrototype.update.call(this, function (err, result) {
    if (err) {
      logger.error("Local node update failed: " + err.message);
      self.onNodeLostConnection_();
    }
    onComplete(err, result);
  });
};

/**
 * Connect to a remote client node.
 * @param {NetSimClientNode} client
 * @param {!NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.connectToClient = function (client, onComplete) {
  this.connectToNode(client, (function (err, wire) {
    if (err) {
      onComplete(err);
      return;
    }

    // Check whether WE just established a mutual connection with a remote client.
    this.shard_.wireTable.refresh().always((function () {
      this.onWireTableChange_(this.shard_.wireTable.readAll());
      onComplete(err, wire);
    }).bind(this));
  }).bind(this));
};

/**
 * @param {!NetSimRouterNode} router
 * @param {NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.connectToRouter = function (router, onComplete) {
  onComplete = onComplete || function () {};

  logger.info(this.getDisplayName() + ": Connecting to " + router.getDisplayName());
  this.connectToNode(router, (function (err, wire) {
    if (err) {
      onComplete(err);
      return;
    }

    this.myRouterID_ = router.entityID;

    this.remoteChange.notifyObservers(this.getOutgoingWire(), this.getMyRouter());
    onComplete(null, wire);
  }).bind(this));
};

/**
 * Create an appropriate initial wire row for connecting to the given node.
 * Overrides NetSimNode version to add improved connect-to-router functionality.
 * @param {!NetSimNode} otherNode
 * @returns {WireRow}
 * @override
 */
NetSimLocalClientNode.prototype.makeWireRowForConnectingTo = function (otherNode) {
  if (otherNode instanceof NetSimRouterNode) {
    return {
      localNodeID: this.entityID,
      remoteNodeID: otherNode.entityID,
      localAddress: otherNode.getRandomAvailableClientAddress(),
      remoteAddress: otherNode.getAddress(),
      localHostname: this.getHostname(),
      remoteHostname: otherNode.getHostname()
    };
  }
  return NetSimLocalClientNode.superPrototype.makeWireRowForConnectingTo.call(this, otherNode);
};

/**
 * Helper/accessor for router controller instance for the router that this
 * client is directly connected to.
 * @returns {NetSimRouterNode|null} Router we are connected to or null if not
 *          connected to a router at all.
 */
NetSimLocalClientNode.prototype.getMyRouter = function () {
  if (this.myRouterID_ === undefined) {
    return null;
  }

  return _.find(this.routers_, (function (router) {
    return router.entityID === this.myRouterID_;
  }).bind(this));
};

/**
 * @param {NodeStyleCallback} [onComplete]
 */
NetSimLocalClientNode.prototype.disconnectRemote = function (onComplete) {
  onComplete = onComplete || function () {};

  // save the wire so we can destroy it
  var wire = this.getOutgoingWire();

  // remove all local references to connections
  this.cleanUpBeforeDestroyingWire_();

  // destroy wire on API
  wire.destroy((function (err) {
    // We're not going to stop if an error occurred here; the error might
    // just be that the wire was already cleaned up by another node.
    // As long as we make a good-faith disconnect effort, the cleanup system
    // will correct any mistakes and we won't lock up our client trying to
    // re-disconnect.
    if (err) {
      logger.info("Error while disconnecting: " + err.message);
    }
    onComplete(null);
  }).bind(this));
};

/**
 * Common cleanup behavior shared between the synchronous and asynchronous
 * disconnect paths.
 * @private
 */
NetSimLocalClientNode.prototype.cleanUpBeforeDestroyingWire_ = function () {
  this.myRemoteClient = null;
  this.myRouterID_ = undefined;
  this.remoteChange.notifyObservers(null, null);
};

/**
 * Put a message on our outgoing wire, to whatever we are connected to
 * at the moment.
 * @param {string} payload
 * @param {!NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.sendMessage = function (payload, onComplete) {
  var myWire = this.getOutgoingWire();
  if (!myWire) {
    onComplete(new Error('Cannot send message; not connected.'));
    return;
  }

  var localNodeID = myWire.localNodeID;
  var remoteNodeID = myWire.remoteNodeID;

  // Who will be responsible for picking up/cleaning up this message?
  var simulatingNodeID = this.selectSimulatingNode_(localNodeID, remoteNodeID);
  var levelConfig = NetSimGlobals.getLevelConfig();
  var extraHops = levelConfig.minimumExtraHops;
  if (levelConfig.minimumExtraHops !== levelConfig.maximumExtraHops) {
    extraHops = NetSimGlobals.randomIntInRange(levelConfig.minimumExtraHops, levelConfig.maximumExtraHops + 1);
  }

  var self = this;
  NetSimMessage.send(this.shard_, {
    fromNodeID: localNodeID,
    toNodeID: remoteNodeID,
    simulatedBy: simulatingNodeID,
    payload: payload,
    extraHopsRemaining: extraHops
  }, (function (err, row) {
    if (err) {
      logger.error('Failed to send message: ' + err.message + "\n" + JSON.stringify(payload));
      NetSimAlert.error(i18n.sendMessageError());
      onComplete(err);
      return;
    }

    logger.info(this.getDisplayName() + ': Sent message:' + '\nfrom: ' + localNodeID + '\nto  : ' + remoteNodeID + '\nsim : ' + simulatingNodeID + '\nhops: ' + extraHops);

    if (self.sentLog_) {
      self.sentLog_.log(payload, row.id);
    }
    onComplete(null);
  }).bind(this));
};

/**
 * Decide whether the local node or the remote node will be responsible
 * for picking up and cleaning up this message from remote storage.
 * @param {number} localNodeID
 * @param {number} remoteNodeID
 * @returns {number} one of the two IDs provided
 */
NetSimLocalClientNode.prototype.selectSimulatingNode_ = function (localNodeID, remoteNodeID) {
  if (NetSimGlobals.getLevelConfig().messageGranularity === MessageGranularity.BITS) {
    // In simplex wire mode, the local node cleans up its own messages
    // when it knows they are no longer current.
    return localNodeID;
  } else if (this.myRouterID_ !== undefined && this.myRouterID_ === remoteNodeID) {
    // If sending to a router, we will do our own simulation on the router's
    // behalf
    return localNodeID;
  }
  // Default case: The designated recipient must pick up the message.
  return remoteNodeID;
};

/**
 * Sequentially puts a list of messages onto the outgoing wire, to whatever
 * we are connected to at the moment.
 * @param {string[]} payloads
 * @param {!NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.sendMessages = function (payloads, onComplete) {
  if (payloads.length === 0) {
    onComplete(null);
    return;
  }

  this.sendMessage(payloads[0], (function (err, result) {
    if (err) {
      onComplete(err, result);
      return;
    }

    this.sendMessages(payloads.slice(1), onComplete);
  }).bind(this));
};

/**
 * Whenever the node table changes, make needed changes to our collection of
 * routers configured to simulate for the local node.
 * @private
 */
NetSimLocalClientNode.prototype.onNodeTableChange_ = function () {
  var nodeRows = this.shard_.nodeTable.readAll();

  // If our own row is gone, drop everything and handle disconnect.
  if (!this.canFindOwnRowIn(nodeRows)) {
    this.onNodeLostConnection_();
    return;
  }

  // Remove simulating routers that have vanished from remote storage.
  this.routers_ = this.routers_.filter(function (simulatingRouter) {
    var stillExists = nodeRows.some(function (row) {
      return row.id === simulatingRouter.entityID;
    });
    if (!stillExists) {
      simulatingRouter.stopSimulation();
      return false;
    }
    return true;
  });

  // Create and simulate new routers
  nodeRows.filter(function (row) {
    return row.type === NetSimConstants.NodeType.ROUTER;
  }).forEach(function (row) {
    var alreadySimulating = this.routers_.some(function (simulatingRouter) {
      return row.id === simulatingRouter.entityID;
    });

    if (!alreadySimulating) {
      var newRouter = new NetSimRouterNode(this.shard_, row);
      newRouter.initializeSimulation(this.entityID);
      this.routers_.push(newRouter);
    }
  }, this);
};

/**
 * @param {Object[]} nodeRows
 * @returns {boolean} TRUE if own row is in given row collection
 */
NetSimLocalClientNode.prototype.canFindOwnRowIn = function (nodeRows) {
  return nodeRows.some(function (row) {
    return row.id === this.entityID && row.uuid === this.uuid;
  }, this);
};

/**
 * Handler for any wire table change.  Used here to detect mutual
 * connections between client nodes that indicate we can move to a
 * "connected" state or stop trying to connect.
 * @private
 */
NetSimLocalClientNode.prototype.onWireTableChange_ = function () {
  var myWire = this.getOutgoingWire();
  if (!myWire) {
    return;
  }

  var wireRows = this.shard_.wireTable.readAll();
  var myConnectionTargetWireRow, isTargetConnectedToSomeoneElse;

  // Look for mutual connection
  var mutualConnectionRow = _.find(wireRows, (function (row) {
    return row.remoteNodeID === myWire.localNodeID && row.localNodeID === myWire.remoteNodeID;
  }).bind(this));

  if (mutualConnectionRow && !this.myRemoteClient) {
    // New mutual connection! Get the node for our own use.
    NetSimClientNode.get(mutualConnectionRow.localNodeID, this.shard_, (function (err, remoteClient) {
      this.myRemoteClient = remoteClient;
      this.remoteChange.notifyObservers(myWire, this.myRemoteClient);
    }).bind(this));
  } else if (!mutualConnectionRow && this.myRemoteClient) {
    // Remote client disconnected or we disconnected; either way we are
    // no longer connected.
    NetSimAlert.info(i18n.alertPartnerDisconnected());
    this.disconnectRemote();
  } else if (!mutualConnectionRow && !this.myRemoteClient) {
    // The client we're trying to connect to might have connected to
    // someone else; check if they did and if so, stop trying to connect
    myConnectionTargetWireRow = _.find(wireRows, (function (row) {
      return row.localNodeID === myWire.remoteNodeID && row.remoteNodeID !== myWire.localNodeID;
    }).bind(this));
    isTargetConnectedToSomeoneElse = myConnectionTargetWireRow ? wireRows.some(function (row) {
      return row.remoteNodeID === myConnectionTargetWireRow.localNodeID && row.localNodeID === myConnectionTargetWireRow.remoteNodeID;
    }) : undefined;
    if (myConnectionTargetWireRow && isTargetConnectedToSomeoneElse) {
      NetSimAlert.info(i18n.alertConnectionRefused());
      this.disconnectRemote();
    }
  }
};

/**
 * Listens for changes to the message table.  Detects and handles messages
 * sent to this node.
 * @private
 */
NetSimLocalClientNode.prototype.onMessageTableChange_ = function () {
  if (!NetSimGlobals.getLevelConfig().automaticReceive) {
    // In this level, we will not automatically pick up messages directed
    // at us.  We must manually call a receive method instead.
    return;
  }

  if (this.isProcessingMessages_) {
    // We're already in this method, getting called recursively because
    // we are making changes to the table.  Ignore this call.
    return;
  }

  var messages = this.shard_.messageTable.readAll().map((function (row) {
    return new NetSimMessage(this.shard_, row);
  }).bind(this)).filter((function (message) {
    return message.toNodeID === this.entityID && message.simulatedBy === this.entityID;
  }).bind(this));

  if (messages.length === 0) {
    // No messages for us, no work to do
    return;
  }

  // Setup (sync): Set processing flag
  logger.info("Local node received " + messages.length + " messages");
  this.isProcessingMessages_ = true;

  // Step 1 (async): Pull all our messages out of storage
  NetSimEntity.destroyEntities(messages, (function (err) {
    if (err) {
      logger.error('Error pulling message off the wire: ' + err.message);
      this.isProcessingMessages_ = false;
      return;
    }

    // Step 2 (sync): Handle all messages
    messages.forEach(function (message) {
      this.handleMessage_(message);
    }, this);

    // Cleanup (sync): Clear processing flag
    logger.info("Local node finished processing " + messages.length + " messages");
    this.isProcessingMessages_ = false;
  }).bind(this));
};

/**
 * Post message to 'received' log.
 * @param {!NetSimMessage} message
 * @private
 */
NetSimLocalClientNode.prototype.handleMessage_ = function (message) {
  logger.info(this.getDisplayName() + ': Handling incoming message');
  // TODO: How much validation should we do here?
  if (this.receivedLog_) {
    this.receivedLog_.log(message.payload, message.entityID);
  }
};

/**
 * Asynchronously receive the latest message shared between this node
 * and its connected remote node.
 * @param {!NodeStyleCallback} onComplete - given the message as a result, or
 *        NULL if no messages exist.
 */
NetSimLocalClientNode.prototype.getLatestMessageOnSimplexWire = function (onComplete) {
  var myWire = this.getOutgoingWire();
  if (!myWire) {
    onComplete(new Error("Unable to retrieve message; not connected."));
    return;
  }

  // Does an asynchronous request to the message table to ensure we have
  // the latest contents
  var messageTable = this.shard_.messageTable;
  messageTable.refresh().fail(onComplete).done((function () {
    // We only care about rows on our (simplex) wire
    var rowsOnWire = messageTable.readAll().filter((function (row) {
      return myWire.isMessageRowOnSimplexWire(row);
    }).bind(this));

    // If there are no rows, complete successfully but pass null result.
    if (rowsOnWire.length === 0) {
      onComplete(null, null);
      return;
    }

    var lastRow = rowsOnWire[rowsOnWire.length - 1];
    onComplete(null, new NetSimMessage(this.shard_, lastRow));
  }).bind(this));
};

/**
 * Asynchronously set the state of the shared wire.
 * @param {string} newState - probably ought to be "0" or "1"
 * @param {!NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.setSimplexWireState = function (newState, onComplete) {
  this.sendMessage(newState, (function (err) {
    if (err) {
      logger.warn(err.message);
      onComplete(new Error("Failed to set wire state."));
      return;
    }

    // We're not done!  Also do our part to keep the message table clean.
    this.removeMyOldMessagesFromWire_(onComplete);
  }).bind(this));
};

/**
 * Removes all messages on the current wire that are simulated by the local
 * node and are not the latest message on the wire.
 * Used by simplex configurations where we only care about the wire's current
 * (latest) state.
 * @param {!NodeStyleCallback} onComplete
 */
NetSimLocalClientNode.prototype.removeMyOldMessagesFromWire_ = function (onComplete) {
  var myWire = this.getOutgoingWire();
  if (!myWire) {
    onComplete(new Error("Unable to retrieve message; not connected."));
    return;
  }

  // Does an asynchronous request to the message table to ensure we have
  // the latest contents
  var messageTable = this.shard_.messageTable;
  messageTable.refresh().fail(onComplete).done((function () {
    // We only care about rows on our (simplex) wire
    var rowsOnWire = messageTable.readAll().filter(function (row) {
      return myWire.isMessageRowOnSimplexWire(row);
    }, this);

    // "Old" rows are all but the last element (the latest one)
    var oldRowsOnWire = rowsOnWire.slice(0, -1);

    // We are only in charge of deleting messages that we are simulating
    var myOldRowsOnWire = oldRowsOnWire.filter(function (row) {
      return row.simulatedBy === this.entityID;
    }, this);

    // Convert to message entities so we can destroy them
    var myOldMessagesOnWire = myOldRowsOnWire.map(function (row) {
      return new NetSimMessage(this.shard_, row);
    }, this);

    NetSimEntity.destroyEntities(myOldMessagesOnWire, onComplete);
  }).bind(this));
};

},{"../ObservableEvent":"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimAlert":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.js","./NetSimClientNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimClientNode.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimMessage":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMessage.js","./NetSimRouterNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLobby.js":[function(require,module,exports){
/**
 * @overview UI controller for lobby - handles flow for name entry, section
 *           selection, and remote node selection.
 * @see NetSimShardSelectionPanel for name entry and shard selection.
 * @see NetSimRemoteNodeSelectionPanel for implementation of the actual
 *      lobby table.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimNodeFactory = require('./NetSimNodeFactory');
var NetSimClientNode = require('./NetSimClientNode');
var NetSimAlert = require('./NetSimAlert');
var NetSimApiError = require('./NetSimApiError');
var NetSimRouterNode = require('./NetSimRouterNode');
var NetSimShardSelectionPanel = require('./NetSimShardSelectionPanel');
var NetSimRemoteNodeSelectionPanel = require('./NetSimRemoteNodeSelectionPanel');

var logger = require('./NetSimLogger').getSingleton();
var NetSimGlobals = require('./NetSimGlobals');

/**
 * @typedef {Object} ShardChoice
 * @property {string} shardSeed - unique key for shard within level, used in
 *           share URLs
 * @property {string} shardID - unique key for shard in tables API, used as
 *           prefix to table names.  Must be 48 characters or less, and
 *           consistently generatable from a level ID and seed.
 * @property {string} displayName - localized shard name
 */

/**
 * Generator and controller for lobby/connection controls.
 *
 * @param {jQuery} rootDiv
 * @param {NetSim} connection - The shard connection that this
 *        lobby control will manipulate.
 * @param {Object} options
 * @param {DashboardUser} options.user
 * @param {string} options.levelKey
 * @param {string} options.sharedShardSeed
 * @constructor
 * @augments NetSimPanel
 */
var NetSimLobby = module.exports = function (rootDiv, netsim, options) {
  /**
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * Shard connection that this lobby control will manipulate.
   * @type {NetSim}
   * @private
   */
  this.netsim_ = netsim;

  /**
   * @type {string}
   * @private
   */
  this.levelKey_ = options.levelKey;

  /**
   * @type {NetSimShardSelectionPanel}
   * @private
   */
  this.shardSelectionPanel_ = null;

  /**
   * @type {NetSimRemoteNodeSelectionPanel}
   * @private
   */
  this.nodeSelectionPanel_ = null;

  /**
   * @type {NetSimShard}
   * @private
   */
  this.shard_ = null;

  /**
   * @type {NetSimLocalClientNode}
   * @private
   */
  this.myNode_ = null;

  /**
   * Storage for ObservableEvent registration keys, to make sure we
   * can unregister as needed.
   * @type {Object}
   */
  this.eventKeys = {};

  /**
   * @type {DashboardUser}
   * @private
   */
  this.user_ = options.user;

  /**
   * @type {string}
   * @private
   */
  this.displayName_ = options.user.isSignedIn ? options.user.name : '';

  /**
   * Shard options for the current user
   * @type {ShardChoice[]}
   * @private
   */
  this.shardChoices_ = [];

  /**
   * Which shard ID is currently selected
   * @type {string}
   * @private
   */
  this.selectedShardID_ = undefined;

  /**
   * @type {NetSimNode[]}
   * @private
   */
  this.nodesOnShard_ = [];

  /**
   * @type {NetSimNode[]}
   * @private
   */
  this.incomingConnectionNodes_ = [];

  /**
   * @type {NetSimNode}
   * @private
   */
  this.remoteNode_ = null;

  /**
   * Allows multiple methods to have a 'disable' lock on the lobby.
   * @type {Object}
   * @private
   */
  this.disableEverythingKeys_ = {};

  // Figure out the list of user sections, which requires an async request
  // and re-render if the user is signed in.
  if (options.user.isSignedIn) {
    this.getUserSections_((function (sectionList) {
      this.buildShardChoiceList_(sectionList, options.sharedShardSeed);
      this.render();
    }).bind(this));
  } else {
    this.buildShardChoiceList_([], options.sharedShardSeed);
  }

  // Initial render
  this.render();

  // Register for events
  this.netsim_.shardChange.register(this.onShardChange_.bind(this));
};

/**
 * Recreate markup within panel body.
 */
NetSimLobby.prototype.render = function () {
  var isConnectedToShard = this.shard_ !== null;
  if (!isConnectedToShard) {

    // Shard selection panel: Controls for setting display name and picking
    // a section, if they aren't set automatically.
    this.shardSelectionPanel_ = new NetSimShardSelectionPanel(this.rootDiv_, {
      displayName: this.displayName_,
      shardChoices: this.shardChoices_,
      selectedShardID: this.selectedShardID_,
      disableControls: this.isEverythingDisabled()
    }, {
      setNameCallback: this.setDisplayName.bind(this),
      setShardCallback: this.setShardID.bind(this)
    });
  } else {

    // Node selection panel: The lobby list of who we can connect to, and
    // controls for picking one and connecting.
    this.nodeSelectionPanel_ = new NetSimRemoteNodeSelectionPanel(this.rootDiv_, {
      user: this.user_,
      shardID: this.shard_.id,
      nodesOnShard: this.nodesOnShard_,
      incomingConnectionNodes: this.incomingConnectionNodes_,
      remoteNode: this.remoteNode_,
      myNodeID: this.myNode_.entityID,
      disableControls: this.isEverythingDisabled()
    }, {
      addRouterCallback: this.addRouterToLobby.bind(this),
      cancelButtonCallback: this.onCancelButtonClick_.bind(this),
      joinButtonCallback: this.onJoinButtonClick_.bind(this),
      resetShardCallback: this.onResetShardButtonClick_.bind(this)
    });
  }

  this.netsim_.debouncedResizeFooter();
};

NetSimLobby.prototype.updateLayout = function () {
  if (this.nodeSelectionPanel_) {
    this.nodeSelectionPanel_.updateLayout();
  }
};

/**
 * @param {string} displayName
 */
NetSimLobby.prototype.setDisplayName = function (displayName) {
  this.displayName_ = displayName;
  this.render();

  if (this.selectedShardID_ && this.displayName_ && !this.netsim_.isConnectedToShardID(this.selectedShardID_)) {
    this.netsim_.connectToShard(this.selectedShardID_, this.displayName_);
  }
};

/**
 * @param {string} shardID
 */
NetSimLobby.prototype.setShardID = function (shardID) {
  this.selectedShardID_ = shardID;
  this.render();

  if (this.selectedShardID_ && this.displayName_ && !this.netsim_.isConnectedToShardID(this.selectedShardID_)) {
    this.netsim_.connectToShard(this.selectedShardID_, this.displayName_);
  }
};

/**
 * @param {NetSimShard} shard
 * @param {NetSimLocalClientNode} myNode
 * @private
 */
NetSimLobby.prototype.onShardChange_ = function (shard, myNode) {
  // Unregister old handlers
  if (this.eventKeys.registeredShard) {
    this.eventKeys.registeredShard.nodeTable.tableChange.unregister(this.eventKeys.nodeTable);
    this.eventKeys.registeredShard.wireTable.tableChange.unregister(this.eventKeys.wireTable);
    this.registeredShard = undefined;
  }

  this.shard_ = shard;
  this.myNode_ = myNode;

  if (this.shard_) {
    // We got connected to a shard!
    // Register for events
    this.eventKeys.nodeTable = this.shard_.nodeTable.tableChange.register(this.onNodeTableChange_.bind(this));
    this.eventKeys.wireTable = this.shard_.wireTable.tableChange.register(this.onWireTableChange_.bind(this));
    this.eventKeys.registeredShard = this.shard_;

    // Trigger a forced read of the node table
    this.fetchInitialLobbyData_();
  } else {
    // We've been disconnected from a shard
    // Clear our selected shard ID
    this.selectedShardID_ = undefined;

    // Clear cached lobby data
    this.nodesOnShard_.length = 0;
    this.incomingConnectionNodes_.length = 0;

    // Redraw the lobby
    this.render();

    // If there's only one option, try to auto-reconnect
    if (this.shardChoices_.length === 1) {
      this.setShardID(this.shardChoices_[0].shardID);
    }
  }
};

/**
 * Upon connecting to a new shard, we need to trigger a manual read of the
 * node and wire tables to ensure our lobby listing is correct.  Otherwise we'd
 * have to wait until a change was detected in one of those tables.
 * @private
 */
NetSimLobby.prototype.fetchInitialLobbyData_ = function () {
  $.when(this.shard_.nodeTable.refresh(), this.shard_.wireTable.refresh()).fail((function (nodeErr, wireErr) {
    if (nodeErr) {
      logger.warn('Node table refresh failed: ' + nodeErr);
    } else if (wireErr) {
      logger.warn('Wire table refresh failed: ' + wireErr);
    }
  }).bind(this)).done((function () {
    // Because the lobby may not get table-change events from this refresh,
    // manually pass the cached table contents in.
    this.onNodeTableChange_();
    this.onWireTableChange_();

    // If we use routers and there's no router, create a router.
    // TODO: Move this logic to the server, somehow.
    if (NetSimGlobals.getLevelConfig().canConnectToRouters && !this.doesShardContainRouter()) {
      this.addRouterToLobby();
    }
  }).bind(this));
};

/**
 * @returns {boolean} whether the currently cached node data for the shard
 *          includes a router node.
 */
NetSimLobby.prototype.doesShardContainRouter = function () {
  return undefined !== _.find(this.nodesOnShard_, function (shardNode) {
    return shardNode instanceof NetSimRouterNode;
  });
};

/**
 * Generate a new router node, configured according to the current level.
 * The change to the node table should trigger appropriate updates to various
 * UI elements.
 */
NetSimLobby.prototype.addRouterToLobby = function () {
  var enableCallback = this.disableEverything();
  NetSimRouterNode.create(this.shard_, (function (err) {
    enableCallback();
    if (err) {
      var ValidationError = NetSimApiError.ValidationError;
      switch (err.details) {
        case ValidationError.CONFLICT:
          // Another router with the same routerNumber already exists.
          // Ignore this; to the user it looks like it worked!
          logger.warn('Did not create router; ' + 'Another user created a router at the same time.');
          break;

        case ValidationError.LIMIT_REACHED:
          // The server's router limit has been reached.
          // Usually the client will remove the "Add Router" button first.
          logger.warn('Did not create router; Router limit reached.');
          NetSimAlert.warn(i18n.routerLimitReachedError());
          break;

        default:
          // Malformed row or some other unexpected error.
          logger.error("Unable to create router: " + err.message);
          NetSimAlert.error(i18n.addRouterToLobbyError());
      }
    }
  }).bind(this));
};

/**
 * @returns {boolean} TRUE if anything has requested the whole lobby to be
 *          disabled, false otherwise.
 */
NetSimLobby.prototype.isEverythingDisabled = function () {
  return Object.keys(this.disableEverythingKeys_).length > 0;
};

/**
 * Disable all of the lobby controls together.
 * @returns {function} Callback for re-enabling the lobby.
 */
NetSimLobby.prototype.disableEverything = function () {
  var requestKey = utils.createUuid();
  this.disableEverythingKeys_[requestKey] = true;

  if (this.nodeSelectionPanel_) {
    this.nodeSelectionPanel_.disableEverything();
  }

  // Return an 'enable' callback
  return this.enableEverything_.bind(this, requestKey);
};

/**
 * Release a 'disable-hold' on the lobby and re-enable the lobby controls if
 * it was the last such disable-hold.
 * @param {!string} key - a unique identifier for this particular disable request.
 * @private
 */
NetSimLobby.prototype.enableEverything_ = function (key) {
  delete this.disableEverythingKeys_[key];
  if (!this.isEverythingDisabled()) {
    if (this.nodeSelectionPanel_) {
      this.nodeSelectionPanel_.enableEverything();
    }
  }
};

/**
 * Handler for clicking the "Join" button.
 * @param {NetSimClientNode|NetSimRouterNode} nodeToJoin
 */
NetSimLobby.prototype.onJoinButtonClick_ = function (nodeToJoin) {
  var enableCallback = this.disableEverything();
  if (nodeToJoin instanceof NetSimRouterNode) {
    this.netsim_.connectToRouter(nodeToJoin.entityID, enableCallback);
  } else if (nodeToJoin instanceof NetSimClientNode) {
    this.myNode_.connectToClient(nodeToJoin, enableCallback);
  }
};

/**
 * Handler for clicking the "Cancel" button to stop trying to connect to
 * another client.
 * @private
 */
NetSimLobby.prototype.onCancelButtonClick_ = function () {
  var enableCallback = this.disableEverything();
  this.netsim_.disconnectFromRemote(enableCallback);
};

/**
 * Handle for clicking the reset shard button.
 * @private
 */
NetSimLobby.prototype.onResetShardButtonClick_ = function () {
  this.netsim_.resetShard();
};

/**
 * Called whenever a change is detected in the nodes table - which should
 * trigger a refresh of the lobby listing
 * @private
 */
NetSimLobby.prototype.onNodeTableChange_ = function () {
  this.nodesOnShard_ = NetSimNodeFactory.nodesFromRows(this.shard_, this.shard_.nodeTable.readAll());
  this.render();
};

/**
 * Called whenever a change is detected in the wires table.
 * @private
 */
NetSimLobby.prototype.onWireTableChange_ = function () {
  var rows = this.shard_.wireTable.readAll();
  // Update the collection of nodes with connections pointing toward us.
  this.incomingConnectionNodes_ = rows.filter(function (wireRow) {
    return wireRow.remoteNodeID === this.myNode_.entityID;
  }, this).map(function (wireRow) {
    return _.find(this.nodesOnShard_, function (node) {
      return node.entityID === wireRow.localNodeID;
    });
  }, this).filter(function (node) {
    // In case the wire table change comes in before the node table change.
    return node !== undefined;
  });

  // Find outgoing wires
  var outgoingWireRow = _.find(rows, (function (wireRow) {
    return wireRow.localNodeID === this.myNode_.entityID;
  }).bind(this));

  this.remoteNode_ = outgoingWireRow ? _.find(this.nodesOnShard_, function (node) {
    return node.entityID === outgoingWireRow.remoteNodeID;
  }) : null;

  // Re-render with new information
  this.render();
};

/**
 * Send a request to dashboard and retrieve a JSON array listing the
 * sections this user belongs to.
 * @param {function} callback
 * @private
 */
NetSimLobby.prototype.getUserSections_ = function (callback) {
  var memberSectionsRequest = $.ajax({
    dataType: 'json',
    url: '/v2/sections/membership'
  });

  var ownedSectionsRequest = $.ajax({
    dataType: 'json',
    url: '/v2/sections'
  });

  $.when(memberSectionsRequest, ownedSectionsRequest).done(function (result1, result2) {
    var memberSectionData = result1[0];
    var ownedSectionData = result2[0];
    callback(memberSectionData.concat(ownedSectionData));
  });
};

/**
 * Populate the internal cache of shard options, given a set of the current
 * user's sections.
 * @param {Array} sectionList - list of sections this user is a member or
 *        administrator of.  Each section has an id and a name.  May be empty.
 * @param {string} sharedShardSeed - a shard ID present if we reached netsim
 *        via a share link.  We should make sure this shard is an option.
 * @private
 */
NetSimLobby.prototype.buildShardChoiceList_ = function (sectionList, sharedShardSeed) {
  this.shardChoices_.length = 0;

  // If we have a shared shard seed, put it first in the list:
  if (sharedShardSeed) {
    var sharedShardID = this.makeShardIDFromSeed_(sharedShardSeed);
    this.shardChoices_.push({
      shardSeed: sharedShardSeed,
      shardID: sharedShardID,
      displayName: sharedShardSeed
    });
  }

  // Add user's sections to the shard list
  this.shardChoices_ = this.shardChoices_.concat(sectionList.map((function (section) {
    return {
      shardSeed: section.id,
      shardID: this.makeShardIDFromSeed_(section.id),
      displayName: section.name
    };
  }).bind(this)));

  // If there still aren't any options, generate a random shard
  if (this.shardChoices_.length === 0) {
    var seed = utils.createUuid();
    var randomShardID = this.makeShardIDFromSeed_(seed);
    this.shardChoices_.push({
      shardSeed: seed,
      shardID: randomShardID,
      displayName: i18n.myPrivateNetwork()
    });
  }

  // If there's only one possible shard, select it by default
  if (this.shardChoices_.length === 1 && !this.selectedShardID_) {
    this.setShardID(this.shardChoices_[0].shardID);
  }
};

/**
 * Generate a unique shard key from the given seed
 * @param {string} seed
 * @private
 */
NetSimLobby.prototype.makeShardIDFromSeed_ = function (seed) {
  // TODO (bbuchanan) : Hash shard ID, more likely to ensure it's unique
  //                    and fits within 48 characters.
  // Maybe grab this MIT-licensed implementation via node?
  // https://github.com/blueimp/JavaScript-MD5
  return ('ns_' + this.levelKey_ + '_' + seed).substr(0, 48);
};

/**
 * Gets a share URL for the currently-selected shard ID.
 * @returns {string} or empty string if there is no shard selected.
 */
NetSimLobby.prototype.getShareLink = function () {
  if (!this.displayName_) {
    return '';
  }

  var selectedShard = _.find(this.shardChoices_, (function (shard) {
    return shard.shardID === this.selectedShardID_;
  }).bind(this));

  if (selectedShard) {
    var baseLocation = document.location.protocol + '//' + document.location.host + document.location.pathname;
    return baseLocation + '?s=' + selectedShard.shardSeed;
  }

  return '';
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimAlert":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.js","./NetSimApiError":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimApiError.js","./NetSimClientNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimClientNode.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimNodeFactory":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNodeFactory.js","./NetSimRemoteNodeSelectionPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRemoteNodeSelectionPanel.js","./NetSimRouterNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js","./NetSimShardSelectionPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShardSelectionPanel.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShardSelectionPanel.js":[function(require,module,exports){
/**
 * @overview Lobby UI component used for name entry and selecting a shard/class
 *           section.
 * @see NetSimLobby for usage.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var i18n = require('./locale');
var markup = require('./NetSimShardSelectionPanel.html.ejs');
var NetSimPanel = require('./NetSimPanel');

var KeyCodes = require('../constants').KeyCodes;

/**
 * @type {string}
 * @const
 */
var SELECTOR_NONE_VALUE = '';

/**
 * Generator and controller for message log.
 *
 * @param {jQuery} rootDiv
 *
 * @param {Object} options
 * @param {string} options.displayName
 * @param {Array} options.shardChoices
 * @param {string} options.selectedShardID
 *
 * @param {Object} callbacks
 * @param {function} callbacks.setNameCallback
 * @param {function} callbacks.setShardCallback
 *
 * @constructor
 * @augments NetSimPanel
 */
var NetSimShardSelectionPanel = module.exports = function (rootDiv, options, callbacks) {
  /**
   * @type {string}
   * @private
   */
  this.displayName_ = options.displayName;

  /**
   * Shard options for the current user
   * @type {ShardChoice[]}
   * @private
   */
  this.shardChoices_ = utils.valueOr(options.shardChoices, []);

  /**
   * Which shard ID is currently selected
   * @type {string}
   * @private
   */
  this.selectedShardID_ = utils.valueOr(options.selectedShardID, SELECTOR_NONE_VALUE);

  /**
   * @type {function}
   * @private
   */
  this.setNameCallback_ = callbacks.setNameCallback;

  /**
   * @type {function}
   * @private
   */
  this.setShardCallback_ = callbacks.setShardCallback;

  // Initial render
  NetSimPanel.call(this, rootDiv, {
    className: 'netsim-shard-selection-panel',
    panelTitle: i18n.pickASection(),
    userToggleable: false
  });
};
NetSimShardSelectionPanel.inherits(NetSimPanel);

/**
 * Recreate markup within panel body.
 */
NetSimShardSelectionPanel.prototype.render = function () {
  // Create boilerplate panel markup
  NetSimShardSelectionPanel.superPrototype.render.call(this);

  // Add our own content markup
  var newMarkup = $(markup({
    displayName: this.displayName_,
    selectedShardID: this.selectedShardID_,
    shardChoices: this.shardChoices_,
    SELECTOR_NONE_VALUE: SELECTOR_NONE_VALUE
  }));
  this.getBody().html(newMarkup);

  // Bind handlers
  var nameField = this.getBody().find('#netsim-lobby-name');
  nameField.keyup(this.onNameKeyUp_.bind(this));

  var setNameButton = this.getBody().find('#netsim-lobby-set-name-button');
  setNameButton.click(this.setNameButtonClick_.bind(this));

  var shardSelect = this.getBody().find('#netsim-shard-select');
  shardSelect.change(this.onShardSelectChange_.bind(this));
  shardSelect.keyup(this.onShardSelectKeyUp_.bind(this));

  var setShardButton = this.getBody().find('#netsim-shard-confirm-button');
  setShardButton.click(this.setShardButtonClick_.bind(this));

  // At the end of any render we should focus on the earliest unsatisfied
  // field, or if all fields are satisfied, try connecting to the specified
  // shard.
  if (this.displayName_.length === 0) {
    nameField.focus();
  } else if (this.selectedShardID_ === SELECTOR_NONE_VALUE) {
    shardSelect.focus();
  }
};

/**
 * @param {Event} jQueryEvent
 * @private
 */
NetSimShardSelectionPanel.prototype.onNameKeyUp_ = function (jQueryEvent) {
  var name = jQueryEvent.target.value;
  var setNameButton = this.getBody().find('#netsim-lobby-set-name-button');
  setNameButton.attr('disabled', name.length === 0);

  if (name.length > 0 && jQueryEvent.which === KeyCodes.ENTER) {
    this.setNameButtonClick_();
  }
};

/** @private */
NetSimShardSelectionPanel.prototype.setNameButtonClick_ = function () {
  this.setNameCallback_(this.getBody().find('#netsim-lobby-name').val());
};

/**
 * @param {Event} jQueryEvent
 * @private
 */
NetSimShardSelectionPanel.prototype.onShardSelectChange_ = function (jQueryEvent) {
  var shardID = jQueryEvent.target.value;
  var setShardButton = this.getBody().find('#netsim-shard-confirm-button');
  setShardButton.attr('disabled', !shardID || shardID === SELECTOR_NONE_VALUE);
};

/**
 * @param {Event} jQueryEvent
 * @private
 */
NetSimShardSelectionPanel.prototype.onShardSelectKeyUp_ = function (jQueryEvent) {
  var shardID = jQueryEvent.target.value;
  if (shardID && shardID !== SELECTOR_NONE_VALUE && jQueryEvent.which === KeyCodes.ENTER) {
    this.setShardButtonClick_();
  }
};

/** @private */
NetSimShardSelectionPanel.prototype.setShardButtonClick_ = function () {
  this.setShardCallback_(this.getBody().find('#netsim-shard-select').val());
};

},{"../constants":"/home/trevor/code-dot-org/apps/build/js/constants.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./NetSimShardSelectionPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShardSelectionPanel.html.ejs","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimShardSelectionPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var i18n = require('./locale');
; buf.push('\n<div class="content-wrap">\n  <div class="field-box display-name-control">\n    <label for="netsim-lobby-name">', escape((6,  i18n.myName() )), '</label>\n    <input id="netsim-lobby-name" type="text" value="', escape((7,  displayName )), '" ');7; if (displayName.length > 0) { ; buf.push('disabled');7; } ; buf.push(' />\n    ');8; if (displayName.length === 0) { ; buf.push('\n      <input id="netsim-lobby-set-name-button" type="button" value="', escape((9,  i18n.setName() )), '" disabled />\n    ');10; } ; buf.push('\n  </div>\n  ');12; if (displayName.length > 0) { ; buf.push('\n    <div class="field-box shard-control">\n      <label for="netsim-shard-select">', escape((14,  i18n.mySection() )), '</label>\n      <select id="netsim-shard-select" ');15; if (selectedShardID) { ; buf.push('disabled');15; } ; buf.push('>\n        <option value="', escape((16,  SELECTOR_NONE_VALUE )), '">', escape((16,  i18n.dropdownPickOne() )), '</option>\n        ');17;
          var selectedAnyShard = false;
          shardChoices.forEach(function (shardChoice) {
            var attributes = '';
            if (shardChoice.shardID === selectedShardID) {
              attributes = 'selected';
              selectedAnyShard = true;
            }
            ; buf.push('\n              <option value="', escape((26,  shardChoice.shardID )), '" ', escape((26,  attributes )), '>', escape((26,  shardChoice.displayName )), '</option>\n            ');27;
          });
        ; buf.push('\n      </select>\n      ');31; if (!selectedShardID) { ; buf.push('\n        <input id="netsim-shard-confirm-button" type="button" value="', escape((32,  i18n.joinSection() )), '" ');32; if (!selectedAnyShard) { ; buf.push('disabled');32; } ; buf.push(' />\n      ');33; } ; buf.push('\n    </div>\n  ');35; } ; buf.push('\n  <div class="clearfix"></div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRemoteNodeSelectionPanel.js":[function(require,module,exports){
/**
 * @overview Lobby table UI component.
 * @see NetSimLobby for usage.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimPanel = require('./NetSimPanel');
var markup = require('./NetSimRemoteNodeSelectionPanel.html.ejs');
var NodeType = require('./NetSimConstants').NodeType;
var NetSimGlobals = require('./NetSimGlobals');
var NetSimUtils = require('./NetSimUtils');
var NetSimRouterNode = require('./NetSimRouterNode');

/**
 * Apply a very small debounce to lobby buttons to avoid doing extra work
 * as a result of double-clicks and/or scripts that want to click buttons a
 * few thousand times.
 * @const {number}
 */
var BUTTON_DEBOUNCE_DURATION_MS = 100;

/**
 * Generator and controller for lobby node listing, selection, and connection
 * controls.
 *
 * @param {jQuery} rootDiv
 *
 * @param {Object} options
 * @param {DashboardUser} options.user
 * @param {string} options.shardID
 * @param {NetSimNode[]} options.nodesOnShard
 * @param {NetSimNode[]} options.incomingConnectionNodes
 * @param {NetSimNode} options.remoteNode - null if not attempting to connect
 * @param {number} options.myNodeID
 * @param {boolean} options.disableControls
 *
 * @param {Object} callbacks
 * @param {function} callbacks.addRouterCallback
 * @param {function} callbacks.cancelButtonCallback
 * @param {function} callbacks.joinButtonCallback
 * @param {function} callbacks.resetShardCallback
 *
 * @constructor
 * @augments NetSimPanel
 */
var NetSimRemoteNodeSelectionPanel = module.exports = function (rootDiv, options, callbacks) {

  /**
   * @type {DashboardUser}
   * @private
   */
  this.user_ = options.user;

  /**
   * @type {string}
   * @private
   */
  this.shardID_ = options.shardID;

  /**
   * @type {NetSimNode[]}
   * @private
   */
  this.nodesOnShard_ = options.nodesOnShard;

  /**
   * @type {NetSimNode[]}
   * @private
   */
  this.incomingConnectionNodes_ = options.incomingConnectionNodes;

  /**
   * @type {NetSimNode}
   * @private
   */
  this.remoteNode_ = options.remoteNode;

  /**
   * @type {number}
   * @private
   */
  this.myNodeID_ = options.myNodeID;

  function buttonDebounce(callback) {
    return _.debounce(callback, BUTTON_DEBOUNCE_DURATION_MS, {
      leading: true,
      trailing: false
    });
  }

  /**
   * Handler for "Add Router" button
   * @type {function}
   * @private
   */
  this.addRouterCallback_ = buttonDebounce(callbacks.addRouterCallback);

  /**
   * Handler for cancel button (backs out of non-mutual connection)
   * @type {function}
   * @private
   */
  this.cancelButtonCallback_ = buttonDebounce(callbacks.cancelButtonCallback);

  /**
   * Handler for "join" button next to each connectable node.
   * @type {function}
   * @private
   */
  this.joinButtonCallback_ = buttonDebounce(callbacks.joinButtonCallback);

  /**
   * Handler for "reset shard" button click.
   * @type {function}
   * @private
   */
  this.resetShardCallback_ = buttonDebounce(callbacks.resetShardCallback);

  // Initial render
  NetSimPanel.call(this, rootDiv, {
    className: 'netsim-lobby-panel',
    panelTitle: this.getLocalizedPanelTitle(),
    userToggleable: false
  });

  if (options.disableControls) {
    this.disableEverything();
  }
};
NetSimRemoteNodeSelectionPanel.inherits(NetSimPanel);

/**
 * Recreate markup within panel body.
 */
NetSimRemoteNodeSelectionPanel.prototype.render = function () {
  // Clone the reference area (with handlers) before we re-render
  var referenceArea = $('#reference_area').first().clone(true);

  // Create boilerplate panel markup
  NetSimRemoteNodeSelectionPanel.superPrototype.render.call(this);

  // Add our own content markup
  var newMarkup = $(markup({
    controller: this,
    nodesOnShard: this.nodesOnShard_,
    incomingConnectionNodes: this.incomingConnectionNodes_,
    remoteNode: this.remoteNode_
  }));
  this.getBody().html(newMarkup);

  this.updateLayout();

  // Move the reference area to beneath the instructions
  this.getBody().find('.reference-area-placeholder').append(referenceArea);

  // Teachers and admins get a special "Reset Simulation" button
  if (this.canCurrentUserResetShard()) {
    this.addButton(i18n.shardResetButton(), this.resetShardCallback_);
  }

  // Button that takes you to the next level.
  NetSimUtils.makeContinueButton(this);

  this.addRouterButton_ = this.getBody().find('#netsim-lobby-add-router');
  this.addRouterButton_.click(unlessDisabled(this.addRouterCallback_));

  this.getBody().find('.join-button').click(unlessDisabled(this.onJoinClick_.bind(this)));
  this.getBody().find('.accept-button').click(unlessDisabled(this.onJoinClick_.bind(this)));
  this.getBody().find('.cancel-button').click(unlessDisabled(this.cancelButtonCallback_));
};

/**
 * Wrap the provided callback in a check to make sure the target is not disabled.
 * @param {function} callback
 * @returns {function}
 */
function unlessDisabled(callback) {
  return function (jQueryEvent) {
    if (!$(jQueryEvent.target).is('[disabled]')) {
      callback(jQueryEvent);
    }
  };
}

/**
 * Updates the layout of the markup, usually in response to a window
 * resize. Currently just adjusts the height of the lobby table to keep
 * everything onscreen.
 */
NetSimRemoteNodeSelectionPanel.prototype.updateLayout = function () {

  var lobbyTable = this.getBody().find('#netsim-scrolling-lobby');
  var container = this.getBody().closest('#netsim-disconnected');

  if (lobbyTable.is(':visible')) {
    lobbyTable.height("none");
    var overflow = container.prop('scrollHeight') - container.prop('clientHeight');

    if (overflow > 0) {
      var newHeight = lobbyTable.height() - overflow;
      var minHeight = lobbyTable.find('tr').first().outerHeight(true);
      lobbyTable.height(Math.max(newHeight, minHeight));
    }
  }
};

/**
 * @returns {string} a localized panel title appropriate to the current level
 *          configuration
 */
NetSimRemoteNodeSelectionPanel.prototype.getLocalizedPanelTitle = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  if (levelConfig.canConnectToClients && levelConfig.canConnectToRouters) {
    return i18n.connectToANode();
  } else if (levelConfig.canConnectToClients) {
    return i18n.connectToAPeer();
  } else if (levelConfig.canConnectToRouters) {
    if (levelConfig.broadcastMode) {
      return i18n.connectToARoom();
    }
    return i18n.connectToARouter();
  }
  return i18n.connectToANode();
};

/**
 * @returns {string} localized lobby instructions appropriate to the current
 *          level configuration
 */
NetSimRemoteNodeSelectionPanel.prototype.getLocalizedLobbyInstructions = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  if (levelConfig.canConnectToClients && levelConfig.canConnectToRouters) {
    return i18n.lobbyInstructionsGeneral();
  } else if (levelConfig.canConnectToClients) {
    return i18n.lobbyInstructionsForPeers();
  } else if (levelConfig.canConnectToRouters) {
    if (levelConfig.broadcastMode) {
      return i18n.lobbyInstructionsForRooms();
    }
    return i18n.lobbyInstructionsForRouters();
  }
  return i18n.lobbyInstructionsGeneral();
};

/**
 * @param {Event} jQueryEvent
 * @private
 */
NetSimRemoteNodeSelectionPanel.prototype.onJoinClick_ = function (jQueryEvent) {
  var target = $(jQueryEvent.target);
  var nodeID = target.data('nodeId');
  var clickedNode = _.find(this.nodesOnShard_, function (node) {
    return node.entityID === nodeID;
  });

  this.joinButtonCallback_(clickedNode);
};

/**
 * @param {NetSimNode} node
 * @returns {boolean}
 */
NetSimRemoteNodeSelectionPanel.prototype.isMyNode = function (node) {
  return this.myNodeID_ === node.entityID;
};

/**
 * Check whether the level configuration allows connections to the specified
 * node.
 * @param {NetSimNode} connectionTarget
 * @returns {boolean} whether connection to the target is allowed
 */
NetSimRemoteNodeSelectionPanel.prototype.canConnectToNode = function (connectionTarget) {
  // Can't connect to own node
  if (this.isMyNode(connectionTarget)) {
    return false;
  }

  var isClient = connectionTarget.getNodeType() === NodeType.CLIENT;
  var isRouter = connectionTarget.getNodeType() === NodeType.ROUTER;

  // Can't connect to full routers
  if (connectionTarget.isFull()) {
    return false;
  }

  // Permissible connection limited by level configuration
  var levelConfig = NetSimGlobals.getLevelConfig();
  var allowClients = levelConfig.canConnectToClients;
  var allowRouters = levelConfig.canConnectToRouters;
  return isClient && allowClients || isRouter && allowRouters;
};

/**
 * @returns {boolean} TRUE if we have an open outgoing connection request.
 */
NetSimRemoteNodeSelectionPanel.prototype.hasOutgoingRequest = function () {
  return !!this.remoteNode_;
};

/**
 * For use with Array.prototype.filter()
 * @param {NetSimNode} node
 * @returns {boolean} TRUE if the given node should show up in the lobby
 */
NetSimRemoteNodeSelectionPanel.prototype.shouldShowNode = function (node) {
  var levelConfig = NetSimGlobals.getLevelConfig();
  var isClient = node.getNodeType() === NodeType.CLIENT;
  var isRouter = node.getNodeType() === NodeType.ROUTER;
  var showClients = levelConfig.showClientsInLobby;
  var showRouters = levelConfig.showRoutersInLobby;
  return isClient && showClients || isRouter && showRouters;
};

/**
 * @returns {boolean} TRUE if we expect the current user to have permission to
 *          perform a shard reset.  Only governs display of shard reset button,
 *          actual reset is authenticated on the server.
 */
NetSimRemoteNodeSelectionPanel.prototype.canCurrentUserResetShard = function () {
  if (!this.user_) {
    return false;
  } else if (this.user_.isAdmin) {
    return true;
  }

  // Find a section ID in the current shard ID
  var matches = /_(\d+)$/.exec(this.shardID_);
  if (!matches) {
    return false;
  }

  // matches[1] is the first capture group (\d+), the numeric section ID.
  var sectionID = parseInt(matches[1], 10);
  return this.user_.ownsSection(sectionID);
};

/**
 * @returns {boolean} TRUE if it's currently possible to add a new router.
 *          Drives whether the "Add Router" button should be displayed.
 */
NetSimRemoteNodeSelectionPanel.prototype.canAddRouter = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();
  if (this.hasOutgoingRequest() || !levelConfig.showAddRouterButton) {
    return false;
  }

  var routerLimit = NetSimRouterNode.getMaximumRoutersPerShard();
  var routerCount = this.nodesOnShard_.filter(function (node) {
    return NodeType.ROUTER === node.getNodeType();
  }).length;
  return routerCount < routerLimit;
};

/**
 * Disable all of the buttons within the panel (does not apply to panel-header
 * buttons!)
 */
NetSimRemoteNodeSelectionPanel.prototype.disableEverything = function () {
  this.getBody().find('.netsim-button').attr('disabled', true);
};

/**
 * Enable all of the buttons within the panel (does not apply to panel-header
 * buttons!)
 */
NetSimRemoteNodeSelectionPanel.prototype.enableEverything = function () {
  this.getBody().find('.netsim-button').removeAttr('disabled');
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./NetSimRemoteNodeSelectionPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRemoteNodeSelectionPanel.html.ejs","./NetSimRouterNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRemoteNodeSelectionPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimGlobals = require('./NetSimGlobals');
var NodeType = require('./NetSimConstants').NodeType;

/** @type {function} */
var getAssetUrl = NetSimGlobals.getAssetUrlFunction();

/** @type {NetSimLevelConfiguration} */
var levelConfig = NetSimGlobals.getLevelConfig();

/**
 * @typedef {Object} RowMetadata
 * @property {number} nodeID
 * @property {string} classAttr
 * @property {string} displayName
 * @property {string} status
 */

/**
 * For use with Array.prototype.filter()
 * @param {NetSimNode} node
 * @returns {boolean}
 */
var omitIncomingConnectionNodes = function (node) {
  return undefined === _.find(incomingConnectionNodes, function (connectionRequestNode) {
        return connectionRequestNode.entityID === node.entityID;
      });
};

/**
 * For use with Array.prototype.filter()
 * @param {NetSimNode} node
 * @returns {boolean}
 */
var omitOutgoingRequestTargets = function (node) {
  return !remoteNode || (remoteNode.entityID !== node.entityID);
};

/**
 * For use with Array.prototype.map()
 * @param {NetSimNode} node
 * @returns {RowMetadata}
 */
var nodeToRowMetadata = function (node) {
  var displayName = node.getDisplayName();
  var sortKey = displayName;
  var classes = ['user-row'];

  if (node.getNodeType() === NodeType.ROUTER) {
    // Sort routers by left-padded router number (looks like natural sort)
    sortKey = ('000' + node.routerNumber).slice(-3);
    classes = ['router-row'];
  }

  if (controller.isMyNode(node)) {
    classes.push('own-row');
  }

  return {
    nodeID: node.entityID,
    sortKey: sortKey,
    classAttr: classes.join(' '),
    displayName: displayName,
    hostname: node.getHostname(),
    status: node.getStatus(),
    isFull: node.isFull(),
    canConnectToNode: controller.canConnectToNode(node)
  };
};

/**
 * For use with Array.prototype.sort()
 * @param {RowMetadata} a
 * @param {RowMetadata} b
 * @returns {number}
 */
var lobbySort = function (a, b) {
  return (a.sortKey > b.sortKey) ? 1 : -1;
};

var lobbyRows = nodesOnShard
    .filter(controller.shouldShowNode.bind(controller))
    .filter(omitIncomingConnectionNodes)
    .filter(omitOutgoingRequestTargets)
    .map(nodeToRowMetadata)
    .sort(lobbySort);

var requestRows = incomingConnectionNodes
    .filter(controller.shouldShowNode.bind(controller))
    .filter(omitOutgoingRequestTargets)
    .map(nodeToRowMetadata)
    .sort(lobbySort);

var outgoingRequestRows = (remoteNode ? [ remoteNode ] : [])
    .filter(controller.shouldShowNode.bind(controller))
    .map(nodeToRowMetadata);

/**
 * @param {string} buttonText
 * @param {string} buttonID
 * @param {string[]} extraClasses
 * @param {Object} extraAttributes
 * @returns {string} markup for NetSim-style button
 */
function buttonMarkup(buttonText, buttonID, extraClasses, extraAttributes) {
  var classes = utils.valueOr(extraClasses, []);
  classes.push('netsim-button');
  classes.push('large-button');

  extraAttributes = utils.valueOr(extraAttributes, {});

  var markup = '<span class="' + classes.join(' ') + '" ';

  // ID attribute for span tag
  if (buttonID) {
    markup += 'id="' + buttonID + '" ';
  }

  // Extra attributes for span tag
  for (var key in extraAttributes) {
    if (extraAttributes.hasOwnProperty(key)) {
      markup += key + '="' + extraAttributes[key] + '" ';
    }
  }

  markup += '>' + buttonText + '</span>';
  return markup;
}

function writeBeginTable(classname) {
  if (classname) {
    ; buf.push('<table class="', escape((135, classname)), '">');135;
  } else {
    ; buf.push('<table>');137;
  }
}

function writeEndTable() {
  ; buf.push('</table>');142;
}

function writeBeginTbody() {
  ; buf.push('<tbody>');146;
}

function writeEndTbody() {
  ; buf.push('</tbody>');150;
}

function writeHeader(headerText) {
  ; buf.push('\n    <thead>\n      <tr>\n        <th colspan="3">', escape((157,  headerText )), '</th>\n      </tr>\n    </thead>\n  ');160;
}

function writeEmptyRow(contents) {
  contents = utils.valueOr(contents, '');
  ; buf.push('\n    <tr>\n      <td colspan="3" class="empty-row">', (167,  contents ), '</td>\n    </tr>\n  ');169;
}

function writeNodeRow(row, nodeStatus, buttonType, addlClass) {
    var button;
    if (buttonType === 'join-button') {
      button = buttonMarkup(i18n.buttonJoin(), undefined, [buttonType, addlClass], { 'data-node-id': row.nodeID });
    } else if (buttonType === 'accept-button') {
      button = buttonMarkup(i18n.buttonAccept(), undefined, [buttonType, addlClass], { 'data-node-id': row.nodeID });
    } else if (buttonType === 'cancel-button') {
      button = buttonMarkup(i18n.buttonCancel(), undefined, [buttonType, addlClass, 'secondary'], { 'data-node-id': row.nodeID });
    } else if (buttonType === 'full-button') {
      button = buttonMarkup(i18n.buttonFull(), undefined, [buttonType, addlClass], { 'disabled': 'disabled' });
    }
  ; buf.push('\n    <tr>\n      <td nowrap>', escape((185,  row.displayName )), ' <small>(', escape((185,  row.hostname )), ')</small></td>\n      ');186; if (button) { ; buf.push('\n        <td>', (187,  nodeStatus ), '</td>\n        <td class="button-column">\n          ', (189,  button ), '\n        </td>\n      ');191; } else { ; buf.push('\n        <td colspan="2">', (192,  nodeStatus ), '</td>\n      ');193; } ; buf.push('\n    </tr>\n  ');195;
}

; buf.push('\n<div class="content-wrap">\n  <div class="instructions">\n    ', escape((201,  controller.getLocalizedLobbyInstructions() )), '\n    <div class="reference-area-placeholder"></div>\n  </div>\n  <div class="controls">\n\n    ');206;
      // Outgoing request table (hidden if empty)
      if (outgoingRequestRows.length > 0) {
        writeBeginTable();
        writeHeader(i18n.outgoingConnectionRequests());
        writeBeginTbody();
        outgoingRequestRows.forEach(function (row) {
          var outgoingStatus = i18n.lobbyStatusWaitingForOther({
            spinner: '<img src="' + getAssetUrl('media/netsim/loading.gif') + '" />',
            otherName: row.displayName,
            otherStatus: row.status
          });
          writeNodeRow(row, outgoingStatus, 'cancel-button', row.classAttr);
        });
        writeEndTbody();
        writeEndTable();
      }

      // Incoming requests table (hidden if empty)
      if (requestRows.length > 0) {
        writeBeginTable();
        writeHeader(i18n.incomingConnectionRequests());
        writeBeginTbody();
        requestRows.forEach(function (row) {
          var buttonType;
          if (!controller.hasOutgoingRequest() && row.canConnectToNode) {
            buttonType = 'accept-button';
          }
          var incomingStatus = i18n.lobbyStatusWaitingForYou();
          writeNodeRow(row, incomingStatus, buttonType, row.classAttr);
        });
        writeEndTbody();
        writeEndTable();
      }
    ; buf.push('\n\n    ');242;
      // Primary lobby list
      writeBeginTable("nomargin");
      writeHeader(i18n.lobby());
      writeEndTable();
    ; buf.push('\n    <div id="netsim-scrolling-lobby">\n    ');249;
      writeBeginTable();
      writeBeginTbody();
      lobbyRows.forEach(function (row) {
        var buttonType;
        if (!controller.hasOutgoingRequest()) {
          if (row.isFull) {
            buttonType = 'full-button';
          } else if (row.canConnectToNode) {
            buttonType = 'join-button';
          }
        }
        writeNodeRow(row, row.status, buttonType, row.classAttr);
      });

      var buttons = [];

      if (controller.canAddRouter()) {
        var buttonText = levelConfig.broadcastMode ? i18n.addRoom() : i18n.addRouter();
        buttons.push(buttonMarkup(
            buttonText,
            'netsim-lobby-add-router',
            ['secondary']
        ));
      }

      if (levelConfig.showLogBrowserButton) {
        buttons.push(buttonMarkup(
            i18n.logBrowserButton(),
            'show-router-log-modal',
            ['secondary'],
            {
              'data-toggle':'modal',
              'data-target':'#router-log-modal'
            }
        ));
      }

      if (buttons.length > 0) {
        writeEmptyRow(buttons.join(' '));
      } else if (lobbyRows.length === 0) {
        writeEmptyRow(i18n.lobbyIsEmpty());
      }

      writeEndTbody();
      writeEndTable();
    ; buf.push('\n    </div>\n\n  </div>\n  <div class="clear"></div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNodeFactory.js":[function(require,module,exports){
/**
 * @overview Utility methods for generating the right kinds of node controllers
 *           from raw node table rows.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var NetSimConstants = require('./NetSimConstants');

var NodeType = NetSimConstants.NodeType;

var NetSimNodeFactory = module.exports;

/**
 * Given a set of rows from the node table on a shard, gives back a set of node
 * controllers (of appropriate types).
 * @param {!NetSimShard} shard
 * @param {!Array.<Object>} nodeRows
 * @throws when a row doesn't have a mappable node type.
 * @return {Array.<NetSimNode>} nodes for the rows
 */
NetSimNodeFactory.nodesFromRows = function (shard, nodeRows) {
  return nodeRows.map(NetSimNodeFactory.nodeFromRow.bind(this, shard));
};

/**
 * Given a row from the node table on a shard, gives back a node controllers
 * (of appropriate types).
 * @param {!NetSimShard} shard
 * @param {!Object} nodeRow
 * @throws when the row doesn't have a mappable node type.
 * @return {NetSimNode} node for the rows
 */
NetSimNodeFactory.nodeFromRow = function (shard, nodeRow) {
  if (nodeRow.type === NodeType.CLIENT) {
    var NetSimClientNode = require('./NetSimClientNode');
    return new NetSimClientNode(shard, nodeRow);
  } else if (nodeRow.type === NodeType.ROUTER) {
    var NetSimRouterNode = require('./NetSimRouterNode');
    return new NetSimRouterNode(shard, nodeRow);
  }

  // Oops!  We probably shouldn't ever get here.
  throw new Error("Unable to map row to node.");
};

},{"./NetSimClientNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimClientNode.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimRouterNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimRouterNode.js":[function(require,module,exports){
/**
 * @overview Router node simulation entity.  Also contains logic for the
 *           auto-DNS system.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var i18n = require('./locale');
var NetSimConstants = require('./NetSimConstants');
var NetSimUtils = require('./NetSimUtils');
var NetSimNode = require('./NetSimNode');
var NetSimEntity = require('./NetSimEntity');
var NetSimLogEntry = require('./NetSimLogEntry');
var NetSimLogger = require('./NetSimLogger');
var NetSimWire = require('./NetSimWire');
var NetSimMessage = require('./NetSimMessage');
var ObservableEvent = require('../ObservableEvent');
var Packet = require('./Packet');
var DataConverters = require('./DataConverters');
var NetSimNodeFactory = require('./NetSimNodeFactory');

var _ = utils.getLodash();

var serializeNumber = NetSimUtils.serializeNumber;
var deserializeNumber = NetSimUtils.deserializeNumber;

var asciiToBinary = DataConverters.asciiToBinary;

var DnsMode = NetSimConstants.DnsMode;
var NodeType = NetSimConstants.NodeType;
var BITS_PER_BYTE = NetSimConstants.BITS_PER_BYTE;

var logger = NetSimLogger.getSingleton();
var NetSimGlobals = require('./NetSimGlobals');

/**
 * @type {number}
 * @readonly
 */
var MAX_CLIENT_CONNECTIONS = 6;

/**
 * Conveniently, a router's address in its local network is always zero.
 * @type {number}
 * @readonly
 */
var ROUTER_LOCAL_ADDRESS = 0;

/**
 * Address that can only be used for the auto-dns node.
 * May eventually be replaced with a dynamically assigned address.
 * @type {number}
 * @readonly
 */
var AUTO_DNS_RESERVED_ADDRESS = 15;

/**
 * Hostname assigned to the automatic dns 'node' in the local network.
 * There will only be one of these, so it can be simple.
 * @type {string}
 * @readonly
 */
var AUTO_DNS_HOSTNAME = 'dns';

/**
 * Value the auto-DNS will return instead of an address when it can't
 * locate a node with the given hostname in the local network.
 * @type {string}
 * @readonly
 */
var AUTO_DNS_NOT_FOUND = 'NOT_FOUND';

/**
 * Maximum packet lifetime in the router queue, sort of a primitive Time-To-Live
 * system that helps prevent a queue from being indefinitely blocked by a very
 * large packet.  Packets that exceed this time will silently fail delivery.
 * @type {number}
 * @readonly
 */
var PACKET_MAX_LIFETIME_MS = 10 * 60 * 1000;

/**
 * To avoid calculating a totally unreasonable number of addresses, this is
 * the most addresses we will consider when picking one for a new host.
 * This means full support up to a 12-bit address part, which should be more
 * than enough.
 * @type {number}
 */
var ADDRESS_OPTION_LIMIT = 4096;

/**
 * Client model of simulated router
 *
 * Represents the client's view of a given router, provides methods for
 *   letting the client interact with the router, and wraps the client's
 *   work doing part of the router simulation.
 *
 * A router -exists- when it has a row in the lobby table of type 'router'
 * A router is connected to a user when a 'user' row exists in the lobby
 *   table that has a status 'Connected to {router ID} by wires {X, Y}'.
 * A router will also share a wire (simplex) or wires (duplex) with each user,
 *   which appear in the wire table.
 *
 * @param {!NetSimShard} shard
 * @param {RouterRow} [routerRow] - Lobby row for this router.
 * @constructor
 * @augments NetSimNode
 */
var NetSimRouterNode = module.exports = function (shard, row) {
  row = row !== undefined ? row : {};
  NetSimNode.call(this, shard, row);

  var levelConfig = NetSimGlobals.getLevelConfig();

  /**
   * This router's identifying number, which gets translated into its address.
   * Should be unique among routers on the shard.
   * @type {number}
   */
  this.routerNumber = row.routerNumber;

  /**
   * Unix timestamp (local) of router creation time.
   * @type {number}
   */
  this.creationTime = utils.valueOr(row.creationTime, Date.now());

  /**
   * Sets current DNS mode for the router's local network.
   * This value is manipulated by all clients.
   * @type {DnsMode}
   * @private
   */
  this.dnsMode = utils.valueOr(row.dnsMode, levelConfig.defaultDnsMode);

  /**
   * Sets current DNS node ID for the router's local network.
   * This value is manipulated by all clients.
   * @type {number}
   * @private
   */
  this.dnsNodeID = row.dnsNodeID;

  /**
   * Speed (in bits per second) at which messages are processed.
   * @type {number}
   */
  this.bandwidth = utils.valueOr(deserializeNumber(row.bandwidth), levelConfig.defaultRouterBandwidth);

  /**
   * Amount of data (in bits) that the router queue can hold before it starts
   * dropping packets.
   * @type {number}
   */
  this.memory = utils.valueOr(deserializeNumber(row.memory), levelConfig.defaultRouterMemory);

  /**
   * Percent chance (0-1) that a packet being routed will be dropped for no
   * reason.
   * @type {number}
   */
  this.randomDropChance = utils.valueOr(row.randomDropChance, levelConfig.defaultRandomDropChance);

  /**
   * Determines a subset of connection and message events that this
   * router will respond to, only managing events from the given node ID,
   * to avoid conflicting with other clients also simulating this router.
   *
   * Not persisted on server.
   *
   * @type {number}
   * @private
   */
  this.simulateForSender_ = undefined;

  /**
   * Local cache of the last tick time in the local simulation.
   * Allows us to schedule/timestamp events that don't happen inside the
   * tick event.
   * @type {number}
   * @private
   */
  this.simulationTime_ = 0;

  /**
   * Packet format specification this router will use to parse, route, and log
   * packets that it receives.  Set on router that is simulated by client.
   *
   * Not persisted on server.
   *
   * @type {Packet.HeaderType[]}
   * @private
   */
  this.packetSpec_ = [];

  /**
   * Local cache of our remote row, used to decide whether our state has
   * changed.
   * 
   * Not persisted to server.
   * 
   * @type {Object}
   * @private
   */
  this.stateCache_ = {};

  /**
   * Event others can observe, which we fire when our own remote row changes.
   * 
   * @type {ObservableEvent}
   */
  this.stateChange = new ObservableEvent();

  /**
   * Event others can observe, which we fire when the router statistics
   * change (which may be very frequent...)
   *
   * @type {ObservableEvent}
   */
  this.statsChange = new ObservableEvent();

  /**
   * Local cache of wires attached to this router, used for detecting and
   * broadcasting relevant changes.
   *
   * Not persisted on server.
   *
   * @type {Array}
   * @private
   */
  this.myWireRowCache_ = [];

  /**
   * Event others can observe, which we fire when the router's set of wires
   * changes indicating a change in the local network.
   *
   * @type {ObservableEvent}
   */
  this.wiresChange = new ObservableEvent();

  /**
   * Local cache of log rows associated with this router, used for detecting
   * and broadcasting relevant changes.
   * 
   * @type {Array}
   * @private
   */
  this.myLogRowCache_ = [];

  /**
   * Event others can observe, which we fire when the router's log content
   * changes.
   * 
   * @type {ObservableEvent}
   */
  this.logChange = new ObservableEvent();

  /**
   * Whether router is in the middle of work.  Keeps router from picking up
   * its own change notifications or interrupting its own processes.
   * @type {boolean}
   * @private
   */
  this.isRouterProcessing_ = false;

  /**
   * Local cache of messages that need to be processed by (any simulation
   * of) the router.  Used for tracking router memory, throughput, etc.
   * @type {NetSimMessage[]}
   * @private
   */
  this.routerQueueCache_ = [];

  /**
   * Set of scheduled 'routing events'
   * @type {Object[]}
   * @private
   */
  this.localRoutingSchedule_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.isAutoDnsProcessing_ = false;

  /**
   * Local cache of messages that need to be processed by (any simulation
   * of) the auto-DNS. Used for stats and limiting.
   * @type {NetSimMessage[]}
   * @private
   */
  this.autoDnsQueue_ = [];

  /**
   * Most clients that can be connected to this router.
   * Moved to instance variable so that tests can override it in certain cases.
   * @type {number}
   * @private
   */
  this.maxClientConnections_ = MAX_CLIENT_CONNECTIONS;
};
NetSimRouterNode.inherits(NetSimNode);

/**
 * Static async creation method. See NetSimEntity.create().
 * @param {!NetSimShard} shard
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        created entity, or null if entity creation failed.
 */
NetSimRouterNode.create = function (shard, onComplete) {
  var nextRouterNumber = 1;
  shard.nodeTable.readAll().forEach(function (node) {
    if (NodeType.ROUTER === node.type && node.routerNumber >= nextRouterNumber) {
      nextRouterNumber = node.routerNumber + 1;
    }
  });

  var entity = new NetSimRouterNode(shard, { routerNumber: nextRouterNumber });
  entity.getTable().create(entity.buildRow(), function (err, row) {
    if (err) {
      onComplete(err, null);
      return;
    }
    onComplete(null, new NetSimRouterNode(shard, row));
  });
};

/**
 * Static async retrieval method.  See NetSimEntity.get().
 * @param {!number} routerID - The row ID for the entity you'd like to find.
 * @param {!NetSimShard} shard
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        found entity, or null if entity search failed.
 */
NetSimRouterNode.get = function (routerID, shard, onComplete) {
  NetSimEntity.get(NetSimRouterNode, routerID, shard, onComplete);
};

/**
 * @typedef {Object} RouterRow
 * @property {number} creationTime - Unix timestamp (local)
 * @property {number} bandwidth - Router max transmission/processing rate
 *           in bits/second
 * @property {number} memory - Router max queue capacity in bits
 * @property {DnsMode} dnsMode - Current DNS mode for the local network
 * @property {number} dnsNodeID - Entity ID of the current DNS node in the
 *           local network.
 * @property {number} randomDropChance - Odds (0-1) that a packet being routed
 *           will be dropped for no reason.
 */

/**
 * Build table row for this node.
 * @returns {RouterRow}
 * @private
 * @override
 */
NetSimRouterNode.prototype.buildRow = function () {
  return utils.extend(NetSimRouterNode.superPrototype.buildRow.call(this), {
    routerNumber: this.routerNumber,
    creationTime: this.creationTime,
    bandwidth: serializeNumber(this.bandwidth),
    memory: serializeNumber(this.memory),
    dnsMode: this.dnsMode,
    dnsNodeID: this.dnsNodeID,
    randomDropChance: this.randomDropChance
  });
};

/**
 * Load state from remoteRow into local model, then notify anything observing
 * us that we've changed.
 * @param {RouterRow} remoteRow
 * @private
 */
NetSimRouterNode.prototype.onMyStateChange_ = function (remoteRow) {
  this.routerNumber = remoteRow.routerNumber;
  this.creationTime = remoteRow.creationTime;
  this.bandwidth = deserializeNumber(remoteRow.bandwidth);
  this.memory = deserializeNumber(remoteRow.memory);
  this.dnsMode = remoteRow.dnsMode;
  this.dnsNodeID = remoteRow.dnsNodeID;
  this.randomDropChance = remoteRow.randomDropChance;
  this.stateChange.notifyObservers(this);
};

/**
 * Performs queued routing and DNS operations.
 * @param {RunLoop.Clock} clock
 */
NetSimRouterNode.prototype.tick = function (clock) {
  this.simulationTime_ = clock.time;
  this.routeOverdueMessages_(clock);
  if (this.dnsMode === DnsMode.AUTOMATIC) {
    this.tickAutoDns_(clock);
  }
};

/**
 * This name is a bit of a misnomer, but it's memorable; we actually route
 * all messages that are DUE or OVERDUE.
 * @param {RunLoop.Clock} clock
 * @private
 */
NetSimRouterNode.prototype.routeOverdueMessages_ = function (clock) {
  if (this.isRouterProcessing_) {
    return;
  }

  // Separate out messages whose scheduled time has arrived or is past.
  // Flag them so we can remove them later.
  var readyScheduleMessages = [];
  var expiredScheduleMessages = [];
  this.localRoutingSchedule_.forEach(function (item) {
    if (clock.time >= item.completionTime) {
      item.beingRouted = true;
      readyScheduleMessages.push(item.message);
    } else if (clock.time >= item.expirationTime) {
      item.beingRouted = true;
      expiredScheduleMessages.push(item.message);
    }
  });

  // If no messages are ready, we're done.
  if (readyScheduleMessages.length + expiredScheduleMessages.length === 0) {
    return;
  }

  // First, remove the expired items.  They just silently vanish
  this.isRouterProcessing_ = true;
  NetSimEntity.destroyEntities(expiredScheduleMessages, (function () {

    // Next, process the messages that are ready for routing
    this.routeMessages_(readyScheduleMessages, (function () {

      // Finally, remove all the schedule entries that we flagged earlier
      this.localRoutingSchedule_ = this.localRoutingSchedule_.filter(function (item) {
        return !item.beingRouted;
      });
      this.isRouterProcessing_ = false;
    }).bind(this));
  }).bind(this));
};

/**
 * Examine the queue, and add/adjust schedule entries for packets that
 * should be handled by the local simulation.  If a packet has no entry,
 * it should be added to the schedule.  If it does and we can see that its
 * scheduled completion time is too far in the future, we should move it up.
 */
NetSimRouterNode.prototype.recalculateSchedule = function () {
  // To calculate our schedule, we keep a rolling "Pessimistic completion time"
  // as we walk down the queue.  This "pessimistic time" is when the packet
  // would finish processing, assuming all of the packets ahead of it in the
  // queue must be processed first and the first packet in the queue is just
  // starting to process now.  We do this because the first packet might be
  // owned by a remote client, so we won't have partial progress information
  // on it.
  //
  // Thus, the pessimistic time is the _latest_ we would expect the router
  // to be done processing the packet given the current bandwidth setting,
  // if the router was an actual hardware device.
  //
  // The estimate is actually _optimistic_ in the sense that it doesn't wait
  // for notification that a remotely-simulated packet is done before
  // processing a locally-simulated one.  We're making our best guess about
  // how the packets would be timed with no latency introducing gaps between
  // packets.
  //
  // If the client simulating the packet at the head of the queue disconnects
  // it won't block other packets from being sent, but it will increase their
  // "pessimistic estimates" until that orphaned packet gets cleaned up.

  var queueSizeInBits = 0;
  var pessimisticCompletionTime = this.simulationTime_;
  var queuedMessage;
  var processingDuration;
  for (var i = 0; i < this.routerQueueCache_.length; i++) {
    queuedMessage = this.routerQueueCache_[i];
    queueSizeInBits += queuedMessage.payload.length;
    processingDuration = this.calculateProcessingDurationForMessage_(queuedMessage);
    pessimisticCompletionTime += processingDuration;

    // Don't schedule beyond memory capacity; we're going to drop those packets
    if (this.localSimulationOwnsMessage_(queuedMessage) && queueSizeInBits <= this.memory) {
      this.scheduleRoutingForMessage(queuedMessage, pessimisticCompletionTime);
    }
  }
};

/**
 * Checks the schedule for the queued row.  If no schedule entry exists, adds
 * a new one with the provided pessimistic completion time.  If it's already
 * scheduled and the pessimistic time given is BETTER than the previously
 * scheduled completion time, will update the schedule entry with the better
 * time.
 * @param {NetSimMessage} queuedMessage
 * @param {number} pessimisticCompletionTime - in local simulation time
 */
NetSimRouterNode.prototype.scheduleRoutingForMessage = function (queuedMessage, pessimisticCompletionTime) {
  var scheduleItem = _.find(this.localRoutingSchedule_, function (item) {
    return item.message.entityID === queuedMessage.entityID;
  });

  if (scheduleItem) {
    // When our pessimistic time is better than our scheduled time we
    // should update the scheduled time.  This can happen when messages
    // earlier in the queue expire, or are otherwise removed earlier than
    // their size led us to expect.
    if (pessimisticCompletionTime < scheduleItem.completionTime) {
      scheduleItem.completionTime = pessimisticCompletionTime;
    }
  } else {
    // If the item doesn't have a schedule entry at all, add it
    this.addMessageToSchedule_(queuedMessage, pessimisticCompletionTime);
  }
};

/**
 * Adds a new entry to the routing schedule, with a default expiration time.
 * @param {NetSimMessage} queuedMessage - message to route
 * @param {number} completionTime - in simulation time
 * @private
 */
NetSimRouterNode.prototype.addMessageToSchedule_ = function (queuedMessage, completionTime) {
  this.localRoutingSchedule_.push({
    message: queuedMessage,
    completionTime: completionTime,
    expirationTime: this.simulationTime_ + PACKET_MAX_LIFETIME_MS,
    beingRouted: false
  });
};

/**
 * Takes a message out of the routing schedule.  Modifies the schedule,
 * should not be called while iterating through the schedule!
 * Does nothing if the message isn't present in the schedule.
 * @param {NetSimMessage} queuedMessage
 * @private
 */
NetSimRouterNode.prototype.removeMessageFromSchedule_ = function (queuedMessage) {
  var scheduleIdx;
  for (var i = 0; i < this.localRoutingSchedule_.length; i++) {
    if (this.localRoutingSchedule_[i].message.entityID === queuedMessage.entityID) {
      scheduleIdx = i;
    }
  }
  if (scheduleIdx !== undefined) {
    this.localRoutingSchedule_.splice(scheduleIdx, 1);
  }
};

/**
 * Lets the auto-DNS part of the router simulation handle its requests.
 * For now, auto-DNS can do "batch" processing, no throughput limits.
 * @private
 */
NetSimRouterNode.prototype.tickAutoDns_ = function () {
  if (this.isAutoDnsProcessing_) {
    return;
  }

  // Filter DNS queue down to requests the local simulation should handle.
  var localSimDnsRequests = this.autoDnsQueue_.filter(this.localSimulationOwnsMessage_.bind(this));

  // If there's nothing we can process, we're done.
  if (localSimDnsRequests.length === 0) {
    return;
  }

  // Process DNS requests
  this.isAutoDnsProcessing_ = true;
  this.processAutoDnsRequests_(localSimDnsRequests, (function () {
    this.isAutoDnsProcessing_ = false;
  }).bind(this));
};

/** @inheritdoc */
NetSimRouterNode.prototype.getDisplayName = function () {
  if (NetSimGlobals.getLevelConfig().broadcastMode) {
    return i18n.roomNumberX({
      x: this.getRouterNumber()
    });
  }

  return i18n.routerNumberX({
    x: this.getRouterNumber()
  });
};

/**
 * Given the level address format string (e.g. "4.4.4.4") which it pulls from
 * globals, returns an array of the parsed lengths of each format part in order
 * (e.g. [4, 4, 4, 4]).
 * @returns {number[]}
 */
function getAddressFormatParts() {
  return NetSimGlobals.getLevelConfig().addressFormat.split(/\D+/).filter(function (part) {
    return part.length > 0;
  }).map(function (part) {
    return parseInt(part, 10);
  });
}

/**
 * Helper that prevents the router's display number or address from being beyond
 * the representable size of the the router part in the address format (if
 * two-part addresses are being used).
 * Does not do anything special to prevent collisions, just returns entityID
 * modulo the assignable address space - but this will be better than having
 * non-conflicting routers you can never address at all.
 * @returns {number}
 */
NetSimRouterNode.prototype.getRouterNumber = function () {
  // If two or more parts, limit our router number to the maximum value of
  // the second-to-last address part.
  var addressFormatParts = getAddressFormatParts();
  if (addressFormatParts.length >= 2) {
    var assignableAddressValues = Math.pow(2, addressFormatParts.reverse()[1]);
    return this.routerNumber % assignableAddressValues;
  }
  return this.routerNumber;
};

/**
 * Get the maximum number of routers that will be allowed on the shard.
 * In most levels this is a strict global value (probably 20).
 * In levels using an address format with two or more parts the second-to-last
 * part determines the addressable space for routers, and the max routers
 * will be the minimum of the global max and the addressable space.
 *
 * @example If the global max routers is 20, but the address format is 4.4,
 *          we can only address 16 routers (less than 20) so 16 is our max
 *          routers per shard value.
 *
 * @returns {number}
 */
NetSimRouterNode.getMaximumRoutersPerShard = function () {
  // If two or more parts, limit our routers to the maximum value of
  // the second-to-last address part.
  var addressFormatParts = getAddressFormatParts();
  if (addressFormatParts.length >= 2) {
    return Math.min(NetSimGlobals.getGlobalMaxRouters(), Math.pow(2, addressFormatParts.reverse()[1]));
  }
  return NetSimGlobals.getGlobalMaxRouters();
};

/**
 * Get node's own address, which is dependent on the address format
 * configured in the level but for routers always ends in zero.
 * @returns {string}
 */
NetSimRouterNode.prototype.getAddress = function () {
  return this.makeLocalNetworkAddress_(ROUTER_LOCAL_ADDRESS);
};

/**
 * Get local network's auto-dns address, which is dependent on the address
 * format configured for the level but the last part should always be 15.
 * @returns {string}
 */
NetSimRouterNode.prototype.getAutoDnsAddress = function () {
  return this.makeLocalNetworkAddress_(AUTO_DNS_RESERVED_ADDRESS);
};

/**
 * Get node's hostname, a modified version of its display name.
 * @returns {string}
 * @override
 */
NetSimRouterNode.prototype.getHostname = function () {
  // Use regex to strip anything that's not a word-character or a digit
  // from the node's display name.  For routers, we don't append the node ID
  // because it's already part of the display name.
  return this.getDisplayName().replace(/[^\w\d]/g, '').toLowerCase();
};

/** @inheritdoc */
NetSimRouterNode.prototype.getNodeType = function () {
  return NodeType.ROUTER;
};

/** @inheritdoc */
NetSimRouterNode.prototype.getStatus = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();
  var connectionCount = this.countConnections();
  if (connectionCount === 0) {
    if (levelConfig.broadcastMode) {
      return i18n.roomStatusNoConnections({
        maximumClients: this.maxClientConnections_
      });
    }

    return i18n.routerStatusNoConnections({
      maximumClients: this.maxClientConnections_
    });
  }

  var connectedNodeNames = this.getConnectedNodeNames_().join(', ');
  if (connectionCount >= this.maxClientConnections_) {
    if (levelConfig.broadcastMode) {
      return i18n.roomStatusFull({
        connectedClients: connectedNodeNames
      });
    }

    return i18n.routerStatusFull({
      connectedClients: connectedNodeNames
    });
  }

  if (levelConfig.broadcastMode) {
    return i18n.roomStatus({
      connectedClients: connectedNodeNames,
      remainingSpace: this.maxClientConnections_ - connectionCount
    });
  }

  return i18n.routerStatus({
    connectedClients: connectedNodeNames,
    remainingSpace: this.maxClientConnections_ - connectionCount
  });
};

/**
 * @returns {string[]} the names of all the nodes connected to this router.
 * @private
 */
NetSimRouterNode.prototype.getConnectedNodeNames_ = function () {
  var cachedNodeRows = this.shard_.nodeTable.readAll();
  return this.getConnections().map(function (wire) {
    var nodeRow = _.find(cachedNodeRows, function (nodeRow) {
      return nodeRow.id === wire.localNodeID;
    });
    if (nodeRow) {
      return nodeRow.name;
    }
    return i18n.unknownNode();
  });
};

/** @inheritdoc */
NetSimRouterNode.prototype.isFull = function () {
  // Determine status based on cached wire data
  var cachedWireRows = this.shard_.wireTable.readAll();
  var incomingWireRows = cachedWireRows.filter(function (wireRow) {
    return wireRow.remoteNodeID === this.entityID;
  }, this);

  return incomingWireRows.length >= this.maxClientConnections_;
};

/**
 * Makes sure that the given specification contains the fields that this
 * router needs to do its job.
 * @param {Packet.HeaderType[]} packetSpec
 * @private
 */
NetSimRouterNode.prototype.validatePacketSpec_ = function (packetSpec) {
  // There are no requirements in broadcast mode
  if (NetSimGlobals.getLevelConfig().broadcastMode) {
    return;
  }

  // Require TO_ADDRESS for routing
  if (!packetSpec.some(function (headerField) {
    return headerField === Packet.HeaderType.TO_ADDRESS;
  })) {
    logger.warn("Packet specification does not have a toAddress field.");
  }

  // Require FROM_ADDRESS for auto-DNS tasks
  if (!packetSpec.some(function (headerField) {
    return headerField === Packet.HeaderType.FROM_ADDRESS;
  })) {
    logger.warn("Packet specification does not have a fromAddress field.");
  }
};

/**
 * Puts this router controller into a mode where it will only
 * simulate for connection and messages -from- the given node.
 * @param {!number} nodeID
 */
NetSimRouterNode.prototype.initializeSimulation = function (nodeID) {
  this.simulateForSender_ = nodeID;
  this.packetSpec_ = NetSimGlobals.getLevelConfig().routerExpectsPacketHeader;
  this.validatePacketSpec_(this.packetSpec_);

  if (nodeID !== undefined) {
    var nodeChangeEvent = this.shard_.nodeTable.tableChange;
    var nodeChangeHandler = this.onNodeTableChange_.bind(this);
    this.nodeChangeKey_ = nodeChangeEvent.register(nodeChangeHandler);

    var wireChangeEvent = this.shard_.wireTable.tableChange;
    var wireChangeHandler = this.onWireTableChange_.bind(this);
    this.wireChangeKey_ = wireChangeEvent.register(wireChangeHandler);

    var logChangeEvent = this.shard_.logTable.tableChange;
    var logChangeHandler = this.onLogTableChange_.bind(this);
    this.logChangeKey_ = logChangeEvent.register(logChangeHandler);

    var newMessageEvent = this.shard_.messageTable.tableChange;
    var newMessageHandler = this.onMessageTableChange_.bind(this);
    this.newMessageEventKey_ = newMessageEvent.register(newMessageHandler);

    // Populate router wire cache with initial data
    this.onWireTableChange_();

    // Populate router log cache with initial data
    this.onLogTableChange_();
  }
};

/**
 * Gives the simulating node a chance to unregister from anything it
 * was observing.
 */
NetSimRouterNode.prototype.stopSimulation = function () {
  if (this.nodeChangeKey_ !== undefined) {
    var nodeChangeEvent = this.shard_.nodeTable.tableChange;
    nodeChangeEvent.unregister(this.nodeChangeKey_);
    this.nodeChangeKey_ = undefined;
  }

  if (this.wireChangeKey_ !== undefined) {
    var wireChangeEvent = this.shard_.wireTable.tableChange;
    wireChangeEvent.unregister(this.wireChangeKey_);
    this.wireChangeKey_ = undefined;
  }

  if (this.logChangeKey_ !== undefined) {
    var logChangeEvent = this.shard_.logTable.tableChange;
    logChangeEvent.unregister(this.logChangeKey_);
    this.logChangeKey_ = undefined;
  }

  if (this.newMessageEventKey_ !== undefined) {
    var newMessageEvent = this.shard_.messageTable.tableChange;
    newMessageEvent.unregister(this.newMessageEventKey_);
    this.newMessageEventKey_ = undefined;
  }
};

/**
 * Puts the router into the given DNS mode, triggers a remote update,
 * and creates/destroys the network's automatic DNS node.
 * @param {DnsMode} newDnsMode
 */
NetSimRouterNode.prototype.setDnsMode = function (newDnsMode) {
  if (this.dnsMode === newDnsMode) {
    return;
  }

  if (this.dnsMode === DnsMode.NONE) {
    this.dnsNodeID = undefined;
  } else if (this.dnsMode === DnsMode.AUTOMATIC) {
    this.dnsNodeID = AUTO_DNS_RESERVED_ADDRESS;
  }

  this.dnsMode = newDnsMode;
  this.update();
};

/**
 * @param {number} newBandwidth in bits per second
 */
NetSimRouterNode.prototype.setBandwidth = function (newBandwidth) {
  if (this.bandwidth === newBandwidth) {
    return;
  }

  this.bandwidth = newBandwidth;
  this.recalculateSchedule();
  this.update();
};

/**
 * @param {number} newMemory in bits
 */
NetSimRouterNode.prototype.setMemory = function (newMemory) {
  if (this.memory === newMemory) {
    return;
  }

  this.memory = newMemory;
  this.enforceMemoryLimit_();
  this.update();
};

/**
 * @returns {NetSimWire[]} all of the wires that are attached to this router.
 */
NetSimRouterNode.prototype.getConnections = function () {
  var shard = this.shard_;
  var routerID = this.entityID;
  return shard.wireTable.readAll().filter(function (wireRow) {
    return wireRow.remoteNodeID === routerID;
  }).map(function (wireRow) {
    return new NetSimWire(shard, wireRow);
  });
};

/**
 * @returns {number} total number of wires connected to this router.
 */
NetSimRouterNode.prototype.countConnections = function () {
  return this.getConnections().length;
};

/**
 * Add a router log entry (not development logging, this is user-facing!)
 * @param {string} packet - binary log payload
 * @param {NetSimLogEntry.LogStatus} status
 */
NetSimRouterNode.prototype.log = function (packet, status) {
  NetSimLogEntry.create(this.shard_, this.entityID, packet, status, function () {});
};

/**
 * @param {Array} haystack
 * @param {*} needle
 * @returns {boolean} TRUE if needle found in haystack
 */
var contains = function contains(haystack, needle) {
  return haystack.some(function (element) {
    return element === needle;
  });
};

/**
 * Called when another node establishes a connection to this one, giving this
 * node a chance to reject the connection.
 *
 * The router checks against its connection limit, and rejects the connection
 * if its limit is now exceeded.
 *
 * @param {!NetSimNode} otherNode attempting to connect to this one
 * @param {!NodeStyleCallback} onComplete response method - should call with TRUE
 *        if connection is allowed, FALSE if connection is rejected.
 */
NetSimRouterNode.prototype.acceptConnection = function (otherNode, onComplete) {
  var rejectionReason = null;

  // Force a refresh to verify that we have not exceeded the connection limit.
  this.shard_.wireTable.refresh().done((function () {
    var connections = this.getConnections();

    // Check for connection limit exceeded
    if (connections.length > this.maxClientConnections_) {
      rejectionReason = new Error("Too many connections.");
      return;
    }

    // Check for address collisions
    var addressesSoFar = {};
    addressesSoFar[this.getAddress()] = true;
    addressesSoFar[this.getAutoDnsAddress()] = true;
    var addressCollision = connections.some(function (wire) {
      var collides = addressesSoFar.hasOwnProperty(wire.localAddress);
      addressesSoFar[wire.localAddress] = true;
      return collides;
    });
    if (addressCollision) {
      rejectionReason = new Error("Address collision detected.");
    }
  }).bind(this)).fail(function (err) {
    logger.info("Rejected connection from " + otherNode.getDisplayName() + ": " + err.message);
    rejectionReason = err;
  }).always(function () {
    onComplete(rejectionReason, null === rejectionReason);
  });
};

/**
 * Generate a list of available addresses, then pick one at random and return it.
 * @returns {string} a new available address.
 */
NetSimRouterNode.prototype.getRandomAvailableClientAddress = function () {
  var addressList = this.getConnections().filter(function (wire) {
    return wire.localAddress !== undefined;
  }).map(function (wire) {
    return wire.localAddress;
  });

  // Generate a list of unused addresses in the addressable space (to a limit)
  var addressFormat = NetSimGlobals.getLevelConfig().addressFormat;
  var addressPartSizes = addressFormat.split(/\D+/).filter(function (part) {
    return part.length > 0;
  }).map(function (part) {
    return parseInt(part, 10);
  }).reverse();
  var maxLocalAddresses = Math.min(Math.pow(2, addressPartSizes[0]), ADDRESS_OPTION_LIMIT);

  var possibleAddresses = [];
  var nextAddress;
  for (var i = 0; i < maxLocalAddresses; i++) {
    nextAddress = this.makeLocalNetworkAddress_(i);
    // Verify that the address in question is not taken already.
    if (!(nextAddress === this.getAddress() || nextAddress === this.getAutoDnsAddress() || contains(addressList, nextAddress))) {
      possibleAddresses.push(nextAddress);
    }
  }

  var randomIndex = NetSimGlobals.randomIntInRange(0, possibleAddresses.length);
  return possibleAddresses[randomIndex];
};

/**
 * Generate an address matching the level's configured address format, that
 * falls within this router's local network and ends in the given value.
 * @param {number} lastPart
 * @returns {string}
 * @private
 */
NetSimRouterNode.prototype.makeLocalNetworkAddress_ = function (lastPart) {
  var addressFormat = NetSimGlobals.getLevelConfig().addressFormat;
  var usedLastPart = false;
  var usedRouterID = false;

  return addressFormat.split(/(\D+)/).reverse().map((function (part) {
    var bitWidth = parseInt(part, 10);
    if (isNaN(bitWidth)) {
      // This is a non-number part, pass it through to the result
      return part;
    }

    if (!usedLastPart) {
      usedLastPart = true;
      return lastPart.toString();
    }

    if (!usedRouterID) {
      usedRouterID = true;
      return this.getRouterNumber().toString();
    }

    return '0';
  }).bind(this)).reverse().join('');
};

/**
 * @returns {Array} A list of remote nodes connected to this router, including
 *          their hostname, address, whether they are the local node, and
 *          whether they are the current DNS node for the network.
 */
NetSimRouterNode.prototype.getAddressTable = function () {
  var addressTable = this.myWireRowCache_.map((function (row) {
    return {
      hostname: row.localHostname,
      address: row.localAddress,
      isLocal: row.localNodeID === this.simulateForSender_,
      isDnsNode: row.localNodeID === this.dnsNodeID
    };
  }).bind(this));

  // Special case: In auto-dns mode we add the DNS entry to the address table
  if (this.dnsMode === DnsMode.AUTOMATIC) {
    addressTable.push({
      hostname: AUTO_DNS_HOSTNAME,
      address: this.getAutoDnsAddress(),
      isLocal: false,
      isDnsNode: true
    });
  }

  return addressTable;
};

/**
 * Given a node ID, finds the local network address of that node.  Cannot
 * be used to find the address of the router or auto-dns node (since their
 * node IDs are not unique).  Will return undefined if the node ID is not
 * found.
 *
 * @param {number} nodeID
 * @returns {number|undefined}
 * @private
 */
NetSimRouterNode.prototype.getAddressForNodeID_ = function (nodeID) {
  var wireRow = _.find(this.myWireRowCache_, function (row) {
    return row.localNodeID === nodeID;
  });

  if (wireRow !== undefined) {
    return wireRow.localAddress;
  }
  return undefined;
};

/**
 * Given a hostname, finds the local network address of the node with that
 * hostname.  Will return undefined if no node with that hostname is found.
 *
 * @param {string} hostname
 * @returns {number|undefined}
 * @private
 */
NetSimRouterNode.prototype.getAddressForHostname_ = function (hostname) {
  if (hostname === this.getHostname()) {
    return this.getAddress();
  }

  if (this.dnsMode === DnsMode.AUTOMATIC && hostname === AUTO_DNS_HOSTNAME) {
    return this.getAutoDnsAddress();
  }

  var wireRow = _.find(this.myWireRowCache_, function (row) {
    return row.localHostname === hostname;
  });

  if (wireRow !== undefined) {
    return wireRow.localAddress;
  }

  // If we don't have connected routers, this is as far as the auto-DNS can see.
  if (!NetSimGlobals.getLevelConfig().connectedRouters) {
    return undefined;
  }

  // Is it some node elsewhere on the shard?
  var nodes = NetSimNodeFactory.nodesFromRows(this.shard_, this.shard_.nodeTable.readAll());
  var node = _.find(nodes, function (node) {
    return node.getHostname() === hostname;
  });
  if (node) {
    return node.getAddress();
  }

  return undefined;
};

/**
 * Given a local network address, finds the node ID of the node at that
 * address.  Will return undefined if no node is found at the given address.
 *
 * @param {string} address
 * @returns {number|undefined}
 * @private
 */
NetSimRouterNode.prototype.getNodeIDForAddress_ = function (address) {
  if (address === this.getAddress()) {
    return this.entityID;
  }

  if (this.dnsMode === DnsMode.AUTOMATIC && address === this.getAutoDnsAddress()) {
    return this.entityID;
  }

  var wireRow = _.find(this.myWireRowCache_, function (row) {
    return row.localAddress === address;
  });

  if (wireRow !== undefined) {
    return wireRow.localNodeID;
  }
  return undefined;
};

/**
 * Given a network address, finds the node that is the next step along the
 * correct path from this router to that address.  Will return null if no
 * path to the address is found.
 * @param {string} address
 * @param {number} hopsRemaining
 * @param {number[]} visitedNodeIDs
 * @returns {NetSimNode|null}
 * @private
 */
NetSimRouterNode.prototype.getNextNodeTowardAddress_ = function (address, hopsRemaining, visitedNodeIDs) {
  // Is it us?
  if (address === this.getAddress()) {
    return this;
  }

  // Is it our Auto-DNS node?
  if (this.dnsMode === DnsMode.AUTOMATIC && address === this.getAutoDnsAddress()) {
    return this;
  }

  // Is it a local client?
  var nodes = NetSimNodeFactory.nodesFromRows(this.shard_, this.shard_.nodeTable.readAll());
  var wireRow = _.find(this.myWireRowCache_, function (row) {
    return row.localAddress === address;
  });
  if (wireRow !== undefined) {
    var localClient = _.find(nodes, function (node) {
      return node.entityID === wireRow.localNodeID;
    });
    if (localClient !== undefined) {
      return localClient;
    }
  }

  // End of local subnet cases:
  // In levels where routers are not connected, this is as far as we go.
  var levelConfig = NetSimGlobals.getLevelConfig();
  if (!levelConfig.connectedRouters) {
    return null;
  }

  // Is it another node?
  var destinationNode = _.find(nodes, function (node) {
    return address === node.getAddress() || node.dnsMode === DnsMode.AUTOMATIC && node.getNodeType() === NodeType.ROUTER && address === node.getAutoDnsAddress();
  });

  // If the node we're after doesn't exist anywhere, we should stop now.
  if (!destinationNode) {
    return null;
  }

  // We are trying to get somewhere else!  Figure out what the target router
  // for our destination is.
  var destinationRouter = null;
  if (destinationNode.getNodeType() === NodeType.ROUTER) {
    destinationRouter = destinationNode;
  } else {
    var destinationWire = destinationNode.getOutgoingWire();
    if (destinationWire) {
      destinationRouter = utils.valueOr(_.find(nodes, function (node) {
        return node.entityID === destinationWire.remoteNodeID;
      }), null);
    }
  }

  if (!destinationRouter) {
    return null;
  }

  // If we have extra hops, we should try and go to a router that is NOT
  // the target router.
  if (hopsRemaining > 0) {
    // Generate the set of possible target routers
    var possibleDestinationRouters = nodes.filter(function (node) {
      return node.getNodeType() === NodeType.ROUTER && node.entityID !== destinationRouter.entityID && node.entityID !== this.entityID && !visitedNodeIDs.some(function (visitedID) {
        return node.entityID === visitedID;
      });
    }, this);
    if (possibleDestinationRouters.length > 0) {
      return NetSimGlobals.randomPickOne(possibleDestinationRouters);
    }
  }

  // If there's nowhere else to go or we are out of extra hops, go to the
  // target router.
  return destinationRouter;
};

/**
 * When the node table changes, we check whether our own row has changed
 * and propagate those changes as appropriate.
 * @private
 * @throws
 */
NetSimRouterNode.prototype.onNodeTableChange_ = function () {
  var myRow = _.find(this.shard_.nodeTable.readAll(), (function (row) {
    return row.id === this.entityID;
  }).bind(this));

  if (myRow === undefined) {
    // This can happen now, to non-primary routers, because detection
    // of the router's removal (stopping its simulation) in NetSimLocalClientNode
    // and this method happen in an uncertain order.
    return;
  }

  if (!_.isEqual(this.stateCache_, myRow)) {
    this.stateCache_ = myRow;
    this.onMyStateChange_(myRow);
  }
};

/**
 * When the wires table changes, we may have a new connection or have lost
 * a connection.  Propagate updates about our connections
 * @private
 */
NetSimRouterNode.prototype.onWireTableChange_ = function () {
  var myWireRows = this.shard_.wireTable.readAll().filter((function (row) {
    return row.remoteNodeID === this.entityID;
  }).bind(this));

  if (!_.isEqual(this.myWireRowCache_, myWireRows)) {
    this.myWireRowCache_ = myWireRows;
    this.wiresChange.notifyObservers();
  }
};

/**
 * When the logs table changes, we may have a new connection or have lost
 * a connection.  Propagate updates about our connections
 * @private
 */
NetSimRouterNode.prototype.onLogTableChange_ = function () {
  var myLogRows = this.shard_.logTable.readAll().filter((function (row) {
    return row.nodeID === this.entityID;
  }).bind(this));

  if (!_.isEqual(this.myLogRowCache_, myLogRows)) {
    this.myLogRowCache_ = myLogRows;
    this.logChange.notifyObservers();
  }
};

/**
 * Get list of log entries in this router's memory.
 * @returns {NetSimLogEntry[]}
 */
NetSimRouterNode.prototype.getLog = function () {
  return this.myLogRowCache_.map((function (row) {
    return new NetSimLogEntry(this.shard_, row, this.packetSpec_);
  }).bind(this));
};

/**
 * @returns {number} the number of packets in the router queue
 */
NetSimRouterNode.prototype.getQueuedPacketCount = function () {
  return this.routerQueueCache_.length;
};

/**
 * @returns {number} router memory currently in use, in bits
 */
NetSimRouterNode.prototype.getMemoryInUse = function () {
  return this.routerQueueCache_.reduce(function (prev, cur) {
    return prev + cur.payload.length;
  }, 0);
};

/**
 * @returns {number} expected router data rate (in bits per second) over the
 *          next second
 */
NetSimRouterNode.prototype.getCurrentDataRate = function () {
  // For simplicity, we're defining the 'curent data rate' as how many bits
  // we expect to get processed in the next second; which is our queue size,
  // capped at our bandwidth.
  return Math.min(this.getMemoryInUse(), this.bandwidth);
};

/**
 * When the message table changes, we might have a new message to handle.
 * Check for and handle unhandled messages.
 * @private
 * @throws if this method is called on a non-simulating router.
 */
NetSimRouterNode.prototype.onMessageTableChange_ = function () {
  if (!this.simulateForSender_) {
    // What?  Only simulating routers should be hooked up to message notifications.
    throw new Error("Non-simulating router got message table change notifiction");
  }

  var messages = this.shard_.messageTable.readAll().map((function (row) {
    return new NetSimMessage(this.shard_, row);
  }).bind(this));

  this.updateRouterQueue_(messages);

  if (this.dnsMode === DnsMode.AUTOMATIC) {
    this.updateAutoDnsQueue_(messages);
  }
};

/**
 * Updates our cache of all messages that are going to the router (regardless
 * of which simulation will handle them), so we can use it for stats and rate
 * limiting.
 * @param {NetSimMessage[]} messages
 */
NetSimRouterNode.prototype.updateRouterQueue_ = function (messages) {
  var newQueue = messages.filter(NetSimMessage.isValid).filter(this.isMessageToRouter_.bind(this));
  if (_.isEqual(this.routerQueueCache_, newQueue)) {
    return;
  }

  logger.info(this.getDisplayName() + ': Message queue updated (size ' + newQueue.length + ')');

  this.routerQueueCache_ = newQueue;
  this.recalculateSchedule();
  this.enforceMemoryLimit_();
  this.statsChange.notifyObservers(this);
};

/**
 * Checks the router queue for packets beyond the router's memory limit,
 * and drops the first one we simulate locally.  Since this will trigger
 * a table change, this will occur async-recursively until all packets
 * over the memory limit are dropped.
 * @private
 */
NetSimRouterNode.prototype.enforceMemoryLimit_ = function () {
  // Only proceed if a packet we simulate exists beyond the memory limit
  var droppablePacket = this.findFirstLocallySimulatedPacketOverMemoryLimit();
  if (!droppablePacket) {
    return;
  }

  this.removeMessageFromSchedule_(droppablePacket);
  droppablePacket.destroy((function (err) {
    if (err) {
      // Rarely, this could fire twice for one packet and have one drop fail.
      // That's fine; just don't log if we didn't successfully drop.
      return;
    }

    this.log(droppablePacket.payload, NetSimLogEntry.LogStatus.DROPPED);
  }).bind(this));
};

/**
 * Walk the router queue, and return the first packet we find beyond the router's
 * memory capacity that the local simulation controls and is able to drop.
 * @returns {NetSimMessage|null} null if no such message is found.
 */
NetSimRouterNode.prototype.findFirstLocallySimulatedPacketOverMemoryLimit = function () {
  var packet;
  var usedMemory = 0;
  for (var i = 0; i < this.routerQueueCache_.length; i++) {
    packet = this.routerQueueCache_[i];
    usedMemory += packet.payload.length;
    if (usedMemory > this.memory && this.localSimulationOwnsMessage_(packet)) {
      return packet;
    }
  }
  return null;
};

/**
 * @param {NetSimMessage} message
 * @returns {boolean} TRUE if this message is destined for the router (not the
 *          auto-DNS part though!) and FALSE if destined anywhere else.
 * @private
 */
NetSimRouterNode.prototype.isMessageToRouter_ = function (message) {
  if (this.dnsMode === DnsMode.AUTOMATIC && this.isMessageToAutoDns_(message)) {
    return false;
  }

  return message.toNodeID === this.entityID;
};

NetSimRouterNode.prototype.routeMessages_ = function (messages, onComplete) {
  if (messages.length === 0) {
    onComplete(null);
    return;
  }

  this.routeMessage_(messages[0], (function (err, result) {
    if (err) {
      onComplete(err, result);
      return;
    }

    this.routeMessages_(messages.slice(1), onComplete);
  }).bind(this));
};

/**
 *
 * @param {NetSimMessage} message
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.routeMessage_ = function (message, onComplete) {
  message.destroy((function (err, result) {
    if (err) {
      onComplete(err, result);
      return;
    }

    // Apply random chance to drop packet, right as we are about to forward it
    if (this.randomDropChance > 0 && NetSimGlobals.random() <= this.randomDropChance) {
      this.log(message.payload, NetSimLogEntry.LogStatus.DROPPED);
      onComplete(null);
      return;
    }

    var levelConfig = NetSimGlobals.getLevelConfig();
    if (levelConfig.broadcastMode) {
      this.forwardMessageToAll_(message, onComplete);
    } else {
      this.forwardMessageToRecipient_(message, onComplete);
    }
  }).bind(this));
};

/**
 * Forward the given message to all nodes that are connected to this router.
 * This is effectively "hub" operation.
 * @param {NetSimMessage} message
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.forwardMessageToAll_ = function (message, onComplete) {
  // Assumptions for broadcast mode:
  // 1. We can totally ignore packet headers, because addresses don't matter
  // 2. We won't send to the Auto-DNS, since DNS make no sense with no addresses

  // Grab the list of all connected nodes
  var connectedNodeIDs = this.myWireRowCache_.map(function (wireRow) {
    return wireRow.localNodeID;
  });

  this.forwardMessageToNodeIDs_(message, connectedNodeIDs, (function (err, result) {
    if (err) {
      this.log(message.payload, NetSimLogEntry.LogStatus.DROPPED);
    } else {
      this.log(message.payload, NetSimLogEntry.LogStatus.SUCCESS);
    }
    onComplete(err, result);
  }).bind(this));
};

/**
 * Forward the given message to the list of node IDs provided.
 * This function works by calling itself recursively with the tail of the
 * node ID list each time it finishes sending one of the messages, so
 * timing on this "broadcast" won't be exactly correct - that's probably okay
 * though, especially at the point in the curriculum where this is used.
 * @param {NetSimMessage} message
 * @param {number[]} nodeIDs
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.forwardMessageToNodeIDs_ = function (message, nodeIDs, onComplete) {

  var messages = nodeIDs.map(function (nodeID) {
    return {
      fromNodeID: this.entityID,
      toNodeID: nodeID,
      simulatedBy: nodeID,
      payload: message.payload
    };
  }, this);

  NetSimMessage.sendMany(this.shard_, messages, onComplete);
};

/**
 * Read the given message to find its destination address, try and map that
 * address to one of our connections, and send the message payload to
 * the new address.
 *
 * @param {NetSimMessage} message
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.forwardMessageToRecipient_ = function (message, onComplete) {
  var toAddress;
  var routerNodeID = this.entityID;

  // Find a connection to route this message to.
  try {
    var packet = new Packet(this.packetSpec_, message.payload);
    toAddress = packet.getHeaderAsAddressString(Packet.HeaderType.TO_ADDRESS);
  } catch (error) {
    logger.warn("Packet not readable by router");
    this.log(message.payload, NetSimLogEntry.LogStatus.DROPPED);
    onComplete(null);
    return;
  }

  var destinationNode = this.getNextNodeTowardAddress_(toAddress, message.extraHopsRemaining, message.visitedNodeIDs);
  if (destinationNode === null) {
    // Can't find or reach the address within the simulation
    logger.warn("Destination address not reachable");
    this.log(message.payload, NetSimLogEntry.LogStatus.DROPPED);
    onComplete(null);
    return;
  } else if (destinationNode === this && toAddress === this.getAddress()) {
    // This router IS the packet's destination, it's done.
    logger.warn("Packet stopped at router.");
    this.log(message.payload, NetSimLogEntry.LogStatus.SUCCESS);
    onComplete(null);
    return;
  }

  // TODO: Handle bad state where more than one wire matches dest address?

  // The sender simulates a message until it reaches the final leg of its trip,
  // when it's going to a client node.  At that point, the recipient takes over.
  var simulatingNodeID = message.simulatedBy;
  if (destinationNode.getNodeType() === NodeType.CLIENT) {
    simulatingNodeID = destinationNode.entityID;
  }

  // Create a new message with a new payload.
  NetSimMessage.send(this.shard_, {
    fromNodeID: routerNodeID,
    toNodeID: destinationNode.entityID,
    simulatedBy: simulatingNodeID,
    payload: message.payload,
    extraHopsRemaining: Math.max(0, message.extraHopsRemaining - 1),
    visitedNodeIDs: message.visitedNodeIDs.concat(this.entityID)
  }, (function (err, result) {
    this.log(message.payload, NetSimLogEntry.LogStatus.SUCCESS);
    onComplete(err, result);
  }).bind(this));
};

/**
 * @param {NetSimMessage} message
 * @returns {boolean} TRUE if the given message should be operated on by the local
 *          simulation, FALSE if another user's simulation should handle it.
 * @private
 */
NetSimRouterNode.prototype.localSimulationOwnsMessage_ = function (message) {
  return this.simulateForSender_ && message.simulatedBy === this.simulateForSender_;
};

/**
 * @param {NetSimMessage} message
 * @returns {number} time required to process this message, in milliseconds.
 * @private
 */
NetSimRouterNode.prototype.calculateProcessingDurationForMessage_ = function (message) {
  if (this.bandwidth === Infinity) {
    return 0;
  }
  return message.payload.length * 1000 / this.bandwidth;
};

/**
 * Update queue of all auto-dns messages, which can be used for stats or limiting.
 * @param {NetSimMessage[]} messages
 * @private
 */
NetSimRouterNode.prototype.updateAutoDnsQueue_ = function (messages) {
  var newQueue = messages.filter(this.isMessageToAutoDns_.bind(this));
  if (_.isEqual(this.autoDnsQueue_, newQueue)) {
    return;
  }

  this.autoDnsQueue_ = newQueue;
  // Propagate notification of queue change?
  // Work will proceed on next tick
};

/**
 * @param {NetSimMessage} message
 * @return {boolean}
 */
NetSimRouterNode.prototype.isMessageToAutoDns_ = function (message) {
  var packet, toAddress;
  try {
    packet = new Packet(this.packetSpec_, message.payload);
    toAddress = packet.getHeaderAsAddressString(Packet.HeaderType.TO_ADDRESS);
  } catch (error) {
    logger.warn("Packet not readable by auto-DNS: " + error);
    return false;
  }

  // Messages to the auto-dns are both to and from the router node, and
  // addressed to the DNS.
  return message.toNodeID === this.entityID && message.fromNodeID === this.entityID && toAddress === this.getAutoDnsAddress();
};

/**
 * Batch-process DNS requests, generating responses wherever possible.
 * @param {NetSimMessage[]} messages
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.processAutoDnsRequests_ = function (messages, onComplete) {
  // 1. Remove the requests from the wire
  NetSimEntity.destroyEntities(messages, (function (err, result) {
    if (err) {
      onComplete(err, result);
      return;
    }

    // 2. Generate all responses, asynchronously.
    this.generateDnsResponses_(messages, onComplete);
  }).bind(this));
};

/**
 * @param {NetSimMessage[]} messages
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.generateDnsResponses_ = function (messages, onComplete) {
  if (messages.length === 0) {
    onComplete(null);
    return;
  }

  // Process head
  this.generateDnsResponse_(messages[0], (function (err, result) {
    if (err) {
      onComplete(err, result);
      return;
    }

    // Process tail
    this.generateDnsResponses_(messages.slice(1), onComplete);
  }).bind(this));
};

/**
 * @param {NetSimMessage} message
 * @param {!NodeStyleCallback} onComplete
 * @private
 */
NetSimRouterNode.prototype.generateDnsResponse_ = function (message, onComplete) {
  var packet, fromAddress, query, responseHeaders, responseBody, responseBinary;
  var routerNodeID = this.entityID;
  var autoDnsNodeID = this.entityID;

  // Extract message contents
  try {
    packet = new Packet(this.packetSpec_, message.payload);
    fromAddress = packet.getHeaderAsAddressString(Packet.HeaderType.FROM_ADDRESS);
    query = packet.getBodyAsAscii(BITS_PER_BYTE);
  } catch (error) {
    // Malformed packet, ignore
    onComplete(error);
    return;
  }

  // Check that the query is well-formed
  // Regex match "GET [hostnames...]"
  // Then below, we'll split the hostnames on whitespace to process them.
  var requestMatch = query.match(/GET\s+(\S.*)/);
  if (requestMatch !== null) {
    // Good request, look up all addresses and build up response
    // Skipping first match, which is the full regex
    var responses = requestMatch[1].split(/\s+/).map((function (queryHostname) {
      var address = this.getAddressForHostname_(queryHostname);
      return queryHostname + ':' + utils.valueOr(address, AUTO_DNS_NOT_FOUND);
    }).bind(this));
    responseBody = responses.join(' ');
  } else {
    // Malformed request, send back instructions
    responseBody = i18n.autoDnsUsageMessage();
  }

  responseHeaders = {
    fromAddress: this.getAutoDnsAddress(),
    toAddress: fromAddress,
    packetIndex: 1,
    packetCount: 1
  };

  responseBinary = packet.encoder.concatenateBinary(packet.encoder.makeBinaryHeaders(responseHeaders), asciiToBinary(responseBody, BITS_PER_BYTE));

  NetSimMessage.send(this.shard_, {
    fromNodeID: autoDnsNodeID,
    toNodeID: routerNodeID,
    simulatedBy: message.simulatedBy,
    payload: responseBinary
  }, onComplete);
};

},{"../ObservableEvent":"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js","../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogEntry":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogEntry.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimMessage":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMessage.js","./NetSimNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNode.js","./NetSimNodeFactory":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNodeFactory.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./NetSimWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimWire.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimMessage.js":[function(require,module,exports){
/**
 * @overview Simulation entity for a message between two nodes.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var NetSimEntity = require('./NetSimEntity');
var DataConverters = require('./DataConverters');
var base64ToBinary = DataConverters.base64ToBinary;
var binaryToBase64 = DataConverters.binaryToBase64;
var NetSimLogger = require('./NetSimLogger');

var logger = NetSimLogger.getSingleton();

/**
 * @typedef {Object} MessageData
 * @property {!number} fromNodeID - sender node ID
 * @property {!number} toNodeID - destination node ID
 * @property {!number} simulatedBy - node ID of client simulating message
 * @property {!string} payload - message content in a binary string
 * @property {number} extraHopsRemaining
 * @property {number[]} visitedNodeIDs
 */

/**
 * @typedef {Object} MessageRow
 * @property {!number} fromNodeID - this message in-flight-from node
 * @property {!number} toNodeID - this message in-flight-to node
 * @property {!number} simulatedBy - Node ID of the client responsible for
 *           all operations involving this message.
 * @property {!Base64Payload} base64Payload - base64-encoded binary
 *           message content, all of which can be exposed to the
 *           student.  May contain headers of its own.
 * @property {!number} extraHopsRemaining
 * @property {!number[]} visitedNodeIDs
 */

/**
 * Local controller for a message that is 'on the wire'
 *
 * Doesn't actually have any association with the wire - one could,
 * theoretically, send a message from any node in the simulation to any other
 * node in the simulation.
 *
 * Any message that exists in the table is 'in transit' to a node.  Nodes
 * should remove messages as soon as they receive them.
 *
 * @param {!NetSimShard} shard - The shard where this wire lives.
 * @param {MessageRow} [messageRow] - A row out of the _message table on the
 *        shard.  If provided, will initialize this message with the given
 *        data.  If not, this message will initialize to default values.
 * @constructor
 * @augments NetSimEntity
 * @implements MessageData
 */
var NetSimMessage = module.exports = function (shard, messageRow) {
  messageRow = messageRow !== undefined ? messageRow : {};
  NetSimEntity.call(this, shard, messageRow);

  /**
   * Node ID that this message is 'in transit' from.
   * @type {number}
   */
  this.fromNodeID = messageRow.fromNodeID;

  /**
   * Node ID that this message is 'in transit' to.
   * @type {number}
   */
  this.toNodeID = messageRow.toNodeID;

  /**
   * ID of the node responsible for operations on this message.
   * @type {number}
   */
  this.simulatedBy = messageRow.simulatedBy;

  /**
   * All other message content, including the 'packets' students will send.
   * @type {*}
   */
  this.payload = '';
  if (messageRow.base64Payload) {
    try {
      this.payload = base64ToBinary(messageRow.base64Payload.string, messageRow.base64Payload.len);
    } catch (e) {
      logger.error(e.message);
    }
  }

  /**
   * If this is an inter-router message, the number of routers this
   * message should try to visit before going to the router that
   * will actually lead to its destination.
   * @type {number}
   */
  this.extraHopsRemaining = utils.valueOr(messageRow.extraHopsRemaining, 0);

  /**
   * A history of router node IDs this message has visited.
   * @type {number[]}
   */
  this.visitedNodeIDs = utils.valueOr(messageRow.visitedNodeIDs, []);
};
NetSimMessage.inherits(NetSimEntity);

/**
 * Static row construction method. Used by dynamic buildRow method and
 * by static async API creation methods to create a properly-formatted
 * row for database insertion
 * @param {MessageData} messageData
 * @returns {MessageRow}
 * @throws {TypeError} if payload is invalid
 */
NetSimMessage.buildRowFromData = function (messageData) {
  return {
    fromNodeID: messageData.fromNodeID,
    toNodeID: messageData.toNodeID,
    simulatedBy: messageData.simulatedBy,
    base64Payload: binaryToBase64(messageData.payload),
    extraHopsRemaining: utils.valueOr(messageData.extraHopsRemaining, 0),
    visitedNodeIDs: utils.valueOr(messageData.visitedNodeIDs, [])
  };
};

/**
 * Static async creation method.  Creates a new message on the given shard,
 * and then calls the callback with a success boolean.
 * @param {!NetSimShard} shard
 * @param {!MessageData} messageData
 * @param {!NodeStyleCallback} onComplete (success)
 */
NetSimMessage.send = function (shard, messageData, onComplete) {
  try {
    var row = NetSimMessage.buildRowFromData(messageData);
    shard.messageTable.create(row, onComplete);
  } catch (err) {
    onComplete(err, null);
  }
};

/**
 * Static async multi-create method. Creates new messages on the given shard,
 * and then calls the callback with a success boolean.
 * @param {!NetSimShard} shard
 * @param {MessageData[]} messageDatas
 * @param {!NodeStyleCallback} onComplete (success)
 */
NetSimMessage.sendMany = function (shard, messageDatas, onComplete) {
  try {
    var rows = messageDatas.map(NetSimMessage.buildRowFromData);
    shard.messageTable.multiCreate(rows, onComplete);
  } catch (err) {
    onComplete(err, null);
  }
};

/**
 * Static helper.
 * @param {NetSimMessage} message
 * @returns {boolean} TRUE iff the given message is well-formed.
 */
NetSimMessage.isValid = function (message) {
  return (/^[01]*$/.test(message.payload)
  );
};

/**
 * Helper that gets the wires table for the configured instance.
 * @returns {NetSimTable}
 */
NetSimMessage.prototype.getTable = function () {
  return this.shard_.messageTable;
};

/**
 * Build own row for the message table
 * @returns {MessageRow}
 * @throws {TypeError} if payload is invalid
 */
NetSimMessage.prototype.buildRow = function () {
  return NetSimMessage.buildRowFromData(this);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogEntry.js":[function(require,module,exports){
/**
 * @overview Simulation entity for router log entries.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 5,
 maxstatements: 200
 */
'use strict';

var moment = require('moment');
var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimEntity = require('./NetSimEntity');
var Packet = require('./Packet');
var NetSimNodeFactory = require('./NetSimNodeFactory');
var DataConverters = require('./DataConverters');
var formatBinary = DataConverters.formatBinary;
var base64ToBinary = DataConverters.base64ToBinary;
var binaryToBase64 = DataConverters.binaryToBase64;
var NetSimLogger = require('./NetSimLogger');

var BITS_PER_BYTE = require('./NetSimConstants').BITS_PER_BYTE;
var logger = NetSimLogger.getSingleton();

/**
 * @typedef {Object} LogEntryRow
 * @property {number} nodeID
 * @property {Base64Payload} base64Binary - base64-encoded binary
 *           message content, all of which can be exposed to the
 *           student.  May contain headers of its own.
 * @property {NetSimLogEntry.LogStatus} status
 * @property {number} timestamp
 */

/**
 * Entry in shared log for a node on the network.
 *
 * Once created, should not be modified until/unless a cleanup process
 * removes it.
 *
 * @param {!NetSimShard} shard - The shard where this log entry lives.
 * @param {LogEntryRow} [row] - A row out of the log table on the
 *        shard.  If provided, will initialize this log with the given
 *        data.  If not, this log will initialize to default values.
 * @param {Packet.HeaderType[]} [packetSpec] - Packet layout spec used to
 *        interpret the contents of the logged packet
 * @constructor
 * @augments NetSimEntity
 */
var NetSimLogEntry = module.exports = function (shard, row, packetSpec) {
  row = row !== undefined ? row : {};
  NetSimEntity.call(this, shard, row);

  /**
   * Node ID of the node that owns this log entry (e.g. a router node)
   * @type {number}
   */
  this.nodeID = row.nodeID;

  /**
   * Binary content of the log entry.  Defaults to empty string.
   * @type {string}
   */
  this.binary = '';
  if (row.base64Binary) {
    try {
      this.binary = base64ToBinary(row.base64Binary.string, row.base64Binary.len);
    } catch (e) {
      logger.error(e.message);
    }
  }

  /**
   * Status value for log entry; for router log, usually SUCCESS for completion
   * of routing or DROPPED if routing failed.
   * @type {NetSimLogEntry.LogStatus}
   */
  this.status = utils.valueOr(row.status, NetSimLogEntry.LogStatus.SUCCESS);

  /**
   * @type {Packet}
   * @private
   */
  this.packet_ = new Packet(utils.valueOr(packetSpec, []), this.binary);

  /**
   * Unix timestamp (local) of log creation time.
   * @type {number}
   */
  this.timestamp = row.timestamp !== undefined ? row.timestamp : Date.now();
};
NetSimLogEntry.inherits(NetSimEntity);

/**
 * @enum {string}
 * @const
 */
NetSimLogEntry.LogStatus = {
  SUCCESS: 'success',
  DROPPED: 'dropped'
};

/**
 * Helper that gets the log table for the configured instance.
 * @returns {NetSimTable}
 */
NetSimLogEntry.prototype.getTable = function () {
  return this.shard_.logTable;
};

/**
 * Build own row for the log table
 * @returns {LogEntryRow}
 */
NetSimLogEntry.prototype.buildRow = function () {
  return {
    nodeID: this.nodeID,
    base64Binary: binaryToBase64(this.binary),
    status: this.status,
    timestamp: this.timestamp
  };
};

/**
 * Static async creation method.  Creates a new message on the given shard,
 * and then calls the callback with a success boolean.
 * @param {!NetSimShard} shard
 * @param {!number} nodeID - associated node's row ID
 * @param {!string} binary - log contents
 * @param {NetSimLogEntry.LogStatus} status
 * @param {!NodeStyleCallback} onComplete (success)
 */
NetSimLogEntry.create = function (shard, nodeID, binary, status, onComplete) {
  var entity = new NetSimLogEntry(shard);
  entity.nodeID = nodeID;
  entity.binary = binary;
  entity.status = status;
  entity.timestamp = Date.now();
  entity.getTable().create(entity.buildRow(), function (err, result) {
    if (err) {
      onComplete(err, null);
      return;
    }
    onComplete(err, new NetSimLogEntry(shard, result));
  });
};

/**
 * Get requested packet header field as a string.  Returns empty string
 * if the requested field is not in the current packet format.
 * @param {Packet.HeaderType} field
 * @returns {string}
 */
NetSimLogEntry.prototype.getHeaderField = function (field) {
  try {
    if (Packet.isAddressField(field)) {
      return this.packet_.getHeaderAsAddressString(field);
    } else {
      return this.packet_.getHeaderAsInt(field).toString();
    }
  } catch (e) {
    return '';
  }
};

/** Get packet message as binary. */
NetSimLogEntry.prototype.getMessageBinary = function () {
  return formatBinary(this.packet_.getBodyAsBinary(), BITS_PER_BYTE);
};

/** Get packet message as ASCII */
NetSimLogEntry.prototype.getMessageAscii = function () {
  return this.packet_.getBodyAsAscii(BITS_PER_BYTE);
};

/**
 * @returns {string} Localized packet status, "success" or "dropped"
 */
NetSimLogEntry.prototype.getLocalizedStatus = function () {
  if (this.status === NetSimLogEntry.LogStatus.SUCCESS) {
    return i18n.logStatus_success();
  } else if (this.status === NetSimLogEntry.LogStatus.DROPPED) {
    return i18n.logStatus_dropped();
  }
  return '';
};

/**
 * @returns {string} Localized "X of Y" packet count info for this entry.
 */
NetSimLogEntry.prototype.getLocalizedPacketInfo = function () {
  return i18n.xOfYPackets({
    x: this.getHeaderField(Packet.HeaderType.PACKET_INDEX),
    y: this.getHeaderField(Packet.HeaderType.PACKET_COUNT)
  });
};

/**
 * @returns {string} 12-hour time with milliseconds
 */
NetSimLogEntry.prototype.getTimeString = function () {
  return moment(this.timestamp).format('h:mm:ss.SSS A');
};

/**
 * Get a controller for the node that generated this log entry
 * @returns {NetSimClientNode|NetSimRouterNode|null}
 */
NetSimLogEntry.prototype.getOriginNode = function () {
  var nodeRows = this.shard_.nodeTable.readAll();
  var originNodeRow = _.find(nodeRows, (function (row) {
    return row.id === this.nodeID;
  }).bind(this));

  if (!originNodeRow) {
    return null;
  }

  return NetSimNodeFactory.nodeFromRow(this.shard_, originNodeRow);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimNodeFactory":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNodeFactory.js","./Packet":"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","moment":"/home/trevor/code-dot-org/apps/node_modules/moment/moment.js"}],"/home/trevor/code-dot-org/apps/node_modules/moment/moment.js":[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/Packet.js":[function(require,module,exports){
/**
 * @overview Utility class for encoding and decoding simulated packets.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var NetSimUtils = require('./NetSimUtils');
var DataConverters = require('./DataConverters');
var NetSimGlobals = require('./NetSimGlobals');

/**
 * Wraps binary packet content with the format information required to
 * interpret it.
 * @param {Packet.HeaderType[]} formatSpec
 * @param {string} binary
 * @constructor
 */
var Packet = module.exports = function (formatSpec, binary) {
  var level = NetSimGlobals.getLevelConfig();

  /** @type {Packet.Encoder} */
  this.encoder = new Packet.Encoder(level.addressFormat, level.packetCountBitWidth, formatSpec);

  /** @type {string} of binary content */
  this.binary = binary;
};

/**
 * Possible packet header fields.  Values to this enum become keys
 * that can be used when defining a level configuration.  They also correspond
 * to class names that get applied to fields representing data in that column.
 * @enum {string}
 * @readonly
 */
Packet.HeaderType = {
  TO_ADDRESS: 'toAddress',
  FROM_ADDRESS: 'fromAddress',
  PACKET_INDEX: 'packetIndex',
  PACKET_COUNT: 'packetCount'
};

/**
 * Whether the given header field type will use the address format.
 * @param {Packet.HeaderType} headerType
 * @returns {boolean}
 */
Packet.isAddressField = function (headerType) {
  return headerType === Packet.HeaderType.TO_ADDRESS || headerType === Packet.HeaderType.FROM_ADDRESS;
};

/**
 * Whether the given header field will use the packetCount bit width.
 * @param {Packet.HeaderType} headerType
 * @returns {boolean}
 */
Packet.isPacketField = function (headerType) {
  return headerType === Packet.HeaderType.PACKET_INDEX || headerType === Packet.HeaderType.PACKET_COUNT;
};

/**
 * @param {Packet.HeaderType} headerType
 * @returns {string} of binary content
 */
Packet.prototype.getHeaderAsBinary = function (headerType) {
  return this.encoder.getHeader(headerType, this.binary);
};

/**
 * @param {Packet.HeaderType} headerType
 * @returns {number}
 */
Packet.prototype.getHeaderAsInt = function (headerType) {
  return this.encoder.getHeaderAsInt(headerType, this.binary);
};

/**
 * @param {Packet.HeaderType} headerType
 * @returns {string}
 */
Packet.prototype.getHeaderAsAddressString = function (headerType) {
  return this.encoder.getHeaderAsAddressString(headerType, this.binary);
};

/**
 * @returns {string} binary content
 */
Packet.prototype.getBodyAsBinary = function () {
  return this.encoder.getBody(this.binary);
};

/**
 * @param {number} bitsPerChar
 * @returns {string} ascii content
 */
Packet.prototype.getBodyAsAscii = function (bitsPerChar) {
  return this.encoder.getBodyAsAscii(this.binary, bitsPerChar);
};

/**
 * Given a particular packet format, can convert a set of fields down
 * into a binary string matching the specification, or extract fields
 * on demand from a binary string.
 * @param {AddressHeaderFormat} addressFormat
 * @param {number} packetCountBitWidth
 * @param {Packet.HeaderType[]} headerSpec - Specification of packet format, an
 *        ordered set of objects in the form {key:string, bits:number} where
 *        key is the field name you'll use to retrieve the information, and
 *        bits is the length of the field.
 * @constructor
 */
Packet.Encoder = function (addressFormat, packetCountBitWidth, headerSpec) {
  /** @type {string} */
  this.addressFormat_ = addressFormat;

  this.addressBitWidth_ = this.calculateBitWidth(this.addressFormat_);

  /** @type {number} */
  this.packetCountBitWidth_ = packetCountBitWidth;

  /** @type {Packet.HeaderType[]} */
  this.headerSpec_ = headerSpec;

  this.validateSpec();
};

/**
 * @param {AddressHeaderFormat} addressFormat
 * @private
 */
Packet.Encoder.prototype.calculateBitWidth = function (addressFormat) {
  return addressFormat.split(/\D+/).reduce(function (prev, cur) {
    return prev + (parseInt(cur, 10) || 0);
  }, 0);
};

/**
 * Verify that the configured format specification describes a valid format that
 * can be used by the Packet.Encoder object.
 */
Packet.Encoder.prototype.validateSpec = function () {
  var keyCache = {};

  for (var i = 0; i < this.headerSpec_.length; i++) {
    var isAddressField = Packet.isAddressField(this.headerSpec_[i]);
    var isPacketField = Packet.isPacketField(this.headerSpec_[i]);

    if (isAddressField && this.addressBitWidth_ === 0) {
      throw new Error("Invalid packet format: Includes an address field but " + " address format is invalid.");
    }

    if (isPacketField && this.packetCountBitWidth_ === 0) {
      throw new Error("Invalid packet format: Includes a packet count field " + " but packet field bit width is zero");
    }

    if (!isAddressField && !isPacketField) {
      throw new Error("Invalid packet format: Unrecognized packet header field " + this.headerSpec_[i]);
    }

    if (keyCache.hasOwnProperty(this.headerSpec_[i])) {
      throw new Error("Invalid packet format: Field keys must be unique.");
    } else {
      keyCache[this.headerSpec_[i]] = 'used';
    }
  }
};

/**
 * Retrieve requested header field by key from the provided binary blob.
 *
 * @param {Packet.HeaderType} key - which header to retrieve
 * @param {string} binary for entire packet
 * @returns {string} binary string value for header field
 * @throws when requested key is not in the configured packet spec
 */
Packet.Encoder.prototype.getHeader = function (key, binary) {
  var ruleIndex = 0,
      binaryIndex = 0;

  // Strip whitespace so we don't worry about being passed formatted binary
  binary = DataConverters.minifyBinary(binary);

  while (this.headerSpec_[ruleIndex] !== key) {
    binaryIndex += this.getFieldBitWidth(this.headerSpec_[ruleIndex]);
    ruleIndex++;

    if (ruleIndex >= this.headerSpec_.length) {
      // Didn't find key
      throw new Error('Key "' + key + '" not found in packet spec.');
    }
  }

  // Read value
  var bitWidth = this.getFieldBitWidth(this.headerSpec_[ruleIndex]);
  var bits = binary.slice(binaryIndex, binaryIndex + bitWidth);

  // Right-pad with zeroes to desired size
  if (bitWidth !== Infinity) {
    while (bits.length < bitWidth) {
      bits += '0';
    }
  }

  return bits;
};

/**
 * @param {Packet.HeaderType} key - field name
 * @param {string} binary - entire packet as a binary string
 * @returns {number} - requested field, interpreted as an int.
 */
Packet.Encoder.prototype.getHeaderAsInt = function (key, binary) {
  return DataConverters.binaryToInt(this.getHeader(key, binary));
};

/**
 * Retrieve an address header as a string, so we can give the multi-part
 * representation.
 * @param {Packet.HeaderType} key
 * @param {string} binary for whole packet
 * @returns {string}
 */
Packet.Encoder.prototype.getHeaderAsAddressString = function (key, binary) {
  return DataConverters.binaryToAddressString(this.getHeader(key, binary), this.addressFormat_);
};

/**
 * Skip over headers given in spec and return remainder of binary which
 * must be the message body.
 * @param {string} binary - entire packet as a binary string
 * @returns {string} packet body binary string
 */
Packet.Encoder.prototype.getBody = function (binary) {
  return DataConverters.minifyBinary(binary).slice(this.getHeaderLength());
};

/**
 * @returns {number} How many bits the header takes up
 */
Packet.Encoder.prototype.getHeaderLength = function () {
  return this.headerSpec_.reduce((function (prev, cur) {
    return prev + this.getFieldBitWidth(cur);
  }).bind(this), 0);
};

/**
 * Skip over headers given in spec, and return remainder of packet interpreted
 * to ascii with the given character width.
 * @param {string} binary - entire packet as a binary string
 * @param {number} bitsPerChar - bits to represent as a single character,
 *        recommended to use 8 for normal ASCII.
 */
Packet.Encoder.prototype.getBodyAsAscii = function (binary, bitsPerChar) {
  return DataConverters.binaryToAscii(this.getBody(binary), bitsPerChar);
};

/**
 * @param {Packet.HeaderType} headerType
 * @returns {number} how many bits that field should take in the packet header
 */
Packet.Encoder.prototype.getFieldBitWidth = function (headerType) {
  if (Packet.isAddressField(headerType)) {
    return this.addressBitWidth_;
  }

  if (Packet.isPacketField(headerType)) {
    return this.packetCountBitWidth_;
  }

  // Should never get here.
  throw new Error("Unable to select a bit-width for field " + headerType);
};

/**
 * Given a "headers" object where the values are numbers, returns a corresponding
 * "headers" object where the values have all been converted to binary
 * representations at the appropriate width.  Only header fields that appear in
 * the configured packet header format will be converted and passed through to
 * output.
 * @param {Object} headers - with number values
 */
Packet.Encoder.prototype.makeBinaryHeaders = function (headers) {
  var binaryHeaders = {};
  this.headerSpec_.forEach(function (headerField) {
    if (headers.hasOwnProperty(headerField)) {
      // Convert differently for address and packet fields?
      if (Packet.isAddressField(headerField)) {
        binaryHeaders[headerField] = this.addressStringToBinary(headers[headerField]);
      } else {
        binaryHeaders[headerField] = DataConverters.intToBinary(headers[headerField], this.getFieldBitWidth(headerField));
      }
    }
  }, this);
  return binaryHeaders;
};

/**
 * Convert an address string (possibly multi-part) into binary based on the
 * configured address format.
 * @param {string} address
 * @returns {string} binary representation
 */
Packet.Encoder.prototype.addressStringToBinary = function (address) {
  return DataConverters.addressStringToBinary(address, this.addressFormat_);
};

/**
 * Takes a set of binary headers and a binary body, and generates a complete
 * packet binary matching the configured packet spec in terms of header width
 * and ordering.
 *
 * @param {Object} binaryHeaders - hash containing packet headers in binary, where
 *        the hash keys correspond to the "key" values in the packet spec, and
 *        the hash values are binary strings.
 * @param {string} body - binary string of the unlimited-length body of the
 *        packet, which will be placed after the packet headers.
 *
 * @returns {string} binary string of provided data, conforming to configured
 *          packet format.
 */
Packet.Encoder.prototype.concatenateBinary = function (binaryHeaders, body) {
  var parts = [];

  this.headerSpec_.forEach(function (fieldSpec) {
    var fieldWidth = this.getFieldBitWidth(fieldSpec);

    // Get header value from provided headers, if it exists.
    // If not, we'll start with an empty string and pad it to the correct
    // length, below.
    var fieldBits = binaryHeaders.hasOwnProperty(fieldSpec) ? binaryHeaders[fieldSpec] : '';

    // Right-truncate to the desired size
    fieldBits = fieldBits.slice(0, fieldWidth);

    // Left-pad to desired size
    fieldBits = NetSimUtils.zeroPadLeft(fieldBits, fieldWidth);

    parts.push(fieldBits);
  }, this);

  parts.push(body);

  return parts.join('');
};

},{"./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTab.js":[function(require,module,exports){
/**
 * @overview UI controller for the DNS tab in the left column.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimDnsTab.html.ejs');
var DnsMode = require('./NetSimConstants').DnsMode;
var NetSimDnsModeControl = require('./NetSimDnsModeControl');
var NetSimDnsManualControl = require('./NetSimDnsManualControl');
var NetSimDnsTable = require('./NetSimDnsTable');
var NetSimGlobals = require('./NetSimGlobals');

/**
 * Generator and controller for "DNS" tab.
 * @param {jQuery} rootDiv
 * @param {function} dnsModeChangeCallback
 * @param {function} becomeDnsCallback
 * @constructor
 */
var NetSimDnsTab = module.exports = function (rootDiv, dnsModeChangeCallback, becomeDnsCallback) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {function}
   * @private
   */
  this.dnsModeChangeCallback_ = dnsModeChangeCallback;

  /**
   * @type {function}
   * @private
   */
  this.becomeDnsCallback_ = becomeDnsCallback;

  /**
   * @type {NetSimDnsModeControl}
   * @private
   */
  this.dnsModeControl_ = null;

  /**
   * @type {NetSimDnsManualControl}
   * @private
   */
  this.dnsManualControl_ = null;

  /**
   * @type {NetSimDnsTable}
   * @private
   */
  this.dnsTable_ = null;

  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimDnsTab.prototype.render = function () {
  var levelConfig = NetSimGlobals.getLevelConfig();

  var renderedMarkup = $(markup({
    level: levelConfig
  }));
  this.rootDiv_.html(renderedMarkup);

  if (levelConfig.showDnsModeControl) {
    this.dnsModeControl_ = new NetSimDnsModeControl(this.rootDiv_.find('.dns_mode'), this.dnsModeChangeCallback_);
  }

  this.dnsManualControl_ = new NetSimDnsManualControl(this.rootDiv_.find('.dns_manual_control'), this.becomeDnsCallback_);

  this.dnsTable_ = new NetSimDnsTable(this.rootDiv_.find('.dns_table'));
};

/**
 * @param {DnsMode} newDnsMode
 */
NetSimDnsTab.prototype.setDnsMode = function (newDnsMode) {
  if (this.dnsModeControl_) {
    this.dnsModeControl_.setDnsMode(newDnsMode);
  }

  this.dnsTable_.setDnsMode(newDnsMode);
  this.rootDiv_.find('.dns_manual_control').toggle(newDnsMode === DnsMode.MANUAL);
  this.rootDiv_.find('.dns-notes').toggle(newDnsMode !== DnsMode.NONE);
};

/**
 * @param {boolean} isDnsNode
 */
NetSimDnsTab.prototype.setIsDnsNode = function (isDnsNode) {
  this.dnsManualControl_.setIsDnsNode(isDnsNode);
};

/**
 * @param {Array} tableContents
 */
NetSimDnsTab.prototype.setDnsTableContents = function (tableContents) {
  this.dnsTable_.setDnsTableContents(tableContents);
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimDnsManualControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsManualControl.js","./NetSimDnsModeControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsModeControl.js","./NetSimDnsTab.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTab.html.ejs","./NetSimDnsTable":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTable.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTable.js":[function(require,module,exports){
/**
 * @overview UI table of local subnet, displaying hostname => address map.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimDnsTable.html.ejs');
var DnsMode = require('./NetSimConstants').DnsMode;

/**
 * Generator and controller for DNS network lookup table component.
 * Shows different amounts of information depending on the DNS mode.
 *
 * @param {jQuery} rootDiv
 * @constructor
 */
var NetSimDnsTable = module.exports = function (rootDiv) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {DnsMode}
   * @private
   */
  this.dnsMode_ = DnsMode.NONE;

  /**
   * @type {Array}
   * @private
   */
  this.addressTableData_ = [];

  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimDnsTable.prototype.render = function () {
  var renderedMarkup = $(markup({
    dnsMode: this.dnsMode_,
    tableData: this.addressTableData_
  }));
  this.rootDiv_.html(renderedMarkup);
};

/**
 * @param {DnsMode} newDnsMode
 */
NetSimDnsTable.prototype.setDnsMode = function (newDnsMode) {
  this.dnsMode_ = newDnsMode;
  this.render();
};

/**
 * @param {Array} tableContents
 */
NetSimDnsTable.prototype.setDnsTableContents = function (tableContents) {
  this.addressTableData_ = tableContents;
  this.render();
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimDnsTable.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTable.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTable.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var DnsMode = require('./NetSimConstants').DnsMode;
; buf.push('\n<div class="netsim-dns-table">\n  <h1>My Network</h1>\n  <table>\n    <thead>\n    <tr>\n      <th>Hostname</th>\n      <th>Address</th>\n    </tr>\n    </thead>\n    <tbody>\n    ');14;
    tableData.forEach(function (row) {
      var displayHostname = row.hostname;
      var displayAddress = '';
      var rowClasses = [];

      if (dnsMode === DnsMode.NONE || row.isDnsNode || row.isLocal) {
        displayAddress = row.address;
      }

      if (row.isLocal) {
        displayHostname += " (Me)";
        rowClasses.push('local-node');
      }

      if (row.isDnsNode && dnsMode !== DnsMode.NONE) {
        displayHostname += " (DNS)";
        rowClasses.push('dns-node');
      }
      ; buf.push('\n        <tr class="', escape((34,  rowClasses.join(' ') )), '">\n          <td>', escape((35,  displayHostname )), '</td>\n          <td>', escape((36,  displayAddress )), '</td>\n        </tr>\n      ');38;
    });
    ; buf.push('\n    </tbody>\n  </table>\n</div>'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsTab.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="netsim-dns-tab">\n  ');2; if (level.showDnsModeControl) { ; buf.push('\n  <div class="dns_mode"></div>\n  ');4; } ; buf.push('\n  <div class="dns_manual_control"></div>\n  <div class="dns_table"></div>\n  <div class="dns-notes">\n    <h1>Notes</h1>\n    <div>\n      <textarea></textarea>\n    </div>\n  </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsModeControl.js":[function(require,module,exports){
/**
 * @overview UI component used to select a DNS mode at runtime.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimDnsModeControl.html.ejs');
var DnsMode = require('./NetSimConstants').DnsMode;

/**
 * Generator and controller for DNS mode selector
 * @param {jQuery} rootDiv
 * @param {function} dnsModeChangeCallback
 * @constructor
 */
var NetSimDnsModeControl = module.exports = function (rootDiv, dnsModeChangeCallback) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {function}
   * @private
   */
  this.dnsModeChangeCallback_ = dnsModeChangeCallback;

  /**
   * Set of all DNS mode radio buttons
   * @type {jQuery}
   * @private
   */
  this.dnsModeRadios_ = null;

  /**
   * Internal state: Current DNS mode.
   * @type {DnsMode}
   * @private
   */
  this.currentDnsMode_ = DnsMode.NONE;

  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimDnsModeControl.prototype.render = function () {
  var renderedMarkup = $(markup({}));
  this.rootDiv_.html(renderedMarkup);

  this.dnsModeRadios_ = this.rootDiv_.find('input[type="radio"][name="dns_mode"]');
  this.dnsModeRadios_.change(this.onDnsModeChange_.bind(this));
  this.setDnsMode(this.currentDnsMode_);
};

/**
 * Handler for a new radio button being selected.
 * @private
 */
NetSimDnsModeControl.prototype.onDnsModeChange_ = function () {
  var newDnsMode = this.dnsModeRadios_.filter(':checked').val();
  this.dnsModeChangeCallback_(newDnsMode);
};

/**
 * @param {DnsMode} newDnsMode
 */
NetSimDnsModeControl.prototype.setDnsMode = function (newDnsMode) {
  this.currentDnsMode_ = newDnsMode;
  this.dnsModeRadios_.filter('[value="' + newDnsMode + '"]').prop('checked', true);
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimDnsModeControl.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsModeControl.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsModeControl.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var DnsMode = require('./NetSimConstants').DnsMode;
  var i18n = require('./locale');

  /**
   * @param {exports.DnsMode} mode
   * @param {string} label
   */
  function makeRadio(mode, label) {
    ; buf.push('\n    <div class="dns_mode_', escape((11,  mode )), '">\n      <input id="dns_mode_', escape((12,  mode )), '"\n                   type="radio"\n                   name="dns_mode"\n                   value="', escape((15,  mode )), '" />\n      <label for="dns_mode_', escape((16,  mode )), '">', escape((16,  label )), '</label>\n    </div>\n    ');18;
  }
; buf.push('\n<div class="dns-mode-control">\n  <h1>', escape((22,  i18n.dnsMode() )), '</h1>\n  ');23; makeRadio(DnsMode.NONE, i18n.dnsMode_NONE()); ; buf.push('\n  ');24; makeRadio(DnsMode.MANUAL, i18n.dnsMode_MANUAL()); ; buf.push('\n  ');25; makeRadio(DnsMode.AUTOMATIC, i18n.dnsMode_AUTOMATIC()); ; buf.push('\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsManualControl.js":[function(require,module,exports){
/**
 * @overview UI button used become the current DNS node in manual DNS mode.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimDnsManualControl.html.ejs');

/**
 * Generator and controller for DNS mode selector
 * @param {jQuery} rootDiv
 * @param {function} becomeDnsCallback
 * @constructor
 */
var NetSimDnsManualControl = module.exports = function (rootDiv, becomeDnsCallback) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {function}
   * @private
   */
  this.becomeDnsCallback_ = becomeDnsCallback;

  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimDnsManualControl.prototype.render = function () {
  var renderedMarkup = $(markup({}));
  this.rootDiv_.html(renderedMarkup);
  this.rootDiv_.find('input[type="button"]').click(this.onBecomeDnsButtonClick_.bind(this));
};

/**
 * Handler for button click.
 * @private
 */
NetSimDnsManualControl.prototype.onBecomeDnsButtonClick_ = function () {
  this.becomeDnsCallback_();
};

/**
 * @param {boolean} isDnsNode
 */
NetSimDnsManualControl.prototype.setIsDnsNode = function (isDnsNode) {
  this.rootDiv_.find('input[type="button"]').attr('disabled', isDnsNode);
};

},{"./NetSimDnsManualControl.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsManualControl.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimDnsManualControl.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="netsim_dns_manual_control">\n  <h1>Manual Control</h1>\n  <input id="become_dns_button" type="button" value="Take over as DNS" />\n</div>'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimClientNode.js":[function(require,module,exports){
/**
 * @overview Simulated client node.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NodeType = require('./NetSimConstants').NodeType;
var NetSimEntity = require('./NetSimEntity');
var NetSimNode = require('./NetSimNode');
var NetSimWire = require('./NetSimWire');

/**
 * Client model of simulated node
 *
 * Represents the client's view of a node that is controlled by a user client,
 * either by our own client or somebody else's.  Is a NetSimEntity, meaning
 * it wraps a row in the node table and provides functionality around it.
 *
 * You may be looking for NetSimLocalClientNode if you're trying to manipulate
 * your local client node.
 *
 * @param {!NetSimShard} shard
 * @param {Object} [clientRow] - Lobby row for this router.
 * @constructor
 * @augments NetSimNode
 */
var NetSimClientNode = module.exports = function (shard, clientRow) {
  NetSimNode.call(this, shard, clientRow);
};
NetSimClientNode.inherits(NetSimNode);

/** @inheritdoc */
NetSimClientNode.prototype.getNodeType = function () {
  return NodeType.CLIENT;
};

/** @inheritdoc */
NetSimClientNode.prototype.getStatus = function () {
  var outgoingWire = this.getOutgoingWire();
  if (!outgoingWire) {
    return i18n.notConnected();
  }

  // Get remote node for display name / hostname
  var cachedNodeRows = this.shard_.nodeTable.readAll();
  var remoteNodeRow = _.find(cachedNodeRows, function (nodeRow) {
    return nodeRow.id === outgoingWire.remoteNodeID;
  });

  var remoteNodeName = i18n.unknownNode();
  if (remoteNodeRow) {
    remoteNodeName = remoteNodeRow.name;
  }

  // Check for connection state
  var mutualConnection;
  if (remoteNodeRow && remoteNodeRow.type === NodeType.ROUTER) {
    mutualConnection = true;
  } else {
    var cachedWireRows = this.shard_.wireTable.readAll();
    mutualConnection = cachedWireRows.some(function (wireRow) {
      return wireRow.localNodeID === outgoingWire.remoteNodeID && wireRow.remoteNodeID === outgoingWire.localNodeID;
    });
  }

  if (mutualConnection) {
    return i18n.connectedToNodeName({ nodeName: remoteNodeName });
  }
  return i18n.connectingToNodeName({ nodeName: remoteNodeName });
};

/** @inheritdoc */
NetSimClientNode.prototype.isFull = function () {
  var outgoingWire = this.getOutgoingWire();
  if (!outgoingWire) {
    return false;
  }
  var cachedWireRows = this.shard_.wireTable.readAll();
  return cachedWireRows.some(function (wireRow) {
    return wireRow.localNodeID === outgoingWire.remoteNodeID && wireRow.remoteNodeID === outgoingWire.localNodeID;
  });
};

/**
 * Determine what address has been assigned to this client on its outgoing
 * wire.
 * @returns {string|undefined}
 */
NetSimClientNode.prototype.getAddress = function () {
  var wire = this.getOutgoingWire();
  if (!wire) {
    return undefined;
  }
  return wire.localAddress;
};

/**
 * Based on cached wire data, retrieve this node's outgoing wire.
 * @returns {NetSimWire|null} null if wire does not exist.
 */
NetSimClientNode.prototype.getOutgoingWire = function () {
  var cachedWireRows = this.shard_.wireTable.readAll();
  var outgoingWireRow = _.find(cachedWireRows, function (wireRow) {
    return wireRow.localNodeID === this.entityID;
  }, this);
  if (outgoingWireRow) {
    return new NetSimWire(this.shard_, outgoingWireRow);
  }
  return null;
};

/**
 * Static async retrieval method.  See NetSimEntity.get().
 * @param {!number} nodeID - The row ID for the entity you'd like to find.
 * @param {!NetSimShard} shard
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        found entity, or null if entity search failed.
 */
NetSimClientNode.get = function (nodeID, shard, onComplete) {
  NetSimEntity.get(NetSimClientNode, nodeID, shard, onComplete);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimNode":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNode.js","./NetSimWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimWire.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimNode.js":[function(require,module,exports){
/**
 * @overview A base class for all simulation node entities.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

require('../utils');
var i18n = require('./locale');
var NetSimEntity = require('./NetSimEntity');
var NetSimWire = require('./NetSimWire');

/**
 * Client model of simulated network entity, which lives
 * in a shard table.
 *
 * Wraps the entity row with helper methods for examining and maintaining
 * the entity state in shared storage.
 *
 * @param {!NetSimShard} shard
 * @param {Object} [nodeRow] JSON row from table.
 * @constructor
 * @augments NetSimEntity
 */
var NetSimNode = module.exports = function (shard, nodeRow) {
  nodeRow = nodeRow !== undefined ? nodeRow : {};
  NetSimEntity.call(this, shard, nodeRow);

  /**
   * @type {string}
   * @private
   */
  this.displayName_ = nodeRow.name;
};
NetSimNode.inherits(NetSimEntity);

/**
 * Get shared table for nodes
 * @returns {SharedTable}
 * @private
 */
NetSimNode.prototype.getTable = function () {
  return this.shard_.nodeTable;
};

/** Build table row for this node */
NetSimNode.prototype.buildRow = function () {
  return {
    type: this.getNodeType(),
    name: this.getDisplayName()
  };
};

/**
 * Get node's display name, which is stored in table.
 * @returns {string}
 */
NetSimNode.prototype.getDisplayName = function () {
  return this.displayName_ ? this.displayName_ : i18n.defaultNodeName();
};

/**
 * Get node's short display name, which is the same as the display name
 * but truncated to the first word if it's over a certain length.
 * @returns {string}
 */
NetSimNode.prototype.getShortDisplayName = function () {
  // If the name is longer than ten characters (longer than "Router 999")
  // then only show up to the first whitespace.
  var shortName = this.getDisplayName();
  if (shortName.length > 10) {
    shortName = shortName.split(/\s/)[0];
  }
  return shortName;
};

/**
 * Get node's hostname, a modified version of its display name.
 * @returns {string}
 */
NetSimNode.prototype.getHostname = function () {
  // Strip everything that's not a word-character or a digit from the display
  // name, then append the node ID so that hostnames are more likely to
  // be unique.
  return this.getShortDisplayName().replace(/[^\w\d]/g, '').toLowerCase() + this.entityID;
};

/**
 * Get node's type.
 * @returns {NodeType}
 */
NetSimNode.prototype.getNodeType = function () {
  throw new Error('getNodeType method is not implemented');
};

/**
 * Get localized description of node status.
 * @returns {string}
 */
NetSimNode.prototype.getStatus = function () {
  throw new Error('getStatus method is not implemented');
};

/**
 * Whether or not this node can accept any more connections
 * @returns {boolean}
 */
NetSimNode.prototype.isFull = function () {
  throw new Error('isFull method is not implemented');
};

/**
 * Establish a connection between this node and another node,
 * by creating a wire between them, and verifying that the remote node
 * can accept the connection.
 * When finished, calls onComplete({the new wire})
 * On failure, calls onComplete(null)
 * @param {!NetSimNode} otherNode
 * @param {NodeStyleCallback} [onComplete]
 */
NetSimNode.prototype.connectToNode = function (otherNode, onComplete) {
  onComplete = onComplete || function () {};

  var self = this;
  NetSimWire.create(this.shard_, this.makeWireRowForConnectingTo(otherNode), function (err, wire) {
    if (err) {
      onComplete(err, null);
      return;
    }

    otherNode.acceptConnection(self, function (err, isAccepted) {
      if (err || !isAccepted) {
        wire.destroy(function () {
          onComplete(new Error('Connection rejected: ' + err.message), null);
        });
        return;
      }

      onComplete(null, wire);
    });
  });
};

/**
 * Create an appropriate initial wire row for connecting to the given node.
 * @param {!NetSimNode} otherNode
 * @returns {WireRow}
 */
NetSimNode.prototype.makeWireRowForConnectingTo = function (otherNode) {
  return {
    localNodeID: this.entityID,
    remoteNodeID: otherNode.entityID
  };
};

/**
 * Called when another node establishes a connection to this one, giving this
 * node a chance to reject the connection.
 * @param {!NetSimNode} otherNode attempting to connect to this one
 * @param {!NodeStyleCallback} onComplete response method - should call with TRUE
 *        if connection is allowed, FALSE if connection is rejected.
 */
NetSimNode.prototype.acceptConnection = function (otherNode, onComplete) {
  onComplete(null, true);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js","./NetSimWire":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimWire.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimWire.js":[function(require,module,exports){
/**
 * @overview Simulation Entity: A connection between two nodes and related
 *           metadata.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils');
var NetSimEntity = require('./NetSimEntity');
var ArgumentUtils = require('./ArgumentUtils');

/**
 * @typedef {Object} WireRow
 * @property {!number} localNodeID
 * @property {!number} remoteNodeID
 * @property {string} localAddress
 * @property {string} remoteAddress
 * @property {string} localHostname
 * @property {string} remoteHostname
 */

/**
 * Local controller for a simulated connection between nodes,
 * which is stored in the wire table on the shard.  The controller can
 * be initialized with the JSON row from the table, effectively wrapping that
 * data in helpful methods.
 *
 * @param {!NetSimShard} shard - The shard where this wire lives.
 * @param {WireRow} [wireRow] - A row out of the _wire table on the shard.
 *        If provided, will initialize this wire with the given data.  If not,
 *        this wire will initialize to default values.
 * @constructor
 * @augments NetSimEntity
 */
var NetSimWire = module.exports = function (shard, wireRow) {
  wireRow = wireRow !== undefined ? wireRow : {};
  NetSimEntity.call(this, shard, wireRow);

  /**
   * Connected node row IDs within the _lobby table
   * @type {number}
   */
  this.localNodeID = wireRow.localNodeID;
  /** @type {number} */
  this.remoteNodeID = wireRow.remoteNodeID;

  /**
   * Assigned local addresses for the ends of this wire.
   * @type {string}
   */
  this.localAddress = wireRow.localAddress;
  /** @type {string} */
  this.remoteAddress = wireRow.remoteAddress;

  /**
   * Display hostnames for the ends of this wire.
   * Generally, each endpoint should set its own hostname.
   * @type {string}
   */
  this.localHostname = wireRow.localHostname;
  /** @type {string} */
  this.remoteHostname = wireRow.remoteHostname;
};
NetSimWire.inherits(NetSimEntity);

/**
 * Static async creation method.  See NetSimEntity.create().
 * @param {!NetSimShard} shard
 * @param {!WireRow} initialRow
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        created entity, or null if entity creation failed.
 */
NetSimWire.create = function (shard, initialRow, onComplete) {
  ArgumentUtils.validateRequired(initialRow, "initialRow");
  ArgumentUtils.validateRequired(initialRow.localNodeID, "localNodeID", ArgumentUtils.isPositiveNoninfiniteNumber);
  ArgumentUtils.validateRequired(initialRow.remoteNodeID, "remoteNodeID", ArgumentUtils.isPositiveNoninfiniteNumber);
  var entity = new NetSimWire(shard, initialRow);
  entity.getTable().create(entity.buildRow(), function (err, row) {
    if (err) {
      onComplete(err, null);
      return;
    }
    onComplete(null, new NetSimWire(shard, row));
  });
};

/**
 * Helper that gets the wires table for the configured shard.
 * @returns {NetSimTable}
 */
NetSimWire.prototype.getTable = function () {
  return this.shard_.wireTable;
};

/**
 * Build own row for the wire table
 * @returns {WireRow}
 */
NetSimWire.prototype.buildRow = function () {
  return {
    localNodeID: this.localNodeID,
    remoteNodeID: this.remoteNodeID,
    localAddress: this.localAddress,
    remoteAddress: this.remoteAddress,
    localHostname: this.localHostname,
    remoteHostname: this.remoteHostname
  };
};

/**
 * @param {MessageRow} messageRow
 * @returns {boolean} TRUE if the given message is travelling between the nodes
 *          that this wire connects, in the wire's direction.
 */
NetSimWire.prototype.isMessageRowOnDuplexWire = function (messageRow) {
  return this.localNodeID === messageRow.fromNodeID && this.remoteNodeID === messageRow.toNodeID;
};

/**
 * @param {MessageRow} messageRow
 * @returns {boolean} TRUE if the given message is travelling between the nodes
 *          that this wire connects, in either direction.
 */
NetSimWire.prototype.isMessageRowOnSimplexWire = function (messageRow) {
  var onWire = this.isMessageRowOnDuplexWire(messageRow);
  var onReverseWire = this.localNodeID === messageRow.toNodeID && this.remoteNodeID === messageRow.fromNodeID;
  return onWire || onReverseWire;
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./ArgumentUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/ArgumentUtils.js","./NetSimEntity":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEntity.js":[function(require,module,exports){
/**
 * @overview base class for all simulation entities.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

/**
 * Client model of simulated network entity, which lives in a shard table.
 *
 * Wraps the entity row with helper methods for examining and maintaining
 * the entity state in shared storage.
 *
 * @param {!NetSimShard} shard
 * @param {Object} [entityRow] JSON row from table.
 * @constructor
 */
var NetSimEntity = module.exports = function (shard, entityRow) {
  if (entityRow === undefined) {
    entityRow = {};
  }

  /**
   * @type {NetSimShard}
   * @protected
   */
  this.shard_ = shard;

  /**
   * Node's row ID within the _lobby table.  Unique within instance.
   * @type {number}
   */
  this.entityID = entityRow.id;

  /**
   * Node's UUID assigned when it was initially inserted into the table.
   * @type {string}
   */
  this.uuid = entityRow.uuid;
};

/**
 * Static async creation method.  Creates a new entity on the given shard,
 * and then calls the callback with a local controller for the new entity.
 * @param {!function} EntityType - The constructor for the entity type you want
 *        to create.
 * @param {!NetSimShard} shard
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        created entity, or null if entity creation failed.
 */
NetSimEntity.create = function (EntityType, shard, onComplete) {
  var entity = new EntityType(shard);
  entity.getTable().create(entity.buildRow(), function (err, row) {
    if (err) {
      onComplete(err, null);
    } else {
      onComplete(null, new EntityType(shard, row));
    }
  });
};

/**
 * Static async retrieval method.  Searches for a new entity on the given
 * shard, and then calls the callback with a local controller for the
 * found entity.
 * @param {!function} EntityType - The constructor for the entity type you want
 *        to find.
 * @param {!number} entityID - The row ID for the entity you'd like to find.
 * @param {!NetSimShard} shard
 * @param {!NodeStyleCallback} onComplete - Method that will be given the
 *        found entity, or null if entity search failed.
 */
NetSimEntity.get = function (EntityType, entityID, shard, onComplete) {
  var entity = new EntityType(shard);
  entity.getTable().read(entityID, function (err, row) {
    if (err) {
      onComplete(err, null);
    } else {
      onComplete(err, new EntityType(shard, row));
    }
  });
};

/**
 * Push entity state into remote storage.
 * @param {NodeStyleCallback} [onComplete] - Optional completion callback.
 */
NetSimEntity.prototype.update = function (onComplete) {
  onComplete = onComplete || function () {};

  this.getTable().update(this.entityID, this.buildRow(), onComplete);
};

/**
 * Remove entity from remote storage.
 * @param {NodeStyleCallback} [onComplete] - Optional completion callback
 */
NetSimEntity.prototype.destroy = function (onComplete) {
  onComplete = onComplete || function () {};

  this.getTable()['delete'](this.entityID, onComplete);
};

/**
 * Remove entity from remote storage, using a synchronous call.
 * For use when navigating away from the page; otherwise, async version
 * is preferred.
 * @returns {Error|null} error if entity delete fails
 */
NetSimEntity.prototype.synchronousDestroy = function () {
  return this.getTable().synchronousDelete(this.entityID);
};

/** Get storage table for this entity type. */
NetSimEntity.prototype.getTable = function () {
  // This method should be implemented by a child class.
  throw new Error('Method getTable is not implemented.');
};

/** Construct table row for this entity. */
NetSimEntity.prototype.buildRow = function () {
  return {};
};

/**
 * Destroys all provided entities (from remote storage) asynchronously, and
 * calls onComplete when all entities have been destroyed and/or an error occurs.
 * @param {NetSimEntity[]} entities
 * @param {!NodeStyleCallback} onComplete
 * @throws {Error} if all passed entities do not belong to the same table.
 */
NetSimEntity.destroyEntities = function (entities, onComplete) {
  if (entities.length === 0) {
    onComplete(null, true);
    return;
  }

  var table = entities[0].getTable();
  var entityIDs = entities.map(function (entity) {
    if (entity.getTable() !== table) {
      throw new Error("destroyEntities requires all entities to be in the same table");
    }
    return entity.entityID;
  });

  table.deleteMany(entityIDs, onComplete);
};

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimChunkSizeControl.js":[function(require,module,exports){
/**
 * @overview UI slider used to change the local device's chunk size, which
 *           is used when interpreting binary to other formats.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var i18n = require('./locale');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for chunk size slider/selector
 * @param {jQuery} rootDiv
 * @param {function} chunkSizeChangeCallback
 * @constructor
 * @augments NetSimSlider
 */
var NetSimChunkSizeControl = module.exports = function (rootDiv, chunkSizeChangeCallback) {
  NetSimSlider.call(this, rootDiv, {
    onChange: chunkSizeChangeCallback,
    min: 1,
    max: 32
  });

  // Auto-render, unlike our parent class
  this.render();
};
NetSimChunkSizeControl.inherits(NetSimSlider);

/**
 * Converts an external-facing numeric value into a localized string
 * representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimChunkSizeControl.prototype.valueToLabel = function (val) {
  return i18n.numBitsPerChunk({
    numBits: val
  });
};

/**
 * Alternate label converter, used for slider end labels.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimChunkSizeControl.prototype.valueToShortLabel = function (val) {
  return val.toString();
};

},{"./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitRateControl.js":[function(require,module,exports){
/**
 * @overview UI slider used to change the local device's bitrate.
 *           Differs from the pulse rate slider in scale and units.
 * @see NetSimPulseRateControl
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

// Utils required only for Function.prototype.inherits()
require('../utils');
var NetSimUtils = require('./NetSimUtils');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for packet size slider/selector
 * @param {jQuery} rootDiv
 * @param {number} initialValue - in bits per second
 * @param {function} sliderChangeCallback
 * @constructor
 */
var NetSimBitRateControl = module.exports = function (rootDiv, initialValue, sliderChangeCallback) {
  NetSimSlider.call(this, rootDiv, {
    onChange: sliderChangeCallback,
    value: initialValue,
    min: 1,
    max: 20,
    upperBoundInfinite: true
  });

  // Auto-render, unlike our base class
  this.render();
};
NetSimBitRateControl.inherits(NetSimSlider);

/**
 * Converts a numeric rate value (in bits pers second) into a
 * localized string representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimBitRateControl.prototype.valueToLabel = function (val) {
  return NetSimUtils.bitrateToLocalizedRoundedBitrate(val);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitLogPanel.js":[function(require,module,exports){
/**
 * @overview UI component, a log panel (used as "Sent Bits" and "Received Bits")
 *           that is used in the single-bit-sending configurations of the simulator.
 *
 * @see INetSimLogPanel for the interface implemented here.
 * @see NetSimLogPanel for the component used in packet-sending mode.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

require('../utils'); // For Function.prototype.inherits()
var i18n = require('./locale');
var markup = require('./NetSimBitLogPanel.html.ejs');
var NetSimPanel = require('./NetSimPanel');
var NetSimEncodingControl = require('./NetSimEncodingControl');
var NetSimGlobals = require('./NetSimGlobals');

var logger = require('./NetSimLogger').getSingleton();

/**
 * Generator and controller for bit-log, which receives bits one at a time.
 * @param {jQuery} rootDiv
 * @param {Object} options
 * @param {string} options.logTitle
 * @param {boolean} [options.isMinimized] defaults to FALSE
 * @param {boolean} [options.showReadWireButton] defaults to FALSE
 * @param {NetSim} options.netsim
 * @constructor
 * @augments NetSimPanel
 * @implements INetSimLogPanel
 */
var NetSimBitLogPanel = module.exports = function (rootDiv, options) {
  /**
   * The current binary contents of the log panel
   * @type {string}
   * @private
   */
  this.binary_ = '';

  /**
   * A message encoding (display) setting.
   * @type {string}
   * @private
   */
  this.encodings_ = [];

  /**
   * Current chunk size (bytesize) for interpreting binary in the log.
   * @type {number}
   * @private
   */
  this.chunkSize_ = 8;

  /**
   * Localized panel title
   * @type {string}
   * @private
   */
  this.logTitle_ = options.logTitle;

  /**
   * Reference to the top-level NetSim controller for reading bits and
   * triggering animations.
   * @type {NetSim}
   * @private
   */
  this.netsim_ = options.netsim;

  /**
   * Whether this log should have a "Read Wire" button.
   * @type {boolean}
   * @private
   */
  this.showReadWireButton_ = options.showReadWireButton;

  /**
   * How tall the overall panel should be when it's open (in pixels).
   * Set by a dynamic resize system.
   * @type {number}
   * @private
   */
  this.openHeight_ = 0;

  // Initial render
  NetSimPanel.call(this, rootDiv, {
    className: 'netsim-log-panel',
    panelTitle: options.logTitle,
    beginMinimized: options.isMinimized
  });
};
NetSimBitLogPanel.inherits(NetSimPanel);

NetSimBitLogPanel.prototype.render = function () {
  // Create boilerplate panel markup
  NetSimBitLogPanel.superPrototype.render.call(this);

  // Add our own content markup
  var newMarkup = $(markup({
    binary: this.binary_,
    enabledEncodings: this.encodings_,
    chunkSize: this.chunkSize_,
    showReadWireButton: this.showReadWireButton_
  }));
  this.getBody().html(newMarkup);
  NetSimEncodingControl.hideRowsByEncoding(this.getBody(), this.encodings_);

  this.getBody().find('#read-wire-button').click(this.onReceiveButtonPress_.bind(this));

  // Add a clear button to the panel header
  this.addButton(i18n.clear(), this.onClearButtonPress_.bind(this));

  // Snap back to the dynamic size we've been given.
  this.sizeToOpenHeight_();
};

/**
 * Remove all packets from the log, resetting its state.
 * @private
 */
NetSimBitLogPanel.prototype.onClearButtonPress_ = function () {
  this.binary_ = '';
  this.render();
};

/**
 * Asynchronously fetch the wire state from remote storage, and log it.
 * @param {Event} jQueryEvent
 * @private
 */
NetSimBitLogPanel.prototype.onReceiveButtonPress_ = function (jQueryEvent) {
  var thisButton = $(jQueryEvent.target);
  if (thisButton.is('[disabled]')) {
    return;
  }

  thisButton.attr('disabled', 'disabled');
  this.netsim_.receiveBit((function (err, message) {
    if (err) {
      logger.warn("Error reading wire state: " + err.message);
      thisButton.removeAttr('disabled');
      return;
    }

    // A successful fetch with a null message means there's nothing
    // on the wire.  We should log its default state: off/zero
    var receivedBit = '0';
    if (message) {
      receivedBit = message.payload;
    }

    this.log(receivedBit);
    this.netsim_.animateReadWireState(receivedBit);
    thisButton.removeAttr('disabled');
  }).bind(this));
};

/**
 * Put a message into the log.
 * @param {string} binaryBit
 */
NetSimBitLogPanel.prototype.log = function (binaryBit) {
  this.binary_ += binaryBit.toString();
  this.render();
};

/**
 * Show or hide parts of the send UI based on the currently selected encoding
 * mode.
 * @param {EncodingType[]} newEncodings
 */
NetSimBitLogPanel.prototype.setEncodings = function (newEncodings) {
  this.encodings_ = newEncodings;
  this.render();
};

/**
 * Change how binary input in interpreted and formatted in the log.
 * @param {number} newChunkSize
 */
NetSimBitLogPanel.prototype.setChunkSize = function (newChunkSize) {
  this.chunkSize_ = newChunkSize;
  this.render();
};

/**
 * Sets the vertical space that this log panel should consume (including margins)
 * @param {number} heightPixels
 */
NetSimBitLogPanel.prototype.setHeight = function (heightPixels) {
  this.openHeight_ = heightPixels;
  this.sizeToOpenHeight_();
};

/**
 * Scale the scroll area inside the panel so that the whole panel
 * is the desired height.
 * @private
 */
NetSimBitLogPanel.prototype.sizeToOpenHeight_ = function () {
  var root = this.getRoot().find('.netsim-panel');
  var panelHeader = root.find('h1');
  var panelBody = root.find('.panel-body');
  var scrollArea = root.find('.scroll-area');

  var panelMargins = parseFloat(root.css('margin-top')) + parseFloat(root.css('margin-bottom'));
  var headerHeight = panelHeader.outerHeight(true);
  var panelBorders = parseFloat(panelBody.css('border-top-width')) + parseFloat(panelBody.css('border-bottom-width'));
  var scrollMargins = parseFloat(scrollArea.css('margin-top')) + parseFloat(scrollArea.css('margin-bottom'));

  // We set the panel height by fixing the size of its inner scrollable
  // area.
  var newScrollViewportHeight = this.openHeight_ - (panelMargins + headerHeight + panelBorders + scrollMargins);
  scrollArea.height(Math.floor(newScrollViewportHeight));
};

/**
 * @returns {number} vertical space that panel currently consumes (including
 * margins) in pixels.
 */
NetSimBitLogPanel.prototype.getHeight = function () {
  return this.getRoot().find('.netsim-panel').outerHeight(true);
};

/**
 * After toggling panel visibility, trigger a layout update so send/log panel
 * space is shared correctly.
 * @private
 * @override
 */
NetSimBitLogPanel.prototype.onMinimizerClick_ = function () {
  NetSimBitLogPanel.superPrototype.onMinimizerClick_.call(this);
  NetSimGlobals.updateLayout();
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimBitLogPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitLogPanel.html.ejs","./NetSimEncodingControl":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./NetSimPanel":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.js":[function(require,module,exports){
/**
 * @overview base class for all "panels" (visual boxes) in the NetSim
 *           interface, provides some common expand/collapse functionality.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var markup = require('./NetSimPanel.html.ejs');
var ArgumentUtils = require('./ArgumentUtils');

/**
 * Generator and controller for a NetSim Panel, a single section on the
 * page which may be collapsible.
 * @param {jQuery} rootDiv - Element within which the panel is recreated
 *        every time render() is called.  Will wipe out contents of this
 *        element, but not the element itself.
 * @param {Object} [options]
 * @param {string} [options.className] - an additional class to be appended to
 *        the panel's root (one layer inside rootDiv) for style rules.
 *        Defaults to no class, so only the 'netsim-panel' class will be used.
 * @param {string} [options.panelTitle] - Localized initial panel title.
 *        Defaults to empty string.
 * @param {boolean} [options.userToggleable] - Whether this panel can be minimized
 *        (closed) by clicking on the title. Defaults to TRUE.
 * @param {boolean} [options.beginMinimized] - Whether this panel should be
 *        minimized (closed) when it is initially created.  Defaults to FALSE.
 * @constructor
 */
var NetSimPanel = module.exports = function (rootDiv, options) {
  /**
   * Unique instance ID for this panel, in case we have several
   * of them on a page.
   * @type {number}
   * @private
   */
  this.instanceID_ = NetSimPanel.uniqueIDCounter;
  NetSimPanel.uniqueIDCounter++;

  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * An additional className to be appended to the panel's root (one layer
   * inside rootDiv), for style rules.
   * @type {string}
   * @private
   */
  this.className_ = utils.valueOr(options.className, '');

  /**
   * Panel title, displayed in header.
   * @type {string}
   * @private
   */
  this.panelTitle_ = utils.valueOr(options.panelTitle, '');

  /**
   * Whether this panel can be minimized (closed) by clicking on the title.
   * @type {boolean}
   * @private
   */
  this.userToggleable_ = utils.valueOr(options.userToggleable, true);

  /**
   * Whether the component is minimized, for consistent
   * state across re-renders.
   * @type {boolean}
   * @private
   */
  this.isMinimized_ = utils.valueOr(options.beginMinimized, false);

  // Initial render
  this.render();
};

/**
 * Static counter used to generate/uniquely identify different instances
 * of this log widget on the page.
 * @type {number}
 */
NetSimPanel.uniqueIDCounter = 0;

/**
 * Rebuild the panel contents inside of the rootDiv
 */
NetSimPanel.prototype.render = function () {
  var newMarkup = $(markup({
    instanceID: this.instanceID_,
    className: this.className_,
    panelTitle: this.panelTitle_,
    userToggleable: this.userToggleable_
  }));
  this.rootDiv_.html(newMarkup);

  if (this.userToggleable_) {
    this.rootDiv_.find('.minimizer').click(this.onMinimizerClick_.bind(this));
  }
  this.setMinimized(this.isMinimized_);
};

/**
 * @returns {jQuery} a handle on the root element for this panel
 */
NetSimPanel.prototype.getRoot = function () {
  return this.rootDiv_;
};

/**
 * Set panel title.
 * @param {string} newTitle - Localized panel title.
 */
NetSimPanel.prototype.setPanelTitle = function (newTitle) {
  this.panelTitle_ = newTitle;
  this.rootDiv_.find('.title-text').text(newTitle);
};

/**
 * Toggle whether this panel is minimized.
 * @private
 */
NetSimPanel.prototype.onMinimizerClick_ = function () {
  this.setMinimized(!this.isMinimized_);
};

/**
 * @param {boolean} becomeMinimized
 */
NetSimPanel.prototype.setMinimized = function (becomeMinimized) {
  var panelDiv = this.rootDiv_.find('.netsim-panel');
  var minimizer = panelDiv.find('.minimizer');
  if (becomeMinimized) {
    panelDiv.addClass('minimized');
    minimizer.find('.fa').addClass('fa-plus-square').removeClass('fa-minus-square');
  } else {
    panelDiv.removeClass('minimized');
    minimizer.find('.fa').addClass('fa-minus-square').removeClass('fa-plus-square');
  }
  this.isMinimized_ = becomeMinimized;
};

/**
 * Whether this panel is currently minimized (showing only its header) or not.
 * @returns {boolean}
 */
NetSimPanel.prototype.isMinimized = function () {
  return this.isMinimized_;
};

/**
 * Add a button to the right end of the panel header.
 * @param {string} buttonText
 * @param {function} pressCallback
 * @param {Object} [options]
 * @param {boolean} [options.secondary] - default TRUE, secondary button style
 * @param {string[]} [options.classes] - default [], additional classes on the
 *        button element.
 */
NetSimPanel.prototype.addButton = function (buttonText, pressCallback, options) {
  options = ArgumentUtils.extendOptionsObject(options || {});

  var button = $('<span>').addClass('netsim-button').html(buttonText).click(pressCallback);

  if (options.get('secondary', ArgumentUtils.isBoolean, true)) {
    button.addClass('secondary');
  }

  options.get('classes', ArgumentUtils.isArrayOfStrings(), []).forEach(function (className) {
    button.addClass(className);
  });

  button.appendTo(this.rootDiv_.find('.panel-controls'));
};

/**
 * @returns {jQuery} the body Div of the panel, for panel content.
 */
NetSimPanel.prototype.getBody = function () {
  return this.rootDiv_.find('.panel-body');
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./ArgumentUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/ArgumentUtils.js","./NetSimPanel.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div id="netsim-panel-', escape((1,  instanceID )), '"\n     class="netsim-panel ', escape((2,  className )), '">\n  <h1>\n    <div class="panel-controls"></div>\n    <div class="single-line-with-ellipsis pad-left');5; if (userToggleable) { ; buf.push(' minimizer');5; } ; buf.push('">\n      ');6; if (userToggleable) { ; buf.push('\n        <i class="fa fa-minus-square"></i>\n      ');8; } ; buf.push('\n      <span class="title-text">', escape((9,  panelTitle )), '</span>\n    </div>\n  </h1>\n  <div class="panel-body">\n  </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.js":[function(require,module,exports){
/**
 * @overview UI controller for set of radio buttons used to select display encodings.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var markup = require('./NetSimEncodingControl.html.ejs');
var EncodingType = require('./NetSimConstants').EncodingType;

/**
 * Generator and controller for message encoding selector: A dropdown that
 * controls whether messages are displayed in some combination of binary, hex,
 * decimal, ascii, etc.
 * @param {jQuery} rootDiv
 * @param {NetSimLevelConfiguration} levelConfig
 * @param {function} changeEncodingCallback
 * @constructor
 */
var NetSimEncodingControl = module.exports = function (rootDiv, levelConfig, changeEncodingCallback) {
  /**
   * Component root, which we fill whenever we call render()
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * @type {NetSimLevelConfiguration}
   * @private
   */
  this.levelConfig_ = levelConfig;

  /**
   * @type {function}
   * @private
   */
  this.changeEncodingCallback_ = changeEncodingCallback;

  /**
   * @type {jQuery}
   * @private
   */
  this.checkboxes_ = null;

  // Initial render
  this.render();
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimEncodingControl.prototype.render = function () {
  var renderedMarkup = $(markup({
    level: this.levelConfig_
  }));
  this.rootDiv_.html(renderedMarkup);
  this.checkboxes_ = this.rootDiv_.find('input[type="checkbox"][name="encoding_checkboxes"]');
  this.checkboxes_.change(this.onCheckboxesChange_.bind(this));
};

/**
 * Send new selected encodings to registered callback on change.
 * @private
 */
NetSimEncodingControl.prototype.onCheckboxesChange_ = function () {
  var selectedEncodings = [];
  this.checkboxes_.filter(':checked').each(function (i, element) {
    selectedEncodings.push(element.value);
  });
  this.changeEncodingCallback_(selectedEncodings);
};

/**
 * Change selector value to the new provided value.
 * @param {EncodingType[]} newEncodings
 */
NetSimEncodingControl.prototype.setEncodings = function (newEncodings) {
  this.checkboxes_.each(function (i, element) {
    $(element).attr('checked', newEncodings.indexOf(element.value) > -1);
  });
};

/**
 * Generate a jQuery selector string that will get all rows that
 * have ANY of the provided classes.
 * @param {EncodingType[]} encodings
 * @returns {string}
 */
var makeEncodingRowSelector = function makeEncodingRowSelector(encodings) {
  return encodings.map(function (className) {
    return 'tr.' + className;
  }).join(', ');
};

/**
 * Static helper, shows/hides rows under provided element according to the given
 * encoding setting.
 * @param {jQuery} rootElement - root of elements to show/hide
 * @param {EncodingType[]} encodings - a message encoding setting
 */
NetSimEncodingControl.hideRowsByEncoding = function (rootElement, encodings) {
  var hiddenEncodings = [];
  for (var key in EncodingType) {
    if (EncodingType.hasOwnProperty(key) && encodings.indexOf(EncodingType[key]) === -1) {
      hiddenEncodings.push(EncodingType[key]);
    }
  }
  rootElement.find(makeEncodingRowSelector(encodings)).show();
  rootElement.find(makeEncodingRowSelector(hiddenEncodings)).hide();
};

/**
 * Static helper that converts a given array of encodings to an object
 * mapping each encoding to `true`. Used for more efficient
 * isEncodingEnabled checks
 * @param {EncodingType[]} encodings
 * @returns {Object.<EncodingType, boolean>}
 */
NetSimEncodingControl.encodingsAsHash = function (encodings) {
  return encodings.reduce(function (hash, encoding) {
    hash[encoding] = true;
    return hash;
  }, {});
};

},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimEncodingControl.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.html.ejs"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimEncodingControl.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var EncodingType = require('./NetSimConstants').EncodingType;
  var i18n = require('./locale');

  /**
   * @param {EncodingType} encodingType
   * @param {string} encodingLabel
   */
  function makeCheckbox(encodingType, encodingLabel) {
    var divClasses = ['encoding_checkboxes_' + encodingType];
    if (level.showEncodingControls.indexOf(encodingType) === -1) {
      divClasses.push('hidden-control');
    }
    ; buf.push('\n    <div class="', escape((15,  divClasses.join(' ') )), '">\n      <input type="checkbox"\n             name="encoding_checkboxes"\n             id="encoding_checkboxes_', escape((18,  encodingType )), '"\n             value="', escape((19,  encodingType )), '"\n          />\n      <label for="encoding_checkboxes_', escape((21,  encodingType )), '">', escape((21,  encodingLabel )), '</label>\n    </div>\n    ');23;
  }
; buf.push('\n<div class="netsim-encoding-selector">\n  <h1>', escape((27,  i18n.encoding() )), '</h1>\n  ');28; makeCheckbox(EncodingType.ASCII, i18n.ascii()); ; buf.push('\n  ');29; makeCheckbox(EncodingType.DECIMAL, i18n.decimal()); ; buf.push('\n  ');30; makeCheckbox(EncodingType.HEXADECIMAL, i18n.hexadecimal()); ; buf.push('\n  ');31; makeCheckbox(EncodingType.BINARY, i18n.binary()); ; buf.push('\n  ');32; makeCheckbox(EncodingType.A_AND_B, i18n.a_and_b()); ; buf.push('\n</div>'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBitLogPanel.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  var i18n = require('./locale');
  var NetSimConstants = require('./NetSimConstants');
  var DataConverters = require('./DataConverters');

  var getEncodingLabel = require('./NetSimUtils').getEncodingLabel;

  var EncodingType = NetSimConstants.EncodingType;
  var PacketUIColumnType = NetSimConstants.PacketUIColumnType;

  /**
   * @param {EncodingType} encodingType
   * @param {string} encodedContent
   */
  function logRow(encodingType, encodedContent) {
    ; buf.push('\n    <tr class="', escape((17,  encodingType )), '">\n      <th nowrap class="', escape((18,  PacketUIColumnType.ENCODING_LABEL )), '">', escape((18,  getEncodingLabel(encodingType) )), '</th>\n      <td class="', escape((19,  PacketUIColumnType.MESSAGE )), '">', escape((19,  encodedContent )), '</td>\n    </tr>\n    ');21;
  }
; buf.push('\n<div class="scroll-area bit-log-scroll-area">\n  <div class="packet">\n    <table>\n      <tbody>\n        ');28;
          logRow(EncodingType.ASCII, DataConverters.binaryToAscii(binary, chunkSize));

          logRow(EncodingType.DECIMAL, DataConverters.alignDecimal(DataConverters.binaryToDecimal(binary, chunkSize)));

          logRow(EncodingType.HEXADECIMAL, DataConverters.formatHex(DataConverters.binaryToHex(binary), chunkSize));

          logRow(EncodingType.BINARY, DataConverters.formatBinary(binary, chunkSize));

          logRow(EncodingType.A_AND_B, DataConverters.formatAB(DataConverters.binaryToAB(binary), chunkSize));
        ; buf.push('\n      </tbody>\n    </table>\n  </div>\n  ');42; if (showReadWireButton) { ; buf.push('\n    <div class="panel-footer bit-log-panel-footer">\n      <div class="right-side-controls">\n        <span class="netsim-button large-button" id="read-wire-button">', escape((45,  i18n.readWire() )), '</span>\n      </div>\n    </div>\n  ');48; } ; buf.push('\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./DataConverters":"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js","ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimBandwidthControl.js":[function(require,module,exports){
/**
 * @overview UI Slider control used for changing simulated router bandwidth.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

// Utils required only for Function.prototype.inherits()
require('../utils');
var NetSimConstants = require('./NetSimConstants');
var NetSimUtils = require('./NetSimUtils');
var NetSimSlider = require('./NetSimSlider');

/**
 * Generator and controller for packet size slider/selector
 * @param {jQuery} rootDiv
 * @param {function} sliderChangeCallback
 * @param {function} sliderStopCallback
 * @constructor
 */
var NetSimBandwidthControl = module.exports = function (rootDiv, sliderChangeCallback, sliderStopCallback) {
  NetSimSlider.LogarithmicSlider.call(this, rootDiv, {
    onChange: sliderChangeCallback,
    onStop: sliderStopCallback,
    value: Infinity,
    min: 4,
    max: 128 * NetSimConstants.BITS_PER_KILOBIT,
    upperBoundInfinite: true
  });

  // Auto-render, unlike our base class
  this.render();
};
NetSimBandwidthControl.inherits(NetSimSlider.LogarithmicSlider);

/**
 * Converts a numeric bandwidth value (in bits) into a compact localized string
 * representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 * @override
 */
NetSimBandwidthControl.prototype.valueToLabel = function (val) {
  return NetSimUtils.bitrateToLocalizedRoundedBitrate(val);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimSlider":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.js":[function(require,module,exports){
/**
 * @overview Base implementation of NetSim UI sliders.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var markup = require('./NetSimSlider.html.ejs');
var i18n = require('./locale');

/**
 * @type {number}
 * @const
 */
var SLIDER_DEFAULT_MIN_VALUE = 0;

/**
 * @type {number}
 * @const
 */
var SLIDER_DEFAULT_MAX_VALUE = 100;

/**
 *
 * @constructor
 * @param {jQuery} rootDiv - element whose content we replace with the slider
 *        on render()
 * @param {Object} options
 * @param {function} [options.onChange] - a function invoked whenever the
 *        slider-value is changed by the student.  Passed the new value as an
 *        argument.
 * @param {function} [options.onStop] - a function invoked only when the
 *        slider-handle is released by the student.  Passed the new value as an
 *        argument.
 * @param {number} [options.value] - Initial value of the slider.  Defaults to
 *        slider minimum value.
 * @param {number} [options.min] - Lowest possible value of the slider;
 *        next-to-lowest if lowerBoundInfinite is true.  Defaults to zero.
 * @param {number} [options.max] - Highest possible value of the slider;
 *        next-to-highest if upperBoundInfinite is true.  Defaults to 100.
 * @param {number} [options.step] - Step-value of jQueryUI slider - not
 *        necessarily related to min and max values if you provide custom value
 *        converters. Defaults to 1.  If negative, the slider is reversed and
 *        puts the min value on the right.  Cannot be zero or noninteger.
 * @param {boolean} [options.upperBoundInfinite] - if TRUE, the highest value
 *        on the slider will be Infinity/Unlimited.  Default FALSE.
 * @param {boolean} [options.lowerBoundInfinite] - if TRUE, the lowest value
 *        on the slider will be -Infinity/Unlimited.  Default FALSE.
 * @param {boolean} [options.isDisabled] - if TRUE the slider value is locked
 *        and cannot be changed.
 */
var NetSimSlider = module.exports = function (rootDiv, options) {
  /**
   * Unique instance ID for this panel, in case we have several
   * of them on a page.
   * @type {number}
   * @private
   */
  this.instanceID_ = NetSimSlider.uniqueIDCounter;
  NetSimSlider.uniqueIDCounter++;

  /**
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = rootDiv;

  /**
   * A function invoked whenever the slider-value is changed by the student.
   * Passed the new value (not slider position) as an argument.
   * @type {function}
   * @private
   */
  this.changeCallback_ = utils.valueOr(options.onChange, function () {});

  /**
   * A function invoked only when the slider-handle is released by the student.
   * Passed the new value (not slider position) as an argument
   * @type {function}
   * @private
   */
  this.stopCallback_ = utils.valueOr(options.onStop, function () {});

  /**
   * @type {number}
   * @private
   */
  this.minValue_ = utils.valueOr(options.min, SLIDER_DEFAULT_MIN_VALUE);

  /**
   * @type {number}
   * @private
   */
  this.maxValue_ = utils.valueOr(options.max, SLIDER_DEFAULT_MAX_VALUE);

  /**
   * The current (outward-facing) value of the slider.
   * @type {number}
   * @private
   */
  this.value_ = utils.valueOr(options.value, this.minValue_);

  /**
   * Whether the slider maximum value should be Infinity.
   * @type {boolean}
   * @private
   */
  this.isUpperBoundInfinite_ = utils.valueOr(options.upperBoundInfinite, false);

  /**
   * Whether the slider minimimum value should be -Infinity.
   * @type {boolean}
   * @private
   */
  this.isLowerBoundInfinite_ = utils.valueOr(options.lowerBoundInfinite, false);

  /**
   * @type {number}
   * @private
   */
  this.step_ = utils.valueOr(options.step, 1);
  if (this.step_ === 0) {
    throw new Error("NetSimSlider does not support zero step values.");
  } else if (this.step_ % 1 !== 0) {
    throw new Error("NetSimSlider does not support non-integer step values. " + " Use DecimalPrecisionSlider instead.");
  }

  /**
   * Whether the slider is disabled and noninteractable.
   * @type {boolean}
   * @private
   */
  this.isDisabled_ = utils.valueOr(options.isDisabled, false);
};

/**
 * Static counter used to generate/uniquely identify different instances
 * of this component on the page
 * @type {number}
 */
NetSimSlider.uniqueIDCounter = 0;

/**
 * @returns {boolean} TRUE if the step value is less than zero.
 * @private
 */
NetSimSlider.prototype.isStepNegative_ = function () {
  return this.step_ < 0;
};

/**
 * Fill the root div with new elements reflecting the current state
 */
NetSimSlider.prototype.render = function () {
  var minValue = this.isLowerBoundInfinite_ ? -Infinity : this.minValue_;
  var maxValue = this.isUpperBoundInfinite_ ? Infinity : this.maxValue_;
  var minPosition = this.valueToSliderPosition(this.isStepNegative_() ? maxValue : minValue);
  var maxPosition = this.valueToSliderPosition(this.isStepNegative_() ? minValue : maxValue);

  var renderedMarkup = $(markup({
    instanceID: this.instanceID_,
    minValue: this.valueToShortLabel(this.isStepNegative_() ? maxValue : minValue),
    maxValue: this.valueToShortLabel(this.isStepNegative_() ? minValue : maxValue)
  }));
  this.rootDiv_.html(renderedMarkup);

  this.rootDiv_.find('.slider').slider({
    value: this.valueToSliderPosition(this.value_),
    min: minPosition,
    max: maxPosition,
    step: Math.abs(this.step_),
    slide: this.onSliderValueChange_.bind(this),
    stop: this.onSliderStop_.bind(this),
    disabled: this.isDisabled_
  });

  // Use wider labels if we have an infinite bound
  if (this.isLowerBoundInfinite_ || this.isUpperBoundInfinite_) {
    this.rootDiv_.find('.slider-labels').addClass('wide-labels');
  }

  this.setLabelFromValue_(this.value_);
};

/**
 * Disable this slider, so the user can't change its value
 */
NetSimSlider.prototype.disable = function () {
  this.isDisabled_ = true;
  this.rootDiv_.find('.slider').slider('option', 'disabled', true);
};

/**
 * Enable this slider, so the user can change its value
 */
NetSimSlider.prototype.enable = function () {
  this.isDisabled_ = false;
  this.rootDiv_.find('.slider').slider('option', 'disabled', false);
};

/**
 * External access to set the value of the slider.
 * @param {number} newValue
 */
NetSimSlider.prototype.setValue = function (newValue) {
  if (this.value_ === newValue) {
    return;
  }

  this.value_ = newValue;
  this.rootDiv_.find('.slider').slider('option', 'value', this.valueToSliderPosition(newValue));
  this.setLabelFromValue_(newValue);
};

/** @private */
NetSimSlider.prototype.onSliderValueChange_ = function (event, ui) {
  var newValue = this.sliderPositionToValue(ui.value);
  this.value_ = newValue;
  this.setLabelFromValue_(newValue);
  this.changeCallback_(newValue);
};

/** @private */
NetSimSlider.prototype.onSliderStop_ = function () {
  this.stopCallback_(this.value_);
};

/**
 * Updates the slider label to localize and display the given value.
 * @param {number} val - slider value to display
 * @private
 */
NetSimSlider.prototype.setLabelFromValue_ = function (val) {
  this.rootDiv_.find('.slider-value').text(this.valueToLabel(val));
};

/**
 * Converts the given value into an internal value we can pass to the
 * jQueryUI slider control.
 * @param {number} val - external-facing value
 * @returns {number} - internal slider value
 */
NetSimSlider.prototype.valueToSliderPosition = function (val) {
  if (this.isUpperBoundInfinite_ && val > this.maxValue_) {
    return this.valueToSliderPosition(this.maxValue_) + this.step_;
  } else if (this.isLowerBoundInfinite_ && val < this.minValue_) {
    return this.valueToSliderPosition(this.minValue_) - this.step_;
  }
  return Math.max(this.minValue_, Math.min(this.maxValue_, val)) * (this.isStepNegative_() ? -1 : 1);
};

/**
 * Converts the internal jQueryUI slider value into an external-facing
 * value for this control.
 * Should be an inverse of valueToSliderPosition
 * @param {number} pos - internal slider value
 * @returns {number} - external-facing value
 */
NetSimSlider.prototype.sliderPositionToValue = function (pos) {
  if (this.isStepNegative_()) {
    if (pos < this.valueToSliderPosition(this.maxValue_)) {
      return this.isUpperBoundInfinite_ ? Infinity : this.maxValue_;
    } else if (pos > this.valueToSliderPosition(this.minValue_)) {
      return this.isLowerBoundInfinite_ ? -Infinity : this.minValue_;
    }
    return -pos;
  } else {
    if (pos > this.valueToSliderPosition(this.maxValue_)) {
      return this.isUpperBoundInfinite_ ? Infinity : this.maxValue_;
    } else if (pos < this.valueToSliderPosition(this.minValue_)) {
      return this.isLowerBoundInfinite_ ? -Infinity : this.minValue_;
    }
    return pos;
  }
};

/**
 * Converts an external-facing numeric value into a localized string
 * representation of that value.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 */
NetSimSlider.prototype.valueToLabel = function (val) {
  if (val === Infinity || val === -Infinity) {
    return i18n.unlimited();
  }
  return val;
};

/**
 * Alternate label converter, used for slider end labels.
 * @param {number} val - numeric value of the control
 * @returns {string} - localized string representation of value
 */
NetSimSlider.prototype.valueToShortLabel = function (val) {
  return this.valueToLabel(val);
};

/**
 * Since jQueryUI sliders don't support noninteger step values, this is
 * a simple helper wrapped around NetSimSlider that adds support for
 * fractional step values down to a given precision.
 * @param {jQuery} rootDiv
 * @param {Object} options - takes NetSimSlider options, except:
 * @param {number} [options.step] - values between 0 and 1 are allowed.
 * @param {number} [options.precision] - number of decimal places of precision
 *        this slider needs (can match the number of decimal places in your
 *        step value).  Default 2.
 * @constructor
 */
NetSimSlider.DecimalPrecisionSlider = function (rootDiv, options) {
  /**
   * Number of decimal places of precision added to the default slider
   * functionality.
   * @type {number}
   * @private
   */
  this.precision_ = utils.valueOr(options.precision, 2);

  // We convert the given step value by the requested precision before passing
  // it on to NetSimSlider, so that we give NetSimSlider an integer step value.
  options.step = options.step * Math.pow(10, this.precision_);

  NetSimSlider.call(this, rootDiv, options);
};
NetSimSlider.DecimalPrecisionSlider.inherits(NetSimSlider);

/**
 * @param {number} val - external-facing value
 * @returns {number} - internal slider value
 * @override
 */
NetSimSlider.DecimalPrecisionSlider.prototype.valueToSliderPosition = function (val) {
  // Use clamping from parent class, which should be applied before our transform.
  return NetSimSlider.prototype.valueToSliderPosition.call(this, val) * Math.pow(10, this.precision_);
};

/**
 * Should be an inverse of valueToSliderPosition
 * @param {number} pos - internal slider value
 * @returns {number} - external-facing value
 * @override
 */
NetSimSlider.DecimalPrecisionSlider.prototype.sliderPositionToValue = function (pos) {
  // Use clamping from parent class, which should be applied before our transform.
  return NetSimSlider.prototype.sliderPositionToValue.call(this, pos) / Math.pow(10, this.precision_);
};

/**
 * Default minimum of zero is useless to a logarithmic scale
 * @type {number}
 * @const
 */
var LOGARITHMIC_DEFAULT_MIN_VALUE = 1;

/**
 * By default, a logarithmic scale slider increases by a factor of 2
 * every step.
 * @type {number}
 */
var LOGARITHMIC_DEFAULT_BASE = 2;

/**
 * @param {jQuery} rootDiv
 * @param {Object} options - takes NetSimSlider options, except:
 * @param {number} [options.min] - same as base slider, but defaults to 1.
 * @param {number} [options.logBase] - factor by which the value increases
 *        with every slider step.  Default base 2.
 * @constructor
 * @augments NetSimSlider
 */
NetSimSlider.LogarithmicSlider = function (rootDiv, options) {
  options.min = utils.valueOr(options.min, LOGARITHMIC_DEFAULT_MIN_VALUE);
  NetSimSlider.call(this, rootDiv, options);

  /**
   * Factor by which the value increases with every slider step.
   * @type {number}
   * @private
   */
  this.logBase_ = utils.valueOr(options.logBase, LOGARITHMIC_DEFAULT_BASE);

  /**
   * Precalculate natural log of our base value, because we'll use it a lot.
   * @type {number}
   * @private
   */
  this.lnLogBase_ = Math.log(this.logBase_);

  this.calculateSliderBounds_();
};
NetSimSlider.LogarithmicSlider.inherits(NetSimSlider);

/**
 * For the logarithmic slider, it's easiest to calculate the slider
 * boundary values once and use them later.
 * @private
 */
NetSimSlider.LogarithmicSlider.prototype.calculateSliderBounds_ = function () {
  // Pick boundary slider values
  this.maxSliderPosition = this.logFloor_(this.maxValue_);
  // Add a step if we don't already land exactly on a step, to
  // compensate for the floor() operation
  if (Math.pow(this.logBase_, this.maxSliderPosition) !== this.maxValue_) {
    this.maxSliderPosition += this.step_;
  }
  this.minSliderPosition = this.logFloor_(this.minValue_);

  // Pick infinity slider values
  this.infinitySliderPosition = this.maxSliderPosition + this.step_;
  this.negInfinitySliderPosition = this.minSliderPosition - this.step_;
};

/**
 * Cheater "floor(log_base_n(x))" method with a hacky workaround for
 * floating-point errors.  Uses the logarithmic base factor that the slider
 * is configured for (this.logBase_). Good enough for the slider.
 * @param {number} val
 * @returns {number}
 * @private
 */
NetSimSlider.LogarithmicSlider.prototype.logFloor_ = function (val) {
  // JavaScript floating-point math causes this logarithm calculation to
  // sometimes return slightly imprecise values. For example:
  // log(1000) / log(10) === 2.9999999999999996
  // Although we usually want to floor noninteger values, the above calculation
  // is supposed to come out as exactly 3.
  // The fudge factor below gives a threshold at which we will ceil() a result
  // rather than floor() it, to account for this imprecision.
  // The _right_ way to fix this is to use a better number type like BigDecimal,
  // but it's not really worth it for this use case.  Six digits is more than
  // enough precision for the slider when we're trying to work with whole
  // numbers anyway.
  var ceilThreshold = 0.0000001;
  return Math.floor(ceilThreshold + Math.log(val) / this.lnLogBase_);
};

/**
 * Converts the given value into an internal value we can pass to the
 * jQueryUI slider control.
 * @param {number} val - external-facing value
 * @returns {number} - internal slider value
 * @override
 */
NetSimSlider.LogarithmicSlider.prototype.valueToSliderPosition = function (val) {
  if (val > this.maxValue_) {
    return this.isUpperBoundInfinite_ ? this.infinitySliderPosition : this.maxSliderPosition;
  } else if (val === this.maxValue_) {
    return this.maxSliderPosition;
  } else if (val < this.minValue_) {
    return this.isLowerBoundInfinite_ ? this.negInfinitySliderPosition : this.minSliderPosition;
  } else if (val === this.minValue_) {
    return this.minSliderPosition;
  }
  return Math.max(this.minSliderPosition, this.logFloor_(val));
};

/**
 * Converts the internal jQueryUI slider value into an external-facing
 * value for this control.
 * Should be an inverse of valueToSliderPosition
 * @param {number} pos - internal slider value
 * @returns {number} - external-facing value
 * @override
 */
NetSimSlider.LogarithmicSlider.prototype.sliderPositionToValue = function (pos) {
  if (pos > this.maxSliderPosition) {
    return this.isUpperBoundInfinite_ ? Infinity : this.maxValue_;
  } else if (pos === this.maxSliderPosition) {
    return this.maxValue_;
  } else if (pos < this.minSliderPosition) {
    return this.isLowerBoundInfinite_ ? -Infinity : this.minValue_;
  } else if (pos === this.minSliderPosition) {
    return this.minValue_;
  }
  return Math.pow(this.logBase_, pos);
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimSlider.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.html.ejs","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimSlider.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div id="netsim_slider_', escape((1,  instanceID )), '" class="netsim-slider">\n  <div class="slider-inline-wrap">\n    <div class="slider"></div>\n    <div class="slider-labels">\n      <div class="max-value">', escape((5,  maxValue )), '</div>\n      <div class="min-value">', escape((6,  minValue )), '</div>\n      <div class="current-value">\n        <label><span class="slider-value"></span></label>\n      </div>\n    </div>\n  </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimApi.js":[function(require,module,exports){
/**
 * @overview Wraps NetSim REST APIs for operations of "tables" and "shards."
 * @see net_sim_api.rb
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var NetSimApiError = require('./NetSimApiError');

/**
 * @type {string}
 * @const
 */
var NETSIM_API_BASE_URL = '/v3/netsim';

/**
 * @name NetSimShardApi
 */
var shardApi = {

  /**
   * Create an initialized NetSim Shard API instance.
   * @param {string} shardID
   * @returns {NetSimShardApi}
   */
  create: function create(shardID) {
    return $.extend({}, shardApi, {

      /**
       * Shard identifier.
       * @type {string}
       */
      shardID: shardID,

      /**
       * Beginning part of URL for all calls that interact with the shard.
       * @type {string}
       */
      baseUrl: NETSIM_API_BASE_URL + '/' + shardID
    });
  },

  makeTableApi: function makeTableApi(tableName) {
    return tableApi.create(this.shardID, tableName);
  }
};

/**
 * @name NetSimTableApi
 */
var tableApi = {

  /**
   * Create an initialized NetSim Table API instance.
   * @param {string} shardID
   * @param {string} tableName
   * @returns {NetSimTableApi}
   */
  create: function create(shardID, tableName) {
    return $.extend({}, tableApi, {

      /**
       * Shard identifier.
       * @type {string}
       */
      shardID: shardID,

      /**
       * Table name.
       * @type {string}
       */
      tableName: tableName,

      /**
       * Beginning part of URL for all calls that interact only with
       * this table.
       * @type {string}
       */
      baseUrl: NETSIM_API_BASE_URL + '/' + shardID + '/' + tableName
    });
  },

  /**
   * Request all rows from the given table.
   * @param {NodeStyleCallback} callback - Expected result is an array of
   *        row objects.
   */
  allRows: function allRows(callback) {
    $.ajax({
      url: this.baseUrl,
      type: "get",
      dataType: "json"
    }).done(function (data, text) {
      callback(null, data);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), null);
    });
  },

  /**
   * Request all rows including and following the given row ID from the table.
   * @param {int} rowID - lower bound on row IDs to fetch
   * @param {NodeStyleCallback} callback - Expected result is an array of
   *        table rows.
   */
  allRowsFromID: function allRowsFromID(rowID, callback) {
    $.ajax({
      url: this.baseUrl + '@' + rowID,
      type: "get",
      dataType: "json"
    }).done(function (data, text) {
      callback(null, data);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), null);
    });
  },

  /**
   * Insert a row or rows into the table.
   * @param {Object|Object[]} value - desired row contents, as either an
   *        Object for a single row or an Array of Objects for multiple.
   *        Must be JSON.stringify-able.
   * @param {NodeStyleCallback} callback - Expected result is the created
   *        row object or objects (which will include an assigned 'id'
   *        key).
   */
  createRow: function createRow(value, callback) {
    var data;

    try {
      data = JSON.stringify(value);
    } catch (e) {
      callback(e, undefined);
      return;
    }

    $.ajax({
      url: this.baseUrl,
      type: "post",
      contentType: "application/json; charset=utf-8",
      data: data
    }).done(function (body, text) {
      callback(null, body);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), undefined);
    });
  },

  /**
   * Remove multiple rows at once.
   * @param {number[]} ids - The row IDs to remove.
   * @param {NodeStyleCallback} callback - Expected result is TRUE.
   * @param {boolean} [async] default TRUE.
   */
  deleteRows: function deleteRows(ids, callback, async) {
    async = async !== false; // `undefined` maps to true

    // Generate query string in the form "id[]=1&id[]=2&..."
    var queryString = ids.map(function (id) {
      return 'id[]=' + id;
    }).join('&');

    $.ajax({
      url: this.baseUrl + '?' + queryString,
      type: 'delete',
      dataType: 'json',
      async: async
    }).done(function (data, text) {
      callback(null, true);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), false);
    });
  },

  /**
   * Retrieve a row.
   * @param {number} id - The row identifier.
   * @param {NodeStyleCallback} callback - Expected result is the requested
   *        row object.
   */
  fetchRow: function fetchRow(id, callback) {
    $.ajax({
      url: this.baseUrl + "/" + id,
      type: "get",
      dataType: "json"
    }).done(function (data, text) {
      callback(null, data);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), undefined);
    });
  },

  /**
   * Change the contents of a row.
   * @param {number} id - The row identifier.
   * @param {Object} value - The new row contents.
   * @param {NodeStyleCallback} callback - Expected result is the new row object.
   */
  updateRow: function updateRow(id, value, callback) {
    $.ajax({
      url: this.baseUrl + "/" + id,
      type: "post",
      contentType: "application/json; charset=utf-8",
      data: JSON.stringify(value)
    }).done(function (data, text) {
      callback(null, data);
    }).fail(function (request, status, error) {
      callback(new NetSimApiError(request), false);
    });
  }
};

module.exports = {
  /**
   * Create a NetSim Shard API instance for the given shard.
   * @param {string} shardID
   * @returns {NetSimShardApi}
   */
  makeShardApi: function makeShardApi(shardID) {
    return shardApi.create(shardID);
  },

  /**
   * Create a NetSim Table API instance for the given shard and table name.
   * @param {string} shardID
   * @param {string} tableName
   * @returns {NetSimTableApi}
   */
  makeTableApi: function makeTableApi(shardID, tableName) {
    return tableApi.create(shardID, tableName);
  }
};

},{"./NetSimApiError":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimApiError.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimApiError.js":[function(require,module,exports){
/**
 * @overview Extended error type returned for failed interactions with NetSim
 * server API (net_sim_api.rb) that extracts and exposes additional error info.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

require('../utils'); // provide Function.prototype.inherits

/**
 * Special error type for failed server requests, which tries to extract
 * additional error information from the server's response.
 * @param {jqXHR} request
 * @constructor
 * @extends Error
 */
var NetSimApiError = module.exports = function (request) {
  /** @type {string} */
  this.name = 'NetSimApiError';

  /** @type {string} */
  this.message = 'Request failed';

  /** @type {string} */
  this.stack = new Error().stack;

  /**
   * Additional error information returned by the server, which can drive
   * specific responses by the client.
   * @type {string|Array}
   */
  this.details = undefined;

  // Attempt to extract additional information from the request object
  if (request) {
    this.message = 'status: ' + request.status + '; error: ' + request.statusText;
    try {
      var response = JSON.parse(request.responseText);
      if (response.details) {
        this.details = response.details;
        this.message += '; details: ' + JSON.stringify(this.details);
      }
    } catch (e) {
      this.details = null;
    }
  }
};
NetSimApiError.inherits(Error);

/**
 * Ways that a row insert operation can fail via NetSimApi.
 * @enum {string}
 */
NetSimApiError.ValidationError = {
  MALFORMED: 'malformed',
  CONFLICT: 'conflict',
  LIMIT_REACHED: 'limit_reached'
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.js":[function(require,module,exports){
/**
 * @overview Controller for creating growl-style Bootstrap alerts
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
/* global setTimeout */
'use strict';

var markup = require('./NetSimAlert.html.ejs');
var ArgumentUtils = require('./ArgumentUtils');
var NetSimLogger = require('./NetSimLogger');

var logger = NetSimLogger.getSingleton();

var NetSimAlert = module.exports = {};

/**
 * Returns the alert container, or creates and inserts one if it does
 * not exist. Also attaches a close handler so the container will
 * remove itself when it empties
 * @private
 * @return {jQuery}
 */
NetSimAlert.getOrCreateAlertContainer_ = function () {
  var alertContainer = $('.netsim-alert-container');

  if (alertContainer.length === 0) {
    alertContainer = $('<div>').addClass("netsim-alert-container");
    $('#netsim').append(alertContainer);

    alertContainer.on('closed', function () {
      if ($(this).children().length === 1) {
        $(this).remove();
      }
    });
  }

  return alertContainer;
};

/**
 * Simple check to see if Bootstrap's Alert function is attached to the
 * global jQuery object.
 * @return {boolean} whether or not bootstrap's `alert` function is
 *                   loaded and available
 */
NetSimAlert.isBootstrapAlertLoaded_ = function () {
  return typeof $().alert === 'function';
};

/**
 * Primary alert creation method. Expects a body of content for the
 * alert and a flavor for the alert type. Can optionally include a title
 * and a timeout time.
 *
 * @param {body} string
 * @param {flavor} string
 * @param {Object} options
 * @param {string} options.title
 * @param {number} options.timeout Timeout in ms. defaults to 5000.
 * @return {jQuery} the created alert element
 */
NetSimAlert.create_ = function (body, flavor, options) {

  if (!NetSimAlert.isBootstrapAlertLoaded_()) {
    logger.warn("Bootstrap Alert not loaded; NetSimAlert refusing to create alert");
    return;
  }

  ArgumentUtils.validateRequired(body, 'body', ArgumentUtils.isString);
  ArgumentUtils.validateRequired(flavor, 'flavor', ArgumentUtils.isString);
  options = ArgumentUtils.extendOptionsObject(options);

  var $container = NetSimAlert.getOrCreateAlertContainer_();

  var bootstrapAlert = $(markup({
    flavor: flavor,
    body: body,
    title: options.get('title', ArgumentUtils.isString)
  }));

  $container.append(bootstrapAlert);
  bootstrapAlert.alert();

  setTimeout(function () {
    bootstrapAlert.alert('close');
  }, options.get('timeout', ArgumentUtils.isPositiveNoninfiniteNumber, 5000));

  return bootstrapAlert;
};

/** Wrapper method to call create with an "alert-warn" flavor */
NetSimAlert.warn = function (body, options) {
  return NetSimAlert.create_(body, "alert-warn", options);
};

/** Wrapper method to call create with an "alert-info" flavor */
NetSimAlert.info = function (body, options) {
  return NetSimAlert.create_(body, "alert-info", options);
};

/** Wrapper method to call create with an "alert-error" flavor */
NetSimAlert.error = function (body, options) {
  return NetSimAlert.create_(body, "alert-error", options);
};

/** Wrapper method to call create with an "alert-success" flavor */
NetSimAlert.success = function (body, options) {
  return NetSimAlert.create_(body, "alert-success", options);
};

},{"./ArgumentUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/ArgumentUtils.js","./NetSimAlert.html.ejs":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.html.ejs","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimAlert.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
  /**
   * @name body
   * @type {!string}
   */

  /**
   * @name flavor
   * @type {!string}
   */

  /**
   * @name title
   * @type {string}
   */
; buf.push('\n<div class="alert netsim-alert ', escape((17,  flavor )), ' fade in">\n  <button type="button" class="netsim-alert-button close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n  ');19; if (title) { ; buf.push('<strong>', escape((19,  title )), '</strong>');19; } ; buf.push('\n  ', escape((20,  body )), '\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/trevor/code-dot-org/apps/node_modules/ejs/lib/ejs.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/DataConverters.js":[function(require,module,exports){
/**
 * @overview Provides utility methods for converting user data between
 *           different encodings, and formatting those encodings: binary,
 *           hex, decimal, ASCII.  "A and B" is a special encoding that is
 *           just binary with "A" sub'd for 0 and "B" sub'd for 1.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';
/* global window */
/* global require */
/* global exports */

var utils = require('../utils'); // For String.prototype.repeat polyfill
var NetSimUtils = require('./NetSimUtils');

// window.{btoa, atob} polyfills
if (!(window.atob && window.btoa)) {
  var base64 = require('Base64');
  window.btoa = window.btoa || base64.btoa;
  window.atob = window.atob || base64.atob;
}

/**
 * @typedef {string} AddressHeaderFormat
 * A string indicating the parts of an address field in the packet header,
 * their respective byte-widths, and the separators to be used when converting
 * binary to a readable format.
 * Examples:
 * "4" indicates a single 4-byte number, e.g. 5 / 0101
 * "8.4" indicates an 8-byte number followed by a 4-byte number, separated
 *   by a period, e.g. 1.1 / 000000010001 or 18.9 / 00010010 1001
 * "8.8.8.8" would be an IPv4 address, e.g.
 *   127.0.0.1 / 01111111 00000000 00000000 00000001
 */

/**
 * Converts an As and Bs string into its most compact representation, forced
 * to uppercase.
 * @param {string} abString
 * @returns {string}
 */
exports.minifyAB = function (abString) {
  return abString.replace(/[^AB]/gi, '').toUpperCase();
};

/**
 * Converts an AB-binary string to a formatted representation, with chunks
 * of a set size separated by a space.
 * @param {string} abString
 * @param {number} chunkSize
 * @param {number} [offset] bit-offset for formatting effect; default 0.
 * @returns {string} formatted version
 */
exports.formatAB = function (abString, chunkSize, offset) {
  return exports.formatBinary(exports.abToBinary(abString), chunkSize, offset).replace(/0/g, 'A').replace(/1/g, 'B');
};

/**
 * Converts a binary string into its most compact string representation.
 * @param {string} binaryString that may contain whitespace
 * @returns {string} binary string with no whitespace
 */
exports.minifyBinary = function (binaryString) {
  return binaryString.replace(/[^01]/g, '');
};

/**
 * Converts a binary string to a formatted representation, with chunks of
 * a set size separated by a space.
 * @param {string} binaryString - may be unformatted already
 * @param {number} chunkSize - how many bits per format chunk
 * @param {number} [offset] bit-offset for formatting effect; default 0.
 * @returns {string} pretty formatted binary string
 */
exports.formatBinary = function (binaryString, chunkSize, offset) {
  offset = utils.valueOr(offset, 0);
  if (chunkSize <= 0) {
    throw new RangeError("Parameter chunkSize must be greater than zero");
  }

  var binary = exports.minifyBinary(binaryString);

  var chunks = [];
  var firstChunkLength = utils.mod(offset, chunkSize);
  if (firstChunkLength > 0) {
    chunks.push(binary.substr(0, firstChunkLength));
  }

  for (var i = firstChunkLength; i < binary.length; i += chunkSize) {
    chunks.push(binary.substr(i, chunkSize));
  }

  return chunks.join(' ');
};

/**
 * Converts a hexadecimal string into its most compact string representation.
 * Strips whitespace and non-hex characters, and coerces letters to uppercase.
 * @param {string} hexString
 * @returns {string}
 */
exports.minifyHex = function (hexString) {
  return hexString.replace(/[^0-9A-F]/gi, '').toUpperCase();
};

/**
 * Reduces all whitespace to single characters and strips non-digits.
 * @param decimalString
 */
exports.minifyDecimal = function (decimalString) {
  return decimalString.replace(/(^\s+|\s+$|[^0-9\s])/g, '').replace(/\s+/g, ' ');
};

/**
 * Converts a hex string to a formatted representation, with chunks of
 * a set size separated by a space.
 * @param {string} hexString
 * @param {number} chunkSize - in bits!
 * @param {number} [offset] hex-digit-offset for formatting effect; default 0.
 * @returns {string} formatted hex
 */
exports.formatHex = function (hexString, chunkSize, offset) {
  offset = utils.valueOr(offset, 0);
  if (chunkSize <= 0) {
    throw new RangeError("Parameter chunkSize must be greater than zero");
  }

  // Don't format hex when the chunkSize doesn't align with hex characters.
  if (chunkSize % 4 !== 0) {
    return hexString;
  }

  var hexChunkSize = chunkSize / 4;
  var hex = exports.minifyHex(hexString);

  var chunks = [];
  var firstChunkLength = utils.mod(offset, hexChunkSize);
  if (firstChunkLength > 0) {
    chunks.push(hex.substr(0, firstChunkLength));
  }

  for (var i = firstChunkLength; i < hex.length; i += hexChunkSize) {
    chunks.push(hex.substr(i, hexChunkSize));
  }

  return chunks.join(' ');
};

/**
 * Takes a set of whitespace-separated numbers and pads the spacing between
 * them to the width of the widest number, so that they line up when they
 * wrap.
 * @param {string} decimalString
 * @returns {string} aligned decimal string
 */
exports.alignDecimal = function (decimalString) {
  if (decimalString.replace(/\D/g, '') === '') {
    return '';
  }

  var numbers = exports.minifyDecimal(decimalString).split(/\s+/);

  // Find the length of the longest number
  var mostDigits = numbers.reduce(function (prev, cur) {
    if (cur.length > prev) {
      return cur.length;
    }
    return prev;
  }, 0);

  var zeroPadding = '0'.repeat(mostDigits);

  return numbers.map(function (numString) {
    // Left-pad each number with non-breaking spaces up to max width.
    return (zeroPadding + numString).slice(-mostDigits);
  }).join(' ');
};

/**
 * Interprets a string of As and Bs as binary where A is 0 and B is 1, then
 * interprets that binary as a single number, and returns that number.
 * @param {string} abString
 * @returns {number}
 */
exports.abToInt = function (abString) {
  return exports.binaryToInt(exports.abToBinary(abString));
};

/**
 * Converts a number to an AB binary representation
 * @param {number} num
 * @param {number} width
 * @returns {string}
 */
exports.intToAB = function (num, width) {
  return exports.binaryToAB(exports.intToBinary(num, width));
};

/**
 * Converts As and Bs to a binary string, where A is 0 and B is 1.
 * @param {string} abString
 * @returns {string}
 */
exports.abToBinary = function (abString) {
  return exports.minifyAB(abString).replace(/A/g, '0').replace(/B/g, '1');
};

/**
 * Converts binary into As and Bs, where 0 is A and 1 is B.
 * @param {string} binaryString
 * @returns {string}
 */
exports.binaryToAB = function (binaryString) {
  return exports.minifyBinary(binaryString).replace(/0/g, 'A').replace(/1/g, 'B');
};

/**
 * Interprets a binary string as a single number, and returns that number.
 * @param {string} binaryString
 * @returns {number}
 */
exports.binaryToInt = function (binaryString) {
  return parseInt(exports.minifyBinary(binaryString), 2);
};

var intToString = function intToString(int, base, width) {
  if (width <= 0) {
    throw new RangeError("Output width must be greater than zero");
  }
  return NetSimUtils.zeroPadLeft(int.toString(base), width);
};

/**
 * Converts a number to a binary string representation with the given width.
 * @param {number} int - number to convert
 * @param {number} width - number of bits to use
 * @returns {string} - binary representation with length of "width"
 */
exports.intToBinary = function (int, width) {
  return intToString(int, 2, width);
};

/**
 * Interprets a hex string as a single number, and returns that number.
 * @param hexadecimalString
 * @returns {Number}
 */
exports.hexToInt = function (hexadecimalString) {
  return parseInt(exports.minifyHex(hexadecimalString), 16);
};

/**
 * Converts a number to a hexadecimal string representation with the given
 * width.
 * @param {number} int - number to convert
 * @param {number} width - number of characters to use
 * @returns {string} - hex representation with length of "width"
 */
exports.intToHex = function (int, width) {
  return intToString(int, 16, width).toUpperCase();
};

/**
 * Converts a hex string to a binary string, by mapping each hex character
 * to four bits of binary.
 * @param {string} hexadecimalString
 * @returns {string} binary representation.
 */
exports.hexToBinary = function (hexadecimalString) {
  var uglyHex = exports.minifyHex(hexadecimalString);
  var binary = '';

  for (var i = 0; i < uglyHex.length; i++) {
    binary += exports.intToBinary(exports.hexToInt(uglyHex.substr(i, 1)), 4);
  }

  return binary;
};

/**
 * Converts a binary string to a hex string, mapping each four bits into
 * a hex character and right-padding with zeroes to round out the binary length.
 * @param {string} binaryString
 * @returns {string}
 */
exports.binaryToHex = function (binaryString) {
  var currentNibble;
  var nibbleWidth = 4;
  var chars = [];
  var uglyBinary = exports.minifyBinary(binaryString);
  for (var i = 0; i < uglyBinary.length; i += nibbleWidth) {
    currentNibble = NetSimUtils.zeroPadRight(uglyBinary.substr(i, nibbleWidth), nibbleWidth);
    chars.push(exports.intToHex(exports.binaryToInt(currentNibble), 1));
  }
  return chars.join('');
};

/**
 * Converts a string set of numbers to a binary representation of those numbers
 * using the given byte-size.
 * @param {string} decimalString - A set of numbers separated by whitespace.
 * @param {number} byteSize - How many bits to use to represent each number.
 * @returns {string} Binary representation.
 */
exports.decimalToBinary = function (decimalString, byteSize) {
  // Special case: No numbers
  if (decimalString.replace(/\D/g, '') === '') {
    return '';
  }

  return exports.minifyDecimal(decimalString).split(/\s+/).map(function (numString) {
    return exports.intToBinary(parseInt(numString, 10), byteSize);
  }).join('');
};

/**
 * Converts binary to a string of decimal numbers separated by whitespace.
 * @param {string} binaryString
 * @param {number} byteSize - How many bits to read for each number
 * @returns {string} decimal numbers
 */
exports.binaryToDecimal = function (binaryString, byteSize) {
  var currentByte;
  var numbers = [];
  var binary = exports.minifyBinary(binaryString);
  for (var i = 0; i < binary.length; i += byteSize) {
    currentByte = NetSimUtils.zeroPadRight(binary.substr(i, byteSize), byteSize);
    numbers.push(exports.binaryToInt(currentByte));
  }
  return numbers.join(' ');
};

/**
 * Converts ascii to binary, using the given bytesize for each character.
 * Overflow is ignored (left-trimmed); recommend using a bytesize of 8 in
 * most circumstances.
 * @param {string} asciiString
 * @param {number} byteSize
 * @returns {string}
 */
exports.asciiToBinary = function (asciiString, byteSize) {
  var bytes = [];
  for (var i = 0; i < asciiString.length; i++) {
    bytes.push(exports.intToBinary(asciiString.charCodeAt(i), byteSize));
  }
  return bytes.join('');
};

/**
 * Converts binary to an ascii string, using the given bytesize for each
 * character.  If the binary is not divisible by bytesize, the final character
 * is right-padded.
 * @param {string} binaryString
 * @param {number} byteSize
 * @returns {string} ASCII string
 */
exports.binaryToAscii = function (binaryString, byteSize) {
  if (byteSize <= 0) {
    throw new RangeError("Parameter byteSize must be greater than zero");
  }

  var currentByte;
  var chars = [];
  var binary = exports.minifyBinary(binaryString);
  for (var i = 0; i < binary.length; i += byteSize) {
    currentByte = NetSimUtils.zeroPadRight(binary.substr(i, byteSize), byteSize);
    chars.push(String.fromCharCode(exports.binaryToInt(currentByte)));
  }
  return chars.join('');
};

/**
 * @typedef {Object} Base64Payload
 * @property {string} string - the base64-encoded payload
 * @property {number} len - the length of the original binary payload
 */

/**
 * Converts binary to a base64 string for more efficient network
 * transfer. Because base64 expects even bytes, we pad the binary string
 * to the nearest byte and return the original length. The reverse
 * conversion expects to be given that original length.
 * @param {string} binaryString
 * @returns {Base64Payload} Object containing the base64 string and the
 *          length of of the original binaryString
 * @throws {TypeError} if binaryString argument is not a
 *         properly-formatted string of zeroes and ones.
 * @example
 * // returns { string: "kg==", len: 7 }
 * DataConverters.binaryToBase64("1001001");
 */
exports.binaryToBase64 = function (binaryString) {

  if (/^[01]*$/.test(binaryString) === false) {
    throw new TypeError("argument binaryString to method binaryToBase64" + "must be a binary string; received \"" + binaryString + "\" instead");
  }

  var byteLen = Math.ceil(binaryString.length / 8.0) * 8;
  var paddedBinaryString = NetSimUtils.zeroPadRight(binaryString, byteLen);
  var payload = window.btoa(exports.binaryToAscii(paddedBinaryString, 8));

  return { string: payload, len: binaryString.length };
};

/**
 * Converts a base64 string back into a binary string of the specified
 * length.
 * @param {string} base64string
 * @param {number} len
 * @returns {string} binaryString
 * @throws {TypeError} if base64string argument is not a
 *         properly base64-encoded string
 * @example
 * // returns "1001001"
 * DataConverters.base64ToBinary("kg==", 7);
 */
exports.base64ToBinary = function (base64string, len) {
  var decodedData;
  try {
    decodedData = window.atob(base64string);
  } catch (e) {
    throw new TypeError("argument base64string to method base64ToBinary" + "must be a base64-encoded string");
  }
  return exports.asciiToBinary(decodedData, 8).substr(0, len);
};

/**
 * Converts binary to an address string using the provided address format.
 * @param {string} binaryString
 * @param {AddressHeaderFormat} addressFormat
 * @returns {string}
 */
exports.binaryToAddressString = function (binaryString, addressFormat) {
  var binary = exports.minifyBinary(binaryString);
  if (binary.length === 0) {
    return '';
  }

  var indexIntoBinary = 0;

  // Parentheses in the split() regex cause the dividing elements to be captured
  // and also included in the return value.
  return addressFormat.split(/(\D+)/).map(function (formatPart) {
    var bitWidth = parseInt(formatPart, 10);
    if (isNaN(bitWidth)) {
      // Pass non-number parts of the format through, so we use the original
      // entered characters/layout for formatting.
      return formatPart;
    }

    var binarySlice = binary.substr(indexIntoBinary, bitWidth);
    var intVal = binarySlice.length > 0 ? exports.binaryToInt(binarySlice) : 0;
    indexIntoBinary += bitWidth;
    return intVal.toString();
  }).join('');
};

/**
 * Converts a formatted address string (decimal numbers with separators) into
 * binary with bit-widths for each part matching the given format.
 * @param {string} addressString
 * @param {AddressHeaderFormat} addressFormat
 * @returns {string}
 */
exports.addressStringToBinary = function (addressString, addressFormat) {
  if (addressString.length === 0) {
    return '';
  }

  // Actual user input, converted to a number[]
  var addressParts = addressString.toString().split(/\D+/).map(function (stringPart) {
    return parseInt(stringPart, 10);
  }).filter(function (numberPart) {
    return !isNaN(numberPart);
  });

  // Format, converted to a number[] where the numbers are bit-widths
  var partWidths = addressFormat.split(/\D+/).map(function (stringPart) {
    return parseInt(stringPart, 10);
  }).filter(function (numberPart) {
    return !isNaN(numberPart);
  });

  var partValue;
  var binary = '';
  for (var i = 0; i < partWidths.length; i++) {
    partValue = i < addressParts.length ? addressParts[i] : 0;
    binary = binary + exports.intToBinary(partValue, partWidths[i]);
  }
  return binary;
};

/**
 * Convert a binary string to a formatted representation, with chunks that
 * correspond to the parts of the address header.
 * @param {string} binaryString
 * @param {AddressHeaderFormat} addressFormat
 */
exports.formatBinaryForAddressHeader = function (binaryString, addressFormat) {
  var binary = exports.minifyBinary(binaryString);

  var partWidths = addressFormat.split(/\D+/).map(function (stringPart) {
    return parseInt(stringPart, 10);
  }).filter(function (numberPart) {
    return !isNaN(numberPart);
  });

  var chunks = [];
  var index = 0;
  partWidths.forEach(function (bitWidth) {
    var next = binary.substr(index, bitWidth);
    if (next.length > 0) {
      chunks.push(next);
    }
    index += bitWidth;
  });

  var next = binary.substr(index);
  if (next.length > 0) {
    chunks.push(next);
  }

  return chunks.join(' ');
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimUtils":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js","Base64":"/home/trevor/code-dot-org/apps/node_modules/Base64/base64.js"}],"/home/trevor/code-dot-org/apps/node_modules/Base64/base64.js":[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    var str = String(input);
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = str.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimUtils.js":[function(require,module,exports){
/**
 * @overview Static helper methods for NetSim.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();
var i18n = require('./locale');
var NetSimConstants = require('./NetSimConstants');
var NetSimGlobals = require('./NetSimGlobals');

var logger = require('./NetSimLogger').getSingleton();

var EncodingType = NetSimConstants.EncodingType;

/**
 * Make a new SVG element, appropriately namespaced, wrapped in a jQuery
 * object for (semi-)easy manipulation.
 * @param {string} type - the tagname for the svg element.
 * @returns {jQuery} for chaining
 */
exports.jQuerySvgElement = function (type) {
  var newElement = $(document.createElementNS('http://www.w3.org/2000/svg', type));

  /**
   * Override addClass since jQuery addClass doesn't work on svg.
   * @param {string} className
   */
  newElement.addClass = function (className) {
    var oldClasses = newElement.attr('class');
    if (!oldClasses) {
      newElement.attr('class', className);
    } else if (!newElement.hasClass(className)) {
      newElement.attr('class', oldClasses + ' ' + className);
    }
    return newElement;
  };

  /**
   * Override removeClass since jQuery removeClass doesn't work on svg.
   * Removes the given classname if it exists on the element.
   * @param {string} className
   * @returns {jQuery} for chaining
   */
  newElement.removeClass = function (className) {
    var oldClasses = newElement.attr('class');
    if (oldClasses) {
      var newClasses = oldClasses.split(/\s+/g).filter(function (word) {
        return word !== className;
      }).join(' ');
      newElement.attr('class', newClasses);
    }
    return newElement;
  };

  /**
   * Override hasClass since jQuery hasClass doesn't work on svg.
   * Checks whether the element has the given class.
   * @param {string} className
   * @returns {boolean}
   */
  newElement.hasClass = function (className) {
    var oldClasses = newElement.attr('class');
    return oldClasses && oldClasses.split(/\s+/g).some(function (existingClass) {
      return existingClass === className;
    });
  };

  /**
   * Override toggleClass since jQuery toggleClass doesn't work on svg.
   *
   * Two versions:
   *
   * toggleClass(className) reverses the state of the class on the element;
   *   if it has the class it gets removed, if it doesn't have the class it
   *   gets added.
   *
   * toggleClass(className, shouldHaveClass) adds or removes the class on the
   *   element depending on the value of the second argument.
   *
   *
   * @param {string} className
   * @param {boolean} [shouldHaveClass]
   * @returns {jQuery} for chaining
   */
  newElement.toggleClass = function (className, shouldHaveClass) {
    // Default second argument - if not provided, we flip the current state
    shouldHaveClass = utils.valueOr(shouldHaveClass, !newElement.hasClass(className));

    if (shouldHaveClass) {
      newElement.addClass(className);
    } else {
      newElement.removeClass(className);
    }
    return newElement;
  };

  return newElement;
};

/**
 * Checks configuration against tab type to decide whether tab
 * of type should be shown.
 * @param {NetSimLevelConfiguration} levelConfig
 * @param {NetSimTabType} tabType
 */
exports.shouldShowTab = function (levelConfig, tabType) {
  return levelConfig.showTabs.indexOf(tabType) > -1;
};

/**
 * Get the localized string for the given encoding type.
 * @param {EncodingType} encodingType
 * @returns {string} localized encoding name
 */
exports.getEncodingLabel = function (encodingType) {
  if (encodingType === EncodingType.ASCII) {
    return i18n.ascii();
  } else if (encodingType === EncodingType.DECIMAL) {
    return i18n.decimal();
  } else if (encodingType === EncodingType.HEXADECIMAL) {
    return i18n.hex();
  } else if (encodingType === EncodingType.BINARY) {
    return i18n.binary();
  } else if (encodingType === EncodingType.A_AND_B) {
    return i18n.a_and_b();
  }
  return '';
};

/**
 * @param {Object} enumObj - Technically any object, but should be used with
 *        an enum like those found in NetSimConstants
 * @param {function} func - A function to call for each value in the enum,
 *        which gets passed the enum value.
 */
exports.forEachEnumValue = function (enumObj, func) {
  for (var enumKey in enumObj) {
    if (enumObj.hasOwnProperty(enumKey)) {
      func(enumObj[enumKey]);
    }
  }
};

/**
 * Rules used by serializeNumber and deserializeNumber to map unsupported
 * JavaScript values into JSON and back.
 * @type {{jsVal: number, jsonVal: string}[]}
 * @readonly
 */
var NUMBER_SERIALIZATION_RULES = [{ jsVal: Infinity, jsonVal: 'Infinity' }, { jsVal: -Infinity, jsonVal: '-Infinity' }, { jsVal: NaN, jsonVal: 'NaN' }, { jsVal: undefined, jsonVal: 'undefined' }];

/**
 * Checks that the provided value is actually the special value NaN, unlike
 * standard isNaN which returns true for anything that's not a number.
 * @param {*} val - any value
 * @returns {boolean}
 */
var isExactlyNaN = function isExactlyNaN(val) {
  // NaN is the only value in JavaScript that is not exactly equal to itself.
  // Therefore, if val !== val, then val must be NaN.
  return val !== val;
};

/**
 * Because JSON doesn't support the values Infinity, NaN, or undefined, you can
 * use this method to store those values in JSON as strings.
 * @param {number|NaN} num
 * @returns {number|string}
 */
exports.serializeNumber = function (num) {
  var applicableRule = _.find(NUMBER_SERIALIZATION_RULES, function (rule) {
    return rule.jsVal === num || isExactlyNaN(rule.jsVal) && isExactlyNaN(num);
  });
  return applicableRule ? applicableRule.jsonVal : num;
};

/**
 * Because JSON doesn't support the values Infinity, NaN, or undefined, you can
 * use this method to retrieve a value from JSON that is either a number or one
 * of those values.
 * @param {number|string} storedNum
 * @returns {number|NaN}
 */
exports.deserializeNumber = function (storedNum) {
  var applicableRule = _.find(NUMBER_SERIALIZATION_RULES, function (rule) {
    return rule.jsonVal === storedNum;
  });
  return applicableRule ? applicableRule.jsVal : storedNum;
};

/**
 * Helper for converting from an older header-spec format to a new, simpler one.
 * Old format: {key:{string}, bits:{number}}[]
 * New format: string[]
 * If we detect the old format, we return a spec in the new format.
 * @param {Array} spec
 * @returns {Array}
 */
exports.scrubHeaderSpecForBackwardsCompatibility = function (spec) {
  var foundOldFormat = false;
  var scrubbedSpec = [];
  spec.forEach(function (specEntry) {
    if (typeof specEntry === 'string') {
      // This is new new format, we can just copy it over.
      scrubbedSpec.push(specEntry);
    } else if (specEntry !== null && typeof specEntry === 'object') {
      // This is the old {key:'', bits:0} format.  We just want the key.
      scrubbedSpec.push(specEntry.key);
      foundOldFormat = true;
    }
  });

  // Issue a warning if an old format got converted, so we know to update
  // the level.
  if (foundOldFormat) {
    logger.warn("Converting old header specification format to new format." + " This level should be updated to use the new format.");
  }

  return scrubbedSpec;
};

/**
 * @param {NetSimLevelConfiguration} levelConfig
 * @returns {NetSimLevelConfiguration} same thing, but with certain values
 *          converted or cleaned.
 * @private
 */
exports.scrubLevelConfiguration_ = function (levelConfig) {
  var scrubbedLevel = _.clone(levelConfig, true);

  // Convert old header spec format to new header spec format
  scrubbedLevel.routerExpectsPacketHeader = exports.scrubHeaderSpecForBackwardsCompatibility(scrubbedLevel.routerExpectsPacketHeader);
  scrubbedLevel.clientInitialPacketHeader = exports.scrubHeaderSpecForBackwardsCompatibility(scrubbedLevel.clientInitialPacketHeader);

  // Coerce certain values to string that might have been mistaken for numbers
  scrubbedLevel.addressFormat = scrubbedLevel.addressFormat.toString();

  // Explicitly list fields that we suspect may have a string value that
  // needs to be converted to a number, like "Infinity"
  scrubbedLevel.defaultPacketSizeLimit = exports.deserializeNumber(scrubbedLevel.defaultPacketSizeLimit);

  // Packet Size cannot be infinity; defaults to 8kb
  if (scrubbedLevel.defaultPacketSizeLimit === Infinity) {
    scrubbedLevel.defaultPacketSizeLimit = 8192;
  }

  scrubbedLevel.defaultBitRateBitsPerSecond = exports.deserializeNumber(scrubbedLevel.defaultBitRateBitsPerSecond);
  scrubbedLevel.defaultChunkSizeBits = exports.deserializeNumber(scrubbedLevel.defaultChunkSizeBits);
  scrubbedLevel.defaultRouterBandwidth = exports.deserializeNumber(scrubbedLevel.defaultRouterBandwidth);
  scrubbedLevel.defaultRouterMemory = exports.deserializeNumber(scrubbedLevel.defaultRouterMemory);

  // Generate a warning if we see a possible missed string-to-number conversion
  Object.keys(scrubbedLevel).filter(function (key) {
    // Ignore level params with underscores, they are the dashboard versions
    // of the camelCase parameters that the app actually uses.
    return !/_/.test(key);
  }).forEach(function (key) {
    var unconvertedValue = NUMBER_SERIALIZATION_RULES.some(function (rule) {
      return scrubbedLevel[key] === rule.jsonVal;
    });
    if (unconvertedValue) {
      logger.warn("Level option '" + key + "' has unconverted string value '" + scrubbedLevel[key] + "'");
    }
  });

  return scrubbedLevel;
};

/**
 * Converts a number of bits into a localized representation of that data
 * size in bytes, kilobytes, megabytes, gigabytes.
 * @param {number} bits
 * @returns {string} - localized string representation of size in bytes
 */
exports.bitsToLocalizedRoundedBytesize = function (bits) {
  if (bits === Infinity) {
    return i18n.unlimited();
  }

  var gbytes = Math.floor(bits / NetSimConstants.BITS_PER_GIGABYTE);
  if (gbytes > 0) {
    return i18n.x_GBytes({ x: gbytes });
  }

  var mbytes = Math.floor(bits / NetSimConstants.BITS_PER_MEGABYTE);
  if (mbytes > 0) {
    return i18n.x_MBytes({ x: mbytes });
  }

  var kbytes = Math.floor(bits / NetSimConstants.BITS_PER_KILOBYTE);
  if (kbytes > 0) {
    return i18n.x_KBytes({ x: kbytes });
  }

  var bytes = Math.floor(bits / NetSimConstants.BITS_PER_BYTE);
  if (bytes > 0) {
    return i18n.x_Bytes({ x: bytes });
  }

  return i18n.x_bits({ x: bits });
};

/**
 * Converts a bitrate into a localized representation of that data
 * size in bits/sec, kilobits, megabits, gigabits.
 * @param {number} bitsPerSecond
 * @returns {string} - localized string representation of speed in bits
 */
exports.bitrateToLocalizedRoundedBitrate = function (bitsPerSecond) {
  if (bitsPerSecond === Infinity) {
    return i18n.unlimited();
  }

  var gbps = Math.floor(bitsPerSecond / NetSimConstants.BITS_PER_GIGABIT);
  if (gbps > 0) {
    return i18n.x_Gbps({ x: gbps });
  }

  var mbps = Math.floor(bitsPerSecond / NetSimConstants.BITS_PER_MEGABIT);
  if (mbps > 0) {
    return i18n.x_Mbps({ x: mbps });
  }

  var kbps = Math.floor(bitsPerSecond / NetSimConstants.BITS_PER_KILOBIT);
  if (kbps > 0) {
    return i18n.x_Kbps({ x: kbps });
  }

  var bps = Math.floor(bitsPerSecond * 100) / 100;
  return i18n.x_bps({ x: bps });
};

exports.zeroPadLeft = function (string, desiredWidth) {
  var padding = '0'.repeat(desiredWidth);
  return (padding + string).slice(-desiredWidth);
};

exports.zeroPadRight = function (string, desiredWidth) {
  var padding = '0'.repeat(desiredWidth);
  return (string + padding).substr(0, desiredWidth);
};

/**
 * Creates a Continue/Finish button on the given NetSimPanel (in its header).
 * @param {NetSimPanel} onPanel
 * @static
 */
exports.makeContinueButton = function (onPanel) {
  onPanel.addButton(i18n.continueButton({ caret: '<i class="fa fa-caret-right"></i>' }), function (jQueryEvent) {
    if (!$(jQueryEvent.target).is(':disabled')) {
      NetSimGlobals.completeLevelAndContinue();
    }
  }, {
    secondary: false,
    classes: ['submitButton']
  });
};

},{"../utils":"/home/trevor/code-dot-org/apps/build/js/utils.js","./NetSimConstants":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js","./NetSimGlobals":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js","./NetSimLogger":"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js","./locale":"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js"}],"/home/trevor/code-dot-org/apps/build/js/netsim/locale.js":[function(require,module,exports){
// locale for netsim

"use strict";

module.exports = window.blockly.netsim_locale;

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimLogger.js":[function(require,module,exports){
/**
 * @overview Utility class wrapping more granular log behavior that isn't
 * available in all browsers.  Also makes it easy to turn logging on and off
 * in tests.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

/**
 * Logging API to control log levels and support different browsers
 * @constructor
 * @param {Console} window console API
 * @param {LogLevel} verbosity
 */
var NetSimLogger = module.exports = function (outputConsole, verbosity /*=VERBOSE*/) {
  /**
   * @type {Console}
   * @private
   */
  this.outputConsole_ = outputConsole;

  /**
   * Always mapped to console.log, or no-op if not available.
   * @type {Function}
   * @private
   */
  this.log_ = function () {};

  /**
   * If configured for info logging, gets mapped to console.info,
   * falls back to console.log, or no-op.
   * @type {Function}
   */
  this.info = function () {};

  /**
   * If configured for warning logging, gets mapped to console.warn,
   * falls back to console.log, or no-op.
   * @type {Function}
   */
  this.warn = function () {};

  /**
   * If configured for error logging, gets mapped to console.error,
   * falls back to console.log, or no-op.
   * @type {Function}
   */
  this.error = function () {};

  this.setVerbosity(undefined === verbosity ? LogLevel.VERBOSE : verbosity);
};

/**
 * Log verbosity levels enum.
 * @readonly
 * @enum {number}
 */
var LogLevel = {
  NONE: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  VERBOSE: 4
};
NetSimLogger.LogLevel = LogLevel;

/**
 * Global singleton
 * @type {NetSimLogger}
 */
var singletonInstance;

/**
 * Static getter/lazy-creator for the global singleton instance.
 * @returns {NetSimLogger}
 */
NetSimLogger.getSingleton = function () {
  if (singletonInstance === undefined) {
    singletonInstance = new NetSimLogger(console, LogLevel.WARN);
  }
  return singletonInstance;
};

/**
 * Binds internal function calls according to given verbosity level.
 * @param verbosity
 */
NetSimLogger.prototype.setVerbosity = function (verbosity) {
  // Note: We don't call this.outputConsole_.log.bind here, because in IE9 the
  // console's logging methods do not inherit from Function.

  this.log_ = this.outputConsole_ && this.outputConsole_.log ? Function.prototype.bind.call(this.outputConsole_.log, this.outputConsole_) : function () {};

  if (verbosity >= LogLevel.INFO) {
    this.info = this.outputConsole_ && this.outputConsole_.info ? Function.prototype.bind.call(this.outputConsole_.info, this.outputConsole_) : this.log_;
  } else {
    this.info = function () {};
  }

  if (verbosity >= LogLevel.WARN) {
    this.warn = this.outputConsole_ && this.outputConsole_.warn ? Function.prototype.bind.call(this.outputConsole_.warn, this.outputConsole_) : this.log_;
  } else {
    this.warn = function () {};
  }

  if (verbosity >= LogLevel.ERROR) {
    this.error = this.outputConsole_ && this.outputConsole_.error ? Function.prototype.bind.call(this.outputConsole_.error, this.outputConsole_) : this.log_;
  } else {
    this.error = function () {};
  }
};

/**
 * Writes to output, depending on log level
 * @param {*} message
 * @param {LogLevel} logLevel
 */
NetSimLogger.prototype.log = function (message, logLevel /*=INFO*/) {
  if (undefined === logLevel) {
    logLevel = LogLevel.INFO;
  }

  switch (logLevel) {
    case LogLevel.ERROR:
      this.error(message);
      break;
    case LogLevel.WARN:
      this.warn(message);
      break;
    case LogLevel.INFO:
      this.info(message);
      break;
    default:
      this.log_(message);
  }
};

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimGlobals.js":[function(require,module,exports){
/**
 * @overview Global singleton used to simplify certain cross-cutting concerns,
 *           including:
 *
 *           Access to level configuration.
 *           Access to environment-specific asset URLs.
 *           Reproducible random number functions for easy testing.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

var seedrandom = require('seedrandom');

/**
 * Reference to root StudioApp controller
 * @type {StudioApp}
 * @private
 */
var studioApp_ = null;

/**
 * Reference to root NetSim controller
 * @type {NetSim}
 * @private
 */
var netsim_ = null;

/**
 * Replacable pseudo-random number generator function that lets us set a global
 * random seed if we wish.
 * @type {function}
 * @private
 */
var pseudoRandomNumberFunction_ = Math.random;

/**
 * Get a random integer in the given range.
 * @param {number} low inclusive lower end of range
 * @param {number} high exclusive upper end of range
 * @returns {number}
 */
var randomIntInRange = function randomIntInRange(low, high) {
  return Math.floor(pseudoRandomNumberFunction_() * (high - low)) + low;
};

/**
 * Provide singleton access to global simulation settings
 */
module.exports = {

  /**
   * Set the root controllers that can be used for global operations.
   * @param {StudioApp} studioApp
   * @param {NetSim} netsim
   */
  setRootControllers: function setRootControllers(studioApp, netsim) {
    studioApp_ = studioApp;
    netsim_ = netsim;
  },

  /**
   * @returns {NetSimLevelConfiguration}
   */
  getLevelConfig: function getLevelConfig() {
    return netsim_.level;
  },

  /**
   * @returns {PubSubConfig}
   */
  getPubSubConfig: function getPubSubConfig() {
    return {
      usePusher: netsim_.usePusher,
      pusherApplicationKey: netsim_.pusherApplicationKey
    };
  },

  /**
   * @returns {number}
   */
  getGlobalMaxRouters: function getGlobalMaxRouters() {
    return netsim_.globalMaxRouters;
  },

  /**
   * @returns {function}
   */
  getAssetUrlFunction: function getAssetUrlFunction() {
    return studioApp_.assetUrl;
  },

  /**
   * Trigger a layout update of the right column, received/sent/send panels.
   */
  updateLayout: function updateLayout() {
    netsim_.updateLayout();
  },

  /**
   * Trigger an attempt to complete the current level and continue to the next.
   */
  completeLevelAndContinue: function completeLevelAndContinue() {
    netsim_.completeLevelAndContinue();
  },

  /**
   * Reseed the random number generator.  If this is never called, the default
   * Math.random function is used as the generator.
   * @param {string} newSeed
   */
  setRandomSeed: function setRandomSeed(newSeed) {
    pseudoRandomNumberFunction_ = seedrandom(newSeed);
  },

  /**
   * @returns {number} a random value between 0 and 1
   */
  random: function random() {
    return pseudoRandomNumberFunction_();
  },

  /**
   * Get a random integer in the given range.
   * @param {number} low inclusive lower end of range
   * @param {number} high exclusive upper end of range
   * @returns {number}
   */
  randomIntInRange: randomIntInRange,

  /**
   * Get a random item out of a collection
   * @param {Array} collection
   * @returns {*} undefined if collection is empty
   */
  randomPickOne: function randomPickOne(collection) {
    var size = collection.length;
    if (size === 0) {
      return undefined;
    }

    return collection[randomIntInRange(0, size)];
  }

};

},{"seedrandom":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/index.js":[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/alea.js","./lib/tychei":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/tychei.js","./lib/xor128":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xor128.js","./lib/xor4096":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xor4096.js","./lib/xorshift7":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xorshift7.js","./lib/xorwow":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xorwow.js","./seedrandom":"/home/trevor/code-dot-org/apps/node_modules/seedrandom/seedrandom.js"}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/seedrandom.js":[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
    var out = new Uint8Array(width);
    (global.crypto || global.msCrypto).getRandomValues(out);
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/index.js":[function(require,module,exports){
'use strict';

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')

exports.createHash = exports.Hash = require('create-hash')

exports.createHmac = exports.Hmac = require('create-hmac')

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
exports.getHashes = function () {
  return hashes;
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-aes');
[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key];
})

var dh = require('diffie-hellman');
[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key];
})

var sign = require('browserify-sign');
[
  'createSign',
  'Sign',
  'createVerify',
  'Verify'
].forEach(function (key) {
  exports[key] = sign[key];
})

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt');

[
  'publicEncrypt',
  'privateEncrypt',
  'publicDecrypt',
  'privateDecrypt'
].forEach(function (key) {
  exports[key] = publicEncrypt[key];
})

// the least I can do is make error messages for the rest of the node.js/crypto api.
;[
  'createCredentials'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'));
  }
})

},{"browserify-aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js","browserify-sign":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/browser.js","browserify-sign/algos":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/algos.js","create-ecdh":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js","create-hmac":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js","diffie-hellman":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/browser.js","pbkdf2":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/pbkdf2/browser.js","public-encrypt":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/browser.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/browser.js":[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt');
exports.privateDecrypt = require('./privateDecrypt');

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};
},{"./privateDecrypt":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/privateDecrypt.js","./publicEncrypt":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/publicEncrypt.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/publicEncrypt.js":[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var randomBytes = require('randombytes');
var createHash = require('create-hash');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var withPublic = require('./withPublic');
var crt = require('browserify-rsa');

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHVibGljRW5jcnlwdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKTtcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcblxudmFyIGNvbnN0YW50cyA9IHtcbiAgUlNBX1BLQ1MxX09BRVBfUEFERElORzogNCxcbiAgUlNBX1BLQ1MxX1BBRERJTjogMSxcbiAgUlNBX05PX1BBRERJTkc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdChwdWJsaWNfa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwdWJsaWNfa2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY19rZXkpO1xuICB2YXIgcGFkZGVkTXNnO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICBwYWRkZWRNc2cgPSBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBibihtc2cpO1xuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtTGVuID4gayAtIGhMZW4yIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSBoTGVuMiAtIDIpO1xuICBwcy5maWxsKDApO1xuICB2YXIgZGJsZW4gPSBrIC0gaExlbiAtIDE7XG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbik7XG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIG5ldyBCdWZmZXIoWzFdKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSB4b3Ioc2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSk7XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMF0pLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKTtcbn1cbmZ1bmN0aW9uIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKXtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgcHM7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBuZXcgQnVmZmVyKGsgLSBtTGVuIC0gMyk7XG4gICAgcHMuZmlsbCgweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKTtcbiAgfVxuICByZXR1cm4gbmV3IGJuKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzAsIHJldmVyc2U/MToyXSksIHBzLCBuZXcgQnVmZmVyKFswXSksIG1zZ10sIGspKTtcbn1cbmZ1bmN0aW9uIG5vblplcm8obGVuLCBjcnlwdG8pIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gIHZhciBjdXIgPSAwO1xuICB2YXIgbnVtO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gICAgICBjdXIgPSAwO1xuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK107XG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59Il19
},{"./mgf":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/mgf.js","./withPublic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/withPublic.js","./xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/xor.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js","browserify-rsa":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/browserify-rsa/index.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js","parse-asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/index.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/privateDecrypt.js":[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var crt = require('browserify-rsa');
var createHash = require('create-hash');
var withPublic = require('./withPublic');
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHJpdmF0ZURlY3J5cHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpO1xudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcml2YXRlRGVjcnlwdChwcml2YXRlX2tleSwgZW5jLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nO1xuICBpZiAocHJpdmF0ZV9rZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwcml2YXRlX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICBcbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwcml2YXRlX2tleSk7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICBpZiAoZW5jLmxlbmd0aCA+IGsgfHwgbmV3IGJuKGVuYykuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgdmFyIG1zZztcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBtc2cgPSB3aXRoUHVibGljKG5ldyBibihlbmMpLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IGNydChlbmMsIGtleSk7XG4gIH1cbiAgdmFyIHpCdWZmZXIgPSBuZXcgQnVmZmVyKGsgLSBtc2cubGVuZ3RoKTtcbiAgekJ1ZmZlci5maWxsKDApO1xuICBtc2cgPSBCdWZmZXIuY29uY2F0KFt6QnVmZmVyLCBtc2ddLCBrKTtcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICByZXR1cm4gb2FlcChrZXksIG1zZyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHJldHVybiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHJldHVybiBtc2c7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBuID0ga2V5Lm1vZHVsdXM7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtc2dbMF0gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgbWFza2VkU2VlZCA9IG1zZy5zbGljZSgxLCBoTGVuICsgMSk7XG4gIHZhciBtYXNrZWREYiA9ICBtc2cuc2xpY2UoaExlbiArIDEpO1xuICB2YXIgc2VlZCA9IHhvcihtYXNrZWRTZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKTtcbiAgdmFyIGRiID0geG9yKG1hc2tlZERiLCBtZ2Yoc2VlZCwgayAtIGhMZW4gLSAxKSk7XG4gIGlmIChjb21wYXJlKGlIYXNoLCBkYi5zbGljZSgwLCBoTGVuKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgaSA9IGhMZW47XG4gIHdoaWxlIChkYltpXSA9PT0gMCkge1xuICAgIGkrKztcbiAgfVxuICBpZiAoZGJbaSsrXSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHJldHVybiBkYi5zbGljZShpKTtcbn1cblxuZnVuY3Rpb24gcGtjczEoa2V5LCBtc2csIHJldmVyc2Upe1xuICB2YXIgcDEgPSBtc2cuc2xpY2UoMCwgMik7XG4gIHZhciBpID0gMjtcbiAgdmFyIHN0YXR1cyA9IDA7XG4gIHdoaWxlIChtc2dbaSsrXSAhPT0gMCkge1xuICAgIGlmIChpID49IG1zZy5sZW5ndGgpIHtcbiAgICAgIHN0YXR1cysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBwcyA9IG1zZy5zbGljZSgyLCBpIC0gMSk7XG4gIHZhciBwMiA9IG1zZy5zbGljZShpIC0gMSwgaSk7XG5cbiAgaWYgKChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAyJyAmJiAhcmV2ZXJzZSkgfHwgKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDEnICYmIHJldmVyc2UpKXtcbiAgICBzdGF0dXMrKztcbiAgfVxuICBpZiAocHMubGVuZ3RoIDwgOCkge1xuICAgIHN0YXR1cysrO1xuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICByZXR1cm4gIG1zZy5zbGljZShpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYil7XG4gIGEgPSBuZXcgQnVmZmVyKGEpO1xuICBiID0gbmV3IEJ1ZmZlcihiKTtcbiAgdmFyIGRpZiA9IDA7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIGRpZisrO1xuICAgIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIH1cbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGRpZiArPSAoYVtpXSBeIGJbaV0pO1xuICB9XG4gIHJldHVybiBkaWY7XG59Il19
},{"./mgf":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/mgf.js","./withPublic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/withPublic.js","./xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/xor.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js","browserify-rsa":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/browserify-rsa/index.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js","parse-asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/xor.js":[function(require,module,exports){
module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/withPublic.js":[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvd2l0aFB1YmxpYy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5mdW5jdGlvbiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KSB7XG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZGRlZE1zZ1xuICAgIC50b1JlZChibi5tb250KGtleS5tb2R1bHVzKSlcbiAgICAucmVkUG93KG5ldyBibihrZXkucHVibGljRXhwb25lbnQpKVxuICAgIC5mcm9tUmVkKClcbiAgICAudG9BcnJheSgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoUHVibGljOyJdfQ==
},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/index.js":[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
var ciphers = require('browserify-aes');
var compat = require('pbkdf2');
module.exports = parseKeys;

function parseKeys(buffer) {
  var password;
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer);
  }

  var stripped = fixProc(buffer, password);

  var type = stripped.tag;
  var data = stripped.data;
  var subtype,ndata;
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
        case '1.2.840.10045.2.1':
        ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: 'ec',
            data:  ndata
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(data, password);
      //falling through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default: throw new Error('unknown key type ' +  type);
  }
}
parseKeys.signature = asn1.signature;
function decrypt(data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10)/8;
  var key = compat.pbkdf2Sync(password, salt, iters, keylen);
  var cipher = ciphers.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer.concat(out);
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKTtcbnZhciBhZXNpZCA9IHJlcXVpcmUoJy4vYWVzaWQuanNvbicpO1xudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKTtcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKTtcbnZhciBjb21wYXQgPSByZXF1aXJlKCdwYmtkZjInKTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzO1xuXG5mdW5jdGlvbiBwYXJzZUtleXMoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZDtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdvYmplY3QnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHBhc3N3b3JkID0gYnVmZmVyLnBhc3NwaHJhc2U7XG4gICAgYnVmZmVyID0gYnVmZmVyLmtleTtcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIH1cblxuICB2YXIgc3RyaXBwZWQgPSBmaXhQcm9jKGJ1ZmZlciwgcGFzc3dvcmQpO1xuXG4gIHZhciB0eXBlID0gc3RyaXBwZWQudGFnO1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGE7XG4gIHZhciBzdWJ0eXBlLG5kYXRhO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQVUJMSUMgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5QdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKTtcbiAgICAgIHN3aXRjaChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpO1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgIG5kYXRhLnN1YmplY3RQcml2YXRlS2V5ID0gbmRhdGEuc3ViamVjdFB1YmxpY0tleTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2VjJyxcbiAgICAgICAgICAgIGRhdGE6ICBuZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnB1Yl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgIHN1YnR5cGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyAgdHlwZSk7XG4gICAgY2FzZSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVuY3J5cHRlZFByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICAgIGRhdGEgPSBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkKTtcbiAgICAgIC8vZmFsbGluZyB0aHJvdWdoXG4gICAgY2FzZSAnUFJJVkFURSBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKTtcbiAgICAgIHN3aXRjaChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpO1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnZlOiBuZGF0YS5hbGdvcml0aG0uY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKS5wcml2YXRlS2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHJpdl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIHBhcmFtczogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArICBzdWJ0eXBlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgIHR5cGUpO1xuICAgIGNhc2UgJ1JTQSBQVUJMSUMgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgIGNhc2UgJ1JTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgY2FzZSAnRFNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICBwYXJhbXM6IGFzbjEuRFNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9O1xuICAgIGNhc2UgJ0VDIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VydmU6IGRhdGEucGFyYW1ldGVycy52YWx1ZSxcbiAgICAgICAgcHJpdmF0ZUtleTogZGF0YS5wcml2YXRlS2V5XG4gICAgICB9O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgIHR5cGUpO1xuICB9XG59XG5wYXJzZUtleXMuc2lnbmF0dXJlID0gYXNuMS5zaWduYXR1cmU7XG5mdW5jdGlvbiBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkKSB7XG4gIHZhciBzYWx0ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLnNhbHQ7XG4gIHZhciBpdGVycyA9IHBhcnNlSW50KGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5pdGVycy50b1N0cmluZygpLCAxMCk7XG4gIHZhciBhbGdvID0gYWVzaWRbZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuYWxnby5qb2luKCcuJyldO1xuICB2YXIgaXYgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5pdjtcbiAgdmFyIGNpcGhlclRleHQgPSBkYXRhLnN1YmplY3RQcml2YXRlS2V5O1xuICB2YXIga2V5bGVuID0gcGFyc2VJbnQoYWxnby5zcGxpdCgnLScpWzFdLCAxMCkvODtcbiAgdmFyIGtleSA9IGNvbXBhdC5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVycywga2V5bGVuKTtcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KTtcbiAgdmFyIG91dCA9IFtdO1xuICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKTtcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpO1xufVxuIl19
},{"./aesid.json":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/aesid.json","./asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/asn1.js","./fixProc":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/fixProc.js","browserify-aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","pbkdf2":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/pbkdf2/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/fixProc.js":[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
var startRegex =/^-----BEGIN (.*) KEY-----\r?\n/m;
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
var evp = require('./EVP_BytesToKey');
var ciphers = require('browserify-aes');
module.exports = function (okey, password) {
  var key = okey.toString();
  var match = key.match(findProc);
  var decrypted;
  if (!match) {
    var match2 = key.match(fullRegex);
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
  } else {
    var suite = 'aes' + match[1];
    var iv = new Buffer(match[2], 'hex');
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
    var cipherKey = evp(password, iv.slice(0,8), parseInt(match[1]));
    var out = [];
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer.concat(out);
  }
  var tag = key.match(startRegex)[1] + ' KEY';
  return {
    tag: tag,
    data: decrypted
  };
};

// http://stackoverflow.com/a/7033705
function wrap (str) {
  var chunks = []

  for (var i = 0; i < str.length; i += 64) {
    chunks.push(str.slice(i, i + 64))
  }
  return chunks.join("\n")
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvZml4UHJvYy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEXFxyP1xcbkRFSy1JbmZvOiBBRVMtKCg/OjEyOCl8KD86MTkyKXwoPzoyNTYpKS1DQkMsKFswLTlBLUhdKylcXHI/XFxuXFxyP1xcbihbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxyP1xcbi9tO1xudmFyIHN0YXJ0UmVnZXggPS9eLS0tLS1CRUdJTiAoLiopIEtFWS0tLS0tXFxyP1xcbi9tO1xudmFyIGZ1bGxSZWdleCA9IC9eLS0tLS1CRUdJTiAoLiopIEtFWS0tLS0tXFxyP1xcbihbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxyP1xcbi0tLS0tRU5EIFxcMSBLRVktLS0tLSQvbTtcbnZhciBldnAgPSByZXF1aXJlKCcuL0VWUF9CeXRlc1RvS2V5Jyk7XG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZmluZFByb2MpO1xuICB2YXIgZGVjcnlwdGVkO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpO1xuICAgIGRlY3J5cHRlZCA9IG5ldyBCdWZmZXIobWF0Y2gyWzJdLnJlcGxhY2UoL1xccj9cXG4vZywgJycpLCAnYmFzZTY0Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN1aXRlID0gJ2FlcycgKyBtYXRjaFsxXTtcbiAgICB2YXIgaXYgPSBuZXcgQnVmZmVyKG1hdGNoWzJdLCAnaGV4Jyk7XG4gICAgdmFyIGNpcGhlclRleHQgPSBuZXcgQnVmZmVyKG1hdGNoWzNdLnJlcGxhY2UoL1xccj9cXG4vZywgJycpLCAnYmFzZTY0Jyk7XG4gICAgdmFyIGNpcGhlcktleSA9IGV2cChwYXNzd29yZCwgaXYuc2xpY2UoMCw4KSwgcGFyc2VJbnQobWF0Y2hbMV0pKTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwgY2lwaGVyS2V5LCBpdik7XG4gICAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSk7XG4gICAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpO1xuICAgIGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQob3V0KTtcbiAgfVxuICB2YXIgdGFnID0ga2V5Lm1hdGNoKHN0YXJ0UmVnZXgpWzFdICsgJyBLRVknO1xuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGRhdGE6IGRlY3J5cHRlZFxuICB9O1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzAzMzcwNVxuZnVuY3Rpb24gd3JhcCAoc3RyKSB7XG4gIHZhciBjaHVua3MgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA2NCkge1xuICAgIGNodW5rcy5wdXNoKHN0ci5zbGljZShpLCBpICsgNjQpKVxuICB9XG4gIHJldHVybiBjaHVua3Muam9pbihcIlxcblwiKVxufVxuIl19
},{"./EVP_BytesToKey":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/EVP_BytesToKey.js","browserify-aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/EVP_BytesToKey.js":[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
module.exports = function evp(password, salt, keyLen) {
  keyLen = keyLen/8;
  var ki = 0;
  var ii = 0;
  var key = new Buffer(keyLen);
  var addmd = 0;
  var md, md_buf;
  var i;
  while (true) {
    md = createHash('md5');
    if(addmd++ > 0) {
       md.update(md_buf);
    }
    md.update(password);
    md.update(salt);
    md_buf = md.digest();
    i = 0;
    if(keyLen > 0) {
      while(true) {
        if(keyLen === 0) {
          break;
        }
        if(i === md_buf.length) {
          break;
        }
        key[ki++] = md_buf[i++];
        keyLen--;
       }
    }
   if(keyLen === 0) {
      break;
    }
  }
  for(i=0;i<md_buf.length;i++) {
    md_buf[i] = 0;
  }
  return key;
};
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvRVZQX0J5dGVzVG9LZXkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBldnAocGFzc3dvcmQsIHNhbHQsIGtleUxlbikge1xuICBrZXlMZW4gPSBrZXlMZW4vODtcbiAgdmFyIGtpID0gMDtcbiAgdmFyIGlpID0gMDtcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKTtcbiAgdmFyIGFkZG1kID0gMDtcbiAgdmFyIG1kLCBtZF9idWY7XG4gIHZhciBpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIG1kID0gY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgaWYoYWRkbWQrKyA+IDApIHtcbiAgICAgICBtZC51cGRhdGUobWRfYnVmKTtcbiAgICB9XG4gICAgbWQudXBkYXRlKHBhc3N3b3JkKTtcbiAgICBtZC51cGRhdGUoc2FsdCk7XG4gICAgbWRfYnVmID0gbWQuZGlnZXN0KCk7XG4gICAgaSA9IDA7XG4gICAgaWYoa2V5TGVuID4gMCkge1xuICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBpZihrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2krK107XG4gICAgICAgIGtleUxlbi0tO1xuICAgICAgIH1cbiAgICB9XG4gICBpZihrZXlMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IoaT0wO2k8bWRfYnVmLmxlbmd0aDtpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwO1xuICB9XG4gIHJldHVybiBrZXk7XG59OyJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/asn1.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/asn1.js"][0].apply(exports,arguments)
},{"asn1.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js"][0].apply(exports,arguments)
},{"./asn1/api":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js","./asn1/base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","./asn1/constants":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js","./asn1/decoders":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js","./asn1/encoders":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js"][0].apply(exports,arguments)
},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js","./pem":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/pem.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/pem.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/pem.js"][0].apply(exports,arguments)
},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js"][0].apply(exports,arguments)
},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js"][0].apply(exports,arguments)
},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js","./pem":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/pem.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/pem.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/pem.js"][0].apply(exports,arguments)
},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js"][0].apply(exports,arguments)
},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js"][0].apply(exports,arguments)
},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js"][0].apply(exports,arguments)
},{"../constants":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js"][0].apply(exports,arguments)
},{"./buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js","./node":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js","./reporter":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js"][0].apply(exports,arguments)
},{"inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js"][0].apply(exports,arguments)
},{"../base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","minimalistic-assert":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js"][0].apply(exports,arguments)
},{"../base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js"][0].apply(exports,arguments)
},{"../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","vm":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/vm-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/parse-asn1/aesid.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/aesid.json"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/browserify-rsa/index.js":[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).mod(p);
  h.imul(q);
  m2.iadd(h);
  var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
  if (out.length < len) {
    var prefix = new Buffer(len - out.length);
    prefix.fill(0);
    out = Buffer.concat([prefix, out], len);
  }
  return out;
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS5tb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLm1vZChwKTtcbiAgaC5pbXVsKHEpO1xuICBtMi5pYWRkKGgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihtMi5pbXVsKGJsaW5kcy51bmJsaW5kZXIpLm1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoKSk7XG4gIGlmIChvdXQubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHByZWZpeCA9IG5ldyBCdWZmZXIobGVuIC0gb3V0Lmxlbmd0aCk7XG4gICAgcHJlZml4LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbcHJlZml4LCBvdXRdLCBsZW4pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci5tb2QocHJpdi5wcmltZTEpIHx8ICFyLm1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufSJdfQ==
},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/node_modules/bn.js/lib/bn.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/public-encrypt/mgf.js":[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbWdmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VlZCwgbGVuKSB7XG4gIHZhciB0ID0gbmV3IEJ1ZmZlcignJyk7XG4gIHZhciAgaSA9IDAsIGM7XG4gIHdoaWxlICh0Lmxlbmd0aCA8IGxlbikge1xuICAgIGMgPSBpMm9wcyhpKyspO1xuICAgIHQgPSBCdWZmZXIuY29uY2F0KFt0LCBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNlZWQpLnVwZGF0ZShjKS5kaWdlc3QoKV0pO1xuICB9XG4gIHJldHVybiB0LnNsaWNlKDAsIGxlbik7XG59O1xuXG5mdW5jdGlvbiBpMm9wcyhjKSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKDQpO1xuICBvdXQud3JpdGVVSW50MzJCRShjLDApO1xuICByZXR1cm4gb3V0O1xufSJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/browser.js":[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime');
var primes = require('./lib/primes');

var DH = require('./lib/dh');

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');

  return new DH(prime, gen);
}

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
    genc = generator;
    generator = enc;
    enc = undefined;
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdlbmVyYXRlUHJpbWUgPSByZXF1aXJlKCcuL2xpYi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9saWIvcHJpbWVzJyk7XG5cbnZhciBESCA9IHJlcXVpcmUoJy4vbGliL2RoJyk7XG5cbmZ1bmN0aW9uIGdldERpZmZpZUhlbGxtYW4obW9kKSB7XG4gIHZhciBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0ucHJpbWUsICdoZXgnKTtcbiAgdmFyIGdlbiA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0uZ2VuLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlmZmllSGVsbG1hbihwcmltZSwgZW5jLCBnZW5lcmF0b3IsIGdlbmMpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlbmMpIHx8ICh0eXBlb2YgZW5jID09PSAnc3RyaW5nJyAmJiBbJ2hleCcsICdiaW5hcnknLCAnYmFzZTY0J10uaW5kZXhPZihlbmMpID09PSAtMSkpIHtcbiAgICBnZW5jID0gZ2VuZXJhdG9yO1xuICAgIGdlbmVyYXRvciA9IGVuYztcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBlbmMgPSBlbmMgfHwgJ2JpbmFyeSc7XG4gIGdlbmMgPSBnZW5jIHx8ICdiaW5hcnknO1xuICBnZW5lcmF0b3IgPSBnZW5lcmF0b3IgfHwgbmV3IEJ1ZmZlcihbMl0pO1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbmVyYXRvcikpIHtcbiAgICBnZW5lcmF0b3IgPSBuZXcgQnVmZmVyKGdlbmVyYXRvciwgZ2VuYyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByaW1lID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgREgoZ2VuZXJhdGVQcmltZShwcmltZSwgZ2VuZXJhdG9yKSwgZ2VuZXJhdG9yLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaW1lKSkge1xuICAgIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZSwgZW5jKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbmVyYXRvciwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmdldERpZmZpZUhlbGxtYW4gPSBnZXREaWZmaWVIZWxsbWFuO1xuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZXhwb3J0cy5EaWZmaWVIZWxsbWFuID0gY3JlYXRlRGlmZmllSGVsbG1hbjtcbiJdfQ==
},{"./lib/dh":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/dh.js","./lib/generatePrime":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/generatePrime.js","./lib/primes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/primes.json","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/primes.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/dh.js":[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;
  
  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;
    
    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      } 
      break;
    default: 
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function defineError (self, error) {
  try {
    Object.defineProperty(self, 'verifyError', {
      enumerable: true,
      value: error,
      writable: false
    });
  } catch(e) {
    self.verifyError = error;
  }
}
function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = void 0;
  this._priv = void 0;
  
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
    defineError(this, checkPrime(this.__prime, generator));
  } else {
    defineError(this, 8);
  }
}

DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2RoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG4gIFxuICBpZiAocHJpbWUuaXNFdmVuKCkgfHxcbiAgICAhcHJpbWVzLnNpbXBsZVNpZXZlIHx8XG4gICAgIXByaW1lcy5mZXJtYXRUZXN0KHByaW1lKSB8fFxuICAgICFtaWxsZXJSYWJpbi50ZXN0KHByaW1lKSkge1xuICAgIC8vbm90IGEgcHJpbWUgc28gKzFcbiAgICBlcnJvciArPSAxO1xuICAgIFxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfSBcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IFxuICAgICAgZXJyb3IgKz0gNDtcbiAgfVxuICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVFcnJvciAoc2VsZiwgZXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ3ZlcmlmeUVycm9yJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBlcnJvcixcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZWxmLnZlcmlmeUVycm9yID0gZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIERIKHByaW1lLCBnZW5lcmF0b3IsIG1hbGxlYWJsZSkge1xuICB0aGlzLnNldEdlbmVyYXRvcihnZW5lcmF0b3IpO1xuICB0aGlzLl9fcHJpbWUgPSBuZXcgQk4ocHJpbWUpO1xuICB0aGlzLl9wcmltZSA9IEJOLm1vbnQodGhpcy5fX3ByaW1lKTtcbiAgdGhpcy5fcHJpbWVMZW4gPSBwcmltZS5sZW5ndGg7XG4gIHRoaXMuX3B1YiA9IHZvaWQgMDtcbiAgdGhpcy5fcHJpdiA9IHZvaWQgMDtcbiAgXG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICAgIGRlZmluZUVycm9yKHRoaXMsIGNoZWNrUHJpbWUodGhpcy5fX3ByaW1lLCBnZW5lcmF0b3IpKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVFcnJvcih0aGlzLCA4KTtcbiAgfVxufVxuXG5ESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3ByaXYpIHtcbiAgICB0aGlzLl9wcml2ID0gbmV3IEJOKHJhbmRvbUJ5dGVzKHRoaXMuX3ByaW1lTGVuKSk7XG4gIH1cbiAgdGhpcy5fcHViID0gdGhpcy5fZ2VuLnRvUmVkKHRoaXMuX3ByaW1lKS5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoKTtcbn07XG5cbkRILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIG90aGVyID0gbmV3IEJOKG90aGVyKTtcbiAgb3RoZXIgPSBvdGhlci50b1JlZCh0aGlzLl9wcmltZSk7XG4gIHZhciBzZWNyZXQgPSBvdGhlci5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihzZWNyZXQudG9BcnJheSgpKTtcbiAgdmFyIHByaW1lID0gdGhpcy5nZXRQcmltZSgpO1xuICBpZiAob3V0Lmxlbmd0aCA8IHByaW1lLmxlbmd0aCkge1xuICAgIHZhciBmcm9udCA9IG5ldyBCdWZmZXIocHJpbWUubGVuZ3RoIC0gb3V0Lmxlbmd0aCk7XG4gICAgZnJvbnQuZmlsbCgwKTtcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtmcm9udCwgb3V0XSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wdWIsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIGdldFByaXZhdGVLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wcml2LCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaW1lID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fX3ByaW1lLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX2dlbiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5zZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZ2VuLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuKSkge1xuICAgIGdlbiA9IG5ldyBCdWZmZXIoZ2VuLCBlbmMpO1xuICB9XG4gIHRoaXMuX2dlbiA9IG5ldyBCTihnZW4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4udG9BcnJheSgpKTtcbiAgaWYgKCFlbmMpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcbiAgfVxufSJdfQ==
},{"./generatePrime":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/generatePrime.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","miller-rabin":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/miller-rabin/lib/mr.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/lib/generatePrime.js":[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);
  var runs, comp;
  function generateRandom(bits) {
    runs = -1;
    var out = new BN(randomBytes(Math.ceil(bits / 8)));
    while (out.bitLength() > bits) {
      out.ishrn(1);
    }
    if (out.isEven()) {
      out.iadd(ONE);
    }
    if (!out.testn(1)) {
      out.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (out.mod(TWENTYFOUR).cmp(ELEVEN)) {
        out.iadd(FOUR);
      }
      comp = {
        major: [TWENTYFOUR],
        minor: [TWELVE]
      };
    } else if (!gen.cmp(FIVE)) {
      rem = out.mod(TEN);
      while (rem.cmp(THREE)) {
        out.iadd(FOUR);
        rem = out.mod(TEN);
      }
      comp = {
        major: [FOUR, SIXTEEN],
        minor: [TWO, EIGHT]
      };
    } else {
      comp = {
        major: [FOUR],
        minor: [TWO]
      };
    }
    return out;
  }
  var num = generateRandom(bits);

  var n2 = num.shrn(1);

  while (true) {
    while (num.bitLength() > bits) {
      num = generateRandom(bits);
      n2 = num.shrn(1);
    }
    runs++;
    if (simpleSieve(n2) &&  simpleSieve(num) &&
      fermatTest(n2) &&  fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
    num.iadd(comp.major[runs%comp.major.length]);
    n2.iadd(comp.minor[runs%comp.minor.length]);
  }

}
},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js","miller-rabin":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/miller-rabin/lib/mr.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/miller-rabin/lib/mr.js":[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js","brorand":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/miller-rabin/node_modules/brorand/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/miller-rabin/node_modules/brorand/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/brorand/index.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/index.js":[function(require,module,exports){
var createECDH = require('crypto').createECDH;

module.exports = createECDH || require('./browser');
},{"./browser":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/browser.js","crypto":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/browser.js":[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic');
var BN = require('bn.js');

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRUNESChjdXJ2ZSkge1xuXHRyZXR1cm4gbmV3IEVDREgoY3VydmUpO1xufTtcblxudmFyIGFsaWFzZXMgPSB7XG5cdHNlY3AyNTZrMToge1xuXHRcdG5hbWU6ICdzZWNwMjU2azEnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHNlY3AyMjRyMToge1xuXHRcdG5hbWU6ICdwMjI0Jyxcblx0XHRieXRlTGVuZ3RoOiAyOFxuXHR9LFxuXHRwcmltZTI1NnYxOiB7XG5cdFx0bmFtZTogJ3AyNTYnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHByaW1lMTkydjE6IHtcblx0XHRuYW1lOiAncDE5MicsXG5cdFx0Ynl0ZUxlbmd0aDogMjRcblx0fSxcblx0ZWQyNTUxOToge1xuXHRcdG5hbWU6ICdlZDI1NTE5Jyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9XG59O1xuXG5hbGlhc2VzLnAyMjQgPSBhbGlhc2VzLnNlY3AyMjRyMTtcbmFsaWFzZXMucDI1NiA9IGFsaWFzZXMuc2VjcDI1NnIxID0gYWxpYXNlcy5wcmltZTI1NnYxO1xuYWxpYXNlcy5wMTkyID0gYWxpYXNlcy5zZWNwMTkycjEgPSBhbGlhc2VzLnByaW1lMTkydjE7XG5cbmZ1bmN0aW9uIEVDREgoY3VydmUpIHtcblx0dGhpcy5jdXJ2ZVR5cGUgPSBhbGlhc2VzW2N1cnZlXTtcblx0aWYgKCF0aGlzLmN1cnZlVHlwZSApIHtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHtcblx0XHRcdG5hbWU6IGN1cnZlXG5cdFx0fTtcblx0fVxuXHR0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmVjKHRoaXMuY3VydmVUeXBlLm5hbWUpO1xuXHR0aGlzLmtleXMgPSB2b2lkIDA7XG59XG5cbkVDREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuXHR0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKTtcblx0cmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KGVuYywgZm9ybWF0KTtcbn07XG5cbkVDREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIsIGluZW5jLCBlbmMpIHtcblx0aW5lbmMgPSBpbmVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuXHRcdG90aGVyID0gbmV3IEJ1ZmZlcihvdGhlciwgaW5lbmMpO1xuXHR9XG5cdHZhciBvdGhlclB1YiA9IHRoaXMuY3VydmUua2V5RnJvbVB1YmxpYyhvdGhlcikuZ2V0UHVibGljKCk7XG5cdHZhciBvdXQgPSBvdGhlclB1Yi5tdWwodGhpcy5rZXlzLmdldFByaXZhdGUoKSkuZ2V0WCgpO1xuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUob3V0LCBlbmMsIHRoaXMuY3VydmVUeXBlLmJ5dGVMZW5ndGgpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG5cdHZhciBrZXkgPSB0aGlzLmtleXMuZ2V0UHVibGljKGZvcm1hdCA9PT0gJ2NvbXByZXNzZWQnLCB0cnVlKTtcblx0aWYgKGZvcm1hdCA9PT0gJ2h5YnJpZCcpIHtcblx0XHRpZiAoa2V5W2tleS5sZW5ndGggLSAxXSAlIDIpIHtcblx0XHRcdGtleVswXSA9IDc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleSBbMF0gPSA2O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoa2V5LCBlbmMpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChlbmMpIHtcblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMua2V5cy5nZXRQcml2YXRlKCksIGVuYyk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuXHRcdHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpO1xuXHR9XG5cdHRoaXMua2V5cy5faW1wb3J0UHVibGljKHB1Yik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuRUNESC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2LCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcblx0XHRwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpO1xuXHR9XG5cdHZhciBfcHJpdiA9IG5ldyBCTihwcml2KTtcblx0X3ByaXYgPSBfcHJpdi50b1N0cmluZygxNik7XG5cdHRoaXMua2V5cy5faW1wb3J0UHJpdmF0ZShfcHJpdik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYywgbGVuKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShibikpIHtcblx0XHRibiA9IGJuLnRvQXJyYXkoKTtcblx0fVxuXHR2YXIgYnVmID0gbmV3IEJ1ZmZlcihibik7XG5cdGlmIChsZW4gJiYgYnVmLmxlbmd0aCA8IGxlbikge1xuXHRcdHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIobGVuIC0gYnVmLmxlbmd0aCk7XG5cdFx0emVyb3MuZmlsbCgwKTtcblx0XHRidWYgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgYnVmXSk7XG5cdH1cblx0aWYgKCFlbmMpIHtcblx0XHRyZXR1cm4gYnVmO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcblx0fVxufVxuIl19
},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js"][0].apply(exports,arguments)
},{"../package.json":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/package.json","./elliptic/curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/index.js","./elliptic/curves":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curves.js","./elliptic/ec":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/index.js","./elliptic/hmac-drbg":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/hmac-drbg.js","./elliptic/utils":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/utils.js","brorand":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/brorand/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/package.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/package.json"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/brorand/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/brorand/index.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/utils.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/utils.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/hmac-drbg.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/hmac-drbg.js"][0].apply(exports,arguments)
},{"../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","hash.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/index.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","./key":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/key.js","./signature":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/signature.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/signature.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/signature.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/ec/key.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/key.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curves.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curves.js"][0].apply(exports,arguments)
},{"../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","./precomputed/secp256k1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js","hash.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"][0].apply(exports,arguments)
},{"./hash/common":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js","./hash/hmac":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js","./hash/ripemd":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js","./hash/sha":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js","./hash/utils":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js"][0].apply(exports,arguments)
},{"inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js"][0].apply(exports,arguments)
},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js"][0].apply(exports,arguments)
},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js"][0].apply(exports,arguments)
},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js"][0].apply(exports,arguments)
},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/index.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js"][0].apply(exports,arguments)
},{"./base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/base.js","./edwards":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/edwards.js","./mont":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/mont.js","./short":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/short.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/short.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/short.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/mont.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/mont.js"][0].apply(exports,arguments)
},{"../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/edwards.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/edwards.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic/curve/base.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/base.js"][0].apply(exports,arguments)
},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-ecdh/node_modules/bn.js/lib/bn.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/browser.js":[function(require,module,exports){
(function (Buffer){
'use strict'
var sign = require('./sign')
var verify = require('./verify')
var stream = require('stream')
var inherits = require('inherits')
var _algos = require('./algos')
var createHash = require('create-hash')
var algos = {}
Object.keys(_algos).forEach(function (key) {
  algos[key] = algos[key.toLowerCase()] = _algos[key]
})

exports.createSign = exports.Sign = createSign

function createSign (algorithm) {
  return new Sign(algorithm)
}

exports.createVerify = exports.Verify = createVerify

function createVerify (algorithm) {
  return new Verify(algorithm)
}

inherits(Sign, stream.Writable)

function Sign (algorithm) {
  stream.Writable.call(this)
  var data = algos[algorithm]
  if (!data)
    throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string')
    data = new Buffer(data, enc)
  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)
  if (enc) {
    sig = sig.toString(enc)
  }
  return sig
}

inherits(Verify, stream.Writable)
function Verify (algorithm) {
  stream.Writable.call(this)
  var data = algos[algorithm]
  if (!data)
    throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string')
    data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  this.end()
  var hash = this._hash.digest()
  if (typeof sig === 'string')
    sig = new Buffer(sig, enc)

  return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbnZhciBzaWduID0gcmVxdWlyZSgnLi9zaWduJylcbnZhciB2ZXJpZnkgPSByZXF1aXJlKCcuL3ZlcmlmeScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBfYWxnb3MgPSByZXF1aXJlKCcuL2FsZ29zJylcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIGFsZ29zID0ge31cbk9iamVjdC5rZXlzKF9hbGdvcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGFsZ29zW2tleV0gPSBhbGdvc1trZXkudG9Mb3dlckNhc2UoKV0gPSBfYWxnb3Nba2V5XVxufSlcblxuZXhwb3J0cy5jcmVhdGVTaWduID0gZXhwb3J0cy5TaWduID0gY3JlYXRlU2lnblxuXG5mdW5jdGlvbiBjcmVhdGVTaWduIChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBTaWduKGFsZ29yaXRobSlcbn1cblxuZXhwb3J0cy5jcmVhdGVWZXJpZnkgPSBleHBvcnRzLlZlcmlmeSA9IGNyZWF0ZVZlcmlmeVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbmluaGVyaXRzKFNpZ24sIHN0cmVhbS5Xcml0YWJsZSlcblxuZnVuY3Rpb24gU2lnbiAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG4gIHZhciBkYXRhID0gYWxnb3NbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoVHlwZSA9IGRhdGEuaGFzaFxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cblxuU2lnbi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChkYXRhLCBfLCBkb25lKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIGRvbmUoKVxufVxuXG5TaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuU2lnbi5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ25NZXRob2QgKGtleSwgZW5jKSB7XG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBzaWcgPSBzaWduKEJ1ZmZlci5jb25jYXQoW3RoaXMuX3RhZywgaGFzaF0pLCBrZXksIHRoaXMuX2hhc2hUeXBlLCB0aGlzLl9zaWduVHlwZSlcbiAgaWYgKGVuYykge1xuICAgIHNpZyA9IHNpZy50b1N0cmluZyhlbmMpXG4gIH1cbiAgcmV0dXJuIHNpZ1xufVxuXG5pbmhlcml0cyhWZXJpZnksIHN0cmVhbS5Xcml0YWJsZSlcbmZ1bmN0aW9uIFZlcmlmeSAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG4gIHZhciBkYXRhID0gYWxnb3NbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cblxuVmVyaWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblZlcmlmeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKVxuICAgIHNpZyA9IG5ldyBCdWZmZXIoc2lnLCBlbmMpXG5cbiAgcmV0dXJuIHZlcmlmeShzaWcsIEJ1ZmZlci5jb25jYXQoW3RoaXMuX3RhZywgaGFzaF0pLCBrZXksIHRoaXMuX3NpZ25UeXBlKVxufVxuIl19
},{"./algos":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/algos.js","./sign":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/sign.js","./verify":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/verify.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/verify.js":[function(require,module,exports){
(function (Buffer){
'use strict'
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var parseKeys = require('parse-asn1')
var elliptic = require('elliptic')
var curves = require('./curves')
var BN = require('bn.js')
module.exports = verify

function verify (sig, hash, key, signType) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    if (signType !== 'ecdsa') {
      throw new Error('wrong public key type')
    }
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong public key type')
    }
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa') {
      throw new Error('wrong public key type')
    }
  }
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))

  sig = new Buffer(sig.fromRed().toArray())
  var out = 0
  if (padNum < 8) {
    out = 1
  }
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) {
    out = 1
  }

  i = -1
  while (++i < len) {
    out |= (sig[i] ^ pad[i])
  }
  return out === 0
}
function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId)
    throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new elliptic.ec(curveId)

  var pubkey = pub.data.subjectPrivateKey.data
  return curve.verify(hash, sig, pubkey)
}
function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montq = BN.mont(q)
  var montp = BN.mont(p)
  var w =  s.invm(q)
  var v = g.toRed(montp)
  .redPow(new BN(hash).mul(w).mod(q))
  .fromRed()
  .mul(
    y.toRed(montp)
    .redPow(r.mul(w).mod(q))
    .fromRed()
  ).mod(p).mod(q)
  return !v.cmp(r)
}
function checkValue (b, q) {
  if (b.cmpn(0) <= 0) {
    throw new Error('invalid sig')
  }
  if (b.cmp(q) >= q) {
    throw new Error('invalid sig')
  }
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL3ZlcmlmeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZnlcblxuZnVuY3Rpb24gdmVyaWZ5IChzaWcsIGhhc2gsIGtleSwgc2lnblR5cGUpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgICByZXR1cm4gZWNWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSBpZiAocHViLnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHB1Yi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAxIF1cbiAgdmFyIHBhZE51bSA9IDBcbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDIgPCBsZW4pIHtcbiAgICBwYWQucHVzaCgweGZmKVxuICAgIHBhZE51bSsrXG4gIH1cbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHtcbiAgICBwYWQucHVzaChoYXNoW2ldKVxuICB9XG4gIHBhZCA9IG5ldyBCdWZmZXIocGFkKVxuICB2YXIgcmVkID0gQk4ubW9udChwdWIubW9kdWx1cylcbiAgc2lnID0gbmV3IEJOKHNpZykudG9SZWQocmVkKVxuXG4gIHNpZyA9IHNpZy5yZWRQb3cobmV3IEJOKHB1Yi5wdWJsaWNFeHBvbmVudCkpXG5cbiAgc2lnID0gbmV3IEJ1ZmZlcihzaWcuZnJvbVJlZCgpLnRvQXJyYXkoKSlcbiAgdmFyIG91dCA9IDBcbiAgaWYgKHBhZE51bSA8IDgpIHtcbiAgICBvdXQgPSAxXG4gIH1cbiAgbGVuID0gTWF0aC5taW4oc2lnLmxlbmd0aCwgcGFkLmxlbmd0aClcbiAgaWYgKHNpZy5sZW5ndGggIT09IHBhZC5sZW5ndGgpIHtcbiAgICBvdXQgPSAxXG4gIH1cblxuICBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dCB8PSAoc2lnW2ldIF4gcGFkW2ldKVxuICB9XG4gIHJldHVybiBvdXQgPT09IDBcbn1cbmZ1bmN0aW9uIGVjVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBlbGxpcHRpYy5lYyhjdXJ2ZUlkKVxuXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG4gIHJldHVybiBjdXJ2ZS52ZXJpZnkoaGFzaCwgc2lnLCBwdWJrZXkpXG59XG5mdW5jdGlvbiBkc2FWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBwID0gcHViLmRhdGEucFxuICB2YXIgcSA9IHB1Yi5kYXRhLnFcbiAgdmFyIGcgPSBwdWIuZGF0YS5nXG4gIHZhciB5ID0gcHViLmRhdGEucHViX2tleVxuICB2YXIgdW5wYWNrZWQgPSBwYXJzZUtleXMuc2lnbmF0dXJlLmRlY29kZShzaWcsICdkZXInKVxuICB2YXIgcyA9IHVucGFja2VkLnNcbiAgdmFyIHIgPSB1bnBhY2tlZC5yXG4gIGNoZWNrVmFsdWUocywgcSlcbiAgY2hlY2tWYWx1ZShyLCBxKVxuICB2YXIgbW9udHEgPSBCTi5tb250KHEpXG4gIHZhciBtb250cCA9IEJOLm1vbnQocClcbiAgdmFyIHcgPSAgcy5pbnZtKHEpXG4gIHZhciB2ID0gZy50b1JlZChtb250cClcbiAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgLmZyb21SZWQoKVxuICAubXVsKFxuICAgIHkudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhyLm11bCh3KS5tb2QocSkpXG4gICAgLmZyb21SZWQoKVxuICApLm1vZChwKS5tb2QocSlcbiAgcmV0dXJuICF2LmNtcChyKVxufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZSAoYiwgcSkge1xuICBpZiAoYi5jbXBuKDApIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgfVxuICBpZiAoYi5jbXAocSkgPj0gcSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxuICB9XG59XG4iXX0=
},{"./curves":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/curves.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","parse-asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/sign.js":[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var parseKeys = require('parse-asn1')
var BN = require('bn.js')
var elliptic = require('elliptic')
var crt = require('browserify-rsa')
var createHmac = require('create-hmac')
var curves = require('./curves')

module.exports = sign
function sign (hash, key, hashType, signType) {
  var priv = parseKeys(key)
  if (priv.curve) {
    if (signType !== 'ecdsa') {
      throw new Error('wrong private key type')
    }
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    return dsaSign(hash, priv, hashType)
    if (signType !== 'dsa') {
      throw new Error('wrong private key type')
    }
  } else {
    if (signType !== 'rsa') {
      throw new Error('wrong private key type')
    }
  }
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff)
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }

  var out = crt(pad, priv)
  return out
}
function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId)
    throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new elliptic.ec(curveId)

  var key = curve.genKeyPair()
  key._importPrivate(priv.privateKey)
  var out = key.sign(hash)
  return new Buffer(out.toDER())
}
function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var montq = BN.mont(q)
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (!s.cmpn(0)) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}
function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r)
  // Pad values
  if (s[0] & 0x80)
    s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}
module.exports.getKey = getKey
function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([0]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([1]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  return {
    k: k,
    v: v
  }
}
function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) {
    bits.ishrn(shift)
  }
  return bits
}
function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([zeros, out])
  }
  return out
}
module.exports.makeKey = makeKey
function makeKey (q, kv, algo) {
  var t
  var k
  while (true) {
    t = new Buffer('')
    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
      t = Buffer.concat([t, kv.v])
    }
    k = bits2int(t, q)
    kv.k =  createHmac(algo, kv.k)
        .update(kv.v)
        .update(new Buffer([0]))
        .digest()
    kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
    if (k.cmp(q) === -1) {
      return k
    }
  }
}
function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL3NpZ24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpZ25cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIGtleSwgaGFzaFR5cGUsIHNpZ25UeXBlKSB7XG4gIHZhciBwcml2ID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHByaXYuY3VydmUpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBlY1NpZ24oaGFzaCwgcHJpdilcbiAgfSBlbHNlIGlmIChwcml2LnR5cGUgPT09ICdkc2EnKSB7XG4gICAgcmV0dXJuIGRzYVNpZ24oaGFzaCwgcHJpdiwgaGFzaFR5cGUpXG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMCwgMSBdXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAxIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgfVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkge1xuICAgIHBhZC5wdXNoKGhhc2hbaV0pXG4gIH1cblxuICB2YXIgb3V0ID0gY3J0KHBhZCwgcHJpdilcbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gZWNTaWduIChoYXNoLCBwcml2KSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3ByaXYuY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwcml2LmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgZWxsaXB0aWMuZWMoY3VydmVJZClcblxuICB2YXIga2V5ID0gY3VydmUuZ2VuS2V5UGFpcigpXG4gIGtleS5faW1wb3J0UHJpdmF0ZShwcml2LnByaXZhdGVLZXkpXG4gIHZhciBvdXQgPSBrZXkuc2lnbihoYXNoKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cbmZ1bmN0aW9uIGRzYVNpZ24gKGhhc2gsIHByaXYsIGFsZ28pIHtcbiAgdmFyIHggPSBwcml2LnBhcmFtcy5wcml2X2tleVxuICB2YXIgcCA9IHByaXYucGFyYW1zLnBcbiAgdmFyIHEgPSBwcml2LnBhcmFtcy5xXG4gIHZhciBtb250cSA9IEJOLm1vbnQocSlcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmICghcy5jbXBuKDApKSB7XG4gICAgICBzID0gZmFsc2VcbiAgICAgIHIgPSBuZXcgQk4oMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvREVSKHIsIHMpXG59XG5mdW5jdGlvbiB0b0RFUiAociwgcykge1xuICByID0gci50b0FycmF5KClcbiAgcyA9IHMudG9BcnJheSgpXG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKVxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWzBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgeF0pXG4gIH1cbiAgdmFyIGhsZW4gPSBoYXNoLmxlbmd0aFxuICB2YXIgaGJpdHMgPSBiaXRzMm9jdGV0cyhoYXNoLCBxKVxuICB2YXIgdiA9IG5ldyBCdWZmZXIoaGxlbilcbiAgdi5maWxsKDEpXG4gIHZhciBrID0gbmV3IEJ1ZmZlcihobGVuKVxuICBrLmZpbGwoMClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShuZXcgQnVmZmVyKFswXSkpXG4gICAgLnVwZGF0ZSh4KVxuICAgIC51cGRhdGUoaGJpdHMpXG4gICAgLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC5kaWdlc3QoKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAudXBkYXRlKG5ldyBCdWZmZXIoWzFdKSlcbiAgICAudXBkYXRlKHgpXG4gICAgLnVwZGF0ZShoYml0cylcbiAgICAuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLmRpZ2VzdCgpXG4gIHJldHVybiB7XG4gICAgazogayxcbiAgICB2OiB2XG4gIH1cbn1cbmZ1bmN0aW9uIGJpdHMyaW50IChvYml0cywgcSkge1xuICB2YXIgYml0cyA9IG5ldyBCTihvYml0cylcbiAgdmFyIHNoaWZ0ID0gKG9iaXRzLmxlbmd0aCA8PCAzKSAtIHEuYml0TGVuZ3RoKClcbiAgaWYgKHNoaWZ0ID4gMCkge1xuICAgIGJpdHMuaXNocm4oc2hpZnQpXG4gIH1cbiAgcmV0dXJuIGJpdHNcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIG91dF0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxubW9kdWxlLmV4cG9ydHMubWFrZUtleSA9IG1ha2VLZXlcbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdCA9IG5ldyBCdWZmZXIoJycpXG4gICAgd2hpbGUgKHQubGVuZ3RoICogOCA8IHEuYml0TGVuZ3RoKCkpIHtcbiAgICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspXG4gICAgICAgIC51cGRhdGUoa3YudilcbiAgICAgICAgLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwga3Yudl0pXG4gICAgfVxuICAgIGsgPSBiaXRzMmludCh0LCBxKVxuICAgIGt2LmsgPSAgY3JlYXRlSG1hYyhhbGdvLCBrdi5rKVxuICAgICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAgIC51cGRhdGUobmV3IEJ1ZmZlcihbMF0pKVxuICAgICAgICAuZGlnZXN0KClcbiAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKVxuICAgICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAgIC5kaWdlc3QoKVxuICAgIGlmIChrLmNtcChxKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBrXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYWtlUiAoZywgaywgcCwgcSkge1xuICByZXR1cm4gZy50b1JlZChCTi5tb250KHApKS5yZWRQb3coaykuZnJvbVJlZCgpLm1vZChxKVxufVxuIl19
},{"./curves":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/curves.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","browserify-rsa":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/browserify-rsa/index.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hmac":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js","elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","parse-asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/index.js":[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
var ciphers = require('browserify-aes');
var compat = require('pbkdf2');
module.exports = parseKeys;

function parseKeys(buffer) {
  var password;
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer);
  }

  var stripped = fixProc(buffer, password);

  var type = stripped.tag;
  var data = stripped.data;
  var subtype,ndata;
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
        case '1.2.840.10045.2.1':
        ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: 'ec',
            data:  ndata
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(data, password);
      //falling through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default: throw new Error('unknown key type ' +  type);
  }
}
parseKeys.signature = asn1.signature;
function decrypt(data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10)/8;
  var key = compat.pbkdf2Sync(password, salt, iters, keylen);
  var cipher = ciphers.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer.concat(out);
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc24xID0gcmVxdWlyZSgnLi9hc24xJyk7XG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKTtcbnZhciBmaXhQcm9jID0gcmVxdWlyZSgnLi9maXhQcm9jJyk7XG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJyk7XG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlS2V5cztcblxuZnVuY3Rpb24gcGFyc2VLZXlzKGJ1ZmZlcikge1xuICB2YXIgcGFzc3dvcmQ7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnb2JqZWN0JyAmJiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBwYXNzd29yZCA9IGJ1ZmZlci5wYXNzcGhyYXNlO1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXk7XG4gIH1cbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICB9XG5cbiAgdmFyIHN0cmlwcGVkID0gZml4UHJvYyhidWZmZXIsIHBhc3N3b3JkKTtcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZztcbiAgdmFyIGRhdGEgPSBzdHJpcHBlZC5kYXRhO1xuICB2YXIgc3VidHlwZSxuZGF0YTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUFVCTElDIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJyk7XG4gICAgICBzd2l0Y2goc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKTtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICBuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSA9IG5kYXRhLnN1YmplY3RQdWJsaWNLZXk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlYycsXG4gICAgICAgICAgICBkYXRhOiAgbmRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wdWJfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArICBzdWJ0eXBlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgIHR5cGUpO1xuICAgIGNhc2UgJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FbmNyeXB0ZWRQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICBkYXRhID0gZGVjcnlwdChkYXRhLCBwYXNzd29yZCk7XG4gICAgICAvL2ZhbGxpbmcgdGhyb3VnaFxuICAgIGNhc2UgJ1BSSVZBVEUgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5Qcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJyk7XG4gICAgICBzd2l0Y2goc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKTtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJ2ZTogbmRhdGEuYWxnb3JpdGhtLmN1cnZlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJykucHJpdmF0ZUtleVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnByaXZfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBwYXJhbXM6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyAgc3VidHlwZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArICB0eXBlKTtcbiAgICBjYXNlICdSU0EgUFVCTElDIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICBjYXNlICdSU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgIGNhc2UgJ0RTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgcGFyYW1zOiBhc24xLkRTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfTtcbiAgICBjYXNlICdFQyBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlOiBkYXRhLnBhcmFtZXRlcnMudmFsdWUsXG4gICAgICAgIHByaXZhdGVLZXk6IGRhdGEucHJpdmF0ZUtleVxuICAgICAgfTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArICB0eXBlKTtcbiAgfVxufVxucGFyc2VLZXlzLnNpZ25hdHVyZSA9IGFzbjEuc2lnbmF0dXJlO1xuZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBwYXNzd29yZCkge1xuICB2YXIgc2FsdCA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5zYWx0O1xuICB2YXIgaXRlcnMgPSBwYXJzZUludChkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuaXRlcnMudG9TdHJpbmcoKSwgMTApO1xuICB2YXIgYWxnbyA9IGFlc2lkW2RhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLmFsZ28uam9pbignLicpXTtcbiAgdmFyIGl2ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuaXY7XG4gIHZhciBjaXBoZXJUZXh0ID0gZGF0YS5zdWJqZWN0UHJpdmF0ZUtleTtcbiAgdmFyIGtleWxlbiA9IHBhcnNlSW50KGFsZ28uc3BsaXQoJy0nKVsxXSwgMTApLzg7XG4gIHZhciBrZXkgPSBjb21wYXQucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcnMsIGtleWxlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoYWxnbywga2V5LCBpdik7XG4gIHZhciBvdXQgPSBbXTtcbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSk7XG4gIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KTtcbn1cbiJdfQ==
},{"./aesid.json":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/aesid.json","./asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/asn1.js","./fixProc":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/fixProc.js","browserify-aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","pbkdf2":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/pbkdf2/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/pbkdf2/browser.js":[function(require,module,exports){
(function (Buffer){
var createHmac = require('create-hmac')
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

exports.pbkdf2 = pbkdf2
function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  if (typeof callback !== 'function') {
    throw new Error('No callback provided to pbkdf2')
  }

  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
  setTimeout(function () {
    callback(undefined, result)
  })
}

exports.pbkdf2Sync = pbkdf2Sync
function pbkdf2Sync (password, salt, iterations, keylen, digest) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError('Bad key length')
  }

  digest = digest || 'sha1'

  if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()

      for (var k = 0; k < hLen; k++) {
        T[k] ^= U[k]
      }
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGJrZGYyL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgTUFYX0FMTE9DID0gTWF0aC5wb3coMiwgMzApIC0gMSAvLyBkZWZhdWx0IGluIGlvanNcblxuZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjJcbmZ1bmN0aW9uIHBia2RmMiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRpZ2VzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZGlnZXN0XG4gICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYWxsYmFjayBwcm92aWRlZCB0byBwYmtkZjInKVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlc3VsdClcbiAgfSlcbn1cblxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcGJrZGYyU3luY1xuZnVuY3Rpb24gcGJrZGYyU3luYyAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVyYXRpb25zIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXRlcmF0aW9ucyA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgaXRlcmF0aW9ucycpXG4gIH1cblxuICBpZiAodHlwZW9mIGtleWxlbiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLZXkgbGVuZ3RoIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoa2V5bGVuIDwgMCB8fCBrZXlsZW4gPiBNQVhfQUxMT0MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQsICdiaW5hcnknKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgJ2JpbmFyeScpXG5cbiAgdmFyIGhMZW5cbiAgdmFyIGwgPSAxXG4gIHZhciBESyA9IG5ldyBCdWZmZXIoa2V5bGVuKVxuICB2YXIgYmxvY2sxID0gbmV3IEJ1ZmZlcihzYWx0Lmxlbmd0aCArIDQpXG4gIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciByXG4gIHZhciBUXG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG4gICAgYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG4gICAgdmFyIFUgPSBjcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpXG5cbiAgICBpZiAoIWhMZW4pIHtcbiAgICAgIGhMZW4gPSBVLmxlbmd0aFxuICAgICAgVCA9IG5ldyBCdWZmZXIoaExlbilcbiAgICAgIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcbiAgICAgIHIgPSBrZXlsZW4gLSAobCAtIDEpICogaExlblxuICAgIH1cblxuICAgIFUuY29weShULCAwLCAwLCBoTGVuKVxuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgIFUgPSBjcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShVKS5kaWdlc3QoKVxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKykge1xuICAgICAgICBUW2tdIF49IFVba11cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgdmFyIGxlbiA9IChpID09PSBsID8gciA6IGhMZW4pXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gIH1cblxuICByZXR1cm4gREtcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hmac":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js":[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)

  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL2Jyb3dzZXInKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxuXG52YXIgWkVST1MgPSBuZXcgQnVmZmVyKDEyOClcblpFUk9TLmZpbGwoMClcblxuZnVuY3Rpb24gSG1hYyhhbGcsIGtleSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICB9XG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGtleSkuZGlnZXN0KClcblxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShpcGFkKVxufVxuXG5pbmhlcml0cyhIbWFjLCBUcmFuc2Zvcm0pXG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhtYWMucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcblxuICBuZXh0KClcbn1cblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcblxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjKGFsZywga2V5KSB7XG4gIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash/browser":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/fixProc.js":[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
var startRegex =/^-----BEGIN (.*) KEY-----\r?\n/m;
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
var evp = require('./EVP_BytesToKey');
var ciphers = require('browserify-aes');
module.exports = function (okey, password) {
  var key = okey.toString();
  var match = key.match(findProc);
  var decrypted;
  if (!match) {
    var match2 = key.match(fullRegex);
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
  } else {
    var suite = 'aes' + match[1];
    var iv = new Buffer(match[2], 'hex');
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
    var cipherKey = evp(password, iv.slice(0,8), parseInt(match[1]));
    var out = [];
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer.concat(out);
  }
  var tag = key.match(startRegex)[1] + ' KEY';
  return {
    tag: tag,
    data: decrypted
  };
};

// http://stackoverflow.com/a/7033705
function wrap (str) {
  var chunks = []

  for (var i = 0; i < str.length; i += 64) {
    chunks.push(str.slice(i, i + 64))
  }
  return chunks.join("\n")
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2ZpeFByb2MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXBhdGlsL3BlbXN0cmlwXG52YXIgZmluZFByb2MgPSAvUHJvYy1UeXBlOiA0LEVOQ1JZUFRFRFxccj9cXG5ERUstSW5mbzogQUVTLSgoPzoxMjgpfCg/OjE5Mil8KD86MjU2KSktQ0JDLChbMC05QS1IXSspXFxyP1xcblxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4vbTtcbnZhciBzdGFydFJlZ2V4ID0vXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4vbTtcbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4tLS0tLUVORCBcXDEgS0VZLS0tLS0kL207XG52YXIgZXZwID0gcmVxdWlyZSgnLi9FVlBfQnl0ZXNUb0tleScpO1xudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2tleSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleSA9IG9rZXkudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGZpbmRQcm9jKTtcbiAgdmFyIGRlY3J5cHRlZDtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHZhciBtYXRjaDIgPSBrZXkubWF0Y2goZnVsbFJlZ2V4KTtcbiAgICBkZWNyeXB0ZWQgPSBuZXcgQnVmZmVyKG1hdGNoMlsyXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV07XG4gICAgdmFyIGl2ID0gbmV3IEJ1ZmZlcihtYXRjaFsyXSwgJ2hleCcpO1xuICAgIHZhciBjaXBoZXJUZXh0ID0gbmV3IEJ1ZmZlcihtYXRjaFszXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpO1xuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsOCksIHBhcnNlSW50KG1hdGNoWzFdKSk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpO1xuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpO1xuICAgIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKTtcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dCk7XG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXSArICcgS0VZJztcbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBkYXRhOiBkZWNyeXB0ZWRcbiAgfTtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcwMzM3MDVcbmZ1bmN0aW9uIHdyYXAgKHN0cikge1xuICB2YXIgY2h1bmtzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gNjQpIHtcbiAgICBjaHVua3MucHVzaChzdHIuc2xpY2UoaSwgaSArIDY0KSlcbiAgfVxuICByZXR1cm4gY2h1bmtzLmpvaW4oXCJcXG5cIilcbn1cbiJdfQ==
},{"./EVP_BytesToKey":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/EVP_BytesToKey.js","browserify-aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/EVP_BytesToKey.js":[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
module.exports = function evp(password, salt, keyLen) {
  keyLen = keyLen/8;
  var ki = 0;
  var ii = 0;
  var key = new Buffer(keyLen);
  var addmd = 0;
  var md, md_buf;
  var i;
  while (true) {
    md = createHash('md5');
    if(addmd++ > 0) {
       md.update(md_buf);
    }
    md.update(password);
    md.update(salt);
    md_buf = md.digest();
    i = 0;
    if(keyLen > 0) {
      while(true) {
        if(keyLen === 0) {
          break;
        }
        if(i === md_buf.length) {
          break;
        }
        key[ki++] = md_buf[i++];
        keyLen--;
       }
    }
   if(keyLen === 0) {
      break;
    }
  }
  for(i=0;i<md_buf.length;i++) {
    md_buf[i] = 0;
  }
  return key;
};
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL0VWUF9CeXRlc1RvS2V5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXZwKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4pIHtcbiAga2V5TGVuID0ga2V5TGVuLzg7XG4gIHZhciBraSA9IDA7XG4gIHZhciBpaSA9IDA7XG4gIHZhciBrZXkgPSBuZXcgQnVmZmVyKGtleUxlbik7XG4gIHZhciBhZGRtZCA9IDA7XG4gIHZhciBtZCwgbWRfYnVmO1xuICB2YXIgaTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBtZCA9IGNyZWF0ZUhhc2goJ21kNScpO1xuICAgIGlmKGFkZG1kKysgPiAwKSB7XG4gICAgICAgbWQudXBkYXRlKG1kX2J1Zik7XG4gICAgfVxuICAgIG1kLnVwZGF0ZShwYXNzd29yZCk7XG4gICAgbWQudXBkYXRlKHNhbHQpO1xuICAgIG1kX2J1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIGkgPSAwO1xuICAgIGlmKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaWYoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGtleVtraSsrXSA9IG1kX2J1ZltpKytdO1xuICAgICAgICBrZXlMZW4tLTtcbiAgICAgICB9XG4gICAgfVxuICAgaWYoa2V5TGVuID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZm9yKGk9MDtpPG1kX2J1Zi5sZW5ndGg7aSsrKSB7XG4gICAgbWRfYnVmW2ldID0gMDtcbiAgfVxuICByZXR1cm4ga2V5O1xufTsiXX0=
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js":[function(require,module,exports){
(function (Buffer){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Transform = require('stream').Transform

function HashNoConstructor(hash) {
  Transform.call(this)

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Transform)

HashNoConstructor.prototype._transform = function (data, _, next) {
  this.buffers.push(data)

  next()
}

HashNoConstructor.prototype._flush = function (next) {
  this.push(this.digest())
  next()
}

HashNoConstructor.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this.buffers.push(data)
  return this
}

HashNoConstructor.prototype.digest = function (enc) {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return enc ? r.toString(enc) : r
}

function Hash(hash) {
  Transform.call(this)

  this._hash = hash
}

inherits(Hash, Transform)

Hash.prototype._transform = function (data, enc, next) {
  if (enc) data = new Buffer(data, enc)

  this._hash.update(data)

  next()
}

Hash.prototype._flush = function (next) {
  this.push(this._hash.digest())
  this._hash = null

  next()
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Hash.prototype.digest = function (enc) {
  var outData = this._hash.digest()

  return enc ? outData.toString(enc) : outData
}

module.exports = function createHash (alg) {
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxudmFyIHJtZDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxuXG5mdW5jdGlvbiBIYXNoTm9Db25zdHJ1Y3RvcihoYXNoKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbiAgdGhpcy5idWZmZXJzID0gW11cbn1cblxuaW5oZXJpdHMoSGFzaE5vQ29uc3RydWN0b3IsIFRyYW5zZm9ybSlcblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChkYXRhKVxuXG4gIG5leHQoKVxufVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG4gIG5leHQoKVxufVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdGhpcy5idWZmZXJzLnB1c2goZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQodGhpcy5idWZmZXJzKVxuICB2YXIgciA9IHRoaXMuX2hhc2goYnVmKVxuICB0aGlzLmJ1ZmZlcnMgPSBudWxsXG5cbiAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbn1cblxuZnVuY3Rpb24gSGFzaChoYXNoKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgVHJhbnNmb3JtKVxuXG5IYXNoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIGVuYywgbmV4dCkge1xuICBpZiAoZW5jKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcblxuICBuZXh0KClcbn1cblxuSGFzaC5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgdGhpcy5wdXNoKHRoaXMuX2hhc2guZGlnZXN0KCkpXG4gIHRoaXMuX2hhc2ggPSBudWxsXG5cbiAgbmV4dCgpXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgfVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG5cbiAgcmV0dXJuIGVuYyA/IG91dERhdGEudG9TdHJpbmcoZW5jKSA6IG91dERhdGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgaWYgKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3IobWQ1KVxuICBpZiAoJ3JtZDE2MCcgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihybWQxNjApXG5cbiAgcmV0dXJuIG5ldyBIYXNoKHNoYShhbGcpKVxufVxuIl19
},{"./md5":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","ripemd160":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js","sha.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/index.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/index.js":[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha.js","./sha1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha1.js","./sha224":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha224.js","./sha256":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js","./sha384":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha384.js","./sha512":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha384.js":[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._a = 0xcbbb9d5d | 0
  this._b = 0x629a292a | 0
  this._c = 0x9159015a | 0
  this._d = 0x152fecd8 | 0
  this._e = 0x67332667 | 0
  this._f = 0x8eb44a87 | 0
  this._g = 0xdb0c2e0d | 0
  this._h = 0x47b5481d | 0

  this._al = 0xc1059ed8 | 0
  this._bl = 0x367cd507 | 0
  this._cl = 0x3070dd17 | 0
  this._dl = 0xf70e5939 | 0
  this._el = 0xffc00b31 | 0
  this._fl = 0x68581511 | 0
  this._gl = 0x64f98fa7 | 0
  this._hl = 0xbefa4fa4 | 0

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Y2JiYjlkNWQgfCAwXG4gIHRoaXMuX2IgPSAweDYyOWEyOTJhIHwgMFxuICB0aGlzLl9jID0gMHg5MTU5MDE1YSB8IDBcbiAgdGhpcy5fZCA9IDB4MTUyZmVjZDggfCAwXG4gIHRoaXMuX2UgPSAweDY3MzMyNjY3IHwgMFxuICB0aGlzLl9mID0gMHg4ZWI0NGE4NyB8IDBcbiAgdGhpcy5fZyA9IDB4ZGIwYzJlMGQgfCAwXG4gIHRoaXMuX2ggPSAweDQ3YjU0ODFkIHwgMFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOCB8IDBcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3IHwgMFxuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTcgfCAwXG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOSB8IDBcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxIHwgMFxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTEgfCAwXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhNyB8IDBcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2EsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYiwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9lLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiJdfQ==
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","./sha512":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js":[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  this._al = 0xf3bcc908 | 0
  this._bl = 0x84caa73b | 0
  this._cl = 0xfe94f82b | 0
  this._dl = 0x5f1d36f1 | 0
  this._el = 0xade682d1 | 0
  this._fl = 0x2b3e6c1f | 0
  this._gl = 0xfb41bd6b | 0
  this._hl = 0x137e2179 | 0

  return this
}

function S (X, Xl, n) {
  return (X >>> n) | (Xl << (32 - n))
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z))
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z))
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  var i = 0, j = 0
  var Wi, Wil
  function calcW () {
    var x = W[j - 15 * 2]
    var xl = W[j - 15 * 2 + 1]
    var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
    var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

    x = W[j - 2 * 2]
    xl = W[j - 2 * 2 + 1]
    var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
    var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7 = W[j - 7 * 2]
    var Wi7l = W[j - 7 * 2 + 1]

    var Wi16 = W[j - 16 * 2]
    var Wi16l = W[j - 16 * 2 + 1]

    Wil = gamma0l + Wi7l
    Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
    Wil = Wil + gamma1l
    Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
    Wil = Wil + Wi16l
    Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
  }

  function loop () {
    W[j] = Wi
    W[j + 1] = Wil

    var maj = Maj(a, b, c)
    var majl = Maj(al, bl, cl)

    var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
    var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
    var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
    var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

    // t1 = h + sigma1 + ch + K[i] + W[i]
    var Ki = K[j]
    var Kil = K[j + 1]

    var ch = Ch(e, f, g)
    var chl = Ch(el, fl, gl)

    var t1l = hl + sigma1l
    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
    t1l = t1l + chl
    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
    t1l = t1l + Kil
    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
    t1l = t1l + Wil
    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl
    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

    h = g
    hl = gl
    g = f
    gl = fl
    f = e
    fl = el
    el = (dl + t1l) | 0
    e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
    d = c
    dl = cl
    c = b
    cl = bl
    b = a
    bl = al
    al = (t1l + t2l) | 0
    a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0

    i++
    j += 2
  }

  while (i < 16) {
    Wi = M.readInt32BE(j * 4)
    Wil = M.readInt32BE(j * 4 + 4)

    loop()
  }

  while (i < 80) {
    calcW()
    loop()
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)
  writeInt64BE(this._g, this._gl, 48)
  writeInt64BE(this._h, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjcgfCAwXG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1IHwgMFxuICB0aGlzLl9jID0gMHgzYzZlZjM3MiB8IDBcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2EgfCAwXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmIHwgMFxuICB0aGlzLl9mID0gMHg5YjA1Njg4YyB8IDBcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWIgfCAwXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5IHwgMFxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOCB8IDBcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiIHwgMFxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmIgfCAwXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMSB8IDBcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxIHwgMFxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWYgfCAwXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YiB8IDBcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFMgKFgsIFhsLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbikgfCAoWGwgPDwgKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpXG59XG5cbmZ1bmN0aW9uIE1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KSlcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIHZhciBpID0gMCwgaiA9IDBcbiAgdmFyIFdpLCBXaWxcbiAgZnVuY3Rpb24gY2FsY1cgKCkge1xuICAgIHZhciB4ID0gV1tqIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaiAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IFMoeCwgeGwsIDEpIF4gUyh4LCB4bCwgOCkgXiAoeCA+Pj4gNylcbiAgICB2YXIgZ2FtbWEwbCA9IFMoeGwsIHgsIDEpIF4gUyh4bCwgeCwgOCkgXiBTKHhsLCB4LCA3KVxuXG4gICAgeCA9IFdbaiAtIDIgKiAyXVxuICAgIHhsID0gV1tqIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBTKHgsIHhsLCAxOSkgXiBTKHhsLCB4LCAyOSkgXiAoeCA+Pj4gNilcbiAgICB2YXIgZ2FtbWExbCA9IFMoeGwsIHgsIDE5KSBeIFMoeCwgeGwsIDI5KSBeIFMoeGwsIHgsIDYpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3ID0gV1tqIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2ogLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNiA9IFdbaiAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2ogLSAxNiAqIDIgKyAxXVxuXG4gICAgV2lsID0gZ2FtbWEwbCArIFdpN2xcbiAgICBXaSA9IGdhbW1hMCArIFdpNyArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKVxuICAgIFdpbCA9IFdpbCArIGdhbW1hMWxcbiAgICBXaSA9IFdpICsgZ2FtbWExICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApXG4gICAgV2lsID0gV2lsICsgV2kxNmxcbiAgICBXaSA9IFdpICsgV2kxNiArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3AgKCkge1xuICAgIFdbal0gPSBXaVxuICAgIFdbaiArIDFdID0gV2lsXG5cbiAgICB2YXIgbWFqID0gTWFqKGEsIGIsIGMpXG4gICAgdmFyIG1hamwgPSBNYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gUyhhLCBhbCwgMjgpIF4gUyhhbCwgYSwgMikgXiBTKGFsLCBhLCA3KVxuICAgIHZhciBzaWdtYTBsID0gUyhhbCwgYSwgMjgpIF4gUyhhLCBhbCwgMikgXiBTKGEsIGFsLCA3KVxuICAgIHZhciBzaWdtYTFoID0gUyhlLCBlbCwgMTQpIF4gUyhlLCBlbCwgMTgpIF4gUyhlbCwgZSwgOSlcbiAgICB2YXIgc2lnbWExbCA9IFMoZWwsIGUsIDE0KSBeIFMoZWwsIGUsIDE4KSBeIFMoZSwgZWwsIDkpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG4gICAgdmFyIEtpID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoID0gQ2goZSwgZiwgZylcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgIHZhciB0MWwgPSBobCArIHNpZ21hMWxcbiAgICB2YXIgdDEgPSBoICsgc2lnbWExaCArICgodDFsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMClcbiAgICB0MWwgPSB0MWwgKyBjaGxcbiAgICB0MSA9IHQxICsgY2ggKyAoKHQxbCA+Pj4gMCkgPCAoY2hsID4+PiAwKSA/IDEgOiAwKVxuICAgIHQxbCA9IHQxbCArIEtpbFxuICAgIHQxID0gdDEgKyBLaSArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApXG4gICAgdDFsID0gdDFsICsgV2lsXG4gICAgdDEgPSB0MSArIFdpICsgKCh0MWwgPj4+IDApIDwgKFdpbCA+Pj4gMCkgPyAxIDogMClcblxuICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgdmFyIHQybCA9IHNpZ21hMGwgKyBtYWpsXG4gICAgdmFyIHQyID0gc2lnbWEwaCArIG1haiArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKVxuXG4gICAgaCA9IGdcbiAgICBobCA9IGdsXG4gICAgZyA9IGZcbiAgICBnbCA9IGZsXG4gICAgZiA9IGVcbiAgICBmbCA9IGVsXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgIGUgPSAoZCArIHQxICsgKChlbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICBkID0gY1xuICAgIGRsID0gY2xcbiAgICBjID0gYlxuICAgIGNsID0gYmxcbiAgICBiID0gYVxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGEgPSAodDEgKyB0MiArICgoYWwgPj4+IDApIDwgKHQxbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuXG4gICAgaSsrXG4gICAgaiArPSAyXG4gIH1cblxuICB3aGlsZSAoaSA8IDE2KSB7XG4gICAgV2kgPSBNLnJlYWRJbnQzMkJFKGogKiA0KVxuICAgIFdpbCA9IE0ucmVhZEludDMyQkUoaiAqIDQgKyA0KVxuXG4gICAgbG9vcCgpXG4gIH1cblxuICB3aGlsZSAoaSA8IDgwKSB7XG4gICAgY2FsY1coKVxuICAgIGxvb3AoKVxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2EgPSAodGhpcy5fYSArIGEgKyAoKHRoaXMuX2FsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9iID0gKHRoaXMuX2IgKyBiICsgKCh0aGlzLl9ibCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fYyA9ICh0aGlzLl9jICsgYyArICgodGhpcy5fY2wgPj4+IDApIDwgKGNsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2QgPSAodGhpcy5fZCArIGQgKyAoKHRoaXMuX2RsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9lID0gKHRoaXMuX2UgKyBlICsgKCh0aGlzLl9lbCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fZiA9ICh0aGlzLl9mICsgZiArICgodGhpcy5fZmwgPj4+IDApIDwgKGZsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2cgPSAodGhpcy5fZyArIGcgKyAoKHRoaXMuX2dsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9oID0gKHRoaXMuX2ggKyBoICsgKCh0aGlzLl9obCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYSwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2MsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2QsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2UsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2YsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2csIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2gsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIl19
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha224.js":[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8 | 0
  this._b = 0x367cd507 | 0
  this._c = 0x3070dd17 | 0
  this._d = 0xf70e5939 | 0
  this._e = 0xffc00b31 | 0
  this._f = 0x68581511 | 0
  this._g = 0x64f98fa7 | 0
  this._h = 0xbefa4fa4 | 0

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDggfCAwXG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3IHwgMFxuICB0aGlzLl9jID0gMHgzMDcwZGQxNyB8IDBcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzkgfCAwXG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxIHwgMFxuICB0aGlzLl9mID0gMHg2ODU4MTUxMSB8IDBcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTcgfCAwXG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuIl19
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","./sha256":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js":[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  return this
}

function S (X, n) {
  return (X >>> n) | (X << (32 - n))
}

function R (X, n) {
  return (X >>> n)
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z))
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z))
}

function Sigma0256 (x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22))
}

function Sigma1256 (x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25))
}

function Gamma0256 (x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3))
}

function Gamma1256 (x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10))
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var j = 0

  function calcW () { return Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16] }
  function loop (w) {
    W[j] = w

    var T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
    var T2 = Sigma0256(a) + Maj(a, b, c)

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

    j++
  }

  while (j < 16) loop(M.readInt32BE(j * 4))
  while (j < 64) loop(calcW())

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2NyB8IDBcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODUgfCAwXG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyIHwgMFxuICB0aGlzLl9kID0gMHhhNTRmZjUzYSB8IDBcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2YgfCAwXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjIHwgMFxuICB0aGlzLl9nID0gMHgxZjgzZDlhYiB8IDBcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTkgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gUyAoWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIFIgKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKVxufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKVxufVxuXG5mdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpXG59XG5cbmZ1bmN0aW9uIFNpZ21hMDI1NiAoeCkge1xuICByZXR1cm4gKFMoeCwgMikgXiBTKHgsIDEzKSBeIFMoeCwgMjIpKVxufVxuXG5mdW5jdGlvbiBTaWdtYTEyNTYgKHgpIHtcbiAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSlcbn1cblxuZnVuY3Rpb24gR2FtbWEwMjU2ICh4KSB7XG4gIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSlcbn1cblxuZnVuY3Rpb24gR2FtbWExMjU2ICh4KSB7XG4gIHJldHVybiAoUyh4LCAxNykgXiBTKHgsIDE5KSBeIFIoeCwgMTApKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICB2YXIgaiA9IDBcblxuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBHYW1tYTEyNTYoV1tqIC0gMl0pICsgV1tqIC0gN10gKyBHYW1tYTAyNTYoV1tqIC0gMTVdKSArIFdbaiAtIDE2XSB9XG4gIGZ1bmN0aW9uIGxvb3AgKHcpIHtcbiAgICBXW2pdID0gd1xuXG4gICAgdmFyIFQxID0gaCArIFNpZ21hMTI1NihlKSArIENoKGUsIGYsIGcpICsgS1tqXSArIHdcbiAgICB2YXIgVDIgPSBTaWdtYTAyNTYoYSkgKyBNYWooYSwgYiwgYylcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSBkICsgVDFcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gVDEgKyBUMlxuXG4gICAgaisrXG4gIH1cblxuICB3aGlsZSAoaiA8IDE2KSBsb29wKE0ucmVhZEludDMyQkUoaiAqIDQpKVxuICB3aGlsZSAoaiA8IDY0KSBsb29wKGNhbGNXKCkpXG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iXX0=
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha1.js":[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0, k

  function calcW () { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYTEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTEsIEhhc2gpXG5cblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxIHwgMFxuICB0aGlzLl9iID0gMHhlZmNkYWI4OSB8IDBcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmUgfCAwXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2IHwgMFxuICB0aGlzLl9lID0gMHhjM2QyZTFmMCB8IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wgKG51bSwgY250KSB7XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKVxufVxuXG5TaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hXG4gIHZhciBiID0gdGhpcy5fYlxuICB2YXIgYyA9IHRoaXMuX2NcbiAgdmFyIGQgPSB0aGlzLl9kXG4gIHZhciBlID0gdGhpcy5fZVxuXG4gIHZhciBqID0gMCwga1xuXG4gIGZ1bmN0aW9uIGNhbGNXICgpIHsgcmV0dXJuIHJvbChXW2ogLSAzXSBeIFdbaiAtIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdLCAxKSB9XG4gIGZ1bmN0aW9uIGxvb3AgKHcsIGYpIHtcbiAgICBXW2pdID0gd1xuXG4gICAgdmFyIHQgPSByb2woYSwgNSkgKyBmICsgZSArIHcgKyBrXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvbChiLCAzMClcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gICAgaisrXG4gIH1cblxuICBrID0gMTUxODUwMDI0OVxuICB3aGlsZSAoaiA8IDE2KSBsb29wKE0ucmVhZEludDMyQkUoaiAqIDQpLCAoYiAmIGMpIHwgKCh+YikgJiBkKSlcbiAgd2hpbGUgKGogPCAyMCkgbG9vcChjYWxjVygpLCAoYiAmIGMpIHwgKCh+YikgJiBkKSlcbiAgayA9IDE4NTk3NzUzOTNcbiAgd2hpbGUgKGogPCA0MCkgbG9vcChjYWxjVygpLCBiIF4gYyBeIGQpXG4gIGsgPSAtMTg5NDAwNzU4OFxuICB3aGlsZSAoaiA8IDYwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSlcbiAgayA9IC04OTk0OTc1MTRcbiAgd2hpbGUgKGogPCA4MCkgbG9vcChjYWxjVygpLCBiIF4gYyBeIGQpXG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIl19
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha.js":[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0, k

  /*
   * SHA-1 has a bitwise rotate left operation. But, SHA is not
   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
   */
  function calcW () { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDEgfCAwXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5IHwgMFxuICB0aGlzLl9jID0gMHg5OGJhZGNmZSB8IDBcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzYgfCAwXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwIHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbCAobnVtLCBjbnQpIHtcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuICB2YXIgZSA9IHRoaXMuX2VcblxuICB2YXIgaiA9IDAsIGtcblxuICAvKlxuICAgKiBTSEEtMSBoYXMgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0IG9wZXJhdGlvbi4gQnV0LCBTSEEgaXMgbm90XG4gICAqIGZ1bmN0aW9uIGNhbGNXKCkgeyByZXR1cm4gcm9sKFdbaiAtIDNdIF4gV1tqIC0gIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdLCAxKSB9XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBXW2ogLSAzXSBeIFdbaiAtIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdIH1cbiAgZnVuY3Rpb24gbG9vcCAodywgZikge1xuICAgIFdbal0gPSB3XG5cbiAgICB2YXIgdCA9IHJvbChhLCA1KSArIGYgKyBlICsgdyArIGtcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm9sKGIsIDMwKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgICBqKytcbiAgfVxuXG4gIGsgPSAxNTE4NTAwMjQ5XG4gIHdoaWxlIChqIDwgMTYpIGxvb3AoTS5yZWFkSW50MzJCRShqICogNCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICB3aGlsZSAoaiA8IDIwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICBrID0gMTg1OTc3NTM5M1xuICB3aGlsZSAoaiA8IDQwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcbiAgayA9IC0xODk0MDA3NTg4XG4gIHdoaWxlIChqIDwgNjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKVxuICBrID0gLTg5OTQ5NzUxNFxuICB3aGlsZSAoaiA8IDgwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuXG4iXX0=
},{"./hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js":[function(require,module,exports){
(function (Buffer){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX3MgPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICB2YXIgcyA9IHRoaXMuX3MgfHwgMFxuICB2YXIgZiA9IDBcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgd2hpbGUgKHMgPCBsKSB7XG4gICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgfVxuXG4gICAgcyArPSBjaFxuICAgIGYgKz0gY2hcblxuICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgfVxuICB9XG4gIHRoaXMuX3MgPSBzXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIl19
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":[function(require,module,exports){
(function (Buffer){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8vIGNvbnN0YW50cyB0YWJsZVxudmFyIHpsID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dXG5cbnZhciB6ciA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXVxuXG52YXIgc2wgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dXG5cbnZhciBzciA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl1cblxudmFyIGhsID0gWzB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdXG52YXIgaHIgPSBbMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF1cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzIChieXRlcykge1xuICB2YXIgd29yZHMgPSBbXVxuICBmb3IgKHZhciBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KSB7XG4gICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKVxuICB9XG4gIHJldHVybiB3b3Jkc1xufVxuXG5mdW5jdGlvbiB3b3Jkc1RvQnl0ZXMgKHdvcmRzKSB7XG4gIHZhciBieXRlcyA9IFtdXG4gIGZvciAodmFyIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOCkge1xuICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayAoSCwgTSwgb2Zmc2V0KSB7XG4gIC8vIHN3YXAgZW5kaWFuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGlcbiAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldXG5cbiAgICAvLyBTd2FwXG4gICAgTVtvZmZzZXRfaV0gPSAoXG4gICAgICAoKChNX29mZnNldF9pIDw8IDgpIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICAgIClcbiAgfVxuXG4gIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gIHZhciBhbCwgYmwsIGNsLCBkbCwgZWxcbiAgdmFyIGFyLCBiciwgY3IsIGRyLCBlclxuXG4gIGFyID0gYWwgPSBIWzBdXG4gIGJyID0gYmwgPSBIWzFdXG4gIGNyID0gY2wgPSBIWzJdXG4gIGRyID0gZGwgPSBIWzNdXG4gIGVyID0gZWwgPSBIWzRdXG5cbiAgLy8gY29tcHV0YXRpb25cbiAgdmFyIHRcbiAgZm9yIChpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB0ID0gKGFsICsgTVtvZmZzZXQgKyB6bFtpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjEoYmwsIGNsLCBkbCkgKyBobFswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGYyKGJsLCBjbCwgZGwpICsgaGxbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhibCwgY2wsIGRsKSArIGhsWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjQoYmwsIGNsLCBkbCkgKyBobFszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjUoYmwsIGNsLCBkbCkgKyBobFs0XVxuICAgIH1cbiAgICB0ID0gdCB8IDBcbiAgICB0ID0gcm90bCh0LCBzbFtpXSlcbiAgICB0ID0gKHQgKyBlbCkgfCAwXG4gICAgYWwgPSBlbFxuICAgIGVsID0gZGxcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxuICAgIGNsID0gYmxcbiAgICBibCA9IHRcblxuICAgIHQgPSAoYXIgKyBNW29mZnNldCArIHpyW2ldXSkgfCAwXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdCArPSBmNShiciwgY3IsIGRyKSArIGhyWzBdXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHQgKz0gZjQoYnIsIGNyLCBkcikgKyBoclsxXVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0ICs9IGYzKGJyLCBjciwgZHIpICsgaHJbMl1cbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdCArPSBmMihiciwgY3IsIGRyKSArIGhyWzNdXG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgdCArPSBmMShiciwgY3IsIGRyKSArIGhyWzRdXG4gICAgfVxuXG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc3JbaV0pXG4gICAgdCA9ICh0ICsgZXIpIHwgMFxuICAgIGFyID0gZXJcbiAgICBlciA9IGRyXG4gICAgZHIgPSByb3RsKGNyLCAxMClcbiAgICBjciA9IGJyXG4gICAgYnIgPSB0XG4gIH1cblxuICAvLyBpbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICB0ID0gKEhbMV0gKyBjbCArIGRyKSB8IDBcbiAgSFsxXSA9IChIWzJdICsgZGwgKyBlcikgfCAwXG4gIEhbMl0gPSAoSFszXSArIGVsICsgYXIpIHwgMFxuICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKSB8IDBcbiAgSFs0XSA9IChIWzBdICsgYmwgKyBjcikgfCAwXG4gIEhbMF0gPSB0XG59XG5cbmZ1bmN0aW9uIGYxICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKVxufVxuXG5mdW5jdGlvbiBmMiAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgJiAoeSkpIHwgKCh+eCkgJiAoeikpKVxufVxuXG5mdW5jdGlvbiBmMyAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgfCAofih5KSkpIF4gKHopKVxufVxuXG5mdW5jdGlvbiBmNCAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgJiAoeikpIHwgKCh5KSAmICh+KHopKSkpXG59XG5cbmZ1bmN0aW9uIGY1ICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKCh5KSB8ICh+KHopKSkpXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiByaXBlbWQxNjAgKG1lc3NhZ2UpIHtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ3V0ZjgnKVxuICB9XG5cbiAgdmFyIG0gPSBieXRlc1RvV29yZHMobWVzc2FnZSlcblxuICB2YXIgbkJpdHNMZWZ0ID0gbWVzc2FnZS5sZW5ndGggKiA4XG4gIHZhciBuQml0c1RvdGFsID0gbWVzc2FnZS5sZW5ndGggKiA4XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgbVtuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpXG4gIG1bKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcbiAgICAoKChuQml0c1RvdGFsIDw8IDgpIHwgKG5CaXRzVG90YWwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgKCgobkJpdHNUb3RhbCA8PCAyNCkgfCAobkJpdHNUb3RhbCA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBwcm9jZXNzQmxvY2soSCwgbSwgaSlcbiAgfVxuXG4gIC8vIHN3YXAgZW5kaWFuXG4gIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAvLyBzaG9ydGN1dFxuICAgIHZhciBIX2kgPSBIW2ldXG5cbiAgICAvLyBTd2FwXG4gICAgSFtpXSA9ICgoKEhfaSA8PCA4KSB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgfVxuXG4gIHZhciBkaWdlc3RieXRlcyA9IHdvcmRzVG9CeXRlcyhIKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihkaWdlc3RieXRlcylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByaXBlbWQxNjBcbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/asn1.js":[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

var asn1 = require('asn1.js');

var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  );
});
exports.RSAPrivateKey = RSAPrivateKey;

var RSAPublicKey = asn1.define('RSAPublicKey', function() {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  );
});
exports.RSAPublicKey = RSAPublicKey;

var PublicKey = asn1.define('SubjectPublicKeyInfo', function() {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  );
});
exports.PublicKey = PublicKey;

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
        this.key('p').int(),
        this.key('q').int(),
        this.key('g').int()
      ).optional()
  );
});

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  );
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  );
});

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  );
});
exports.DSAPrivateKey = DSAPrivateKey;

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int();
});
var ECPrivateKey = asn1.define('ECPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  );
});
exports.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1.define('ECParameters', function() {
  this.choice({
    namedCurve: this.objid()
  });
});

exports.signature = asn1.define('signature', function() {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  );
});

},{"asn1.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js":[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js","./asn1/base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","./asn1/constants":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js","./asn1/decoders":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js","./asn1/encoders":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js":[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js","./pem":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/pem.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/pem.js":[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js":[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr')
    return this._createEncoderBuffer(str);
  else if (tag === 'bitstr')
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._createEncoderBuffer(str);
  return this.reporter.error('Encoding of string type: ' + tag +
                             ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (num.sign === false && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js":[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js","./pem":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/pem.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/pem.js":[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js":[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.start();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  return buffer.cut(state);
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js":[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js":[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js":[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js","./node":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js","./reporter":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js":[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js":[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","minimalistic-assert":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js":[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js":[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js":[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","vm":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/vm-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/vm-browserify/index.js":[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/vm-browserify/node_modules/indexof/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/vm-browserify/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/aesid.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js":[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');

},{"../package.json":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/package.json","./elliptic/curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js","./elliptic/curves":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curves.js","./elliptic/ec":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/index.js","./elliptic/hmac-drbg":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/hmac-drbg.js","./elliptic/utils":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/utils.js","brorand":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/brorand/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/package.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={
  "name": "elliptic",
  "version": "3.1.0",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "scripts": {
    "test": "make lint && mocha --reporter=spec test/*-test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "browserify": "^3.44.2",
    "jscs": "^1.11.3",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0",
    "uglify-js": "^2.4.13"
  },
  "dependencies": {
    "bn.js": "^2.0.3",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "inherits": "^2.0.1"
  },
  "gitHead": "d86cd2a8178f7e7cecbd6dd92eea084e2ab44c13",
  "_id": "elliptic@3.1.0",
  "_shasum": "c21682ef762769b56a74201609105da11d5f60cc",
  "_from": "elliptic@>=3.0.0 <4.0.0",
  "_npmVersion": "2.11.0",
  "_nodeVersion": "2.2.1",
  "_npmUser": {
    "name": "indutny",
    "email": "fedor@indutny.com"
  },
  "maintainers": [
    {
      "name": "indutny",
      "email": "fedor@indutny.com"
    }
  ],
  "dist": {
    "shasum": "c21682ef762769b56a74201609105da11d5f60cc",
    "tarball": "http://registry.npmjs.org/elliptic/-/elliptic-3.1.0.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-3.1.0.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/brorand/index.js":[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

if (typeof window === 'object') {
  if (window.crypto && window.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker
  try {
    var crypto = require('cry' + 'pto');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
    // Emulate crypto API using randy
    Rand.prototype._rand = function _rand(n) {
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
  }
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/utils.js":[function(require,module,exports){
'use strict';

var utils = exports;

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (!enc) {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.ishrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.ishrn(1);
    k2.ishrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/hmac-drbg.js":[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};

},{"../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","hash.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/index.js":[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.shrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn(2));
  do {
    var priv = new bn(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.shrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new bn(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray();
  for (var i = bkey.length; i < 21; i++)
    bkey.unshift(0);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray();
  for (var i = nonce.length; i < bytes; i++)
    nonce.unshift(0);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn(1));
  do {
    var k = new bn(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.mod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0)
      s = this.n.sub(s);

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  } while (true);
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new bn(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).mod(this.n);
  var u2 = sinv.mul(r).mod(this.n);

  var p = this.g.mulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  return p.getX().mod(this.n).cmp(r) === 0;
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new bn(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.mod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  r = this.curve.pointFromX(isYOdd, r);
  var eNeg = e.neg().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = signature.r.invm(n);
  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime = this.recoverPubKey(e, signature, i);

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","./key":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/key.js","./signature":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/signature.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/signature.js":[function(require,module,exports){
'use strict';

var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new bn(options.r, 16);
  this.s = new bn(options.s, 16);
  if (options.recoveryParam !== null)
    this.recoveryParam = options.recoveryParam;
  else
    this.recoveryParam = null;
}
module.exports = Signature;

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
    return false;
  var total = data[1];
  if (1 + total > data.length)
    return false;
  var rlen = data[3];
  // Short length notation
  if (rlen >= 0x80)
    return false;
  if (4 + rlen + 2 >= data.length)
    return false;
  if (data[4 + rlen] !== 0x02)
    return false;
  var slen = data[5 + rlen];
  // Short length notation
  if (slen >= 0x80)
    return false;
  if (4 + rlen + 2 + slen > data.length)
    return false;

  this.r = new bn(data.slice(4, 4 + rlen));
  this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));
  this.recoveryParam = null;

  return true;
};

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  var total = r.length + s.length + 4;
  var res = [ 0x30, total, 0x02, r.length ];
  res = res.concat(r, [ 0x02, s.length ], s);
  return utils.encode(res, enc);
};

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/key.js":[function(require,module,exports){
'use strict';

var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!enc)
    return this.pub;

  var len = this.ec.curve.p.byteLength();
  var x = this.pub.getX().toArray();

  for (var i = x.length; i < len; i++)
    x.unshift(0);

  var res;
  if (this.ec.curve.type !== 'mont') {
    if (compact) {
      res = [ this.pub.getY().isEven() ? 0x02 : 0x03 ].concat(x);
    } else {
      var y = this.pub.getY().toArray();
      for (var i = y.length; i < len; i++)
        y.unshift(0);
      var res = [ 0x04 ].concat(x, y);
    }
  } else {
    res = x;
  }

  return utils.encode(res, enc);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new bn(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.mod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }

  key = utils.toArray(key, enc);
  if (this.ec.curve.type !== 'mont')
    return this._importPublicShort(key);
  else
    return this._importPublicMont(key);
};

KeyPair.prototype._importPublicShort = function _importPublicShort(key) {
  var len = this.ec.curve.p.byteLength();
  if (key[0] === 0x04 && key.length - 1 === 2 * len) {
    this.pub = this.ec.curve.point(
      key.slice(1, 1 + len),
      key.slice(1 + len, 1 + 2 * len));
  } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
    this.pub = this.ec.curve.pointFromX(key[0] === 0x03, key.slice(1, 1 + len));
  }
};

KeyPair.prototype._importPublicMont = function _importPublicMont(key) {
  this.pub = this.ec.curve.point(key, 1);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg) {
  return this.ec.sign(msg, this);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curves.js":[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var elliptic = require('../elliptic');

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","./precomputed/secp256k1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js","hash.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js":[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js","./hash/hmac":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js","./hash/ripemd":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js","./hash/sha":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js","./hash/utils":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js":[function(require,module,exports){
var utils = exports;
var inherits = require('inherits');

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;

},{"inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js":[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js":[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js":[function(require,module,exports){
var hmac = exports;

var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js":[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"../hash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js":[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/base.js","./edwards":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/edwards.js","./mont":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/mont.js","./short":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/short.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/short.js":[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn(vec.a, 16),
        b: new bn(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn.mont(num);
  var tinv = new bn(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn(1);
  var y1 = new bn(0);
  var x2 = new bn(0);
  var y2 = new bn(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.sign) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.sign) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.sign) {
      split.k1.sign = !split.k1.sign;
      p = p.neg(true);
    }
    if (split.k2.sign) {
      split.k2.sign = !split.k2.sign;
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn(0);
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = new bn(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/mont.js":[function(require,module,exports){
'use strict';

var curve = require('../curve');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.i4 = new bn(4).toRed(this.red).redInvm();
  this.two = new bn(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new bn(x, 16);
    this.z = new bn(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/edwards.js":[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
  this.c = new bn(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new bn(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y = rhs.redMul(lhs.redInvm()).redSqrt();
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y, curve.one);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = z ? new bn(z, 16) : this.curve.one;
    this.t = t && new bn(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","../curve":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/base.js":[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');

var getNAF = elliptic.utils.getNAF;
var getJSF = elliptic.utils.getJSF;
var assert = elliptic.utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

  // Useful for many curves
  this.zero = new bn(0).toRed(this.red);
  this.one = new bn(1).toRed(this.red);
  this.two = new bn(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;
  return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../../elliptic":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js","bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/browserify-rsa/index.js":[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).mod(p);
  h.imul(q);
  m2.iadd(h);
  var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
  if (out.length < len) {
    var prefix = new Buffer(len - out.length);
    prefix.fill(0);
    out = Buffer.concat([prefix, out], len);
  }
  return out;
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBjcnQ7XG5mdW5jdGlvbiBibGluZChwcml2KSB7XG4gIHZhciByID0gZ2V0cihwcml2KTtcbiAgdmFyIGJsaW5kZXIgPSByLnRvUmVkKGJuLm1vbnQocHJpdi5tb2R1bHVzKSlcbiAgLnJlZFBvdyhuZXcgYm4ocHJpdi5wdWJsaWNFeHBvbmVudCkpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHtcbiAgICBibGluZGVyOiBibGluZGVyLFxuICAgIHVuYmxpbmRlcjpyLmludm0ocHJpdi5tb2R1bHVzKVxuICB9O1xufVxuZnVuY3Rpb24gY3J0KG1zZywgcHJpdikge1xuICB2YXIgYmxpbmRzID0gYmxpbmQocHJpdik7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbW9kID0gYm4ubW9udChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYmxpbmRlZCA9IG5ldyBibihtc2cpLm11bChibGluZHMuYmxpbmRlcikubW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS5tb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS5tb2QocHJpdi5tb2R1bHVzKS50b0FycmF5KCkpO1xuICBpZiAob3V0Lmxlbmd0aCA8IGxlbikge1xuICAgIHZhciBwcmVmaXggPSBuZXcgQnVmZmVyKGxlbiAtIG91dC5sZW5ndGgpO1xuICAgIHByZWZpeC5maWxsKDApO1xuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgb3V0XSwgbGVuKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIubW9kKHByaXYucHJpbWUxKSB8fCAhci5tb2QocHJpdi5wcmltZTIpKSB7XG4gICAgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgfVxuICByZXR1cm4gcjtcbn0iXX0=
},{"bn.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","randombytes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js":[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var crypto = global.crypto || global.msCrypto
if(crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}
function oldBrowser() {
  throw new Error(
      'secure random number generation not supported by this browser\n'+
      'use chrome, FireFox or Internet Explorer 11'
    )
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cbmlmKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXM7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXI7XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcyhzaXplLCBjYikge1xuICB2YXIgYnl0ZXMgPSBuZXcgQnVmZmVyKHNpemUpOyAvL2luIGJyb3dzZXJpZnksIHRoaXMgaXMgYW4gZXh0ZW5kZWQgVWludDhBcnJheVxuICAgIC8qIFRoaXMgd2lsbCBub3Qgd29yayBpbiBvbGRlciBicm93c2Vycy5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICovXG5cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gb2xkQnJvd3NlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG4nK1xuICAgICAgJ3VzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnXG4gICAgKVxufVxuIl19
},{"_process":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js":[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/curves.js":[function(require,module,exports){
'use strict'
exports['1.3.132.0.10'] = 'secp256k1'

exports['1.3.132.0.33'] = 'p224'

exports['1.2.840.10045.3.1.1'] = 'p192'

exports['1.2.840.10045.3.1.7'] = 'p256'

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/algos.js":[function(require,module,exports){
(function (Buffer){
'use strict'
exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha224',
  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
}
exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha256',
  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
}
exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha384',
  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
}
exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha512',
  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
}
exports['RSA-SHA1'] = {
	sign: 'rsa',
	hash: 'sha1',
	id: new Buffer('3021300906052b0e03021a05000414', 'hex')
}
exports['ecdsa-with-SHA1'] = {
	sign: 'ecdsa',
	hash: 'sha1',
	id: new Buffer('', 'hex')
}
exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
  sign: 'dsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
  sign: 'dsa',
  hash: 'sha224',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
  sign: 'dsa',
  hash: 'sha256',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
  sign: 'dsa',
  hash: 'sha384',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
  sign: 'dsa',
  hash: 'sha512',
  id: new Buffer('', 'hex')
}
exports['DSA-RIPEMD160'] = {
  sign: 'dsa',
  hash: 'rmd160',
  id: new Buffer('', 'hex')
}
exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
  sign: 'rsa',
  hash: 'rmd160',
  id: new Buffer('3021300906052b2403020105000414', 'hex')
}
exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
  sign: 'rsa',
  hash: 'md5',
  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2FsZ29zLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuZXhwb3J0c1snUlNBLVNIQTIyNCddID0gZXhwb3J0cy5zaGEyMjRXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGEyMjQnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWMnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEEyNTYnXSA9IGV4cG9ydHMuc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhMjU2JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwMzEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMTA1MDAwNDIwJywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtU0hBMzg0J10gPSBleHBvcnRzLnNoYTM4NFdpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTM4NCcsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMCcsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVNIQTUxMiddID0gZXhwb3J0cy5zaGE1MTJXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGE1MTInLFxuICBpZDogbmV3IEJ1ZmZlcignMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDAnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEExJ10gPSB7XG5cdHNpZ246ICdyc2EnLFxuXHRoYXNoOiAnc2hhMScsXG5cdGlkOiBuZXcgQnVmZmVyKCczMDIxMzAwOTA2MDUyYjBlMDMwMjFhMDUwMDA0MTQnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ2VjZHNhLXdpdGgtU0hBMSddID0ge1xuXHRzaWduOiAnZWNkc2EnLFxuXHRoYXNoOiAnc2hhMScsXG5cdGlkOiBuZXcgQnVmZmVyKCcnLCAnaGV4Jylcbn1cbmV4cG9ydHMuRFNBID0gZXhwb3J0c1snRFNBLVNIQTEnXSA9IGV4cG9ydHNbJ0RTQS1TSEEnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGExJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTIyNCddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMjI0J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMjI0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTI1NiddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMjU2J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMjU2JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTM4NCddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMzg0J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMzg0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTUxMiddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBNTEyJ10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhNTEyJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVJJUEVNRDE2MCddID0ge1xuICBzaWduOiAnZHNhJyxcbiAgaGFzaDogJ3JtZDE2MCcsXG4gIGlkOiBuZXcgQnVmZmVyKCcnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1SSVBFTUQxNjAnXSA9IGV4cG9ydHMucmlwZW1kMTYwV2l0aFJTQSA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdybWQxNjAnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0JywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtTUQ1J10gPSBleHBvcnRzLm1kNVdpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ21kNScsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjA1MDUwMDA0MTAnLCAnaGV4Jylcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/browser.js":[function(require,module,exports){
var ciphers = require('./encrypter')
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = require('./decrypter')
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = require('./modes')
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/decrypter.js","./encrypter":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/encrypter.js","./modes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/encrypter.js":[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('./cipherBase')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('./EVP_BytesToKey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vY2lwaGVyQmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnLi9FVlBfQnl0ZXNUb0tleScpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IENpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH0gZWxzZSBpZiAoY2h1bmsudG9TdHJpbmcoJ2hleCcpICE9PSAnMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAnKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBuZXcgQnVmZmVyKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG4gIHZhciBvdXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbiAgcmV0dXJuIG91dFxufVxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH1cbiAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG4iXX0=
},{"./EVP_BytesToKey":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/EVP_BytesToKey.js","./aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/aes.js","./authCipher":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/authCipher.js","./cipherBase":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/cipherBase.js","./modes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes.js","./modes/cbc":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cbc.js","./modes/cfb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb.js","./modes/cfb1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb1.js","./modes/cfb8":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb8.js","./modes/ctr":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ctr.js","./modes/ecb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ecb.js","./modes/ofb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ofb.js","./streamCipher":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/streamCipher.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/decrypter.js":[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('./cipherBase')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('./EVP_BytesToKey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZGVjcnlwdGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vY2lwaGVyQmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJy4vRVZQX0J5dGVzVG9LZXknKVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlY2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVcbiAgfVxufVxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbiJdfQ==
},{"./EVP_BytesToKey":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/EVP_BytesToKey.js","./aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/aes.js","./authCipher":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/authCipher.js","./cipherBase":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/cipherBase.js","./modes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes.js","./modes/cbc":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cbc.js","./modes/cfb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb.js","./modes/cfb1":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb1.js","./modes/cfb8":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb8.js","./modes/ctr":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ctr.js","./modes/ecb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ecb.js","./modes/ofb":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ofb.js","./streamCipher":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/streamCipher.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/streamCipher.js":[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('./cipherBase')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vY2lwaGVyQmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaywgdGhpcy5fZGVjcnlwdClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuIl19
},{"./aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/aes.js","./cipherBase":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/cipherBase.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ofb.js":[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvb2ZiLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","buffer-xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ecb.js":[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/ctr.js":[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iXX0=
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","buffer-xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb8.js":[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iXX0=
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb1.js":[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBuZXcgQnVmZmVyKFt2YWx1ZV0pXSlcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iXX0=
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cfb.js":[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKCcnKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gbmV3IEJ1ZmZlcignJylcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","buffer-xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes/cbc.js":[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/modes.js":[function(require,module,exports){
exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/authCipher.js":[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('./cipherBase')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2NpcGhlckJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMV0pXSlcbiAgaXYgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMl0pXSlcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdmFyIGggPSBuZXcgQnVmZmVyKDQpXG4gIGguZmlsbCgwKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSCh0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpKVxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gbmV3IEJ1ZmZlcihydW1wKVxuICAgICAgcnVtcC5maWxsKDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICB9XG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfVxuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCAmJiBCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICAgIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgb3V0KytcbiAgfVxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiJdfQ==
},{"./aes":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/aes.js","./cipherBase":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/cipherBase.js","./ghash":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/ghash.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","buffer-xor":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/node_modules/buffer-xor/index.js":[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbm9kZV9tb2R1bGVzL2J1ZmZlci14b3IvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/ghash.js":[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZ2hhc2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHplcm9zID0gbmV3IEJ1ZmZlcigxNilcbnplcm9zLmZpbGwoMClcbm1vZHVsZS5leHBvcnRzID0gR0hBU0hcbmZ1bmN0aW9uIEdIQVNIIChrZXkpIHtcbiAgdGhpcy5oID0ga2V5XG4gIHRoaXMuc3RhdGUgPSBuZXcgQnVmZmVyKDE2KVxuICB0aGlzLnN0YXRlLmZpbGwoMClcbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG4vLyBmcm9tIGh0dHA6Ly9iaXR3aXNlc2hpZnRsZWZ0LmdpdGh1Yi5pby9zamNsL2RvYy9zeW1ib2xzL3NyYy9jb3JlX2djbS5qcy5odG1sXG4vLyBieSBKdWhvIFbDpGjDpC1IZXJ0dHVhXG5HSEFTSC5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgYmxvY2subGVuZ3RoKSB7XG4gICAgdGhpcy5zdGF0ZVtpXSBePSBibG9ja1tpXVxuICB9XG4gIHRoaXMuX211bHRpcGx5KClcbn1cblxuR0hBU0gucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFZpID0gdG9BcnJheSh0aGlzLmgpXG4gIHZhciBaaSA9IFswLCAwLCAwLCAwXVxuICB2YXIgaiwgeGksIGxzYl9WaVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCAxMjgpIHtcbiAgICB4aSA9ICh0aGlzLnN0YXRlW35+KGkgLyA4KV0gJiAoMSA8PCAoNyAtIGkgJSA4KSkpICE9PSAwXG4gICAgaWYgKHhpKSB7XG4gICAgICAvLyBaX2krMSA9IFpfaSBeIFZfaVxuICAgICAgWmkgPSB4b3IoWmksIFZpKVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBvZiBMU0IoVl9pKVxuICAgIGxzYl9WaSA9IChWaVszXSAmIDEpICE9PSAwXG5cbiAgICAvLyBWX2krMSA9IFZfaSA+PiAxXG4gICAgZm9yIChqID0gMzsgaiA+IDA7IGotLSkge1xuICAgICAgVmlbal0gPSAoVmlbal0gPj4+IDEpIHwgKChWaVtqIC0gMV0gJiAxKSA8PCAzMSlcbiAgICB9XG4gICAgVmlbMF0gPSBWaVswXSA+Pj4gMVxuXG4gICAgLy8gSWYgTFNCKFZfaSkgaXMgMSwgVl9pKzEgPSAoVl9pID4+IDEpIF4gUlxuICAgIGlmIChsc2JfVmkpIHtcbiAgICAgIFZpWzBdID0gVmlbMF0gXiAoMHhlMSA8PCAyNClcbiAgICB9XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IGZyb21BcnJheShaaSlcbn1cbkdIQVNILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBidWZdKVxuICB2YXIgY2h1bmtcbiAgd2hpbGUgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgY2h1bmsgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHRoaXMuZ2hhc2goY2h1bmspXG4gIH1cbn1cbkdIQVNILnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChhYmwsIGJsKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuZ2hhc2goQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgemVyb3NdLCAxNikpXG4gIH1cbiAgdGhpcy5naGFzaChmcm9tQXJyYXkoW1xuICAgIDAsIGFibCxcbiAgICAwLCBibFxuICBdKSlcbiAgcmV0dXJuIHRoaXMuc3RhdGVcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIHJldHVybiBbXG4gICAgYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSgxMilcbiAgXVxufVxuZnVuY3Rpb24gZnJvbUFycmF5IChvdXQpIHtcbiAgb3V0ID0gb3V0Lm1hcChmaXh1cF91aW50MzIpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG52YXIgdWludF9tYXggPSBNYXRoLnBvdygyLCAzMilcbmZ1bmN0aW9uIGZpeHVwX3VpbnQzMiAoeCkge1xuICB2YXIgcmV0LCB4X3Bvc1xuICByZXQgPSB4ID4gdWludF9tYXggfHwgeCA8IDAgPyAoeF9wb3MgPSBNYXRoLmFicyh4KSAlIHVpbnRfbWF4LCB4IDwgMCA/IHVpbnRfbWF4IC0geF9wb3MgOiB4X3BvcykgOiB4XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIHhvciAoYSwgYikge1xuICByZXR1cm4gW1xuICAgIGFbMF0gXiBiWzBdLFxuICAgIGFbMV0gXiBiWzFdLFxuICAgIGFbMl0gXiBiWzJdLFxuICAgIGFbM10gXiBiWzNdXG4gIF1cbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/cipherBase.js":[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase () {
  Transform.call(this)
  this._base64Cache = new Buffer('')
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}
CipherBase.prototype._transform = function (data, _, next) {
  this.push(this._update(data))
  next()
}
CipherBase.prototype._flush = function (next) {
  try {
    this.push(this._final())
  } catch(e) {
    return next(e)
  }
  next()
}
CipherBase.prototype.final = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (enc !== 'base64') {
    return value.toString(enc)
  }
  this._base64Cache = Buffer.concat([this._base64Cache, value])
  var out
  if (final) {
    out = this._base64Cache
    this._base64Cache = null
    return out.toString('base64')
  }
  var len = this._base64Cache.length
  var overhang = len % 3
  if (!overhang) {
    out = this._base64Cache
    this._base64Cache = new Buffer('')
    return out.toString('base64')
  }
  var newLen = len - overhang
  if (!newLen) {
    return ''
  }

  out = this._base64Cache.slice(0, newLen)
  this._base64Cache = this._base64Cache.slice(-overhang)
  return out.toString('base64')
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvY2lwaGVyQmFzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlICgpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fYmFzZTY0Q2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgbmV4dCgpXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gbmV4dChlKVxuICB9XG4gIG5leHQoKVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluYWwpIHtcbiAgaWYgKGVuYyAhPT0gJ2Jhc2U2NCcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoZW5jKVxuICB9XG4gIHRoaXMuX2Jhc2U2NENhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5fYmFzZTY0Q2FjaGUsIHZhbHVlXSlcbiAgdmFyIG91dFxuICBpZiAoZmluYWwpIHtcbiAgICBvdXQgPSB0aGlzLl9iYXNlNjRDYWNoZVxuICAgIHRoaXMuX2Jhc2U2NENhY2hlID0gbnVsbFxuICAgIHJldHVybiBvdXQudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuX2Jhc2U2NENhY2hlLmxlbmd0aFxuICB2YXIgb3ZlcmhhbmcgPSBsZW4gJSAzXG4gIGlmICghb3ZlcmhhbmcpIHtcbiAgICBvdXQgPSB0aGlzLl9iYXNlNjRDYWNoZVxuICAgIHRoaXMuX2Jhc2U2NENhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgICByZXR1cm4gb3V0LnRvU3RyaW5nKCdiYXNlNjQnKVxuICB9XG4gIHZhciBuZXdMZW4gPSBsZW4gLSBvdmVyaGFuZ1xuICBpZiAoIW5ld0xlbikge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgb3V0ID0gdGhpcy5fYmFzZTY0Q2FjaGUuc2xpY2UoMCwgbmV3TGVuKVxuICB0aGlzLl9iYXNlNjRDYWNoZSA9IHRoaXMuX2Jhc2U2NENhY2hlLnNsaWNlKC1vdmVyaGFuZylcbiAgcmV0dXJuIG91dC50b1N0cmluZygnYmFzZTY0Jylcbn1cbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","readable-stream/duplex.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/duplex.js","readable-stream/passthrough.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js","readable-stream/readable.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/readable.js","readable-stream/transform.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/transform.js","readable-stream/writable.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/writable.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/readable.js":[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiJdfQ==
},{"./_stream_readable":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/process/browser.js","core-util-is":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYikpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHV0aWwuaXNTdHJpbmcoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXIpO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGggPiAxKSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBjYnMgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKylcbiAgICAgIGNicy5wdXNoKHN0YXRlLmJ1ZmZlcltjXS5jYWxsYmFjayk7XG5cbiAgICAvLyBjb3VudCB0aGUgb25lIHdlIGFyZSBhZGRpbmcsIGFzIHdlbGwuXG4gICAgLy8gVE9ETyhpc2FhY3MpIGNsZWFuIHRoaXMgdXBcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgc3RhdGUuYnVmZmVyLCAnJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2JzW2ldKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhciBidWZmZXJcbiAgICBzdGF0ZS5idWZmZXIgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGMrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcblxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oY2h1bmspKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2VcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIl19
},{"./_stream_duplex":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIl19
},{"./_stream_duplex":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","events":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","isarray":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/isarray/index.js","stream":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/stream-browserify/index.js","string_decoder/":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/string_decoder/index.js","util":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/string_decoder/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihhcmcpO1xufVxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59Il19
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){
arguments[4]["/home/trevor/code-dot-org/apps/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/aes.js":[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYWVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcblxuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBzY3J1Yl92ZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gR2xvYmFsICgpIHtcbiAgdGhpcy5TQk9YID0gW11cbiAgdGhpcy5JTlZfU0JPWCA9IFtdXG4gIHRoaXMuU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5JTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5SQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG59XG5cbkdsb2JhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGQsIGksIHN4LCB0LCB4LCB4MiwgeDQsIHg4LCB4aSwgX2lcbiAgZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pLCBfcmVzdWx0c1xuICAgIF9yZXN1bHRzID0gW11cbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpIDw8IDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChpIDw8IDEpIF4gMHgxMWIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0c1xuICB9KSgpXG4gIHggPSAwXG4gIHhpID0gMFxuICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICB0aGlzLlNCT1hbeF0gPSBzeFxuICAgIHRoaXMuSU5WX1NCT1hbc3hdID0geFxuICAgIHgyID0gZFt4XVxuICAgIHg0ID0gZFt4Ml1cbiAgICB4OCA9IGRbeDRdXG4gICAgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLlNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLlNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5TVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5TVUJfTUlYWzNdW3hdID0gdFxuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5JTlZfU1VCX01JWFszXVtzeF0gPSB0XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIEcgPSBuZXcgR2xvYmFsKClcblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5cbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuXG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcblxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheSAoYnVmKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC8gNFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBidWZmZXJUb0FycmF5KGtleSlcbiAgdGhpcy5fZG9SZXNldCgpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnZLc1Jvdywga2V5U2l6ZSwga2V5V29yZHMsIGtzUm93LCBrc1Jvd3MsIHRcbiAga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcbiAga3NSb3dzID0gKHRoaXMuX25Sb3VuZHMgKyAxKSAqIDRcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICB0aGlzLl9rZXlTY2hlZHVsZVtrc1Jvd10gPSBrc1JvdyA8IGtleVNpemUgPyBrZXlXb3Jkc1trc1Jvd10gOiAodCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gMV0sIChrc1JvdyAlIGtleVNpemUpID09PSAwID8gKHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCksIHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSwgdCBePSBHLlJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNCkgOiBrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQgPyB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0gOiB2b2lkIDAsIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KVxuICB9XG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gW11cbiAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1Jvd1xuICAgIHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIChpbnZLc1JvdyAlIDQgPyAwIDogNCldXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQgPyB0IDogRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdCA+Pj4gMjRdXSBeIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0ICYgMHhmZl1dXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgdGVtcCA9IFtNWzNdLCBNWzFdXVxuICBNWzFdID0gdGVtcFswXVxuICBNWzNdID0gdGVtcFsxXVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1Yl92ZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2tleSlcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9DcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YKSB7XG4gIHZhciBrc1JvdywgczAsIHMxLCBzMiwgczMsIHQwLCB0MSwgdDIsIHQzXG5cbiAgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAga3NSb3cgPSA0XG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCB0aGlzLl9uUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYWzBdW3MwID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYWzBdW3MxID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYWzBdW3MyID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYWzBdW3MzID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgcmV0dXJuIFtcbiAgICBmaXh1cF91aW50MzIodDApLFxuICAgIGZpeHVwX3VpbnQzMih0MSksXG4gICAgZml4dXBfdWludDMyKHQyKSxcbiAgICBmaXh1cF91aW50MzIodDMpXG4gIF1cbn1cblxuZXhwb3J0cy5BRVMgPSBBRVNcbiJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-aes/EVP_BytesToKey.js":[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvRVZQX0J5dGVzVG9LZXkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIGtleUxlbiwgaXZMZW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgfVxuICBrZXlMZW4gPSBrZXlMZW4gLyA4XG4gIGl2TGVuID0gaXZMZW4gfHwgMFxuICB2YXIga2kgPSAwXG4gIHZhciBpaSA9IDBcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKVxuICB2YXIgaXYgPSBuZXcgQnVmZmVyKGl2TGVuKVxuICB2YXIgYWRkbWQgPSAwXG4gIHZhciBtZF9idWZcbiAgdmFyIGlcbiAgdmFyIGJ1ZnMgPSBbXVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChhZGRtZCsrID4gMCkge1xuICAgICAgYnVmcy5wdXNoKG1kX2J1ZilcbiAgICB9XG4gICAgYnVmcy5wdXNoKHBhc3N3b3JkKVxuICAgIG1kX2J1ZiA9IG1kNShCdWZmZXIuY29uY2F0KGJ1ZnMpKVxuICAgIGJ1ZnMgPSBbXVxuICAgIGkgPSAwXG4gICAgaWYgKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBrZXlba2krK10gPSBtZF9idWZbaV1cbiAgICAgICAga2V5TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdkxlbiA+IDAgJiYgaSAhPT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGl2TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaXZbaWkrK10gPSBtZF9idWZbaV1cbiAgICAgICAgaXZMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleUxlbiA9PT0gMCAmJiBpdkxlbiA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG1kX2J1Zi5sZW5ndGg7IGkrKykge1xuICAgIG1kX2J1ZltpXSA9IDBcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdlxuICB9XG59XG4iXX0=
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js","create-hash/md5":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js":[function(require,module,exports){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
},{"./helpers":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/helpers.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/helpers.js":[function(require,module,exports){
(function (Buffer){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvaGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoOyJdfQ==
},{"buffer":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

},{"base64-js":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/home/trevor/code-dot-org/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xorwow.js":[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xorshift7.js":[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xor4096.js":[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1104.3115.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/xor128.js":[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/tychei.js":[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"/home/trevor/code-dot-org/apps/node_modules/seedrandom/lib/alea.js":[function(require,module,exports){
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/NetSimConstants.js":[function(require,module,exports){
/**
 * @overview Constants and enums used across Internet Simulator.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxstatements: 200
 */
/* global exports */
'use strict';

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_NIBBLE = 4;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_BYTE = 8;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_KILOBYTE = 1024 * exports.BITS_PER_BYTE;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_MEGABYTE = 1024 * exports.BITS_PER_KILOBYTE;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_GIGABYTE = 1024 * exports.BITS_PER_MEGABYTE;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_KILOBIT = 1024;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_MEGABIT = 1024 * exports.BITS_PER_KILOBIT;

/**
 * @type {number}
 * @const
 */
exports.BITS_PER_GIGABIT = 1024 * exports.BITS_PER_MEGABIT;

/**
 * Types of nodes that can show up in the simulation.
 * @enum {string}
 */
exports.NodeType = {
  CLIENT: 'client',
  ROUTER: 'router'
};

/**
 * What type of message makes up the 'atom' of communication for this
 * simulator mode - single-bit messages (variant 1) or whole packets (variants
 * 2 and up)
 * @enum {string}
 */
exports.MessageGranularity = {
  PACKETS: 'packets',
  BITS: 'bits'
};

/**
 * DNS modes for the simulator.  Only applies in variant 3, when connecting
 * to a router.
 * @enum {string}
 */
exports.DnsMode = {
  /** There is no DNS node.  Everyone can see every other node's address. */
  NONE: 'none',

  /** One user acts as the DNS node at a time.  Everyone can see their own
   *  address and the DNS node's address, but nothing else. */
  MANUAL: 'manual',

  /** An automatic DNS node is added to the simulation.  Nodes are automatically
   *  registered with the DNS on connection. */
  AUTOMATIC: 'automatic'
};

/**
 * Encodings that can be used to interpret and display binary messages in
 * the simulator.
 * Map to class-names that can be applied to related table rows.
 * @enum {string}
 */
exports.EncodingType = {
  /** Renders each chunk of bits (using variable chunksize) in ascii */
  ASCII: 'ascii',

  /** Renders each chunk of bits (using variable chunksize) in decimal */
  DECIMAL: 'decimal',

  /** Renders each binary nibble as a hex character. */
  HEXADECIMAL: 'hexadecimal',

  /** All packet data is actually stored and moved around in binary, so
   *  the 'binary' encoding just represents access to that raw data. */
  BINARY: 'binary',

  /** An encoding used early in the lessons to show that binary isn't always
   *  1s and 0s.  Just like binary, but replaces 1/0 with A/B. */
  A_AND_B: 'a_and_b'
};

/**
 * Enumeration of tabs for level configuration
 * @enum {string}
 */
exports.NetSimTabType = {
  INSTRUCTIONS: 'instructions',
  MY_DEVICE: 'my_device',
  ROUTER: 'router',
  DNS: 'dns'
};

/**
 * Column types that can be used any time a packet is displayed on the page.
 * Related to Packet.HeaderType, but different because this includes columns
 * that aren't part of the header, and groups the packetInfo together.
 * Map to class-names that can be applied to related table cells.
 * @enum {string}
 */
exports.PacketUIColumnType = {
  ENCODING_LABEL: 'encodingLabel',
  TO_ADDRESS: 'toAddress',
  FROM_ADDRESS: 'fromAddress',
  PACKET_INFO: 'packetInfo',
  MESSAGE: 'message'
};

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/DashboardUser.js":[function(require,module,exports){
/**
 * @overview Interface to dashboard user data API.
 */

/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

/**
 * @typedef {Object} Section
 * @property {number} id - Section's numeric identifier in Dashboard.
 */

// TODO (bbuchanan): This whole file should go away when we have a shared
//                   Javascript User object that can be available on page load.

/**
 * Represents a Dashboard user account - could be a teacher, a student, etc.
 * @constructor
 */
var DashboardUser = module.exports = function () {
  /**
   * Indicates whether the async call has completed yet.
   * @type {boolean}
   */
  this.isReady = false;

  /**
   * Queue of callbacks to hit when this object gets initialized.
   * @type {function[]}
   * @private
   */
  this.whenReadyCallbacks_ = [];

  /**
   * User ID
   * @type {number}
   */
  this.id = undefined;

  /**
   * User display name
   * @type {string}
   */
  this.name = "";

  /**
   * Whether the user is a site admin.
   * NOTE: This should only be used in a convenience/display sense; anything
   *       requiring actual security should be authenticated through the server,
   *       and not depend on client code.
   * @type {boolean}
   */
  this.isAdmin = false;

  /**
   * List of sections owned by this user.
   * @type {Section[]}
   */
  this.ownedSections = [];
};

/**
 * @type {DashboardUser}
 * @private
 * @static
 */
DashboardUser.currentUser_ = null;

/**
 * Kick of an asynchronous request for the current user's data, and immediately
 * pass back a placeholder object that has a whenReady method others can
 * use to guarantee the data is present.
 *
 * @return {DashboardUser} that doesn't have its data yet, but will soon.
 */
DashboardUser.getCurrentUser = function () {
  if (!DashboardUser.currentUser_) {
    DashboardUser.currentUser_ = new DashboardUser();
    $.ajax({
      url: '/v2/user',
      type: 'get',
      dataType: 'json',
      success: function success(data /*, textStatus, jqXHR*/) {
        DashboardUser.currentUser_.initialize(data);
      },
      error: function error() /*jqXHR, textStatus, errorThrown*/{
        DashboardUser.currentUser_.initialize({
          isSignedIn: false
        });
      }
    });
  }
  return DashboardUser.currentUser_;
};

/**
 * Load data into user from async request, when ready.
 * @param data
 */
DashboardUser.prototype.initialize = function (data) {
  this.id = data.id;
  this.name = data.name;
  this.isAdmin = data.admin === true;
  this.ownedSections = data.owned_sections;
  this.isSignedIn = data.isSignedIn !== false;
  this.isReady = true;

  // Call any queued callbacks
  this.whenReadyCallbacks_.forEach((function (callback) {
    callback(this);
  }).bind(this));
  this.whenReadyCallbacks_.length = 0;
};

/**
 * Provide code to be called when this object is ready to use
 * Possible for it to be called immediately.
 * @param {!function} callback
 */
DashboardUser.prototype.whenReady = function (callback) {
  if (this.isReady) {
    callback(this);
  } else {
    this.whenReadyCallbacks_.push(callback);
  }
};

/**
 * Check whether the current user owns the section with the given section ID.
 * @param {number} sectionID
 * @returns {boolean}
 */
DashboardUser.prototype.ownsSection = function (sectionID) {
  return this.ownedSections.some(function (section) {
    return section.id === sectionID;
  });
};

},{}],"/home/trevor/code-dot-org/apps/build/js/netsim/ArgumentUtils.js":[function(require,module,exports){
/**
 * @overview Utilities for validating and retrieving arguments to a method.
 */
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,
 eqeqeq: true,

 maxlen: 90,
 maxparams: 4,
 maxstatements: 200
 */
'use strict';

/**
 * Makes sure the given argument is provided and passes the validation check.
 * @param {?} arg - the argument to validate
 * @param {!string} argName - Argument name (for useful error reporting)
 * @param {function(?)} [validator] - validation check to run on the argument.
 *        Defaults to no check (anything passes).
 * @returns {?} the original argument.
 * @throws {TypeError} if the argument is missing or invalid.
 */
exports.validateRequired = function (arg, argName, validator) {
  if (undefined === arg) {
    throw new TypeError(argName + ' is required.');
  } else if (typeof validator === 'function' && !validator(arg)) {
    throw new TypeError('Cannot set ' + argName + ' to ' + arg + '.');
  }
  return arg;
};

/**
 * Adds an option getter to the provided options Object that validates
 * the passed arguments and can provide default values.
 * @param {Object} optionsObject - the raw options object.  May be passed
 *        undefined (as in an omitted options object) but must not be null
 *        or a non-object type.  Not modified.
 * @returns {Object} that includes a `get` method.  Will be an object
 *          even if original optionsObject argument was undefined.
 * @throws {TypeError} if a non-object is passed to the constructor.
 * @throws {Error} if extending the object would overwrite an existing property.
 */
exports.extendOptionsObject = function (optionsObject) {
  // Allow `undefined` and all objects except for `null`
  var isUndefined = optionsObject === undefined;
  var isRealObject = typeof optionsObject === 'object' && optionsObject !== null;
  if (!(isUndefined || isRealObject)) {
    throw new TypeError('Options object must be an object.');
  }

  if (optionsObject && optionsObject.hasOwnProperty('get')) {
    throw new Error('Cannot extend options; property "get" would be overwritten.');
  }

  return $.extend({}, optionsObject, {
    /**
     * Retrieve an optional value from the options object, passing it through the
     * provided validation function, and returning the given default value if
     * the requested option was not set.
     * @param {!string} optionKey - name of the option in the raw options object.
     * @param {function(?)} [validator] - validation check to run on the value,
     *        if it has been set.  Should return TRUE if valid and FALSE otherwise.
     *        Defaults to no check (anything passes).
     * @param {?} [defaultValue] - What to return if the option was not set.
     *        Defaults to `undefined`.
     * @returns {?} The value of the option if it was set, and the provided
     *          default value if it was not set.
     * @throws {TypeError} if the validator function returns FALSE when called
     *         on the option value.
     */
    get: function get(optionKey, validator, defaultValue) {
      if (!optionsObject || optionsObject[optionKey] === undefined) {
        return defaultValue;
      }

      if (typeof validator === 'function' && !validator(optionsObject[optionKey])) {
        throw new TypeError('Cannot set ' + optionKey + ' to ' + optionsObject[optionKey] + '.');
      }

      return optionsObject[optionKey];
    }
  });
};

/**
 * Validator function that verifies that the argument is a number, is
 * greater than or equal to zero, and is not Infinity.
 * @param arg
 * @returns {boolean} TRUE if provided argument is valid.
 * @static
 */
exports.isPositiveNoninfiniteNumber = function (arg) {
  return typeof arg === 'number' && !isNaN(arg) && arg >= 0 && arg !== Infinity;
};

/**
 * Validator function that verifies that the argument is a number, is
 * greater than or equal to zero, and is not Infinity.
 * @param {?} arg
 * @returns {boolean} TRUE if provided argument is valid.
 * @static
 */
exports.isBoolean = function (arg) {
  return typeof arg === 'boolean';
};

/**
 * Validator function that verifies that the argument is a string.
 * @param {?} arg
 * @returns {boolean} TRUE if provided argument is valid.
 * @static
 */
exports.isString = function (arg) {
  return typeof arg === 'string';
};

/**
 * Validator function that verifies the argument is an array.
 * Sure this seems redundant, but included here for discoverability.
 * @param {?} arg
 * @returns {boolean} TRUE if the provided argument is an array.
 */
exports.isArray = function (arg) {
  return Array.isArray(arg);
};

/**
 * Validator function that verifies that argument is an array of strings.
 * @param {?} arg
 * @returns {boolean} TRUE if provided argument is an array and every element
 *          in the array is a string.
 * @static
 */
exports.isArrayOfStrings = function (arg) {
  return Array.isArray(arg) && arg.every(exports.isString);
};

},{}],"/home/trevor/code-dot-org/apps/build/js/RunLoop.js":[function(require,module,exports){
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
/* global window */
'use strict';

var ObservableEvent = require('./ObservableEvent');

// It is more accurate to use performance.now(), but we use Date.now()
// for compatibility with Safari and older browsers. This should only cause
// a small error in the deltaTime for the initial frame anyway.
// See Also:
// * https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame
// * https://developer.mozilla.org/en-US/docs/Web/API/Performance.now
var windowNow = window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now;

/**
 * How many ticks we try to fire every second.
 * @type {number}
 * @const
 */
var PREFERRED_TICKS_PER_SECOND = 10;

/**
 * Precalculated milliseconds per tick.
 * @type {number}
 * @const
 */
var PREFERRED_MS_PER_TICK = 1000 / PREFERRED_TICKS_PER_SECOND;

/**
 * Rendered frames per second on older browsers where we can't lock to the
 * repaint event.
 * @type {number}
 * @const
 */
var FALLBACK_FPS = 30;

/**
 * Precalculated milliseconds per frame for fallback case
 * @type {number}
 * @const
 */
var FALLBACK_MS_PER_FRAME = 1000 / FALLBACK_FPS;

/**
 * Simple run-loop manager
 * @constructor
 */
var RunLoop = module.exports = function () {

  /**
   * Whether the run-loop will continue running.
   * @type {boolean}
   */
  this.enabled = false;

  /**
   * Tracks current time and delta time for the tick loop.
   * Passed to observers when events fire.
   * @type {RunLoop.Clock}
   */
  this.tickClock = new RunLoop.Clock();

  /**
   * Tracks current time and delta time for the render loop.
   * Passed to observers when events fire.
   * @type {RunLoop.Clock}
   */
  this.renderClock = new RunLoop.Clock();

  /**
   * Method that gets called over and over, regardless of whether NetSim
   * is in focus or not.  Called less often than render().  Can be slowed
   * to about once per second when NetSim is in the background.
   * @type {Function}
   * @private
   */
  this.tick_ = this.buildTickMethod_();

  /**
   * Method that gets called over and over when NetSim is visible.  Gets as
   * close to maximum framerate as possible.  Called more often than tick(), but
   * can be paused entirely when NetSim is in the background.
   * @type {Function}
   * @private
   */
  this.render_ = this.buildRenderMethod_();

  /**  @type {ObservableEvent} */
  this.tick = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.render = new ObservableEvent();
};

/**
 * Simple tracking for time values
 * @constructor
 */
RunLoop.Clock = function () {
  /**
   * Time the current/most recent tick started, in ms.
   * Depending on browser this might be epoch time or time since load -
   *  therefore, don't use for absolute time!
   * @type {number}
   */
  this.time = windowNow();

  /**
   * Time in ms between the latest/current tick and the previous tick.
   * Precision dependent on browser capabilities.
   * @type {number}
   */
  this.deltaTime = 0;
};

RunLoop.prototype.buildTickMethod_ = function () {
  var tickMethod;
  var self = this;
  tickMethod = function () {
    if (self.enabled) {
      var curTime = windowNow();
      self.tickClock.deltaTime = curTime - self.tickClock.time;
      self.tickClock.time = curTime;
      self.tick.notifyObservers(self.tickClock);
      setTimeout(tickMethod, PREFERRED_MS_PER_TICK - self.tickClock.deltaTime);
    }
  };
  return tickMethod;
};

RunLoop.prototype.buildRenderMethod_ = function () {
  var renderMethod;
  var self = this;
  if (window.requestAnimationFrame) {
    renderMethod = function (hiResTimeStamp) {
      if (self.enabled) {
        self.renderClock.deltaTime = hiResTimeStamp - self.renderClock.time;
        self.renderClock.time = hiResTimeStamp;
        self.render.notifyObservers(self.renderClock);
        requestAnimationFrame(renderMethod);
      }
    };
  } else {
    renderMethod = function () {
      if (self.enabled) {
        var curTime = windowNow();
        self.renderClock.deltaTime = curTime - self.renderClock.time;
        self.renderClock.time = curTime;
        self.render.notifyObservers(self.renderClock);
        setTimeout(renderMethod, FALLBACK_MS_PER_FRAME - self.renderClock.deltaTime);
      }
    };
  }
  return renderMethod;
};

/** Start the run loop (runs immediately) */
RunLoop.prototype.begin = function () {
  this.enabled = true;
  this.tickClock.time = windowNow();
  this.renderClock.time = windowNow();
  this.tick_(this.tickClock.time);
  this.render_(this.renderClock.time);
};

/**
 * Stop the run loop
 * If in the middle of a tick, will finish the current tick.
 * If called by an event between ticks, will prevent the next tick from firing.
 */
RunLoop.prototype.end = function () {
  this.enabled = false;
};

},{"./ObservableEvent":"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js"}],"/home/trevor/code-dot-org/apps/build/js/ObservableEvent.js":[function(require,module,exports){
/* jshint
 funcscope: true,
 newcap: true,
 nonew: true,
 shadow: false,
 unused: true,

 maxlen: 90,
 maxparams: 3,
 maxstatements: 200
 */
'use strict';

/**
 * A subscription/notification atom, used to cleanly hook up callbacks
 * without attaching anything to the DOM or other global scope.
 * @constructor
 */
var ObservableEvent = module.exports = function () {
  /**
   * Objects observing this.
   * @type {Array}
   * @private
   */
  this.observerList_ = [];
};

/**
 * Subscribe a method to be called when notifyObservers is called.
 * @param {function} onNotify - method called when notifyObservers gets called.
 *        Will receive any arguments passed to notifyObservers.
 * @returns {Object} key - used to unregister from observable
 */
ObservableEvent.prototype.register = function (onNotify) {
  var key = { toCall: onNotify };
  Object.freeze(key);
  this.observerList_.push(key);
  return key;
};

/**
 * Unsubscribe from notifications.
 * @param {Object} keyObj - Key generated when registering
 * @returns {boolean} - Whether an unregistration actually occurred
 */
ObservableEvent.prototype.unregister = function (keyObj) {
  for (var i = 0; i < this.observerList_.length; i++) {
    if (keyObj === this.observerList_[i]) {
      this.observerList_.splice(i, 1);
      return true;
    }
  }
  return false;
};

/**
 * Call all methods subscribed to this ObservableEvent, passing through
 * any arguments.
 * @param {...} Any arguments, which are passed through to the observing
 *              functions.
 */
ObservableEvent.prototype.notifyObservers = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this.observerList_.forEach(function (observer) {
    observer.toCall.apply(undefined, args);
  });
};

},{}]},{},["/home/trevor/code-dot-org/apps/build/js/netsim/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mYWN0b3ItYnVuZGxlL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC9qcy9uZXRzaW0vbWFpbi5qcyIsImJ1aWxkL2pzL25ldHNpbS9za2lucy5qcyIsImJ1aWxkL2pzL25ldHNpbS9uZXRzaW0uanMiLCJidWlsZC9qcy9uZXRzaW0vcGFnZS5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9sZXZlbHMuanMiLCJidWlsZC9qcy9uZXRzaW0vY29udHJvbHMuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltVmlzdWFsaXphdGlvbi5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1WaXpTaW11bGF0aW9uV2lyZS5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1WaXpXaXJlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVZpelNpbXVsYXRpb25Ob2RlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVZpekF1dG9EbnNOb2RlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVZpek5vZGUuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltVml6RWxlbWVudC5qcyIsImJ1aWxkL2pzL25ldHNpbS90d2VlbnMuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltVmlzdWFsaXphdGlvbi5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1UYWJzQ29tcG9uZW50LmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVRhYnNDb21wb25lbnQuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltU3RhdHVzUGFuZWwuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltU3RhdHVzUGFuZWwuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltU2hhcmQuanMiLCJidWlsZC9qcy9uZXRzaW0vUHViU3ViU2VydmljZS5qcyIsImJ1aWxkL2pzL25ldHNpbS9QdWJTdWJDaGFubmVsLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVRhYmxlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVNlbmRQYW5lbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1TZW5kUGFuZWwuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUm91dGVyVGFiLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVJvdXRlclRhYi5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1Sb3V0ZXJTdGF0c1RhYmxlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVJvdXRlclN0YXRzVGFibGUuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUm91dGVyTG9nTW9kYWwuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUm91dGVyTG9nTW9kYWwuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUGFja2V0U2l6ZUNvbnRyb2wuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUGFja2V0RWRpdG9yLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVBhY2tldEVkaXRvci5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1NeURldmljZVRhYi5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1QdWxzZVJhdGVDb250cm9sLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbU15RGV2aWNlVGFiLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbU1ldHJvbm9tZS5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1NZXRyb25vbWUuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltTWVtb3J5Q29udHJvbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1Mb2dQYW5lbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1Mb2dQYW5lbC5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1Mb2dQYWNrZXQuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltTG9jYWxDbGllbnROb2RlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbUxvYmJ5LmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltU2hhcmRTZWxlY3Rpb25QYW5lbC5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbU5vZGVGYWN0b3J5LmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVJvdXRlck5vZGUuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltTWVzc2FnZS5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1Mb2dFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwiYnVpbGQvanMvbmV0c2ltL1BhY2tldC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1EbnNUYWIuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltRG5zVGFibGUuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltRG5zVGFibGUuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltRG5zVGFiLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbURuc01vZGVDb250cm9sLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbURuc01vZGVDb250cm9sLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbURuc01hbnVhbENvbnRyb2wuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltRG5zTWFudWFsQ29udHJvbC5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1DbGllbnROb2RlLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbU5vZGUuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltV2lyZS5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1FbnRpdHkuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltQ2h1bmtTaXplQ29udHJvbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1CaXRSYXRlQ29udHJvbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1CaXRMb2dQYW5lbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1QYW5lbC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1QYW5lbC5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1FbmNvZGluZ0NvbnRyb2wuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltRW5jb2RpbmdDb250cm9sLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbUJpdExvZ1BhbmVsLmh0bWwuZWpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbUJhbmR3aWR0aENvbnRyb2wuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltU2xpZGVyLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbVNsaWRlci5odG1sLmVqcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1BcGkuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltQXBpRXJyb3IuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltQWxlcnQuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltQWxlcnQuaHRtbC5lanMiLCJidWlsZC9qcy9uZXRzaW0vRGF0YUNvbnZlcnRlcnMuanMiLCJub2RlX21vZHVsZXMvQmFzZTY0L2Jhc2U2NC5qcyIsImJ1aWxkL2pzL25ldHNpbS9OZXRTaW1VdGlscy5qcyIsImJ1aWxkL2pzL25ldHNpbS9sb2NhbGUuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltTG9nZ2VyLmpzIiwiYnVpbGQvanMvbmV0c2ltL05ldFNpbUdsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3ByaXZhdGVEZWNyeXB0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC94b3IuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9FVlBfQnl0ZXNUb0tleS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9wZW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL3BlbS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvcmVwb3J0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9hcGkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2Flc2lkLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbWdmLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvcHJpbWVzLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9kaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL25vZGVfbW9kdWxlcy9taWxsZXItcmFiaW4vbGliL21yLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9ub2RlX21vZHVsZXMvbWlsbGVyLXJhYmluL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2htYWMtZHJiZy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMva2V5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9zaG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi92ZXJpZnkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Bia2RmMi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvZml4UHJvYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL0VWUF9CeXRlc1RvS2V5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9hc24xLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL3JlcG9ydGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9hZXNpZC5qc29uIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9obWFjLWRyYmcuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2FsZ29zLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmI4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIxLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NiYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvY2lwaGVyQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9FVlBfQnl0ZXNUb0tleS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL2FsZWEuanMiLCJidWlsZC9qcy9uZXRzaW0vTmV0U2ltQ29uc3RhbnRzLmpzIiwiYnVpbGQvanMvbmV0c2ltL0Rhc2hib2FyZFVzZXIuanMiLCJidWlsZC9qcy9uZXRzaW0vQXJndW1lbnRVdGlscy5qcyIsImJ1aWxkL2pzL1J1bkxvb3AuanMiLCJidWlsZC9qcy9PYnNlcnZhYmxlRXZlbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNwQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ2xELElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQzs7QUFFakMsSUFBSSxNQUFNLEdBQUcsT0FB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QUM5RCxDQUFDOzs7Ozs7QUFNRiw4QkFBOEIsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBWTtBQUN0RSxNQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQzlELENBQUM7OztBQ3RZRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0NBQ2xFLENBQUM7OztBQ3BPRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM21HQSxZQUFZLENBQUM7O0FBRWIsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzNDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2pELElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFTL0MsSUFBSSxNQUFNLEdBQUcsTUFBTSxD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LENBQUM7R0FDOUM7O0NBRUYsQ0FBQzs7O0FDMUpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1d0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzM0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25HQSxZQUFZLENBQUM7Ozs7OztBQU1iLE9BQU8sQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7QUFNNUIsT0FBTyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7Ozs7OztBQU0xQixPQUFPLENBQUMsaUJBQWlCLEdB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QWUsR0FBRyxZQUFZO0FBQ3RELE1BQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBRSxTQUFTLEVBQUUsQ0FBQyxDQUFFLENBQUM7QUFDdEQsTUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxRQUFRLEVBQUU7QUFDN0MsWUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0dBQ3hDLENBQUMsQ0FBQztDQUNKLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGFwcE1haW4gPSByZXF1aXJlKCcuLi9hcHBNYWluJyk7XG52YXIgc3R1ZGlvQXBwID0gcmVxdWlyZSgnLi4vU3R1ZGlvQXBwJykuc2luZ2xldG9uO1xudmFyIE5ldFNpbSA9IHJlcXVpcmUoJy4vbmV0c2ltJyk7XG5cbnZhciBsZXZlbHMgPSByZXF1aXJlKCcuL2xldmVscycpO1xudmFyIHNraW5zID0gcmVxdWlyZSgnLi9za2lucycpO1xuXG53aW5kb3cubmV0c2ltTWFpbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5za2luc01vZHVsZSA9IHNraW5zO1xuICBvcHRpb25zLmlzRWRpdG9ybGVzcyA9IHRydWU7XG5cbiAgdmFyIG5ldFNpbSA9IG5ldyBOZXRTaW0oKTtcbiAgbmV0U2ltLmluamVjdFN0dWRpb0FwcChzdHVkaW9BcHApO1xuICBhcHBNYWluKG5ldFNpbSwgbGV2ZWxzLCBvcHRpb25zKTtcbn07XG4iLCJ2YXIgc2tpbkJhc2UgPSByZXF1aXJlKCcuLi9za2lucycpO1xuXG5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAoYXNzZXRVcmwsIGlkKSB7XG4gIHZhciBza2luID0gc2tpbkJhc2UubG9hZChhc3NldFVybCwgaWQpO1xuICByZXR1cm4gc2tpbjtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBJbnRlcm5ldCBTaW11bGF0b3IgYXBwIGZvciBDb2RlLm9yZy5cbiAqICAgICAgICAgICBUaGlzIGZpbGUgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBJbnRlcm5ldCBTaW11bGF0b3IuXG4gKi9cblxuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiovXG4vKiBnbG9iYWwgLUJsb2NrbHkgKi9cbi8qIGdsb2JhbCBzZW5kUmVwb3J0ICovXG4vKiBnbG9iYWwgY29uZmlybSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcbnZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBPYnNlcnZhYmxlRXZlbnQgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlRXZlbnQnKTtcbnZhciBSdW5Mb29wID0gcmVxdWlyZSgnLi4vUnVuTG9vcCcpO1xudmFyIHBhZ2UgPSByZXF1aXJlKCcuL3BhZ2UuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1BbGVydCA9IHJlcXVpcmUoJy4vTmV0U2ltQWxlcnQnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIERhc2hib2FyZFVzZXIgPSByZXF1aXJlKCcuL0Rhc2hib2FyZFVzZXInKTtcbnZhciBOZXRTaW1CaXRMb2dQYW5lbCA9IHJlcXVpcmUoJy4vTmV0U2ltQml0TG9nUGFuZWwnKTtcbnZhciBOZXRTaW1Mb2JieSA9IHJlcXVpcmUoJy4vTmV0U2ltTG9iYnknKTtcbnZhciBOZXRTaW1Mb2NhbENsaWVudE5vZGUgPSByZXF1aXJlKCcuL05ldFNpbUxvY2FsQ2xpZW50Tm9kZScpO1xudmFyIE5ldFNpbUxvZ2dlciA9IHJlcXVpcmUoJy4vTmV0U2ltTG9nZ2VyJyk7XG52YXIgTmV0U2ltTG9nUGFuZWwgPSByZXF1aXJlKCcuL05ldFNpbUxvZ1BhbmVsJyk7XG52YXIgTmV0U2ltUm91dGVyTG9nTW9kYWwgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlckxvZ01vZGFsJyk7XG52YXIgTmV0U2ltUm91dGVyTm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltUm91dGVyTm9kZScpO1xudmFyIE5ldFNpbVNlbmRQYW5lbCA9IHJlcXVpcmUoJy4vTmV0U2ltU2VuZFBhbmVsJyk7XG52YXIgTmV0U2ltU2hhcmQgPSByZXF1aXJlKCcuL05ldFNpbVNoYXJkJyk7XG52YXIgTmV0U2ltU3RhdHVzUGFuZWwgPSByZXF1aXJlKCcuL05ldFNpbVN0YXR1c1BhbmVsJyk7XG52YXIgTmV0U2ltVGFic0NvbXBvbmVudCA9IHJlcXVpcmUoJy4vTmV0U2ltVGFic0NvbXBvbmVudCcpO1xudmFyIE5ldFNpbVZpc3VhbGl6YXRpb24gPSByZXF1aXJlKCcuL05ldFNpbVZpc3VhbGl6YXRpb24nKTtcblxudmFyIERuc01vZGUgPSBOZXRTaW1Db25zdGFudHMuRG5zTW9kZTtcbnZhciBNZXNzYWdlR3JhbnVsYXJpdHkgPSBOZXRTaW1Db25zdGFudHMuTWVzc2FnZUdyYW51bGFyaXR5O1xuXG52YXIgbG9nZ2VyID0gTmV0U2ltTG9nZ2VyLmdldFNpbmdsZXRvbigpO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcblxuLyoqXG4gKiBUaGUgdG9wLWxldmVsIEludGVybmV0IFNpbXVsYXRvciBjb250cm9sbGVyLlxuICogQHBhcmFtIHtTdHVkaW9BcHB9IHN0dWRpb0FwcCBUaGUgc3R1ZGlvQXBwIGluc3RhbmNlIHRvIGJ1aWxkIHVwb24uXG4gKi9cbnZhciBOZXRTaW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLnNraW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufVxuICAgKi9cbiAgdGhpcy5sZXZlbCA9IHt9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5oZWFkaW5nID0gMDtcblxuICAvKipcbiAgICogQ3VycmVudCB1c2VyIG9iamVjdCB3aGljaCBhc3luY2hyb25vdXNseSBncmFicyB0aGUgY3VycmVudCB1c2VyJ3NcbiAgICogaW5mbyBmcm9tIHRoZSBkYXNoYm9hcmQgQVBJLlxuICAgKiBAdHlwZSB7RGFzaGJvYXJkVXNlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY3VycmVudFVzZXJfID0gRGFzaGJvYXJkVXNlci5nZXRDdXJyZW50VXNlcigpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3NvciBvYmplY3QgZm9yIHNlbGVjdCBzaW11bGF0aW9uIHNoYXJkJ3MgdGFibGVzLCB3aGVyZSBhbiBzaGFyZFxuICAgKiBpcyBhIGdyb3VwIG9mIHRhYmxlcyBzaGFyZWQgYnkgYSBncm91cCBvZiB1c2VycywgYWxsb3dpbmcgdGhlbSB0byBvYnNlcnZlXG4gICAqIGEgY29tbW9uIG5ldHdvcmsgc3RhdGUuXG4gICAqXG4gICAqIFNlZSBlbi53aWtpcGVkaWEub3JnL3dpa2kvSW5zdGFuY2VfZHVuZ2VvbiBmb3IgYSBwb3B1bGFyIGV4YW1wbGUgb2YgdGhpc1xuICAgKiBjb25jZXB0LlxuICAgKlxuICAgKiBAdHlwZSB7TmV0U2ltU2hhcmR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNoYXJkXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBjbGllbnQncyBub2RlIHJlcHJlc2VudGF0aW9uIHdpdGhpbiB0aGUgc2hhcmQuXG4gICAqIEB0eXBlIHtOZXRTaW1Mb2NhbENsaWVudE5vZGV9XG4gICAqL1xuICB0aGlzLm15Tm9kZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRpY2sgYW5kIFJlbmRlciBsb29wIG1hbmFnZXIgZm9yIHRoZSBzaW11bGF0b3JcbiAgICogQHR5cGUge1J1bkxvb3B9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJ1bkxvb3BfID0gbmV3IFJ1bkxvb3AoKTtcblxuICAvKipcbiAgICogQ3VycmVudCBjaHVuayBzaXplIChieXRlc2l6ZSlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2h1bmtTaXplXyA9IDg7XG5cbiAgLyoqXG4gICAqIFRoZSBcIm15IGRldmljZVwiIGJpdHJhdGUgaW4gYml0cyBwZXIgc2Vjb25kXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm15RGV2aWNlQml0UmF0ZV8gPSBJbmZpbml0eTtcblxuICAvKipcbiAgICogQ3VycmVudGx5IGVuYWJsZWQgZW5jb2RpbmcgdHlwZXMuXG4gICAqIEB0eXBlIHtFbmNvZGluZ1R5cGVbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZW5hYmxlZEVuY29kaW5nc18gPSBbXTtcblxuICAvKipcbiAgICogQ3VycmVudCBkbnMgbW9kZS5cbiAgICogQHR5cGUge0Ruc01vZGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRuc01vZGVfID0gRG5zTW9kZS5OT05FO1xuXG4gIC8vIC0tIENvbXBvbmVudHMgLS1cbiAgLyoqXG4gICAqIEB0eXBlIHtJTmV0U2ltTG9nUGFuZWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlY2VpdmVkTWVzc2FnZUxvZ18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7SU5ldFNpbUxvZ1BhbmVsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zZW50TWVzc2FnZUxvZ18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFdmVudDogQ29ubmVjdGVkIHRvLCBvciBkaXNjb25uZWN0ZWQgZnJvbSwgYSBzaGFyZC5cbiAgICogU3BlY2lmaWNhbGx5LCBhZGRlZCBvciByZW1vdmVkIG91ciBjbGllbnQgbm9kZSBmcm9tIHRoZSBzaGFyZCdzIG5vZGUgdGFibGUuXG4gICAqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9XG4gICAqL1xuICB0aGlzLnNoYXJkQ2hhbmdlID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuICB0aGlzLnNoYXJkQ2hhbmdlLnJlZ2lzdGVyKHRoaXMub25TaGFyZENoYW5nZV8uYmluZCh0aGlzKSk7XG5cbiAgLyoqXG4gICAqIFVudHlwZWQgc3RvcmFnZSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggZXZlbnRzIHdlIGhhdmUgY3VycmVudGx5IGJvdW5kLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5ldmVudEtleXMgPSB7fTtcbn07XG5cbk5ldFNpbS5wcm90b3R5cGUuaW5qZWN0U3R1ZGlvQXBwID0gZnVuY3Rpb24gKHN0dWRpb0FwcCkge1xuICB0aGlzLnN0dWRpb0FwcF8gPSBzdHVkaW9BcHA7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBwYWdlIGxvYWQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnNraW5cbiAqIEBwYXJhbSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufSBjb25maWcubGV2ZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcucmFja0VudiAtIGRldmVsb3BtZW50L3Byb2R1Y3Rpb24vZXRjLlxuICogQHBhcmFtIHtib29sZWFufSBjb25maWcuZW5hYmxlU2hvd0NvZGUgLSBBbHdheXMgZmFsc2UgZm9yIE5ldFNpbVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZmlnLmxvYWRBdWRpb1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5odG1sIC0gcmVuZGVyZWQgbWFya3VwIHRvIGJlIGNyZWF0ZWQgaW5zaWRlIHRoaXMgbWV0aG9kXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBpZiAoIXRoaXMuc3R1ZGlvQXBwXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldFNpbSByZXF1aXJlcyBhIFN0dWRpb0FwcFwiKTtcbiAgfVxuXG4gIC8vIFNldCB1cCBnbG9iYWwgc2luZ2xldG9uIGZvciBlYXN5IGFjY2VzcyB0byBzaW11bGF0b3Itd2lkZSBzZXR0aW5nc1xuICBOZXRTaW1HbG9iYWxzLnNldFJvb3RDb250cm9sbGVycyh0aGlzLnN0dWRpb0FwcF8sIHRoaXMpO1xuXG4gIC8vIFJlbW92ZSBpY29uIGZyb20gYWxsIE5ldFNpbSBpbnN0cnVjdGlvbnMgZGlhbG9nc1xuICBjb25maWcuc2tpbi5zdGF0aWNBdmF0YXIgPSBudWxsO1xuICBjb25maWcuc2tpbi5zbWFsbFN0YXRpY0F2YXRhciA9IG51bGw7XG4gIGNvbmZpZy5za2luLmZhaWx1cmVBdmF0YXIgPSBudWxsO1xuICBjb25maWcuc2tpbi53aW5BdmF0YXIgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTa2luIGZvciB0aGUgbG9hZGVkIGxldmVsXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLnNraW4gPSBjb25maWcuc2tpbjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGxvYWRlZCBsZXZlbFxuICAgKiBAdHlwZSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufVxuICAgKi9cbiAgdGhpcy5sZXZlbCA9IE5ldFNpbVV0aWxzLnNjcnViTGV2ZWxDb25maWd1cmF0aW9uXyhjb25maWcubGV2ZWwpO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IG9wZXJhdGluZyBlbnZpcm9ubWVudCwgdXNlZCB0byBkcml2ZSBjZXJ0YWluIGNvbmZpZ3VyYXRpb24uXG4gICAqIEB0eXBlIHtzdHJpbmd9IG9uZSBvZiBcImRldmVsb3BtZW50XCJ8XCJzdGFnaW5nXCJ8XCJ0ZXN0XCJ8XCJwcm9kdWN0aW9uXCJcbiAgICovXG4gIHRoaXMuZW52aXJvbm1lbnQgPSBjb25maWcucmFja0VudjtcblxuICAvKipcbiAgICogV2hldGhlciBOZXRTaW0gc2hvdWxkIHN1YnNjcmliZSB0byBldmVudHMgdXNpbmcgUHVzaGVyLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMudXNlUHVzaGVyID0gY29uZmlnLnVzZVB1c2hlcjtcblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBhcHBsaWNhdGlvbiBrZXkgZm9yIHRoZSBQdXNoZXIgc2VydmljZS4gKE5vdCB1c2VkIGlmIG5vdCB1c2luZ1xuICAgKiBQdXNoZXIpLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5wdXNoZXJBcHBsaWNhdGlvbktleSA9IGNvbmZpZy5wdXNoZXJBcHBsaWNhdGlvbktleTtcblxuICAvKipcbiAgICogVGhlIHN0cmljdCBtYXhpbXVtIG51bWJlciBvZiByb3V0ZXJzIHBlciBzaGFyZC4gIE5vdGUgdGhlIHJlYWwgbWF4aW11bVxuICAgKiBtYXkgYmUgbG93ZXIgaWYgYm91bmRlZCBieSBhZGRyZXNzYWJsZSBzcGFjZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZ2xvYmFsTWF4Um91dGVycyA9IGNvbmZpZy5uZXRzaW1NYXhSb3V0ZXJzO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciByZXBvcnRpbmcgbGV2ZWwgY29tcGxldGlvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5yZXBvcnRpbmdJbmZvXyA9IGNvbmZpZy5yZXBvcnQ7XG5cbiAgY29uZmlnLmh0bWwgPSBwYWdlKHtcbiAgICBhc3NldFVybDogdGhpcy5zdHVkaW9BcHBfLmFzc2V0VXJsLFxuICAgIGRhdGE6IHtcbiAgICAgIHZpc3VhbGl6YXRpb246ICcnLFxuICAgICAgbG9jYWxlRGlyZWN0aW9uOiB0aGlzLnN0dWRpb0FwcF8ubG9jYWxlRGlyZWN0aW9uKCksXG4gICAgICBjb250cm9sczogcmVxdWlyZSgnLi9jb250cm9scy5odG1sLmVqcycpKHthc3NldFVybDogdGhpcy5zdHVkaW9BcHBfLmFzc2V0VXJsfSlcbiAgICB9LFxuICAgIGhpZGVSdW5CdXR0b246IHRydWVcbiAgfSk7XG5cbiAgY29uZmlnLmVuYWJsZVNob3dDb2RlID0gZmFsc2U7XG4gIGNvbmZpZy5waW5Xb3Jrc3BhY2VUb0JvdHRvbSA9IHRydWU7XG4gIGNvbmZpZy5sb2FkQXVkaW8gPSB0aGlzLmxvYWRBdWRpb18uYmluZCh0aGlzKTtcblxuICAvLyBPdmVycmlkZSBjZXJ0YWluIFN0dWRpb0FwcCBtZXRob2RzIC0gbmV0c2ltIGRvZXMgYSBsb3Qgb2YgY29uZmlndXJhdGlvblxuICAvLyBpdHNlbGYsIGJlY2F1c2Ugb2YgaXRzIG5vbnN0YW5kYXJkIGxheW91dC5cbiAgdGhpcy5zdHVkaW9BcHBfLmNvbmZpZ3VyZURvbSA9IE5ldFNpbS5jb25maWd1cmVEb21PdmVycmlkZV8uYmluZCh0aGlzLnN0dWRpb0FwcF8pO1xuICB0aGlzLnN0dWRpb0FwcF8ub25SZXNpemUgPSBOZXRTaW0ub25SZXNpemVPdmVycmlkZV8uYmluZCh0aGlzLnN0dWRpb0FwcF8pO1xuXG4gIHRoaXMuc3R1ZGlvQXBwXy5pbml0KGNvbmZpZyk7XG5cbiAgLy8gQ3JlYXRlIG5ldHNpbSBsb2JieSB3aWRnZXQgaW4gcGFnZVxuICB0aGlzLmN1cnJlbnRVc2VyXy53aGVuUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW5pdFdpdGhVc2VyXyh0aGlzLmN1cnJlbnRVc2VyXyk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gQmVnaW4gdGhlIG1haW4gc2ltdWxhdGlvbiBsb29wXG4gIHRoaXMucnVuTG9vcF8udGljay5yZWdpc3Rlcih0aGlzLnRpY2suYmluZCh0aGlzKSk7XG4gIHRoaXMucnVuTG9vcF8uYmVnaW4oKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtSdW5Mb29wLkNsb2NrfSBjbG9ja1xuICovXG5OZXRTaW0ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgaWYgKHRoaXMuaXNDb25uZWN0ZWRUb1NoYXJkKCkpIHtcbiAgICB0aGlzLm15Tm9kZS50aWNrKGNsb2NrKTtcbiAgICB0aGlzLnNoYXJkXy50aWNrKGNsb2NrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQdWxsIGFuIGlkZW50aWZpZXIgZnJvbSB0aGUgVVJMIHRoYXQgc2VwYXJhdGVzIHRoaXMgbGV2ZWwncyBzaGFyZCBmcm9tIG90aGVycy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuZ2V0VW5pcXVlTGV2ZWxLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoMSkucmVwbGFjZSgvXFxXL2csICctJyk7XG59O1xuXG4vKipcbiAqIEV4dHJhY3RzIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSBhIGZ1bGwgVVJMIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBzaW1wbGVcbiAqIG9iamVjdC5cbiAqIEByZXR1cm5zIHsqfVxuICovXG5OZXRTaW0ucHJvdG90eXBlLmdldE92ZXJyaWRlU2hhcmRJRCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcnRzID0gbG9jYXRpb24uc2VhcmNoLnNwbGl0KCc/Jyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHNoYXJkSUQ7XG4gIHBhcnRzWzFdLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgIGlmIChzaWRlcy5sZW5ndGggPiAxICYmIHNpZGVzWzBdID09PSAncycpIHtcbiAgICAgIHNoYXJkSUQgPSBzaWRlc1sxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2hhcmRJRDtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgdGhlIGxldmVsIGlzIGNvbmZpZ3VyZWQgdG8gc2hvdyBhbnkgdGFicy5cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5zaG91bGRTaG93QW55VGFicyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGV2ZWwuc2hvd1RhYnMubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gdGhhdCBjYW4gaGFwcGVuIG9uY2Ugd2UgaGF2ZSBhIHVzZXIgbmFtZS5cbiAqIENvdWxkIGNvbGxhcHNlIHRoaXMgYmFjayBpbnRvIGluaXQgaWYgYXQgc29tZSBwb2ludCB3ZSBjYW4gZ3VhcmFudGVlIHRoYXRcbiAqIHVzZXIgbmFtZSBpcyBhdmFpbGFibGUgb24gbG9hZC5cbiAqIEBwYXJhbSB7RGFzaGJvYXJkVXNlcn0gdXNlclxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5pbml0V2l0aFVzZXJfID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgdGhpcy5tYWluQ29udGFpbmVyXyA9ICQoJyNuZXRzaW0nKTtcblxuICAvLyBDcmVhdGUgbG9nIHBhbmVscyBhY2NvcmRpbmcgdG8gbGV2ZWwgY29uZmlndXJhdGlvblxuICBpZiAodGhpcy5sZXZlbC5tZXNzYWdlR3JhbnVsYXJpdHkgPT09IE1lc3NhZ2VHcmFudWxhcml0eS5QQUNLRVRTKSB7XG4gICAgdGhpcy5yZWNlaXZlZE1lc3NhZ2VMb2dfID0gbmV3IE5ldFNpbUxvZ1BhbmVsKCQoJyNuZXRzaW0tcmVjZWl2ZWQnKSwge1xuICAgICAgbG9nVGl0bGU6IGkxOG4ucmVjZWl2ZWRNZXNzYWdlTG9nKCksXG4gICAgICBpc01pbmltaXplZDogZmFsc2UsXG4gICAgICBoYXNVbnJlYWRNZXNzYWdlczogdHJ1ZSxcbiAgICAgIHBhY2tldFNwZWM6IHRoaXMubGV2ZWwuY2xpZW50SW5pdGlhbFBhY2tldEhlYWRlclxuICAgIH0pO1xuXG4gICAgdGhpcy5zZW50TWVzc2FnZUxvZ18gPSBuZXcgTmV0U2ltTG9nUGFuZWwoJCgnI25ldHNpbS1zZW50JyksIHtcbiAgICAgIGxvZ1RpdGxlOiBpMThuLnNlbnRNZXNzYWdlTG9nKCksXG4gICAgICBpc01pbmltaXplZDogdHJ1ZSxcbiAgICAgIGhhc1VucmVhZE1lc3NhZ2VzOiBmYWxzZSxcbiAgICAgIHBhY2tldFNwZWM6IHRoaXMubGV2ZWwuY2xpZW50SW5pdGlhbFBhY2tldEhlYWRlclxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMubGV2ZWwubWVzc2FnZUdyYW51bGFyaXR5ID09PSBNZXNzYWdlR3JhbnVsYXJpdHkuQklUUykge1xuICAgIHRoaXMucmVjZWl2ZWRNZXNzYWdlTG9nXyA9IG5ldyBOZXRTaW1CaXRMb2dQYW5lbCgkKCcjbmV0c2ltLXJlY2VpdmVkJyksIHtcbiAgICAgIGxvZ1RpdGxlOiBpMThuLnJlY2VpdmVCaXRzKCksXG4gICAgICBpc01pbmltaXplZDogZmFsc2UsXG4gICAgICBuZXRzaW06IHRoaXMsXG4gICAgICBzaG93UmVhZFdpcmVCdXR0b246IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuc2VudE1lc3NhZ2VMb2dfID0gbmV3IE5ldFNpbUJpdExvZ1BhbmVsKCQoJyNuZXRzaW0tc2VudCcpLCB7XG4gICAgICBsb2dUaXRsZTogaTE4bi5zZW50Qml0c0xvZygpLFxuICAgICAgaXNNaW5pbWl6ZWQ6IGZhbHNlLFxuICAgICAgbmV0c2ltOiB0aGlzXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN0YXR1c1BhbmVsXyA9IG5ldyBOZXRTaW1TdGF0dXNQYW5lbChcbiAgICAgICQoJyNuZXRzaW0tc3RhdHVzJyksXG4gICAgICB7XG4gICAgICAgIGRpc2Nvbm5lY3RDYWxsYmFjazogdGhpcy5kaXNjb25uZWN0RnJvbVJlbW90ZS5iaW5kKHRoaXMsIGZ1bmN0aW9uICgpIHt9KVxuICAgICAgfSk7XG5cbiAgdGhpcy5yb3V0ZXJMb2dNb2RhbF8gPSBuZXcgTmV0U2ltUm91dGVyTG9nTW9kYWwoJCgnI3JvdXRlci1sb2ctbW9kYWwnKSk7XG5cbiAgdGhpcy52aXN1YWxpemF0aW9uXyA9IG5ldyBOZXRTaW1WaXN1YWxpemF0aW9uKCQoJyNuZXRzaW0tdmlzdWFsaXphdGlvbicpLFxuICAgICAgdGhpcy5ydW5Mb29wXyk7XG5cbiAgLy8gTG9iYnkgcGFuZWw6IENvbnRyb2xzIGZvciBwaWNraW5nIGEgcmVtb3RlIG5vZGUgYW5kIGNvbm5lY3RpbmcgdG8gaXQuXG4gIHRoaXMubG9iYnlfID0gbmV3IE5ldFNpbUxvYmJ5KFxuICAgICAgJCgnLmxvYmJ5LXBhbmVsJyksXG4gICAgICB0aGlzLCB7XG4gICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgIGxldmVsS2V5OiB0aGlzLmdldFVuaXF1ZUxldmVsS2V5KCksXG4gICAgICAgIHNoYXJlZFNoYXJkU2VlZDogdGhpcy5nZXRPdmVycmlkZVNoYXJkSUQoKVxuICAgICAgfSk7XG5cbiAgLy8gVGFiIHBhbmVsIC0gY29udGFpbnMgaW5zdHJ1Y3Rpb25zLCBteSBkZXZpY2UsIHJvdXRlciwgZG5zXG4gIGlmICh0aGlzLnNob3VsZFNob3dBbnlUYWJzKCkpIHtcbiAgICB0aGlzLnRhYnNfID0gbmV3IE5ldFNpbVRhYnNDb21wb25lbnQoXG4gICAgICAgICQoJyNuZXRzaW0tdGFicycpLFxuICAgICAgICB0aGlzLnJ1bkxvb3BfLFxuICAgICAgICB7XG4gICAgICAgICAgY2h1bmtTaXplU2xpZGVyQ2hhbmdlQ2FsbGJhY2s6IHRoaXMuc2V0Q2h1bmtTaXplLmJpbmQodGhpcyksXG4gICAgICAgICAgbXlEZXZpY2VCaXRSYXRlQ2hhbmdlQ2FsbGJhY2s6IHRoaXMuc2V0TXlEZXZpY2VCaXRSYXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgZW5jb2RpbmdDaGFuZ2VDYWxsYmFjazogdGhpcy5jaGFuZ2VFbmNvZGluZ3MuYmluZCh0aGlzKSxcbiAgICAgICAgICByb3V0ZXJCYW5kd2lkdGhTbGlkZXJDaGFuZ2VDYWxsYmFjazogdGhpcy5zZXRSb3V0ZXJCYW5kd2lkdGguYmluZCh0aGlzKSxcbiAgICAgICAgICByb3V0ZXJCYW5kd2lkdGhTbGlkZXJTdG9wQ2FsbGJhY2s6IHRoaXMuY2hhbmdlUmVtb3RlUm91dGVyQmFuZHdpZHRoLmJpbmQodGhpcyksXG4gICAgICAgICAgcm91dGVyTWVtb3J5U2xpZGVyQ2hhbmdlQ2FsbGJhY2s6IHRoaXMuc2V0Um91dGVyTWVtb3J5LmJpbmQodGhpcyksXG4gICAgICAgICAgcm91dGVyTWVtb3J5U2xpZGVyU3RvcENhbGxiYWNrOiB0aGlzLmNoYW5nZVJlbW90ZVJvdXRlck1lbW9yeS5iaW5kKHRoaXMpLFxuICAgICAgICAgIGRuc01vZGVDaGFuZ2VDYWxsYmFjazogdGhpcy5jaGFuZ2VSZW1vdGVEbnNNb2RlLmJpbmQodGhpcyksXG4gICAgICAgICAgYmVjb21lRG5zQ2FsbGJhY2s6IHRoaXMuYmVjb21lRG5zTm9kZS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIHRoaXMudGFic18uYXR0YWNoVG9SdW5Mb29wKHRoaXMucnVuTG9vcF8pO1xuICB9XG5cbiAgdGhpcy5zZW5kUGFuZWxfID0gbmV3IE5ldFNpbVNlbmRQYW5lbCgkKCcjbmV0c2ltLXNlbmQnKSwgdGhpcy5sZXZlbCxcbiAgICAgIHRoaXMpO1xuXG4gIHRoaXMuY2hhbmdlRW5jb2RpbmdzKHRoaXMubGV2ZWwuZGVmYXVsdEVuYWJsZWRFbmNvZGluZ3MpO1xuICB0aGlzLnNldENodW5rU2l6ZSh0aGlzLmxldmVsLmRlZmF1bHRDaHVua1NpemVCaXRzKTtcbiAgdGhpcy5zZXRNeURldmljZUJpdFJhdGUodGhpcy5sZXZlbC5kZWZhdWx0Qml0UmF0ZUJpdHNQZXJTZWNvbmQpO1xuICB0aGlzLnNldFJvdXRlckJhbmR3aWR0aCh0aGlzLmxldmVsLmRlZmF1bHRSb3V0ZXJCYW5kd2lkdGgpO1xuICB0aGlzLnNldFJvdXRlck1lbW9yeSh0aGlzLmxldmVsLmRlZmF1bHRSb3V0ZXJNZW1vcnkpO1xuICB0aGlzLnNldERuc01vZGUodGhpcy5sZXZlbC5kZWZhdWx0RG5zTW9kZSk7XG4gIHRoaXMucmVuZGVyKCk7XG5cbiAgLy8gVHJ5IGFuZCBncmFjZWZ1bGx5IGRpc2Nvbm5lY3Qgd2hlbiBjbG9zaW5nIHRoZSB3aW5kb3dcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25CZWZvcmVVbmxvYWRfLmJpbmQodGhpcykpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgdGhpcy5vblVubG9hZF8uYmluZCh0aGlzKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfLmRlYm91bmNlKHRoaXMudXBkYXRlTGF5b3V0LmJpbmQodGhpcyksIDI1MCkpO1xufTtcblxuLyoqXG4gKiBCZWZvcmUtdW5sb2FkIGhhbmRsZXIsIHVzZWQgdG8gd2FybiB0aGUgdXNlciAoaWYgbmVjZXNzYXJ5KSBvZiB3aGF0IHRoZXlcbiAqIGFyZSBhYmFuZG9uaW5nIGlmIHRoZXkgbmF2aWdhdGUgYXdheSBmcm9tIHRoZSBwYWdlLlxuICpcbiAqIFRoaXMgZXZlbnQgaGFzIHNvbWUgd2VpcmQgc3BlY2lhbCBwcm9wZXJ0aWVzIGFuZCBpbmNvbnNpc3RlbnQgYmVoYXZpb3JcbiAqIGFjcm9zcyBicm93c2Vyc1xuICpcbiAqIFNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy9iZWZvcmV1bmxvYWRcbiAqIGh0dHA6Ly93d3cuemFjaGxlYXQuY29tL3dlYi9kb250LWxldC10aGUtZG9vci1oaXQteW91LW9udW5sb2FkLWFuZC1vbmJlZm9yZXVubG9hZC9cbiAqIGh0dHA6Ly93d3cuaHVubG9jay5jb20vYmxvZ3MvTWFzdGVyaW5nX1RoZV9CYWNrX0J1dHRvbl9XaXRoX0phdmFzY3JpcHRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IElmIHdlIHdhbnQgdG8gd2FybiB0aGUgdXNlciBiZWZvcmUgdGhleSBsZWF2ZVxuICogICAgICAgICAgdGhlIHBhZ2UsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgd2FybmluZyBzdHJpbmcsIHdoaWNoIG1heSBvclxuICogICAgICAgICAgbWF5IG5vdCBhY3R1YWxseSBiZSB1c2VkIGJ5IHRoZSBicm93c2VyIHRvIHByZXNlbnQgYSB3YXJuaW5nLiAgSWZcbiAqICAgICAgICAgIHdlIGRvbid0IHdhbnQgdG8gd2FybiB0aGUgdXNlciwgdGhpcyBtZXRob2QgZG9lc24ndCByZXR1cm4gYW55dGhpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLm9uQmVmb3JlVW5sb2FkXyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAod2luZG93Ll9fVGVzdEludGVyZmFjZSAmJiB3aW5kb3cuX19UZXN0SW50ZXJmYWNlLmlnbm9yZU9uQmVmb3JlVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm8gbmVlZCB0byB3YXJuIGFib3V0IG5hdmlnYXRpbmcgYXdheSBpZiB0aGUgc3R1ZGVudCBpcyBub3QgY29ubmVjdGVkLFxuICAvLyBvciBpcyBzdGlsbCBpbiB0aGUgbG9iYnkuXG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9SZW1vdGUoKSkge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gaTE4bi5vbkJlZm9yZVVubG9hZFdhcm5pbmcoKTtcbiAgICByZXR1cm4gaTE4bi5vbkJlZm9yZVVubG9hZFdhcm5pbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbmxvYWQgaGFuZGxlci4gIFVzZWQgdG8gYXR0ZW1wdCBhIGNsZWFuIGRpc2Nvbm5lY3QgZnJvbSB0aGUgc2ltdWxhdGlvblxuICogdXNpbmcgc3luY2hyb25vdXMgQUpBWCBjYWxscyB0byByZW1vdmUgb3VyIG93biByb3dzIGZyb20gcmVtb3RlIHN0b3JhZ2UuXG4gKlxuICogU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3VubG9hZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUub25VbmxvYWRfID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvU2hhcmQoKSkge1xuICAgIHRoaXMuc3luY2hyb25vdXNEaXNjb25uZWN0RnJvbVNoYXJkXygpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gYSBuZXRzaW0gc2hhcmRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5OZXRTaW0ucHJvdG90eXBlLmlzQ29ubmVjdGVkVG9TaGFyZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChudWxsICE9PSB0aGlzLm15Tm9kZSk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gYSBzaGFyZCB3aXRoIHRoZSBnaXZlbiBJRFxuICogQHBhcmFtIHtzdHJpbmd9IHNoYXJkSURcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5OZXRTaW0ucHJvdG90eXBlLmlzQ29ubmVjdGVkVG9TaGFyZElEID0gZnVuY3Rpb24gKHNoYXJkSUQpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWRUb1NoYXJkKCkgJiYgdGhpcy5zaGFyZF8uaWQgPT09IHNoYXJkSUQ7XG59O1xuXG4vKipcbiAqIEVzdGFibGlzaGVzIGEgbmV3IGNvbm5lY3Rpb24gdG8gYSBuZXRzaW0gc2hhcmQsIGNsb3NpbmcgdGhlIG9sZCBvbmVcbiAqIGlmIHByZXNlbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHNoYXJkSURcbiAqIEBwYXJhbSB7IXN0cmluZ30gZGlzcGxheU5hbWVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5jb25uZWN0VG9TaGFyZCA9IGZ1bmN0aW9uIChzaGFyZElELCBkaXNwbGF5TmFtZSkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvU2hhcmQoKSkge1xuICAgIGxvZ2dlci53YXJuKFwiQXV0by1jbG9zaW5nIHByZXZpb3VzIGNvbm5lY3Rpb24uLi5cIik7XG4gICAgdGhpcy5kaXNjb25uZWN0RnJvbVNoYXJkKHRoaXMuY29ubmVjdFRvU2hhcmQuYmluZCh0aGlzLCBzaGFyZElELCBkaXNwbGF5TmFtZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc2hhcmRfID0gbmV3IE5ldFNpbVNoYXJkKHNoYXJkSUQsIE5ldFNpbUdsb2JhbHMuZ2V0UHViU3ViQ29uZmlnKCkpO1xuICB0aGlzLmNyZWF0ZU15Q2xpZW50Tm9kZV8oZGlzcGxheU5hbWUsIGZ1bmN0aW9uIChlcnIsIG15Tm9kZSkge1xuICAgIHRoaXMubXlOb2RlID0gbXlOb2RlO1xuICAgIHRoaXMuc2hhcmRDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKHRoaXMuc2hhcmRfLCB0aGlzLm15Tm9kZSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgbG9iYnkgdGFibGUgaGFzIGFscmVhZHkgYmVlbiBjb25maWd1cmVkLCBjb25uZWN0cyB0byB0aGF0IHRhYmxlXG4gKiBieSBpbnNlcnRpbmcgYSByb3cgZm9yIG91cnNlbHZlcyBpbnRvIHRoYXQgdGFibGUgYW5kIHNhdmluZyB0aGUgcm93IElELlxuICogQHBhcmFtIHshc3RyaW5nfSBkaXNwbGF5TmFtZVxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgLSByZXN1bHQgaXMgbmV3IGxvY2FsIG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuY3JlYXRlTXlDbGllbnROb2RlXyA9IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSwgb25Db21wbGV0ZSkge1xuICBOZXRTaW1Mb2NhbENsaWVudE5vZGUuY3JlYXRlKHRoaXMuc2hhcmRfLCBkaXNwbGF5TmFtZSwgZnVuY3Rpb24gKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2xpZW50IG5vZGU7IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgTmV0U2ltQWxlcnQuZXJyb3IoaTE4bi5jcmVhdGVNeUNsaWVudE5vZGVFcnJvcigpKTtcbiAgICAgIG9uQ29tcGxldGUoZXJyLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNldExvc3RDb25uZWN0aW9uQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgTmV0U2ltQWxlcnQud2FybihpMThuLmFsZXJ0Q29ubmVjdGlvblJlc2V0KCkpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0RnJvbVNoYXJkKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmluaXRpYWxpemVTaW11bGF0aW9uKHRoaXMuc2VudE1lc3NhZ2VMb2dfLCB0aGlzLnJlY2VpdmVkTWVzc2FnZUxvZ18pO1xuICAgIG9uQ29tcGxldGUoZXJyLCBub2RlKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogU3luY2hyb25vdXMgZGlzY29ubmVjdCwgZm9yIHVzZSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLnN5bmNocm9ub3VzRGlzY29ubmVjdEZyb21TaGFyZF8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubXlOb2RlLnN0b3BTaW11bGF0aW9uKCk7XG4gIHRoaXMubXlOb2RlLnN5bmNocm9ub3VzRGVzdHJveSgpO1xuICB0aGlzLm15Tm9kZSA9IG51bGw7XG4gIC8vIERvbid0IG5vdGlmeSBvYnNlcnZlcnMsIHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIG5hdmlnYXRpbmcgYXdheVxuICAvLyBmcm9tIHRoZSBwYWdlLlxufTtcblxuLyoqXG4gKiBFbmRzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBuZXRzaW0gc2hhcmQuXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBbb25Db21wbGV0ZV1cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5kaXNjb25uZWN0RnJvbVNoYXJkID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgb25Db21wbGV0ZSA9IG9uQ29tcGxldGUgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkVG9TaGFyZCgpKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJSZWR1bmRhbnQgZGlzY29ubmVjdCBjYWxsLlwiKTtcbiAgICBvbkNvbXBsZXRlKG51bGwsIG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9SZW1vdGUoKSkge1xuICAgIC8vIERpc2Nvbm5lY3QsIGZyb20gdGhlIHJlbW90ZSBub2RlLCBhbmQgdHJ5IHRoaXMgYWdhaW4gb24gY29tcGxldGlvbi5cbiAgICB0aGlzLmRpc2Nvbm5lY3RGcm9tUmVtb3RlKHRoaXMuZGlzY29ubmVjdEZyb21TaGFyZC5iaW5kKHRoaXMsIG9uQ29tcGxldGUpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLm15Tm9kZS5zdG9wU2ltdWxhdGlvbigpO1xuICB0aGlzLm15Tm9kZS5kZXN0cm95KGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdFcnJvciBkZXN0cm95aW5nIG5vZGU6JyArIGVyci5tZXNzYWdlKTtcbiAgICAgIC8vIERvbid0IHN0b3AgZGlzY29ubmVjdGluZyBvbiBhbiBlcnJvciBoZXJlOyB3ZSBtYWtlIGEgZ29vZC1mYWl0aFxuICAgICAgLy8gZWZmb3J0IHRvIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlcywgYW5kIGxldCB0aGUgY2xlYW5pbmcgc3lzdGVtIHRha2VcbiAgICAgIC8vIGNhcmUgb2YgdGhlIHJlc3QuXG4gICAgfVxuXG4gICAgdGhpcy5teU5vZGUgPSBudWxsO1xuICAgIHRoaXMuc2hhcmRfLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnNoYXJkXyA9IG51bGw7XG4gICAgdGhpcy5zaGFyZENoYW5nZS5ub3RpZnlPYnNlcnZlcnMobnVsbCwgbnVsbCk7XG4gICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBsb2NhbCBjbGllbnQgaXMgY29ubmVjdGVkIHRvIGEgcmVtb3RlIG5vZGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5pc0Nvbm5lY3RlZFRvUmVtb3RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZFRvQ2xpZW50KCkgfHwgdGhpcy5pc0Nvbm5lY3RlZFRvUm91dGVyKCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtOZXRTaW1Ob2RlfSB0aGUgcmVtb3RlIG5vZGUgb3VyIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8sIG9yIG51bGwgaWZcbiAqICAgICAgICAgIG5vdCBjb25uZWN0ZWRcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5nZXRDb25uZWN0ZWRSZW1vdGVOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xpZW50ID0gdGhpcy5nZXRDb25uZWN0ZWRDbGllbnQoKTtcbiAgdmFyIHJvdXRlciA9IHRoaXMuZ2V0Q29ubmVjdGVkUm91dGVyKCk7XG4gIHJldHVybiBjbGllbnQgPyBjbGllbnQgOiByb3V0ZXI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBsb2NhbCBjbGllbnQgaGFzIGEgbXV0dWFsIFAyUCBjb25uZWN0aW9uIHRvXG4gKiAgICAgICAgICBhbm90aGVyIGNsaWVudC5cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5pc0Nvbm5lY3RlZFRvQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEodGhpcy5nZXRDb25uZWN0ZWRDbGllbnQoKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtOZXRTaW1DbGllbnROb2RlfSB0aGUgY2xpZW50IG5vZGUgb3VyIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8sIG9yXG4gKiAgICAgICAgICBudWxsIGlmIG5vdCBjb25uZWN0ZWQgdG8gYW5vdGhlciBjbGllbnQuXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvU2hhcmQoKSkge1xuICAgIHJldHVybiB0aGlzLm15Tm9kZS5teVJlbW90ZUNsaWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogV2hldGhlciBvdXIgY2xpZW50IG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgcm91dGVyIG5vZGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5pc0Nvbm5lY3RlZFRvUm91dGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEodGhpcy5nZXRDb25uZWN0ZWRSb3V0ZXIoKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtOZXRTaW1Sb3V0ZXJOb2RlfSB0aGUgcm91dGVyIG5vZGUgb3VyIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8sIG9yXG4gKiAgICAgICAgICBudWxsIGlmIG5vdCBjb25uZWN0ZWQgdG8gYSByb3V0ZXIuXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkUm91dGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvU2hhcmQoKSkge1xuICAgIHJldHVybiB0aGlzLm15Tm9kZS5nZXRNeVJvdXRlcigpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBFc3RhYmxpc2ggYSBjb25uZWN0aW9uIGJldHdlZW4gdGhlIGxvY2FsIGNsaWVudCBhbmQgdGhlIGdpdmVuXG4gKiBzaW11bGF0ZWQgcm91dGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdXRlcklEXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuY29ubmVjdFRvUm91dGVyID0gZnVuY3Rpb24gKHJvdXRlcklELCBvbkNvbXBsZXRlKSB7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9SZW1vdGUoKSkge1xuICAgIC8vIERpc2Nvbm5lY3QgYW5kIHRyeSB0byBjb25uZWN0IGFnYWluIHdoZW4gd2UncmUgZG9uZS5cbiAgICBsb2dnZXIud2FybihcIkF1dG8tZGlzY29ubmVjdGluZyBmcm9tIHByZXZpb3VzIHJvdXRlci5cIik7XG4gICAgdGhpcy5kaXNjb25uZWN0RnJvbVJlbW90ZSh0aGlzLmNvbm5lY3RUb1JvdXRlci5iaW5kKHRoaXMsIHJvdXRlcklELCBvbkNvbXBsZXRlKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBOZXRTaW1Sb3V0ZXJOb2RlLmdldChyb3V0ZXJJRCwgdGhpcy5zaGFyZF8sIGZ1bmN0aW9uIChlcnIsIHJvdXRlcikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gZmluZCByb3V0ZXIgd2l0aCBJRCAnICsgcm91dGVySUQgKyAnOyAnICtcbiAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICBvbkNvbXBsZXRlKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5teU5vZGUuY29ubmVjdFRvUm91dGVyKHJvdXRlciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2dnZXIud2FybignRmFpbGVkIHRvIGNvbm5lY3QgdG8gJyArIHJvdXRlci5nZXREaXNwbGF5TmFtZSgpICsgJzsgJyArXG4gICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBvbkNvbXBsZXRlKGVyciwgcm91dGVyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIG91ciBjbGllbnQgbm9kZSBmcm9tIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHJlbW90ZSBub2RlLlxuICogRGVzdHJveXMgdGhlIHNoYXJlZCB3aXJlLlxuICogQHBhcmFtIHtOb2RlU3R5bGVDYWxsYmFja30gW29uQ29tcGxldGVdIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGNhbGwgd2hlblxuICogICAgICAgIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5kaXNjb25uZWN0RnJvbVJlbW90ZSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIG9uQ29tcGxldGUgPSB1dGlscy52YWx1ZU9yKG9uQ29tcGxldGUsIGZ1bmN0aW9uICgpIHt9KTtcbiAgdGhpcy5teU5vZGUuZGlzY29ubmVjdFJlbW90ZShvbkNvbXBsZXRlKTtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzIGZldGNoIG9mIHRoZSBsYXRlc3QgbWVzc2FnZSBzaGFyZWQgYmV0d2VlbiB0aGUgbG9jYWxcbiAqIG5vZGUgYW5kIGl0cyBjb25uZWN0ZWQgcmVtb3RlLlxuICogVXNlZCBvbmx5IGluIHNpbXBsZXggJiBiaXQtZ3JhbnVsYXIgbW9kZS5cbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUucmVjZWl2ZUJpdCA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIHRoaXMubXlOb2RlLmdldExhdGVzdE1lc3NhZ2VPblNpbXBsZXhXaXJlKG9uQ29tcGxldGUpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZW5jb2RpbmctdmlldyBzZXR0aW5nIGFjcm9zcyB0aGUgd2hvbGUgYXBwLlxuICpcbiAqIFByb3BhZ2F0ZXMgdGhlIGNoYW5nZSBkb3duIGludG8gcmVsZXZhbnQgY2hpbGQgY29tcG9uZW50cywgcG9zc2libHlcbiAqIGluY2x1ZGluZyB0aGUgY29udHJvbCB0aGF0IGluaXRpYXRlZCB0aGUgY2hhbmdlOyBpbiB0aGF0IGNhc2UsIHJlLXNldHRpbmdcbiAqIHRoZSB2YWx1ZSBzaG91bGQgYmUgYSBuby1vcCBhbmQgc2FmZSB0byBkby5cbiAqXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBuZXdFbmNvZGluZ3NcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5jaGFuZ2VFbmNvZGluZ3MgPSBmdW5jdGlvbiAobmV3RW5jb2RpbmdzKSB7XG4gIHRoaXMuZW5hYmxlZEVuY29kaW5nc18gPSBuZXdFbmNvZGluZ3M7XG4gIGlmICh0aGlzLnRhYnNfKSB7XG4gICAgdGhpcy50YWJzXy5zZXRFbmNvZGluZ3MobmV3RW5jb2RpbmdzKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVkTWVzc2FnZUxvZ18uc2V0RW5jb2RpbmdzKG5ld0VuY29kaW5ncyk7XG4gIHRoaXMuc2VudE1lc3NhZ2VMb2dfLnNldEVuY29kaW5ncyhuZXdFbmNvZGluZ3MpO1xuICB0aGlzLnNlbmRQYW5lbF8uc2V0RW5jb2RpbmdzKG5ld0VuY29kaW5ncyk7XG4gIHRoaXMudmlzdWFsaXphdGlvbl8uc2V0RW5jb2RpbmdzKG5ld0VuY29kaW5ncyk7XG4gIHRoaXMudXBkYXRlTGF5b3V0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGVuYWJsZWQgZW5jb2RpbmcgdHlwZXMuXG4gKiBAcmV0dXJucyB7RW5jb2RpbmdUeXBlW119XG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuZ2V0RW5jb2RpbmdzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lbmFibGVkRW5jb2RpbmdzXztcbn07XG5cbi8qKlxuICogVXBkYXRlIGNodW5rLXNpemUvYnl0ZXNpemUgc2V0dGluZyBhY3Jvc3MgdGhlIHdob2xlIGFwcC5cbiAqXG4gKiBQcm9wYWdhdGVzIHRoZSBjaGFuZ2UgZG93biBpbnRvIHJlbGV2YW50IGNoaWxkIGNvbXBvbmVudHMsIHBvc3NpYmx5XG4gKiBpbmNsdWRpbmcgdGhlIGNvbnRyb2wgdGhhdCBpbml0aWF0ZWQgdGhlIGNoYW5nZTsgaW4gdGhhdCBjYXNlLCByZS1zZXR0aW5nXG4gKiB0aGUgdmFsdWUgc2hvdWxkIGJlIGEgbm8tb3AgYW5kIHNhZmUgdG8gZG8uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0NodW5rU2l6ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLnNldENodW5rU2l6ZSA9IGZ1bmN0aW9uIChuZXdDaHVua1NpemUpIHtcbiAgdGhpcy5jaHVua1NpemVfID0gbmV3Q2h1bmtTaXplO1xuICBpZiAodGhpcy50YWJzXykge1xuICAgIHRoaXMudGFic18uc2V0Q2h1bmtTaXplKG5ld0NodW5rU2l6ZSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlZE1lc3NhZ2VMb2dfLnNldENodW5rU2l6ZShuZXdDaHVua1NpemUpO1xuICB0aGlzLnNlbnRNZXNzYWdlTG9nXy5zZXRDaHVua1NpemUobmV3Q2h1bmtTaXplKTtcbiAgdGhpcy5zZW5kUGFuZWxfLnNldENodW5rU2l6ZShuZXdDaHVua1NpemUpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYml0cmF0ZSBmb3IgdGhlIGxvY2FsIGRldmljZSwgd2hpY2ggYWZmZWN0cyBzZW5kLWFuaW1hdGlvbiBzcGVlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdCaXRSYXRlIGluIGJpdHMgcGVyIHNlY29uZFxuICovXG5OZXRTaW0ucHJvdG90eXBlLnNldE15RGV2aWNlQml0UmF0ZSA9IGZ1bmN0aW9uIChuZXdCaXRSYXRlKSB7XG4gIHRoaXMubXlEZXZpY2VCaXRSYXRlXyA9IG5ld0JpdFJhdGU7XG4gIGlmICh0aGlzLnRhYnNfKSB7XG4gICAgdGhpcy50YWJzXy5zZXRNeURldmljZUJpdFJhdGUobmV3Qml0UmF0ZSk7XG4gIH1cbiAgdGhpcy5zZW5kUGFuZWxfLnNldEJpdFJhdGUobmV3Qml0UmF0ZSk7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IGNyZWF0aW9uVGltZXN0YW1wTXMgKi9cbk5ldFNpbS5wcm90b3R5cGUuc2V0Um91dGVyQ3JlYXRpb25UaW1lID0gZnVuY3Rpb24gKGNyZWF0aW9uVGltZXN0YW1wTXMpIHtcbiAgaWYgKHRoaXMudGFic18pIHtcbiAgICB0aGlzLnRhYnNfLnNldFJvdXRlckNyZWF0aW9uVGltZShjcmVhdGlvblRpbWVzdGFtcE1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgcm91dGVyIGJhbmR3aWR0aCBhY3Jvc3MgdGhlIGFwcC5cbiAqXG4gKiBQcm9wYWdhdGVzIHRoZSBjaGFuZ2UgZG93biBpbnRvIHJlbGV2YW50IGNoaWxkIGNvbXBvbmVudHMsIHBvc3NpYmx5IGluY2x1ZGluZ1xuICogdGhlIGNvbnRyb2wgdGhhdCBpbml0aWF0ZWQgdGhlIGNoYW5nZTsgaW4gdGhhdCBjYXNlLCByZS1zZXR0aW5nIHRoZSB2YWx1ZVxuICogc2hvdWxkIGJlIGEgbm8tb3AgYW5kIHNhZmUgdG8gZG8uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0JhbmR3aWR0aCBpbiBiaXRzL3NlY29uZFxuICovXG5OZXRTaW0ucHJvdG90eXBlLnNldFJvdXRlckJhbmR3aWR0aCA9IGZ1bmN0aW9uIChuZXdCYW5kd2lkdGgpIHtcbiAgaWYgKHRoaXMudGFic18pIHtcbiAgICB0aGlzLnRhYnNfLnNldFJvdXRlckJhbmR3aWR0aChuZXdCYW5kd2lkdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgcm91dGVyIGJhbmR3aWR0aCBhY3Jvc3MgdGhlIHNpbXVsYXRpb24sIHByb2FnYXRpbmcgdGhlIGNoYW5nZSB0byBvdGhlclxuICogY2xpZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdCYW5kd2lkdGggaW4gYml0cy9zZWNvbmRcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5jaGFuZ2VSZW1vdGVSb3V0ZXJCYW5kd2lkdGggPSBmdW5jdGlvbiAobmV3QmFuZHdpZHRoKSB7XG4gIHRoaXMuc2V0Um91dGVyQmFuZHdpZHRoKG5ld0JhbmR3aWR0aCk7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9Sb3V0ZXIoKSkge1xuICAgIHRoaXMuZ2V0Q29ubmVjdGVkUm91dGVyKCkuc2V0QmFuZHdpZHRoKG5ld0JhbmR3aWR0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHJvdXRlciBtZW1vcnkgYWNyb3NzIHRoZSBhcHAuXG4gKlxuICogUHJvcGFnYXRlcyB0aGUgY2hhbmdlIGRvd24gaW50byByZWxldmFudCBjaGlsZCBjb21wb25lbnRzLCBwb3NzaWJseSBpbmNsdWRpbmdcbiAqIHRoZSBjb250cm9sIHRoYXQgaW5pdGlhdGVkIHRoZSBjaGFuZ2U7IGluIHRoYXQgY2FzZSwgcmUtc2V0dGluZyB0aGUgdmFsdWVcbiAqIHNob3VsZCBiZSBhIG5vLW9wIGFuZCBzYWZlIHRvIGRvLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNZW1vcnkgaW4gYml0c1xuICovXG5OZXRTaW0ucHJvdG90eXBlLnNldFJvdXRlck1lbW9yeSA9IGZ1bmN0aW9uIChuZXdNZW1vcnkpIHtcbiAgaWYgKHRoaXMudGFic18pIHtcbiAgICB0aGlzLnRhYnNfLnNldFJvdXRlck1lbW9yeShuZXdNZW1vcnkpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgcm91dGVyIG1lbW9yeSBjYXBhY2l0eSBhY3Jvc3MgdGhlIHNpbXVsYXRpb24sIHByb3BhZ2F0aW5nIHRoZSBjaGFuZ2VcbiAqIHRvIG90aGVyIGNsaWVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3TWVtb3J5IGluIGJpdHNcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5jaGFuZ2VSZW1vdGVSb3V0ZXJNZW1vcnkgPSBmdW5jdGlvbiAobmV3TWVtb3J5KSB7XG4gIHRoaXMuc2V0Um91dGVyTWVtb3J5KG5ld01lbW9yeSk7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9Sb3V0ZXIoKSkge1xuICAgIHRoaXMuZ2V0Q29ubmVjdGVkUm91dGVyKCkuc2V0TWVtb3J5KG5ld01lbW9yeSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIEROUyBtb2RlIGFjcm9zcyB0aGUgd2hvbGUgYXBwLlxuICpcbiAqIFByb3BhZ2F0ZXMgdGhlIGNoYW5nZSBkb3duIGludG8gcmVsZXZhbnQgY2hpbGQgY29tcG9uZW50cywgcG9zc2libHlcbiAqIGluY2x1ZGluZyB0aGUgY29udHJvbCB0aGF0IGluaXRpYXRlZCB0aGUgY2hhbmdlOyBpbiB0aGF0IGNhc2UsIHJlLXNldHRpbmdcbiAqIHRoZSB2YWx1ZSBzaG91bGQgYmUgYSBuby1vcCBhbmQgc2FmZSB0byBkby5cbiAqXG4gKiBAcGFyYW0ge0Ruc01vZGV9IG5ld0Ruc01vZGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5zZXREbnNNb2RlID0gZnVuY3Rpb24gKG5ld0Ruc01vZGUpIHtcbiAgdGhpcy5kbnNNb2RlXyA9IG5ld0Ruc01vZGU7XG4gIGlmICh0aGlzLnRhYnNfKSB7XG4gICAgdGhpcy50YWJzXy5zZXREbnNNb2RlKG5ld0Ruc01vZGUpO1xuICB9XG4gIHRoaXMudmlzdWFsaXphdGlvbl8uc2V0RG5zTW9kZShuZXdEbnNNb2RlKTtcbn07XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgRE5TIG1vZGUuXG4gKiBAcmV0dXJucyB7RG5zTW9kZX1cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5nZXREbnNNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kbnNNb2RlXztcbn07XG5cbi8qKlxuICogU2V0cyBETlMgbW9kZSBhY3Jvc3MgdGhlIHdob2xlIHNpbXVsYXRpb24sIHByb3BhZ2F0aW5nIHRoZSBjaGFuZ2VcbiAqIHRvIG90aGVyIGNsaWVudHMuXG4gKiBAcGFyYW0ge0Ruc01vZGV9IG5ld0Ruc01vZGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5jaGFuZ2VSZW1vdGVEbnNNb2RlID0gZnVuY3Rpb24gKG5ld0Ruc01vZGUpIHtcbiAgdGhpcy5zZXREbnNNb2RlKG5ld0Ruc01vZGUpO1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvUm91dGVyKCkpIHtcbiAgICB0aGlzLmdldENvbm5lY3RlZFJvdXRlcigpLnNldERuc01vZGUobmV3RG5zTW9kZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc0Ruc05vZGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5zZXRJc0Ruc05vZGUgPSBmdW5jdGlvbiAoaXNEbnNOb2RlKSB7XG4gIGlmICh0aGlzLnRhYnNfKSB7XG4gICAgdGhpcy50YWJzXy5zZXRJc0Ruc05vZGUoaXNEbnNOb2RlKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9Sb3V0ZXIoKSkge1xuICAgIHRoaXMuc2V0RG5zVGFibGVDb250ZW50cyh0aGlzLmdldENvbm5lY3RlZFJvdXRlcigpLmdldEFkZHJlc3NUYWJsZSgpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZG5zTm9kZUlEXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuc2V0RG5zTm9kZUlEID0gZnVuY3Rpb24gKGRuc05vZGVJRCkge1xuICB0aGlzLnZpc3VhbGl6YXRpb25fLnNldERuc05vZGVJRChkbnNOb2RlSUQpO1xufTtcblxuLyoqXG4gKiBUZWxscyBzaW11bGF0aW9uIHRoYXQgd2Ugd2FudCB0byBiZWNvbWUgdGhlIEROUyBub2RlIGZvciBvdXJcbiAqIGNvbm5lY3RlZCByb3V0ZXIuXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuYmVjb21lRG5zTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRJc0Ruc05vZGUodHJ1ZSk7XG4gIGlmICh0aGlzLm15Tm9kZSAmJiB0aGlzLm15Tm9kZS5nZXRNeVJvdXRlcigpKSB7XG4gICAgLy8gU1RBVEUgSVMgVEhFIFJPT1QgT0YgQUxMIEVWSUxcbiAgICB2YXIgbXlOb2RlID0gdGhpcy5teU5vZGU7XG4gICAgdmFyIHJvdXRlciA9IG15Tm9kZS5nZXRNeVJvdXRlcigpO1xuICAgIHJvdXRlci5kbnNOb2RlSUQgPSBteU5vZGUuZW50aXR5SUQ7XG4gICAgcm91dGVyLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhYmxlQ29udGVudHNcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5zZXREbnNUYWJsZUNvbnRlbnRzID0gZnVuY3Rpb24gKHRhYmxlQ29udGVudHMpIHtcbiAgaWYgKHRoaXMudGFic18pIHtcbiAgICB0aGlzLnRhYnNfLnNldERuc1RhYmxlQ29udGVudHModGFibGVDb250ZW50cyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gbG9nRGF0YVxuICovXG5OZXRTaW0ucHJvdG90eXBlLnNldFJvdXRlckxvZ0RhdGEgPSBmdW5jdGlvbiAobG9nRGF0YSkge1xuICBpZiAodGhpcy50YWJzXykge1xuICAgIHRoaXMudGFic18uc2V0Um91dGVyTG9nRGF0YShsb2dEYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcXVldWVkUGFja2V0Q291bnRcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuc2V0Um91dGVyUXVldWVkUGFja2V0Q291bnRfID0gZnVuY3Rpb24gKHF1ZXVlZFBhY2tldENvdW50KSB7XG4gIGlmICh0aGlzLnRhYnNfKSB7XG4gICAgdGhpcy50YWJzXy5zZXRSb3V0ZXJRdWV1ZWRQYWNrZXRDb3VudChxdWV1ZWRQYWNrZXRDb3VudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHVzZWRNZW1vcnlJbkJpdHNcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuc2V0Um91dGVyTWVtb3J5SW5Vc2VfID0gZnVuY3Rpb24gKHVzZWRNZW1vcnlJbkJpdHMpIHtcbiAgaWYgKHRoaXMudGFic18pIHtcbiAgICB0aGlzLnRhYnNfLnNldFJvdXRlck1lbW9yeUluVXNlKHVzZWRNZW1vcnlJbkJpdHMpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhUmF0ZUJpdHNQZXJTZWNvbmRcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuc2V0Um91dGVyRGF0YVJhdGVfID0gZnVuY3Rpb24gKGRhdGFSYXRlQml0c1BlclNlY29uZCkge1xuICBpZiAodGhpcy50YWJzXykge1xuICAgIHRoaXMudGFic18uc2V0Um91dGVyRGF0YVJhdGUoZGF0YVJhdGVCaXRzUGVyU2Vjb25kKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2FkIGF1ZGlvIGFzc2V0cyBmb3IgdGhpcyBhcHBcbiAqIFRPRE8gKGJidWNoYW5hbik6IE91Z2h0IHRvIHB1bGwgdGhpcyBpbnRvIGFuIGF1ZGlvIG1hbmFnZW1lbnQgbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLmxvYWRBdWRpb18gPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIFN0dWRpb0FwcC5jb25maWd1cmVEb20uXG4gKiBTaG91bGQgYmUgYm91bmQgYWdhaW5zdCBTdHVkaW9BcHAgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFNob3VsZCBhdCBsZWFzdCBjb250YWluXG4gKiAgIGNvbnRhaW5lcklkOiBJRCBvZiBhIHBhcmVudCBET00gZWxlbWVudCBmb3IgYXBwIGNvbnRlbnRcbiAqICAgaHRtbDogQ29udGVudCB0byBwdXQgaW5zaWRlICNjb250YWluZXJJZFxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltLmNvbmZpZ3VyZURvbU92ZXJyaWRlXyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmZpZy5jb250YWluZXJJZCk7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjb25maWcuaHRtbDtcblxuICB2YXIgdml6SGVpZ2h0ID0gdGhpcy5NSU5fV09SS1NQQUNFX0hFSUdIVDtcbiAgdmFyIHZpc3VhbGl6YXRpb25Db2x1bW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV0c2ltLWxlZnRjb2wnKTtcblxuICBpZiAoY29uZmlnLnBpbldvcmtzcGFjZVRvQm90dG9tKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNvbnRhaW5lci5jbGFzc05hbWUgKyBcIiBwaW5fYm90dG9tXCI7XG4gICAgdmlzdWFsaXphdGlvbkNvbHVtbi5jbGFzc05hbWUgPSB2aXN1YWxpemF0aW9uQ29sdW1uLmNsYXNzTmFtZSArIFwiIHBpbl9ib3R0b21cIjtcbiAgfSBlbHNlIHtcbiAgICB2aXN1YWxpemF0aW9uQ29sdW1uLnN0eWxlLm1pbkhlaWdodCA9IHZpekhlaWdodCArICdweCc7XG4gICAgY29udGFpbmVyLnN0eWxlLm1pbkhlaWdodCA9IHZpekhlaWdodCArICdweCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmVzaXplIHRoZSBsZWZ0IGNvbHVtbiBzbyBpdCBwaW5zIGFib3ZlIHRoZSBmb290ZXIuXG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZUxlZnRDb2x1bW5Ub1NpdEFib3ZlRm9vdGVyKCkge1xuICB2YXIgcGlubmVkTGVmdENvbHVtbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuZXRzaW0tbGVmdGNvbC5waW5fYm90dG9tJyk7XG4gIGlmICghcGlubmVkTGVmdENvbHVtbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzbWFsbEZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlLXNtYWxsLWZvb3RlciAuc21hbGwtZm9vdGVyLWJhc2UnKTtcblxuICB2YXIgYm90dG9tID0gMDtcbiAgaWYgKHNtYWxsRm9vdGVyKSB7XG4gICAgdmFyIGNvZGVBcHAgPSAkKCcjY29kZUFwcCcpO1xuICAgIGJvdHRvbSArPSAkKHNtYWxsRm9vdGVyKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAvLyBGb290ZXIgaXMgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LCBub3QgY29kZUFwcCwgc28gd2UgbmVlZCB0b1xuICAgIC8vIHJlbW92ZSB0aGUgY29kZUFwcCBib3R0b20gb2Zmc2V0IHRvIGdldCB0aGUgY29ycmVjdCBtYXJnaW4uXG4gICAgYm90dG9tIC09IHBhcnNlSW50KGNvZGVBcHAuY3NzKCdib3R0b20nKSwgMTApO1xuICB9XG5cbiAgcGlubmVkTGVmdENvbHVtbi5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xufVxuXG5mdW5jdGlvbiByZXNpemVGb290ZXJUb0ZpdFRvTGVmdE9mQ29udGVudCgpIHtcbiAgdmFyIGxlZnRDb2x1bW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV0c2ltLWxlZnRjb2wucGluX2JvdHRvbScpO1xuICB2YXIgaW5zdHJ1Y3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmluc3RydWN0aW9ucycpO1xuICB2YXIgc21hbGxGb290ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGFnZS1zbWFsbC1mb290ZXIgLnNtYWxsLWZvb3Rlci1iYXNlJyk7XG5cbiAgaWYgKCFzbWFsbEZvb3Rlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoc21hbGxGb290ZXIpW1wicGFkZGluZy1sZWZ0XCJdKTtcblxuICB2YXIgYm91bmRpbmdXaWR0aDtcbiAgaWYgKGxlZnRDb2x1bW4gJiYgJChsZWZ0Q29sdW1uKS5pcygnOnZpc2libGUnKSkge1xuICAgIGJvdW5kaW5nV2lkdGggPSBsZWZ0Q29sdW1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0O1xuICB9IGVsc2UgaWYgKGluc3RydWN0aW9ucyAmJiAkKGluc3RydWN0aW9ucykuaXMoJzp2aXNpYmxlJykpIHtcbiAgICBib3VuZGluZ1dpZHRoID0gaW5zdHJ1Y3Rpb25zLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0O1xuICB9XG5cbiAgc21hbGxGb290ZXIuc3R5bGUubWF4V2lkdGggPSAoYm91bmRpbmdXaWR0aCkgPyAoYm91bmRpbmdXaWR0aCAtIHBhZGRpbmcpICsgJ3B4JyA6IG51bGw7XG59XG5cbnZhciBuZXRzaW1EZWJvdW5jZWRSZXNpemVGb290ZXIgPSBfLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgcmVzaXplRm9vdGVyVG9GaXRUb0xlZnRPZkNvbnRlbnQoKTtcbiAgcmVzaXplTGVmdENvbHVtblRvU2l0QWJvdmVGb290ZXIoKTtcbn0sIDEwKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBTdHVkaW9BcHAub25SZXNpemVcbiAqIFNob3VsZCBiZSBib3VuZCBhZ2FpbnN0IFN0dWRpb0FwcCBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5vblJlc2l6ZU92ZXJyaWRlXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcGNvbnRhaW5lcicpO1xuICB2YXIgZGl2UGFyZW50ID0gZGl2LnBhcmVudE5vZGU7XG4gIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdlBhcmVudCk7XG4gIHZhciBwYXJlbnRXaWR0aCA9IHBhcnNlSW50KHBhcmVudFN0eWxlLndpZHRoLCAxMCk7XG4gIGRpdi5zdHlsZS50b3AgPSBkaXZQYXJlbnQub2Zmc2V0VG9wICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gcGFyZW50V2lkdGggKyAncHgnO1xuXG4gIG5ldHNpbURlYm91bmNlZFJlc2l6ZUZvb3RlcigpO1xufTtcblxuLyoqXG4gKiBQYXNzdGhyb3VnaCB0byBsb2NhbCBcInN0YXRpY1wiIG5ldHNpbURlYm91bmNlUmVzaXplRm9vdGVyIG1ldGhvZFxuICovXG5OZXRTaW0ucHJvdG90eXBlLmRlYm91bmNlZFJlc2l6ZUZvb3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgbmV0c2ltRGVib3VuY2VkUmVzaXplRm9vdGVyKCk7XG59O1xuXG4vKipcbiAqIFJlLXJlbmRlciBwYXJ0cyBvZiB0aGUgcGFnZSB0aGF0IGNhbiBiZSByZS1yZW5kZXJlZCBpbiBwbGFjZS5cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9SZW1vdGUoKSkge1xuICAgIHZhciBteUFkZHJlc3MgPSB0aGlzLm15Tm9kZS5nZXRBZGRyZXNzKCk7XG5cbiAgICAvLyBTd2FwIGluICdjb25uZWN0ZWQnIGRpdlxuICAgIHRoaXMubWFpbkNvbnRhaW5lcl8uZmluZCgnI25ldHNpbS1kaXNjb25uZWN0ZWQnKS5oaWRlKCk7XG4gICAgdGhpcy5tYWluQ29udGFpbmVyXy5maW5kKCcjbmV0c2ltLWNvbm5lY3RlZCcpLnNob3coKTtcblxuICAgIC8vIFJlbmRlciByaWdodCBjb2x1bW5cbiAgICB0aGlzLnNlbmRQYW5lbF8uc2V0RnJvbUFkZHJlc3MobXlBZGRyZXNzKTtcblxuICAgIC8vIFJlbmRlciBsZWZ0IGNvbHVtblxuICAgIGlmICh0aGlzLnN0YXR1c1BhbmVsXykge1xuICAgICAgdGhpcy5zdGF0dXNQYW5lbF8ucmVuZGVyKHtcbiAgICAgICAgbXlIb3N0bmFtZTogdGhpcy5teU5vZGUuZ2V0SG9zdG5hbWUoKSxcbiAgICAgICAgbXlBZGRyZXNzOiBteUFkZHJlc3MsXG4gICAgICAgIHJlbW90ZU5vZGVOYW1lOiB0aGlzLmdldENvbm5lY3RlZFJlbW90ZU5vZGUoKS5nZXREaXNwbGF5TmFtZSgpLFxuICAgICAgICBzaGFyZUxpbms6IHRoaXMubG9iYnlfLmdldFNoYXJlTGluaygpXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU3dhcCBpbiAnZGlzY29ubmVjdGVkJyBkaXZcbiAgICB0aGlzLm1haW5Db250YWluZXJfLmZpbmQoJyNuZXRzaW0tZGlzY29ubmVjdGVkJykuc2hvdygpO1xuICAgIHRoaXMubWFpbkNvbnRhaW5lcl8uZmluZCgnI25ldHNpbS1jb25uZWN0ZWQnKS5oaWRlKCk7XG5cbiAgICAvLyBSZW5kZXIgbG9iYnlcbiAgICB0aGlzLmxvYmJ5Xy5yZW5kZXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnJvdXRlckxvZ01vZGFsXykge1xuICAgIHRoaXMucm91dGVyTG9nTW9kYWxfLnJlbmRlcigpO1xuICB9XG5cbiAgdGhpcy51cGRhdGVMYXlvdXQoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBjb25uZWN0aW9uIG5vdGlmaWVzIHVzIHRoYXQgd2UndmUgY29ubmVjdGVkIHRvLFxuICogb3IgZGlzY29ubmVjdGVkIGZyb20sIGEgc2hhcmQuXG4gKiBAcGFyYW0ge05ldFNpbVNoYXJkfSBzaGFyZCAtIG51bGwgaWYgZGlzY29ubmVjdGVkLlxuICogQHBhcmFtIHtOZXRTaW1Mb2NhbENsaWVudE5vZGV9IGxvY2FsTm9kZSAtIG51bGwgaWYgZGlzY29ubmVjdGVkXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLm9uU2hhcmRDaGFuZ2VfPSBmdW5jdGlvbiAoc2hhcmQsIGxvY2FsTm9kZSkge1xuICAvLyBVbnJlZ2lzdGVyIG9sZCBoYW5kbGVyc1xuICBpZiAodGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhMb2NhbE5vZGUpIHtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aExvY2FsTm9kZS5yZW1vdGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMucmVtb3RlQ2hhbmdlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aExvY2FsTm9kZSA9IG51bGw7XG4gIH1cblxuICAvLyBSZWdpc3RlciBuZXcgaGFuZGxlcnNcbiAgaWYgKGxvY2FsTm9kZSkge1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlbW90ZUNoYW5nZSA9IGxvY2FsTm9kZS5yZW1vdGVDaGFuZ2UucmVnaXN0ZXIoXG4gICAgICAgIHRoaXMub25SZW1vdGVDaGFuZ2VfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoTG9jYWxOb2RlID0gbG9jYWxOb2RlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBsb2cgdmlld2VyJ3Mgc2hhcmQgcmVmZXJlbmNlIHNvIGl0IGNhbiBnZXQgY3VycmVudCBkYXRhLlxuICBpZiAodGhpcy5yb3V0ZXJMb2dNb2RhbF8pIHtcbiAgICB0aGlzLnJvdXRlckxvZ01vZGFsXy5zZXRTaGFyZChzaGFyZCk7XG4gIH1cblxuICAvLyBTaGFyZCBjaGFuZ2VzIGFsbW9zdCBBTFdBWVMgcmVxdWlyZSBhIHJlLXJlbmRlclxuICB0aGlzLnZpc3VhbGl6YXRpb25fLnNldFNoYXJkKHNoYXJkKTtcbiAgdGhpcy52aXN1YWxpemF0aW9uXy5zZXRMb2NhbE5vZGUobG9jYWxOb2RlKTtcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBsb2NhbCBub2RlIG5vdGlmaWVzIHRoYXQgd2UndmUgYmVlbiBjb25uZWN0ZWQgdG8sXG4gKiBvciBkaXNjb25uZWN0ZWQgZnJvbSwgYSByb3V0ZXIuXG4gKiBAcGFyYW0ge05ldFNpbVdpcmV9IHdpcmUgLSBudWxsIGlmIGRpc2Nvbm5lY3RlZC5cbiAqIEBwYXJhbSB7TmV0U2ltTm9kZX0gcmVtb3RlTm9kZSAtIG51bGwgaWYgZGlzY29ubmVjdGVkXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW0ucHJvdG90eXBlLm9uUmVtb3RlQ2hhbmdlXyA9IGZ1bmN0aW9uICh3aXJlLCByZW1vdGVOb2RlKSB7XG4gIHZhciByb3V0ZXJDb25uZWN0RXZlbnQgPSByZW1vdGVOb2RlICYmIHJlbW90ZU5vZGUgaW5zdGFuY2VvZiBOZXRTaW1Sb3V0ZXJOb2RlO1xuICB2YXIgcm91dGVyRGlzY29ubmVjdEV2ZW50ID0gIXJlbW90ZU5vZGUgJiYgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhSb3V0ZXI7XG5cbiAgLy8gVW5ob29rIG9sZCBoYW5kbGVyc1xuICBpZiAodGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhSb3V0ZXIpIHtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aFJvdXRlci5zdGF0ZUNoYW5nZS51bnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLmV2ZW50S2V5cy5yb3V0ZXJTdGF0ZUNoYW5nZSk7XG4gICAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhSb3V0ZXIuc3RhdHNDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMucm91dGVyU3RhdHNDaGFuZ2UpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoUm91dGVyLndpcmVzQ2hhbmdlLnVucmVnaXN0ZXIoXG4gICAgICAgIHRoaXMuZXZlbnRLZXlzLnJvdXRlcldpcmVzQ2hhbmdlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aFJvdXRlci5sb2dDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMucm91dGVyTG9nQ2hhbmdlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aFJvdXRlciA9IG51bGw7XG4gIH1cblxuICAvLyBIb29rIHVwIG5ldyBoYW5kbGVyc1xuICBpZiAocm91dGVyQ29ubmVjdEV2ZW50KSB7XG4gICAgdGhpcy5ldmVudEtleXMucm91dGVyU3RhdGVDaGFuZ2UgPSByZW1vdGVOb2RlLnN0YXRlQ2hhbmdlLnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLm9uUm91dGVyU3RhdGVDaGFuZ2VfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJvdXRlclN0YXRzQ2hhbmdlID0gcmVtb3RlTm9kZS5zdGF0c0NoYW5nZS5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5vblJvdXRlclN0YXRzQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yb3V0ZXJXaXJlc0NoYW5nZSA9IHJlbW90ZU5vZGUud2lyZXNDaGFuZ2UucmVnaXN0ZXIoXG4gICAgICAgIHRoaXMub25Sb3V0ZXJXaXJlc0NoYW5nZV8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ldmVudEtleXMucm91dGVyTG9nQ2hhbmdlID0gcmVtb3RlTm9kZS5sb2dDaGFuZ2UucmVnaXN0ZXIoXG4gICAgICAgIHRoaXMub25Sb3V0ZXJMb2dDaGFuZ2VfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoUm91dGVyID0gcmVtb3RlTm9kZTtcbiAgfVxuXG4gIHRoaXMucmVuZGVyKCk7XG5cbiAgaWYgKHJvdXRlckNvbm5lY3RFdmVudCkge1xuICAgIHRoaXMub25Sb3V0ZXJDb25uZWN0XyhyZW1vdGVOb2RlKTtcbiAgfSBlbHNlIGlmIChyb3V0ZXJEaXNjb25uZWN0RXZlbnQpIHtcbiAgICB0aGlzLm9uUm91dGVyRGlzY29ubmVjdF8oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGVwcyB0byB0YWtlIHdoZW4gd2Ugd2VyZSBub3QgY29ubmVjdGVkIHRvIGEgcm91dGVyIGFuZCBub3cgd2UgYXJlLlxuICogQHBhcmFtIHtOZXRTaW1Sb3V0ZXJOb2RlfSByb3V0ZXIgdGhhdCB3ZSBhcmUgbm93IGNvbm5lY3RlZCB0b1xuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5vblJvdXRlckNvbm5lY3RfID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICB0aGlzLm9uUm91dGVyU3RhdGVDaGFuZ2VfKHJvdXRlcik7XG4gIHRoaXMub25Sb3V0ZXJTdGF0c0NoYW5nZV8ocm91dGVyKTtcbiAgdGhpcy5zZXRSb3V0ZXJMb2dEYXRhKHJvdXRlci5nZXRMb2coKSk7XG4gIHRoaXMucm91dGVyTG9nTW9kYWxfLnNldFJvdXRlcihyb3V0ZXIpO1xufTtcblxuLyoqXG4gKiBTdGVwcyB0byB0YWtlIHdoZW4gd2Ugd2VyZSBjb25uZWN0ZWQgdG8gYSByb3V0ZXIgYW5kIG5vdyB3ZSBhcmUgbm90LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5vblJvdXRlckRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldFJvdXRlckNyZWF0aW9uVGltZSgwKTtcbiAgdGhpcy5zZXRSb3V0ZXJRdWV1ZWRQYWNrZXRDb3VudF8oMCk7XG4gIHRoaXMuc2V0Um91dGVyTWVtb3J5SW5Vc2VfKDApO1xuICB0aGlzLnNldFJvdXRlckRhdGFSYXRlXygwKTtcbiAgdGhpcy5zZXRSb3V0ZXJMb2dEYXRhKFtdKTtcbiAgdGhpcy5yb3V0ZXJMb2dNb2RhbF8uc2V0Um91dGVyKG51bGwpO1xufTtcblxuLyoqXG4gKiBMb2NhbCByZXNwb25zZSB0byByb3V0ZXIgc3RhdGUgY2hhbmdpbmcsIHdoaWNoIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkXG4gKiBsb2NhbGx5IG9yIHJlbW90ZWx5LlxuICogQHBhcmFtIHtOZXRTaW1Sb3V0ZXJOb2RlfSByb3V0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUub25Sb3V0ZXJTdGF0ZUNoYW5nZV8gPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gIHZhciBteU5vZGUgPSB7fTtcbiAgaWYgKHRoaXMubXlOb2RlKSB7XG4gICAgbXlOb2RlID0gdGhpcy5teU5vZGU7XG4gIH1cblxuICB0aGlzLnNldFJvdXRlckNyZWF0aW9uVGltZShyb3V0ZXIuY3JlYXRpb25UaW1lKTtcbiAgdGhpcy5zZXRSb3V0ZXJCYW5kd2lkdGgocm91dGVyLmJhbmR3aWR0aCk7XG4gIHRoaXMuc2V0Um91dGVyTWVtb3J5KHJvdXRlci5tZW1vcnkpO1xuICB0aGlzLnNldERuc01vZGUocm91dGVyLmRuc01vZGUpO1xuICB0aGlzLnNldERuc05vZGVJRChyb3V0ZXIuZG5zTW9kZSA9PT0gRG5zTW9kZS5OT05FID8gdW5kZWZpbmVkIDogcm91dGVyLmRuc05vZGVJRCk7XG4gIHRoaXMuc2V0SXNEbnNOb2RlKHJvdXRlci5kbnNNb2RlID09PSBEbnNNb2RlLk1BTlVBTCAmJlxuICAgICAgcm91dGVyLmRuc05vZGVJRCA9PT0gbXlOb2RlLmVudGl0eUlEKTtcbn07XG5cbi8qKlxuICogSXNvbGF0ZXMgdXBkYXRlcyB0aGF0IHdlIHNob3VsZCBkbyB3aGVuIGEgcm91dGVyJ3Mgc3RhdHMgY2hhbmdlLCBzaW5jZVxuICogdGhlc2UgaGFwcGVuIGEgbG90IG1vcmUgb2Z0ZW4uXG4gKiBAcGFyYW0ge05ldFNpbVJvdXRlck5vZGV9IHJvdXRlclxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5vblJvdXRlclN0YXRzQ2hhbmdlXyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgdGhpcy5zZXRSb3V0ZXJRdWV1ZWRQYWNrZXRDb3VudF8ocm91dGVyLmdldFF1ZXVlZFBhY2tldENvdW50KCkpO1xuICB0aGlzLnNldFJvdXRlck1lbW9yeUluVXNlXyhyb3V0ZXIuZ2V0TWVtb3J5SW5Vc2UoKSk7XG4gIHRoaXMuc2V0Um91dGVyRGF0YVJhdGVfKHJvdXRlci5nZXRDdXJyZW50RGF0YVJhdGUoKSk7XG59O1xuXG4vKipcbiAqIFdoYXQgdG8gZG8gd2hlbiBvdXIgY29ubmVjdGVkIHJvdXRlcidzIGxvY2FsIG5ldHdvcmsgY2hhbmdlcy5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUub25Sb3V0ZXJXaXJlc0NoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkVG9Sb3V0ZXIoKSkge1xuICAgIHRoaXMuc2V0RG5zVGFibGVDb250ZW50cyh0aGlzLmdldENvbm5lY3RlZFJvdXRlcigpLmdldEFkZHJlc3NUYWJsZSgpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IHRvIGRvIHdoZW4gb3VyIGNvbm5lY3RlZCByb3V0ZXIncyBsb2dzIGNoYW5nZS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUub25Sb3V0ZXJMb2dDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvUm91dGVyKCkpIHtcbiAgICB0aGlzLnNldFJvdXRlckxvZ0RhdGEodGhpcy5nZXRDb25uZWN0ZWRSb3V0ZXIoKS5nZXRMb2coKSk7XG4gIH1cbn07XG5cbi8qKlxuICogS2ljayBvZmYgYW4gYW5pbWF0aW9uIHRoYXQgc2hvd3MgdGhlIGxvY2FsIG5vZGUgc2V0dGluZyB0aGUgc3RhdGUgb2YgYVxuICogc2ltcGxleCB3aXJlLlxuICogQHBhcmFtIHtcIjBcInxcIjFcIn0gbmV3U3RhdGVcbiAqL1xuTmV0U2ltLnByb3RvdHlwZS5hbmltYXRlU2V0V2lyZVN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gIHRoaXMudmlzdWFsaXphdGlvbl8uYW5pbWF0ZVNldFdpcmVTdGF0ZShuZXdTdGF0ZSk7XG59O1xuXG4vKipcbiAqIEtpY2sgb2ZmIGFuIGFuaW1hdGlvbiB0aGF0IHNob3dzIHRoZSBsb2NhbCBub2RlIHJlYWRpbmcgdGhlIHN0YXRlIG9mIGFcbiAqIHNpbXBsZXggd2lyZS5cbiAqIEBwYXJhbSB7XCIwXCJ8XCIxXCJ9IG5ld1N0YXRlXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuYW5pbWF0ZVJlYWRXaXJlU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgdGhpcy52aXN1YWxpemF0aW9uXy5hbmltYXRlUmVhZFdpcmVTdGF0ZShuZXdTdGF0ZSk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmljYWxseSwgdXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhlIHJpZ2h0IGNvbHVtbiB3aGVuIGNvbm5lY3RlZCxcbiAqIGFuZCBjaGFuZ2UgaG93IHRoZSB0aHJlZSBwYW5lbHMgdGhlcmUgKHJlY2VpdmVkIGxvZywgc2VudCBsb2csIHNlbmQgY29udHJvbHMpXG4gKiBzaGFyZSB0aGUgY3VycmVudCB2ZXJ0aWNhbCBzcGFjZSBpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogV2UncmUgdHJ5aW5nIHRvIHVzZSB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICpcbiAqIDEuIFRoZSBzZW5kIGNvbnRyb2xzIHBhbmVsIGlzIGZpeGVkIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0LCBhbmQgd2lsbFxuICogICAgc2l6ZSB1cHdhcmRzIHRvIGZpdCBpdHMgY29udGVudHMgdXAgdG8gYSBtYXhpbXVtIGhlaWdodC5cbiAqIDIuIFRoZSBsb2cgd2lkZ2V0cyB1c2UgdGhlIHJlbWFpbmluZyB2ZXJ0aWNhbCBzcGFjZVxuICogICAgYSkgSWYgb25seSBvbmUgbG9nIHdpZGdldCBpcyBvcGVuLCBpdCBmaWxscyB0aGUgdmVydGljYWwgc3BhY2UgKGV4Y2VwdFxuICogICAgICAgbGVhdmVzIGVub3VnaCByb29tIHRvIHNlZSB0aGUgb3RoZXIgaGVhZGVyKVxuICogICAgYikgSWYgYm90aCBsb2cgd2lkZ2V0cyBhcmUgb3BlbiwgdGhleSBzaGFyZSB0aGUgdmVydGljYWwgc3BhY2UgNTAvNTBcbiAqICAgIGMpIElmIGJvdGggbG9nIHdpZGdldHMgYXJlIGNsb3NlZCwgdGhleSBmbG9hdCBhdCB0aGUgdG9wIG9mIHRoZSBzcGFjZS5cbiAqL1xuTmV0U2ltLnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByaWdodENvbHVtbiA9ICQoJyNuZXRzaW0tcmlnaHRjb2wnKTtcbiAgdmFyIHNlbmRQYW5lbCA9ICQoJyNuZXRzaW0tc2VuZCcpO1xuICB2YXIgbG9nV3JhcCA9ICQoJyNuZXRzaW0tbG9ncycpO1xuXG4gIG5ldHNpbURlYm91bmNlZFJlc2l6ZUZvb3RlcigpO1xuXG4gIGlmICh0aGlzLmxvYmJ5Xykge1xuICAgIHRoaXMubG9iYnlfLnVwZGF0ZUxheW91dCgpO1xuICB9XG5cbiAgaWYgKCFyaWdodENvbHVtbi5pcygnOnZpc2libGUnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJpZ2h0IGNvbHVtbiB3cmFwcGVyIGFuZCB0aGUgc2VuZCBwYW5lbCBhcmUgYm90aCBzaXplZCBieSBDU1NcbiAgdmFyIHJpZ2h0Q29sdW1uSGVpZ2h0ID0gcmlnaHRDb2x1bW4uaGVpZ2h0KCk7XG4gIHZhciBzZW5kUGFuZWxIZWlnaHQgPSBzZW5kUGFuZWwuaGVpZ2h0KCk7XG4gIHZhciBsb2dzU2hhcmVkVmVydGljYWxTcGFjZSA9IHJpZ2h0Q29sdW1uSGVpZ2h0IC0gc2VuZFBhbmVsSGVpZ2h0O1xuXG4gIHZhciBzaG93aW5nU2VudCA9ICF0aGlzLnNlbnRNZXNzYWdlTG9nXy5pc01pbmltaXplZCgpO1xuICB2YXIgc2hvd2luZ1JlY2VpdmVkID0gIXRoaXMucmVjZWl2ZWRNZXNzYWdlTG9nXy5pc01pbmltaXplZCgpO1xuICBpZiAoc2hvd2luZ1JlY2VpdmVkICYmIHNob3dpbmdTZW50KSB7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKGxvZ3NTaGFyZWRWZXJ0aWNhbFNwYWNlIC8gMik7XG4gICAgdGhpcy5yZWNlaXZlZE1lc3NhZ2VMb2dfLnNldEhlaWdodChoYWxmSGVpZ2h0KTtcbiAgICB0aGlzLnNlbnRNZXNzYWdlTG9nXy5zZXRIZWlnaHQoaGFsZkhlaWdodCk7XG4gIH0gZWxzZSBpZiAoc2hvd2luZ1JlY2VpdmVkKSB7XG4gICAgdGhpcy5yZWNlaXZlZE1lc3NhZ2VMb2dfLnNldEhlaWdodChNYXRoLmZsb29yKGxvZ3NTaGFyZWRWZXJ0aWNhbFNwYWNlIC1cbiAgICAgICAgdGhpcy5zZW50TWVzc2FnZUxvZ18uZ2V0SGVpZ2h0KCkpKTtcbiAgfSBlbHNlIGlmIChzaG93aW5nU2VudCkge1xuICAgIHRoaXMuc2VudE1lc3NhZ2VMb2dfLnNldEhlaWdodChNYXRoLmZsb29yKGxvZ3NTaGFyZWRWZXJ0aWNhbFNwYWNlIC1cbiAgICAgICAgdGhpcy5yZWNlaXZlZE1lc3NhZ2VMb2dfLmdldEhlaWdodCgpKSk7XG4gIH1cblxuICAvLyBNYW51YWxseSBhZGp1c3QgdGhlIGxvZ3dyYXAgdG8gdGhlIHJlbWFpbmluZyBoZWlnaHRcbiAgbG9nV3JhcC5jc3MoJ2hlaWdodCcsIHJpZ2h0Q29sdW1uSGVpZ2h0IC0gc2VuZFBhbmVsSGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQXBwcm9wcmlhdGUgc3RlcHMgZm9yIHdoZW4gdGhlIHN0dWRlbnQgaGl0cyB0aGUgXCJDb250aW51ZSB0byBuZXh0IGxldmVsXCJcbiAqIGJ1dHRvbi4gIFNob3VsZCBtYXJrIHRoZSBsZXZlbCBhcyBjb21wbGV0ZSBhbmQgbmF2aWdhdGUgdG8gdGhlIG5leHQgbGV2ZWwuXG4gKi9cbk5ldFNpbS5wcm90b3R5cGUuY29tcGxldGVMZXZlbEFuZENvbnRpbnVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvUmVtb3RlKCkgJiYgIWNvbmZpcm0oaTE4bi5vbkJlZm9yZVVubG9hZFdhcm5pbmcoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBdm9pZCBtdWx0aXBsZSBzaW11bHRhbmVvdXMgc3VibWlzc2lvbnMuXG4gICQoJy5zdWJtaXRCdXR0b24nKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuXG4gIHNlbmRSZXBvcnQoe1xuICAgIGZhbGxiYWNrUmVzcG9uc2U6IHRoaXMucmVwb3J0aW5nSW5mb18uZmFsbGJhY2tfcmVzcG9uc2UsXG4gICAgY2FsbGJhY2s6IHRoaXMucmVwb3J0aW5nSW5mb18uY2FsbGJhY2ssXG4gICAgYXBwOiAnbmV0c2ltJyxcbiAgICBsZXZlbDogdGhpcy5sZXZlbC5pZCxcbiAgICByZXN1bHQ6IHRydWUsXG4gICAgdGVzdFJlc3VsdDogMTAwLFxuICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIChzZXJ2ZXJSZXNwb25zZSkge1xuXG4gICAgICAvLyBSZS1lbmFibGUgc3VibWl0IGJ1dHRvbiwgaW4gY2FzZSB0aGVyZSdzIG5vd2hlcmUgdG8gZ28uXG4gICAgICAkKCcuc3VibWl0QnV0dG9uJykuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XG5cbiAgICAgIC8vIElmIHRoZXJlJ3Mgc29tZXdoZXJlIHRvIGdvLCBkaXNjb25uZWN0IGFuZCBnbyFcbiAgICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5yZWRpcmVjdCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZFRvUmVtb3RlKCkpIHtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RGcm9tUmVtb3RlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gc2VydmVyUmVzcG9uc2UucmVkaXJlY3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBzZXJ2ZXJSZXNwb25zZS5yZWRpcmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuICB9KTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdCB0byByZXNldCB0aGUgc2ltdWxhdGlvbiBzaGFyZCwga2lja2luZyBhbGwgdXNlcnMgb3V0IGFuZCByZXNldHRpbmdcbiAqIGFsbCBkYXRhLlxuICovXG5OZXRTaW0ucHJvdG90eXBlLnJlc2V0U2hhcmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNoYXJkXyAmJiBjb25maXJtKGkxOG4uc2hhcmRSZXNldENvbmZpcm1hdGlvbigpKSkge1xuICAgIHRoaXMuc2hhcmRfLnJlc2V0RXZlcnl0aGluZyhmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICBOZXRTaW1BbGVydC5lcnJvcihpMThuLnNoYXJkUmVzZXRFcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7XG4gIHZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTtcbjsgYnVmLnB1c2goJ1xcblxcbjxkaXYgaWQ9XCJyb3RhdGVDb250YWluZXJcIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybCgnLCBlc2NhcGUoKDUsICBhc3NldFVybCgnbWVkaWEvdHVybnBob25lX2hvcml6b250YWwucG5nJykgKSksICcpXCI+XFxuICA8ZGl2IGlkPVwicm90YXRlVGV4dFwiPlxcbiAgICA8cD4nLCBlc2NhcGUoKDcsICBtc2cucm90YXRlVGV4dCgpICkpLCAnPGJyPicsIGVzY2FwZSgoNywgIG1zZy5vcmllbnRhdGlvbkxvY2soKSApKSwgJzwvcD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblxcbicpOzExOyB2YXIgaW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24oKSB7OyBidWYucHVzaCgnICA8ZGl2IGlkPVwiYnViYmxlXCIgY2xhc3M9XCJjbGVhcmZpeFwiPlxcbiAgICA8dGFibGUgaWQ9XCJwcm9tcHQtdGFibGVcIj5cXG4gICAgICA8dHI+XFxuICAgICAgICA8dGQgaWQ9XCJwcm9tcHQtaWNvbi1jZWxsXCI+XFxuICAgICAgICAgIDxpbWcgaWQ9XCJwcm9tcHQtaWNvblwiLz5cXG4gICAgICAgIDwvdGQ+XFxuICAgICAgICA8dGQgaWQ9XCJwcm9tcHQtY2VsbFwiPlxcbiAgICAgICAgICA8cCBpZD1cInByb21wdFwiPlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICA8L3RkPlxcbiAgICAgIDwvdHI+XFxuICAgIDwvdGFibGU+XFxuICAgIDxkaXYgaWQ9XCJhbmktZ2lmLXByZXZpZXctd3JhcHBlclwiPlxcbiAgICAgIDxkaXYgaWQ9XCJhbmktZ2lmLXByZXZpZXdcIj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4nKTsyODsgfTs7IGJ1Zi5wdXNoKCdcXG48ZGl2IGlkPVwiYXBwY29udGFpbmVyXCI+XFxuICA8IS0tIFNob3VsZCBkaXNhYmxlIHNwZWxsLWNoZWNrIG9uIGFsbCBuZXRzaW0gZWxlbWVudHMgLS0+XFxuICA8ZGl2IGlkPVwibmV0c2ltXCIgYXV0b2NhcGl0YWxpemU9XCJmYWxzZVwiIGF1dG9jb3JyZWN0PVwiZmFsc2VcIiBhdXRvY29tcGxldGU9XCJmYWxzZVwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiPlxcblxcbiAgICA8ZGl2IGlkPVwibmV0c2ltLWRpc2Nvbm5lY3RlZFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XCJsb2JieS1wYW5lbFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG5cXG4gICAgPGRpdiBpZD1cIm5ldHNpbS1jb25uZWN0ZWRcIj5cXG4gICAgICA8ZGl2IGlkPVwibmV0c2ltLWxlZnRjb2xcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4td2lkdGgtbGltaXRlclwiPlxcblxcbiAgICAgICAgICA8ZGl2IGlkPVwibmV0c2ltLXN0YXR1c1wiPjwvZGl2PlxcblxcbiAgICAgICAgICA8ZGl2IGlkPVwibmV0c2ltLXZpc3VhbGl6YXRpb25cIj48L2Rpdj5cXG5cXG4gICAgICAgICAgPGRpdiBpZD1cIm5ldHNpbS10YWJzXCI+PC9kaXY+XFxuXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGlkPVwibmV0c2ltLXJpZ2h0Y29sXCI+XFxuICAgICAgICA8ZGl2IGlkPVwibmV0c2ltLWxvZ3NcIj5cXG4gICAgICAgICAgPGRpdiBpZD1cIm5ldHNpbS1yZWNlaXZlZFwiPjwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGlkPVwibmV0c2ltLXNlbnRcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cIm5ldHNpbS1zZW5kXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGlkPVwicm91dGVyLWxvZy1tb2RhbFwiIGNsYXNzPVwibW9kYWwgZmFkZVwiPjwvZGl2PlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGlkPVwiZm9vdGVyc1wiIGRpcj1cIicsIGVzY2FwZSgoNjMsICBkYXRhLmxvY2FsZURpcmVjdGlvbiApKSwgJ1wiPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiaGlkZGVuXCI+XFxuICAgICcpOzY2OyBpbnN0cnVjdGlvbnMoKTsgOyBidWYucHVzaCgnXFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVwiY2xlYXJcIj48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKmpzaGludCBtdWx0aXN0cjogdHJ1ZSAqL1xuLyoqXG4gKiBAb3ZlcnZpZXcgVHlwZSBkb2N1bWVudGF0aW9uIGZvciBhIE5ldFNpbSBsZXZlbCBjb25maWd1cmF0aW9uIG9iamVjdCxcbiAqICAgICAgICAgICBhbmQgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoYXQgb2JqZWN0LlxuICovXG5cbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vUGFja2V0Jyk7XG52YXIgQklUU19QRVJfTklCQkxFID0gTmV0U2ltQ29uc3RhbnRzLkJJVFNfUEVSX05JQkJMRTtcbnZhciBNZXNzYWdlR3JhbnVsYXJpdHkgPSBOZXRTaW1Db25zdGFudHMuTWVzc2FnZUdyYW51bGFyaXR5O1xudmFyIERuc01vZGUgPSBOZXRTaW1Db25zdGFudHMuRG5zTW9kZTtcbnZhciBFbmNvZGluZ1R5cGUgPSBOZXRTaW1Db25zdGFudHMuRW5jb2RpbmdUeXBlO1xudmFyIE5ldFNpbVRhYlR5cGUgPSBOZXRTaW1Db25zdGFudHMuTmV0U2ltVGFiVHlwZTtcblxuLyoqXG4gKiBBIGxldmVsIGNvbmZpZ3VyYXRpb24gdGhhdCBjYW4gYmUgdXNlZCBieSBOZXRTaW1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5ldFNpbUxldmVsQ29uZmlndXJhdGlvblxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnN0cnVjdGlvbnMgLSBJbmhlcml0ZWQgZnJvbSBibG9ja2x5IGxldmVsIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93Q2xpZW50c0luTG9iYnkgLSBXaGV0aGVyIGNsaWVudCBub2RlcyBzaG91bGQgYXBwZWFyXG4gKiAgICAgICAgICAgaW4gdGhlIGxvYmJ5IGxpc3QgYXQgYWxsLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd1JvdXRlcnNJbkxvYmJ5IC0gV2hldGhlciByb3V0ZXIgbm9kZXMgc2hvdWxkIGFwcGVhclxuICogICAgICAgICAgIGluIHRoZSBsb2JieSBsaXN0IGF0IGFsbC5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbkNvbm5lY3RUb0NsaWVudHMgLSBXaGV0aGVyIGNsaWVudCBub2RlcyBhcmUgc2VsZWN0YWJsZVxuICogICAgICAgICAgIGFuZCBjYW4gYmUgY29ubmVjdGVkIHRvXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5Db25uZWN0VG9Sb3V0ZXJzIC0gV2hldGhlciByb3V0ZXIgbm9kZXMgYXJlIHNlbGVjdGFibGVcbiAqICAgICAgICAgICBhbmQgY2FuIGJlIGNvbm5lY3RlZCB0b1xuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0FkZFJvdXRlckJ1dHRvbiAtIFdoZXRoZXIgdGhlIFwiQWRkIFJvdXRlclwiIGJ1dHRvblxuICogICAgICAgICAgIHNob3VsZCBhcHBlYXIgYWJvdmUgdGhlIGxvYmJ5IGxpc3QuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93TG9nQnJvd3NlckJ1dHRvbiAtIFdoZXRoZXIgdGhlIFwiTG9nIEJyb3dzZXJcIiBpc1xuICogICAgICAgICAgIGF2YWlsYWJsZSBpbiB0aGUgbG9iYnkuXG4gKlxuICogQHByb3BlcnR5IHtNZXNzYWdlR3JhbnVsYXJpdHl9IG1lc3NhZ2VHcmFudWxhcml0eSAtIFdoZXRoZXIgdGhlIHNpbXVsYXRvclxuICogICAgICAgICAgIHB1dHMgYSBzaW5nbGUgYml0IGludG8gc3RvcmFnZSBhdCBhIHRpbWUsIG9yIGEgd2hvbGUgcGFja2V0LlxuICogICAgICAgICAgIFNob3VsZCB1c2UgJ2JpdHMnIGZvciB2YXJpYW50IDEgKGxldmVscyBhYm91dCB0aGUgY29vcmRpbmF0aW9uXG4gKiAgICAgICAgICAgcHJvYmxlbSksIGFuZCAncGFja2V0cycgZm9yIGxldmVscyB3aGVyZSB0aGUgY29vcmRpbmF0aW9uIHByb2JsZW1cbiAqICAgICAgICAgICBpcyBhYnN0cmFjdGVkIGF3YXkuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvbWF0aWNSZWNlaXZlIC0gV2hldGhlciB0aGUgbG9jYWwgbm9kZSB3aWxsXG4gKiAgICAgICAgICAgYXV0b21hdGljYWxseSBwaWNrIHVwIG1lc3NhZ2VzIHRvIGl0c2VsZiBmcm9tIHRoZSBtZXNzYWdlIHRhYmxlLFxuICogICAgICAgICAgIGFuZCBkdW1wIHRoZW0gdG8gdGhlIHJlY2VpdmVkIG1lc3NhZ2UgbG9nLiAgSWYgZmFsc2UsIHNvbWUgb3RoZXJcbiAqICAgICAgICAgICBtZXRob2QgbXVzdCBiZSB1c2VkIGZvciByZWNlaXZpbmcgbWVzc2FnZXMuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBicm9hZGNhc3RNb2RlIC0gRW5hYmxpbmcgdGhpcyBvcHRpb24gdHVybnMgXCJyb3V0ZXJzXCJcbiAqICAgICAgICAgICBpbnRvIFwicm9vbXNcIiBhbmQgbWFrZXMgaXQgc28gZXZlcnkgbWVzc2FnZSBzZW50IGluIHRoZSByb29tXG4gKiAgICAgICAgICAgd2lsbCBiZSByZWNlaXZlZCBieSBldmVyeSBvdGhlciBwZXJzb24gaW4gdGhhdCByb29tLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29ubmVjdGVkUm91dGVycyAtIFdoZW4gZmFsc2UgKGRlZmF1bHQpLCBlYWNoIHJvdXRlciBvclxuICogICAgICAgICAgIHJvb20gZXhpc3RzIGluIGlzb2xhdGlvbiBhbmQgd2lsbCBoYXZlIG5vIGNvbnRhY3Qgd2l0aCBvdGhlciByb3V0ZXJzXG4gKiAgICAgICAgICAgb3Igcm9vbXMuICBXaGVuIHRydWUsIGl0IGlzIHBvc3NpYmxlIGZvciBtZXNzYWdlcyB0byB0cmF2ZWwgYmV0d2VlblxuICogICAgICAgICAgIHJvdXRlcnMsIGNvbm5lY3RpbmcgdGhlIHdob2xlIHNoYXJkLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5pbXVtRXh0cmFIb3BzIC0gRmV3ZXN0IG5vbi1kZXN0aW5hdGlvbiByb3V0ZXJzIGFuXG4gKiAgICAgICAgICAgaW50ZXItcm91dGVyIG1lc3NhZ2Ugc2hvdWxkIHRyeSB0byB2aXNpdCBiZWZvcmUgZ29pbmcgdG8gaXRzXG4gKiAgICAgICAgICAgZGVzdGluYXRpb24gcm91dGVyLiAgTnVtYmVyIG9mIGhvcHMgY2FuIGJlIGxvd2VyIGlmIG5ldHdvcmtcbiAqICAgICAgICAgICBjb25kaXRpb25zIGRvbid0IGFsbG93IGl0LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhpbXVtRXh0cmFIb3BzIC0gTW9zdCBub24tZGVzdGluYXRpb24gcm91dGVycyBhblxuICogICAgICAgICAgIGludGVyLXJvdXRlciBtZXNzYWdlIHNob3VsZCB0cnkgdG8gdmlzaXQgYmVmb3JlIGdvaW5nIHRvIGl0c1xuICogICAgICAgICAgIGRlc3RpbmF0aW9uIHJvdXRlci5cbiAqXG4gKiBAcHJvcGVydHkge0FkZHJlc3NIZWFkZXJGb3JtYXR9IGFkZHJlc3NGb3JtYXQgLSBTcGVjaWZ5IGhvdyBtYW55IGJpdHMgd2lkZVxuICogICAgICAgICAgIGFuIGFkZHJlc3MgaXMgd2l0aGluIHRoZSBzaW11bGF0aW9uIGFuZCBob3cgaXQgc2hvdWxkIGJlIGRpdmlkZWRcbiAqICAgICAgICAgICB1cCBpbnRvIGEgaGllcmFyY2h5LiBGb3JtYXQgcmVzZW1ibGVzIElQdjQgZG90LWRlY2ltYWwgbm90YXRpb24sXG4gKiAgICAgICAgICAgYnV0IHRoZSBudW1iZXJzIHNwZWNpZnkgdGhlIG51bWJlciBvZiBiaXRzIGZvciBlYWNoIHNlY3Rpb24uXG4gKiAgICAgICAgICAgRXhhbXBsZXM6XG4gKiAgICAgICAgICAgXCI4LjhcIiAtIDE2LWJpdCBhZGRyZXNzLCByZXByZXNlbnRlZCBhcyB0d28gOC1iaXQgaW50ZWdlcnMuXG4gKiAgICAgICAgICAgXCI0XCIgLSA0IGJpdCBhZGRyZXNzIHJlcHJlc2VudGVkIGFzIG9uZSA0LWJpdCBpbnRlZ2VyLlxuICogICAgICAgICAgIFwiOC40XCIgLSAxMi1iaXQgYWRkcmVzcywgcmVwcmVzZW50ZWQgYXMgYW4gOC1iaXQgaW50ZWdlciBmb2xsb3dlZFxuICogICAgICAgICAgICAgICAgICAgYnkgYSA0LWJpdCBpbnRlZ2VyXG4gKiAgICAgICAgICAgIFRoaXMgZm9ybWF0IHdpbGwgYmUgYXBwbGllZCB0byBhbnkgXCJmcm9tQWRkcmVzc1wiIG9yIFwidG9BZGRyZXNzXCJcbiAqICAgICAgICAgICAgaGVhZGVyIGZpZWxkcyBpbiB0aGUgcGFja2V0IHNwZWNpZmljYXRpb24sIGFuZCB3aWxsIGRldGVybWluZVxuICogICAgICAgICAgICBob3cgcm91dGVycyBhc3NpZ24gYWRkcmVzc2VzLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWNrZXRDb3VudEJpdFdpZHRoIC0gSG93IG1hbnkgYml0cyBzaG91bGQgYmUgYWxsb2NhdGVkXG4gKiAgICAgICAgICAgZm9yIGFueSBcInBhY2tldEluZGV4XCIgb3IgXCJwYWNrZXRDb3VudFwiIGZpZWxkcyBpbiB0aGUgcGFja2V0XG4gKiAgICAgICAgICAgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge1BhY2tldC5IZWFkZXJUeXBlW119IHJvdXRlckV4cGVjdHNQYWNrZXRIZWFkZXIgLSBUaGUgaGVhZGVyIGZvcm1hdFxuICogICAgICAgICAgIHRoZSByb3V0ZXIgdXNlcyB0byBwYXJzZSBpbmNvbWluZyBwYWNrZXRzIGFuZCBmaWd1cmUgb3V0IHdoZXJlXG4gKiAgICAgICAgICAgdG8gcm91dGUgdGhlbS5cbiAqXG4gKiBAcHJvcGVydHkge1BhY2tldC5IZWFkZXJUeXBlW119IGNsaWVudEluaXRpYWxQYWNrZXRIZWFkZXIgLSBUaGUgaGVhZGVyIGZvcm1hdFxuICogICAgICAgICAgIHVzZWQgYnkgdGhlIGxvY2FsIGNsaWVudCBub2RlIHdoZW4gZ2VuZXJhdGluZy9wYXJzaW5nIHBhY2tldHMsXG4gKiAgICAgICAgICAgd2hpY2ggYWZmZWN0cyB0aGUgbGF5b3V0IG9mIHRoZSBzZW5kIHBhbmVsIGFuZCBsb2cgcGFuZWxzLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0hvc3RuYW1lSW5HcmFwaCAtIElmIGZhbHNlLCBzdHVkZW50IGRpc3BsYXkgbmFtZVxuICogICAgICAgICAgIGlzIHVzZWQgaW4gdGhlIG5ldHdvcmsgZ3JhcGguICBJZiB0cnVlLCB0aGVpciBnZW5lcmF0ZWQgaG9zdG5hbWVcbiAqICAgICAgICAgICBpcyBkaXNwbGF5ZWQuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93QWRkUGFja2V0QnV0dG9uIC0gV2hldGhlciB0aGUgXCJBZGQgUGFja2V0XCIgYnV0dG9uXG4gKiAgICAgICAgICAgc2hvdWxkIGFwcGVhciBpbiB0aGUgc2VuZCB3aWRnZXQuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93UGFja2V0U2l6ZUNvbnRyb2wgLSBXaGV0aGVyIHRoZSBwYWNrZXQgc2l6ZSBzbGlkZXJcbiAqICAgICAgICAgICBzaG91bGQgYXBwZWFyIGluIHRoZSBzZW5kIHdpZGdldC5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVmYXVsdFBhY2tldFNpemVMaW1pdCAtIEluaXRpYWwgbWF4aW11bSBwYWNrZXQgc2l6ZS5cbiAqXG4gKiBAcHJvcGVydHkge05ldFNpbVRhYlR5cGVbXX0gc2hvd1RhYnMgLSBXaGljaCB0YWJzIHNob3VsZCBhcHBlYXIgYmVuZWF0aCB0aGVcbiAqICAgICAgICAgICBuZXR3b3JrIHZpc3VhbGl6YXRpb24uICBEb2VzIG5vdCBkZXRlcm1pbmUgdGFiIG9yZGVyOyB0YWJzIGFsd2F5c1xuICogICAgICAgICAgIGFwcGVhciBpbiB0aGUgb3JkZXIgXCJJbnN0cnVjdGlvbnMsIE15IERldmljZSwgUm91dGVyLCBETlMuXCJcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVmYXVsdFRhYkluZGV4IC0gVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIHRhYlxuICogICAgICAgICAgIHRoYXQgc2hvdWxkIGJlIGFjdGl2ZSBieSBkZWZhdWx0LCB3aGljaCBkZXBlbmRzIG9uIHdoaWNoIHRhYnNcbiAqICAgICAgICAgICB5b3UgaGF2ZSBlbmFibGVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd1B1bHNlUmF0ZVNsaWRlciAtIFdoZXRoZXIgdGhlIHB1bHNlIHJhdGUgc2xpZGVyXG4gKiAgICAgICAgICAgaXMgdmlzaWJsZSBvbiB0aGUgXCJNeSBEZXZpY2VcIiB0YWIuICBUaGlzIGNvbnRyb2wgaXMgYSBkaWZmZXJlbnRcbiAqICAgICAgICAgICB2aWV3IG9uIHRoZSBiaXRyYXRlLCBnaXZlbiBpbiBzZWNvbmRzLXBlci1wdWxzZTsgaW4gZmFjdCwgaWYgYm90aFxuICogICAgICAgICAgIHRoaXMgYW5kIHRoZSBiaXRyYXRlIHNsaWRlciBhcmUgdmlzaWJsZSwgZHJhZ2dpbmcgb25lIHdpbGwgY2hhbmdlXG4gKiAgICAgICAgICAgdGhlIG90aGVyLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd01ldHJvbm9tZSAtIFdoZXRoZXIgdGhlIG1ldHJvbm9tZSBzaG91bGQgc2hvdyB1cCBvblxuICogICAgICAgICAgIHRoZSBcIk15IERldmljZVwiIHRhYi5cbiAqXG4gKiBAcHJvcGVydHkge0VuY29kaW5nVHlwZVtdfSBzaG93RW5jb2RpbmdDb250cm9scyAtIFdoaWNoIGVuY29kaW5ncywgKEFTQ0lJLFxuICogICAgICAgICAgIGJpbmFyeSwgZXRjLikgc2hvdWxkIGhhdmUgdmlzaWJsZSBjb250cm9scyBvbiB0aGUgXCJNeSBEZXZpY2VcIiB0YWIuXG4gKlxuICogQHByb3BlcnR5IHtFbmNvZGluZ1R5cGVbXX0gZGVmYXVsdEVuYWJsZWRFbmNvZGluZ3MgLSBXaGljaCBlbmNvZGluZ3Mgc2hvdWxkXG4gKiAgICAgICAgICAgYmUgZW5hYmxlZCBvbiBwYWdlIGxvYWQuICBOb3RlOiBBbiBlbmNvZGluZyBlbmFibGVkIGhlcmUgYnV0IG5vdFxuICogICAgICAgICAgIGluY2x1ZGVkIGluIHRoZSB2aXNpYmxlIGNvbnRyb2xzIHdpbGwgYmUgZW5hYmxlZCBhbmQgY2Fubm90IGJlXG4gKiAgICAgICAgICAgZGlzYWJsZWQgYnkgdGhlIHN0dWRlbnQuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93Qml0UmF0ZUNvbnRyb2wgLSBXaGV0aGVyIHRoZSBiaXQgcmF0ZSBzbGlkZXIgc2hvdWxkXG4gKiAgICAgICAgICAgYmUgZGlzcGxheWVkIG9uIHRoZSBcIk15IERldmljZVwiIHRhYi5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGxvY2tCaXRSYXRlQ29udHJvbCAtIFdoZXRoZXIgdGhlIGJpdCByYXRlIHNsaWRlciBzaG91bGRcbiAqICAgICAgICAgICBiZSBhZGp1c3RhYmxlIGJ5IHRoZSBzdHVkZW50LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0Qml0UmF0ZUJpdHNQZXJTZWNvbmQgLSBEZWZhdWx0IGJpdCByYXRlIG9uIGxldmVsXG4gKiAgICAgICAgICAgbG9hZC4gIEFsc28gc2V0cyB0aGUgcHVsc2UgcmF0ZSBmb3IgbGV2ZWxzIHdpdGggdGhlIG1ldHJvbm9tZS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3dDaHVua1NpemVDb250cm9sIC0gV2hldGhlciB0aGUgY2h1bmsgc2l6ZSBzbGlkZXJcbiAqICAgICAgICAgICBzaG91bGQgYmUgZGlzcGxheWVkIG9uIHRoZSBcIk15IERldmljZVwiIHRhYi5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGxvY2tDaHVua1NpemVDb250cm9sIC0gV2hldGhlciB0aGUgY2h1bmsgc2l6ZSBzbGlkZXJcbiAqICAgICAgICAgICBzaG91bGQgYmUgYWRqdXN0YWJsZSBieSB0aGUgc3R1ZGVudC5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVmYXVsdENodW5rU2l6ZUJpdHMtIERlZmF1bHQgY2h1bmsgc2l6ZSBvbiBsZXZlbCBsb2FkLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd1JvdXRlckJhbmR3aWR0aENvbnRyb2wgLSBXaGV0aGVyIHN0dWRlbnRzIHNob3VsZCBiZVxuICogICAgICAgICAgIGFibGUgdG8gc2VlIGFuZCBtYW5pcHVsYXRlIHRoZSBzbGlkZXIgdGhhdCBhZGp1c3RzIHRoZSByb3V0ZXInc1xuICogICAgICAgICAgIG1heCB0aHJvdWdocHV0IHNwZWVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0Um91dGVyQmFuZHdpZHRoIC0gSG93IGZhc3QgdGhlIHJvdXRlciBzaG91bGQgYmVcbiAqICAgICAgICAgICBhYmxlIHRvIHByb2Nlc3MgcGFja2V0cywgb24gaW5pdGlhbCBsZXZlbCBsb2FkLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd1JvdXRlck1lbW9yeUNvbnRyb2wgLSBXaGV0aGVyIHN0dWRlbnRzIHNob3VsZCBiZVxuICogICAgICAgICAgIGFibGUgdG8gc2VlIGFuZCBtYW5pcHVsYXRlIHRoZSBzbGlkZXIgdGhhdCBhZGp1c3RzIHRoZSByb3V0ZXInc1xuICogICAgICAgICAgIG1heGltdW0gcXVldWUgbWVtb3J5LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0Um91dGVyTWVtb3J5IC0gSG93IG11Y2ggZGF0YSB0aGUgcm91dGVyIHBhY2tldFxuICogICAgICAgICAgIHF1ZXVlIGlzIGFibGUgdG8gaG9sZCBiZWZvcmUgaXQgc3RhcnRzIGRyb3BwaW5nIHBhY2tldHMsIGluIGJpdHMuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRSYW5kb21Ecm9wQ2hhbmNlIC0gT2RkcyB0aGF0IHRoZSByb3V0ZXIgd2lsbCBkcm9wXG4gKiAgICAgICAgICAgdGhlIHBhY2tldCBmb3Igbm8gcmVhc29uIHdoaWxlIHJvdXRpbmcgaXQuICBWYWx1ZSBpbiByYW5nZVxuICogICAgICAgICAgIDAgKG5vIGRyb3BzKSB0byAxIChkcm9wIGV2ZXJ5dGhpbmcpXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93RG5zTW9kZUNvbnRyb2wgLSBXaGV0aGVyIHRoZSBETlMgbW9kZSBjb250cm9scyB3aWxsXG4gKiAgICAgICAgICAgYmUgYXZhaWxhYmxlIHRvIHRoZSBzdHVkZW50LlxuICpcbiAqIEBwcm9wZXJ0eSB7RG5zTW9kZX0gZGVmYXVsdERuc01vZGUgLSBXaGljaCBETlMgbW9kZSB0aGUgc2ltdWxhdG9yIHNob3VsZFxuICogICAgICAgICAgIGluaXRpYWxpemUgaW50by5cbiAqL1xuXG4vKlxuICogQ29uZmlndXJhdGlvbiBmb3IgYWxsIGxldmVscy5cbiAqL1xudmFyIGxldmVscyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogQSBkZWZhdWx0IGxldmVsIGNvbmZpZ3VyYXRpb24gc28gdGhhdCB3ZSBjYW4gZGVmaW5lIHRoZSBvdGhlcnMgYnkgZGVsdGEuXG4gKiBUaGlzIGRlZmF1bHQgY29uZmlndXJhdGlvbiBlbmFibGVzIGV2ZXJ5dGhpbmcgcG9zc2libGUsIHNvIG90aGVyIGNvbmZpZ3NcbiAqIHNob3VsZCBzdGFydCB3aXRoIHRoaXMgb25lIGFuZCBkaXNhYmxlIGZlYXR1cmVzLlxuICogQHR5cGUge05ldFNpbUxldmVsQ29uZmlndXJhdGlvbn1cbiAqL1xubGV2ZWxzLmN1c3RvbSA9IHtcblxuICAvLyBMb2JieSBjb25maWd1cmF0aW9uXG4gIHNob3dDbGllbnRzSW5Mb2JieTogZmFsc2UsXG4gIHNob3dSb3V0ZXJzSW5Mb2JieTogZmFsc2UsXG4gIGNhbkNvbm5lY3RUb0NsaWVudHM6IGZhbHNlLFxuICBjYW5Db25uZWN0VG9Sb3V0ZXJzOiBmYWxzZSxcbiAgc2hvd0FkZFJvdXRlckJ1dHRvbjogZmFsc2UsXG4gIHNob3dMb2dCcm93c2VyQnV0dG9uOiBmYWxzZSxcblxuICAvLyBTaW11bGF0b3Itd2lkZSBzZXR1cFxuICBtZXNzYWdlR3JhbnVsYXJpdHk6IE1lc3NhZ2VHcmFudWxhcml0eS5CSVRTLFxuICBhdXRvbWF0aWNSZWNlaXZlOiBmYWxzZSxcbiAgYnJvYWRjYXN0TW9kZTogZmFsc2UsXG4gIGNvbm5lY3RlZFJvdXRlcnM6IGZhbHNlLFxuICBtaW5pbXVtRXh0cmFIb3BzOiAwLFxuICBtYXhpbXVtRXh0cmFIb3BzOiAwLFxuXG4gIC8vIFBhY2tldCBoZWFkZXIgc3BlY2lmaWNhdGlvblxuICBhZGRyZXNzRm9ybWF0OiAnNCcsXG4gIHBhY2tldENvdW50Qml0V2lkdGg6IDQsXG4gIHJvdXRlckV4cGVjdHNQYWNrZXRIZWFkZXI6IFtdLFxuICBjbGllbnRJbml0aWFsUGFja2V0SGVhZGVyOiBbXSxcblxuICAvLyBWaXN1YWxpemF0aW9uIGNvbmZpZ3VyYXRpb25cbiAgc2hvd0hvc3RuYW1lSW5HcmFwaDogZmFsc2UsXG5cbiAgLy8gU2VuZCB3aWRnZXQgY29uZmlndXJhdGlvblxuICBzaG93QWRkUGFja2V0QnV0dG9uOiBmYWxzZSxcbiAgc2hvd1BhY2tldFNpemVDb250cm9sOiBmYWxzZSxcbiAgZGVmYXVsdFBhY2tldFNpemVMaW1pdDogODE5MixcblxuICAvLyBUYWItcGFuZWwgY29udHJvbFxuICBzaG93VGFiczogW10sXG4gIGRlZmF1bHRUYWJJbmRleDogMCxcblxuICAvLyBJbnN0cnVjdGlvbnMgdGFiIGFuZCBpdHMgY29udHJvbHNcbiAgLy8gTm90ZTogVXNlcyB0aGUgYmxvY2tseS1zdGFuZGFyZCBsZXZlbC5pbnN0cnVjdGlvbnMgdmFsdWUsIHdoaWNoIHNob3VsZFxuICAvLyAgICAgICBiZSBsb2NhbGl6ZWQgYnkgdGhlIHRpbWUgaXQgZ2V0cyBoZXJlLlxuXG4gIC8vIFwiTXkgRGV2aWNlXCIgdGFiIGFuZCBpdHMgY29udHJvbHNcbiAgc2hvd1B1bHNlUmF0ZVNsaWRlcjogZmFsc2UsXG4gIHNob3dNZXRyb25vbWU6IGZhbHNlLFxuICBzaG93RW5jb2RpbmdDb250cm9sczogW10sXG4gIGRlZmF1bHRFbmFibGVkRW5jb2RpbmdzOiBbXSxcbiAgc2hvd0JpdFJhdGVDb250cm9sOiBmYWxzZSxcbiAgbG9ja0JpdFJhdGVDb250cm9sOiBmYWxzZSxcbiAgZGVmYXVsdEJpdFJhdGVCaXRzUGVyU2Vjb25kOiBJbmZpbml0eSxcbiAgc2hvd0NodW5rU2l6ZUNvbnRyb2w6IGZhbHNlLFxuICBsb2NrQ2h1bmtTaXplQ29udHJvbDogZmFsc2UsXG4gIGRlZmF1bHRDaHVua1NpemVCaXRzOiA4LFxuXG4gIC8vIFJvdXRlciB0YWIgYW5kIGl0cyBjb250cm9sc1xuICBzaG93Um91dGVyQmFuZHdpZHRoQ29udHJvbDogZmFsc2UsXG4gIGRlZmF1bHRSb3V0ZXJCYW5kd2lkdGg6IEluZmluaXR5LFxuICBzaG93Um91dGVyTWVtb3J5Q29udHJvbDogZmFsc2UsXG4gIGRlZmF1bHRSb3V0ZXJNZW1vcnk6IEluZmluaXR5LFxuICBkZWZhdWx0UmFuZG9tRHJvcENoYW5jZTogMCxcblxuICAvLyBETlMgdGFiIGFuZCBpdHMgY29udHJvbHNcbiAgc2hvd0Ruc01vZGVDb250cm9sOiBmYWxzZSxcbiAgZGVmYXVsdERuc01vZGU6IERuc01vZGUuTk9ORVxufTtcblxuLyoqXG4gKiBTcGVjaWFsIGxldmVsIGNvbmZpZ3VyYXRpb24gZm9yIHVzZSB3aXRoICdncnVudCBkZXYnIHN0YW5kYWxvbmUgbW9kZS5cbiAqIE5ldmVyIHVzZWQgd2hlbiBzZXJ2aW5nIE5ldFNpbSBsZXZlbHMgdGhyb3VnaCBkYXNoYm9hcmQuXG4gKiBAdHlwZSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufVxuICovXG5sZXZlbHMucGxheWdyb3VuZCA9IHtcblxuICAvLyBMb2JieSBjb25maWd1cmF0aW9uXG4gIHNob3dDbGllbnRzSW5Mb2JieTogZmFsc2UsXG4gIHNob3dSb3V0ZXJzSW5Mb2JieTogdHJ1ZSxcbiAgY2FuQ29ubmVjdFRvQ2xpZW50czogZmFsc2UsXG4gIGNhbkNvbm5lY3RUb1JvdXRlcnM6IHRydWUsXG4gIHNob3dBZGRSb3V0ZXJCdXR0b246IHRydWUsXG4gIHNob3dMb2dCcm93c2VyQnV0dG9uOiB0cnVlLFxuXG4gIC8vIFNpbXVsYXRvci13aWRlIHNldHVwXG4gIG1lc3NhZ2VHcmFudWxhcml0eTogTWVzc2FnZUdyYW51bGFyaXR5LlBBQ0tFVFMsXG4gIGF1dG9tYXRpY1JlY2VpdmU6IHRydWUsXG4gIGJyb2FkY2FzdE1vZGU6IGZhbHNlLFxuICBjb25uZWN0ZWRSb3V0ZXJzOiBmYWxzZSxcbiAgbWluaW11bUV4dHJhSG9wczogMCxcbiAgbWF4aW11bUV4dHJhSG9wczogMCxcblxuICAvLyBQYWNrZXQgaGVhZGVyIHNwZWNpZmljYXRpb25cbiAgYWRkcmVzc0Zvcm1hdDogJzQnLFxuICBwYWNrZXRDb3VudEJpdFdpZHRoOiA0LFxuICByb3V0ZXJFeHBlY3RzUGFja2V0SGVhZGVyOiBbJ3RvQWRkcmVzcycsICdmcm9tQWRkcmVzcyddLFxuICBjbGllbnRJbml0aWFsUGFja2V0SGVhZGVyOiBbJ3RvQWRkcmVzcycsICdmcm9tQWRkcmVzcyddLFxuXG4gIC8vIFZpc3VhbGl6YXRpb24gY29uZmlndXJhdGlvblxuICBzaG93SG9zdG5hbWVJbkdyYXBoOiBmYWxzZSxcblxuICAvLyBTZW5kIHdpZGdldCBjb25maWd1cmF0aW9uXG4gIHNob3dBZGRQYWNrZXRCdXR0b246IGZhbHNlLFxuICBzaG93UGFja2V0U2l6ZUNvbnRyb2w6IGZhbHNlLFxuICBkZWZhdWx0UGFja2V0U2l6ZUxpbWl0OiA4MTkyLFxuXG4gIC8vIFRhYi1wYW5lbCBjb250cm9sXG4gIHNob3dUYWJzOiBbJ2luc3RydWN0aW9ucycsICdteV9kZXZpY2UnLCAncm91dGVyJywgJ2RucyddLFxuICBkZWZhdWx0VGFiSW5kZXg6IDAsXG5cbiAgLy8gSW5zdHJ1Y3Rpb25zIHRhYiBhbmQgaXRzIGNvbnRyb2xzXG4gIC8vIE5vdGU6IFVzZXMgdGhlIGJsb2NrbHktc3RhbmRhcmQgbGV2ZWwuaW5zdHJ1Y3Rpb25zIHZhbHVlLCB3aGljaCBzaG91bGRcbiAgLy8gICAgICAgYmUgbG9jYWxpemVkIGJ5IHRoZSB0aW1lIGl0IGdldHMgaGVyZS5cblxuICAvLyBcIk15IERldmljZVwiIHRhYiBhbmQgaXRzIGNvbnRyb2xzXG4gIHNob3dQdWxzZVJhdGVTbGlkZXI6IGZhbHNlLFxuICBzaG93TWV0cm9ub21lOiBmYWxzZSxcbiAgc2hvd0VuY29kaW5nQ29udHJvbHM6IFsnYV9hbmRfYicsICdiaW5hcnknLCAnaGV4YWRlY2ltYWwnLCAnZGVjaW1hbCcsICdhc2NpaSddLFxuICBkZWZhdWx0RW5hYmxlZEVuY29kaW5nczogWydhX2FuZF9iJywgJ2JpbmFyeScsICdoZXhhZGVjaW1hbCcsICdkZWNpbWFsJywgJ2FzY2lpJ10sXG4gIHNob3dCaXRSYXRlQ29udHJvbDogdHJ1ZSxcbiAgbG9ja0JpdFJhdGVDb250cm9sOiBmYWxzZSxcbiAgZGVmYXVsdEJpdFJhdGVCaXRzUGVyU2Vjb25kOiBJbmZpbml0eSxcbiAgc2hvd0NodW5rU2l6ZUNvbnRyb2w6IHRydWUsXG4gIGxvY2tDaHVua1NpemVDb250cm9sOiBmYWxzZSxcbiAgZGVmYXVsdENodW5rU2l6ZUJpdHM6IDgsXG5cbiAgLy8gUm91dGVyIHRhYiBhbmQgaXRzIGNvbnRyb2xzXG4gIHNob3dSb3V0ZXJCYW5kd2lkdGhDb250cm9sOiB0cnVlLFxuICBkZWZhdWx0Um91dGVyQmFuZHdpZHRoOiBJbmZpbml0eSxcbiAgc2hvd1JvdXRlck1lbW9yeUNvbnRyb2w6IHRydWUsXG4gIGRlZmF1bHRSb3V0ZXJNZW1vcnk6IEluZmluaXR5LFxuICBkZWZhdWx0UmFuZG9tRHJvcENoYW5jZTogMCxcblxuICAvLyBETlMgdGFiIGFuZCBpdHMgY29udHJvbHNcbiAgc2hvd0Ruc01vZGVDb250cm9sOiB0cnVlLFxuICBkZWZhdWx0RG5zTW9kZTogRG5zTW9kZS5OT05FXG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8ZGl2IGlkPVwic2xpZGVyLWNlbGxcIj5cXG4gIDxpbWcgaWQ9XCJzcGlubmVyXCIgc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW47XCIgc3JjPVwiJywgZXNjYXBlKCgyLCAgYXNzZXRVcmwoJ21lZGlhL25ldHNpbS9sb2FkaW5nLmdpZicpICkpLCAnXCIgaGVpZ2h0PTE1IHdpZHRoPTE1PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFRvcC1sZXZlbCBjb250cm9sbGVyIGZvciB0aGUgbmV0d29yayB2aXN1YWxpemF0aW9uLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgdmlzdWFsaXphdGlvbk1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltVmlzdWFsaXphdGlvbi5odG1sLmVqcycpO1xudmFyIE5ldFNpbU5vZGVGYWN0b3J5ID0gcmVxdWlyZSgnLi9OZXRTaW1Ob2RlRmFjdG9yeScpO1xudmFyIE5ldFNpbVdpcmUgPSByZXF1aXJlKCcuL05ldFNpbVdpcmUnKTtcbnZhciBOZXRTaW1WaXpBdXRvRG5zTm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltVml6QXV0b0Ruc05vZGUnKTtcbnZhciBOZXRTaW1WaXpOb2RlID0gcmVxdWlyZSgnLi9OZXRTaW1WaXpOb2RlJyk7XG52YXIgTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUgPSByZXF1aXJlKCcuL05ldFNpbVZpelNpbXVsYXRpb25Ob2RlJyk7XG52YXIgTmV0U2ltVml6U2ltdWxhdGlvbldpcmUgPSByZXF1aXJlKCcuL05ldFNpbVZpelNpbXVsYXRpb25XaXJlJyk7XG52YXIgTmV0U2ltVml6V2lyZSA9IHJlcXVpcmUoJy4vTmV0U2ltVml6V2lyZScpO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcbnZhciB0d2VlbnMgPSByZXF1aXJlKCcuL3R3ZWVucycpO1xudmFyIE5ldFNpbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJyk7XG52YXIgRG5zTW9kZSA9IE5ldFNpbUNvbnN0YW50cy5EbnNNb2RlO1xudmFyIE5vZGVUeXBlID0gTmV0U2ltQ29uc3RhbnRzLk5vZGVUeXBlO1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGJsdXJyZWQgdmlzdWFsaXphdGlvbiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBzaG93bi5cbiAqIEBjb25zdCB7Ym9vbGVhbn1cbiAqL1xudmFyIFNIT1dfQkFDS0dST1VORCA9IGZhbHNlO1xuXG4vKipcbiAqIFRvcC1sZXZlbCBjb250cm9sbGVyIGZvciB0aGUgbmV0d29yayB2aXN1YWxpemF0aW9uLlxuICpcbiAqIEZvciB0aGUgbW9zdCBwYXJ0LCB0aGUgdmlzdWFsaXphdGlvbiBhdHRhY2hlcyB0byB0aGUgcmF3IG5ldHdvcmsgc3RhdGVcbiAqIHJlcHJlc2VudGF0aW9uICh0aGUgc3RvcmFnZSB0YWJsZXMpIGFuZCB1cGRhdGVzIHRvIHJlZmxlY3QgdGhhdCBzdGF0ZSxcbiAqIGluZGVwZW5kZW50IG9mIHRoZSByZXN0IG9mIHRoZSBjb250cm9scyBvbiB0aGUgcGFnZS4gIFRoaXMgc2VwYXJhdGlvbiBtZWFuc1xuICogdGhhdCB0aGUgdmlzdWFsaXphdGlvbiBhbHdheXMgaGFzIG9uZSBjYW5vbmljYWwgc3RhdGUgdG8gb2JzZXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdiAtIFRoZSA8ZGl2PiB0YWcgd2l0aGluIHdoaWNoIHRoZSB2aXN1YWxpemF0aW9uXG4gKiAgICAgICAgd2lsbCBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHtSdW5Mb29wfSBydW5Mb29wIC0gTG9vcCBwcm92aWRpbmcgdGljayBhbmQgcmVuZGVyIGV2ZW50cyB0aGF0IHRoZVxuICogICAgICAgIHZpc3VhbGl6YXRpb24gY2FuIGhvb2sgdXAgdG8gYW5kIHJlc3BvbmQgdG8uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbVZpc3VhbGl6YXRpb24gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBydW5Mb29wKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7alF1ZXJ5fVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IHJvb3REaXY7XG5cbiAgLy8gSW1tZWRpYXRlbHksIGRyb3Agb3VyIFNWRyBjYW52YXMgYW5kIGJhc2ljIGdyb3VwcyBpbnRvIHRoZSBET01cbiAgdGhpcy5yb290RGl2Xy5odG1sKHZpc3VhbGl6YXRpb25NYXJrdXAoe1xuICAgIHNob3dCYWNrZ3JvdW5kOiBTSE9XX0JBQ0tHUk9VTkRcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7alF1ZXJ5fVxuICAgKi9cbiAgdGhpcy5zdmdSb290XyA9IHRoaXMucm9vdERpdl8uZmluZCgnc3ZnJyk7XG5cbiAgLyoqXG4gICAqIEJhY2tncm91bmQgZ3JvdXAgbmV2ZXIgZ29lcyBhd2F5LCBzbyBzZWFyY2ggZm9yIGl0IG9uY2UgYW5kIGNhY2hlXG4gICAqIGl0IGhlcmUuXG4gICAqIEBwcml2YXRlIHtqUXVlcnl9XG4gICAqL1xuICB0aGlzLmJhY2tncm91bmRHcm91cF8gPSB0aGlzLnN2Z1Jvb3RfLmZpbmQoJyNiYWNrZ3JvdW5kLWdyb3VwJyk7XG5cbiAgLyoqXG4gICAqIEZvcmVncm91bmQgZ3JvdXAgbmV2ZXIgZ29lcyBhd2F5LCBzbyBzZWFyY2ggZm9yIGl0IG9uY2UgYW5kIGNhY2hlXG4gICAqIGl0IGhlcmUuXG4gICAqIEBwcml2YXRlIHtqUXVlcnl9XG4gICAqL1xuICB0aGlzLmZvcmVncm91bmRHcm91cF8gPSB0aGlzLnN2Z1Jvb3RfLmZpbmQoJyNmb3JlZ3JvdW5kLWdyb3VwJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBzaGFyZCBjdXJyZW50bHkgYmVpbmcgcmVwcmVzZW50ZWQuXG4gICAqIFdlIGRvbid0IGhhdmUgYSBzaGFyZCBub3csIGJ1dCB3ZSByZWdpc3RlciB3aXRoIHRoZSBjb25uZWN0aW9uIG1hbmFnZXJcbiAgICogdG8gZmluZCBvdXQgd2hlbiB3ZSBoYXZlIG9uZS5cbiAgICogQHByaXZhdGUge05ldFNpbVNoYXJkfVxuICAgKi9cbiAgdGhpcy5zaGFyZF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIFZpekVudGl0aWVzLCB3aGljaCBhcmUgYWxsIHRoZSBlbGVtZW50cyB0aGF0IHdpbGwgYWN0dWFsbHkgc2hvdyB1cFxuICAgKiBpbiBvdXIgdmlzdWFsaXphdGlvbi5cbiAgICogQHByaXZhdGUge05ldFNpbVZpekVsZW1lbnRbXX1cbiAgICovXG4gIHRoaXMuZWxlbWVudHNfID0gW107XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgbG9jYWwgbm9kZSB2aXogZWxlbWVudCwgdGhlIGFuY2hvciBmb3IgdGhlIHZpc3VhbGl6YXRpb24uXG4gICAqIEB0eXBlIHtOZXRTaW1WaXpTaW11bGF0aW9uTm9kZX1cbiAgICovXG4gIHRoaXMubG9jYWxOb2RlID0gbnVsbDtcblxuICAvKipcbiAgICogV2lkdGggKGluIHN2Zy11bml0cykgb2YgdmlzdWFsaXphdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy52aXN1YWxpemF0aW9uV2lkdGggPSAzMDA7XG5cbiAgLyoqXG4gICAqIEhlaWdodCAoaW4gc3ZnLXVuaXRzKSBvZiB2aXN1YWxpemF0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnZpc3VhbGl6YXRpb25IZWlnaHQgPSAzMDA7XG5cbiAgLyoqXG4gICogTGFzdCBrbm93biBETlMgbW9kZSwgc28gdGhhdCBuZXcgZWxlbWVudHMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcbiAgKiBjb3JyZWN0IGRlZmF1bHRcbiAgKiBAdHlwZSB7RG5zTW9kZX1cbiAgKi9cbiAgdGhpcy5kbnNNb2RlXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB2aXN1YWxpemVkIGF1dG8tRE5TIG5vZGUsIGEgZmFrZSBub2RlIChub3QgbWFwcGVkIHRvIHRoZVxuICAgKiBzaW11bGF0aW9uIGluIGEgbm9ybWFsIHdheSkgdGhhdCBhbHNvIGxpdmVzIGluIG91ciBlbGVtZW50c18gY29sbGVjdGlvbi5cbiAgICogQHR5cGUge05ldFNpbVZpekF1dG9EbnNOb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5hdXRvRG5zTm9kZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gd2lyZSBiZXR3ZWVuIHRoZSBhdXRvLUROUyBub2RlIGFuZCB0aGUgZm9yZWdyb3VuZCByb3V0ZXIuXG4gICAqIE1hbmFnZWQgbWFudWFsbHkgc28gd2Uga2VlcCBhIGhhbmRsZSBvbiBpdCwgYnV0IGFsc28gbGl2ZXMgaW4gdGhlIGVsZW1lbnRzX1xuICAgKiBjb2xsZWN0aW9uLlxuICAgKiBAdHlwZSB7TmV0U2ltVml6V2lyZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYXV0b0Ruc1dpcmVfID0gbnVsbDtcblxuICAvKipcbiAgICogRXZlbnQgcmVnaXN0cmF0aW9uIGluZm9ybWF0aW9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50S2V5cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBMYXN0IGtub3duIGVuY29kaW5ncyBzZXQsIHNvIHRoYXQgbmV3IGVsZW1lbnRzIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICogdGhlIGNvcnJlY3QgZGVmYXVsdFxuICAgKiBAdHlwZSB7RW5jb2RpbmdUeXBlW119XG4gICAqL1xuICB0aGlzLmVuY29kaW5nc18gPSBbXTtcblxuICAvLyBIb29rIHVwIHRpY2sgYW5kIHJlbmRlciBtZXRob2RzXG4gIHJ1bkxvb3AudGljay5yZWdpc3Rlcih0aGlzLnRpY2suYmluZCh0aGlzKSk7XG4gIHJ1bkxvb3AucmVuZGVyLnJlZ2lzdGVyKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBUaWNrOiBVcGRhdGUgYWxsIHZpemVudGl0aWVzLCBnaXZpbmcgdGhlbSBhbiBvcHBvcnR1bml0eSB0byByZWNhbGN1bGF0ZVxuICogICAgICAgdGhlaXIgaW50ZXJuYWwgc3RhdGUsIGFuZCByZW1vdmUgYW55IGRlYWQgZW50aXRpZXMgZnJvbSB0aGVcbiAqICAgICAgIHZpc3VhbGl6YXRpb24uXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgLy8gRXZlcnlvbmUgZ2V0cyBhbiB1cGRhdGVcbiAgdGhpcy5lbGVtZW50c18uZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQudGljayhjbG9jayk7XG4gIH0pO1xuXG4gIC8vIFRlYXIgb3V0IGRlYWQgZW50aXRpZXMuXG4gIHRoaXMuZWxlbWVudHNfID0gdGhpcy5lbGVtZW50c18uZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuaXNEZWFkKCkpIHtcbiAgICAgIGVsZW1lbnQuZ2V0Um9vdCgpLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbmRlcjogTGV0IGFsbCB2aXplbnRpdGllcyBcInJlZHJhd1wiIChvciBpbiBvdXIgY2FzZSwgdG91Y2ggdGhlIERPTSlcbiAqIEBwYXJhbSB7UnVuTG9vcC5DbG9ja30gY2xvY2tcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIHRoaXMuZWxlbWVudHNfLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbmRlcihjbG9jayk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHNoYXJkIHRoaXMgdmlzdWFsaXphdGlvbiB3aWxsIHNvdXJjZSBpdHMgZGF0YSBmcm9tLlxuICogUmUtYXR0YWNoZXMgdGFibGUgY2hhbmdlIGxpc3RlbmVycyBmb3IgYWxsIHRoZSB0YWJsZXMgd2UgbmVlZCB0byBtb25pdG9yLlxuICogQHBhcmFtIHs/TmV0U2ltU2hhcmR9IG5ld1NoYXJkIC0gbnVsbCBpZiBkaXNjb25uZWN0ZWRcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuc2V0U2hhcmQgPSBmdW5jdGlvbiAobmV3U2hhcmQpIHtcbiAgdGhpcy5zaGFyZF8gPSBuZXdTaGFyZDtcblxuICAvLyBJZiB3ZSB3ZXJlIHJlZ2lzdGVyZWQgZm9yIHNoYXJkIGV2ZW50cywgdW5yZWdpc3RlciBvbGQgaGFuZGxlcnMuXG4gIGlmICh0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aFNoYXJkKSB7XG4gICAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhTaGFyZC5ub2RlVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMubm9kZVRhYmxlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aFNoYXJkLndpcmVUYWJsZS50YWJsZUNoYW5nZS51bnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLmV2ZW50S2V5cy53aXJlVGFibGUpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoU2hhcmQgPSBudWxsO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIG5ldyBzaGFyZCwgcmVnaXN0ZXIgbmV3IGhhbmRsZXJzLlxuICBpZiAobmV3U2hhcmQpIHtcbiAgICB0aGlzLmV2ZW50S2V5cy5ub2RlVGFibGUgPSBuZXdTaGFyZC5ub2RlVGFibGUudGFibGVDaGFuZ2UucmVnaXN0ZXIoXG4gICAgICAgIHRoaXMub25Ob2RlVGFibGVDaGFuZ2VfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXZlbnRLZXlzLndpcmVUYWJsZSA9IG5ld1NoYXJkLndpcmVUYWJsZS50YWJsZUNoYW5nZS5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5vbldpcmVUYWJsZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhTaGFyZCA9IG5ld1NoYXJkO1xuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZSB3aGljaCBub2RlIHdlIGNvbnNpZGVyIHRoZSAnbG9jYWwgbm9kZScgaW4gdGhlIHZpc3VhbGl6YXRpb24uXG4gKiBXZSBnbyB0aHJvdWdoIGEgc3BlY2lhbCBjcmVhdGlvbiBwcm9jZXNzIGZvciB0aGlzIG5vZGUsIHNvIHRoYXQgaXRcbiAqIGxvb2tzIGFuZCBiZWhhdmVzIGRpZmZlcmVudGx5LlxuICogQHBhcmFtIHs/TmV0U2ltTG9jYWxDbGllbnROb2RlfSBuZXdMb2NhbE5vZGUgLSBudWxsIGlmIGRpc2Nvbm5lY3RlZFxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5zZXRMb2NhbE5vZGUgPSBmdW5jdGlvbiAobmV3TG9jYWxOb2RlKSB7XG4gIC8vIFVucmVnaXN0ZXIgb2xkIGhhbmRsZXJzXG4gIGlmICh0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkV2l0aExvY2FsTm9kZSkge1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoTG9jYWxOb2RlLnJlbW90ZUNoYW5nZS51bnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLmV2ZW50S2V5cy5yZW1vdGVDaGFuZ2UpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRXaXRoTG9jYWxOb2RlID0gbnVsbDtcbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIG5ldyBoYW5kbGVyc1xuICBpZiAobmV3TG9jYWxOb2RlKSB7XG4gICAgdGhpcy5ldmVudEtleXMucmVtb3RlQ2hhbmdlID0gbmV3TG9jYWxOb2RlLnJlbW90ZUNoYW5nZS5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5vblJlbW90ZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFdpdGhMb2NhbE5vZGUgPSBuZXdMb2NhbE5vZGU7XG4gIH1cblxuICAvLyBDcmVhdGUgdml6bm9kZSBmb3IgbG9jYWwgbm9kZVxuICBpZiAobmV3TG9jYWxOb2RlKSB7XG4gICAgaWYgKHRoaXMubG9jYWxOb2RlKSB7XG4gICAgICB0aGlzLmxvY2FsTm9kZS5jb25maWd1cmVGcm9tKG5ld0xvY2FsTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jYWxOb2RlID0gbmV3IE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlKG5ld0xvY2FsTm9kZSwgU0hPV19CQUNLR1JPVU5EKTtcbiAgICAgIHRoaXMuZWxlbWVudHNfLnB1c2godGhpcy5sb2NhbE5vZGUpO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXBfLmFwcGVuZCh0aGlzLmxvY2FsTm9kZS5nZXRSb290KCkpO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsTm9kZS5zZXRJc0xvY2FsTm9kZSgpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmxvY2FsTm9kZSkge1xuICAgICAgdGhpcy5sb2NhbE5vZGUua2lsbCgpO1xuICAgICAgdGhpcy5sb2NhbE5vZGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICB0aGlzLnB1bGxFbGVtZW50c1RvRm9yZWdyb3VuZCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIGxvY2FsIG5vZGUgbm90aWZpZXMgdGhhdCB3ZSd2ZSBiZWVuIGNvbm5lY3RlZCB0byxcbiAqIG9yIGRpc2Nvbm5lY3RlZCBmcm9tLCBhIHJvdXRlci5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLm9uUmVtb3RlQ2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wdWxsRWxlbWVudHNUb0ZvcmVncm91bmQoKTtcbiAgdGhpcy5kaXN0cmlidXRlRm9yZWdyb3VuZE5vZGVzKCk7XG59O1xuXG4vKipcbiAqIEZpbmQgYSBwYXJ0aWN1bGFyIFZpekVsZW1lbnQgaW4gdGhlIHZpc3VhbGl6YXRpb24sIGJ5IHR5cGUgYW5kIElELlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZWxlbWVudFR5cGUgLSBjb25zdHJ1Y3RvciBvZiBlbGVtZW50IHdlJ3JlIGxvb2tpbmcgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZW50aXR5SUQgLSBJRCwgd2l0aCBjb3JyZXNwb25kcyB0byBOZXRTaW1FbnRpdHkuZW50aXR5SURcbiAqIEByZXR1cm5zIHtOZXRTaW1WaXpFbGVtZW50fSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLmdldEVsZW1lbnRCeUVudGl0eUlEID0gZnVuY3Rpb24gKGVsZW1lbnRUeXBlLCBlbnRpdHlJRCkge1xuICByZXR1cm4gXy5maW5kKHRoaXMuZWxlbWVudHNfLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgZWxlbWVudC5nZXRDb3JyZXNwb25kaW5nRW50aXR5SWQgJiZcbiAgICAgICAgZWxlbWVudC5nZXRDb3JyZXNwb25kaW5nRW50aXR5SWQoKSA9PT0gZW50aXR5SUQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzZXQgb2YgVml6V2lyZXMgZGlyZWN0bHkgYXR0YWNoZWQgdG8gdGhlIGdpdmVuIFZpek5vZGUgb25cbiAqIHRoZSBsb2NhbCBlbmQgZm9yIHdoaWNoIHRoZXJlIGFyZSBhbHNvIGNvcnJlc3BvbmRpbmcgVml6V2lyZXMgY29taW5nXG4gKiBmcm9tIHRoZSBvcHBvc2l0ZSBlbmQuIE5vdGUgdGhhdCBpZiB0aGUgVml6Tm9kZSBpcyBhIHJvdXRlciwgd2VcbiAqIGNvbnNpZGVyIGFsbCBhdHRhY2hlZCB3aXJlcyB0byBiZSByZWNpcHJvY2F0ZWQuXG4gKiBAcGFyYW0ge05ldFNpbVZpelNpbXVsYXRpb25Ob2RlfSB2aXpOb2RlXG4gKiBAcmV0dXJucyB7QXJyYXkuPE5ldFNpbVZpelNpbXVsYXRpb25XaXJlPn0gdGhlIGF0dGFjaGVkIHdpcmVzXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLmdldFJlY2lwcm9jYXRlZFdpcmVzQXR0YWNoZWRUb05vZGUgPSBmdW5jdGlvbiAodml6Tm9kZSkge1xuXG4gIGlmICh2aXpOb2RlLmlzUm91dGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lyZXNBdHRhY2hlZFRvTm9kZSh2aXpOb2RlKTtcbiAgfVxuXG4gIHZhciBsb2NhbFdpcmVzID0gdGhpcy5nZXRMb2NhbFdpcmVzQXR0YWNoZWRUb05vZGUodml6Tm9kZSk7XG5cbiAgcmV0dXJuIGxvY2FsV2lyZXMuZmlsdGVyKGZ1bmN0aW9uIChsb2NhbFdpcmUpIHtcblxuICAgIGlmIChsb2NhbFdpcmUucmVtb3RlVml6Tm9kZS5pc1JvdXRlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lyZXNBdHRhY2hlZFRvTm9kZShsb2NhbFdpcmUucmVtb3RlVml6Tm9kZSkuc29tZShmdW5jdGlvbiAod2lyZSkge1xuICAgICAgcmV0dXJuIHdpcmUucmVtb3RlVml6Tm9kZSA9PT0gdml6Tm9kZTtcbiAgICB9KTtcblxuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgc2V0IG9mIFZpeldpcmVzIGRpcmVjdGx5IGF0dGFjaGVkIHRvIHRoZSBnaXZlbiBWaXpOb2RlIG9uIHRoZSBsb2NhbCBlbmRcbiAqIEBwYXJhbSB7TmV0U2ltVml6U2ltdWxhdGlvbk5vZGV9IHZpek5vZGVcbiAqIEByZXR1cm5zIHtBcnJheS48TmV0U2ltVml6U2ltdWxhdGlvbldpcmU+fSB0aGUgYXR0YWNoZWQgd2lyZXNcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxXaXJlc0F0dGFjaGVkVG9Ob2RlID0gZnVuY3Rpb24gKHZpek5vZGUpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgTmV0U2ltVml6V2lyZSAmJiBlbGVtZW50LmxvY2FsVml6Tm9kZSA9PT0gdml6Tm9kZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNldCBvZiBWaXpXaXJlcyBkaXJlY3RseSBhdHRhY2hlZCB0byB0aGUgZ2l2ZW4gVml6Tm9kZSwgKGVpdGhlclxuICogb24gdGhlIGxvY2FsIGVuZCBvciByZW1vdGUgZW5kKVxuICogQHBhcmFtIHtOZXRTaW1WaXpTaW11bGF0aW9uTm9kZX0gdml6Tm9kZVxuICogQHJldHVybnMge0FycmF5LjxOZXRTaW1WaXpTaW11bGF0aW9uV2lyZT59IHRoZSBhdHRhY2hlZCB3aXJlc1xuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5nZXRXaXJlc0F0dGFjaGVkVG9Ob2RlID0gZnVuY3Rpb24gKHZpek5vZGUpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgTmV0U2ltVml6V2lyZSAmJlxuICAgICAgICAoZWxlbWVudC5sb2NhbFZpek5vZGUgPT09IHZpek5vZGUgfHwgZWxlbWVudC5yZW1vdGVWaXpOb2RlID09PSB2aXpOb2RlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBub3RpZmljYXRpb24gdGhhdCBub2RlIHRhYmxlIGNvbnRlbnRzIGhhdmUgY2hhbmdlZC5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLm9uTm9kZVRhYmxlQ2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ29udmVydCByb3dzIHRvIGNvcnJlY3RseS10eXBlZCBvYmplY3RzXG4gIHZhciB0YWJsZU5vZGVzID0gTmV0U2ltTm9kZUZhY3Rvcnkubm9kZXNGcm9tUm93cyh0aGlzLnNoYXJkXyxcbiAgICAgIHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCkpO1xuXG4gIC8vIFVwZGF0ZSBjb2xsZWN0aW9uIG9mIFZpek5vZGVzIGZyb20gc291cmNlIGRhdGFcbiAgdGhpcy51cGRhdGVWaXpFbnRpdGllc09mVHlwZV8oTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUsIHRhYmxlTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG5ld1Zpek5vZGUgPSBuZXcgTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUobm9kZSwgU0hPV19CQUNLR1JPVU5EKTtcbiAgICBuZXdWaXpOb2RlLnNldERuc01vZGUodGhpcy5kbnNNb2RlXyk7XG4gICAgbmV3Vml6Tm9kZS5zbmFwVG9Qb3NpdGlvbihcbiAgICAgICAgTWF0aC5yYW5kb20oKSAqIHRoaXMudmlzdWFsaXphdGlvbldpZHRoIC0gKHRoaXMudmlzdWFsaXphdGlvbldpZHRoIC8gMiksXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLnZpc3VhbGl6YXRpb25IZWlnaHQgLSAodGhpcy52aXN1YWxpemF0aW9uSGVpZ2h0IC8gMikpO1xuICAgIHJldHVybiBuZXdWaXpOb2RlO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgbm90aWZpY2F0aW9uIHRoYXQgd2lyZSB0YWJsZSBjb250ZW50cyBoYXZlIGNoYW5nZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5vbldpcmVUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENvbnZlcnQgcm93cyB0byBjb3JyZWN0bHktdHlwZWQgb2JqZWN0c1xuICB2YXIgdGFibGVXaXJlcyA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWFkQWxsKCkubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gbmV3IE5ldFNpbVdpcmUodGhpcy5zaGFyZF8sIHJvdyk7XG4gIH0sIHRoaXMpO1xuXG4gIC8vIFVwZGF0ZSBjb2xsZWN0aW9uIG9mIFZpeldpcmVzIGZyb20gc291cmNlIGRhdGFcbiAgdGhpcy51cGRhdGVWaXpFbnRpdGllc09mVHlwZV8oTmV0U2ltVml6U2ltdWxhdGlvbldpcmUsIHRhYmxlV2lyZXMsIGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgdmFyIG5ld1ZpeldpcmUgPSBuZXcgTmV0U2ltVml6U2ltdWxhdGlvbldpcmUod2lyZSxcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50QnlFbnRpdHlJRC5iaW5kKHRoaXMpKTtcbiAgICBuZXdWaXpXaXJlLnNldEVuY29kaW5ncyh0aGlzLmVuY29kaW5nc18pO1xuICAgIHJldHVybiBuZXdWaXpXaXJlO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIC8vIEluIGJyb2FkY2FzdCBtb2RlIHdlIGhpZGUgdGhlIHJlYWwgd2lyZXMgYW5kIHJvdXRlciwgYW5kIG92ZXJsYXkgYSBzZXRcbiAgLy8gb2YgZmFrZSB3aXJlcyBzaG93aW5nIGV2ZXJ5Ym9keSBjb25uZWN0ZWQgdG8gZXZlcnlib2R5IGVsc2UuXG4gIGlmIChOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCkuYnJvYWRjYXN0TW9kZSkge1xuICAgIHRoaXMudXBkYXRlQnJvYWRjYXN0TW9kZVdpcmVzXygpO1xuICB9XG5cbiAgLy8gU2luY2UgdGhlIHdpcmVzIHRhYmxlIGRldGVybWluZXMgc2ltdWxhdGVkIGNvbm5lY3Rpdml0eSwgd2UgdHJpZ2dlciBhXG4gIC8vIHJlY2FsY3VsYXRpb24gb2Ygd2hpY2ggbm9kZXMgYXJlIGluIHRoZSBsb2NhbCBuZXR3b3JrIChzaG91bGQgYmUgaW4gdGhlXG4gIC8vIGZvcmVncm91bmQpIGFuZCB0aGVuIHJlLWxheW91dCB0aGUgZm9yZWdyb3VuZCBub2Rlcy5cbiAgdGhpcy5wdWxsRWxlbWVudHNUb0ZvcmVncm91bmQoKTtcbiAgdGhpcy5kaXN0cmlidXRlRm9yZWdyb3VuZE5vZGVzKCk7XG59O1xuXG4vKipcbiAqIEJhc2VkIG9uIG5ldyBjb25uZWN0aXZpdHkgaW5mb3JtYXRpb24sIHJlY2FsY3VsYXRlIHdoaWNoICdmYWtlJyBjb25uZWN0aW9uc1xuICogd2UgbmVlZCB0byBkaXNwbGF5IHRvIHNob3cgYWxsIG5vZGVzIGluIGEgJ3Jvb20nIGhhdmluZyBkaXJlY3Qgd2lyZXMgdG9cbiAqIG9uZSBhbm90aGVyLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUudXBkYXRlQnJvYWRjYXN0TW9kZVdpcmVzXyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gS2lsbCBhbGwgZmFrZSB3aXJlc1xuICB0aGlzLmVsZW1lbnRzXy5mb3JFYWNoKGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gICAgaWYgKHZpekVsZW1lbnQgaW5zdGFuY2VvZiBOZXRTaW1WaXpXaXJlICYmXG4gICAgICAgICEodml6RWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpelNpbXVsYXRpb25XaXJlKSkge1xuICAgICAgdml6RWxlbWVudC5raWxsKCk7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICAvLyBHZW5lcmF0ZSBuZXcgd2lyZXNcbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5nZW5lcmF0ZUJyb2FkY2FzdE1vZGVDb25uZWN0aW9uc18oKTtcbiAgY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29ubmVjdGVkUGFpcikge1xuICAgIHZhciBuZXdGYWtlV2lyZSA9IG5ldyBOZXRTaW1WaXpXaXJlKGNvbm5lY3RlZFBhaXIubm9kZUEsIGNvbm5lY3RlZFBhaXIubm9kZUIpO1xuICAgIHRoaXMuYWRkVml6RWxlbWVudF8obmV3RmFrZVdpcmUpO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogVXNpbmcgdGhlIGNhY2hlZCBub2RlIGFuZCB3aXJlIGRhdGEsIGdlbmVyYXRlcyB0aGUgc2V0IG9mIGFsbCBub2RlIHBhaXJzIChBLEIpXG4gKiBvbiB0aGUgc2hhcmQgc3VjaCB0aGF0IGJvdGggQSBhbmQgQiBhcmUgY2xpZW50IG5vZGVzLCBhbmQgQSBpcyByZWFjaGFibGVcbiAqIGZyb20gQi5cbiAqIEByZXR1cm5zIHtBcnJheS48e25vZGVBOntudW1iZXJ9LCBub2RlQjp7bnVtYmVyfX0+fVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuZ2VuZXJhdGVCcm9hZGNhc3RNb2RlQ29ubmVjdGlvbnNfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZVJvd3MgPSB0aGlzLnNoYXJkXy5ub2RlVGFibGUucmVhZEFsbCgpO1xuICB2YXIgd2lyZVJvd3MgPSB0aGlzLnNoYXJkXy53aXJlVGFibGUucmVhZEFsbCgpO1xuICB2YXIgbm9kZUNvdW50ID0gbm9kZVJvd3MubGVuZ3RoO1xuXG4gIC8vIEdlbmVyYXRlIGEgcmV2ZXJzZSBtYXBwaW5nIGZvciBsb29rdXBzXG4gIHZhciBub2RlSURUb0luZGV4ID0ge307XG4gIGZvciAodmFyIG1hdHJpeEluZGV4ID0gMDsgbWF0cml4SW5kZXggPCBub2RlQ291bnQ7IG1hdHJpeEluZGV4KyspIHtcbiAgICBub2RlSURUb0luZGV4W25vZGVSb3dzW21hdHJpeEluZGV4XS5pZF0gPSBtYXRyaXhJbmRleDtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGVtcHR5IGdyYXBoIG1hdHJpeCBpbml0aWFsaXplZCB3aXRoIG5vIGNvbm5lY3Rpb25zLlxuICB2YXIgZ3JhcGggPSBuZXcgQXJyYXkobm9kZUNvdW50KTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBub2RlQ291bnQ7IHgrKykge1xuICAgIGdyYXBoW3hdID0gbmV3IEFycmF5KG5vZGVDb3VudCk7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBub2RlQ291bnQ7IHkrKykge1xuICAgICAgZ3JhcGhbeF1beV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBseSByZWFsIGNvbm5lY3Rpb25zICh3aXJlcykgdG8gdGhlIGdyYXBoIG1hdHJpeFxuICB3aXJlUm93cy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlUm93KSB7XG4gICAgdmFyIGxvY2FsTm9kZUluZGV4ID0gbm9kZUlEVG9JbmRleFt3aXJlUm93LmxvY2FsTm9kZUlEXTtcbiAgICB2YXIgcmVtb3RlTm9kZUluZGV4ID0gbm9kZUlEVG9JbmRleFt3aXJlUm93LnJlbW90ZU5vZGVJRF07XG4gICAgaWYgKGxvY2FsTm9kZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgcmVtb3RlTm9kZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyYXBoW2xvY2FsTm9kZUluZGV4XVtyZW1vdGVOb2RlSW5kZXhdID0gdHJ1ZTtcbiAgICAgIGdyYXBoW3JlbW90ZU5vZGVJbmRleF1bbG9jYWxOb2RlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFVzZSBzaW1wbGUgRmxveWQtV2Fyc2hhbGwgdG8gY29tcGxldGUgdGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBncmFwaFxuICBmb3IgKHZhciBrID0gMDsgayA8IG5vZGVDb3VudDsgaysrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlQ291bnQ7IGorKykge1xuICAgICAgICBpZiAoZ3JhcGhbaV1ba10gJiYgZ3JhcGhba11bal0pIHtcbiAgICAgICAgICBncmFwaFtpXVtqXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3csIGdlbmVyYXRlIHVuaXF1ZSBwYWlycyBkb2luZyBsb29rdXAgb24gb3VyIHRyYW5zaXRpdmUgY2xvc3VyZSBncmFwaFxuICB2YXIgY29ubmVjdGlvbnMgPSBbXTtcbiAgZm9yICh2YXIgZnJvbSA9IDA7IGZyb20gPCBub2RlQ291bnQgLSAxOyBmcm9tKyspIHtcbiAgICBmb3IgKHZhciB0byA9IGZyb20gKyAxOyB0byA8IG5vZGVDb3VudDsgdG8rKykge1xuICAgICAgLy8gbGVhdmUgcm91dGVyIGNvbm5lY3Rpb25zIG91dCBvZiB0aGlzIGxpc3RcbiAgICAgIHZhciBjbGllbnRUb0NsaWVudCA9IChub2RlUm93c1tmcm9tXS50eXBlID09PSBOb2RlVHlwZS5DTElFTlQgJiZcbiAgICAgICAgICBub2RlUm93c1t0b10udHlwZSA9PT0gTm9kZVR5cGUuQ0xJRU5UKTtcbiAgICAgIC8vIE11c3QgYmUgcmVhY2hhYmxlXG4gICAgICB2YXIgcmVhY2hhYmxlID0gZ3JhcGhbZnJvbV1bdG9dO1xuICAgICAgaWYgKGNsaWVudFRvQ2xpZW50ICYmIHJlYWNoYWJsZSkge1xuICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBub2RlQTogdGhpcy5nZXRFbGVtZW50QnlFbnRpdHlJRChOZXRTaW1WaXpTaW11bGF0aW9uTm9kZSwgbm9kZVJvd3NbZnJvbV0uaWQpLFxuICAgICAgICAgIG5vZGVCOiB0aGlzLmdldEVsZW1lbnRCeUVudGl0eUlEKE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlLCBub2RlUm93c1t0b10uaWQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29ubmVjdGlvbnM7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIFZpekVudGl0aWVzIG9mIHRoZSBnaXZlbiB0eXBlIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGVcbiAqIHZpc3VhbGl6YXRpb24gdG8gdGhlIHNvdXJjZSBkYXRhIGdpdmVuLCBhbmQgY3JlYXRlcy91cGRhdGVzL3JlbW92ZXNcbiAqIFZpekVudGl0aWVzIHNvIHRoYXQgdGhlIHZpc3VhbGl6YXRpb24gcmVmbGVjdHMgdGhlIG5ldyBzb3VyY2UgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB2aXpFbGVtZW50VHlwZVxuICogQHBhcmFtIHtBcnJheS48TmV0U2ltRW50aXR5Pn0gZW50aXR5Q29sbGVjdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3JlYXRpb25NZXRob2RcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLnVwZGF0ZVZpekVudGl0aWVzT2ZUeXBlXyA9IGZ1bmN0aW9uIChcbiAgICB2aXpFbGVtZW50VHlwZSwgZW50aXR5Q29sbGVjdGlvbiwgY3JlYXRpb25NZXRob2QpIHtcblxuICAvLyAxLiBLaWxsIFZpekVudGl0aWVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgc291cmNlIGRhdGFcbiAgdGhpcy5raWxsVml6RW50aXRpZXNPZlR5cGVNaXNzaW5nTWF0Y2hfKHZpekVsZW1lbnRUeXBlLCBlbnRpdHlDb2xsZWN0aW9uKTtcblxuICBlbnRpdHlDb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSkge1xuICAgIHZhciB2aXpFbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50QnlFbnRpdHlJRCh2aXpFbGVtZW50VHlwZSwgZW50aXR5LmVudGl0eUlEKTtcbiAgICBpZiAodml6RWxlbWVudCkge1xuICAgICAgLy8gMi4gVXBkYXRlIGV4aXN0aW5nIFZpekVudGl0aWVzIGZyb20gdGhlaXIgc291cmNlIGRhdGFcbiAgICAgIHZpekVsZW1lbnQuY29uZmlndXJlRnJvbShlbnRpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBDcmVhdGUgbmV3IFZpekVudGl0aWVzIGZvciBuZXcgc291cmNlIGRhdGFcbiAgICAgIHRoaXMuYWRkVml6RWxlbWVudF8oY3JlYXRpb25NZXRob2QoZW50aXR5KSk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ2FsbCBraWxsKCkgb24gYW55IHZpemVudGl0aWVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHR5cGUgYW5kIGRvbid0IG1hcCB0b1xuICogYSBOZXRTaW1FbnRpdHkgaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB2aXpFbGVtZW50VHlwZVxuICogQHBhcmFtIHtBcnJheS48TmV0U2ltRW50aXR5Pn0gZW50aXR5Q29sbGVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUua2lsbFZpekVudGl0aWVzT2ZUeXBlTWlzc2luZ01hdGNoXyA9IGZ1bmN0aW9uIChcbiAgICB2aXpFbGVtZW50VHlwZSwgZW50aXR5Q29sbGVjdGlvbikge1xuICB0aGlzLmVsZW1lbnRzXy5mb3JFYWNoKGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gICAgdmFyIGlzQ29ycmVjdFR5cGUgPSAodml6RWxlbWVudCBpbnN0YW5jZW9mIHZpekVsZW1lbnRUeXBlKTtcbiAgICB2YXIgZm91bmRNYXRjaCA9IGVudGl0eUNvbGxlY3Rpb24uc29tZShmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICByZXR1cm4gdml6RWxlbWVudC5yZXByZXNlbnRzRW50aXR5ICYmIHZpekVsZW1lbnQucmVwcmVzZW50c0VudGl0eShlbnRpdHkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzQ29ycmVjdFR5cGUgJiYgIWZvdW5kTWF0Y2gpIHtcbiAgICAgIHZpekVsZW1lbnQua2lsbCgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBWaXpFbGVtZW50IHRvIHRoZSB2aXN1YWxpemF0aW9uLlxuICogQHBhcmFtIHtOZXRTaW1WaXpFbGVtZW50fSB2aXpFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5hZGRWaXpFbGVtZW50XyA9IGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudHNfLnB1c2godml6RWxlbWVudCk7XG4gIHRoaXMuYmFja2dyb3VuZEdyb3VwXy5wcmVwZW5kKHZpekVsZW1lbnQuZ2V0Um9vdCgpKTtcbn07XG5cbi8qKlxuICogSWYgd2UgZG8gbmVlZCBhIERPTSBjaGFuZ2UsIGRldGFjaCB0aGUgZWxlbWVudCBhbmQgcmVhdHRhY2ggaXQgdG8gdGhlIG5ld1xuICogbGF5ZXIuIFNwZWNpYWwgcnVsZSAoZm9yIG5vdyk6IFByZXBlbmQgd2lyZXMgc28gdGhhdCB0aGV5IHNob3cgdXAgYmVoaW5kXG4gKiBub2Rlcy4gIFdpbGwgbmVlZCBhIGJldHRlciBzb2x1dGlvbiBmb3IgdGhpcyBpZi93aGVuIHRoZSB2aXogZ2V0cyBtb3JlXG4gKiBjb21wbGV4LlxuICogQHBhcmFtIHtOZXRTaW1WaXpFbGVtZW50fSB2aXpFbGVtZW50XG4gKiBAcGFyYW0ge2pRdWVyeX0gbmV3UGFyZW50XG4gKi9cbnZhciBtb3ZlVml6RWxlbWVudFRvR3JvdXAgPSBmdW5jdGlvbiAodml6RWxlbWVudCwgbmV3UGFyZW50KSB7XG4gIHZpekVsZW1lbnQuZ2V0Um9vdCgpLmRldGFjaCgpO1xuICBpZiAodml6RWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpeldpcmUpIHtcbiAgICB2aXpFbGVtZW50LmdldFJvb3QoKS5wcmVwZW5kVG8obmV3UGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2aXpFbGVtZW50LmdldFJvb3QoKS5hcHBlbmRUbyhuZXdQYXJlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY2FsY3VsYXRlIHdoaWNoIG5vZGVzIHNob3VsZCBiZSBpbiB0aGUgZm9yZWdyb3VuZCBsYXllciBieSBkb2luZyBhIGZ1bGxcbiAqIHRyYXZlcnNhbCBzdGFydGluZyB3aXRoIHRoZSBsb2NhbCBub2RlLiAgSW4gc2hvcnQsIGV2ZXJ5dGhpbmcgcmVhY2hhYmxlXG4gKiBmcm9tIHRoZSBsb2NhbCBub2RlIGJlbG9uZ3MgaW4gdGhlIGZvcmVncm91bmQuXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLnB1bGxFbGVtZW50c1RvRm9yZWdyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQmVnaW4gYnkgbWFya2luZyBhbGwgZW50aXRpZXMgYmFja2dyb3VuZCAodW52aXNpdGVkKVxuICB0aGlzLmVsZW1lbnRzXy5mb3JFYWNoKGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gICAgdml6RWxlbWVudC52aXNpdGVkID0gZmFsc2U7XG4gIH0pO1xuXG4gIHZhciB0b0V4cGxvcmUgPSBbXTtcbiAgaWYgKHRoaXMubG9jYWxOb2RlKSB7XG4gICAgdG9FeHBsb3JlLnB1c2godGhpcy5sb2NhbE5vZGUpO1xuICB9XG5cbiAgLy8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIG5vZGVzIHRoYXQgbmVlZCB2aXNpdGluZyxcbiAgLy8gdmlzaXQgdGhlIG5leHQgbm9kZSwgbWFya2luZyBpdCBhcyBcImZvcmVncm91bmQvdmlzaXRlZFwiIGFuZFxuICAvLyBwdXNoaW5nIGFsbCBvZiBpdHMgdW52aXNpdGVkIGNvbm5lY3Rpb25zIG9udG8gdGhlIHN0YWNrLlxuICB2YXIgY3VycmVudFZpekVsZW1lbnQ7XG4gIHdoaWxlICh0b0V4cGxvcmUubGVuZ3RoID4gMCkge1xuICAgIGN1cnJlbnRWaXpFbGVtZW50ID0gdG9FeHBsb3JlLnBvcCgpO1xuICAgIGN1cnJlbnRWaXpFbGVtZW50LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHRvRXhwbG9yZSA9IHRvRXhwbG9yZS5jb25jYXQodGhpcy5nZXRVbnZpc2l0ZWROZWlnaGJvcnNPZl8oY3VycmVudFZpekVsZW1lbnQpKTtcbiAgfVxuXG4gIC8vIE5vdywgdmlzaXRlZCBub2RlcyBiZWxvbmcgaW4gdGhlIGZvcmVncm91bmQuXG4gIC8vIE1vdmUgYWxsIG5vZGVzIHRvIHRoZWlyIG5ldywgY29ycmVjdCBsYXllcnNcbiAgLy8gUG9zc2libGUgb3B0aW1pemF0aW9uOiBDYW4gd2UgZG8gdGhpcyB3aXRoIGp1c3Qgb25lIG9wZXJhdGlvbiBvbiB0aGUgbGl2ZSBET00/XG4gIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5mb3JlZ3JvdW5kR3JvdXBfO1xuICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwXztcbiAgdGhpcy5lbGVtZW50c18uZm9yRWFjaChmdW5jdGlvbiAodml6RWxlbWVudCkge1xuICAgIHZhciBpc0ZvcmVncm91bmQgPSAkLmNvbnRhaW5zKGZvcmVncm91bmRbMF0sIHZpekVsZW1lbnQuZ2V0Um9vdCgpWzBdKTtcblxuICAgIC8vIENoZWNrIHdoZXRoZXIgYSBjaGFuZ2Ugc2hvdWxkIG9jY3VyLiAgSWYgbm90LCB3ZSBsZWF2ZVxuICAgIC8vIG5ld1BhcmVudCB1bmRlZmluZWQgc28gdGhhdCB3ZSBkb24ndCBtYWtlIHVubmVlZGVkIERPTSBjaGFuZ2VzLlxuICAgIGlmICh2aXpFbGVtZW50LnZpc2l0ZWQgJiYgIWlzRm9yZWdyb3VuZCkge1xuICAgICAgbW92ZVZpekVsZW1lbnRUb0dyb3VwKHZpekVsZW1lbnQsIGZvcmVncm91bmQpO1xuICAgICAgdml6RWxlbWVudC5vbkRlcHRoQ2hhbmdlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIXZpekVsZW1lbnQudmlzaXRlZCAmJiBpc0ZvcmVncm91bmQpIHtcbiAgICAgIG1vdmVWaXpFbGVtZW50VG9Hcm91cCh2aXpFbGVtZW50LCBiYWNrZ3JvdW5kKTtcbiAgICAgIHZpekVsZW1lbnQub25EZXB0aENoYW5nZShmYWxzZSk7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB0aGlzLnVwZGF0ZUF1dG9EbnNOb2RlKCk7XG59O1xuXG4vKipcbiAqIFZpc2l0IG1ldGhvZCBmb3IgcHVsbEVsZW1lbnRzVG9Gb3JlZ3JvdW5kLCBub3QgdXNlZCBhbnl3aGVyZSBlbHNlLlxuICogTm90ZXMgdGhhdCB0aGUgY3VycmVudCBlbGVtZW50IGlzIHNob3VsZCBiZSBmb3JlZ3JvdW5kIHdoZW4gd2UncmUgYWxsIGRvbmUsXG4gKiBmaW5kcyB0aGUgY3VycmVudCBlbGVtZW50J3MgdW52aXNpdGVkIGNvbm5lY3Rpb25zLFxuICogcHVzaGVzIHRob3NlIGNvbm5lY3Rpb25zIG9udG8gdGhlIHN0YWNrLlxuICogQHBhcmFtIHtOZXRTaW1WaXpTaW11bGF0aW9uTm9kZXxOZXRTaW1WaXpTaW11bGF0aW9uV2lyZX0gdml6RWxlbWVudFxuICogQHJldHVybnMge0FycmF5LjxOZXRTaW1WaXpFbGVtZW50Pn1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLmdldFVudmlzaXRlZE5laWdoYm9yc09mXyA9IGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gIC8vIEZpbmQgbmV3IGVudGl0aWVzIHRvIGV4cGxvcmUgYmFzZWQgb24gbm9kZSB0eXBlIGFuZCBjb25uZWN0aW9uc1xuICB2YXIgbmVpZ2hib3JzID0gW107XG5cbiAgaWYgKHZpekVsZW1lbnQgaW5zdGFuY2VvZiBOZXRTaW1WaXpTaW11bGF0aW9uTm9kZSkge1xuXG4gICAgLy8gSW4gYnJvYWRjYXN0IG1vZGUgd2UgZGlzcGxheSBcImZha2UsXCIgdW5pZGlyZWN0aW9uYWwgd2lyZXMuIEluXG4gICAgLy8gcmVndWxhciBtb2RlLCB3ZSBvbmx5IHdhbnQgdG8gZGlzcGxheSB3aXJlcyBjb25uZWN0aW5nIHVzIHRvXG4gICAgLy8gbm9kZXMgdGhhdCBhcmUgYWxzbyBjb25uZWN0ZWQgYmFjay5cbiAgICBpZiAoTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLmJyb2FkY2FzdE1vZGUpIHtcbiAgICAgIG5laWdoYm9ycyA9IHRoaXMuZ2V0V2lyZXNBdHRhY2hlZFRvTm9kZSh2aXpFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmVpZ2hib3JzID0gdGhpcy5nZXRSZWNpcHJvY2F0ZWRXaXJlc0F0dGFjaGVkVG9Ob2RlKHZpekVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgY2FzZTogVGhlIEROUyBub2RlIGZha2UgaXMgYSBuZWlnaGJvciBvZiBhIHZpc2l0ZWQgcm91dGVyXG4gICAgaWYgKHZpekVsZW1lbnQuaXNSb3V0ZXIgJiYgdGhpcy5hdXRvRG5zTm9kZV8pIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMuYXV0b0Ruc05vZGVfKTtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHRoaXMuYXV0b0Ruc1dpcmVfKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodml6RWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpeldpcmUpIHtcbiAgICBpZiAodml6RWxlbWVudC5sb2NhbFZpek5vZGUpIHtcbiAgICAgIG5laWdoYm9ycy5wdXNoKHZpekVsZW1lbnQubG9jYWxWaXpOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodml6RWxlbWVudC5yZW1vdGVWaXpOb2RlKSB7XG4gICAgICBuZWlnaGJvcnMucHVzaCh2aXpFbGVtZW50LnJlbW90ZVZpek5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWlnaGJvcnMuZmlsdGVyKGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gICAgcmV0dXJuICF2aXpFbGVtZW50LnZpc2l0ZWQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBsaWNpdGx5IGNvbnRyb2wgVml6Tm9kZXMgaW4gdGhlIGZvcmVncm91bmQsIG1vdmluZyB0aGVtIGludG8gYSBkZXNpcmVkXG4gKiBjb25maWd1cmF0aW9uIGJhc2VkIG9uIHRoZWlyIG51bWJlciBhbmQgdHlwZXMuICBOb2RlcyBhcmUgZ2l2ZW4gYW5pbWF0aW9uXG4gKiBjb21tYW5kcyAodmlhIHR3ZWVuVG9Qb3NpdGlvbikgc28gdGhhdCB0aGV5IGludGVycG9sYXRlIG5pY2VseSB0byB0aGVpciB0YXJnZXRcbiAqIHBvc2l0aW9ucy5cbiAqXG4gKiBDb25maWd1cmF0aW9uczpcbiAqIE9uZSBub2RlIChsb2NhbCBub2RlKTogQ2VudGVyZWQgb24gdGhlIHNjcmVlbi5cbiAqICAgfCAgTCAgfFxuICpcbiAqIFR3byBub2RlczogTG9jYWwgbm9kZSBvbiBsZWZ0LCByZW1vdGUgbm9kZSBvbiByaWdodCwgbm90aGluZyBpbiB0aGUgbWlkZGxlLlxuICogICB8IEwtUiB8XG4gKlxuICogVGhyZWUgb3IgbW9yZSBub2RlczogTG9jYWwgbm9kZSBvbiBsZWZ0LCByb3V0ZXIgaW4gdGhlIG1pZGRsZSwgb3RoZXJcbiAqIG5vZGVzIGRpc3RyaWJ1dGVkIGV2ZW5seSBhcm91bmQgdGhlIHJvdXRlciBpbiBhIGNpcmNsZVxuICogMzogICAgICAgICA0OiAgICBPICAgIDU6ICBPICAgICAgNjpPICAgTyAgICA3Ok8gICBPXG4gKiAgICAgICAgICAgICAgICAgLyAgICAgICAgIHwgICAgICAgICBcXCAvICAgICAgICBcXCAvXG4gKiAgIEwtUi0wICAgICAgTC1SICAgICAgICBMLVItTyAgICAgIEwtUiAgICAgICAgTC1SLU9cbiAqICAgICAgICAgICAgICAgICBcXCAgICAgICAgIHwgICAgICAgICAvIFxcICAgICAgICAvIFxcXG4gKiAgICAgICAgICAgICAgICAgIE8gICAgICAgIE8gICAgICAgIE8gICBPICAgICAgTyAgIE9cbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuZGlzdHJpYnV0ZUZvcmVncm91bmROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5icm9hZGNhc3RNb2RlKSB7XG4gICAgdGhpcy5kaXN0cmlidXRlRm9yZWdyb3VuZE5vZGVzRm9yQnJvYWRjYXN0XygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7QXJyYXkuPE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlPn0gKi9cbiAgdmFyIGZvcmVncm91bmROb2RlcyA9IHRoaXMuZWxlbWVudHNfLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgTmV0U2ltVml6Tm9kZSAmJiBlbGVtZW50LmlzRm9yZWdyb3VuZDtcbiAgfSk7XG5cbiAgLy8gU29tZXRpbWVzLCB0aGVyZSdzIG5vIHdvcmsgdG8gZG8uXG4gIGlmIChmb3JlZ3JvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT25lIG5vZGU6IENlbnRlcmVkIG9uIHNjcmVlblxuICBpZiAoZm9yZWdyb3VuZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZvcmVncm91bmROb2Rlc1swXS50d2VlblRvUG9zaXRpb24oMCwgMCwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBteU5vZGU7XG5cbiAgLy8gVHdvIG5vZGVzOiBQbGFjZWQgYWNyb3NzIGZyb20gZWFjaCBvdGhlciwgbG9jYWwgbm9kZSBvbiBsZWZ0XG4gIGlmIChmb3JlZ3JvdW5kTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgbXlOb2RlID0gdGhpcy5sb2NhbE5vZGU7XG4gICAgdmFyIG90aGVyTm9kZSA9IF8uZmluZChmb3JlZ3JvdW5kTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZSAhPT0gbXlOb2RlO1xuICAgIH0pO1xuICAgIG15Tm9kZS50d2VlblRvUG9zaXRpb24oLTc1LCAwLCA0MDAsIHR3ZWVucy5lYXNlT3V0UXVhZCk7XG4gICAgb3RoZXJOb2RlLnR3ZWVuVG9Qb3NpdGlvbig3NSwgMCwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRocmVlIG9yIG1vcmUgbm9kZXM6XG4gIC8vICogTG9jYWwgbm9kZSBvbiBsZWZ0XG4gIC8vICogUm91dGVyIGluIHRoZSBtaWRkbGVcbiAgLy8gKiBPdGhlciBub2RlcyBldmVubHkgZGlzdHJpYnV0ZWQgaW4gYSBjaXJjbGVcbiAgbXlOb2RlID0gdGhpcy5sb2NhbE5vZGU7XG4gIHZhciByb3V0ZXJOb2RlID0gXy5maW5kKGZvcmVncm91bmROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pc1JvdXRlcjtcbiAgfSk7XG4gIHZhciBvdGhlck5vZGVzID0gZm9yZWdyb3VuZE5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSBteU5vZGUgJiYgbm9kZSAhPT0gcm91dGVyTm9kZTtcbiAgfSk7XG5cbiAgbXlOb2RlLnR3ZWVuVG9Qb3NpdGlvbigtMTAwLCAwLCA0MDAsIHR3ZWVucy5lYXNlT3V0UXVhZCk7XG4gIHJvdXRlck5vZGUudHdlZW5Ub1Bvc2l0aW9uKDAsIDAsIDUwMCwgdHdlZW5zLmVhc2VPdXRRdWFkKTtcbiAgdmFyIHJhZGlhbnNCZXR3ZWVuTm9kZXMgPSAyKk1hdGguUEkgLyAob3RoZXJOb2Rlcy5sZW5ndGggKyAxKTsgLy8gSW5jbHVkZSBteU5vZGUhXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHNpbihyYWQpID0gby9oXG4gICAgdmFyIGggPSAxMDA7XG4gICAgLy8gRXh0cmEgTWF0aC5QSSBoZXJlIHB1dHMgMGRlZyBvbiB0aGUgbGVmdC5cbiAgICB2YXIgcmFkID0gTWF0aC5QSSArIChpKzEpICogcmFkaWFuc0JldHdlZW5Ob2RlcztcbiAgICB2YXIgeCA9IE1hdGguY29zKHJhZCkgKiBoO1xuICAgIHZhciB5ID0gTWF0aC5zaW4ocmFkKSAqIGg7XG4gICAgb3RoZXJOb2Rlc1tpXS50d2VlblRvUG9zaXRpb24oeCwgeSwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cGxpY2l0bHkgY29udHJvbCBWaXpOb2RlcyBpbiB0aGUgZm9yZWdyb3VuZCwgbW92aW5nIHRoZW0gaW50byBhIGRlc2lyZWRcbiAqIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gdGhlaXIgbnVtYmVyIGFuZCB0eXBlcy4gIE5vZGVzIGFyZSBnaXZlbiBhbmltYXRpb25cbiAqIGNvbW1hbmRzICh2aWEgdHdlZW5Ub1Bvc2l0aW9uKSBzbyB0aGF0IHRoZXkgaW50ZXJwb2xhdGUgbmljZWx5IHRvIHRoZWlyIHRhcmdldFxuICogcG9zaXRpb25zLlxuICpcbiAqIENvbmZpZ3VyYXRpb25zOlxuICogT25lIG5vZGUgKGxvY2FsIG5vZGUpOiBDZW50ZXJlZCBvbiB0aGUgc2NyZWVuLlxuICogICB8ICBMICB8XG4gKlxuICogVHdvIG5vZGVzOiBMb2NhbCBub2RlIG9uIGxlZnQsIHJlbW90ZSBub2RlIG9uIHJpZ2h0LCBub3RoaW5nIGluIHRoZSBtaWRkbGUuXG4gKiAgIHwgTC1SIHxcbiAqXG4gKiBUaHJlZSBvciBtb3JlIG5vZGVzOiBEaXN0cmlidXRlZCBhcm91bmQgY2VudGVyIG9mIGZyYW1lXG4gKiAzOiAgICBPICAgIDQ6ICBPICAgICAgNTogTyAgTyAgICA2OiBPIE9cbiAqICAgTCAgICAgICAgICBMICAgTyAgICAgIEwgICAgICAgICAgTCAgIE9cbiAqICAgICAgIE8gICAgICAgIE8gICAgICAgICBPICBPICAgICAgIE8gT1xuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5kaXN0cmlidXRlRm9yZWdyb3VuZE5vZGVzRm9yQnJvYWRjYXN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48TmV0U2ltVml6U2ltdWxhdGlvbk5vZGU+fSAqL1xuICB2YXIgZm9yZWdyb3VuZE5vZGVzID0gdGhpcy5lbGVtZW50c18uZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBOZXRTaW1WaXpTaW11bGF0aW9uTm9kZSAmJlxuICAgICAgICBlbGVtZW50LmlzRm9yZWdyb3VuZCAmJlxuICAgICAgICAhZWxlbWVudC5pc1JvdXRlcjtcbiAgfSk7XG5cbiAgLy8gU29tZXRpbWVzLCB0aGVyZSdzIG5vIHdvcmsgdG8gZG8uXG4gIGlmIChmb3JlZ3JvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT25lIG5vZGU6IENlbnRlcmVkIG9uIHNjcmVlblxuICBpZiAoZm9yZWdyb3VuZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZvcmVncm91bmROb2Rlc1swXS50d2VlblRvUG9zaXRpb24oMCwgMCwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBteU5vZGU7XG5cbiAgLy8gVHdvIG5vZGVzOiBQbGFjZWQgYWNyb3NzIGZyb20gZWFjaCBvdGhlciwgbG9jYWwgbm9kZSBvbiBsZWZ0XG4gIGlmIChmb3JlZ3JvdW5kTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgbXlOb2RlID0gdGhpcy5sb2NhbE5vZGU7XG4gICAgdmFyIG90aGVyTm9kZSA9IF8uZmluZChmb3JlZ3JvdW5kTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZSAhPT0gbXlOb2RlO1xuICAgIH0pO1xuICAgIG15Tm9kZS50d2VlblRvUG9zaXRpb24oLTc1LCAwLCA0MDAsIHR3ZWVucy5lYXNlT3V0UXVhZCk7XG4gICAgb3RoZXJOb2RlLnR3ZWVuVG9Qb3NpdGlvbig3NSwgMCwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRocmVlIG9yIG1vcmUgbm9kZXM6XG4gIC8vICogTG9jYWwgbm9kZSBvbiBsZWZ0XG4gIC8vICogT3RoZXIgbm9kZXMgZXZlbmx5IGRpc3RyaWJ1dGVkIGluIGEgY2lyY2xlXG4gIG15Tm9kZSA9IHRoaXMubG9jYWxOb2RlO1xuICB2YXIgb3RoZXJOb2RlcyA9IGZvcmVncm91bmROb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAhPT0gbXlOb2RlO1xuICB9KTtcblxuICBteU5vZGUudHdlZW5Ub1Bvc2l0aW9uKC0xMDAsIDAsIDQwMCwgdHdlZW5zLmVhc2VPdXRRdWFkKTtcbiAgdmFyIHJhZGlhbnNCZXR3ZWVuTm9kZXMgPSAyKk1hdGguUEkgLyAob3RoZXJOb2Rlcy5sZW5ndGggKyAxKTsgLy8gSW5jbHVkZSBteU5vZGUhXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHNpbihyYWQpID0gby9oXG4gICAgdmFyIGggPSAxMDA7XG4gICAgLy8gRXh0cmEgTWF0aC5QSSBoZXJlIHB1dHMgMGRlZyBvbiB0aGUgbGVmdC5cbiAgICB2YXIgcmFkID0gTWF0aC5QSSArIChpKzEpICogcmFkaWFuc0JldHdlZW5Ob2RlcztcbiAgICB2YXIgeCA9IE1hdGguY29zKHJhZCkgKiBoO1xuICAgIHZhciB5ID0gTWF0aC5zaW4ocmFkKSAqIGg7XG4gICAgb3RoZXJOb2Rlc1tpXS50d2VlblRvUG9zaXRpb24oeCwgeSwgNjAwLCB0d2VlbnMuZWFzZU91dFF1YWQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG5zTW9kZX0gbmV3RG5zTW9kZVxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5zZXREbnNNb2RlID0gZnVuY3Rpb24gKG5ld0Ruc01vZGUpIHtcblxuICB0aGlzLmRuc01vZGVfID0gbmV3RG5zTW9kZTtcblxuICAvLyBTaG93L2hpZGUgdGhlIGF1dG8tRE5TIG5vZGUgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc3RhdGVcbiAgaWYgKG5ld0Ruc01vZGUgPT09IERuc01vZGUuQVVUT01BVElDKSB7XG4gICAgdGhpcy5tYWtlQXV0b0Ruc05vZGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlc3Ryb3lBdXRvRG5zTm9kZSgpO1xuICB9XG5cbiAgLy8gVGVsbCBhbGwgbm9kZXMgYWJvdXQgdGhlIG5ldyBETlMgbW9kZSwgc28gdGhleSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gc2hvdyBvciBoaWRlIHRoZWlyIGFkZHJlc3MuXG4gIHRoaXMuZWxlbWVudHNfLmZvckVhY2goZnVuY3Rpb24gKHZpekVsZW1lbnQpIHtcbiAgICBpZiAodml6RWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlKSB7XG4gICAgICB2aXpFbGVtZW50LnNldERuc01vZGUobmV3RG5zTW9kZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBVcGRhdGUgbGF5ZXJpbmcgYW5kIGxheW91dCBzaW5jZSB3ZSBqdXN0IGFkZGVkL3JlbW92ZWQgYSBub2RlLlxuICB0aGlzLnB1bGxFbGVtZW50c1RvRm9yZWdyb3VuZCgpO1xuICB0aGlzLmRpc3RyaWJ1dGVGb3JlZ3JvdW5kTm9kZXMoKTtcbn07XG5cbi8qKlxuICogSWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LCBjcmVhdGUgYW4gYXV0by1ETlMgbm9kZSBhbmQgY29ycmVzcG9uZGluZ1xuICogd2lyZS5cbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUubWFrZUF1dG9EbnNOb2RlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuYXV0b0Ruc05vZGVfKSB7XG4gICAgdGhpcy5hdXRvRG5zTm9kZV8gPSBuZXcgTmV0U2ltVml6QXV0b0Ruc05vZGUoU0hPV19CQUNLR1JPVU5EKTtcbiAgICB0aGlzLmFkZFZpekVsZW1lbnRfKHRoaXMuYXV0b0Ruc05vZGVfKTtcblxuICAgIHRoaXMuYXV0b0Ruc1dpcmVfID0gbmV3IE5ldFNpbVZpeldpcmUodGhpcy5hdXRvRG5zTm9kZV8sIG51bGwpO1xuICAgIHRoaXMuYWRkVml6RWxlbWVudF8odGhpcy5hdXRvRG5zV2lyZV8pO1xuICB9XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHVwZGF0ZSB0aGUgYXV0by1ETlMgbm9kZSBhbmQgd2lyZSB0byBtYXRjaCB0aGUgZm9yZWdyb3VuZCByb3V0ZXIuXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLnVwZGF0ZUF1dG9EbnNOb2RlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuYXV0b0Ruc05vZGVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZvcmVncm91bmRSb3V0ZXJOb2RlID0gXy5maW5kKHRoaXMuZWxlbWVudHNfLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUgJiZcbiAgICAgICAgZWxlbWVudC5pc1JvdXRlciAmJlxuICAgICAgICBlbGVtZW50LmlzRm9yZWdyb3VuZDtcbiAgfSk7XG5cbiAgLy8gVXBkYXRlIGFkZHJlc3MgdG8gbWF0Y2ggZm9yZWdyb3VuZCByb3V0ZXJcbiAgaWYgKGZvcmVncm91bmRSb3V0ZXJOb2RlKSB7XG4gICAgdGhpcy5hdXRvRG5zTm9kZV8uc2V0QWRkcmVzcyhmb3JlZ3JvdW5kUm91dGVyTm9kZS5hdXRvRG5zQWRkcmVzcyk7XG4gIH1cblxuICAvLyBVcGRhdGUgd2lyZSBlbmRwb2ludHNcbiAgdGhpcy5hdXRvRG5zV2lyZV8ubG9jYWxWaXpOb2RlID0gdGhpcy5hdXRvRG5zTm9kZV87XG4gIHRoaXMuYXV0b0Ruc1dpcmVfLnJlbW90ZVZpek5vZGUgPSBmb3JlZ3JvdW5kUm91dGVyTm9kZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBhdXRvLUROUyBub2RlIGFuZCB3aXJlLlxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5kZXN0cm95QXV0b0Ruc05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmF1dG9EbnNOb2RlXykge1xuICAgIHRoaXMuYXV0b0Ruc05vZGVfLmtpbGwoKTtcbiAgICB0aGlzLmF1dG9EbnNOb2RlXyA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5hdXRvRG5zV2lyZV8pIHtcbiAgICB0aGlzLmF1dG9EbnNXaXJlXy5raWxsKCk7XG4gICAgdGhpcy5hdXRvRG5zV2lyZV8gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBkbnNOb2RlSURcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuc2V0RG5zTm9kZUlEID0gZnVuY3Rpb24gKGRuc05vZGVJRCkge1xuICB0aGlzLmVsZW1lbnRzXy5mb3JFYWNoKGZ1bmN0aW9uICh2aXpFbGVtZW50KSB7XG4gICAgaWYgKHZpekVsZW1lbnQgaW5zdGFuY2VvZiBOZXRTaW1WaXpTaW11bGF0aW9uTm9kZSkge1xuICAgICAgdml6RWxlbWVudC5zZXRJc0Ruc05vZGUodml6RWxlbWVudC5nZXRDb3JyZXNwb25kaW5nRW50aXR5SWQoKSA9PT0gZG5zTm9kZUlEKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZW5jb2RpbmctdmlldyBzZXR0aW5nIGFjcm9zcyB0aGUgdmlzdWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBuZXdFbmNvZGluZ3NcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuc2V0RW5jb2RpbmdzID0gZnVuY3Rpb24gKG5ld0VuY29kaW5ncykge1xuICB0aGlzLmVuY29kaW5nc18gPSBuZXdFbmNvZGluZ3M7XG4gIHRoaXMuZWxlbWVudHNfLmZvckVhY2goZnVuY3Rpb24gKHZpekVsZW1lbnQpIHtcbiAgICBpZiAodml6RWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpelNpbXVsYXRpb25XaXJlKSB7XG4gICAgICB2aXpFbGVtZW50LnNldEVuY29kaW5ncyhuZXdFbmNvZGluZ3MpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEtpY2sgb2ZmIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgc2hvdyB0aGUgc3RhdGUgb2YgdGhlIHNpbXBsZXggd2lyZSBiZWluZ1xuICogc2V0IGJ5IHRoZSBsb2NhbCBub2RlLlxuICogQHBhcmFtIHtcIjBcInxcIjFcIn0gbmV3U3RhdGVcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuYW5pbWF0ZVNldFdpcmVTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAvLyBBc3N1bXB0aW9ucyAtIHdlIGFyZSB0YWxraW5nIGFib3V0IHRoZSB3aXJlIGJldHdlZW4gdGhlIGxvY2FsIG5vZGVcbiAgLy8gYW5kIGl0cyByZW1vdGUgcGFydG5lci5cbiAgLy8gVGhpcyBvbmx5IGdldHMgdXNlZCBpbiBwZWVyLXRvLXBlZXIgbW9kZSwgc28gdGhlcmUgc2hvdWxkIGJlIGFuIGluY29taW5nXG4gIC8vIHdpcmUgdG9vLCB3aGljaCB3ZSBzaG91bGQgaGlkZS5cbiAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIG5vIHN1Y2ggd2lyZSBleGlzdHMuXG4gIC8vIFdlIGNhbiBzdG9wIGFueSBwcmV2aW91cyBhbmltYXRpb24gb24gdGhlIHdpcmUgaWYgdGhpcyBpcyBjYWxsZWRcblxuICB2YXIgdml6V2lyZSA9IHRoaXMuZ2V0Vml6V2lyZVRvUmVtb3RlKCk7XG4gIHZhciBpbmNvbWluZ1dpcmUgPSB0aGlzLmdldFZpeldpcmVGcm9tUmVtb3RlKCk7XG4gIGlmICghKHZpeldpcmUgJiYgaW5jb21pbmdXaXJlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhpZGUgdGhlIGluY29taW5nIHdpcmUgYmVjYXVzZSB3ZSBhcmUgaW4gc2ltcGxleCBtb2RlLlxuICBpbmNvbWluZ1dpcmUuaGlkZSgpO1xuICAvLyBBbmltYXRlIHRoZSBvdXRnb2luZyB3aXJlXG4gIHZpeldpcmUuYW5pbWF0ZVNldFN0YXRlKG5ld1N0YXRlKTtcbn07XG5cbi8qKlxuICogS2ljayBvZmYgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBzaG93IHRoZSBzdGF0ZSBvZiB0aGUgc2ltcGxleCB3aXJlIGJlaW5nXG4gKiByZWFkIGJ5IHRoZSBsb2NhbCBub2RlLlxuICogQHBhcmFtIHtcIjBcInxcIjFcIn0gbmV3U3RhdGVcbiAqL1xuTmV0U2ltVmlzdWFsaXphdGlvbi5wcm90b3R5cGUuYW5pbWF0ZVJlYWRXaXJlU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgLy8gQXNzdW1lcyB3ZSBhcmUgaW4gc2ltcGxleCBQMlAgbW9kZSBhbmQgdGFsa2luZyBhYm91dCB0aGUgd2lyZSBiZXR3ZWVuXG4gIC8vIHRoZSBsb2NhbCBub2RlIGFuZCBpdHMgcmVtb3RlIHBhcnRuZXIuICBUaGlzIGlzIGEgbm8tb3AgaWYgbm8gc3VjaCB3aXJlXG4gIC8vIGV4aXN0cy4gIFdlIGNhbiBzdG9wIGFueSBwcmV2aW91cyBhbmltYXRpb24gb24gdGhlIHdpcmUgaWYgdGhpcyBpcyBjYWxsZWQuXG5cbiAgdmFyIHZpeldpcmUgPSB0aGlzLmdldFZpeldpcmVUb1JlbW90ZSgpO1xuICB2YXIgaW5jb21pbmdXaXJlID0gdGhpcy5nZXRWaXpXaXJlRnJvbVJlbW90ZSgpO1xuICBpZiAoISh2aXpXaXJlICYmIGluY29taW5nV2lyZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIaWRlIHRoZSBpbmNvbWluZyB3aXJlIGJlY2F1c2Ugd2UgYXJlIGluIHNpbXBsZXggbW9kZS5cbiAgaW5jb21pbmdXaXJlLmhpZGUoKTtcbiAgLy8gQW5pbWF0ZSB0aGUgb3V0Z29pbmcgd2lyZVxuICB2aXpXaXJlLmFuaW1hdGVSZWFkU3RhdGUobmV3U3RhdGUpO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBvdXRnb2luZyB3aXJlIGZyb20gdGhlIGxvY2FsIG5vZGUgdG8gYSByZW1vdGUgbm9kZS5cbiAqIEByZXR1cm5zIHtOZXRTaW1WaXpTaW11bGF0aW9uV2lyZXxudWxsfSBudWxsIGlmIG5vIG91dGdvaW5nIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gKi9cbk5ldFNpbVZpc3VhbGl6YXRpb24ucHJvdG90eXBlLmdldFZpeldpcmVUb1JlbW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmxvY2FsTm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG91dGdvaW5nV2lyZXMgPSB0aGlzLmVsZW1lbnRzXy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpelNpbXVsYXRpb25XaXJlICYmXG4gICAgICAgIGVsZW1lbnQubG9jYWxWaXpOb2RlID09PSB0aGlzLmxvY2FsTm9kZTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKG91dGdvaW5nV2lyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gb3V0Z29pbmdXaXJlc1swXTtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaW5jb21pbmcgd2lyZSBmcm9tIGEgcmVtb3RlIG5vZGUgdG8gdGhlIGxvY2FsIG5vZGUuXG4gKiBAcmV0dXJucyB7TmV0U2ltVml6U2ltdWxhdGlvbldpcmV8bnVsbH0gbnVsbCBpZiBubyBpbmNvbWluZyBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICovXG5OZXRTaW1WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5nZXRWaXpXaXJlRnJvbVJlbW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmxvY2FsTm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGluY29taW5nV2lyZXMgPSB0aGlzLmVsZW1lbnRzXy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIE5ldFNpbVZpelNpbXVsYXRpb25XaXJlICYmXG4gICAgICAgIGVsZW1lbnQucmVtb3RlVml6Tm9kZSA9PT0gdGhpcy5sb2NhbE5vZGU7XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChpbmNvbWluZ1dpcmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGluY29taW5nV2lyZXNbMF07XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgV2lyZXMgaW4gdGhlIHZpc3VhbGl6YXRpb24gdGhhdCBtYXAgdG8gc2ltdWxhdGlvbiBlbnRpdGllcy5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xudmFyIE5ldFNpbVZpek5vZGUgPSByZXF1aXJlKCcuL05ldFNpbVZpek5vZGUnKTtcbnZhciBOZXRTaW1WaXpXaXJlID0gcmVxdWlyZSgnLi9OZXRTaW1WaXpXaXJlJyk7XG5cbi8qKlxuICogQHBhcmFtIHtOZXRTaW1XaXJlfSBzb3VyY2VXaXJlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRFbGVtZW50QnlFbnRpdHlJRCAtIEFsbG93cyB0aGlzIHdpcmUgdG8gc2VhcmNoXG4gKiAgICAgICAgZm9yIG90aGVyIGVudGl0aWVzIGluIHRoZSBzaW11bGF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1WaXpXaXJlXG4gKi9cbnZhciBOZXRTaW1WaXpTaW11bGF0aW9uV2lyZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZVdpcmUsXG4gICAgZ2V0RWxlbWVudEJ5RW50aXR5SWQpIHtcbiAgdmFyIGxvY2FsTm9kZSA9IGdldEVsZW1lbnRCeUVudGl0eUlkKE5ldFNpbVZpek5vZGUsIHNvdXJjZVdpcmUubG9jYWxOb2RlSUQpO1xuICB2YXIgcmVtb3RlTm9kZSA9IGdldEVsZW1lbnRCeUVudGl0eUlkKE5ldFNpbVZpek5vZGUsIHNvdXJjZVdpcmUucmVtb3RlTm9kZUlEKTtcbiAgTmV0U2ltVml6V2lyZS5jYWxsKHRoaXMsIGxvY2FsTm9kZSwgcmVtb3RlTm9kZSk7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBOZXRTaW1XaXJlIHRoYXQgdGhpcyBOZXRTaW1WaXpTaW11bGF0aW9uV2lyZSBtYXBzIHRvLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5jb3JyZXNwb25kaW5nV2lyZUlkXyA9IHNvdXJjZVdpcmUuZW50aXR5SUQ7XG5cbiAgLyoqXG4gICAqIFVVSUQgb2YgdGhlIE5ldFNpbVdpcmUgdGhhdCB0aGlzIE5ldFNpbVZpelNpbXVsYXRpb25XaXJlIG1hcHMgdG8uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmNvcnJlc3BvbmRpbmdXaXJlVXVpZF8gPSBzb3VyY2VXaXJlLnV1aWQ7XG5cbiAgLyoqXG4gICAqIEJvdW5kIGdldEVsZW1lbnRCeUVudGl0eUlkIG1ldGhvZCBmcm9tIHZpenVhbGl6YXRpb24gY29udHJvbGxlcjtcbiAgICogd2UgaG9sZCBvbiB0byB0aGlzIHNvIHRoYXQgY2FsbHMgdG8gY29uZmlndXJlRnJvbSBjYW4gZmluZCBub2RlcyBsYXRlci5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5nZXRFbGVtZW50QnlFbnRpdHlJZF8gPSBnZXRFbGVtZW50QnlFbnRpdHlJZDtcblxuICB0aGlzLmNvbmZpZ3VyZUZyb20oc291cmNlV2lyZSk7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuTmV0U2ltVml6U2ltdWxhdGlvbldpcmUuaW5oZXJpdHMoTmV0U2ltVml6V2lyZSk7XG5cbi8qKlxuICogQ29uZmlndXJpbmcgYSB3aXJlIG1lYW5zIGxvb2tpbmcgdXAgdGhlIHZpeiBub2RlcyB0aGF0IHdpbGwgYmUgaXRzIGVuZHBvaW50cy5cbiAqIEBwYXJhbSB7TmV0U2ltV2lyZX0gc291cmNlV2lyZVxuICovXG5OZXRTaW1WaXpTaW11bGF0aW9uV2lyZS5wcm90b3R5cGUuY29uZmlndXJlRnJvbSA9IGZ1bmN0aW9uIChzb3VyY2VXaXJlKSB7XG4gIHRoaXMuY29ycmVzcG9uZGluZ1dpcmVJZF8gPSBzb3VyY2VXaXJlLmVudGl0eUlEO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdXaXJlVXVpZF8gPSBzb3VyY2VXaXJlLnV1aWQ7XG5cbiAgdGhpcy5sb2NhbFZpek5vZGUgPSB0aGlzLmdldEVsZW1lbnRCeUVudGl0eUlkXyhOZXRTaW1WaXpOb2RlLCBzb3VyY2VXaXJlLmxvY2FsTm9kZUlEKTtcbiAgdGhpcy5yZW1vdGVWaXpOb2RlID0gdGhpcy5nZXRFbGVtZW50QnlFbnRpdHlJZF8oTmV0U2ltVml6Tm9kZSwgc291cmNlV2lyZS5yZW1vdGVOb2RlSUQpO1xuXG4gIGlmICh0aGlzLmxvY2FsVml6Tm9kZSkge1xuICAgIHRoaXMubG9jYWxWaXpOb2RlLnNldEFkZHJlc3Moc291cmNlV2lyZS5sb2NhbEFkZHJlc3MpO1xuICB9XG5cbiAgaWYgKHRoaXMucmVtb3RlVml6Tm9kZSkge1xuICAgIHRoaXMucmVtb3RlVml6Tm9kZS5zZXRBZGRyZXNzKHNvdXJjZVdpcmUucmVtb3RlQWRkcmVzcyk7XG4gIH1cblxuICBpZiAoTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLmJyb2FkY2FzdE1vZGUpIHtcbiAgICB0aGlzLmdldFJvb3QoKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICB9XG59O1xuXG4vKipcbiAqIElEIG9mIHRoZSBOZXRTaW1FbnRpdHkgdGhhdCBtYXBzIHRvIHRoaXMgdmlzdWFsaXphdGlvbiBlbGVtZW50LlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuTmV0U2ltVml6U2ltdWxhdGlvbldpcmUucHJvdG90eXBlLmdldENvcnJlc3BvbmRpbmdFbnRpdHlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29ycmVzcG9uZGluZ1dpcmVJZF87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltRW50aXR5fSBlbnRpdHlcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHRoaXMgVml6RWxlbWVudCByZXByZXNlbnRzIHRoZSBnaXZlbiBOZXRTaW1FbnRpdHkuXG4gKi9cbk5ldFNpbVZpelNpbXVsYXRpb25XaXJlLnByb3RvdHlwZS5yZXByZXNlbnRzRW50aXR5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICByZXR1cm4gdGhpcy5jb3JyZXNwb25kaW5nV2lyZUlkXyA9PT0gZW50aXR5LmVudGl0eUlEICYmXG4gICAgICB0aGlzLmNvcnJlc3BvbmRpbmdXaXJlVXVpZF8gPT09IGVudGl0eS51dWlkO1xufTtcblxuLyoqXG4gKiBLaWxsaW5nIGEgdmlzdWFsaXphdGlvbiBub2RlIHJlbW92ZXMgaXRzIElEIHNvIHRoYXQgaXQgd29uJ3QgY29uZmxpY3Qgd2l0aFxuICogYW5vdGhlciB2aXpub2RlIG9mIG1hdGNoaW5nIElEIGJlaW5nIGFkZGVkLCBhbmQgYmVnaW5zIGl0cyBleGl0IGFuaW1hdGlvbi5cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1WaXpTaW11bGF0aW9uV2lyZS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgTmV0U2ltVml6U2ltdWxhdGlvbldpcmUuc3VwZXJQcm90b3R5cGUua2lsbC5jYWxsKHRoaXMpO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdXaXJlSWRfID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdXaXJlVXVpZF8gPSB1bmRlZmluZWQ7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgV2lyZXMgaW4gdGhlIHZpc3VhbGl6YXRpb24uXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGpRdWVyeVN2Z0VsZW1lbnQgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJykualF1ZXJ5U3ZnRWxlbWVudDtcbnZhciBOZXRTaW1WaXpFbGVtZW50ID0gcmVxdWlyZSgnLi9OZXRTaW1WaXpFbGVtZW50Jyk7XG52YXIgdHdlZW5zID0gcmVxdWlyZSgnLi90d2VlbnMnKTtcbnZhciBEYXRhQ29udmVydGVycyA9IHJlcXVpcmUoJy4vRGF0YUNvbnZlcnRlcnMnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xuXG52YXIgRW5jb2RpbmdUeXBlID0gTmV0U2ltQ29uc3RhbnRzLkVuY29kaW5nVHlwZTtcblxudmFyIGJpbmFyeVRvQUIgPSBEYXRhQ29udmVydGVycy5iaW5hcnlUb0FCO1xuXG4vKipcbiAqIEhvdyBmYXIgdGhlIGZseWluZyBsYWJlbCBzaG91bGQgcmVzdCBhYm92ZSB0aGUgd2lyZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIFRFWFRfRklOQUxfVkVSVElDQUxfT0ZGU0VUID0gLTEwO1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltVml6Tm9kZX0gbG9jYWxOb2RlXG4gKiBAcGFyYW0ge05ldFNpbVZpek5vZGV9IHJlbW90ZU5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbVZpekVsZW1lbnRcbiAqL1xudmFyIE5ldFNpbVZpeldpcmUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsb2NhbE5vZGUsIHJlbW90ZU5vZGUpIHtcbiAgTmV0U2ltVml6RWxlbWVudC5jYWxsKHRoaXMpO1xuXG4gIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG4gIHJvb3QuYWRkQ2xhc3MoJ3Zpei13aXJlJyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtqUXVlcnl9IHdyYXBwZWQgYXJvdW5kIGEgU1ZHUGF0aEVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubGluZV8gPSBqUXVlcnlTdmdFbGVtZW50KCdwYXRoJylcbiAgICAgIC5hcHBlbmRUbyhyb290KTtcblxuICAvKipcbiAgICogQHR5cGUge2pRdWVyeX0gd3JhcHBlZCBhcm91bmQgYSBTVkdUZXh0RWxlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5xdWVzdGlvbk1hcmtfID0galF1ZXJ5U3ZnRWxlbWVudCgndGV4dCcpXG4gICAgICAudGV4dCgnPycpXG4gICAgICAuYWRkQ2xhc3MoJ3F1ZXN0aW9uLW1hcmsnKVxuICAgICAgLmFwcGVuZFRvKHJvb3QpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7alF1ZXJ5fSB3cmFwcGVkIGFyb3VuZCBhIFNWR1RleHRFbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRleHRfID0galF1ZXJ5U3ZnRWxlbWVudCgndGV4dCcpXG4gICAgICAuYWRkQ2xhc3MoJ3N0YXRlLWxhYmVsJylcbiAgICAgIC5hcHBlbmRUbyhyb290KTtcblxuICAvKipcbiAgICogWC1jb29yZGluYXRlIG9mIHRleHQgbGFiZWwsIGZvciBhbmltYXRpb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRleHRQb3NYXyA9IDA7XG5cbiAgLyoqXG4gICAqIFktY29vcmRpbmF0ZSBvZiB0ZXh0IGxhYmVsLCBmb3IgYW5pbWF0aW9uLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50ZXh0UG9zWV8gPSAwO1xuXG4gIC8qKlxuICAgKiBGbGFnIHRoYXQgYWxsb3dzIHVzIHRvIGZvcmNlIGFuIHVwZGF0ZSBvZiB0aGUgdGV4dCBwb3NpdGlvbjsgdXNlZFxuICAgKiB3aGVuIHdlIG1vdmUgdGV4dCB3aXRob3V0IHR3ZWVucyBiZWNhdXNlIHRoYXQgbWV0aG9kIHByZXZlbnRzIHVzXG4gICAqIGZyb20gYmVpbmcgYWJsZSB0byBkZXRlY3Qgbm9ybWFsbHkgdGhhdCBzb21ldGhpbmcgaGFzIGNoYW5nZWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmZvcmNlVGV4dFBvc1JlbmRlcl8gPSBmYWxzZTtcblxuICAvKipcbiAgICogU1ZHIFBhdGggRGVzY3JpcHRpb24gb2YgdGhpcy5saW5lXywgZm9yIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wYXRoRGF0YV8gPSAnJztcblxuICAvKipcbiAgICogYFRFWFRfRklOQUxfVkVSVElDQUxfT0ZGU0VUYC1vZmZzZXQgWCBhbmQgWSBjb29yZGluYXRlcyBmb3IgdGhlXG4gICAqIGNlbnRlciBvZiB0aGUgd2lyZTsgdXNlZCBmb3IgcG9zaXRpb25pbmcgdGhlIHF1ZXN0aW9uIG1hcmtcbiAgICogQHR5cGUge3t4Om51bWJlciwgeTpudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy53aXJlQ2VudGVyXyA9IHsgeDogMCwgeTogMCB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGVkIGVuY29kaW5nIHR5cGVzLlxuICAgKiBAdHlwZSB7RW5jb2RpbmdUeXBlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVuY29kaW5nc18gPSBbXTtcblxuICB0aGlzLmxvY2FsVml6Tm9kZSA9IGxvY2FsTm9kZTtcbiAgdGhpcy5yZW1vdGVWaXpOb2RlID0gcmVtb3RlTm9kZTtcblxuICB0aGlzLnJlbmRlcigpO1xufTtcbk5ldFNpbVZpeldpcmUuaW5oZXJpdHMoTmV0U2ltVml6RWxlbWVudCk7XG5cbi8qKlxuICogVXBkYXRlIHBhdGggZGF0YSBmb3Igd2lyZSBpZiB3ZSBjYW4gZGV0ZWN0IHBlbmRpbmcgY2hhbmdlc1xuICogQHBhcmFtIHtSdW5Mb29wLkNsb2NrfSBbY2xvY2tdIC0gc29tdGltZXMgb21pdHRlZCBkdXJpbmcgc2V0dXBcbiAqL1xuTmV0U2ltVml6V2lyZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNsb2NrKSB7XG5cbiAgLy8gQ2FjaGUgdGhlIGxvY2FsIHBvc2l0aW9uIHZhbHVlcyBoZXJlLCBzbyB3ZSBjYW4gY2hlY2sgbGF0ZXIgaWZcbiAgLy8gYW55dGhpbmcgaGFzIGNoYW5nZWQgYmVmb3JlIG1ha2luZyBhbiBleHBlbnNpdmUgYC5hdHRyYCBjYWxsXG4gIHZhciB0ZXh0UG9zWCA9IHRoaXMudGV4dFBvc1hfO1xuICB2YXIgdGV4dFBvc1kgPSB0aGlzLnRleHRQb3NZXztcbiAgdmFyIHBhdGhEYXRhID0gdGhpcy5wYXRoRGF0YV87XG4gIHZhciB3aXJlQ2VudGVyID0gdGhpcy53aXJlQ2VudGVyXztcblxuICAvLyBNYWtlIHRoZSBjYWxsIHRvIHN1cGVyIHRvIHVwZGF0ZSBldmVyeXRoaW5nIHdlIGNhbiwgdGhlblxuICAvLyByZWNhbGN1bGF0ZSB0aGUgdmFsdWVzIG9mIG91cnMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIHRoZSBtb3ZlbWVudFxuICAvLyBvZiBvdXIgY29ubmVjdGVkIG5vZGVzXG4gIE5ldFNpbVZpeldpcmUuc3VwZXJQcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgY2xvY2spO1xuXG4gIGlmICh0aGlzLmxvY2FsVml6Tm9kZSAmJiB0aGlzLnJlbW90ZVZpek5vZGUpIHtcbiAgICB0aGlzLnBhdGhEYXRhXyA9IFsnTScsIHRoaXMubG9jYWxWaXpOb2RlLnBvc1gsIHRoaXMubG9jYWxWaXpOb2RlLnBvc1ksXG4gICAgICAgICdMJywgdGhpcy5yZW1vdGVWaXpOb2RlLnBvc1gsIHRoaXMucmVtb3RlVml6Tm9kZS5wb3NZXS5qb2luKCcgJyk7XG4gICAgdGhpcy53aXJlQ2VudGVyXyA9IHRoaXMuZ2V0V2lyZUNlbnRlclBvc2l0aW9uKCk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBpZiBhbmQgb25seSBpZiBhbnkgb2YgdGhlIHZhbHVlcyB3ZSBjYXJlIGFib3V0IGhhdmVcbiAgLy8gY2hhbmdlZCwgdXBkYXRlIG91ciBlbGVtZW50IGluIHRoZSBET01cbiAgaWYgKHRoaXMuZm9yY2VUZXh0UG9zUmVuZGVyXyB8fCB0ZXh0UG9zWCAhPT0gdGhpcy50ZXh0UG9zWF8gfHxcbiAgICAgIHRleHRQb3NZICE9PSB0aGlzLnRleHRQb3NZXykge1xuICAgIHRoaXMudGV4dF9cbiAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLnRleHRQb3NYXylcbiAgICAgICAgLmF0dHIoJ3knLCB0aGlzLnRleHRQb3NZXyk7XG4gICAgdGhpcy5mb3JjZVRleHRQb3NSZW5kZXJfID0gZmFsc2U7XG4gIH1cbiAgaWYgKHBhdGhEYXRhICE9PSB0aGlzLnBhdGhEYXRhXykge1xuICAgIHRoaXMubGluZV8uYXR0cignZCcsIHRoaXMucGF0aERhdGFfKTtcbiAgfVxuICBpZiAod2lyZUNlbnRlci54ICE9PSB0aGlzLndpcmVDZW50ZXJfLnggfHwgd2lyZUNlbnRlci55ICE9PSB0aGlzLndpcmVDZW50ZXJfLnkpIHtcbiAgICB0aGlzLnF1ZXN0aW9uTWFya19cbiAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLndpcmVDZW50ZXJfLngpXG4gICAgICAgIC5hdHRyKCd5JywgdGhpcy53aXJlQ2VudGVyXy55KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoaXMgd2lyZSAtIHVzZWQgdG8gaGlkZSB0aGUgaW5jb21pbmcgd2lyZSB3aGVuIHdlJ3JlIHRyeWluZyB0byBzaG93XG4gKiBzaW1wbGV4IG1vZGUuXG4gKi9cbk5ldFNpbVZpeldpcmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZ2V0Um9vdCgpLmFkZENsYXNzKCdoaWRkZW4td2lyZScpO1xufTtcblxuLyoqXG4gKiBLaWxsaW5nIGEgdmlzdWFsaXphdGlvbiBub2RlIHJlbW92ZXMgaXRzIElEIHNvIHRoYXQgaXQgd29uJ3QgY29uZmxpY3Qgd2l0aFxuICogYW5vdGhlciBub2RlIG9mIG1hdGNoaW5nIElEIGJlaW5nIGFkZGVkLCBhbmQgYmVnaW5zIGl0cyBleGl0IGFuaW1hdGlvbi5cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1WaXpXaXJlLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICBOZXRTaW1WaXpXaXJlLnN1cGVyUHJvdG90eXBlLmtpbGwuY2FsbCh0aGlzKTtcbiAgdGhpcy5sb2NhbFZpek5vZGUgPSBudWxsO1xuICB0aGlzLnJlbW90ZVZpek5vZGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZW5jb2RpbmctdmlldyBzZXR0aW5ncy4gIERldGVybWluZXMgaG93IGJpdCBzZXRzL3JlYWRzIGFyZVxuICogZGlzcGxheWVkIHdoZW4gYW5pbWF0aW5nIGFib3ZlIHRoZSB3aXJlLlxuICpcbiAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlW119IG5ld0VuY29kaW5nc1xuICovXG5OZXRTaW1WaXpXaXJlLnByb3RvdHlwZS5zZXRFbmNvZGluZ3MgPSBmdW5jdGlvbiAobmV3RW5jb2RpbmdzKSB7XG4gIHRoaXMuZW5jb2RpbmdzXyA9IG5ld0VuY29kaW5ncztcbn07XG5cbi8qKlxuICogS2ljayBvZmYgYW4gYW5pbWF0aW9uIG9mIHRoZSB3aXJlIHN0YXRlIGJlaW5nIHNldCBieSB0aGUgbG9jYWwgdml6bm9kZS5cbiAqIEBwYXJhbSB7XCIwXCJ8XCIxXCJ9IG5ld1N0YXRlXG4gKi9cbk5ldFNpbVZpeldpcmUucHJvdG90eXBlLmFuaW1hdGVTZXRTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICBpZiAoISh0aGlzLmxvY2FsVml6Tm9kZSAmJiB0aGlzLnJlbW90ZVZpek5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZseU91dE1zID0gMzAwO1xuICB2YXIgaG9sZFBvc2l0aW9uTXMgPSAzMDA7XG5cbiAgdGhpcy5zdG9wQWxsQW5pbWF0aW9uKCk7XG4gIHRoaXMuc2V0V2lyZUNsYXNzZXNfKG5ld1N0YXRlKTtcbiAgdGhpcy50ZXh0Xy50ZXh0KHRoaXMuZ2V0RGlzcGxheUJpdF8obmV3U3RhdGUpKTtcbiAgdGhpcy5zbmFwVGV4dFRvUG9zaXRpb24odGhpcy5nZXRMb2NhbE5vZGVQb3NpdGlvbigpKTtcbiAgdGhpcy50d2VlblRleHRUb1Bvc2l0aW9uKHRoaXMuZ2V0V2lyZUNlbnRlclBvc2l0aW9uKCksIGZseU91dE1zLFxuICAgICAgdHdlZW5zLmVhc2VPdXRRdWFkKTtcbiAgdGhpcy5kb0FmdGVyRGVsYXkoZmx5T3V0TXMgKyBob2xkUG9zaXRpb25NcywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0V2lyZUNsYXNzZXNfKCd1bmtub3duJyk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEtpY2sgb2ZmIGFuIGFuaW1hdGlvbiBvZiB0aGUgd2lyZSBzdGF0ZSBiZWluZyByZWFkIGJ5IHRoZSBsb2NhbCB2aXpub2RlLlxuICogQHBhcmFtIHtcIjBcInxcIjFcIn0gbmV3U3RhdGVcbiAqL1xuTmV0U2ltVml6V2lyZS5wcm90b3R5cGUuYW5pbWF0ZVJlYWRTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICBpZiAoISh0aGlzLmxvY2FsVml6Tm9kZSAmJiB0aGlzLnJlbW90ZVZpek5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhvbGRQb3NpdGlvbk1zID0gMzAwO1xuICB2YXIgZmx5VG9Ob2RlTXMgPSAzMDA7XG5cbiAgdGhpcy5zdG9wQWxsQW5pbWF0aW9uKCk7XG4gIHRoaXMuc2V0V2lyZUNsYXNzZXNfKG5ld1N0YXRlKTtcbiAgdGhpcy50ZXh0Xy50ZXh0KHRoaXMuZ2V0RGlzcGxheUJpdF8obmV3U3RhdGUpKTtcbiAgdGhpcy5zbmFwVGV4dFRvUG9zaXRpb24odGhpcy5nZXRXaXJlQ2VudGVyUG9zaXRpb24oKSk7XG4gIHRoaXMuZG9BZnRlckRlbGF5KGhvbGRQb3NpdGlvbk1zLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50d2VlblRleHRUb1Bvc2l0aW9uKHRoaXMuZ2V0TG9jYWxOb2RlUG9zaXRpb24oKSwgZmx5VG9Ob2RlTXMsXG4gICAgICAgIHR3ZWVucy5lYXNlT3V0UXVhZCk7XG4gICAgdGhpcy5zZXRXaXJlQ2xhc3Nlc18oJ3Vua25vd24nKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQWRkcy9yZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgU1ZHIHJvb3QgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB3aXJlIHN0YXRlLlxuICogUGFzc2luZyBhbnl0aGluZyBvdGhlciB0aGFuIFwiMVwiIG9yIFwiMFwiIHdpbGwgcHV0IHRoZSB3aXJlIGluIGFuIFwidW5rbm93blwiXG4gKiBzdGF0ZSwgd2hpY2ggYmVnaW5zIGEgQ1NTIHRyYW5zaXRpb24gZmFkZSBiYWNrIHRvIGdyYXkuXG4gKiBAcGFyYW0ge1wiMFwifFwiMVwifCp9IG5ld1N0YXRlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1WaXpXaXJlLnByb3RvdHlwZS5zZXRXaXJlQ2xhc3Nlc18gPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgdmFyIHN0YXRlT2ZmID0gKG5ld1N0YXRlID09PSAnMCcpO1xuICB2YXIgc3RhdGVPbiA9ICghc3RhdGVPZmYgJiYgbmV3U3RhdGUgPT09ICcxJyk7XG4gIHZhciBzdGF0ZVVua25vd24gPSAoIXN0YXRlT2ZmICYmICFzdGF0ZU9uKTtcblxuICB0aGlzLmdldFJvb3QoKS50b2dnbGVDbGFzcygnc3RhdGUtb24nLCBzdGF0ZU9uKTtcbiAgdGhpcy5nZXRSb290KCkudG9nZ2xlQ2xhc3MoJ3N0YXRlLW9mZicsIHN0YXRlT2ZmKTtcbiAgdGhpcy5nZXRSb290KCkudG9nZ2xlQ2xhc3MoJ3N0YXRlLXVua25vd24nLCBzdGF0ZVVua25vd24pO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gYXBwcm9wcmlhdGUgXCJkaXNwbGF5IGJpdFwiIHRvIHNob3cgYWJvdmUgdGhlIHdpcmUsIGdpdmVuIHRoZVxuICogY3VycmVudCBlbmFibGVkIGVuY29kaW5ncyAoc2hvdWxkIG1hdGNoIHRoZSBcInNldCB3aXJlXCIgYnV0dG9uIGxhYmVsKVxuICogQHBhcmFtIHtcIjBcInxcIjFcIn0gd2lyZVN0YXRlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhIGRpc3BsYXkgYml0IGFwcHJvcHJpYXRlIHRvIHRoZSBlbmFibGVkIGVuY29kaW5ncy5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVZpeldpcmUucHJvdG90eXBlLmdldERpc3BsYXlCaXRfID0gZnVuY3Rpb24gKHdpcmVTdGF0ZSkge1xuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkFfQU5EX0IpICYmXG4gICAgICAhdGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkJJTkFSWSkpIHtcbiAgICB3aXJlU3RhdGUgPSBiaW5hcnlUb0FCKHdpcmVTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHdpcmVTdGF0ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gZW5jb2RpbmcgaXMgY3VycmVudGx5IGRpc3BsYXllZCBieSB0aGUgcGFuZWwuXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZX0gcXVlcnlFbmNvZGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1WaXpXaXJlLnByb3RvdHlwZS5pc0VuY29kaW5nRW5hYmxlZF8gPSBmdW5jdGlvbiAocXVlcnlFbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5lbmNvZGluZ3NfLnNvbWUoZnVuY3Rpb24gKGVuYWJsZWRFbmNvZGluZykge1xuICAgIHJldHVybiBlbmFibGVkRW5jb2RpbmcgPT09IHF1ZXJ5RW5jb2Rpbmc7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFuaW1hdGVkIG1vdGlvbiBmcm9tIHRoZSB0ZXh0J3MgY3VycmVudCBwb3NpdGlvbiB0byB0aGVcbiAqIGdpdmVuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NjAwXSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7VHdlZW5GdW5jdGlvbn0gW3R3ZWVuRnVuY3Rpb249bGluZWFyXVxuICovXG5OZXRTaW1WaXpXaXJlLnByb3RvdHlwZS50d2VlblRleHRUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBkdXJhdGlvbixcbiAgICB0d2VlbkZ1bmN0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICB0aGlzLnR3ZWVuc18ucHVzaChuZXcgdHdlZW5zLlR3ZWVuVmFsdWVUbyh0aGlzLCAndGV4dFBvc1hfJywgZGVzdGluYXRpb24ueCxcbiAgICAgICAgZHVyYXRpb24sIHR3ZWVuRnVuY3Rpb24pKTtcbiAgICB0aGlzLnR3ZWVuc18ucHVzaChuZXcgdHdlZW5zLlR3ZWVuVmFsdWVUbyh0aGlzLCAndGV4dFBvc1lfJywgZGVzdGluYXRpb24ueSxcbiAgICAgICAgZHVyYXRpb24sIHR3ZWVuRnVuY3Rpb24pKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRleHRQb3NYXyA9IGRlc3RpbmF0aW9uLng7XG4gICAgdGhpcy50ZXh0UG9zWV8gPSBkZXN0aW5hdGlvbi55O1xuICAgIHRoaXMuZm9yY2VUZXh0UG9zUmVuZGVyXyA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogU25hcHMgdGhlIHRleHQgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gZGVzdGluYXRpb25cbiAqL1xuTmV0U2ltVml6V2lyZS5wcm90b3R5cGUuc25hcFRleHRUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gIHRoaXMudHdlZW5UZXh0VG9Qb3NpdGlvbihkZXN0aW5hdGlvbiwgMCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqL1xuTmV0U2ltVml6V2lyZS5wcm90b3R5cGUuZ2V0TG9jYWxOb2RlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgeDogdGhpcy5sb2NhbFZpek5vZGUucG9zWCxcbiAgICB5OiB0aGlzLmxvY2FsVml6Tm9kZS5wb3NZXG4gIH07XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqL1xuTmV0U2ltVml6V2lyZS5wcm90b3R5cGUuZ2V0V2lyZUNlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHg6ICh0aGlzLnJlbW90ZVZpek5vZGUucG9zWCAtIHRoaXMubG9jYWxWaXpOb2RlLnBvc1gpIC8gMiArXG4gICAgICAgIHRoaXMubG9jYWxWaXpOb2RlLnBvc1gsXG4gICAgeTogKHRoaXMucmVtb3RlVml6Tm9kZS5wb3NZIC0gdGhpcy5yZW1vdGVWaXpOb2RlLnBvc1kpIC8gMiArXG4gICAgICAgIHRoaXMubG9jYWxWaXpOb2RlLnBvc1kgKyBURVhUX0ZJTkFMX1ZFUlRJQ0FMX09GRlNFVFxuICB9O1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IE5vZGVzIGluIHRoZSB2aXN1YWxpemF0aW9uIHRoYXQgbWFwIHRvIHNpbXVsYXRpb24gZW50aXRpZXMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIE5ldFNpbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJyk7XG52YXIgTmV0U2ltVml6Tm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltVml6Tm9kZScpO1xuXG52YXIgTm9kZVR5cGUgPSBOZXRTaW1Db25zdGFudHMuTm9kZVR5cGU7XG5cbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbi8qKlxuICogQHBhcmFtIHtOZXRTaW1Ob2RlfSBzb3VyY2VOb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUJhY2tncm91bmRBbmltYXRpb24gLSBjaGFuZ2VzIHRoZSBiZWhhdmlvciBvZiB0aGlzIG5vZGVcbiAqICAgICAgICB3aGVuIGl0J3MgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbVZpek5vZGVcbiAqL1xudmFyIE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlTm9kZSxcbiAgICB1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uKSB7XG4gIE5ldFNpbVZpek5vZGUuY2FsbCh0aGlzLCB1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uKTtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIE5ldFNpbU5vZGUgdGhhdCB0aGlzIE5ldFNpbVZpelNpbXVsYXRpb25Ob2RlIHJlcHJlc2VudHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmNvcnJlc3BvbmRpbmdOb2RlSURfID0gc291cmNlTm9kZS5lbnRpdHlJRDtcblxuICAvKipcbiAgICogVVVJRCBvZiB0aGUgTmV0U2ltTm9kZSB0aGF0IHRoaXMgTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUgcmVwcmVzZW50cy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuY29ycmVzcG9uZGluZ05vZGVVdWlkXyA9IHNvdXJjZU5vZGUudXVpZDtcblxuICAvKipcbiAgICogSWYgd2UgZW5kIHVwIHJlcHJlc2VudGluZyBhIHJvdXRlciwgd2UgbWF5IG5lZWQgdG8gaG9sZCB0aGUgYXV0by1kbnMgYWRkcmVzc1xuICAgKiB0byBwYXNzIHRvIGEgZmFrZSBhdXRvLWRucyBub2RlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5hdXRvRG5zQWRkcmVzcyA9IHVuZGVmaW5lZDtcblxuICB0aGlzLmNvbmZpZ3VyZUZyb20oc291cmNlTm9kZSk7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUuaW5oZXJpdHMoTmV0U2ltVml6Tm9kZSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7TmV0U2ltTm9kZX0gc291cmNlTm9kZVxuICovXG5OZXRTaW1WaXpTaW11bGF0aW9uTm9kZS5wcm90b3R5cGUuY29uZmlndXJlRnJvbSA9IGZ1bmN0aW9uIChzb3VyY2VOb2RlKSB7XG4gIHRoaXMuY29ycmVzcG9uZGluZ05vZGVJZF8gPSBzb3VyY2VOb2RlLmVudGl0eUlEO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdOb2RlVXVpZF8gPSBzb3VyY2VOb2RlLnV1aWQ7XG5cbiAgdmFyIGxldmVsQ29uZmlnID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuICBpZiAobGV2ZWxDb25maWcuc2hvd0hvc3RuYW1lSW5HcmFwaCkge1xuICAgIHRoaXMuc2V0TmFtZShzb3VyY2VOb2RlLmdldEhvc3RuYW1lKCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2V0TmFtZShzb3VyY2VOb2RlLmdldFNob3J0RGlzcGxheU5hbWUoKSk7XG4gIH1cblxuICBpZiAoc291cmNlTm9kZS5nZXROb2RlVHlwZSgpID09PSBOb2RlVHlwZS5ST1VURVIpIHtcbiAgICB0aGlzLmlzUm91dGVyID0gdHJ1ZTtcbiAgICB0aGlzLmdldFJvb3QoKS5hZGRDbGFzcygncm91dGVyLW5vZGUnKTtcbiAgICB0aGlzLmF1dG9EbnNBZGRyZXNzID0gc291cmNlTm9kZS5nZXRBdXRvRG5zQWRkcmVzcygpO1xuICAgIGlmIChsZXZlbENvbmZpZy5icm9hZGNhc3RNb2RlKSB7XG4gICAgICB0aGlzLmdldFJvb3QoKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJRCBvZiB0aGUgc2ltdWxhdGlvbiBlbnRpdHkgdGhhdCBtYXBzIHRvIHRoaXMgb25lLlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUucHJvdG90eXBlLmdldENvcnJlc3BvbmRpbmdFbnRpdHlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29ycmVzcG9uZGluZ05vZGVJZF87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltRW50aXR5fSBlbnRpdHlcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIG9mIHRoaXMgVml6RWxlbWVudCByZXByZXNlbnRzIHRoZSBnaXZlbiBFbnRpdHkuXG4gKi9cbk5ldFNpbVZpelNpbXVsYXRpb25Ob2RlLnByb3RvdHlwZS5yZXByZXNlbnRzRW50aXR5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICByZXR1cm4gdGhpcy5jb3JyZXNwb25kaW5nTm9kZUlkXyA9PT0gZW50aXR5LmVudGl0eUlEICYmXG4gICAgICB0aGlzLmNvcnJlc3BvbmRpbmdOb2RlVXVpZF8gPT09IGVudGl0eS51dWlkO1xufTtcblxuLyoqXG4gKiBLaWxsaW5nIGEgdmlzdWFsaXphdGlvbiBub2RlIHJlbW92ZXMgaXRzIElEIHNvIHRoYXQgaXQgd29uJ3QgY29uZmxpY3Qgd2l0aFxuICogYW5vdGhlciBub2RlIG9mIG1hdGNoaW5nIElEIGJlaW5nIGFkZGVkLCBhbmQgYmVnaW5zIGl0cyBleGl0IGFuaW1hdGlvbi5cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1WaXpTaW11bGF0aW9uTm9kZS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgTmV0U2ltVml6U2ltdWxhdGlvbk5vZGUuc3VwZXJQcm90b3R5cGUua2lsbC5jYWxsKHRoaXMpO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdOb2RlSWRfID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvcnJlc3BvbmRpbmdOb2RlVXVpZF8gPSB1bmRlZmluZWQ7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgVmlzdWFsaXphdGlvbiBhdXRvLWRucyBub2RlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG52YXIgTmV0U2ltVml6Tm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltVml6Tm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQmFja2dyb3VuZEFuaW1hdGlvbiAtIGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIHRoaXMgbm9kZVxuICogICAgICAgIHdoZW4gaXQncyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgTmV0U2ltVml6Tm9kZVxuICovXG52YXIgTmV0U2ltVml6QXV0b0Ruc05vZGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uKSB7XG4gIE5ldFNpbVZpek5vZGUuY2FsbCh0aGlzLCB1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uKTtcblxuICB0aGlzLmdldFJvb3QoKS5hZGRDbGFzcygnYXV0by1kbnMtbm9kZScpO1xuXG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgaWYgKGxldmVsQ29uZmlnLnNob3dIb3N0bmFtZUluR3JhcGgpIHtcbiAgICB0aGlzLnNldE5hbWUoJ2RucycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2V0TmFtZSgnRE5TJyk7XG4gIH1cblxuICB0aGlzLnNldElzRG5zTm9kZSh0cnVlKTtcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5OZXRTaW1WaXpBdXRvRG5zTm9kZS5pbmhlcml0cyhOZXRTaW1WaXpOb2RlKTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IE5vZGVzIGluIHRoZSB2aXN1YWxpemF0aW9uLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIGpRdWVyeVN2Z0VsZW1lbnQgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJykualF1ZXJ5U3ZnRWxlbWVudDtcbnZhciBOZXRTaW1WaXpFbGVtZW50ID0gcmVxdWlyZSgnLi9OZXRTaW1WaXpFbGVtZW50Jyk7XG52YXIgdHdlZW5zID0gcmVxdWlyZSgnLi90d2VlbnMnKTtcblxudmFyIERuc01vZGUgPSBOZXRTaW1Db25zdGFudHMuRG5zTW9kZTtcblxudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcblxuLyoqXG4gKiBUaGUgbmFycm93ZXN0IHRoYXQgYSB0ZXh0IGJ1YmJsZSBpcyBhbGxvd2VkIHRvIGJlLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgVEVYVF9NSU5fV0lEVEggPSAzMDtcblxuLyoqXG4gKiBXaWR0aCB0byBhZGQgdG8gdGhlIGJ1YmJsZSBiZXlvbmQgdGhlIHdpZHRoIG9mIHRoZSBzdHVkZW50J3MgbmFtZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIFRFWFRfUEFERElOR19YID0gMjA7XG5cbi8qKlxuICogSGVpZ2h0IHRvIGFkZCB0byB0aGUgYnViYmxlIGJleW9uZCB0aGUgaGVpZ2h0IG9mIHRoZSBzdHVkZW50J3MgbmFtZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIFRFWFRfUEFERElOR19ZID0gMTA7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uIC0gY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgdGhpcyBub2RlXG4gKiAgICAgICAgd2hlbiBpdCdzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgTmV0U2ltVml6RWxlbWVudFxuICovXG52YXIgTmV0U2ltVml6Tm9kZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZUJhY2tncm91bmRBbmltYXRpb24pIHtcbiAgTmV0U2ltVml6RWxlbWVudC5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5hZGRyZXNzXyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQHByaXZhdGUge0Ruc01vZGV9XG4gICAqL1xuICB0aGlzLmRuc01vZGVfID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0YXJ0IG9yIHVwZGF0ZSBhbnkgdHdlZW5zIHdoaWxlIHRoZSBub2RlIGlzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAqIGxheWVyLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMudXNlQmFja2dyb3VuZEFuaW1hdGlvbl8gPSB1c2VCYWNrZ3JvdW5kQW5pbWF0aW9uO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNSb3V0ZXIgPSBmYWxzZTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzTG9jYWxOb2RlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0Ruc05vZGUgPSBmYWxzZTtcblxuICAvLyBHaXZlIG91ciByb290IG5vZGUgYSB1c2VmdWwgY2xhc3NcbiAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcbiAgcm9vdC5hZGRDbGFzcygndml6LW5vZGUnKTtcblxuICAvLyBHb2luZyBmb3IgYSBkaWFtZXRlciBvZiBfY2xvc2VfIHRvIDc1XG4gIHZhciByYWRpdXMgPSAzNztcbiAgdmFyIHRleHRWZXJ0aWNhbE9mZnNldCA9IDQ7XG5cbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqUXVlcnlTdmdFbGVtZW50KCdjaXJjbGUnKVxuICAgICAgLmF0dHIoJ2N4JywgMClcbiAgICAgIC5hdHRyKCdjeScsIDApXG4gICAgICAuYXR0cigncicsIHJhZGl1cylcbiAgICAgIC5hcHBlbmRUbyhyb290KTtcblxuICB0aGlzLm5hbWVHcm91cF8gPSBqUXVlcnlTdmdFbGVtZW50KCdnJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgLmFwcGVuZFRvKHJvb3QpO1xuXG4gIHRoaXMuZGlzcGxheU5hbWVfID0galF1ZXJ5U3ZnRWxlbWVudCgndGV4dCcpXG4gICAgICAuYXR0cigneCcsIDApXG4gICAgICAuYXR0cigneScsIHRleHRWZXJ0aWNhbE9mZnNldCk7XG5cbiAgdGhpcy5uYW1lQm94XyA9IGpRdWVyeVN2Z0VsZW1lbnQoJ3JlY3QnKVxuICAgICAgLmFkZENsYXNzKCduYW1lLWJveCcpO1xuXG4gIHRoaXMubmFtZUdyb3VwX1xuICAgICAgLmFwcGVuZCh0aGlzLm5hbWVCb3hfKVxuICAgICAgLmFwcGVuZCh0aGlzLmRpc3BsYXlOYW1lXyk7XG5cbiAgdGhpcy5hZGRyZXNzR3JvdXBfID0galF1ZXJ5U3ZnRWxlbWVudCgnZycpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDMwKScpXG4gICAgICAuaGlkZSgpXG4gICAgICAuYXBwZW5kVG8ocm9vdCk7XG5cbiAgdGhpcy5hZGRyZXNzQm94XyA9IGpRdWVyeVN2Z0VsZW1lbnQoJ3JlY3QnKVxuICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWJveCcpXG4gICAgICAuYXBwZW5kVG8odGhpcy5hZGRyZXNzR3JvdXBfKTtcblxuICB0aGlzLmFkZHJlc3NUZXh0XyA9IGpRdWVyeVN2Z0VsZW1lbnQoJ3RleHQnKVxuICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWJveCcpXG4gICAgICAuYXR0cigneCcsIDApXG4gICAgICAuYXR0cigneScsIHRleHRWZXJ0aWNhbE9mZnNldClcbiAgICAgIC50ZXh0KCc/JylcbiAgICAgIC5hcHBlbmRUbyh0aGlzLmFkZHJlc3NHcm91cF8pO1xuXG4gIC8vIFNldCBhbiBpbml0aWFsIGRlZmF1bHQgdHdlZW4gZm9yIHpvb21pbmcgaW4gZnJvbSBub3RoaW5nLlxuICBpZiAodGhpcy51c2VCYWNrZ3JvdW5kQW5pbWF0aW9uXykge1xuICAgIHRoaXMuc25hcFRvU2NhbGUoMCk7XG4gICAgdGhpcy50d2VlblRvU2NhbGUoMC41LCA4MDAsIHR3ZWVucy5lYXNlT3V0RWxhc3RpYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zbmFwVG9TY2FsZSgwLjUpO1xuICB9XG59O1xuTmV0U2ltVml6Tm9kZS5pbmhlcml0cyhOZXRTaW1WaXpFbGVtZW50KTtcblxuLyoqXG4gKiBGbGFnIHRoaXMgdml6IG5vZGUgYXMgdGhlIHNpbXVsYXRpb24gbG9jYWwgbm9kZS5cbiAqL1xuTmV0U2ltVml6Tm9kZS5wcm90b3R5cGUuc2V0SXNMb2NhbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMb2NhbE5vZGUgPSB0cnVlO1xuICB0aGlzLmdldFJvb3QoKS5hZGRDbGFzcygnbG9jYWwtbm9kZScpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgdml6IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lXG4gKi9cbk5ldFNpbVZpek5vZGUucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiAobmV3TmFtZSkge1xuICB0aGlzLmRpc3BsYXlOYW1lXy50ZXh0KG5ld05hbWUpO1xuICB0aGlzLnJlc2l6ZU5hbWVCb3hfKCk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbk5ldFNpbVZpek5vZGUucHJvdG90eXBlLnJlc2l6ZU5hbWVCb3hfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc2l6ZVJlY3RUb1RleHRfKHRoaXMubmFtZUJveF8sIHRoaXMuZGlzcGxheU5hbWVfKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuTmV0U2ltVml6Tm9kZS5wcm90b3R5cGUucmVzaXplQWRkcmVzc0JveF8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzaXplUmVjdFRvVGV4dF8odGhpcy5hZGRyZXNzQm94XywgdGhpcy5hZGRyZXNzVGV4dF8pO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZvciByZXNpemluZyBhIGJhY2tncm91bmQgcm91bmRlZC1yZWN0IHRvIGZpdCB0aGUgZ2l2ZW4gdGV4dCBlbGVtZW50LlxuICogQHBhcmFtIHtqUXVlcnl9IHJlY3RcbiAqIEBwYXJhbSB7alF1ZXJ5fSB0ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1WaXpOb2RlLnByb3RvdHlwZS5yZXNpemVSZWN0VG9UZXh0XyA9IGZ1bmN0aW9uIChyZWN0LCB0ZXh0KSB7XG4gIHRyeSB7XG4gICAgdmFyIGJveCA9IHRleHRbMF0uZ2V0QkJveCgpO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KFRFWFRfTUlOX1dJRFRILCBib3gud2lkdGggKyBURVhUX1BBRERJTkdfWCk7XG4gICAgdmFyIGhlaWdodCA9IGJveC5oZWlnaHQgKyBURVhUX1BBRERJTkdfWTtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICByZWN0LmF0dHIoJ3gnLCAtaGFsZldpZHRoKVxuICAgICAgICAuYXR0cigneScsIC1oYWxmSGVpZ2h0KVxuICAgICAgICAuYXR0cigncngnLCBoYWxmSGVpZ2h0KVxuICAgICAgICAuYXR0cigncnknLCBoYWxmSGVpZ2h0KVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBKdXN0IGFsbG93IHRoaXMgdG8gYmUgYSBuby1vcCBpZiBpdCBmYWlscy4gIEluIHNvbWUgYnJvd3NlcnMsXG4gICAgLy8gZ2V0QkJveCB3aWxsIHRocm93IGlmIHRoZSBlbGVtZW50IGlzIG5vdCB5ZXQgaW4gdGhlIERPTS5cbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsaW5nIGEgdmlzdWFsaXphdGlvbiBub2RlIHJlbW92ZXMgaXRzIElEIHNvIHRoYXQgaXQgd29uJ3QgY29uZmxpY3Qgd2l0aFxuICogYW5vdGhlciBub2RlIG9mIG1hdGNoaW5nIElEIGJlaW5nIGFkZGVkLCBhbmQgYmVnaW5zIGl0cyBleGl0IGFuaW1hdGlvbi5cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1WaXpOb2RlLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICBOZXRTaW1WaXpOb2RlLnN1cGVyUHJvdG90eXBlLmtpbGwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9wQWxsQW5pbWF0aW9uKCk7XG4gIHRoaXMudHdlZW5Ub1NjYWxlKDAsIDIwMCwgdHdlZW5zLmVhc2VJblF1YWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkcmlmdGluZyBhbmltYXRpb24gZm9yIG5vZGVzIGluIHRoZSBiYWNrZ3JvdW5kLlxuICogQHBhcmFtIHtSdW5Mb29wLkNsb2NrfSBjbG9ja1xuICovXG5OZXRTaW1WaXpOb2RlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIE5ldFNpbVZpek5vZGUuc3VwZXJQcm90b3R5cGUudGljay5jYWxsKHRoaXMsIGNsb2NrKTtcblxuICAvLyBUcmlnZ2VyIGEgbmV3IGRyaWZ0IGlmIHdlJ3JlIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCB0aGUgbGFzdCBvbmUgZmluaXNoZWQuXG4gIGlmICh0aGlzLnVzZUJhY2tncm91bmRBbmltYXRpb25fICYmICF0aGlzLmlzRm9yZWdyb3VuZCAmJlxuICAgICAgdGhpcy50d2VlbnNfLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciByYW5kb21YID0gMzAwICogTWF0aC5yYW5kb20oKSAtIDE1MDtcbiAgICB2YXIgcmFuZG9tWSA9IDMwMCAqIE1hdGgucmFuZG9tKCkgLSAxNTA7XG4gICAgdGhpcy50d2VlblRvUG9zaXRpb24ocmFuZG9tWCwgcmFuZG9tWSwgMjAwMDAsIHR3ZWVucy5lYXNlSW5PdXRRdWFkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGVuIHZpc2libGUsIHJ1bnMgZXZlcnkgZnJhbWVcbiAqIEBwYXJhbSB7UnVuTG9vcC5DbG9ja30gW2Nsb2NrXVxuICovXG5OZXRTaW1WaXpOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgTmV0U2ltVml6Tm9kZS5zdXBlclByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBjbG9jayk7XG5cbiAgLy8gSWYgY3VycmVudGx5IGFuaW1hdGluZywgYWRqdXN0IHRleHQgYm94IHNpemVzIHRvIG1hdGNoXG4gIGlmICh0aGlzLmlzRm9yZWdyb3VuZCAmJiB0aGlzLnR3ZWVuc18ubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucmVzaXplTmFtZUJveF8oKTtcbiAgICB0aGlzLnJlc2l6ZUFkZHJlc3NCb3hfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZvcmVncm91bmRcbiAqL1xuTmV0U2ltVml6Tm9kZS5wcm90b3R5cGUub25EZXB0aENoYW5nZSA9IGZ1bmN0aW9uIChpc0ZvcmVncm91bmQpIHtcbiAgTmV0U2ltVml6Tm9kZS5zdXBlclByb3RvdHlwZS5vbkRlcHRoQ2hhbmdlLmNhbGwodGhpcywgaXNGb3JlZ3JvdW5kKTtcblxuICAvLyBEb24ndCBhZGQgdHdlZW5zIGlmIHRoaXMgbm9kZSBoYXMgYmVlbiBraWxsZWRcbiAgaWYgKHRoaXMuaXNEeWluZygpIHx8IHRoaXMuaXNEZWFkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnR3ZWVuc18ubGVuZ3RoID0gMDtcbiAgaWYgKGlzRm9yZWdyb3VuZCkge1xuICAgIHRoaXMudHdlZW5Ub1NjYWxlKDEsIDYwMCwgdHdlZW5zLmVhc2VPdXRFbGFzdGljKTtcbiAgfSBlbHNlIGlmICh0aGlzLnVzZUJhY2tncm91bmRBbmltYXRpb25fKSB7XG4gICAgdGhpcy50d2VlblRvU2NhbGUoMC41LCA2MDAsIHR3ZWVucy5lYXNlT3V0RWxhc3RpYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zbmFwVG9TY2FsZSgwLjUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gKi9cbk5ldFNpbVZpek5vZGUucHJvdG90eXBlLnNldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB0aGlzLmFkZHJlc3NfID0gYWRkcmVzcztcbiAgdGhpcy51cGRhdGVBZGRyZXNzRGlzcGxheSgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0ROU01vZGV9IG5ld0Ruc01vZGVcbiAqL1xuTmV0U2ltVml6Tm9kZS5wcm90b3R5cGUuc2V0RG5zTW9kZSA9IGZ1bmN0aW9uIChuZXdEbnNNb2RlKSB7XG4gIHRoaXMuZG5zTW9kZV8gPSBuZXdEbnNNb2RlO1xuICB0aGlzLnVwZGF0ZUFkZHJlc3NEaXNwbGF5KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEbnNOb2RlXG4gKi9cbk5ldFNpbVZpek5vZGUucHJvdG90eXBlLnNldElzRG5zTm9kZSA9IGZ1bmN0aW9uIChpc0Ruc05vZGUpIHtcbiAgdGhpcy5pc0Ruc05vZGUgPSBpc0Ruc05vZGU7XG4gIHRoaXMudXBkYXRlQWRkcmVzc0Rpc3BsYXkoKTtcbn07XG5cbk5ldFNpbVZpek5vZGUucHJvdG90eXBlLnVwZGF0ZUFkZHJlc3NEaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV2ZWxDb25maWcgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG5cbiAgLy8gSWYgd2UgYXJlIG5ldmVyIGFzc2lnbmVkIGFuIGFkZHJlc3MsIGRvbid0IHRyeSB0byBzaG93IG9uZS5cbiAgLy8gSW4gYnJvYWRjYXN0IG1vZGUgd2Ugd2lsbCBiZSBhc3NpZ25lZCBhZGRyZXNzZXMgYnV0IG5ldmVyIHVzZSB0aGVtLCBzb1xuICAvLyAgIHRoZXkgc2hvdWxkIGJlIGhpZGRlbi5cbiAgLy8gUm91dGVycyBuZXZlciBzaG93IHRoZWlyIGFkZHJlc3MuXG4gIGlmICh0aGlzLmFkZHJlc3NfID09PSB1bmRlZmluZWQgfHwgbGV2ZWxDb25maWcuYnJvYWRjYXN0TW9kZSB8fCB0aGlzLmlzUm91dGVyKSB7XG4gICAgdGhpcy5hZGRyZXNzR3JvdXBfLmhpZGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmFkZHJlc3NHcm91cF8uc2hvdygpO1xuICBpZiAodGhpcy5kbnNNb2RlXyA9PT0gRG5zTW9kZS5OT05FKSB7XG4gICAgdGhpcy5hZGRyZXNzVGV4dF8udGV4dCh0aGlzLmFkZHJlc3NfICE9PSB1bmRlZmluZWQgPyB0aGlzLmFkZHJlc3NfIDogJz8nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZHJlc3NUZXh0Xy50ZXh0KHRoaXMuaXNMb2NhbE5vZGUgfHwgdGhpcy5pc0Ruc05vZGUgPyB0aGlzLmFkZHJlc3NfIDogJz8nKTtcbiAgfVxuICB0aGlzLnJlc2l6ZUFkZHJlc3NCb3hfKCk7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgQmFzZSB0eXBlIGZvciB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSB2aXN1YWxpemF0aW9uLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGpRdWVyeVN2Z0VsZW1lbnQgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJykualF1ZXJ5U3ZnRWxlbWVudDtcbnZhciB0d2VlbnMgPSByZXF1aXJlKCcuL3R3ZWVucycpO1xuXG4vKipcbiAqIEEgVml6RWxlbWVudCBpcyBhbiBvYmplY3QgdGhhdCAgaGFzIGEgcmVwcmVzZW50YXRpb24gaW4gdGhlIG5ldHdvcmtcbiAqIHZpc3VhbGl6YXRpb24uICBJdHMgcm9sZSBpcyB0byBtYWludGFpbiB0aGF0IHZpc3VhbCByZXByZXNlbnRhdGlvbi5cbiAqIEEgVml6RWxlbWVudCBoYXMgaGVscGVycyBmb3IgcG9zaXRpb25pbmcsIHNjYWxpbmcgYW5kIHR3ZWVuaW5nLlxuICogRXZlcnkgVml6RWxlbWVudCBoYXMgYSByb290IGVsZW1lbnQgd2hpY2ggaXMgYSA8Zz4gdGFnLCBhbiBTVkcgXCJncm91cFwiXG4gKiB0aGF0IGNvbnRhaW5zIHRoZSBvdGhlciBjb21wb25lbnRzIHRoYXQgd2lsbCBhY3R1YWxseSBkcmF3LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltVml6RWxlbWVudCA9IG1vZHVsZS5leHBvcnRzID0gIGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnBvc1ggPSAwO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5wb3NZID0gMDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuc2NhbGUgPSAxO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNGb3JlZ3JvdW5kID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFJvb3QgU1ZHIDxnPiAoZ3JvdXApIGVsZW1lbnQgZm9yIHRoaXMgb2JqZWN0LlxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290R3JvdXBfID0galF1ZXJ5U3ZnRWxlbWVudCgnZycpO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgdHdlZW5zIHdlIHNob3VsZCBjdXJyZW50bHkgYmUgcnVubmluZyBvbiB0aGlzIG5vZGUuXG4gICAqIFByb2Nlc3NlZCBieSB0aWNrKClcbiAgICogQHR5cGUge0FycmF5LjxleHBvcnRzLlR3ZWVuVmFsdWVUbz59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnR3ZWVuc18gPSBbXTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzRGVhZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2pRdWVyeX0gd3JhcHBlciBhcm91bmQgcm9vdCA8Zz4gZWxlbWVudFxuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb290R3JvdXBfO1xufTtcblxuLyoqXG4gKiBCZWdpbnMgdGhlIHByb2Nlc3Mgb2YgZGVzdHJveWluZyB0aGlzIFZpekVsZW1lbnQuICBPbmNlIHN0YXJ0ZWQsIHRoaXNcbiAqIHByb2Nlc3MgY2Fubm90IGJlIHN0b3BwZWQuXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byB0cmlnZ2VyIGFuIFwib24tZGVhdGhcIiBhbmltYXRpb24uXG4gKi9cbk5ldFNpbVZpekVsZW1lbnQucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNEZWFkXyA9IHRydWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoaXMgZW50aXR5IGlzIGRvbmUgd2l0aCBpdHMgZGVhdGggYW5pbWF0aW9uXG4gKiAgICAgICAgICBhbmQgaXMgcmVhZHkgdG8gYmUgY2xlYW5lZCB1cCBieSB0aGUgdmlzdWFsaXphdGlvbiBtYW5hZ2VyLlxuICogICAgICAgICAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSByZXR1cm5zIFRSVUUgYXMgc29vbiBhcyBraWxsKClcbiAqICAgICAgICAgIGlzIGNhbGxlZCBhbmQgYWxsIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlZC5cbiAqL1xuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUuaXNEZWFkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0RlYWRfICYmIHRoaXMudHdlZW5zXy5sZW5ndGggPT09IDA7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoaXMgZW50aXR5IGlzIHBsYXlpbmcgaXRzIGZpbmFsIGFuaW1hdGlvblxuICogICAgICAgICAgYW5kIHdpbGwgYmUgcmVhZHkgdG8gYmUgY2xlYW5lZCB1cCBieSB0aGUgdmlzdWFsaXphdGlvbiBtYW5hZ2VyXG4gKiAgICAgICAgICBzb29uLlxuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS5pc0R5aW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0RlYWRfICYmIHRoaXMudHdlZW5zXy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYWxsIG9mIHRoZSB0d2VlbnMgY3VycmVudGx5IHJ1bm5pbmcgb24gdGhpcyBWaXpFbGVtZW50ICh3aGljaCB3aWxsXG4gKiBwcm9iYWJseSBtb2RpZnkgaXRzIHByb3BlcnRpZXMpIGFuZCB0aGVuIHJlbW92ZSBhbnkgdHdlZW5zIHRoYXQgYXJlIGNvbXBsZXRlZFxuICogZnJvbSB0aGUgbGlzdC5cbiAqL1xuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSByb290IGdyb3VwJ3MgcHJvcGVydGllcyB0byByZWZsZWN0IG91ciBjdXJyZW50IHBvc2l0aW9uXG4gKiBhbmQgc2NhbGUuXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IFtjbG9ja10gLSBzb21ldGltZXMgb21pdHRlZCBkdXJpbmcgc2V0dXBcbiAqL1xuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIGlmICghY2xvY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjYWNoZSBpbml0aWFsIHNldHRpbmdzIGhlcmU7IHdlIGNoZWNrIHRoZW0gbGF0ZXIgdG8gc2VlIGlmIGFueXRoaW5nXG4gIC8vIGhhcyBhY3R1YWxseSBjaGFuZ2VkXG4gIHZhciBwb3NYID0gdGhpcy5wb3NYO1xuICB2YXIgcG9zWSA9IHRoaXMucG9zWTtcbiAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAvLyBVcGRhdGUgdHdlZW5zIGluIHRoZSByZW5kZXIgbG9vcCBzbyB0aGV5IGFyZSB2ZXJ5IHNtb290aFxuICB0aGlzLnR3ZWVuc18uZm9yRWFjaChmdW5jdGlvbiAodHdlZW4pIHtcbiAgICB0d2Vlbi50aWNrKGNsb2NrKTtcbiAgfSk7XG4gIHRoaXMudHdlZW5zXyA9IHRoaXMudHdlZW5zXy5maWx0ZXIoZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgcmV0dXJuICF0d2Vlbi5pc0ZpbmlzaGVkO1xuICB9KTtcblxuICAvLyBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBkb24ndCBib3RoZXIgdG8gdXBkYXRlIHRyYW5zZm9ybVxuICBpZiAocG9zWCAhPT0gdGhpcy5wb3NYIHx8XG4gICAgICBwb3NZICE9PSB0aGlzLnBvc1kgfHxcbiAgICAgIHNjYWxlICE9PSB0aGlzLnNjYWxlKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMucG9zWCArICcgJyArIHRoaXMucG9zWSArICcpJyArXG4gICAgICAgICcgc2NhbGUoJyArIHRoaXMuc2NhbGUgKyAnKSc7XG4gICAgdGhpcy5yb290R3JvdXBfLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZvcmVncm91bmRcbiAqL1xuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUub25EZXB0aENoYW5nZSA9IGZ1bmN0aW9uIChpc0ZvcmVncm91bmQpIHtcbiAgdGhpcy5pc0ZvcmVncm91bmQgPSBpc0ZvcmVncm91bmQ7XG59O1xuXG4vKipcbiAqIFRocm93IGF3YXkgYWxsIGV4aXN0aW5nIHR3ZWVucyBvbiB0aGlzIG9iamVjdC5cbiAqL1xuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUuc3RvcEFsbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50d2VlbnNfLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN0b3BzIGFueSBleGlzdGluZyBtb3Rpb24gYW5pbWF0aW9uIGFuZCBiZWdpbnMgYW4gYW5pbWF0ZWQgbW90aW9uIHRvIHRoZVxuICogZ2l2ZW4gY29vcmRpbmF0ZXMuICBOb3RlOiBUaGlzIGFuaW1hdGVzIHRoZSBWaXpFbGVtZW50J3Mgcm9vdCBncm91cC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdYIGdpdmVuIGluIFNWRyBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdZIGdpdmVuIGluIFNWRyBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NjAwXSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7VHdlZW5GdW5jdGlvbn0gW3R3ZWVuRnVuY3Rpb249bGluZWFyXVxuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS50d2VlblRvUG9zaXRpb24gPSBmdW5jdGlvbiAobmV3WCwgbmV3WSwgZHVyYXRpb24sXG4gICAgdHdlZW5GdW5jdGlvbikge1xuICAvLyBEb24ndCBhY2NlcHQgbmV3IGFuaW1hdGlvbiBjb21tYW5kcyBpZiB3ZSd2ZSBhbHJlYWR5IGJlZW4ga2lsbGVkXG4gIGlmICh0aGlzLmlzRHlpbmcoKSB8fCB0aGlzLmlzRGVhZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyB0d2VlbnMgY29udHJvbGxpbmcgcG9zWCBvciBwb3NZXG4gIHRoaXMucmVtb3ZlQWxsVHdlZW5zT25Qcm9wZXJ0aWVzKFsncG9zWCcsICdwb3NZJ10pO1xuXG4gIC8vIEFkZCB0d28gbmV3IHR3ZWVucywgb25lIGZvciBlYWNoIGF4aXNcbiAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgIHRoaXMudHdlZW5zXy5wdXNoKG5ldyB0d2VlbnMuVHdlZW5WYWx1ZVRvKHRoaXMsICdwb3NYJywgbmV3WCwgZHVyYXRpb24sXG4gICAgICAgIHR3ZWVuRnVuY3Rpb24pKTtcbiAgICB0aGlzLnR3ZWVuc18ucHVzaChuZXcgdHdlZW5zLlR3ZWVuVmFsdWVUbyh0aGlzLCAncG9zWScsIG5ld1ksIGR1cmF0aW9uLFxuICAgICAgICB0d2VlbkZ1bmN0aW9uKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wb3NYID0gbmV3WDtcbiAgICB0aGlzLnBvc1kgPSBuZXdZO1xuICB9XG5cbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIGNhbGxpbmcgdHdlZW5Ub1Bvc2l0aW9uIHdpdGggYSB6ZXJvIGR1cmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3WCBnaXZlbiBpbiBTVkcgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3WSBnaXZlbiBpbiBTVkcgcG9pbnRzXG4gKi9cbk5ldFNpbVZpekVsZW1lbnQucHJvdG90eXBlLnNuYXBUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKG5ld1gsIG5ld1kpIHtcbiAgdGhpcy50d2VlblRvUG9zaXRpb24obmV3WCwgbmV3WSwgMCk7XG59O1xuXG4vKipcbiAqIFN0b3BzIGFueSBleGlzdGluZyBhbmltYXRpb24gb2YgdGhlIGVudGl0eSdzIHNjYWxlIGFuZCBiZWdpbnMgYW4gYW5pbWF0ZWRcbiAqIGNoYW5nZSB0byB0aGUgZ2l2ZW4gdGFyZ2V0IHNjYWxlIHZhbHVlLiAgTm90ZTogdGhpcyBhbmltYXRlcyB0aGUgVml6RWxlbWVudCdzXG4gKiByb290IGdyb3VwLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld1NjYWxlIHdoZXJlIDEuMCBpcyAxMDAlICh1bnNjYWxlZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NjAwXSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7VHdlZW5GdW5jdGlvbn0gW3R3ZWVuRnVuY3Rpb249bGluZWFyXVxuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS50d2VlblRvU2NhbGUgPSBmdW5jdGlvbiAobmV3U2NhbGUsIGR1cmF0aW9uLFxuICAgIHR3ZWVuRnVuY3Rpb24pIHtcbiAgLy8gUmVtb3ZlIGV4aXN0aW5nIHNjYWxlIHR3ZWVuc1xuICB0aGlzLnJlbW92ZUFsbFR3ZWVuc09uUHJvcGVydHkoJ3NjYWxlJyk7XG5cbiAgLy8gT24gbm9uemVybyBkdXJhdGlvbiwgYWRkIHR3ZWVuIHRvIHRhcmdldCBzY2FsZS4gIE90aGVyd2lzZSBqdXN0IHNldCBpdC5cbiAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgIHRoaXMudHdlZW5zXy5wdXNoKG5ldyB0d2VlbnMuVHdlZW5WYWx1ZVRvKHRoaXMsICdzY2FsZScsIG5ld1NjYWxlLCBkdXJhdGlvbixcbiAgICAgICAgdHdlZW5GdW5jdGlvbikpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2NhbGUgPSBuZXdTY2FsZTtcbiAgfVxufTtcblxuTmV0U2ltVml6RWxlbWVudC5wcm90b3R5cGUuZG9BZnRlckRlbGF5ID0gZnVuY3Rpb24gKGRlbGF5LCBjYWxsYmFjaykge1xuICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgdGhpcy50d2VlbnNfLnB1c2gobmV3IHR3ZWVucy5Eb0FmdGVyRGVsYXkodGhpcywgZGVsYXksIGNhbGxiYWNrKSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgKHN0b3ApIGFsbCBhY3RpdmUgdHdlZW5zIHRoYXQgY29udHJvbCB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhpc1xuICogdmlzdWFsaXphdGlvbiBlbnRpdHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gKi9cbk5ldFNpbVZpekVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUFsbFR3ZWVuc09uUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gIHRoaXMucmVtb3ZlQWxsVHdlZW5zT25Qcm9wZXJ0aWVzKFtwcm9wZXJ0eU5hbWVdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIChzdG9wKSBhbGwgYWN0aXZlIHR3ZWVucyB0aGF0IGNvbnRyb2wgYW55IG9mIHRoZSBnaXZlbiBwcm9wZXJ0aWVzXG4gKiBvbiB0aGlzIHZpc3VhbGl6YXRpb24gZW50aXR5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcGVydHlOYW1lc1xuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBbGxUd2VlbnNPblByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lcykge1xuICB0aGlzLnR3ZWVuc18gPSB0aGlzLnR3ZWVuc18uZmlsdGVyKGZ1bmN0aW9uICh0d2Vlbikge1xuICAgIHZhciB0YXJnZXRzVGhpc0VudGl0eSA9IHR3ZWVuLnRhcmdldCA9PT0gdGhpcztcbiAgICB2YXIgaXNSZW1vdmFibGVQcm9wZXJ0eSA9IHByb3BlcnR5TmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHR3ZWVuLnByb3BlcnR5TmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcblxuICAgIC8vIEludmVydCBmb3IgZmlsdGVyKCkgYmVjYXVzZSB3ZSB3YW50IHRvIGtlZXAgZXZlcnl0aGluZyBCVVQgdGhlIG1hdGNoZWRcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuICEodGFyZ2V0c1RoaXNFbnRpdHkgJiYgaXNSZW1vdmFibGVQcm9wZXJ0eSk7XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgY2FsbGluZyB0d2VlblRvU2NhbGUgd2l0aCBhIHplcm8gZHVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3U2NhbGUgd2hlcmUgMS4wIGlzIDEwMCUgKHVuc2NhbGVkKVxuICovXG5OZXRTaW1WaXpFbGVtZW50LnByb3RvdHlwZS5zbmFwVG9TY2FsZSA9IGZ1bmN0aW9uIChuZXdTY2FsZSkge1xuICB0aGlzLnR3ZWVuVG9TY2FsZShuZXdTY2FsZSwgMCk7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgVHdlZW4gZnVuY3Rpb25zIHVzZWQgdG8gYW5pbWF0ZSB2aXN1YWxpemF0aW9uIGVsZW1lbnRzLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbHVlT3IgPSByZXF1aXJlKCcuLi91dGlscycpLnZhbHVlT3I7XG5cbi8qKlxuICogRGVmYXVsdCB0d2VlbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIERFRkFVTFRfVFdFRU5fRFVSQVRJT04gPSA2MDA7XG5cbi8qKlxuICogQSBmb3VyLWFyZyBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gVHdlZW5GdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHQgLSBjdXJyZW50IFRpbWUsIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0d2VlbiBiZWdhblxuICogQHBhcmFtIHtudW1iZXJ9IGIgLSBCZWdpbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMgLSBmaW5hbCBDaGFuZ2UgaW4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkIC0gdG90YWwgdHdlZW4gRHVyYXRpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHRpbWVcbiAqL1xuXG4vKipcbiAqIEludGVycG9sYXRlcyB3aXRoIGEgbGl0dGxlIGJhY2stYW5kLWZvcnRoIG92ZXIgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZW5kLlxuICogQHR5cGUge1R3ZWVuRnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuZWFzZU91dEVsYXN0aWMgPSBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICB2YXIgcywgcCwgYTtcbiAgcz0xLjcwMTU4O1xuICBwPTA7XG4gIGE9YztcbiAgaWYgKHQ9PT0wKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKCh0Lz1kKT09PTEpIHtcbiAgICByZXR1cm4gYitjO1xuICB9XG4gIGlmICghcCkge1xuICAgIHA9ZCowLjM7XG4gIH1cbiAgaWYgKGEgPCBNYXRoLmFicyhjKSkge1xuICAgIGE9YztcbiAgICBzPXAvNDtcbiAgfSBlbHNlIHtcbiAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbiAoYy9hKTtcbiAgfVxuICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCp0KSAqIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSArIGMgKyBiO1xufTtcblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMsIGFjY2VsZXJhdGluZyBhcyBpdCBnb2VzLlxuICogQHR5cGUge1R3ZWVuRnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuZWFzZUluUXVhZCA9IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG4gIHJldHVybiBjKih0Lz1kKSp0ICsgYjtcbn07XG5cbi8qKlxuICogSW50ZXJwb2xhdGVzLCBkZWNlbGVyYXRpbmcgYXMgaXQgZ29lcy5cbiAqIEB0eXBlIHtUd2VlbkZ1bmN0aW9ufVxuICovXG5leHBvcnRzLmVhc2VPdXRRdWFkID0gZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIC1jKih0Lz1kKSoodC0yKSArIGI7XG59O1xuXG5leHBvcnRzLmVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICBpZiAoKHQvPWQvMikgPCAxKSB7XG4gICAgcmV0dXJuIGMvMip0KnQgKyBiO1xuICB9XG4gIHJldHVybiAtYy8yICogKCgtLXQpKih0LTIpIC0gMSkgKyBiO1xufTtcblxuLyoqXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvblxuICogQHR5cGUge1R3ZWVuRnVuY3Rpb259XG4gKi9cbmV4cG9ydHMubGluZWFyID0gZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGMgKiAodCAvIGQpICsgYjtcbn07XG5cbi8qKlxuICogV3JhcHMgYSB0d2VlbiBtZXRob2Qgd2l0aCB0aGUgc3RhdGUgaXQgbmVlZHMgdG8gYW5pbWF0ZSBhIHByb3BlcnR5LlxuICogT24gY3JlYXRpb24sIGFzc3VtZXMgdGhhdCBwcm9wZXJ0eSdzIGN1cnJlbnQgdmFsdWUgZm9yIHN0YXJ0IHZhbHVlcy5cbiAqIE11c3QgYmUgdGlja2VkIHRvIHByb2dyZXNzIHRvd2FyZCBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCBvd25pbmcgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gYW5pbWF0ZVxuICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBNdXN0IGJlIGEgdmFsaWQgcHJvcGVydHkgb24gdGFyZ2V0XG4gKiBAcGFyYW0geyFudW1iZXJ9IGVuZFZhbHVlIC0gVGhlIGRlc2lyZWQgZmluYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSAtIEhvdyBsb25nIHRoZSB0d2VlbiBzaG91bGQgdGFrZSBpbiBtaWxsaXNlY29uZHMsXG4gKiAgICAgICAgZGVmYXVsdCA2MDBtc1xuICogQHBhcmFtIHtUd2VlbkZ1bmN0aW9ufSBbdHdlZW5GdW5jdGlvbl0gLSBBIHR3ZWVuIGZ1bmN0aW9uLCBkZWZhdWx0IGxpbmVhclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuVHdlZW5WYWx1ZVRvID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlOYW1lLCBlbmRWYWx1ZSwgZHVyYXRpb24sXG4gICAgdHdlZW5GdW5jdGlvbikge1xuICAvKipcbiAgICogV2lsbCBiZSBzZXQgdG8gVFJVRSB3aGVuIHR3ZWVuIGlzIGNvbXBsZXRlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2lsbCBiZSBzZXQgb24gb3VyIGZpcnN0IHRpY2suXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7VHdlZW5GdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudHdlZW5GdW5jdGlvbl8gPSB2YWx1ZU9yKHR3ZWVuRnVuY3Rpb24sIGV4cG9ydHMubGluZWFyKTtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc3RhcnRWYWx1ZV8gPSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZGVsdGFWYWx1ZV8gPSBlbmRWYWx1ZSAtIHRoaXMuc3RhcnRWYWx1ZV87XG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHR3ZWVuIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kdXJhdGlvbl8gPSB2YWx1ZU9yKGR1cmF0aW9uLCBERUZBVUxUX1RXRUVOX0RVUkFUSU9OKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtSdW5Mb29wLmNsb2NrfSBjbG9ja1xuICovXG5leHBvcnRzLlR3ZWVuVmFsdWVUby5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uIChjbG9jaykge1xuICBpZiAodGhpcy5zdGFydFRpbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSBjbG9jay50aW1lO1xuICB9XG5cbiAgdmFyIHRpbWVTaW5jZVN0YXJ0ID0gY2xvY2sudGltZSAtIHRoaXMuc3RhcnRUaW1lXztcblxuICBpZiAodGhpcy5kZWx0YVZhbHVlXyAhPT0gMCkge1xuICAgIHRoaXMudGFyZ2V0W3RoaXMucHJvcGVydHlOYW1lXSA9IHRoaXMudHdlZW5GdW5jdGlvbl8oXG4gICAgICAgIHRpbWVTaW5jZVN0YXJ0LFxuICAgICAgICB0aGlzLnN0YXJ0VmFsdWVfLFxuICAgICAgICB0aGlzLmRlbHRhVmFsdWVfLFxuICAgICAgICB0aGlzLmR1cmF0aW9uX1xuICAgICk7XG4gIH1cblxuICBpZiAodGltZVNpbmNlU3RhcnQgPj0gdGhpcy5kdXJhdGlvbl8pIHtcbiAgICB0aGlzLnRhcmdldFt0aGlzLnByb3BlcnR5TmFtZV0gPSB0aGlzLnN0YXJ0VmFsdWVfICsgdGhpcy5kZWx0YVZhbHVlXztcbiAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICB9XG59O1xuXG5leHBvcnRzLkRvQWZ0ZXJEZWxheSA9IGZ1bmN0aW9uICh0YXJnZXQsIGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAvKipcbiAgICogV2lsbCBiZSBzZXQgdG8gVFJVRSB3aGVuIHR3ZWVuIGlzIGNvbXBsZXRlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcblxuXG4gIC8qKlxuICAgKiBXaWxsIGJlIHNldCBvbiBvdXIgZmlyc3QgdGljay5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc3RhcnRUaW1lXyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0d2VlbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZHVyYXRpb25fID0gZHVyYXRpb247XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZHVyYXRpb24gaGFzIGVsYXBzZWQuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UnVuTG9vcC5jbG9ja30gY2xvY2tcbiAqL1xuZXhwb3J0cy5Eb0FmdGVyRGVsYXkucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgaWYgKHRoaXMuc3RhcnRUaW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdGFydFRpbWVfID0gY2xvY2sudGltZTtcbiAgfVxuXG4gIHZhciB0aW1lU2luY2VTdGFydCA9IGNsb2NrLnRpbWUgLSB0aGlzLnN0YXJ0VGltZV87XG4gIGlmICh0aW1lU2luY2VTdGFydCA+PSB0aGlzLmR1cmF0aW9uXykge1xuICAgIHRoaXMuY2FsbGJhY2tfKCk7XG4gICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbi8qKlxuICogV2hldGhlciB0aGUgYmx1cnJlZCBiYWNrZ3JvdW5kIGxheWVyIHNob3VsZCBiZSB2aXNpYmxlLlxuICogQG5hbWUgc2hvd0JhY2tncm91bmRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG47IGJ1Zi5wdXNoKCdcXG48c3ZnIHZlcnNpb249XCIxLjFcIiB3aWR0aD1cIjI5OFwiIGhlaWdodD1cIjI5OFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cXG5cXG4gICcpOzEwOyBpZiAoc2hvd0JhY2tncm91bmQpIHsgOyBidWYucHVzaCgnXFxuICAgIDxmaWx0ZXIgaWQ9XCJiYWNrZ3JvdW5kQmx1clwiPlxcbiAgICAgIDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUdyYXBoaWNcIiBzdGREZXZpYXRpb249XCI1XCIgLz5cXG4gICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj5cXG4gICAgICAgIDxmZUZ1bmNBIHNsb3BlPVwiMC41XCIgdHlwZT1cImxpbmVhclwiPjwvZmVGdW5jQT5cXG4gICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XFxuICAgIDwvZmlsdGVyPlxcbiAgJyk7MTc7IH0gOyBidWYucHVzaCgnXFxuXFxuICA8ZyBpZD1cImNlbnRlcmVkLWdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE1MCwxNTApXCI+XFxuICAgIDxnIGlkPVwiYmFja2dyb3VuZC1ncm91cFwiXFxuICAgICAgICcpOzIxOyBpZiAoc2hvd0JhY2tncm91bmQpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgZmlsdGVyPVwidXJsKCNiYWNrZ3JvdW5kQmx1cilcIlxcbiAgICAgICAnKTsyMzsgfSBlbHNlIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgdmlzaWJpbGl0eT1cImhpZGRlblwiXFxuICAgICAgICcpOzI1OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPjwvZz5cXG5cXG4gICAgPGcgaWQ9XCJmb3JlZ3JvdW5kLWdyb3VwXCI+PC9nPlxcbiAgPC9nPlxcbjwvc3ZnPlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbnRyb2xsZXIgZm9yIHRhYnMgYXJlYSBpbiBsZWZ0IGNvbHVtblxuICogICAgICAgICAgIERpcmVjdGx5IGNvbnRyb2xzIHRoZSBpbnN0cnVjdGlvbnMgdGFiLCBvdGhlcnMgYXJlIGRlbGVnYXRlZC5cbiAqIEBzZWUgTmV0U2ltTXlEZXZpY2VUYWJcbiAqIEBzZWUgTmV0U2ltUm91dGVyVGFiXG4gKiBAc2VlIE5ldFNpbURuc1RhYlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGJ1aWxkTWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1UYWJzQ29tcG9uZW50Lmh0bWwuZWpzJyk7XG52YXIgTmV0U2ltUm91dGVyVGFiID0gcmVxdWlyZSgnLi9OZXRTaW1Sb3V0ZXJUYWInKTtcbnZhciBOZXRTaW1NeURldmljZVRhYiA9IHJlcXVpcmUoJy4vTmV0U2ltTXlEZXZpY2VUYWInKTtcbnZhciBOZXRTaW1EbnNUYWIgPSByZXF1aXJlKCcuL05ldFNpbURuc1RhYicpO1xudmFyIE5ldFNpbVRhYlR5cGUgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLk5ldFNpbVRhYlR5cGU7XG52YXIgc2hvdWxkU2hvd1RhYiA9IHJlcXVpcmUoJy4vTmV0U2ltVXRpbHMnKS5zaG91bGRTaG93VGFiO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcblxuLyoqXG4gKiBXcmFwcGVyIGNvbXBvbmVudCBmb3IgdGFicyBwYW5lbCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgcGFnZS5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge1J1bkxvb3B9IHJ1bkxvb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5jaHVua1NpemVTbGlkZXJDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLm15RGV2aWNlQml0UmF0ZUNoYW5nZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZW5jb2RpbmdDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLnJvdXRlckJhbmR3aWR0aFNsaWRlckNoYW5nZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3Mucm91dGVyQmFuZHdpZHRoU2xpZGVyU3RvcENhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3Mucm91dGVyTWVtb3J5U2xpZGVyQ2hhbmdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5yb3V0ZXJNZW1vcnlTbGlkZXJTdG9wQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5kbnNNb2RlQ2hhbmdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5iZWNvbWVEbnNDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXRTaW1UYWJzQ29tcG9uZW50ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdiwgcnVuTG9vcCwgY2FsbGJhY2tzKSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogQHR5cGUge1J1bkxvb3B9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJ1bkxvb3BfID0gcnVuTG9vcDtcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jaHVua1NpemVTbGlkZXJDaGFuZ2VDYWxsYmFja18gPSBjYWxsYmFja3MuY2h1bmtTaXplU2xpZGVyQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubXlEZXZpY2VCaXRSYXRlQ2hhbmdlQ2FsbGJhY2tfID0gY2FsbGJhY2tzLm15RGV2aWNlQml0UmF0ZUNoYW5nZUNhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVuY29kaW5nQ2hhbmdlQ2FsbGJhY2tfID0gY2FsbGJhY2tzLmVuY29kaW5nQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm91dGVyQmFuZHdpZHRoU2xpZGVyQ2hhbmdlQ2FsbGJhY2tfID1cbiAgICAgIGNhbGxiYWNrcy5yb3V0ZXJCYW5kd2lkdGhTbGlkZXJDaGFuZ2VDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb3V0ZXJCYW5kd2lkdGhTbGlkZXJTdG9wQ2FsbGJhY2tfID1cbiAgICAgIGNhbGxiYWNrcy5yb3V0ZXJCYW5kd2lkdGhTbGlkZXJTdG9wQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm91dGVyTWVtb3J5U2xpZGVyQ2hhbmdlQ2FsbGJhY2tfID1cbiAgICAgIGNhbGxiYWNrcy5yb3V0ZXJNZW1vcnlTbGlkZXJDaGFuZ2VDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb3V0ZXJNZW1vcnlTbGlkZXJTdG9wQ2FsbGJhY2tfID1cbiAgICAgIGNhbGxiYWNrcy5yb3V0ZXJNZW1vcnlTbGlkZXJTdG9wQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTW9kZUNoYW5nZUNhbGxiYWNrXyA9IGNhbGxiYWNrcy5kbnNNb2RlQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYmVjb21lRG5zQ2FsbGJhY2tfID0gY2FsbGJhY2tzLmJlY29tZURuc0NhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltUm91dGVyVGFifVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb3V0ZXJUYWJfID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbU15RGV2aWNlVGFifVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5teURldmljZVRhYl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltRG5zVGFifVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kbnNUYWJfID0gbnVsbDtcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1J1bkxvb3B9IHJ1bkxvb3BcbiAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuYXR0YWNoVG9SdW5Mb29wID0gZnVuY3Rpb24gKHJ1bkxvb3ApIHtcbiAgaWYgKHRoaXMucm91dGVyVGFiXykge1xuICAgIHRoaXMucm91dGVyVGFiXy5hdHRhY2hUb1J1bkxvb3AocnVuTG9vcCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsbCB0aGUgcm9vdCBkaXYgd2l0aCBuZXcgZWxlbWVudHMgcmVmbGVjdGluZyB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5OZXRTaW1UYWJzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgLy8gQ2xvbmUgdGhlIHJlZmVyZW5jZSBhcmVhICh3aXRoIGhhbmRsZXJzKSBiZWZvcmUgd2UgcmUtcmVuZGVyXG4gIHZhciByZWZlcmVuY2VBcmVhID0gJCgnI3JlZmVyZW5jZV9hcmVhJykuZmlyc3QoKS5jbG9uZSh0cnVlKTtcblxuICAvLyBSZW1vdmUgdGhlIGluc3RydWN0aW9ucyBhcmVhLCB0byByZWF0dGFjaCBpbiBhIG1pbnV0ZS5cbiAgdmFyIGluc3RydWN0aW9uc0FyZWEgPSAkKCcjYnViYmxlJykuZmlyc3QoKS5kZXRhY2goKTtcblxuICB2YXIgcmF3TWFya3VwID0gYnVpbGRNYXJrdXAoe1xuICAgIGxldmVsOiBsZXZlbENvbmZpZ1xuICB9KTtcbiAgdmFyIGpRdWVyeVdyYXAgPSAkKHJhd01hcmt1cCk7XG4gIHRoaXMucm9vdERpdl8uaHRtbChqUXVlcnlXcmFwKTtcblxuICB0aGlzLnJvb3REaXZfLmZpbmQoJy5uZXRzaW0tdGFicycpLnRhYnMoe1xuICAgIGFjdGl2ZTogbGV2ZWxDb25maWcuZGVmYXVsdFRhYkluZGV4XG4gIH0pO1xuXG4gIGlmIChzaG91bGRTaG93VGFiKGxldmVsQ29uZmlnLCBOZXRTaW1UYWJUeXBlLklOU1RSVUNUSU9OUykgJiYgcmVmZXJlbmNlQXJlYSkge1xuICAgIHZhciBpbnN0cnVjdGlvbnNUYWIgPSB0aGlzLnJvb3REaXZfLmZpbmQoJyN0YWJfaW5zdHJ1Y3Rpb25zJykuZmlyc3QoKTtcbiAgICBpbnN0cnVjdGlvbnNBcmVhLmFwcGVuZFRvKGluc3RydWN0aW9uc1RhYik7XG4gICAgcmVmZXJlbmNlQXJlYS5hcHBlbmRUbyhpbnN0cnVjdGlvbnNUYWIpO1xuICB9XG5cbiAgaWYgKHNob3VsZFNob3dUYWIobGV2ZWxDb25maWcsIE5ldFNpbVRhYlR5cGUuTVlfREVWSUNFKSkge1xuICAgIHRoaXMubXlEZXZpY2VUYWJfID0gbmV3IE5ldFNpbU15RGV2aWNlVGFiKFxuICAgICAgICB0aGlzLnJvb3REaXZfLmZpbmQoJyN0YWJfbXlfZGV2aWNlJyksXG4gICAgICAgIHRoaXMucnVuTG9vcF8sXG4gICAgICAgIHtcbiAgICAgICAgICBjaHVua1NpemVDaGFuZ2VDYWxsYmFjazogdGhpcy5jaHVua1NpemVTbGlkZXJDaGFuZ2VDYWxsYmFja18sXG4gICAgICAgICAgYml0UmF0ZUNoYW5nZUNhbGxiYWNrOiB0aGlzLm15RGV2aWNlQml0UmF0ZUNoYW5nZUNhbGxiYWNrXyxcbiAgICAgICAgICBlbmNvZGluZ0NoYW5nZUNhbGxiYWNrOiB0aGlzLmVuY29kaW5nQ2hhbmdlQ2FsbGJhY2tfXG4gICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKHNob3VsZFNob3dUYWIobGV2ZWxDb25maWcsIE5ldFNpbVRhYlR5cGUuUk9VVEVSKSkge1xuICAgIHRoaXMucm91dGVyVGFiXyA9IG5ldyBOZXRTaW1Sb3V0ZXJUYWIoXG4gICAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnI3RhYl9yb3V0ZXInKSxcbiAgICAgICAge1xuICAgICAgICAgIGJhbmR3aWR0aFNsaWRlckNoYW5nZUNhbGxiYWNrOiB0aGlzLnJvdXRlckJhbmR3aWR0aFNsaWRlckNoYW5nZUNhbGxiYWNrXyxcbiAgICAgICAgICBiYW5kd2lkdGhTbGlkZXJTdG9wQ2FsbGJhY2s6IHRoaXMucm91dGVyQmFuZHdpZHRoU2xpZGVyU3RvcENhbGxiYWNrXyxcbiAgICAgICAgICBtZW1vcnlTbGlkZXJDaGFuZ2VDYWxsYmFjazogdGhpcy5yb3V0ZXJNZW1vcnlTbGlkZXJDaGFuZ2VDYWxsYmFja18sXG4gICAgICAgICAgbWVtb3J5U2xpZGVyU3RvcENhbGxiYWNrOiB0aGlzLnJvdXRlck1lbW9yeVNsaWRlclN0b3BDYWxsYmFja19cbiAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoc2hvdWxkU2hvd1RhYihsZXZlbENvbmZpZywgTmV0U2ltVGFiVHlwZS5ETlMpKSB7XG4gICAgdGhpcy5kbnNUYWJfID0gbmV3IE5ldFNpbURuc1RhYihcbiAgICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcjdGFiX2RucycpLFxuICAgICAgICB0aGlzLmRuc01vZGVDaGFuZ2VDYWxsYmFja18sXG4gICAgICAgIHRoaXMuYmVjb21lRG5zQ2FsbGJhY2tfKTtcbiAgfVxufTtcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSBuZXdDaHVua1NpemUgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldENodW5rU2l6ZSA9IGZ1bmN0aW9uIChuZXdDaHVua1NpemUpIHtcbiAgaWYgKHRoaXMubXlEZXZpY2VUYWJfKSB7XG4gICAgdGhpcy5teURldmljZVRhYl8uc2V0Q2h1bmtTaXplKG5ld0NodW5rU2l6ZSk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbmV3Qml0UmF0ZSBpbiBiaXRzIHBlciBzZWNvbmQgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldE15RGV2aWNlQml0UmF0ZSA9IGZ1bmN0aW9uIChuZXdCaXRSYXRlKSB7XG4gIGlmICh0aGlzLm15RGV2aWNlVGFiXykge1xuICAgIHRoaXMubXlEZXZpY2VUYWJfLnNldEJpdFJhdGUobmV3Qml0UmF0ZSk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBuZXdFbmNvZGluZ3MgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldEVuY29kaW5ncyA9IGZ1bmN0aW9uIChuZXdFbmNvZGluZ3MpIHtcbiAgaWYgKHRoaXMubXlEZXZpY2VUYWJfKSB7XG4gICAgdGhpcy5teURldmljZVRhYl8uc2V0RW5jb2RpbmdzKG5ld0VuY29kaW5ncyk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gY3JlYXRpb25UaW1lc3RhbXBNcyAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuc2V0Um91dGVyQ3JlYXRpb25UaW1lID0gZnVuY3Rpb24gKGNyZWF0aW9uVGltZXN0YW1wTXMpIHtcbiAgaWYgKHRoaXMucm91dGVyVGFiXykge1xuICAgIHRoaXMucm91dGVyVGFiXy5zZXRSb3V0ZXJDcmVhdGlvblRpbWUoY3JlYXRpb25UaW1lc3RhbXBNcyk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbmV3QmFuZHdpZHRoIGluIGJpdHMvc2Vjb25kICovXG5OZXRTaW1UYWJzQ29tcG9uZW50LnByb3RvdHlwZS5zZXRSb3V0ZXJCYW5kd2lkdGggPSBmdW5jdGlvbiAobmV3QmFuZHdpZHRoKSB7XG4gIGlmICh0aGlzLnJvdXRlclRhYl8pIHtcbiAgICB0aGlzLnJvdXRlclRhYl8uc2V0QmFuZHdpZHRoKG5ld0JhbmR3aWR0aCk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbmV3TWVtb3J5IGluIGJpdHMgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldFJvdXRlck1lbW9yeSA9IGZ1bmN0aW9uIChuZXdNZW1vcnkpIHtcbiAgaWYgKHRoaXMucm91dGVyVGFiXykge1xuICAgIHRoaXMucm91dGVyVGFiXy5zZXRNZW1vcnkobmV3TWVtb3J5KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcXVldWVkUGFja2V0Q291bnRcbiAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuc2V0Um91dGVyUXVldWVkUGFja2V0Q291bnQgPSBmdW5jdGlvbiAocXVldWVkUGFja2V0Q291bnQpIHtcbiAgaWYgKHRoaXMucm91dGVyVGFiXykge1xuICAgIHRoaXMucm91dGVyVGFiXy5zZXRSb3V0ZXJRdWV1ZWRQYWNrZXRDb3VudChxdWV1ZWRQYWNrZXRDb3VudCk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdXNlZE1lbW9yeUluQml0cyAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuc2V0Um91dGVyTWVtb3J5SW5Vc2UgPSBmdW5jdGlvbiAodXNlZE1lbW9yeUluQml0cykge1xuICBpZiAodGhpcy5yb3V0ZXJUYWJfKSB7XG4gICAgdGhpcy5yb3V0ZXJUYWJfLnNldE1lbW9yeUluVXNlKHVzZWRNZW1vcnlJbkJpdHMpO1xuICB9XG59O1xuXG5OZXRTaW1UYWJzQ29tcG9uZW50LnByb3RvdHlwZS5zZXRSb3V0ZXJEYXRhUmF0ZSA9IGZ1bmN0aW9uIChkYXRhUmF0ZUJpdHNQZXJTZWNvbmQpIHtcbiAgaWYgKHRoaXMucm91dGVyVGFiXykge1xuICAgIHRoaXMucm91dGVyVGFiXy5zZXREYXRhUmF0ZShkYXRhUmF0ZUJpdHNQZXJTZWNvbmQpO1xuICB9XG59O1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5ld0Ruc01vZGUgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldERuc01vZGUgPSBmdW5jdGlvbiAobmV3RG5zTW9kZSkge1xuICBpZiAodGhpcy5kbnNUYWJfKSB7XG4gICAgdGhpcy5kbnNUYWJfLnNldERuc01vZGUobmV3RG5zTW9kZSk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IGlzRG5zTm9kZSAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuc2V0SXNEbnNOb2RlID0gZnVuY3Rpb24gKGlzRG5zTm9kZSkge1xuICBpZiAodGhpcy5kbnNUYWJfKSB7XG4gICAgdGhpcy5kbnNUYWJfLnNldElzRG5zTm9kZShpc0Ruc05vZGUpO1xuICB9XG59O1xuXG4vKiogQHBhcmFtIHtBcnJheX0gdGFibGVDb250ZW50cyAqL1xuTmV0U2ltVGFic0NvbXBvbmVudC5wcm90b3R5cGUuc2V0RG5zVGFibGVDb250ZW50cyA9IGZ1bmN0aW9uICh0YWJsZUNvbnRlbnRzKSB7XG4gIGlmICh0aGlzLmRuc1RhYl8pIHtcbiAgICB0aGlzLmRuc1RhYl8uc2V0RG5zVGFibGVDb250ZW50cyh0YWJsZUNvbnRlbnRzKTtcbiAgfVxufTtcblxuLyoqIEBwYXJhbSB7QXJyYXl9IGxvZ0RhdGEgKi9cbk5ldFNpbVRhYnNDb21wb25lbnQucHJvdG90eXBlLnNldFJvdXRlckxvZ0RhdGEgPSBmdW5jdGlvbiAobG9nRGF0YSkge1xuICBpZiAodGhpcy5yb3V0ZXJUYWJfKSB7XG4gICAgdGhpcy5yb3V0ZXJUYWJfLnNldFJvdXRlckxvZ0RhdGEobG9nRGF0YSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7XG4gIHZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcblxuICB2YXIgc2hvdWxkU2hvd1RhYiA9IHJlcXVpcmUoJy4vTmV0U2ltVXRpbHMnKS5zaG91bGRTaG93VGFiO1xuICB2YXIgTmV0U2ltVGFiVHlwZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuTmV0U2ltVGFiVHlwZTtcblxuICB2YXIgc2hvd0luc3RydWN0aW9ucyA9IHNob3VsZFNob3dUYWIobGV2ZWwsIE5ldFNpbVRhYlR5cGUuSU5TVFJVQ1RJT05TKTtcbiAgdmFyIHNob3dNeURldmljZSA9IHNob3VsZFNob3dUYWIobGV2ZWwsIE5ldFNpbVRhYlR5cGUuTVlfREVWSUNFKTtcbiAgdmFyIHNob3dSb3V0ZXIgPSBzaG91bGRTaG93VGFiKGxldmVsLCBOZXRTaW1UYWJUeXBlLlJPVVRFUik7XG4gIHZhciBzaG93RG5zID0gc2hvdWxkU2hvd1RhYihsZXZlbCwgTmV0U2ltVGFiVHlwZS5ETlMpO1xuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cIm5ldHNpbS10YWJzXCI+XFxuICA8dWw+XFxuICAgICcpOzE0OyBpZiAoc2hvd0luc3RydWN0aW9ucykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGxpPjxhIGhyZWY9XCIjdGFiX2luc3RydWN0aW9uc1wiPicsIGVzY2FwZSgoMTUsICBpMThuLmluc3RydWN0aW9ucygpICkpLCAnPC9hPjwvbGk+XFxuICAgICcpOzE2OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAnKTsxNzsgaWYgKHNob3dNeURldmljZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8bGk+PGEgaHJlZj1cIiN0YWJfbXlfZGV2aWNlXCI+JywgZXNjYXBlKCgxOCwgIGkxOG4ubXlEZXZpY2UoKSApKSwgJzwvYT48L2xpPlxcbiAgICAnKTsxOTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7MjA7IGlmIChzaG93Um91dGVyKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxsaT48YSBocmVmPVwiI3RhYl9yb3V0ZXJcIj4nLCBlc2NhcGUoKDIxLCAgaTE4bi5yb3V0ZXIoKSApKSwgJzwvYT48L2xpPlxcbiAgICAnKTsyMjsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7MjM7IGlmIChzaG93RG5zKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxsaT48YSBocmVmPVwiI3RhYl9kbnNcIj4nLCBlc2NhcGUoKDI0LCAgaTE4bi5kbnMoKSApKSwgJzwvYT48L2xpPlxcbiAgICAnKTsyNTsgfSA7IGJ1Zi5wdXNoKCdcXG4gIDwvdWw+XFxuICAnKTsyNzsgaWYgKHNob3dJbnN0cnVjdGlvbnMpIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXYgaWQ9XCJ0YWJfaW5zdHJ1Y3Rpb25zXCI+PC9kaXY+XFxuICAnKTsyOTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICcpOzMwOyBpZiAoc2hvd015RGV2aWNlKSB7IDsgYnVmLnB1c2goJ1xcbiAgICA8ZGl2IGlkPVwidGFiX215X2RldmljZVwiPjwvZGl2PlxcbiAgJyk7MzI7IH0gOyBidWYucHVzaCgnXFxuICAnKTszMzsgaWYgKHNob3dSb3V0ZXIpIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXYgaWQ9XCJ0YWJfcm91dGVyXCI+PC9kaXY+XFxuICAnKTszNTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICcpOzM2OyBpZiAoc2hvd0RucykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBpZD1cInRhYl9kbnNcIj48L2Rpdj5cXG4gICcpOzM4OyB9IDsgYnVmLnB1c2goJ1xcbjwvZGl2PicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbXBvbmVudDogVGhlIHNtYWxsIGV4cGFuZGFibGUgYm94IGFib3ZlIHRoZSB2aXN1YWxpemF0aW9uLFxuICogICAgICAgICAgIHVzZWQgdG8gc2hvdyBkZWJ1ZyBhbmQgZGlhZ25vc3RpYyBpbmZvcm1hdGlvbi5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL3V0aWxzJyk7IC8vIEZvciBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMoKVxudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltU3RhdHVzUGFuZWwuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1QYW5lbCA9IHJlcXVpcmUoJy4vTmV0U2ltUGFuZWwuanMnKTtcbnZhciBOZXRTaW1VdGlscyA9IHJlcXVpcmUoJy4vTmV0U2ltVXRpbHMnKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIGNvbm5lY3Rpb24gc3RhdHVzIHBhbmVsXG4gKiBpbiBsZWZ0IGNvbHVtbiwgZGlzcGxheWVkIHdoaWxlIGNvbm5lY3RlZC5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZGlzY29ubmVjdENhbGxiYWNrIC0gbWV0aG9kIHRvIGNhbGwgd2hlbiBkaXNjb25uZWN0IGJ1dHRvblxuICogICAgICAgIGlzIGNsaWNrZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1QYW5lbFxuICovXG52YXIgTmV0U2ltU3RhdHVzUGFuZWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBjYWxsYmFja3MpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZGlzY29ubmVjdENhbGxiYWNrXyA9IGNhbGxiYWNrcy5kaXNjb25uZWN0Q2FsbGJhY2s7XG5cbiAgLy8gU3VwZXJjbGFzcyBjb25zdHJ1Y3RvclxuICBOZXRTaW1QYW5lbC5jYWxsKHRoaXMsIHJvb3REaXYsIHtcbiAgICBjbGFzc05hbWU6ICduZXRzaW1fc3RhdHVzX3BhbmVsJyxcbiAgICBwYW5lbFRpdGxlOiAnU3RhdHVzJyxcbiAgICB1c2VyVG9nZ2xlYWJsZTogZmFsc2UsXG4gICAgYmVnaW5NaW5pbWl6ZWQ6IHRydWVcbiAgfSk7XG59O1xuTmV0U2ltU3RhdHVzUGFuZWwuaW5oZXJpdHMoTmV0U2ltUGFuZWwpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5yZW1vdGVOb2RlTmFtZV0gLSBEaXNwbGF5IG5hbWUgb2YgcmVtb3RlIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RhdGEubXlIb3N0bmFtZV0gLSBIb3N0bmFtZSBvZiBsb2NhbCBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW2RhdGEubXlBZGRyZXNzXSAtIExvY2FsIG5vZGUgYWRkcmVzcyBhc3NpZ25lZCBieSByb3V0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5zaGFyZUxpbmtdIC0gVVJMIGZvciBzaGFyaW5nIHByaXZhdGUgc2hhcmRcbiAqL1xuTmV0U2ltU3RhdHVzUGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIENhcHR1cmUgdGl0bGUgYmVmb3JlIHdlIHJlbmRlciB0aGUgd3JhcHBlciBwYW5lbC5cbiAgdGhpcy5zZXRQYW5lbFRpdGxlKGRhdGEucmVtb3RlTm9kZU5hbWUpO1xuXG4gIC8vIFJlbmRlciBib2lsZXJwbGF0ZSBwYW5lbCBzdHVmZlxuICBOZXRTaW1TdGF0dXNQYW5lbC5zdXBlclByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICAvLyBQdXQgb3VyIG93biBjb250ZW50IGludG8gdGhlIHBhbmVsIGJvZHlcbiAgdmFyIG5ld01hcmt1cCA9ICQobWFya3VwKHtcbiAgICBteUhvc3RuYW1lOiBkYXRhLm15SG9zdG5hbWUsXG4gICAgbXlBZGRyZXNzOiBkYXRhLm15QWRkcmVzcyxcbiAgICBzaGFyZUxpbms6IGRhdGEuc2hhcmVMaW5rXG4gIH0pKTtcbiAgdGhpcy5nZXRCb2R5KCkuaHRtbChuZXdNYXJrdXApO1xuXG4gIC8vIEFkZCBhIGJ1dHRvbiB0byB0aGUgcGFuZWwgaGVhZGVyXG4gIHRoaXMuYWRkQnV0dG9uKFxuICAgICAgaTE4bi5kaXNjb25uZWN0QnV0dG9uKHsgY2FyZXQ6ICc8aSBjbGFzcz1cImZhIGZhLWNhcmV0LWxlZnRcIj48L2k+JyB9KSxcbiAgICAgIHRoaXMuZGlzY29ubmVjdENhbGxiYWNrXyk7XG5cbiAgLy8gQnV0dG9uIHRoYXQgdGFrZXMgeW91IHRvIHRoZSBuZXh0IGxldmVsLlxuICBOZXRTaW1VdGlscy5tYWtlQ29udGludWVCdXR0b24odGhpcyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cImNvbnRlbnQtd3JhcFwiPlxcbiAgJyk7NTsgaWYgKG15SG9zdG5hbWUpIHsgOyBidWYucHVzaCgnXFxuICA8cD5NeSBob3N0bmFtZTogJywgZXNjYXBlKCg2LCAgbXlIb3N0bmFtZSApKSwgJzwvcD5cXG4gICcpOzc7IH0gOyBidWYucHVzaCgnXFxuXFxuICAnKTs5OyBpZiAobXlBZGRyZXNzKSB7IDsgYnVmLnB1c2goJ1xcbiAgPHA+TXkgYWRkcmVzczogJywgZXNjYXBlKCgxMCwgIG15QWRkcmVzcyApKSwgJzwvcD5cXG4gICcpOzExOyB9IDsgYnVmLnB1c2goJ1xcblxcbiAgJyk7MTM7IGlmIChzaGFyZUxpbmspIHsgOyBidWYucHVzaCgnXFxuICA8cD48YSBocmVmPVwiJywgZXNjYXBlKCgxNCwgIHNoYXJlTGluayApKSwgJ1wiPicsIGVzY2FwZSgoMTQsICBpMThuLnNoYXJlVGhpc05ldHdvcmsoKSApKSwgJzwvYT48L3A+XFxuICAnKTsxNTsgfSA7IGJ1Zi5wdXNoKCdcXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiB0YWJsZXMgdGhhdCBtYXAgdG8gYSBwYXJ0aWN1bGFyXG4gKiAgICAgICAgICAgY2xhc3Mgc2VjdGlvbidzIHNpbXVsYXRpb24sIGlzb2xhdGVkIGZyb20gb3RoZXIgY2xhc3Mgc2VjdGlvbnMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE5ldFNpbVRhYmxlID0gcmVxdWlyZSgnLi9OZXRTaW1UYWJsZScpO1xudmFyIFB1YlN1YlNlcnZpY2UgPSByZXF1aXJlKCcuL1B1YlN1YlNlcnZpY2UnKTtcblxuLyoqXG4gKiBQdWJTdWIgZXZlbnQga2V5IGZvciBldmVudHMgaW52YWxpZGF0aW5nIGFsbCB0YWJsZXMuXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xudmFyIFdIT0xFX1NIQVJEX0VWRU5UID0gJ2FsbF90YWJsZXMnO1xuXG4vKipcbiAqIEEgc2hhcmQgaXMgYW4gaXNvbGF0ZWQsIGNvbXBsZXRlIHNpbXVsYXRpb24gc3RhdGUgc2hhcmVkIGJ5IGEgc3Vic2V0IG9mXG4gKiB1c2Vycy4gIEl0J3MgbWFkZSBvZiBhIHNldCBvZiBzdG9yYWdlIHRhYmxlcyBzZXQgYXBhcnQgYnkgYSBwYXJ0aWN1bGFyXG4gKiBzaGFyZCBJRCBpbiB0aGVpciBuYW1lcy4gIFdlIHVzZSBzaGFyZHMgdG8gYWxsb3cgc3R1ZGVudHMgdG8gaW50ZXJhY3Qgb25seVxuICogd2l0aCB0aGVpciBwYXJ0aWN1bGFyIGNsYXNzIHdoaWxlIHN0aWxsIHN0b3JpbmcgYWxsIE5ldFNpbSB0YWJsZXMgdW5kZXJcbiAqIHRoZSBzYW1lIEFwcCBJRC5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHNoYXJkSURcbiAqIEBwYXJhbSB7IVB1YlN1YkNvbmZpZ30gcHViU3ViQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbVNoYXJkID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2hhcmRJRCwgcHViU3ViQ29uZmlnKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLmlkID0gc2hhcmRJRDtcblxuICAvKiogQHR5cGUge1B1YlN1YlNlcnZpY2V9ICovXG4gIHRoaXMucHViU3ViID0gUHViU3ViU2VydmljZS5jcmVhdGUocHViU3ViQ29uZmlnKTtcblxuICAvKiogQHR5cGUge1B1YlN1YkNoYW5uZWx9ICovXG4gIHRoaXMucHViU3ViQ2hhbm5lbCA9IHRoaXMucHViU3ViLnN1YnNjcmliZSh0aGlzLmlkKTtcbiAgdGhpcy5wdWJTdWJDaGFubmVsLnN1YnNjcmliZShXSE9MRV9TSEFSRF9FVkVOVCxcbiAgICAgIE5ldFNpbVNoYXJkLnByb3RvdHlwZS5vblB1YlN1YkV2ZW50Xy5iaW5kKHRoaXMpKTtcblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBjbGllbnQgKHVzZXIpIG5vZGVzIGFuZCByb3V0ZXIgbm9kZXMgb24gdGhlIHNoYXJkLlxuICAgKiBFYWNoIGNsaWVudCBub2RlIGNvcnJlc3BvbmRzIHRvIGEgdXNlciAob3IgYnJvd3NlciB0YWIsIHRvIGJlIHNwZWNpZmljKS5cbiAgICogUm91dGVyIG5vZGVzIGFyZSBub3QgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciB1c2VyLlxuICAgKlxuICAgKiBBbGwgZW50aXRpZXMgaW4gdGhpcyB0YWJsZSBkZXNjZW5kIGZyb20gTmV0U2ltTm9kZSwgYW5kIGNhbiBiZSBkZXNlcmlhbGl6ZWRcbiAgICogdmlhIHV0aWxpdGllcyBpbiBOZXRTaW1Ob2RlRmFjdG9yeVxuICAgKlxuICAgKiBSb3dzIGluIHRoaXMgdGFibGUgYXJlXG4gICAqIC0gaW5zZXJ0ZWQgd2hlbiBhIG5vZGUgaXMgY3JlYXRlZCAoc3VjaCBhcyB3aGVuIGEgdXNlciBjb25uZWN0cylcbiAgICogLSB1cGRhdGVkIGZvciBjZXJ0YWluIGNoYW5nZXMgdG8gbm9kZSBzdGF0dXMgb3Igcm91dGVyIGNvbmZpZ3VyYXRpb25cbiAgICogLSBkZWxldGVkIHdoZW4gYSBub2RlIGlzIGRlc3Ryb3llZCAoc3VjaCBhcyB3aGVuIGEgdXNlciBkaXNjb25uZWN0cylcbiAgICpcbiAgICogQHR5cGUge05ldFNpbVRhYmxlfVxuICAgKiBAc2VlIHtOZXRTaW1Ob2RlfVxuICAgKiBAc2VlIHtOZXRTaW1DbGllbnROb2RlfVxuICAgKiBAc2VlIHtOZXRTaW1Sb3V0ZXJOb2RlfVxuICAgKiBAc2VlIHtOZXRTaW1Mb2NhbENsaWVudE5vZGV9XG4gICAqIEBzZWUge05ldFNpbU5vZGVGYWN0b3J5fVxuICAgKi9cbiAgdGhpcy5ub2RlVGFibGUgPSBuZXcgTmV0U2ltVGFibGUodGhpcy5wdWJTdWJDaGFubmVsLCBzaGFyZElELCAnbicpO1xuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIHdpcmVzIG9uIHRoZSBzaGFyZC4gIFdpcmVzIGRvY3VtZW50IHRoZSBjb25uZWN0aW9ucyBiZXR3ZWVuXG4gICAqIG5vZGVzIGFuZCBjZXJ0YWluIG5vZGUgbWV0YWRhdGEsIGxpa2UgaG9zdG5hbWVzIGFuZCBhZGRyZXNzZXMuICBXaXJlc1xuICAgKiByZWZlcmVuY2Ugbm9kZSBJRHMsIGFuZCBhcmUgdGhlcmVmb3JlIHJlZmVyZW50aWFsbHkgZGVwZW5kZW50IG9uIHRoZSBub2RlXG4gICAqIHRhYmxlLlxuICAgKlxuICAgKiBBbGwgZW50aXRpZXMgaW4gdGhpcyB0YWJsZSBkZXNlcmlhbGl6ZSBpbnRvIE5ldFNpbVdpcmUuXG4gICAqXG4gICAqIFJvd3MgaW4gdGhpcyB0YWJsZSBhcmVcbiAgICogLSBpbnNlcnRlZCB3aGVuIHR3byBub2RlcyBhcmUgY29ubmVjdGVkXG4gICAqIC0gdXBkYXRlZCB3aGVuIGFzc2lnbmluZyBhbiBhZGRyZXNzXG4gICAqIC0gZGVsZXRlZCB3aGVuIHR3byBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG4gICAqXG4gICAqIEB0eXBlIHtOZXRTaW1UYWJsZX1cbiAgICogQHNlZSB7TmV0U2ltV2lyZX1cbiAgICovXG4gIHRoaXMud2lyZVRhYmxlID0gbmV3IE5ldFNpbVRhYmxlKHRoaXMucHViU3ViQ2hhbm5lbCwgc2hhcmRJRCwgJ3cnKTtcblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXNzYWdlcyAoZW5xdWV1ZWQgb3IgaW4tZmxpZ2h0KSBvbiB0aGUgc2hhcmQuICBNZXNzYWdlc1xuICAgKiByZWZlcmVuY2Ugbm9kZSBJRHMsIGFuZCBhcmUgdGhlcmVmb3JlIHJlZmVyZW50aWFsbHkgZGVwZW5kZW50IG9uIHRoZSBub2RlXG4gICAqIHRhYmxlLlxuICAgKlxuICAgKiBBbGwgZW50aXRpZXMgaW4gdGhpcyB0YWJsZSBkZXNlcmlhbGl6ZSBpbnRvIE5ldFNpbU1lc3NhZ2UuXG4gICAqXG4gICAqIFJvd3MgaW4gdGhpcyB0YWJsZSBhcmVcbiAgICogLSBpbnNlcnRlZCB3aGVuIGEgbWVzc2FnZSBpcyBzZW50XG4gICAqIC0gbmV2ZXIgdXBkYXRlZFxuICAgKiAtIGRlbGV0ZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICpcbiAgICogQHR5cGUge05ldFNpbVRhYmxlfVxuICAgKiBAc2VlIHtOZXRTaW1NZXNzYWdlfVxuICAgKi9cbiAgdGhpcy5tZXNzYWdlVGFibGUgPSBuZXcgTmV0U2ltVGFibGUodGhpcy5wdWJTdWJDaGFubmVsLCBzaGFyZElELCAnbScpO1xuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIGxvZyBlbnRyaWVzIGZvciBub2RlcyBvbiB0aGUgc2hhcmQuICBMb2dzIHJlZmVyZW5jZSBub2RlIElEcyxcbiAgICogYW5kIGFyZSB0aGVyZWZvcmUgcmVmZXJlbnRpYWxseSBkZXBlbmRlbnQgb24gdGhlIG5vZGUgdGFibGUgKGJ1dCB3ZSBzaG91bGRcbiAgICogY2hhbmdlIHRoaXMpLmNoYW5uZWxcbiAgICpcbiAgICogQWxsIGVudGl0aWVzIGluIHRoaXMgdGFibGUgZGVzZXJpYWxpemUgaW50byBOZXRTaW1Mb2dFbnRyeS5cbiAgICpcbiAgICogUm93cyBpbiB0aGlzIHRhYmxlIGFyZVxuICAgKiAtIGluc2VydGVkIHdoZW4gYSByb3V0ZXIgcm91dGVzIG9yIGRyb3BzIGEgbWVzc2FnZVxuICAgKiAtIG5ldmVyIHVwZGF0ZWRcbiAgICogLSBuZXZlciBkZWxldGVkXG4gICAqXG4gICAqIEB0eXBlIHtOZXRTaW1UYWJsZX1cbiAgICogQHNlZSB7TmV0U2ltTG9nRW50cnl9XG4gICAqL1xuICB0aGlzLmxvZ1RhYmxlID0gbmV3IE5ldFNpbVRhYmxlKHRoaXMucHViU3ViQ2hhbm5lbCwgc2hhcmRJRCwgJ2wnLCB7XG4gICAgLy8gVGhpcyBpcyBvbmx5IHNhZmUgdG8gZG8gYmVjYXVzZSB3ZSBuZXZlciB1cGRhdGUgb3IgZGVsZXRlIHJvd3MgaW4gdGhpcyB0YWJsZS5cbiAgICB1c2VJbmNyZW1lbnRhbFJlZnJlc2g6IHRydWVcbiAgfSk7XG4gIHRoaXMubG9nVGFibGUudW5zdWJzY3JpYmUoKTtcbn07XG5cbi8qKlxuICogTmVjZXNzYXJ5IHRlYXItZG93biBmb3Igc2hhcmQuICBJbiBwYXJ0aWN1bGFyLCBkaXNjb25uZWN0aW5nXG4gKiBmcm9tIHB1YnN1YiBzZXJ2aWNlLlxuICovXG5OZXRTaW1TaGFyZC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ub2RlVGFibGUudW5zdWJzY3JpYmUoKTtcbiAgdGhpcy53aXJlVGFibGUudW5zdWJzY3JpYmUoKTtcbiAgdGhpcy5tZXNzYWdlVGFibGUudW5zdWJzY3JpYmUoKTtcbiAgdGhpcy5sb2dUYWJsZS51bnN1YnNjcmliZSgpO1xuICB0aGlzLnB1YlN1YkNoYW5uZWwudW5zdWJzY3JpYmUoV0hPTEVfU0hBUkRfRVZFTlQpO1xuICB0aGlzLnB1YlN1YkNoYW5uZWwgPSBudWxsO1xuICB0aGlzLnB1YlN1Yi51bnN1YnNjcmliZSh0aGlzLmlkKTtcbn07XG5cbi8qKlxuICogVGhpcyB0aWNrIGFsbG93cyBvdXIgdGFibGVzIHRvIHBvbGwgdGhlIHNlcnZlciBmb3IgY2hhbmdlcy5cbiAqIEBwYXJhbSB7IVJ1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKi9cbk5ldFNpbVNoYXJkLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIHRoaXMubm9kZVRhYmxlLnRpY2soY2xvY2spO1xuICB0aGlzLndpcmVUYWJsZS50aWNrKGNsb2NrKTtcbiAgdGhpcy5tZXNzYWdlVGFibGUudGljayhjbG9jayk7XG4gIHRoaXMubG9nVGFibGUudGljayhjbG9jayk7XG59O1xuXG4vKipcbiAqIFRoZSBcInBhbmljIGJ1dHRvblwiIG9wdGlvbiAtIGNsZWFycyBhbGwgZGF0YSBvbiB0aGUgc2hhcmQsIGtpY2tpbmcgYWxsXG4gKiB1c2VycyBvdXQgYW5kIHN0YXJ0aW5nIG92ZXIuXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKi9cbk5ldFNpbVNoYXJkLnByb3RvdHlwZS5yZXNldEV2ZXJ5dGhpbmcgPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAkLmFqYXgoe1xuICAgIHVybDogJy92My9uZXRzaW0vJyArIHRoaXMuaWQsXG4gICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcbiAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgfSkuZG9uZShmdW5jdGlvbigpIHtcbiAgICBvbkNvbXBsZXRlKG51bGwsIHRydWUpO1xuICB9KS5mYWlsKGZ1bmN0aW9uKHJlcXVlc3QsIHN0YXR1cywgZXJyb3IpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzdGF0dXM6ICcgKyBzdGF0dXMgKyAnOyBlcnJvcjogJyArIGVycm9yKTtcbiAgICBvbkNvbXBsZXRlKGVyciwgZmFsc2UpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIFB1YlN1YiBzZXJ2aWNlIGZpcmVzIGFuIGV2ZW50IHRoYXQgYXBwbGllcyB0byBhbGwgdGFibGVzXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TaGFyZC5wcm90b3R5cGUub25QdWJTdWJFdmVudF8gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJpZ2h0IG5vdywgdGhlIG9ubHkgYWxsX3RhYmxlcyBldmVudCBpcyB0aGUgc2hhcmQgcmVzZXQuXG4gIC8vIFJlZnJlc2hpbmcgdGhlIG5vZGUgdGFibGUgaW5mb3JtcyBvdXIgbm9kZSB0aGF0IGEgcmVzZXQgaGFzIG9jY3VycmVkLlxuICAvLyBUT0RPOiBVc2UgYSBcImRpc2Nvbm5lY3QgZnJvbSBzaGFyZFwiIGNhbGxiYWNrIGluc3RlYWQgaGVyZS5cbiAgdGhpcy5ub2RlVGFibGUucmVmcmVzaCgpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFdyYXBwZWQgcHViL3N1YiBzZXJ2aWNlIGNsaWVudCBBUElzIChsaWtlIFB1c2hlcilcbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuLyogZ2xvYmFsIFB1c2hlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHViU3ViQ2hhbm5lbCA9IHJlcXVpcmUoJy4vUHViU3ViQ2hhbm5lbCcpO1xuXG4vKipcbiAqIEphdmFTY3JpcHQgaW50ZXJmYWNlIGZvciBhIHB1Ymxpc2gvc3Vic2NyaWJlIHNlcnZpY2UgcHJvdmlkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb25LZXlcbiAqIEBpbnRlcmZhY2VcbiAqL1xudmFyIFB1YlN1YlNlcnZpY2UgPSBleHBvcnRzO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1YlN1YkNvbmZpZ1xuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VQdXNoZXIgLSBXaGV0aGVyIHRvIHVzZSBQdXNoZXIncyBBUEksIG9yIGEgbnVsbFxuICogICAgICAgICAgIGltcGxlbWVudGF0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHB1c2hlckFwcGxpY2F0aW9uS2V5IC0gSWYgdXNpbmcgUHVzaGVyLCB0aGUgcHVibGljIGtleVxuICogICAgICAgICAgIHJlcXVpcmVkIHRvIGluaXRpYWxpemUgdGhlIFB1c2hlciBBUEkuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gQVBJIGluc3RhbmNlIGFwcHJvcHJpYXRlIHRvIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0geyFQdWJTdWJDb25maWd9IHB1YlN1YkNvbmZpZ1xuICogQHJldHVybnMge1B1YlN1YlNlcnZpY2V9XG4gKi9cblB1YlN1YlNlcnZpY2UuY3JlYXRlID0gZnVuY3Rpb24gKHB1YlN1YkNvbmZpZykge1xuICBpZiAocHViU3ViQ29uZmlnLnVzZVB1c2hlcikge1xuICAgIHJldHVybiBuZXcgUHViU3ViU2VydmljZS5QdXNoZXJTZXJ2aWNlKHB1YlN1YkNvbmZpZy5wdXNoZXJBcHBsaWNhdGlvbktleSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFB1YlN1YlNlcnZpY2UuTnVsbFNlcnZpY2UoKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBQdWJTdWJTZXJ2aWNlI3N1YnNjcmliZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxJRCAtIENoYW5uZWwgdG8gd2hpY2ggd2Ugc3Vic2NyaWJlLlxuICogQHJldHVybnMge1B1YlN1YkNoYW5uZWx9XG4gKi9cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIFB1YlN1YlNlcnZpY2UjdW5zdWJzY3JpYmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsSUQgLSBDaGFubmVsIGZyb20gd2hpY2ggd2UgdW5zdWJzY3JpYmUuXG4gKi9cblxuLyoqXG4gKiBTdHViIGltcGxlbWVudGF0aW9uIG9mIFB1YlN1YiBBUEkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIFB1YlN1YlNlcnZpY2VcbiAqL1xuLy8gRGlzYWJsZSBcInVudXNlZCB2YXJpYWJsZVwiIGVycm9ycyBmb3IgbnVsbCBpbXBsZW1lbnRhdGlvbiBkZWNsYXJhdGlvbnNcbi8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cblB1YlN1YlNlcnZpY2UuTnVsbFNlcnZpY2UgPSBmdW5jdGlvbiAoKSB7IH07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGV2ZW50cyBvbiBhIHBhcnRpY3VsYXIgY2hhbm5lbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsSURcbiAqIEByZXR1cm5zIHtQdWJTdWJDaGFubmVsfVxuICovXG5QdWJTdWJTZXJ2aWNlLk51bGxTZXJ2aWNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbElEKSB7XG4gIHJldHVybiBuZXcgUHViU3ViQ2hhbm5lbC5OdWxsQ2hhbm5lbCgpO1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGV2ZW50cyBvbiBhIHBhcnRpY3VsYXIgY2hhbm5lbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsSURcbiAqL1xuUHViU3ViU2VydmljZS5OdWxsU2VydmljZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbElEKSB7IH07XG5cbi8vIFJlLWVuYWJsZSBcInVudXNlZCB2YXJpYWJsZVwiIGVycm9yXG4vKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuLyoqXG4gKiBXcmFwcGVkIFB1c2hlci5jb20gQVBJLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uS2V5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIFB1YlN1YlNlcnZpY2VcbiAqL1xuUHViU3ViU2VydmljZS5QdXNoZXJTZXJ2aWNlID0gZnVuY3Rpb24gKGFwcGxpY2F0aW9uS2V5KSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBhY3R1YWwgUHVzaGVyIEphdmFTY3JpcHQgQVBJLlxuICAgKiBAdHlwZSB7UHVzaGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5hcGlfID0gbmV3IFB1c2hlcihhcHBsaWNhdGlvbktleSwgeyBlbmNyeXB0ZWQ6IHRydWUgfSk7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBldmVudHMgb24gYSBwYXJ0aWN1bGFyIGNoYW5uZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbElEXG4gKiBAcmV0dXJucyB7UHViU3ViQ2hhbm5lbH1cbiAqL1xuUHViU3ViU2VydmljZS5QdXNoZXJTZXJ2aWNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbElEKSB7XG4gIHJldHVybiBuZXcgUHViU3ViQ2hhbm5lbC5QdXNoZXJDaGFubmVsKHRoaXMuYXBpXy5zdWJzY3JpYmUoY2hhbm5lbElEKSk7XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gZXZlbnRzIG9uIGEgcGFydGljdWxhciBjaGFubmVsLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxJRFxuICovXG5QdWJTdWJTZXJ2aWNlLlB1c2hlclNlcnZpY2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNoYW5uZWxJRCkge1xuICB0aGlzLmFwaV8udW5zdWJzY3JpYmUoY2hhbm5lbElEKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBXcmFwcGVkIHB1Yi9zdWIgc2VydmljZSBjaGFubmVsIEFQSXMgKGxpa2UgUHVzaGVyJ3MgQ2hhbm5lbClcbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW50ZXJmYWNlIGZvciBhIHB1Ymxpc2gvc3Vic2NyaWJlIGNoYW5uZWwuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbnZhciBQdWJTdWJDaGFubmVsID0gZXhwb3J0cztcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIHNvIHRoYXQgdGhlIGdpdmVuIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogZXZlbnQgb2NjdXJzLlxuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBQdWJTdWJDaGFubmVsI3N1YnNjcmliZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiaW5kIHRvLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgZXZlbnQgaXNcbiAqICAgICAgICB0cmlnZ2VyZWQuXG4gKi9cblxuLy8gRGlzYWJsZSBcInVudXNlZCB2YXJpYWJsZVwiIGVycm9ycyBmb3IgbnVsbCBpbXBsZW1lbnRhdGlvbiBkZWNsYXJhdGlvbnNcbi8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIFB1YlN1YkNoYW5uZWxcbiAqL1xuUHViU3ViQ2hhbm5lbC5OdWxsQ2hhbm5lbCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQgc28gdGhlIGdpdmVuIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJpbmQgdG8uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBldmVudCBpc1xuICogICAgICAgIHRyaWdnZXJlZC5cbiAqL1xuUHViU3ViQ2hhbm5lbC5OdWxsQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHsgfTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBhIGdpdmVuIGNhbGxiYWNrIGZyb20gYSBnaXZlbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICovXG5QdWJTdWJDaGFubmVsLk51bGxDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgfTtcblxuLy8gUmUtZW5hYmxlIFwidW51c2VkIHZhcmlhYmxlXCIgZXJyb3Jcbi8qIGpzaGludCB1bnVzZWQ6dHJ1ZSAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMgUHViU3ViQ2hhbm5lbFxuICovXG5QdWJTdWJDaGFubmVsLlB1c2hlckNoYW5uZWwgPSBmdW5jdGlvbiAocHVzaGVyQXBpQ2hhbm5lbCkge1xuICAvKipcbiAgICogVGhlIGFjdHVhbCBQdXNoZXIgQVBJJ3MgY2hhbm5lbC5cbiAgICogQHByaXZhdGUge0NoYW5uZWx9XG4gICAqL1xuICB0aGlzLnB1c2hlckNoYW5uZWxfID0gcHVzaGVyQXBpQ2hhbm5lbDtcblxuICAvKipcbiAgICogQ2FjaGUgcHJvdmlkZWQgY2FsbGJhY2tzIGZvciBlYXN5IHVuc3Vic2NyaWJlLlxuICAgKiBNYXBzIGV2ZW50IG5hbWUgdG8gY2FsbGJhY2suXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNhbGxiYWNrc18gPSB7fTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50IHNvIHRoZSBnaXZlbiBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IG9uIGRvdWJsZS1zdWJzY3JpYmUuXG4gKi9cblB1YlN1YkNoYW5uZWwuUHVzaGVyQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgdGhpcy5wdXNoZXJDaGFubmVsXy5iaW5kKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICBpZiAodGhpcy5jYWxsYmFja3NfW2V2ZW50TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3Vic2NyaWJlZCB0byBldmVudCBcIiArIGV2ZW50TmFtZSk7XG4gIH1cbiAgdGhpcy5jYWxsYmFja3NfW2V2ZW50TmFtZV0gPSBjYWxsYmFjaztcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgYSBnaXZlbiBjYWxsYmFjayBmcm9tIGEgZ2l2ZW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqL1xuUHViU3ViQ2hhbm5lbC5QdXNoZXJDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgdGhpcy5wdXNoZXJDaGFubmVsXy51bmJpbmQoZXZlbnROYW1lLCB0aGlzLmNhbGxiYWNrc19bZXZlbnROYW1lXSk7XG4gIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc19bZXZlbnROYW1lXTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBXcmFwcyByZW1vdGUgc3RvcmFnZSBpbnRlcmZhY2UgYW5kIHBvbGxpbmcgYmVoYXZpb3IuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDQsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCcuLi91dGlscycpLmdldExvZGFzaCgpO1xudmFyIE9ic2VydmFibGVFdmVudCA9IHJlcXVpcmUoJy4uL09ic2VydmFibGVFdmVudCcpO1xudmFyIE5ldFNpbUFwaSA9IHJlcXVpcmUoJy4vTmV0U2ltQXBpJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xudmFyIEFyZ3VtZW50VXRpbHMgPSByZXF1aXJlKCcuL0FyZ3VtZW50VXRpbHMnKTtcblxuLyoqXG4gKiBNYXhpbXVtIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhhdCB0YWJsZXMgc2hvdWxkIHdhaXQgYmV0d2VlbiBmdWxsIGNhY2hlXG4gKiB1cGRhdGVzIGZyb20gdGhlIHNlcnZlci5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBERUZBVUxUX1BPTExJTkdfREVMQVlfTVMgPSAxMDAwMDtcblxuLyoqXG4gKiBNaW5pbXVtIHRpbWUgKGluIG1zKSB0byB3YWl0IGFmdGVyIGFuIGludmFsaWRhdGlvbiBldmVudCBiZWZvcmUgYXR0ZW1wdGluZ1xuICogdG8gdHJpZ2dlciBhIHJlZnJlc2ggcmVxdWVzdC4gIFRoaXMgcHJvZHVjZXMgYSB3aW5kb3cgaW4gd2hpY2ggY2x1c3RlcmVkXG4gKiBpbnZhbGlkYXRpb25zIGNhbiBiZSBjYXB0dXJlZCBhbmQgY29hbGVzY2VkIHRvZ2V0aGVyLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIERFRkFVTFRfTUlOSU1VTV9ERUxBWV9CRUZPUkVfUkVGUkVTSF9NUyA9IDI1MDtcblxuLyoqXG4gKiBNYXhpbXVtIGFkZGl0aW9uYWwgcmFuZG9tIGRlbGF5IChpbiBtcykgdG8gYWRkIGJlZm9yZSB0aGUgcmVmcmVzaCByZXF1ZXN0LlxuICogSGVscHMgc3ByZWFkIG91dCByZXF1ZXN0cyBmcm9tIGRpZmZlcmVudCBjbGllbnRzIHJlc3BvbmRpbmcgdG8gdGhlIHNhbWVcbiAqIGludmFsaWRhdGlvbiBldmVudHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgREVGQVVMVF9NQVhJTVVNX0RFTEFZX0pJVFRFUl9NUyA9IDIwMDtcblxuLyoqXG4gKiBNaW5pbXVtIHRpbWUgKGluIG1zKSB0byB3YWl0IGJldHdlZW4gcmVmcmVzaCByZXF1ZXN0cywgcmVnYXJkbGVzcyBvZiBob3dcbiAqIG1hbnkgaW52YWxpZGF0aW9uIGV2ZW50cyBvY2N1ci5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBERUZBVUxUX01JTklNVU1fREVMQVlfQkVUV0VFTl9SRUZSRVNIRVNfTVMgPSAyNTAwO1xuXG4vKipcbiAqIFdyYXBzIHRoZSBhcHAgc3RvcmFnZSB0YWJsZSBBUEkgaW4gYW4gb2JqZWN0IHdpdGggbG9jYWxcbiAqIGNhY2hpbmcgYW5kIGNhbGxiYWNrcywgd2hpY2ggcHJvdmlkZXMgYSBub3RpZmljYXRpb24gQVBJIHRvIHRoZSByZXN0XG4gKiBvZiB0aGUgTmV0U2ltIGNvZGUuXG4gKiBAcGFyYW0geyFQdWJTdWJDaGFubmVsfSBjaGFubmVsIC0gVGhlIHB1YnN1YiBjaGFubmVsIHVzZWQgdG8gbGlzdGVuXG4gKiAgICAgICAgZm9yIGNoYW5nZXMgdG8gdGhlIHRhYmxlLmNlbGxQYWRkaW5nXG4gKiBAcGFyYW0geyFzdHJpbmd9IHNoYXJkSUQgLSBUaGUgc2hhcmQgSUQgc3BlY2lmaWMgdG8gdGhpcyBjbGFzcycgTmV0U2ltIGluc3RhbmNlLlxuICogQHBhcmFtIHshc3RyaW5nfSB0YWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVtb3RlIHN0b3JhZ2UgdGFibGUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIHRhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VJbmNyZW1lbnRhbFJlZnJlc2hdIC0gZGVmYXVsdHMgdG8gRkFMU0UuICBJZlxuICogICAgICAgIFRSVUUsIHRoaXMgdGFibGUgd2lsbCBvbmx5IHJlcXVlc3QgY29udGVudCB0aGF0IGlzIG5ldyBzaW5jZSBpdHNcbiAqICAgICAgICBsYXN0IHJlZnJlc2gsIG5vdCB0aGUgZW50aXJlIHRhYmxlIGNvbnRlbnRzLiAgQ3VycmVudGx5IHRoaXMgb3B0aW9uXG4gKiAgICAgICAgaXMgbm90IHNhZmUgdG8gdXNlIGlmIHlvdSBjYXJlIGFib3V0IHVwZGF0ZXMgb3IgZGVsZXRlcyBpbiB0aGUgdGFibGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluaW11bURlbGF5QmVmb3JlUmVmcmVzaF0gLSBNaW5pbXVtIHRpbWUgKGluIG1zKVxuICogICAgICAgIHRvIHdhaXQgYWZ0ZXIgYW4gaW52YWxpZGF0aW9uIGV2ZW50IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHRyaWdnZXIgYVxuICogICAgICAgIHJlZnJlc2ggcmVxdWVzdC4gIFRoaXMgcHJvZHVjZXMgYSB3aW5kb3cgaW4gd2hpY2ggY2x1c3RlcmVkXG4gKiAgICAgICAgaW52YWxpZGF0aW9ucyBjYW4gYmUgY2FwdHVyZWQgYW5kIGNvYWxlc2NlZCB0b2dldGhlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhpbXVtSml0dGVyRGVsYXldIC0gTWF4aW11bSBhZGRpdGlvbmFsIHJhbmRvbVxuICogICAgICAgIGRlbGF5IChpbiBtcykgdG8gYWRkIGJlZm9yZSB0aGUgcmVmcmVzaCByZXF1ZXN0LiAgSGVscHMgc3ByZWFkIG91dFxuICogICAgICAgIHJlcXVlc3RzIGZyb20gZGlmZmVyZW50IGNsaWVudHMgcmVzcG9uZGluZyB0byB0aGUgc2FtZSBpbnZhbGlkYXRpb25cbiAqICAgICAgICBldmVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluaW11bURlbGF5QmV0d2VlblJlZnJlc2hlc10gLSBNaW5pbXVtIHRpbWUgKGluIG1zKVxuICogICAgICAgIHRvIHdhaXQgYmV0d2VlbiByZWZyZXNoIHJlcXVlc3RzLCByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGludmFsaWRhdGlvblxuICogICAgICAgIGV2ZW50cyBvY2N1ci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHRocm93cyB7RXJyb3J9IGlmIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBpbnZhbGlkIHR5cGVzIGFyZSBwYXNzZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICovXG52YXIgTmV0U2ltVGFibGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFubmVsLCBzaGFyZElELCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgQXJndW1lbnRVdGlscy52YWxpZGF0ZVJlcXVpcmVkKGNoYW5uZWwsICdjaGFubmVsJyk7XG4gIEFyZ3VtZW50VXRpbHMudmFsaWRhdGVSZXF1aXJlZChzaGFyZElELCAnc2hhcmRJRCcsIEFyZ3VtZW50VXRpbHMuaXNTdHJpbmcpO1xuICBBcmd1bWVudFV0aWxzLnZhbGlkYXRlUmVxdWlyZWQodGFibGVOYW1lLCAndGFibGVOYW1lJywgQXJndW1lbnRVdGlscy5pc1N0cmluZyk7XG4gIG9wdGlvbnMgPSBBcmd1bWVudFV0aWxzLmV4dGVuZE9wdGlvbnNPYmplY3Qob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLnRhYmxlTmFtZV8gPSB0YWJsZU5hbWU7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtQdWJTdWJDaGFubmVsfVxuICAgKi9cbiAgdGhpcy5jaGFubmVsXyA9IGNoYW5uZWw7XG4gIHRoaXMuc3Vic2NyaWJlKCk7XG5cbiAgLyoqXG4gICAqIEFQSSBvYmplY3QgZm9yIG1ha2luZyByZW1vdGUgY2FsbHNcbiAgICogQHR5cGUge05ldFNpbUFwaX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYXBpXyA9IE5ldFNpbUFwaS5tYWtlVGFibGVBcGkoc2hhcmRJRCwgdGFibGVOYW1lKTtcblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBmaXJlcyB3aGVuIGZ1bGwgdGFibGUgdXBkYXRlcyBpbmRpY2F0ZSBhIGNoYW5nZSxcbiAgICogd2hlbiByb3dzIGFyZSBhZGRlZCwgb3Igd2hlbiByb3dzIGFyZSByZW1vdmVkLCBvciB3aGVuIHJvd3MgY2hhbmdlLlxuICAgKiBAdHlwZSB7T2JzZXJ2YWJsZUV2ZW50fVxuICAgKi9cbiAgdGhpcy50YWJsZUNoYW5nZSA9IG5ldyBPYnNlcnZhYmxlRXZlbnQoKTtcblxuICAvKipcbiAgICogU3RvcmUgdGFibGUgY29udGVudHMgbG9jYWxseSwgc28gd2UgY2FuIGRldGVjdCB3aGVuIGNoYW5nZXMgb2NjdXIuXG4gICAqIEBwcml2YXRlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgcm93IElEIG9mIHRoZSBtb3N0IHJlY2VudGx5IGluc2VydGVkIHJvdyByZXRyaWV2ZWQgZnJvbSByZW1vdGUgc3RvcmFnZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubGF0ZXN0Um93SURfID0gMDtcblxuICAvKipcbiAgICogVW5peCB0aW1lc3RhbXAgZm9yIGxhc3QgdGltZSB0aGlzIHRhYmxlJ3MgY2FjaGUgY29udGVudHMgd2VyZSBmdWxseVxuICAgKiB1cGRhdGVkLiAgVXNlZCB0byBkZXRlcm1pbmUgd2hlbiB0byBwb2xsIHRoZSBzZXJ2ZXIgZm9yIGNoYW5nZXMuXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmxhc3RSZWZyZXNoVGltZV8gPSAwO1xuXG4gIC8qKlxuICAgKiBJZiBUUlVFLCB3aWxsIG9ubHkgcmVxdWVzdCBkZWx0YXMgZnJvbSByZW1vdGUgc3RvcmFnZS4gIEN1cnJlbnRseVxuICAgKiB1bnNhZmUgaWYgd2UgY2FyZSBhYm91dCBtb3JlIHRoYW4gaW5zZXJ0cyB0byB0aGUgdGFibGUuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy51c2VJbmNyZW1lbnRhbFJlZnJlc2hfID0gb3B0aW9ucy5nZXQoXG4gICAgICAndXNlSW5jcmVtZW50YWxSZWZyZXNoJyxcbiAgICAgIEFyZ3VtZW50VXRpbHMuaXNCb29sZWFuLFxuICAgICAgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIHRpbWUgKGluIG1zKSB0byB3YWl0IGFmdGVyIGFuIGludmFsaWRhdGlvbiBldmVudCBiZWZvcmUgYXR0ZW1wdGluZ1xuICAgKiB0byB0cmlnZ2VyIGEgcmVmcmVzaCByZXF1ZXN0LiAgVGhpcyBwcm9kdWNlcyBhIHdpbmRvdyBpbiB3aGljaCBjbHVzdGVyZWRcbiAgICogaW52YWxpZGF0aW9ucyBjYW4gYmUgY2FwdHVyZWQgYW5kIGNvYWxlc2NlZCB0b2dldGhlci5cbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluaW11bURlbGF5QmVmb3JlUmVmcmVzaF8gPSBvcHRpb25zLmdldChcbiAgICAgICdtaW5pbXVtRGVsYXlCZWZvcmVSZWZyZXNoJyxcbiAgICAgIEFyZ3VtZW50VXRpbHMuaXNQb3NpdGl2ZU5vbmluZmluaXRlTnVtYmVyLFxuICAgICAgREVGQVVMVF9NSU5JTVVNX0RFTEFZX0JFRk9SRV9SRUZSRVNIX01TKTtcblxuICAvKipcbiAgICogTWF4aW11bSBhZGRpdGlvbmFsIHJhbmRvbSBkZWxheSAoaW4gbXMpIHRvIGFkZCBiZWZvcmUgdGhlIHJlZnJlc2ggcmVxdWVzdC5cbiAgICogSGVscHMgc3ByZWFkIG91dCByZXF1ZXN0cyBmcm9tIGRpZmZlcmVudCBjbGllbnRzIHJlc3BvbmRpbmcgdG8gdGhlIHNhbWVcbiAgICogaW52YWxpZGF0aW9uIGV2ZW50cy5cbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4aW11bUppdHRlckRlbGF5XyA9IG9wdGlvbnMuZ2V0KFxuICAgICAgJ21heGltdW1KaXR0ZXJEZWxheScsXG4gICAgICBBcmd1bWVudFV0aWxzLmlzUG9zaXRpdmVOb25pbmZpbml0ZU51bWJlcixcbiAgICAgIERFRkFVTFRfTUFYSU1VTV9ERUxBWV9KSVRURVJfTVMpO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIHRpbWUgKGluIG1zKSB0byB3YWl0IGJldHdlZW4gcmVmcmVzaCByZXF1ZXN0cywgcmVnYXJkbGVzcyBvZiBob3dcbiAgICogbWFueSBpbnZhbGlkYXRpb24gZXZlbnRzIG9jY3VyLlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5pbXVtRGVsYXlCZXR3ZWVuUmVmcmVzaGVzXyA9IG9wdGlvbnMuZ2V0KFxuICAgICAgJ21pbmltdW1EZWxheUJldHdlZW5SZWZyZXNoZXMnLFxuICAgICAgQXJndW1lbnRVdGlscy5pc1Bvc2l0aXZlTm9uaW5maW5pdGVOdW1iZXIsXG4gICAgICBERUZBVUxUX01JTklNVU1fREVMQVlfQkVUV0VFTl9SRUZSRVNIRVNfTVMpO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBiZXR3ZWVuIHB1bGxpbmcgZnVsbCB0YWJsZSBjb250ZW50c1xuICAgKiBmcm9tIHJlbW90ZSBzdG9yYWdlLlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5wb2xsaW5nSW50ZXJ2YWxfID0gREVGQVVMVF9QT0xMSU5HX0RFTEFZX01TO1xuXG4gIC8qKlxuICAgKiBUaHJvdHRsZWQgdmVyc2lvbiAoc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSkgb2YgdGhlIHJlZnJlc2ggb3BlcmF0aW9uLFxuICAgKiB1c2VkIHRvIGNvYWxlc2NlIHJlZnJlc2ggcmVxdWVzdHMuXG4gICAqIEBwcml2YXRlIHtmdW5jdGlvbn1cbiAgICovXG4gIHRoaXMucmVmcmVzaFRhYmxlXyA9IHRoaXMubWFrZVRocm90dGxlZFJlZnJlc2hfKCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjb25maWd1cmVkIHRhYmxlIG5hbWUuXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5nZXRUYWJsZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhYmxlTmFtZV87XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgdGhpcyB0YWJsZSdzIG9uUHViU3ViRXZlbnQgbWV0aG9kIHRvIGV2ZW50cyBmb3IgdGhpcyB0YWJsZVxuICogb24gb3VyIGxvY2FsIGNoYW5uZWwuXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hhbm5lbF8uc3Vic2NyaWJlKHRoaXMudGFibGVOYW1lXyxcbiAgICAgIE5ldFNpbVRhYmxlLnByb3RvdHlwZS5vblB1YlN1YkV2ZW50Xy5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogVW51YnNjcmliZXMgdGhlIHNhdmVkIGNhbGxiYWNrIGZyb20gZXZlbnRzIGZvciB0aGlzIHRhYmxlIG9uIG91clxuICogbG9jYWwgY2hhbm5lbC5cbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNoYW5uZWxfLnVuc3Vic2NyaWJlKHRoaXMudGFibGVOYW1lXyk7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJldHJpZXZlIG5ldy91cGRhdGVkIHRhYmxlIGNvbnRlbnQgZnJvbSB0aGUgc2VydmVyLCB1c2luZ1xuICogd2hhdGV2ZXIgbWV0aG9kIGlzIG1vc3QgYXBwcm9wcmlhdGUgdG8gdGhpcyB0YWJsZSdzIGNvbmZpZ3VyYXRpb24uXG4gKiBXaGVuIGRvbmUsIHVwZGF0ZXMgdGhlIGxvY2FsIGNhY2hlIGFuZCBoaXRzIHRoZSBwcm92aWRlZCBjYWxsYmFjayB0b1xuICogaW5kaWNhdGUgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IFtjYWxsYmFja10gLSBpbmRpY2F0ZXMgY29tcGxldGlvbiBvZiB0aGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge2pRdWVyeS5Qcm9taXNlfSBHdWFyYW50ZWVkIHRvIHJlc29sdmUgYWZ0ZXIgdGhlIGNhY2hlIHVwZGF0ZSxcbiAqICAgICAgICAgIHNvIC5kb25lKCkgb3BlcmF0aW9ucyBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgY2FjaGUuXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuICAvLyBXaGljaCBBUEkgY2FsbCB0byBtYWtlXG4gIHZhciBhcGlDYWxsID0gdGhpcy51c2VJbmNyZW1lbnRhbFJlZnJlc2hfID9cbiAgICAgIHRoaXMuYXBpXy5hbGxSb3dzRnJvbUlELmJpbmQodGhpcy5hcGlfLCB0aGlzLmxhdGVzdFJvd0lEXyArIDEpIDpcbiAgICAgIHRoaXMuYXBpXy5hbGxSb3dzLmJpbmQodGhpcy5hcGlfKTtcblxuICAvLyBIb3cgdG8gdXBkYXRlIHRoZSBjYWNoZSAoZGVwZW5kcyBvbiB3aGF0IHdlIGV4cGVjdCB0byBnZXQgYmFjaylcbiAgdmFyIGNhY2hlVXBkYXRlID0gdGhpcy51c2VJbmNyZW1lbnRhbFJlZnJlc2hfID9cbiAgICAgIHRoaXMuaW5jcmVtZW50YWxDYWNoZVVwZGF0ZV8uYmluZCh0aGlzKSA6XG4gICAgICB0aGlzLmZ1bGxDYWNoZVVwZGF0ZV8uYmluZCh0aGlzKTtcblxuICAvLyBXaGF0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgQVBJIGNhbGwgY29tcGxldGVzLlxuICB2YXIgYXBpQ2FsbENhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVVcGRhdGUoZGF0YSk7XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEbyB3ZSBmaXJlIHRoZSBBUEkgY2FsbCBub3csIG9yIGFmdGVyIGEgcmFuZG9tIGRlbGF5P1xuICBpZiAodGhpcy5tYXhpbXVtSml0dGVyRGVsYXlfID09PSAwKSB7XG4gICAgYXBpQ2FsbChhcGlDYWxsQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZhciBqaXR0ZXJUaW1lID0gTmV0U2ltR2xvYmFscy5yYW5kb21JbnRJblJhbmdlKDAsIHRoaXMubWF4aW11bUppdHRlckRlbGF5Xyk7XG4gICAgc2V0VGltZW91dChhcGlDYWxsLmJpbmQodGhpcywgYXBpQ2FsbENhbGxiYWNrKSwgaml0dGVyVGltZSk7XG4gIH1cblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aHJvdHRsZWQgcmVmcmVzaCBmdW5jdGlvbiB3aGljaCB3aWxsIGdlbmVyYXRlIGFjdHVhbCBzZXJ2ZXJcbiAqIHJlcXVlc3RzIGF0IHRoZSBtYXhpbXVtIGdpdmVuIHJhdGUgbm8gbWF0dGVyIGhvdyBmYXN0IGl0IGlzIGNhbGxlZC4gVGhpc1xuICogYWxsb3dzIHVzIHRvIGNvYWxlc2NlIHJlZnJlc2hBbGwgZXZlbnRzIGFuZCByZWR1Y2Ugc2VydmVyIGxvYWQuXG4gKlxuICogSG93IHRoaXMgd29ya3M6XG4gKiBXcmFwcyBhIGxvbmdlciB0aHJvdHRsZSB3aXRoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGV2ZW50cyBpbiBhIHNob3J0ZXIgZGVib3VuY2VcbiAqIHdpdGggYSBtYXhpbXVtIHdhaXQgdGltZS4gIFRoaXMgZ2l2ZXMgZ3JvdXBlZCBldmVudHMgYSBjaGFuY2UgdG8gY29hbGVzY2VcbiAqIHdpdGhvdXQgdHJpZ2dlcmluZyBhbiB1bm5lZWRlZCB0cmFpbGluZyBldmVudCBvbiB0aGUgbG9uZ2VyIHRocm90dGxlLlxuICpcbiAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXMgb2Ygd2hhdCdzIGdvaW5nIG9uLCBpZiB1c2luZyBhIDEwMDBtcyB0aHJvdHRsZVxuICogd3JhcHBlZCBpbiBhIDI1MG1zIGRlYm91bmNlLlxuICpcbiAqIEluIGxvdyB0cmFmZmljIHdlIGNvbGxhcHNlIHR3byBncm91cHMgb2YgZXZlbnRzIHRvIGp1c3QgdHdvIGV2ZW50cy5cbiAqXG4gKiBvcmlnaW5hbCBldmVudHMgICA6ICAgfHwgfCAgICAgICAgICAgICAgICAgICAgIHwgfFxuICogZGVib3VuY2VkICAgICAgICAgOiAgIC0yNTA+fCAgICAgICAgICAgICAgICAgICAtMjUwPnxcbiAqIHRoZW4gdGhyb3R0bGVkICAgIDogICAgICAgIHwtLS0tLS0tLS0tLS0tLTEwMDAtPiAgICB8LS0tLS0tLS0tLS0tLS0xMDAwLT5cbiAqXG4gKiBJbiBoaWdoZXIgdHJhZmZpYyB3ZSBjb2xsYXBzZSB0aGUgZ3JvdXBzIGJ1dCBzdGlsbCBrZWVwIGV2ZW50cyBhdCBsZWFzdFxuICogb25lIHNlY29uZCBhcGFydC5cbiAqXG4gKiBvcmlnaW5hbCBldmVudHMgICA6ICAgfHwgfCAgICAgICAgfCAgICAgfCAgICAgIHwgfFxuICogZGVib3VuY2VkICAgICAgICAgOiAgIC0yNTA+fCAgICAgIC0yNTA+fC0yNTA+fCAtMjUwPnxcbiAqIHRoZW4gdGhyb3R0bGVkICAgIDogICAgICAgIHwtLS0tLS0tLS0tLS0tLTEwMDAtPnwtLS0tLS0tLS0tLS0tLTEwMDAtPnxcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5tYWtlVGhyb3R0bGVkUmVmcmVzaF8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aHJvdHRsZWRSZWZyZXNoID0gXy50aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSxcbiAgICAgIHRoaXMubWluaW11bURlbGF5QmV0d2VlblJlZnJlc2hlc18pO1xuICByZXR1cm4gXy5kZWJvdW5jZSh0aHJvdHRsZWRSZWZyZXNoLCB0aGlzLm1pbmltdW1EZWxheUJlZm9yZVJlZnJlc2hfLFxuICAgICAge21heFdhaXQ6IHRoaXMubWluaW11bURlbGF5QmVmb3JlUmVmcmVzaF99KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0FycmF5fSBhbGwgbG9jYWxseSBjYWNoZWQgdGFibGUgcm93c1xuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUucmVhZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlGcm9tQ2FjaGVfKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IW51bWJlcn0gZmlyc3RSb3dJRFxuICogQHJldHVybnMge0FycmF5fSBhbGwgbG9jYWxseSBjYWNoZWQgdGFibGUgcm93cyBoYXZpbmcgcm93IElEID49IGZpcnN0Um93SURcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnJlYWRBbGxGcm9tSUQgPSBmdW5jdGlvbiAoZmlyc3RSb3dJRCkge1xuICByZXR1cm4gdGhpcy5hcnJheUZyb21DYWNoZV8oZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgPj0gZmlyc3RSb3dJRDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IW51bWJlcn0gaWRcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgdGhpcy5hcGlfLmZldGNoUm93KGlkLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDYWNoZVJvd18oaWQsIGRhdGEpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaykge1xuICB0aGlzLmFwaV8uY3JlYXRlUm93KHZhbHVlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRSb3dUb0NhY2hlXyhkYXRhKTtcbiAgICB9XG4gICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVzXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLm11bHRpQ3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlcywgY2FsbGJhY2spIHtcbiAgdGhpcy5hcGlfLmNyZWF0ZVJvdyh2YWx1ZXMsIGZ1bmN0aW9uIChlcnIsIGRhdGFzKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgZGF0YXMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmFkZFJvd1RvQ2FjaGVfKGRhdGEpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGNhbGxiYWNrKGVyciwgZGF0YXMpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFudW1iZXJ9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgdGhpcy5hcGlfLnVwZGF0ZVJvdyhpZCwgdmFsdWUsIGZ1bmN0aW9uIChlcnIsIHN1Y2Nlc3MpIHtcbiAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhY2hlUm93XyhpZCwgdmFsdWUpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFudW1iZXJ9IGlkXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgdGhpcy5kZWxldGVNYW55KFtpZF0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBtdWx0aXBsZSByb3dzIGZyb20gdGhlIHRhYmxlLlxuICogQHBhcmFtIHshbnVtYmVyW119IGlkc1xuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5kZWxldGVNYW55ID0gZnVuY3Rpb24gKGlkcywgY2FsbGJhY2spIHtcbiAgdGhpcy5hcGlfLmRlbGV0ZVJvd3MoaWRzLCBmdW5jdGlvbiAoZXJyLCBzdWNjZXNzKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yZW1vdmVSb3dzRnJvbUNhY2hlXyhpZHMpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSByb3cgdXNpbmcgYSBzeW5jaHJvbm91cyBjYWxsLiBGb3IgdXNlIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb21cbiAqIHRoZSBwYWdlOyBtb3N0IG9mIHRoZSB0aW1lIGFuIGFzeW5jaHJvbm91cyBjYWxsIGlzIHByZWZlcnJlZC5cbiAqIEBwYXJhbSB7IW51bWJlcn0gaWRcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnN5bmNocm9ub3VzRGVsZXRlID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBhc3luYyA9IGZhbHNlOyAvLyBGb3JjZSBzeW5jaHJvbm91cyByZXF1ZXN0XG4gIHRoaXMuYXBpXy5kZWxldGVSb3dzKFtpZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBOb3RoaW5nIHdlIGNhbiByZWFsbHkgZG8gd2l0aCB0aGUgZXJyb3IsIGFzIHdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mXG4gICAgICAvLyBuYXZpZ2F0aW5nIGF3YXkuIFRocm93IHNvIHRoYXQgaGlnaCBpbmNpZGVuY2UgcmF0ZXMgd2lsbCBzaG93IHVwIGluXG4gICAgICAvLyBuZXcgcmVsaWMuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlUm93c0Zyb21DYWNoZV8oW2lkXSk7XG4gIH0uYmluZCh0aGlzKSwgYXN5bmMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBhbGxSb3dzXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUuZnVsbENhY2hlVXBkYXRlXyA9IGZ1bmN0aW9uIChhbGxSb3dzKSB7XG4gIC8vIFJlYnVpbGQgZW50aXJlIGNhY2hlXG4gIHZhciBtYXhSb3dJRCA9IDA7XG4gIHZhciBuZXdDYWNoZSA9IGFsbFJvd3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50Um93KSB7XG4gICAgcHJldltjdXJyZW50Um93LmlkXSA9IGN1cnJlbnRSb3c7XG4gICAgaWYgKGN1cnJlbnRSb3cuaWQgPiBtYXhSb3dJRCkge1xuICAgICAgbWF4Um93SUQgPSBjdXJyZW50Um93LmlkO1xuICAgIH1cbiAgICByZXR1cm4gcHJldjtcbiAgfSwge30pO1xuXG4gIC8vIENoZWNrIGZvciBjaGFuZ2VzLCBpZiBhbnl0aGluZyBjaGFuZ2VkIG5vdGlmeSBhbGwgb2JzZXJ2ZXJzIG9uIHRhYmxlLlxuICBpZiAoIV8uaXNFcXVhbCh0aGlzLmNhY2hlXywgbmV3Q2FjaGUpKSB7XG4gICAgdGhpcy5jYWNoZV8gPSBuZXdDYWNoZTtcbiAgICB0aGlzLmxhdGVzdFJvd0lEXyA9IG1heFJvd0lEO1xuICAgIHRoaXMudGFibGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gIH1cblxuICB0aGlzLmxhc3RSZWZyZXNoVGltZV8gPSBEYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBBZGQgYW5kIHVwZGF0ZSByb3dzIGluIHRoZSBsb2NhbCBjYWNoZSBmcm9tIHRoZSBnaXZlbiBzZXQgb2YgbmV3IHJvd3NcbiAqIChwcm9iYWJseSByZXRyaWV2ZWQgZnJvbSB0aGUgc2VydmVyKS5cbiAqIEBwYXJhbSB7QXJyYXl9IG5ld1Jvd3NcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5pbmNyZW1lbnRhbENhY2hlVXBkYXRlXyA9IGZ1bmN0aW9uIChuZXdSb3dzKSB7XG4gIGlmIChuZXdSb3dzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbWF4Um93SUQgPSAwO1xuICAgIG5ld1Jvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICB0aGlzLmNhY2hlX1tyb3cuaWRdID0gcm93O1xuICAgICAgbWF4Um93SUQgPSBNYXRoLm1heChtYXhSb3dJRCwgcm93LmlkKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmxhdGVzdFJvd0lEXyA9IG1heFJvd0lEO1xuICAgIHRoaXMudGFibGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gIH1cblxuICB0aGlzLmxhc3RSZWZyZXNoVGltZV8gPSBEYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IHJvd1xuICogQHBhcmFtIHshbnVtYmVyfSByb3cuaWRcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5hZGRSb3dUb0NhY2hlXyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgdGhpcy5jYWNoZV9bcm93LmlkXSA9IHJvdztcbiAgdGhpcy50YWJsZUNoYW5nZS5ub3RpZnlPYnNlcnZlcnMoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshbnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnJlbW92ZVJvd3NGcm9tQ2FjaGVfID0gZnVuY3Rpb24gKGlkcykge1xuICB2YXIgY2FjaGVDaGFuZ2VkID0gZmFsc2U7XG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIGlmICh0aGlzLmNhY2hlX1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2lkXTtcbiAgICAgIGNhY2hlQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBpZiAoY2FjaGVDaGFuZ2VkKSB7XG4gICAgdGhpcy50YWJsZUNoYW5nZS5ub3RpZnlPYnNlcnZlcnMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyFudW1iZXJ9IGlkXG4gKiBAcGFyYW0geyFPYmplY3R9IHJvd1xuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnVwZGF0ZUNhY2hlUm93XyA9IGZ1bmN0aW9uIChpZCwgcm93KSB7XG4gIHZhciBvbGRSb3cgPSB0aGlzLmNhY2hlX1tpZF07XG4gIHZhciBuZXdSb3cgPSByb3c7XG5cbiAgLy8gTWFudWFsbHkgYXBwbHkgSURzIHdoaWNoIHNob3VsZCBiZSBwcmVzZW50IGluIHJvdy5cbiAgbmV3Um93LmlkID0gaWQ7XG4gIG5ld1Jvdy51dWlkID0gb2xkUm93LnV1aWQ7XG5cbiAgaWYgKCFfLmlzRXF1YWwob2xkUm93LCBuZXdSb3cpKSB7XG4gICAgdGhpcy5jYWNoZV9baWRdID0gbmV3Um93O1xuICAgIHRoaXMudGFibGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihrZXksIHZhbHVlKX0gW3ByZWRpY2F0ZV0gLSBBIGNvbmRpdGlvbiBvbiByZXR1cm5pbmcgdGhlIHJvdy5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS5hcnJheUZyb21DYWNoZV8gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGsgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICBpZiAodGhpcy5jYWNoZV8uaGFzT3duUHJvcGVydHkoaykgJiYgcHJlZGljYXRlKGssIHRoaXMuY2FjaGVfW2tdKSkge1xuICAgICAgcmVzdWx0LnB1c2godGhpcy5jYWNoZV9ba10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIGhvdyBvZnRlbiB0aGlzIHRhYmxlIGZldGNoZXMgYSBmdWxsIHRhYmxlIHVwZGF0ZSBmcm9tIHRoZVxuICogc2VydmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsTXMgLSBtaWxsaXNlY29uZHMgb2YgZGVsYXkgYmV0d2VlbiB1cGRhdGVzLlxuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUuc2V0UG9sbGluZ0ludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsTXMpIHtcbiAgdGhpcy5wb2xsaW5nSW50ZXJ2YWxfID0gaW50ZXJ2YWxNcztcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBtYXhpbXVtIHJhdGUgYXQgd2hpY2ggdGhlIHJlZnJlc2ggb3BlcmF0aW9uIGZvciB0aGlzIHRhYmxlXG4gKiB3aWxsIF9hY3R1YWxseV8gYmUgZXhlY3V0ZWQsIG5vIG1hdHRlciBob3cgZmFzdCB3ZSByZWNlaXZlIGludmFsaWRhdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlNcyAtIE1pbmltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgIGJldHdlZW4gaW52YWxpZGF0aW9uLXRyaWdnZXJlZCByZXF1ZXN0cyB0byB0aGUgc2VydmVyLlxuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUuc2V0TWluaW11bURlbGF5QmV0d2VlblJlZnJlc2hlcyA9IGZ1bmN0aW9uIChkZWxheU1zKSB7XG4gIC8vIFRvIGRvIHRoaXMsIHdlIGp1c3QgcmVwbGFjZSB0aGUgdGhyb3R0bGVkIHJlZnJlc2ggZnVuY3Rpb24gd2l0aCBhIG5ldyBvbmUuXG4gIHRoaXMubWluaW11bURlbGF5QmV0d2VlblJlZnJlc2hlc18gPSBkZWxheU1zO1xuICB0aGlzLnJlZnJlc2hUYWJsZV8gPSB0aGlzLm1ha2VUaHJvdHRsZWRSZWZyZXNoXygpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG1pbmltdW0gdGltZSAoaW4gbXMpIHRvIHdhaXQgYWZ0ZXIgYW4gaW52YWxpZGF0aW9uIGV2ZW50IGJlZm9yZVxuICogYXR0ZW1wdGluZyB0byB0cmlnZ2VyIGEgcmVmcmVzaCByZXF1ZXN0LiAgVGhpcyBwcm9kdWNlcyBhIHdpbmRvdyBpbiB3aGljaFxuICogY2x1c3RlcmVkIGludmFsaWRhdGlvbnMgY2FuIGJlIGNhcHR1cmVkIGFuZCBjb2FsZXNjZWQgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlNcyAtIE1pbmltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGZpcnN0XG4gKiAgICAgICAgaW52YWxpZGF0aW9uIGFuZCByZXF1ZXN0IHRvIHNlcnZlci5cbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLnNldE1pbmltdW1EZWxheUJlZm9yZVJlZnJlc2ggPSBmdW5jdGlvbiAoZGVsYXlNcykge1xuICAvLyBUbyBkbyB0aGlzLCB3ZSBqdXN0IHJlcGxhY2UgdGhlIHRocm90dGxlZCByZWZyZXNoIGZ1bmN0aW9uIHdpdGggYSBuZXcgb25lLlxuICB0aGlzLm1pbmltdW1EZWxheUJlZm9yZVJlZnJlc2hfID0gZGVsYXlNcztcbiAgdGhpcy5yZWZyZXNoVGFibGVfID0gdGhpcy5tYWtlVGhyb3R0bGVkUmVmcmVzaF8oKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBNYXhpbXVtIGFkZGl0aW9uYWwgcmFuZG9tIGRlbGF5IChpbiBtcykgdG8gYWRkIGJlZm9yZSB0aGUgcmVmcmVzaFxuICogcmVxdWVzdC4gIEhlbHBzIHNwcmVhZCBvdXQgcmVxdWVzdHMgZnJvbSBkaWZmZXJlbnQgY2xpZW50cyByZXNwb25kaW5nIHRvIHRoZVxuICogc2FtZSBldmVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlNcyAtIE1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBhZGQgYmVmb3JlXG4gKiAgICAgICAgcmVmcmVzaCByZXF1ZXN0IGZpcmVzLlxuICovXG5OZXRTaW1UYWJsZS5wcm90b3R5cGUuc2V0TWF4aW11bUppdHRlckRlbGF5ID0gZnVuY3Rpb24gKGRlbGF5TXMpIHtcbiAgLy8gVG8gZG8gdGhpcywgd2UganVzdCByZXBsYWNlIHRoZSB0aHJvdHRsZWQgcmVmcmVzaCBmdW5jdGlvbiB3aXRoIGEgbmV3IG9uZS5cbiAgdGhpcy5tYXhpbXVtSml0dGVyRGVsYXlfID0gZGVsYXlNcztcbn07XG5cbi8qKiBQb2xscyBzZXJ2ZXIgZm9yIHVwZGF0ZXMsIGlmIGl0J3MgYmVlbiBsb25nIGVub3VnaC4gKi9cbk5ldFNpbVRhYmxlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKG5vdyAtIHRoaXMubGFzdFJlZnJlc2hUaW1lXyA+PSB0aGlzLnBvbGxpbmdJbnRlcnZhbF8pIHtcbiAgICB0aGlzLmxhc3RSZWZyZXNoVGltZV8gPSBub3c7XG4gICAgdGhpcy5yZWZyZXNoVGFibGVfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIFB1YlN1YiBzZXJ2aWNlIGZpcmVzIGFuIGV2ZW50IHRoYXQgdGhpcyB0YWJsZSBpcyBzdWJzY3JpYmVkIHRvLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltVGFibGUucHJvdG90eXBlLm9uUHViU3ViRXZlbnRfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlZnJlc2hUYWJsZV8oKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb250cm9sbGVyIGZvciB0aGUgc2VuZCBwYW5lbCAodGhlIGJvdHRvbSBwYW5lbCBvbiB0aGUgcmlnaHQpXG4gKiAgICAgICAgICAgd2hpY2ggaXMgdXNlZCB0byB0cmFuc21pdCBwYWNrZXRzLlxuICogQHNlZSBOZXRTaW1QYWNrZXRFZGl0b3Igd2hpY2ggaXMgdXNlZCBleHRlbnNpdmVseSBoZXJlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4cGFyYW1zOiAzLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1TZW5kUGFuZWwuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1QYW5lbCA9IHJlcXVpcmUoJy4vTmV0U2ltUGFuZWwnKTtcbnZhciBOZXRTaW1QYWNrZXRFZGl0b3IgPSByZXF1aXJlKCcuL05ldFNpbVBhY2tldEVkaXRvcicpO1xudmFyIE5ldFNpbVBhY2tldFNpemVDb250cm9sID0gcmVxdWlyZSgnLi9OZXRTaW1QYWNrZXRTaXplQ29udHJvbCcpO1xudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vUGFja2V0Jyk7XG52YXIgRGF0YUNvbnZlcnRlcnMgPSByZXF1aXJlKCcuL0RhdGFDb252ZXJ0ZXJzJyk7XG52YXIgTmV0U2ltQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9OZXRTaW1Db25zdGFudHMnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbnZhciBFbmNvZGluZ1R5cGUgPSBOZXRTaW1Db25zdGFudHMuRW5jb2RpbmdUeXBlO1xudmFyIE1lc3NhZ2VHcmFudWxhcml0eSA9IE5ldFNpbUNvbnN0YW50cy5NZXNzYWdlR3JhbnVsYXJpdHk7XG52YXIgQklUU19QRVJfQllURSA9IE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9CWVRFO1xuXG52YXIgYmluYXJ5VG9BQiA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQUI7XG5cbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuL05ldFNpbUxvZ2dlcicpLmdldFNpbmdsZXRvbigpO1xuXG4vKipcbiAqIEdlbmVyYXRvciBhbmQgY29udHJvbGxlciBmb3IgbWVzc2FnZSBzZW5kaW5nIHZpZXcuXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdlxuICogQHBhcmFtIHtOZXRTaW1MZXZlbENvbmZpZ3VyYXRpb259IGxldmVsQ29uZmlnXG4gKiBAcGFyYW0ge05ldFNpbX0gbmV0c2ltXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1QYW5lbFxuICovXG52YXIgTmV0U2ltU2VuZFBhbmVsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdiwgbGV2ZWxDb25maWcsXG4gICAgbmV0c2ltKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOZXRTaW1MZXZlbENvbmZpZ3VyYXRpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmxldmVsQ29uZmlnXyA9IGxldmVsQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7UGFja2V0LkhlYWRlclR5cGVbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucGFja2V0U3BlY18gPSBsZXZlbENvbmZpZy5jbGllbnRJbml0aWFsUGFja2V0SGVhZGVyO1xuXG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHRoYXQgb3ducyB0aGUgcm91dGVyIHdlIHdpbGwgcmVwcmVzZW50IC8gbWFuaXB1bGF0ZVxuICAgKiBAdHlwZSB7TmV0U2ltfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5uZXRzaW1fID0gbmV0c2ltO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGNvbnRyb2xsZXJzIGZvciBwYWNrZXRzIGN1cnJlbnRseSBiZWluZyBlZGl0ZWQuXG4gICAqIEB0eXBlIHtOZXRTaW1QYWNrZXRFZGl0b3JbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucGFja2V0c18gPSBbXTtcblxuICAvKipcbiAgICogT3VyIGxvY2FsIG5vZGUncyBhZGRyZXNzLCB6ZXJvIHVudGlsIGFzc2lnbmVkIGJ5IGEgcm91dGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5mcm9tQWRkcmVzc18gPSAwO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIHBhY2tldCBsZW5ndGggY29uZmlndXJhYmxlIGJ5IHNsaWRlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubWF4UGFja2V0U2l6ZV8gPSBsZXZlbENvbmZpZy5kZWZhdWx0UGFja2V0U2l6ZUxpbWl0O1xuXG4gIC8qKlxuICAgKiBCeXRlLXNpemUgdXNlZCBmb3IgZm9ybWF0dGluZyBiaW5hcnkgYW5kIGZvciBpbnRlcnByZXRpbmcgaXRcbiAgICogdG8gZGVjaW1hbCBvciBBU0NJSS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2h1bmtTaXplXyA9IEJJVFNfUEVSX0JZVEU7XG5cbiAgLyoqXG4gICAqIExvY2FsIGRldmljZSBiaXRyYXRlIGluIGJpdHMtcGVyLXNlY29uZCwgd2hpY2ggYWZmZWN0cyBzZW5kIGFuaW1hdGlvblxuICAgKiBzcGVlZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYml0UmF0ZV8gPSBJbmZpbml0eTtcblxuICAvKipcbiAgICogV2hhdCBlbmNvZGluZ3MgYXJlIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZGlzcGxheWVkIGluIGVhY2hcbiAgICogcGFja2V0IGFuZCBwYWNrZXQgZWRpdG9yLlxuICAgKiBAdHlwZSB7RW5jb2RpbmdUeXBlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVuYWJsZWRFbmNvZGluZ3NfID0gbGV2ZWxDb25maWcuZGVmYXVsdEVuYWJsZWRFbmNvZGluZ3M7XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byBwYXJlbnQgZGl2IG9mIHBhY2tldCBlZGl0b3IgbGlzdCwgZm9yIGFkZGluZyBhbmRcbiAgICogcmVtb3ZpbmcgcGFja2V0IGVkaXRvcnMuXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhY2tldHNEaXZfID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbVBhY2tldFNpemVDb250cm9sfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wYWNrZXRTaXplQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBGbGFnIGZvciB3aGV0aGVyIHRoaXMgcGFuZWwgaXMgaW4gXCJzZW5kaW5nXCIgbW9kZSwgbm9uLWludGVyYWN0aXZlIHdoaWxlXG4gICAqIGl0IGFuaW1hdGVzIHRoZSBzZW5kIHByb2Nlc3MgZm9yIHRoZSBjdXJyZW50IG1lc3NhZ2UuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc1BsYXlpbmdTZW5kQW5pbWF0aW9uXyA9IGZhbHNlO1xuXG4gIHZhciBwYW5lbFRpdGxlID0gKGxldmVsQ29uZmlnLm1lc3NhZ2VHcmFudWxhcml0eSA9PT0gTWVzc2FnZUdyYW51bGFyaXR5LlBBQ0tFVFMpID9cbiAgICAgIGkxOG4uc2VuZEFNZXNzYWdlKCkgOiBpMThuLnNlbmRCaXRzKCk7XG5cbiAgLy8gVE9ETzogQmFkIHByaXZhdGUgbWVtYmVyIGFjY2Vzc1xuICB0aGlzLm5ldHNpbV8ucnVuTG9vcF8udGljay5yZWdpc3Rlcih0aGlzLnRpY2suYmluZCh0aGlzKSk7XG5cbiAgTmV0U2ltUGFuZWwuY2FsbCh0aGlzLCByb290RGl2LCB7XG4gICAgY2xhc3NOYW1lOiAnbmV0c2ltLXNlbmQtcGFuZWwnLFxuICAgIHBhbmVsVGl0bGU6IHBhbmVsVGl0bGVcbiAgfSk7XG59O1xuTmV0U2ltU2VuZFBhbmVsLmluaGVyaXRzKE5ldFNpbVBhbmVsKTtcblxuLyoqXG4gKiBQdXRzIHNlbmQgcGFuZWwgaW4gYSBcInNlbmRpbmcgcGFja2V0c1wiIG5vbmludGVyYWN0aXZlIHN0YXRlIGFuZCBiZWdpbnNcbiAqIHNlbmRpbmcgcGFja2V0cyB0byByZW1vdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLmJlZ2luU2VuZGluZ1BhY2tldHNfID0gZnVuY3Rpb24gKCkge1xuICBpZiAoMCA9PT0gdGhpcy5wYWNrZXRzXy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fID0gdHJ1ZTtcbiAgdGhpcy5kaXNhYmxlRXZlcnl0aGluZygpO1xuICB0aGlzLnBhY2tldHNfWzBdLmJlZ2luU2VuZGluZyh0aGlzLm5ldHNpbV8ubXlOb2RlKTtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHdoZW4gYW4gaW5kaXZpZHVhbCBwYWNrZXQgZmluaXNoZXMgaXRzIHNlbmQgYW5pbWF0aW9uLlxuICogTW9zdCBvZiB0aGUgdGltZSB0aGUgcGFja2V0IGdldHMgcmVtb3ZlZCBhbmQgdGhlIG5leHQgcGFja2V0IGJlZ2lucyBpdHNcbiAqIGFuaW1hdGlvbi5cbiAqIElmIGl0J3MgdGhlIGxhc3QgcGFja2V0LCB3ZSBmaW5pc2ggc2VuZGluZyBhbmQgcGVyZm9ybSBhIHBhY2tldCBlZGl0b3JcbiAqIHJlc2V0IGluc3RlYWQuXG4gKiBAcGFyYW0ge05ldFNpbVBhY2tldEVkaXRvcn0gcGFja2V0XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLmRvbmVTZW5kaW5nUGFja2V0XyA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBwYWNrZXQsIHdlJ3JlIGRvbmUgc2VuZGluZyBhbHRvZ2V0aGVyLlxuICBpZiAoMSA9PT0gdGhpcy5wYWNrZXRzXy5sZW5ndGgpIHtcbiAgICB0aGlzLnJlc2V0UGFja2V0c18oKTtcbiAgICB0aGlzLmVuYWJsZUV2ZXJ5dGhpbmcoKTtcbiAgICB0aGlzLnBhY2tldHNfWzBdLmdldEZpcnN0VmlzaWJsZU1lc3NhZ2VCb3goKS5mb2N1cygpO1xuICAgIHRoaXMuaXNQbGF5aW5nU2VuZEFuaW1hdGlvbl8gPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGNvbXBsZXRlZCBwYWNrZXQgYW5kIHN0YXJ0IHNlbmRpbmcgdGhlIG5leHQgb25lLlxuICB0aGlzLnJlbW92ZVBhY2tldF8ocGFja2V0KTtcbiAgdGhpcy5wYWNrZXRzX1swXS5iZWdpblNlbmRpbmcodGhpcy5uZXRzaW1fLm15Tm9kZSk7XG59O1xuXG4vKipcbiAqIFNlbmQgcGFuZWwgdXNlcyBpdHMgdGljayB0byBcInNlbmRcIiBwYWNrZXRzIGF0IGRpZmZlcmVudCBiaXRyYXRlcywgYW5pbWF0aW5nXG4gKiB0aGUgYmluYXJ5IGRyYWluaW5nIG91dCBvZiB0aGUgd2lkZ2V0IGFuZCBhY3R1YWxseSBwb3N0aW5nIGVhY2ggcGFja2V0XG4gKiB0byBzdG9yYWdlIGFzIGl0IGNvbXBsZXRlcy5cbiAqIEBwYXJhbSB7UnVuTG9vcC5DbG9ja30gY2xvY2tcbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIGlmICh0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fICYmIHRoaXMucGFja2V0c18ubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucGFja2V0c19bMF0udGljayhjbG9jayk7XG4gIH1cbn07XG5cbi8qKiBSZXBsYWNlIGNvbnRlbnRzIG9mIG91ciByb290IGVsZW1lbnQgd2l0aCBvdXIgb3duIG1hcmt1cC4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZW5kZXIgYm9pbGVycGxhdGUgcGFuZWwgc3R1ZmZcbiAgTmV0U2ltU2VuZFBhbmVsLnN1cGVyUHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIFB1dCBvdXIgb3duIGNvbnRlbnQgaW50byB0aGUgcGFuZWwgYm9keVxuICB2YXIgbmV3TWFya3VwID0gJChtYXJrdXAoe1xuICAgIGxldmVsOiB0aGlzLmxldmVsQ29uZmlnX1xuICB9KSk7XG4gIHRoaXMuZ2V0Qm9keSgpLmh0bWwobmV3TWFya3VwKTtcblxuICAvLyBBZGQgcGFja2V0IHNpemUgc2xpZGVyIGNvbnRyb2xcbiAgaWYgKHRoaXMubGV2ZWxDb25maWdfLnNob3dQYWNrZXRTaXplQ29udHJvbCkge1xuICAgIHZhciBsZXZlbCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBQYWNrZXQuRW5jb2RlcihsZXZlbC5hZGRyZXNzRm9ybWF0LFxuICAgICAgICBsZXZlbC5wYWNrZXRDb3VudEJpdFdpZHRoLCB0aGlzLnBhY2tldFNwZWNfKTtcbiAgICB0aGlzLnBhY2tldFNpemVDb250cm9sXyA9IG5ldyBOZXRTaW1QYWNrZXRTaXplQ29udHJvbChcbiAgICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcucGFja2V0LXNpemUnKSxcbiAgICAgICAgdGhpcy5wYWNrZXRTaXplQ2hhbmdlQ2FsbGJhY2tfLmJpbmQodGhpcyksXG4gICAgICAgIHtcbiAgICAgICAgICBtaW5pbXVtUGFja2V0U2l6ZTogZW5jb2Rlci5nZXRIZWFkZXJMZW5ndGgoKSxcbiAgICAgICAgICBzbGlkZXJTdGVwVmFsdWU6IDFcbiAgICAgICAgfSk7XG4gICAgdGhpcy5wYWNrZXRTaXplQ29udHJvbF8uc2V0VmFsdWUodGhpcy5tYXhQYWNrZXRTaXplXyk7XG4gIH1cblxuICAvLyBCaW5kIHVzZWZ1bCBlbGVtZW50cyBhbmQgYWRkIGhhbmRsZXJzXG4gIHRoaXMucGFja2V0c0Rpdl8gPSB0aGlzLmdldEJvZHkoKS5maW5kKCcuc2VuZC1wYW5lbC1wYWNrZXRzJyk7XG4gIHRoaXMuZ2V0Qm9keSgpXG4gICAgICAuZmluZCgnI2FkZC1wYWNrZXQtYnV0dG9uJylcbiAgICAgIC5jbGljayh0aGlzLm9uQWRkUGFja2V0QnV0dG9uUHJlc3NfLmJpbmQodGhpcykpO1xuICAvLyBUT0RPOiBOZXRTaW0gYnV0dG9ucyBpbiB0aGlzIHBhbmVsIG5lZWQgdG8gZG8gbm90aGluZyBpZiBkaXNhYmxlZCFcbiAgdGhpcy5nZXRCb2R5KClcbiAgICAgIC5maW5kKCcjc2VuZC1idXR0b24nKVxuICAgICAgLmNsaWNrKHRoaXMub25TZW5kRXZlbnRUcmlnZ2VyZWRfLmJpbmQodGhpcykpO1xuICB0aGlzLmdldEJvZHkoKVxuICAgICAgLmZpbmQoJyNzZXQtd2lyZS1idXR0b24nKVxuICAgICAgLmNsaWNrKHRoaXMub25TZW5kRXZlbnRUcmlnZ2VyZWRfLmJpbmQodGhpcykpO1xuXG4gIC8vIE5vdGU6IEF0IHNvbWUgcG9pbnQsIHdlIG1pZ2h0IHdhbnQgdG8gcmVwbGFjZSB0aGlzIHdpdGggc29tZXRoaW5nXG4gIC8vIHRoYXQgbmljZWx5IHJlLXJlbmRlcnMgdGhlIGNvbnRlbnRzIG9mIHRoaXMucGFja2V0c18uLi4gZm9yIG5vdyxcbiAgLy8gd2Ugb25seSBjYWxsIHJlbmRlciBmb3Igc2V0LXVwLCBzbyBpdCdzIG9rYXkuXG4gIHRoaXMucmVzZXRQYWNrZXRzXygpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBuZXcsIGJsYW5rIHBhY2tldCB0byB0aGUgc2V0IG9mIHBhY2tldHMgYmVpbmcgZWRpdGVkLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS5hZGRQYWNrZXRfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV3UGFja2V0Q291bnQgPSB0aGlzLnBhY2tldHNfLmxlbmd0aCArIDE7XG5cbiAgLy8gVXBkYXRlIHRoZSB0b3RhbCBwYWNrZXQgY291bnQgb24gYWxsIGV4aXN0aW5nIHBhY2tldHNcbiAgdGhpcy5wYWNrZXRzXy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrZXRFZGl0b3IpIHtcbiAgICBwYWNrZXRFZGl0b3Iuc2V0UGFja2V0Q291bnQobmV3UGFja2V0Q291bnQpO1xuICB9KTtcblxuICAvLyBDb3B5IHRoZSB0byBhZGRyZXNzIG9mIHRoZSBwcmV2aW91cyBwYWNrZXQgaWYgaXQgZXhpc3RzLiBPdGhlcndpc2VcbiAgLy8gdXNlIHRoZSBsYXN0IGFkZHJlc3Mgc2VudC5cbiAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBsb2NrIHRoZSB0b0FkZHJlc3MgZm9yIGFsbCBvZiB0aGVzZSBwYWNrZXRzIHRvZ2V0aGVyP1xuICB2YXIgbmV3UGFja2V0VG9BZGRyZXNzO1xuICBpZiAodGhpcy5wYWNrZXRzXy5sZW5ndGggPiAwKSB7XG4gICAgbmV3UGFja2V0VG9BZGRyZXNzID0gdGhpcy5wYWNrZXRzX1t0aGlzLnBhY2tldHNfLmxlbmd0aCAtIDFdLnRvQWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICBuZXdQYWNrZXRUb0FkZHJlc3MgPSAnMCc7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgcGFja2V0XG4gIHZhciBuZXdQYWNrZXQgPSBuZXcgTmV0U2ltUGFja2V0RWRpdG9yKHtcbiAgICBtZXNzYWdlR3JhbnVsYXJpdHk6IHRoaXMubGV2ZWxDb25maWdfLm1lc3NhZ2VHcmFudWxhcml0eSxcbiAgICBwYWNrZXRTcGVjOiB0aGlzLnBhY2tldFNwZWNfLFxuICAgIHRvQWRkcmVzczogbmV3UGFja2V0VG9BZGRyZXNzLFxuICAgIGZyb21BZGRyZXNzOiB0aGlzLmZyb21BZGRyZXNzXyxcbiAgICBwYWNrZXRJbmRleDogbmV3UGFja2V0Q291bnQsXG4gICAgcGFja2V0Q291bnQ6IG5ld1BhY2tldENvdW50LFxuICAgIG1heFBhY2tldFNpemU6IHRoaXMubWF4UGFja2V0U2l6ZV8sXG4gICAgY2h1bmtTaXplOiB0aGlzLmNodW5rU2l6ZV8sXG4gICAgYml0UmF0ZTogdGhpcy5iaXRSYXRlXyxcbiAgICBlbmFibGVkRW5jb2RpbmdzOiB0aGlzLmVuYWJsZWRFbmNvZGluZ3NfLFxuICAgIHJlbW92ZVBhY2tldENhbGxiYWNrOiB0aGlzLnJlbW92ZVBhY2tldF8uYmluZCh0aGlzKSxcbiAgICBkb25lU2VuZGluZ0NhbGxiYWNrOiB0aGlzLmRvbmVTZW5kaW5nUGFja2V0Xy5iaW5kKHRoaXMpLFxuICAgIGNvbnRlbnRDaGFuZ2VDYWxsYmFjazogdGhpcy5vbkNvbnRlbnRDaGFuZ2VfLmJpbmQodGhpcyksXG4gICAgZW50ZXJLZXlQcmVzc2VkQ2FsbGJhY2s6IHRoaXMub25TZW5kRXZlbnRUcmlnZ2VyZWRfLmJpbmQodGhpcylcbiAgfSk7XG5cbiAgLy8gQXR0YWNoIHRoZSBuZXcgcGFja2V0IHRvIHRoaXMgU2VuZFBhbmVsXG4gIHZhciB1cGRhdGVMYXlvdXQgPSB0aGlzLm5ldHNpbV8udXBkYXRlTGF5b3V0LmJpbmQodGhpcy5uZXRzaW1fKTtcbiAgbmV3UGFja2V0LmdldFJvb3QoKS5hcHBlbmRUbyh0aGlzLnBhY2tldHNEaXZfKTtcbiAgbmV3UGFja2V0LmdldFJvb3QoKS5oaWRlKCkuc2xpZGVEb3duKCdmYXN0JywgZnVuY3Rpb24gKCkge1xuICAgIG5ld1BhY2tldC5nZXRGaXJzdFZpc2libGVNZXNzYWdlQm94KCkuZm9jdXMoKTtcbiAgICB1cGRhdGVMYXlvdXQoKTtcbiAgfSk7XG4gIHRoaXMucGFja2V0c18ucHVzaChuZXdQYWNrZXQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBwYWNrZXQgZnJvbSB0aGUgc2VuZCBwYW5lbCwgYW5kIGFkanVzdCBvdGhlciBwYWNrZXRzIGZvclxuICogY29uc2lzdGVuY3kuXG4gKiBAcGFyYW0ge05ldFNpbVBhY2tldEVkaXRvcn0gcGFja2V0XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLnJlbW92ZVBhY2tldF8gPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIC8vIFJlbW92ZSBmcm9tIERPTVxuICB2YXIgdXBkYXRlTGF5b3V0ID0gdGhpcy5uZXRzaW1fLnVwZGF0ZUxheW91dC5iaW5kKHRoaXMubmV0c2ltXyk7XG4gIHBhY2tldC5nZXRSb290KClcbiAgICAgIC5zbGlkZVVwKCdmYXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgIHVwZGF0ZUxheW91dCgpO1xuICAgICAgfSk7XG5cbiAgLy8gUmVtb3ZlIGZyb20gaW50ZXJuYWwgY29sbGVjdGlvblxuICB0aGlzLnBhY2tldHNfID0gdGhpcy5wYWNrZXRzXy5maWx0ZXIoZnVuY3Rpb24gKHBhY2tldEVkaXRvcikge1xuICAgIHJldHVybiBwYWNrZXRFZGl0b3IgIT09IHBhY2tldDtcbiAgfSk7XG5cbiAgLy8gQWRqdXN0IG51bWJlcmluZyBvZiByZW1haW5pbmcgcGFja2V0cyBpZiB3ZSdyZSBub3QgbWlkLXNlbmRcbiAgaWYgKCF0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fKSB7XG4gICAgdmFyIHBhY2tldENvdW50ID0gdGhpcy5wYWNrZXRzXy5sZW5ndGg7XG4gICAgdmFyIHBhY2tldEluZGV4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFja2V0Q291bnQ7IGkrKykge1xuICAgICAgcGFja2V0SW5kZXggPSBpICsgMTtcbiAgICAgIHRoaXMucGFja2V0c19baV0uc2V0UGFja2V0SW5kZXgocGFja2V0SW5kZXgpO1xuICAgICAgdGhpcy5wYWNrZXRzX1tpXS5zZXRQYWNrZXRDb3VudChwYWNrZXRDb3VudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBlZGl0b3IgdG8gaXRzICdlbXB0eScgc3RhdGU6IFJlbW92ZSBhbGwgYnV0IHRoZSBmaXJzdCBwYWNrZXQsXG4gKiBhbmQgcmVzZXQgdGhlIGZpcnN0IHBhY2tldCB0byBlbXB0eS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUucmVzZXRQYWNrZXRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0c18ubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucGFja2V0c0Rpdl8uY2hpbGRyZW4oKS5zbGljZSgxKS5yZW1vdmUoKTtcbiAgICB0aGlzLnBhY2tldHNfLmxlbmd0aCA9IE1hdGgubWluKDEsIHRoaXMucGFja2V0c18ubGVuZ3RoKTtcbiAgICB0aGlzLnBhY2tldHNfWzBdLnJlc2V0UGFja2V0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRQYWNrZXRfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogV2hlbiBhbnkgcGFja2V0IGVkaXRvcidzIGJpbmFyeSBjb250ZW50IGNoYW5nZXMsIHdlIG1heSB3YW50XG4gKiB0byB1cGRhdGUgVUkgd3JhcHBlciBlbGVtZW50cyAobGlrZSB0aGUgXCJzZXQgbmV4dCBiaXRcIiBidXR0b24pXG4gKiBpbiByZXNwb25zZVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS5vbkNvbnRlbnRDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV4dEJpdCA9IHRoaXMuZ2V0TmV4dEJpdF8oKTtcblxuICBpZiAobmV4dEJpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGJpdHMgcXVldWVkIHVwLCBkaXNhYmxlIHRoZSBidXR0b25cbiAgICB0aGlzLmdldFNldFdpcmVCdXR0b24oKS50ZXh0KGkxOG4uc2V0V2lyZSgpKTtcbiAgICB0aGlzLmNvbmRpdGlvbmFsbHlUb2dnbGVTZXRXaXJlQnV0dG9uKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBJZiB3ZSBoYXZlIHRoZSBcIkEvQlwiIGVuY29kaW5nIGVuYWJsZWQgYnV0IF9ub3RfIFwiQmluYXJ5XCIsXG4gICAgLy8gZm9ybWF0IHRoaXMgYnV0dG9uIGxhYmVsIHVzaW5nIHRoZSBcIkEvQlwiIGNvbnZlbnRpb25cbiAgICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkFfQU5EX0IpICYmXG4gICAgICAgICF0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuQklOQVJZKSkge1xuICAgICAgbmV4dEJpdCA9IGJpbmFyeVRvQUIobmV4dEJpdCk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRTZXRXaXJlQnV0dG9uKCkudGV4dChpMThuLnNldFdpcmVUb1ZhbHVlKHsgdmFsdWU6IG5leHRCaXQgfSkpO1xuICAgIHRoaXMuY29uZGl0aW9uYWxseVRvZ2dsZVNldFdpcmVCdXR0b24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBlbmNvZGluZyBpcyBjdXJyZW50bHkgZGlzcGxheWVkIGJ5IHRoZSBwYW5lbC5cbiAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlfSBxdWVyeUVuY29kaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuaXNFbmNvZGluZ0VuYWJsZWRfID0gZnVuY3Rpb24gKHF1ZXJ5RW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuZW5hYmxlZEVuY29kaW5nc18uc29tZShmdW5jdGlvbiAoZW5hYmxlZEVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGVuYWJsZWRFbmNvZGluZyA9PT0gcXVlcnlFbmNvZGluZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBmcm9tIGFkZHJlc3MgZm9yIHRoZSBwYW5lbCwgdXBkYXRlIGFsbCB0aGUgcGFja2V0cyB0byByZWZsZWN0IHRoaXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21BZGRyZXNzXSBkZWZhdWx0IHplcm9cbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS5zZXRGcm9tQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tQWRkcmVzcykge1xuICAvLyBmcm9tQWRkcmVzcyBjYW4gYmUgdW5kZWZpbmVkIGZvciBvdGhlciBwYXJ0cyBvZiB0aGUgc2ltLCBidXQgd2l0aGluXG4gIC8vIHRoZSBzZW5kIHBhbmVsIHdlIGp1c3Qgc2V0IGl0IHRvIHplcm8uXG4gIHRoaXMuZnJvbUFkZHJlc3NfID0gdXRpbHMudmFsdWVPcihmcm9tQWRkcmVzcywgMCk7XG5cbiAgdGhpcy5wYWNrZXRzXy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrZXRFZGl0b3IpIHtcbiAgICBwYWNrZXRFZGl0b3Iuc2V0RnJvbUFkZHJlc3ModGhpcy5mcm9tQWRkcmVzc18pO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fSBqUXVlcnlFdmVudFxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS5vbkFkZFBhY2tldEJ1dHRvblByZXNzXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgdGhpc0J1dHRvbiA9ICQoalF1ZXJ5RXZlbnQudGFyZ2V0KTtcbiAgaWYgKHRoaXNCdXR0b24uaXMoJ1tkaXNhYmxlZF0nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYWRkUGFja2V0XygpO1xuXG4gIC8vIFNjcm9sbCB0byBlbmQgb2YgcGFja2V0IGFyZWFcbiAgdmFyIHNjcm9sbGluZ0FyZWEgPSB0aGlzLmdldEJvZHkoKS5maW5kKCcuc2VuZC1wYW5lbC1wYWNrZXRzJyk7XG4gIHNjcm9sbGluZ0FyZWEuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsaW5nQXJlYVswXS5zY3JvbGxIZWlnaHQgfSwgJ2Zhc3QnKTtcbn07XG5cbi8qKlxuICogU2VuZCBtZXNzYWdlIHRvIGNvbm5lY3RlZCByZW1vdGVcbiAqIEBwYXJhbSB7RXZlbnR9IGpRdWVyeUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLm9uU2VuZEV2ZW50VHJpZ2dlcmVkXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgdHJpZ2dlcmluZ1RhcmdldCA9ICQoalF1ZXJ5RXZlbnQudGFyZ2V0KTtcbiAgaWYgKHRyaWdnZXJpbmdUYXJnZXQuaXMoJ1tkaXNhYmxlZF0nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsZXZlbCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgaWYgKGxldmVsLm1lc3NhZ2VHcmFudWxhcml0eSA9PT0gTWVzc2FnZUdyYW51bGFyaXR5LlBBQ0tFVFMpIHtcbiAgICB0aGlzLmJlZ2luU2VuZGluZ1BhY2tldHNfKCk7XG4gIH0gZWxzZSBpZiAobGV2ZWwubWVzc2FnZUdyYW51bGFyaXR5ID09PSBNZXNzYWdlR3JhbnVsYXJpdHkuQklUUykge1xuICAgIHRoaXMuc2VuZE9uZUJpdF8oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgc2luZ2xlIGJpdCwgbWFudWFsbHkgJ3NldHRpbmcgdGhlIHdpcmUgc3RhdGUnLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltU2VuZFBhbmVsLnByb3RvdHlwZS5zZW5kT25lQml0XyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG15Tm9kZSA9IHRoaXMubmV0c2ltXy5teU5vZGU7XG4gIGlmICghbXlOb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gc2V0IHdpcmUgc3RhdGUgd2hlbiBubyBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlwiKTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGZpcnN0IGJpdCBvZiB0aGUgZmlyc3QgcGFja2V0LiBEaXNhbGxvdyBzZXR0aW5nIHRoZSB3aXJlXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGZpcnN0IGJpdC5cbiAgdmFyIG5leHRCaXQgPSB0aGlzLmdldE5leHRCaXRfKCk7XG4gIGlmIChuZXh0Qml0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBzZXQgd2lyZSBzdGF0ZSB3aGVuIG5vIGJpdCBpcyBxdWV1ZWQuXCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlzYWJsZUV2ZXJ5dGhpbmcoKTtcbiAgICB0aGlzLm5ldHNpbV8uYW5pbWF0ZVNldFdpcmVTdGF0ZShuZXh0Qml0KTtcbiAgICBteU5vZGUuc2V0U2ltcGxleFdpcmVTdGF0ZShuZXh0Qml0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGVyci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnN1bWVGaXJzdEJpdCgpO1xuICAgICAgdGhpcy5lbmFibGVFdmVyeXRoaW5nKCk7XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsbHlUb2dnbGVTZXRXaXJlQnV0dG9uKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgYml0IHRoYXQgd291bGQgYmUgc2VudCwgaWYgc2VuZGluZyB0aGUgZW50ZXJlZCBtZXNzYWdlIG9uZVxuICogYml0IGF0IGEgdGltZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBzaW5nbGUgYml0IGFzIGEgXCIwXCIgb3IgXCIxXCIgaWYgdGhlcmUgYXJlXG4gKiBiaXRzIHRvIGJlIHNlbnQsIG9yIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuZ2V0TmV4dEJpdF8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhY2tldHNfLmxlbmd0aCA+IDAgPyB0aGlzLnBhY2tldHNfWzBdLmdldEZpcnN0Qml0KCkgOiB1bmRlZmluZWQ7XG59O1xuXG4vKiogRGlzYWJsZSBhbGwgY29udHJvbHMgaW4gdGhpcyBwYW5lbCwgdXN1YWxseSBkdXJpbmcgbmV0d29yayBhY3Rpdml0eS4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuZGlzYWJsZUV2ZXJ5dGhpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYScpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJy5uZXRzaW0tYnV0dG9uJykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgaWYgKHRoaXMucGFja2V0U2l6ZUNvbnRyb2xfKSB7XG4gICAgdGhpcy5wYWNrZXRTaXplQ29udHJvbF8uZGlzYWJsZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBidXR0b24gdXNlZCB0byBzZXQgdGhlIHdpcmUgc3RhdGVcbiAqIEByZXR1cm5zIHtqUXVlcnl9XG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuZ2V0U2V0V2lyZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJyNzZXQtd2lyZS1idXR0b24nKTtcbn07XG5cbi8qKiBFbmFibGVzIHRoZSBzZXRXaXJlQnV0dG9uIGlmIHRoZXJlIGlzIGFub3RoZXIgYml0IGluIHRoZSBxdWV1ZSxcbiAqIGRpc2FibGVzIGl0IG90aGVyd2lzZS5cbiAqIEByZXR1cm5zIHtqUXVlcnl9XG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuY29uZGl0aW9uYWxseVRvZ2dsZVNldFdpcmVCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZXRXaXJlQnV0dG9uID0gdGhpcy5nZXRTZXRXaXJlQnV0dG9uKCk7XG4gIGlmICh0aGlzLmdldE5leHRCaXRfKCkgPT09IHVuZGVmaW5lZCkge1xuICAgIHNldFdpcmVCdXR0b24uYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRXaXJlQnV0dG9uLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gIH1cbiAgcmV0dXJuIHNldFdpcmVCdXR0b247XG59O1xuXG4vKiogRW5hYmxlIGFsbCBjb250cm9scyBpbiB0aGlzIHBhbmVsLCB1c3VhbGx5IGFmdGVyIG5ldHdvcmsgYWN0aXZpdHkuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLmVuYWJsZUV2ZXJ5dGhpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYScpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICB0aGlzLmdldEJvZHkoKS5maW5kKCcubmV0c2ltLWJ1dHRvbicpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gIGlmICh0aGlzLnBhY2tldFNpemVDb250cm9sXykge1xuICAgIHRoaXMucGFja2V0U2l6ZUNvbnRyb2xfLmVuYWJsZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZmlyc3QgYml0IG9mIHRoZSBmaXJzdCBwYWNrZXQsIHVzdWFsbHkgYmVjYXVzZSB3ZSBqdXN0IHNlbnRcbiAqIGEgc2luZ2xlIGJpdCBpbiB2YXJpYW50IDEuXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuY29uc3VtZUZpcnN0Qml0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRzXy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5wYWNrZXRzX1swXS5jb25zdW1lRmlyc3RCaXQoKTtcbiAgICBpZiAodGhpcy5wYWNrZXRzX1swXS5nZXRQYWNrZXRCaW5hcnkoKSA9PT0gJycgJiYgdGhpcy5wYWNrZXRzXy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnJlbW92ZVBhY2tldF8odGhpcy5wYWNrZXRzX1swXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNob3cgb3IgaGlkZSBwYXJ0cyBvZiB0aGUgc2VuZCBVSSBiYXNlZCBvbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVuY29kaW5nXG4gKiBtb2RlLlxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gbmV3RW5jb2RpbmdzXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuc2V0RW5jb2RpbmdzID0gZnVuY3Rpb24gKG5ld0VuY29kaW5ncykge1xuICB0aGlzLmVuYWJsZWRFbmNvZGluZ3NfID0gbmV3RW5jb2RpbmdzO1xuICB0aGlzLnBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24gKHBhY2tldEVkaXRvcikge1xuICAgIHBhY2tldEVkaXRvci5zZXRFbmNvZGluZ3MobmV3RW5jb2RpbmdzKTtcbiAgfSk7XG4gIHRoaXMub25Db250ZW50Q2hhbmdlXygpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgaG93IGRhdGEgaXMgaW50ZXJwcmV0ZWQgYW5kIGZvcm1hdHRlZCBieSB0aGlzIGNvbXBvbmVudCwgdHJpZ2dlcmluZ1xuICogYW4gdXBkYXRlIG9mIGFsbCBpbnB1dCBmaWVsZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3Q2h1bmtTaXplXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuc2V0Q2h1bmtTaXplID0gZnVuY3Rpb24gKG5ld0NodW5rU2l6ZSkge1xuICB0aGlzLmNodW5rU2l6ZV8gPSBuZXdDaHVua1NpemU7XG4gIHRoaXMucGFja2V0c18uZm9yRWFjaChmdW5jdGlvbiAocGFja2V0RWRpdG9yKSB7XG4gICAgcGFja2V0RWRpdG9yLnNldENodW5rU2l6ZShuZXdDaHVua1NpemUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBsb2NhbCBkZXZpY2UgYml0cmF0ZSB3aGljaCBhZmZlY3RzIHNlbmQgYW5pbWF0aW9uIHNwZWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0JpdFJhdGUgaW4gYml0cyBwZXIgc2Vjb25kXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUuc2V0Qml0UmF0ZSA9IGZ1bmN0aW9uIChuZXdCaXRSYXRlKSB7XG4gIHRoaXMuYml0UmF0ZV8gPSBuZXdCaXRSYXRlO1xuICB0aGlzLnBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24gKHBhY2tldEVkaXRvcikge1xuICAgIHBhY2tldEVkaXRvci5zZXRCaXRSYXRlKG5ld0JpdFJhdGUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgcGFzc2VkIGRvd24gaW50byBwYWNrZXQgc2l6ZSBjb250cm9sLCBjYWxsZWQgd2hlbiBwYWNrZXQgc2l6ZVxuICogaXMgY2hhbmdlZCBieSB0aGUgdXNlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdQYWNrZXRTaXplXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TZW5kUGFuZWwucHJvdG90eXBlLnBhY2tldFNpemVDaGFuZ2VDYWxsYmFja18gPSBmdW5jdGlvbiAobmV3UGFja2V0U2l6ZSkge1xuICB0aGlzLm1heFBhY2tldFNpemVfID0gbmV3UGFja2V0U2l6ZTtcbiAgdGhpcy5wYWNrZXRzXy5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrZXRFZGl0b3Ipe1xuICAgIHBhY2tldEVkaXRvci5zZXRNYXhQYWNrZXRTaXplKG5ld1BhY2tldFNpemUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWZ0ZXIgdG9nZ2xpbmcgcGFuZWwgdmlzaWJpbGl0eSwgdHJpZ2dlciBhIGxheW91dCB1cGRhdGUgc28gc2VuZC9sb2cgcGFuZWxcbiAqIHNwYWNlIGlzIHNoYXJlZCBjb3JyZWN0bHkuXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cbk5ldFNpbVNlbmRQYW5lbC5wcm90b3R5cGUub25NaW5pbWl6ZXJDbGlja18gPSBmdW5jdGlvbiAoKSB7XG4gIE5ldFNpbVNlbmRQYW5lbC5zdXBlclByb3RvdHlwZS5vbk1pbmltaXplckNsaWNrXy5jYWxsKHRoaXMpO1xuICB0aGlzLm5ldHNpbV8udXBkYXRlTGF5b3V0KCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xuICB2YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG4gIHZhciBNZXNzYWdlR3JhbnVsYXJpdHkgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLk1lc3NhZ2VHcmFudWxhcml0eTtcbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJzZW5kLXBhbmVsLXBhY2tldHNcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVwicGFuZWwtZm9vdGVyXCI+XFxuICA8ZGl2IGNsYXNzPVwicmlnaHQtc2lkZS1jb250cm9sc1wiPlxcbiAgICAnKTs4OyBpZiAobGV2ZWwuc2hvd0FkZFBhY2tldEJ1dHRvbikgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8c3BhbiBjbGFzcz1cIm5ldHNpbS1idXR0b24gc2Vjb25kYXJ5IGxhcmdlLWJ1dHRvblwiIGlkPVwiYWRkLXBhY2tldC1idXR0b25cIj4nLCBlc2NhcGUoKDksICBpMThuLmFkZFBhY2tldCgpICkpLCAnPC9zcGFuPlxcbiAgICAnKTsxMDsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7MTE7IGlmIChsZXZlbC5tZXNzYWdlR3JhbnVsYXJpdHkgPT09IE1lc3NhZ2VHcmFudWxhcml0eS5QQUNLRVRTKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxzcGFuIGNsYXNzPVwibmV0c2ltLWJ1dHRvbiBsYXJnZS1idXR0b25cIiBpZD1cInNlbmQtYnV0dG9uXCI+JywgZXNjYXBlKCgxMiwgIGkxOG4uc2VuZCgpICkpLCAnPC9zcGFuPlxcbiAgICAnKTsxMzsgfSBlbHNlIGlmIChsZXZlbC5tZXNzYWdlR3JhbnVsYXJpdHkgPT09IE1lc3NhZ2VHcmFudWxhcml0eS5CSVRTKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxzcGFuIGNsYXNzPVwibmV0c2ltLWJ1dHRvbiBsYXJnZS1idXR0b25cIiBpZD1cInNldC13aXJlLWJ1dHRvblwiPicsIGVzY2FwZSgoMTQsICBpMThuLnNldFdpcmUoKSApKSwgJzwvc3Bhbj5cXG4gICAgJyk7MTU7IH0gOyBidWYucHVzaCgnXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJwYWNrZXQtc2l6ZVwiPjwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbnRyb2xsZXIgZm9yIHRoZSBcIlJvdXRlclwiIHRhYiBpbiB0aGUgbGVmdCBjb2x1bW4uXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1Sb3V0ZXJUYWIuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1CYW5kd2lkdGhDb250cm9sID0gcmVxdWlyZSgnLi9OZXRTaW1CYW5kd2lkdGhDb250cm9sJyk7XG52YXIgTmV0U2ltTWVtb3J5Q29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltTWVtb3J5Q29udHJvbCcpO1xudmFyIE5ldFNpbVJvdXRlclN0YXRzVGFibGUgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlclN0YXRzVGFibGUnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciByb3V0ZXIgaW5mb3JtYXRpb24gdmlldy5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2IC0gUGFyZW50IGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmJhbmR3aWR0aFNsaWRlckNoYW5nZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuYmFuZHdpZHRoU2xpZGVyU3RvcENhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MubWVtb3J5U2xpZGVyQ2hhbmdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5tZW1vcnlTbGlkZXJTdG9wQ2FsbGJhY2tcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltUm91dGVyVGFiID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdiwgY2FsbGJhY2tzKSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iYW5kd2lkdGhTbGlkZXJDaGFuZ2VDYWxsYmFja18gPSBjYWxsYmFja3MuYmFuZHdpZHRoU2xpZGVyQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYmFuZHdpZHRoU2xpZGVyU3RvcENhbGxiYWNrXyA9IGNhbGxiYWNrcy5iYW5kd2lkdGhTbGlkZXJTdG9wQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubWVtb3J5U2xpZGVyQ2hhbmdlQ2FsbGJhY2tfID0gY2FsbGJhY2tzLm1lbW9yeVNsaWRlckNoYW5nZUNhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1lbW9yeVNsaWRlclN0b3BDYWxsYmFja18gPSBjYWxsYmFja3MubWVtb3J5U2xpZGVyU3RvcENhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltUm91dGVyU3RhdHNUYWJsZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm91dGVyU3RhdHNUYWJsZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltQmFuZHdpZHRoQ29udHJvbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYmFuZHdpZHRoQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTWVtb3J5Q29udHJvbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubWVtb3J5Q29udHJvbF8gPSBudWxsO1xuXG4gIC8vIEluaXRpYWwgcmVuZGVyXG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UnVuTG9vcH0gcnVuTG9vcFxuICovXG5OZXRTaW1Sb3V0ZXJUYWIucHJvdG90eXBlLmF0dGFjaFRvUnVuTG9vcCA9IGZ1bmN0aW9uIChydW5Mb29wKSB7XG4gIGlmICh0aGlzLnJvdXRlclN0YXRzVGFibGVfKSB7XG4gICAgdGhpcy5yb3V0ZXJTdGF0c1RhYmxlXy5hdHRhY2hUb1J1bkxvb3AocnVuTG9vcCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsbCB0aGUgcm9vdCBkaXYgd2l0aCBuZXcgZWxlbWVudHMgcmVmbGVjdGluZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAqL1xuTmV0U2ltUm91dGVyVGFiLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcblxuICB2YXIgcmVuZGVyZWRNYXJrdXAgPSAkKG1hcmt1cCh7XG4gICAgbGV2ZWw6IGxldmVsQ29uZmlnXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcbiAgdGhpcy5yb3V0ZXJTdGF0c1RhYmxlXyA9IG5ldyBOZXRTaW1Sb3V0ZXJTdGF0c1RhYmxlKFxuICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcucm91dGVyLXN0YXRzJykpO1xuICBpZiAobGV2ZWxDb25maWcuc2hvd1JvdXRlckJhbmR3aWR0aENvbnRyb2wpIHtcbiAgICB0aGlzLmJhbmR3aWR0aENvbnRyb2xfID0gbmV3IE5ldFNpbUJhbmR3aWR0aENvbnRyb2woXG4gICAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnLmJhbmR3aWR0aC1jb250cm9sJyksXG4gICAgICAgIHRoaXMuYmFuZHdpZHRoU2xpZGVyQ2hhbmdlQ2FsbGJhY2tfLFxuICAgICAgICB0aGlzLmJhbmR3aWR0aFNsaWRlclN0b3BDYWxsYmFja18pO1xuICB9XG4gIGlmIChsZXZlbENvbmZpZy5zaG93Um91dGVyTWVtb3J5Q29udHJvbCkge1xuICAgIHRoaXMubWVtb3J5Q29udHJvbF8gPSBuZXcgTmV0U2ltTWVtb3J5Q29udHJvbChcbiAgICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcubWVtb3J5LWNvbnRyb2wnKSxcbiAgICAgICAgdGhpcy5tZW1vcnlTbGlkZXJDaGFuZ2VDYWxsYmFja18sXG4gICAgICAgIHRoaXMubWVtb3J5U2xpZGVyU3RvcENhbGxiYWNrXyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtOZXRTaW1Mb2dFbnRyeVtdfSBsb2dEYXRhXG4gKi9cbk5ldFNpbVJvdXRlclRhYi5wcm90b3R5cGUuc2V0Um91dGVyTG9nRGF0YSA9IGZ1bmN0aW9uIChsb2dEYXRhKSB7XG4gIGlmICh0aGlzLnJvdXRlclN0YXRzVGFibGVfKSB7XG4gICAgdGhpcy5yb3V0ZXJTdGF0c1RhYmxlXy5zZXRSb3V0ZXJMb2dEYXRhKGxvZ0RhdGEpO1xuICB9XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IGNyZWF0aW9uVGltZXN0YW1wTXMgKi9cbk5ldFNpbVJvdXRlclRhYi5wcm90b3R5cGUuc2V0Um91dGVyQ3JlYXRpb25UaW1lID0gZnVuY3Rpb24gKGNyZWF0aW9uVGltZXN0YW1wTXMpIHtcbiAgaWYgKHRoaXMucm91dGVyU3RhdHNUYWJsZV8pIHtcbiAgICB0aGlzLnJvdXRlclN0YXRzVGFibGVfLnNldFJvdXRlckNyZWF0aW9uVGltZShjcmVhdGlvblRpbWVzdGFtcE1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3QmFuZHdpZHRoIGluIGJpdHMvc2Vjb25kXG4gKi9cbk5ldFNpbVJvdXRlclRhYi5wcm90b3R5cGUuc2V0QmFuZHdpZHRoID0gZnVuY3Rpb24gKG5ld0JhbmR3aWR0aCkge1xuICBpZiAodGhpcy5iYW5kd2lkdGhDb250cm9sXykge1xuICAgIHRoaXMuYmFuZHdpZHRoQ29udHJvbF8uc2V0VmFsdWUobmV3QmFuZHdpZHRoKTtcbiAgfVxuICBpZiAodGhpcy5yb3V0ZXJTdGF0c1RhYmxlXykge1xuICAgIHRoaXMucm91dGVyU3RhdHNUYWJsZV8uc2V0QmFuZHdpZHRoKG5ld0JhbmR3aWR0aCk7XG4gIH1cbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbmV3TWVtb3J5IGluIGJpdHMvc2Vjb25kICovXG5OZXRTaW1Sb3V0ZXJUYWIucHJvdG90eXBlLnNldE1lbW9yeSA9IGZ1bmN0aW9uIChuZXdNZW1vcnkpIHtcbiAgaWYgKHRoaXMubWVtb3J5Q29udHJvbF8pIHtcbiAgICB0aGlzLm1lbW9yeUNvbnRyb2xfLnNldFZhbHVlKG5ld01lbW9yeSk7XG4gIH1cbiAgaWYgKHRoaXMucm91dGVyU3RhdHNUYWJsZV8pIHtcbiAgICB0aGlzLnJvdXRlclN0YXRzVGFibGVfLnNldFRvdGFsTWVtb3J5KG5ld01lbW9yeSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHF1ZXVlZFBhY2tldENvdW50XG4gKi9cbk5ldFNpbVJvdXRlclRhYi5wcm90b3R5cGUuc2V0Um91dGVyUXVldWVkUGFja2V0Q291bnQgPSBmdW5jdGlvbiAocXVldWVkUGFja2V0Q291bnQpIHtcbiAgaWYgKHRoaXMucm91dGVyU3RhdHNUYWJsZV8pIHtcbiAgICB0aGlzLnJvdXRlclN0YXRzVGFibGVfLnNldFJvdXRlclF1ZXVlZFBhY2tldENvdW50KHF1ZXVlZFBhY2tldENvdW50KTtcbiAgfVxufTtcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSB1c2VkTWVtb3J5SW5CaXRzICovXG5OZXRTaW1Sb3V0ZXJUYWIucHJvdG90eXBlLnNldE1lbW9yeUluVXNlID0gZnVuY3Rpb24gKHVzZWRNZW1vcnlJbkJpdHMpIHtcbiAgaWYgKHRoaXMucm91dGVyU3RhdHNUYWJsZV8pIHtcbiAgICB0aGlzLnJvdXRlclN0YXRzVGFibGVfLnNldE1lbW9yeUluVXNlKHVzZWRNZW1vcnlJbkJpdHMpO1xuICB9XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IGRhdGFSYXRlQml0c1BlclNlY29uZCAqL1xuTmV0U2ltUm91dGVyVGFiLnByb3RvdHlwZS5zZXREYXRhUmF0ZSA9IGZ1bmN0aW9uIChkYXRhUmF0ZUJpdHNQZXJTZWNvbmQpIHtcbiAgaWYgKHRoaXMucm91dGVyU3RhdHNUYWJsZV8pIHtcbiAgICB0aGlzLnJvdXRlclN0YXRzVGFibGVfLnNldERhdGFSYXRlKGRhdGFSYXRlQml0c1BlclNlY29uZCk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG47IGJ1Zi5wdXNoKCdcXG48ZGl2IGNsYXNzPVwibmV0c2ltLXJvdXRlci10YWJcIj5cXG4gIDxoMT4nLCBlc2NhcGUoKDUsICBpMThuLnJvdXRlclRhYl9zdGF0cygpICkpLCAnPC9oMT5cXG4gIDxkaXYgY2xhc3M9XCJyb3V0ZXItc3RhdHNcIj48L2Rpdj5cXG4gICcpOzc7IGlmIChsZXZlbC5zaG93Um91dGVyQmFuZHdpZHRoQ29udHJvbCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGgxPicsIGVzY2FwZSgoOCwgIGkxOG4ucm91dGVyVGFiX2JhbmR3aWR0aCgpICkpLCAnPC9oMT5cXG4gICAgPGRpdiBjbGFzcz1cImJhbmR3aWR0aC1jb250cm9sXCI+PC9kaXY+XFxuICAnKTsxMDsgfSA7IGJ1Zi5wdXNoKCdcXG4gICcpOzExOyBpZiAobGV2ZWwuc2hvd1JvdXRlck1lbW9yeUNvbnRyb2wpIHsgOyBidWYucHVzaCgnXFxuICAgIDxoMT4nLCBlc2NhcGUoKDEyLCAgaTE4bi5yb3V0ZXJUYWJfbWVtb3J5KCkgKSksICc8L2gxPlxcbiAgICA8ZGl2IGNsYXNzPVwibWVtb3J5LWNvbnRyb2xcIj48L2Rpdj5cXG4gICcpOzE0OyB9IDsgYnVmLnB1c2goJ1xcbiAgPGgxPicsIGVzY2FwZSgoMTUsICBpMThuLnJvdXRlclRhYl9sb2dzKCkgKSksICc8L2gxPlxcbiAgPHNwYW4gY2xhc3M9XCJzZWNvbmRhcnkgbmV0c2ltLWJ1dHRvbiBsYXJnZS1idXR0b25cIiBpZD1cInNob3ctcm91dGVyLWxvZy1tb2RhbC10d29cIiBkYXRhLXRvZ2dsZT1cIm1vZGFsXCIgZGF0YS10YXJnZXQ9XCIjcm91dGVyLWxvZy1tb2RhbFwiPicsIGVzY2FwZSgoMTYsICBpMThuLmxvZ0Jyb3dzZXJCdXR0b24oKSApKSwgJzwvc3Bhbj5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb21wb25lbnQgZGlzcGxheWluZyByb3V0ZXIgc3RhdHMgb24gdGhlIFwiUm91dGVyXCIgdGFiLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5odG1sLmVqcycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIE5ldFNpbUxvZ0VudHJ5ID0gcmVxdWlyZSgnLi9OZXRTaW1Mb2dFbnRyeScpO1xuXG4vKipcbiAqIFJlbmRlciBldmVyeSBoYWxmLXNlY29uZCwgbWluaW11bS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIE1BWF9SRU5ERVJfREVMQVlfTVMgPSA1MDA7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgTUlMTElTX1BFUl9TRUNPTkQgPSAxMDAwO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIFNFQ09ORFNfUEVSX01JTlVURSA9IDYwO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIE1JTExJU19QRVJfTUlOVVRFID0gTUlMTElTX1BFUl9TRUNPTkQgKiBTRUNPTkRTX1BFUl9NSU5VVEU7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgTUlOVVRFU19QRVJfSE9VUiA9IDYwO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIE1JTExJU19QRVJfSE9VUiA9IE1JTExJU19QRVJfTUlOVVRFICogTUlOVVRFU19QRVJfSE9VUjtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIEROUyBuZXR3b3JrIGxvb2t1cCB0YWJsZSBjb21wb25lbnQuXG4gKiBTaG93cyBkaWZmZXJlbnQgYW1vdW50cyBvZiBpbmZvcm1hdGlvbiBkZXBlbmRpbmcgb24gdGhlIEROUyBtb2RlLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbVJvdXRlclN0YXRzVGFibGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2KSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogTGFzdCByZW5kZXIgdGltZSwgaW4gc2ltdWxhdGlvbi10aW1lLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5sYXN0UmVuZGVyVGltZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBVbml4IHRpbWVzdGFtcCAobG9jYWwpIG9mIHJvdXRlciBjcmVhdGlvbiB0aW1lXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvdXRlckNyZWF0aW9uVGltZV8gPSAwO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBjb3VudCBvZiBwYWNrZXRzIHRoaXMgcm91dGVyIGhhcyByZWNlaXZlZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudG90YWxQYWNrZXRzXyA9IDA7XG5cbiAgLyoqXG4gICAqIFRvdGFsIGNvdW50IG9mIHBhY2tldHMgdGhpcyByb3V0ZXIgaGFzIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnN1Y2Nlc3NmdWxQYWNrZXRzXyA9IDA7XG5cbiAgLyoqXG4gICAqIFRvdGFsIHNpemUgb2YgYWxsIHBhY2tldHMgcmVjZWl2ZWQgYnkgdGhpcyByb3V0ZXIsIGluIGJpdHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRvdGFsRGF0YV8gPSAwO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBzaXplIG9mIGFsbCBwYWNrZXRzIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYnkgdGhpcyByb3V0ZXIsIGluIGJpdHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnN1Y2Nlc3NmdWxEYXRhXyA9IDA7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gcmF0ZSBvZiBkYXRhIHRyYW5zZmVyIChpbiBiaXRzIHBlciBzZWNvbmQpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJhbmR3aWR0aExpbWl0XyA9IDA7XG5cbiAgLyoqXG4gICAqIEF2ZXJhZ2UgcmF0ZSBvZiBkYXRhIHRyYW5zZmVyIChpbiBiaXRzIHBlciBzZWNvbmQpIG92ZXIgdGhlIGxhc3RcbiAgICogREFUQV9SQVRFX1dJTkRPV19NUyBtaWxsaXNlY29uZHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRhdGFSYXRlXyA9IDA7XG5cbiAgLyoqXG4gICAqIFJvdXRlcidzIHRvdGFsIG1lbW9yeSBjYXBhY2l0eSwgaW4gYml0cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudG90YWxNZW1vcnlfID0gMDtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBhY2tldHMgaW4gdGhlIHJvdXRlcidzIHF1ZXVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5xdWV1ZWRQYWNrZXRzXyA9IDA7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2l6ZSBvZiB0aGUgcm91dGVyJ3MgcGFja2V0IHF1ZXVlLCBpbiBiaXRzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy51c2VkTWVtb3J5XyA9IDA7XG5cbiAgdGhpcy5yZW5kZXIoe30pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1J1bkxvb3B9IHJ1bkxvb3BcbiAqL1xuTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5wcm90b3R5cGUuYXR0YWNoVG9SdW5Mb29wID0gZnVuY3Rpb24gKHJ1bkxvb3ApIHtcbiAgcnVuTG9vcC5yZW5kZXIucmVnaXN0ZXIodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7UnVuTG9vcC5DbG9ja30gY2xvY2tcbiAqL1xuTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIGlmICghdGhpcy5uZWVkc1JlbmRlcihjbG9jaykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVuZGVyZWRNYXJrdXAgPSAkKG1hcmt1cCh7XG4gICAgdXB0aW1lOiB0aGlzLmdldExvY2FsaXplZFVwdGltZSgpLFxuICAgIHF1ZXVlZFBhY2tldHM6IHRoaXMucXVldWVkUGFja2V0c18sXG4gICAgdG90YWxQYWNrZXRzOiB0aGlzLnRvdGFsUGFja2V0c18sXG4gICAgc3VjY2Vzc2Z1bFBhY2tldHM6IHRoaXMuc3VjY2Vzc2Z1bFBhY2tldHNfLFxuICAgIHRvdGFsRGF0YTogdGhpcy50b3RhbERhdGFfLFxuICAgIHN1Y2Nlc3NmdWxEYXRhOiB0aGlzLnN1Y2Nlc3NmdWxEYXRhXyxcbiAgICBiYW5kd2lkdGhMaW1pdDogdGhpcy5iYW5kd2lkdGhMaW1pdF8sXG4gICAgZGF0YVJhdGU6IHRoaXMuZGF0YVJhdGVfLFxuICAgIHRvdGFsTWVtb3J5OiB0aGlzLnRvdGFsTWVtb3J5XyxcbiAgICB1c2VkTWVtb3J5OiB0aGlzLnVzZWRNZW1vcnlfXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcbiAgdGhpcy5sYXN0UmVuZGVyVGltZV8gPSBjbG9jay50aW1lO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhIHJlbmRlciBvcGVyYXRpb24gaXMgbmVlZGVkLlxuICovXG5OZXRTaW1Sb3V0ZXJTdGF0c1RhYmxlLnByb3RvdHlwZS5uZWVkc1JlbmRlciA9IGZ1bmN0aW9uIChjbG9jaykge1xuICByZXR1cm4gKCF0aGlzLmxhc3RSZW5kZXJUaW1lXyB8fFxuICAgICAgY2xvY2sudGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWVfID4gTUFYX1JFTkRFUl9ERUxBWV9NUyk7XG59O1xuXG4vKipcbiAqIE1hcmsgdGhlIHJvdXRlciBsb2cgZGF0YSBkaXJ0eSwgc28gdGhhdCBpdCB3aWxsIHJlLXJlbmRlciBvbiB0aGVcbiAqIG5leHQgZnJhbWUuXG4gKi9cbk5ldFNpbVJvdXRlclN0YXRzVGFibGUucHJvdG90eXBlLnNldE5lZWRzUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RSZW5kZXJUaW1lXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIGR1cmF0aW9uIHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgcm91dGVyIHVwdGltZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk5ldFNpbVJvdXRlclN0YXRzVGFibGUucHJvdG90eXBlLmdldExvY2FsaXplZFVwdGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdXJzVXB0aW1lID0gMDtcbiAgdmFyIG1pbnV0ZXNVcHRpbWUgPSAwO1xuICB2YXIgc2Vjb25kc1VwdGltZSA9IDA7XG4gIGlmICh0aGlzLnJvdXRlckNyZWF0aW9uVGltZV8gPiAwKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kc1VwdGltZSA9IERhdGUubm93KCkgLSB0aGlzLnJvdXRlckNyZWF0aW9uVGltZV87XG4gICAgaG91cnNVcHRpbWUgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kc1VwdGltZSAvIE1JTExJU19QRVJfSE9VUik7XG4gICAgbWlsbGlzZWNvbmRzVXB0aW1lIC09IGhvdXJzVXB0aW1lICogTUlMTElTX1BFUl9IT1VSO1xuICAgIG1pbnV0ZXNVcHRpbWUgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kc1VwdGltZSAvIE1JTExJU19QRVJfTUlOVVRFKTtcbiAgICBtaWxsaXNlY29uZHNVcHRpbWUgLT0gbWludXRlc1VwdGltZSAqIE1JTExJU19QRVJfTUlOVVRFO1xuICAgIHNlY29uZHNVcHRpbWUgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kc1VwdGltZSAvIE1JTExJU19QRVJfU0VDT05EKTtcbiAgfVxuICByZXR1cm4gaG91cnNVcHRpbWUudG9TdHJpbmcoKSArXG4gICAgICAnOicgKyBOZXRTaW1VdGlscy56ZXJvUGFkTGVmdChtaW51dGVzVXB0aW1lLCAyKSArXG4gICAgICAnOicgKyBOZXRTaW1VdGlscy56ZXJvUGFkTGVmdChzZWNvbmRzVXB0aW1lLCAyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOZXRTaW1Mb2dFbnRyeVtdfSBsb2dFbnRyaWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0b3RhbCBkYXRhIHNpemUsIGluIGJpdHMsIG9mIHBhY2tldHMgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiAgICAgICAgICBnaXZlbiBsb2cgZW50cmllcy5cbiAqL1xudmFyIHRvdGFsU2l6ZU9mUGFja2V0cyA9IGZ1bmN0aW9uIChsb2dFbnRyaWVzKSB7XG4gIHJldHVybiBsb2dFbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIuYmluYXJ5Lmxlbmd0aDtcbiAgfSwgMCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltTG9nRW50cnlbXX0gbG9nRGF0YVxuICovXG5OZXRTaW1Sb3V0ZXJTdGF0c1RhYmxlLnByb3RvdHlwZS5zZXRSb3V0ZXJMb2dEYXRhID0gZnVuY3Rpb24gKGxvZ0RhdGEpIHtcbiAgdmFyIHN1Y2Nlc3NMb2dzID0gbG9nRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGxvZ0VudHJ5KSB7XG4gICAgcmV0dXJuIGxvZ0VudHJ5LnN0YXR1cyA9PT0gTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLlNVQ0NFU1M7XG4gIH0pO1xuXG4gIHRoaXMudG90YWxQYWNrZXRzXyA9IGxvZ0RhdGEubGVuZ3RoO1xuICB0aGlzLnN1Y2Nlc3NmdWxQYWNrZXRzXyA9IHN1Y2Nlc3NMb2dzLmxlbmd0aDtcblxuICB0aGlzLnRvdGFsRGF0YV8gPSB0b3RhbFNpemVPZlBhY2tldHMobG9nRGF0YSk7XG4gIHRoaXMuc3VjY2Vzc2Z1bERhdGFfID0gdG90YWxTaXplT2ZQYWNrZXRzKHN1Y2Nlc3NMb2dzKTtcblxuICB0aGlzLnNldE5lZWRzUmVuZGVyKCk7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IGNyZWF0aW9uVGltZXN0YW1wTXMgKi9cbk5ldFNpbVJvdXRlclN0YXRzVGFibGUucHJvdG90eXBlLnNldFJvdXRlckNyZWF0aW9uVGltZSA9IGZ1bmN0aW9uIChjcmVhdGlvblRpbWVzdGFtcE1zKSB7XG4gIHRoaXMucm91dGVyQ3JlYXRpb25UaW1lXyA9IGNyZWF0aW9uVGltZXN0YW1wTXM7XG4gIHRoaXMuc2V0TmVlZHNSZW5kZXIoKTtcbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbmV3QmFuZHdpZHRoIGluIGJpdHMgcGVyIHNlY29uZCAqL1xuTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5wcm90b3R5cGUuc2V0QmFuZHdpZHRoID0gZnVuY3Rpb24gKG5ld0JhbmR3aWR0aCkge1xuICB0aGlzLmJhbmR3aWR0aExpbWl0XyA9IG5ld0JhbmR3aWR0aDtcbiAgdGhpcy5zZXROZWVkc1JlbmRlcigpO1xufTtcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbE1lbW9yeUluQml0cyAqL1xuTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5wcm90b3R5cGUuc2V0VG90YWxNZW1vcnkgPSBmdW5jdGlvbiAodG90YWxNZW1vcnlJbkJpdHMpIHtcbiAgdGhpcy50b3RhbE1lbW9yeV8gPSB0b3RhbE1lbW9yeUluQml0cztcbiAgdGhpcy5zZXROZWVkc1JlbmRlcigpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcXVldWVkUGFja2V0Q291bnRcbiAqL1xuTmV0U2ltUm91dGVyU3RhdHNUYWJsZS5wcm90b3R5cGUuc2V0Um91dGVyUXVldWVkUGFja2V0Q291bnQgPSBmdW5jdGlvbiAoXG4gICAgcXVldWVkUGFja2V0Q291bnQpIHtcbiAgdGhpcy5xdWV1ZWRQYWNrZXRzXyA9IHF1ZXVlZFBhY2tldENvdW50O1xuICB0aGlzLnNldE5lZWRzUmVuZGVyKCk7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHVzZWRNZW1vcnlJbkJpdHMgKi9cbk5ldFNpbVJvdXRlclN0YXRzVGFibGUucHJvdG90eXBlLnNldE1lbW9yeUluVXNlID0gZnVuY3Rpb24gKHVzZWRNZW1vcnlJbkJpdHMpIHtcbiAgdGhpcy51c2VkTWVtb3J5XyA9IHVzZWRNZW1vcnlJbkJpdHM7XG4gIHRoaXMuc2V0TmVlZHNSZW5kZXIoKTtcbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gZGF0YVJhdGVCaXRzUGVyU2Vjb25kICovXG5OZXRTaW1Sb3V0ZXJTdGF0c1RhYmxlLnByb3RvdHlwZS5zZXREYXRhUmF0ZSA9IGZ1bmN0aW9uIChkYXRhUmF0ZUJpdHNQZXJTZWNvbmQpIHtcbiAgdGhpcy5kYXRhUmF0ZV8gPSBkYXRhUmF0ZUJpdHNQZXJTZWNvbmQ7XG4gIHRoaXMuc2V0TmVlZHNSZW5kZXIoKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7XG4gIHZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG4gIHZhciBOZXRTaW1VdGlscyA9IHJlcXVpcmUoJy4vTmV0U2ltVXRpbHMnKTtcblxuICAvKipcbiAgICogV3JpdGUgYSBzdGF0cyByb3cgd2l0aCB0aGUgZ2l2ZW4gdGl0bGUgYW5kIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBsb2NhbGl6ZWQgbmFtZSBvZiB0aGUgc3RhdGlzdGljICh0aGUgaGVhZGVyIGNvbHVtbiBjb250ZW50cylcbiAgICogQHBhcmFtIHsqfSBzdGF0VmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIHN0YXRpc3RpY1xuICAgKi9cbiAgdmFyIHdyaXRlU3RhdFJvdyA9IGZ1bmN0aW9uICh0aXRsZSwgc3RhdFZhbHVlKSB7XG4gICAgOyBidWYucHVzaCgnXFxuICAgICAgPHRyPlxcbiAgICAgICAgPHRoIG5vd3JhcD4nLCBlc2NhcGUoKDEzLCAgdGl0bGUgKSksICc8L3RoPlxcbiAgICAgICAgPHRkPicsIGVzY2FwZSgoMTQsICBzdGF0VmFsdWUgKSksICc8L3RkPlxcbiAgICAgIDwvdHI+XFxuICAgICcpOzE2O1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHN0YXRzIHJvdyB0aGF0IGRpc3BsYXlzIGEgZnJhY3Rpb24gYW5kIGFsc28gaXRzIHBlcmNlbnRhZ2UgZm9ybS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gbG9jYWxpemVkIG5hbWUgb2YgdGhlIHN0YXRpc3RpYyAodGhlIGhlYWRlciBjb2x1bW4gY29udGVudHMpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0VmFsdWUgLSBudW1lcmF0b3Igb2YgdGhlIHN0YXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsVmFsdWUgLSBkZW5vbWluYXRvciBvZiB0aGUgc3RhdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbdG9TdHJpbmdGdW5jdGlvbl0gbWV0aG9kIGZvciBjb252ZXJ0aW5nIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IgdG8gZGlzcGxheSBmb3JtYXRcbiAgICovXG4gIHZhciBmcmFjdGlvblN0YXRSb3cgPSBmdW5jdGlvbiAodGl0bGUsIHBhcnRWYWx1ZSwgdG90YWxWYWx1ZSwgdG9TdHJpbmdGdW5jdGlvbikge1xuICAgIHRvU3RyaW5nRnVuY3Rpb24gPSB1dGlscy52YWx1ZU9yKHRvU3RyaW5nRnVuY3Rpb24sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICB2YXIgdmFsdWVTdHJpbmcgPSB0b1N0cmluZ0Z1bmN0aW9uKHBhcnRWYWx1ZSkgKyAnIC8gJyArIHRvU3RyaW5nRnVuY3Rpb24odG90YWxWYWx1ZSk7XG4gICAgaWYgKHRvdGFsVmFsdWUgPiAwICYmIHRvdGFsVmFsdWUgPCBJbmZpbml0eSkge1xuICAgICAgdmFsdWVTdHJpbmcgKz0gJyAoJyArIE1hdGgucm91bmQoMTAwICogcGFydFZhbHVlIC8gdG90YWxWYWx1ZSkgKyAnJSknO1xuICAgIH1cbiAgICB3cml0ZVN0YXRSb3codGl0bGUsIHZhbHVlU3RyaW5nKTtcbiAgfTtcbjsgYnVmLnB1c2goJ1xcbjx0YWJsZT5cXG4gIDx0Ym9keT5cXG4gICAgJyk7Mzc7IHdyaXRlU3RhdFJvdygnVXB0aW1lJywgdXB0aW1lKTsgOyBidWYucHVzaCgnXFxuICAgICcpOzM4OyB3cml0ZVN0YXRSb3coJ1F1ZXVlZCBQYWNrZXRzJywgcXVldWVkUGFja2V0cyk7IDsgYnVmLnB1c2goJ1xcbiAgICAnKTszOTsgZnJhY3Rpb25TdGF0Um93KCdNZW1vcnkgVXNlJywgdXNlZE1lbW9yeSwgdG90YWxNZW1vcnksIE5ldFNpbVV0aWxzLmJpdHNUb0xvY2FsaXplZFJvdW5kZWRCeXRlc2l6ZSk7IDsgYnVmLnB1c2goJ1xcbiAgICAnKTs0MDsgZnJhY3Rpb25TdGF0Um93KCdUaHJvdWdocHV0JywgZGF0YVJhdGUsIGJhbmR3aWR0aExpbWl0LCBOZXRTaW1VdGlscy5iaXRyYXRlVG9Mb2NhbGl6ZWRSb3VuZGVkQml0cmF0ZSk7IDsgYnVmLnB1c2goJ1xcbiAgICAnKTs0MTsgZnJhY3Rpb25TdGF0Um93KCdSb3V0ZWQgUGFja2V0cycsIHN1Y2Nlc3NmdWxQYWNrZXRzLCB0b3RhbFBhY2tldHMpOyA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7NDI7IGZyYWN0aW9uU3RhdFJvdygnUm91dGVkIERhdGEnLCBzdWNjZXNzZnVsRGF0YSwgdG90YWxEYXRhLCBOZXRTaW1VdGlscy5iaXRzVG9Mb2NhbGl6ZWRSb3VuZGVkQnl0ZXNpemUpOyA7IGJ1Zi5wdXNoKCdcXG4gIDwvdGJvZHk+XFxuPC90YWJsZT5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBhIG1vZGFsIGRpYWxvZyBzaG93aW5nIHRoZSB1bmlvbiBvZiBhbGwgcm91dGVyIGxvZ3MgZm9yIHRoZVxuICogICAgICAgICAgIGN1cnJlbnQgc2hhcmQuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltTG9nRW50cnkgPSByZXF1aXJlKCcuL05ldFNpbUxvZ0VudHJ5Jyk7XG52YXIgUGFja2V0ID0gcmVxdWlyZSgnLi9QYWNrZXQnKTtcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlckxvZ01vZGFsLmh0bWwuZWpzJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG52YXIgTE9HX0VOVFJZX0RBVEFfS0VZID0gJ0xvZ0VudHJ5JztcblxuLyoqIEBjb25zdCB7bnVtYmVyfSAqL1xudmFyIE1BWElNVU1fUk9XU19JTl9GVUxMX1JFTkRFUiA9IDUwMDtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIGNvbnRlbnRzIG9mIG1vZGFsIGRpYWxvZyB0aGF0IHJldmVhbHNcbiAqIGFsbCByb3V0ZXIgbG9ncyB0b2dldGhlciwgaW4gYSBzZWFyY2hhYmxlL3NvcnRhYmxlL2ZpbHRlcmFibGUgbWFubmVyLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbVJvdXRlckxvZ01vZGFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdikge1xuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEBwcml2YXRlIHtqUXVlcnl9XG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogSGlkZGVuIGJ5IGRlZmF1bHQuXG4gICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5pc1Zpc2libGVfID0gZmFsc2U7XG5cbiAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIG1vZGFsXG4gIHRoaXMucm9vdERpdl8ub24oJ3Nob3duLmJzLm1vZGFsJywgdGhpcy5vblNob3dfLmJpbmQodGhpcykpO1xuICB0aGlzLnJvb3REaXZfLm9uKCdoaWRkZW4uYnMubW9kYWwnLCB0aGlzLm9uSGlkZV8uYmluZCh0aGlzKSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtOZXRTaW1TaGFyZH1cbiAgICovXG4gIHRoaXMuc2hhcmRfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGUge05ldFNpbVJvdXRlck5vZGV9XG4gICAqL1xuICB0aGlzLnJvdXRlcl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7TmV0U2ltTG9nRW50cnl9XG4gICAqL1xuICB0aGlzLmxvZ0VudHJpZXNfID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBoaWdoZXN0IGxvZyByb3cgSUQgc3RvcmVkIGluIGxvZ0VudHJpZXNfLCB1c2VkIHRvIG9ubHkgcmV0cmlldmUgbmV3XG4gICAqIGxvZyByb3dzLCB3ZSBkb24ndCBuZWVkIHRvIHJldHJpZXZlIGV2ZXJ5dGhpbmcuXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmxhdGVzdFJvd0lEXyA9IDA7XG5cbiAgLyoqXG4gICAqIFRyYWNraW5nIGluZm9ybWF0aW9uIGZvciB3aGljaCBldmVudHMgd2UncmUgcmVnaXN0ZXJlZCB0bywgc28gd2UgY2FuXG4gICAqIHBlcmZvcm0gY2xlYW51cCBhcyBuZWVkZWQuXG4gICAqIEBwcml2YXRlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50S2V5c18gPSB7fTtcblxuICAvKipcbiAgICogU29ydGluZyBrZXksIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbiwgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaCBzb3J0XG4gICAqIHdlIHVzZSBvbiByZW5kZXIuXG4gICAqIEBwcml2YXRlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLnNvcnRCeV8gPSAndGltZXN0YW1wJztcblxuICAvKipcbiAgICogV2hldGhlciBjdXJyZW50bHkgdXNpbmcgYSBkZXNjZW5kaW5nIHNvcnQuXG4gICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5zb3J0RGVzY2VuZGluZ18gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgaW4gXCJBbGwtUm91dGVyXCIgbW9kZSBvciBkZWFsaW5nIHdpdGggYVxuICAgKiBzaW5nbGUgcm91dGVyLiAgQWx3YXlzIGluaXRpYWxpemVzIHRvIHRydWUgYmVjYXVzZSB3ZSBuZXZlciBpbml0aWFsaXplXG4gICAqIGNvbm5lY3RlZCB0byBhIHNpbmdsZSByb3V0ZXIuXG4gICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0FsbFJvdXRlckxvZ01vZGVfID0gdHJ1ZTtcblxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc29ydCBsb2cgZW50cmllcywgY29uZmlndXJlZFxuICogdG8gc29ydCBhY2NvcmRpbmcgdG8gdGhlIGxvZyBicm93c2VyJ3MgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICogQHJldHVybnMge2Z1bmN0aW9uKE5ldFNpbUxvZ0VudHJ5LCBOZXRTaW1Mb2dFbnRyeSl9IGNvbXBhcmVzIHR3byBsb2cgZW50cmllcyxcbiAqICAgICAgICAgIHJldHVybnMgLTEgaWYgdGhlIGZpcnN0IG9uZSBiZWxvbmdzIGJlZm9yZSB0aGUgc2Vjb25kIG9uZSwgMSBpZlxuICogICAgICAgICAgdGhlIGZpcnN0IG9uZSBiZWxvbmdzIGFmdGVyIHRoZSBzZWNvbmQgb25lLCBhbmQgMCBpZiB0aGV5IGhhdmUgdGhlXG4gKiAgICAgICAgICBzYW1lIHNvcnQgcG9zaXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJMb2dNb2RhbC5wcm90b3R5cGUuZ2V0U29ydENvbXBhcmF0b3JfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2V0U29ydFZhbHVlID0gTmV0U2ltUm91dGVyTG9nTW9kYWwuc29ydEtleVRvU29ydFZhbHVlR2V0dGVyTWFwW3RoaXMuc29ydEJ5X107XG4gIHZhciBpbnZlcnRNdWx0aXBsaWVyID0gdGhpcy5zb3J0RGVzY2VuZGluZ18gPyAtMSA6IDE7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB4ID0gZ2V0U29ydFZhbHVlKGEpO1xuICAgIHZhciB5ID0gZ2V0U29ydFZhbHVlKGIpO1xuICAgIHJldHVybiAoeCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDApICogaW52ZXJ0TXVsdGlwbGllcjtcbiAgfTtcbn07XG5cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnNvcnRLZXlUb1NvcnRWYWx1ZUdldHRlck1hcCA9IHtcblxuICAndGltZXN0YW1wJzogZnVuY3Rpb24gKGxvZ0VudHJ5KSB7XG4gICAgcmV0dXJuIGxvZ0VudHJ5LnRpbWVzdGFtcDtcbiAgfSxcblxuICAnbG9nZ2VkLWJ5JzogZnVuY3Rpb24gKGxvZ0VudHJ5KSB7XG4gICAgdmFyIG9yaWdpbk5vZGUgPSBsb2dFbnRyeS5nZXRPcmlnaW5Ob2RlKCk7XG4gICAgaWYgKG9yaWdpbk5vZGUpIHtcbiAgICAgIHJldHVybiBvcmlnaW5Ob2RlLmdldERpc3BsYXlOYW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBsb2dFbnRyeS5ub2RlSUQudG9TdHJpbmcoMTApO1xuICB9LFxuXG4gICdzdGF0dXMnOiBmdW5jdGlvbiAobG9nRW50cnkpIHtcbiAgICByZXR1cm4gbG9nRW50cnkuZ2V0TG9jYWxpemVkU3RhdHVzKCk7XG4gIH0sXG5cbiAgJ2Zyb20tYWRkcmVzcyc6IGZ1bmN0aW9uIChsb2dFbnRyeSkge1xuICAgIHJldHVybiBsb2dFbnRyeS5nZXRIZWFkZXJGaWVsZChQYWNrZXQuSGVhZGVyVHlwZS5GUk9NX0FERFJFU1MpO1xuICB9LFxuXG4gICd0by1hZGRyZXNzJzogZnVuY3Rpb24gKGxvZ0VudHJ5KSB7XG4gICAgcmV0dXJuIGxvZ0VudHJ5LmdldEhlYWRlckZpZWxkKFBhY2tldC5IZWFkZXJUeXBlLlRPX0FERFJFU1MpO1xuICB9LFxuXG4gICdwYWNrZXQtaW5mbyc6IGZ1bmN0aW9uIChsb2dFbnRyeSkge1xuICAgIHJldHVybiBsb2dFbnRyeS5nZXRMb2NhbGl6ZWRQYWNrZXRJbmZvKCk7XG4gIH0sXG5cbiAgJ21lc3NhZ2UnOiBmdW5jdGlvbiAobG9nRW50cnkpIHtcbiAgICByZXR1cm4gbG9nRW50cnkuZ2V0TWVzc2FnZUFzY2lpKCk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBTdGF0ZSBjaGFuZ2VzIHRoYXQgb2NjdXIgd2hlbiBzaG9pbmcgdGhlIGxvZy5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5vblNob3dfID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zaGFyZF8pIHtcbiAgICB0aGlzLnNoYXJkXy5sb2dUYWJsZS5zdWJzY3JpYmUoKTtcbiAgfVxuICB0aGlzLmlzVmlzaWJsZV8gPSB0cnVlO1xuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBTdGF0ZSBjaGFuZ2VzIHRoYXQgb2NjdXIgd2hlbiBoaWRpbmcgdGhlIGxvZy5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5vbkhpZGVfID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zaGFyZF8pIHtcbiAgICB0aGlzLnNoYXJkXy5sb2dUYWJsZS51bnN1YnNjcmliZSgpO1xuICB9XG4gIHRoaXMuaXNWaXNpYmxlXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgbW9kYWwgaXMgY3VycmVudGx5IHNob3dpbmcuXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzVmlzaWJsZV87XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQmUgbGF6eSwgZG9uJ3QgcmVuZGVyIGlmIG5vdCB2aXNpYmxlLlxuICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZS1yZW5kZXIgZW50aXJlIGxvZyBicm93c2VyIFVJXG4gIHZhciByZW5kZXJlZE1hcmt1cCA9ICQobWFya3VwKHtcbiAgICBpc0FsbFJvdXRlckxvZ01vZGU6IHRoaXMuaXNBbGxSb3V0ZXJMb2dNb2RlXyxcbiAgICBjYW5Ub2dnbGVSb3V0ZXJMb2dNb2RlOiB0aGlzLmNhblRvZ2dsZVJvdXRlckxvZ01vZGVfKCksXG4gICAgc29ydEJ5OiB0aGlzLnNvcnRCeV8sXG4gICAgc29ydERlc2NlbmRpbmc6IHRoaXMuc29ydERlc2NlbmRpbmdfXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcblxuICAvLyBBZGQgaW5wdXQgaGFuZGxlcnNcbiAgdGhpcy5nZXRSb3V0ZXJMb2dUb2dnbGVCdXR0b24oKS5vbmUoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50b2dnbGVSb3V0ZXJMb2dNb2RlXygpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5yb290RGl2Xy5maW5kKCd0aCcpLmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMub25Tb3J0SGVhZGVyQ2xpY2tfKCQoZXZlbnQudGFyZ2V0KS5hdHRyKCdkYXRhLXNvcnQta2V5JykpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIC8vIEFkZCByb3dzIHRvIHRoZSB0YWJsZVxuICB2YXIgcm93cyA9IHRoaXMuZ2V0U29ydGVkRmlsdGVyZWRMb2dFbnRyaWVzKHRoaXMubG9nRW50cmllc18pXG4gICAgICAuc2xpY2UoMCwgTUFYSU1VTV9ST1dTX0lOX0ZVTExfUkVOREVSKVxuICAgICAgLm1hcCh0aGlzLm1ha2VUYWJsZVJvd18uYmluZCh0aGlzKSk7XG4gIHRoaXMucm9vdERpdl8uZmluZCgndGJvZHknKS5hcHBlbmQocm93cyk7XG5cbiAgaWYgKHJvd3MubGVuZ3RoID09PSBNQVhJTVVNX1JPV1NfSU5fRlVMTF9SRU5ERVIpIHtcbiAgICB2YXIgbWF4UmVuZGVyZWRXYXJuaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWF4UmVuZGVyZWRXYXJuaW5nLmNsYXNzTmFtZSA9ICdsb2ctYnJvd3Nlci1saW1pdC1tZXNzYWdlJztcbiAgICBtYXhSZW5kZXJlZFdhcm5pbmcudGV4dENvbnRlbnQgPSBpMThuLnNob3dpbmdGaXJzdFhMb2dFbnRyaWVzKHtcbiAgICAgIHg6IE1BWElNVU1fUk9XU19JTl9GVUxMX1JFTkRFUlxuICAgIH0pO1xuICAgIHRoaXMucm9vdERpdl8uZmluZCgndGFibGUnKS5hZnRlcihtYXhSZW5kZXJlZFdhcm5pbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHNldCBvZiBsb2cgZW50cmllcyB0byB0YWJsZSByb3dzIGFuZCBpbnNlcnQgdGhlbVxuICogaW50byB0aGUgRE9NLCBpbnN0ZWFkIG9mIHJlLXJlbmRlcmluZyB0aGUgd2hvbGUgdGFibGUuXG4gKiBAcGFyYW0geyFOZXRTaW1Mb2dFbnRyeVtdfSBuZXdFbnRyaWVzXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJMb2dNb2RhbC5wcm90b3R5cGUucmVuZGVyTmV3TG9nRW50cmllc18gPSBmdW5jdGlvbiAobmV3RW50cmllcykge1xuICAvLyBCZSBsYXp5LCBkb24ndCByZW5kZXIgYXQgYWxsIGlmIG5vdCB2aXNpYmxlLlxuICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkgfHwgbmV3RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiogQHR5cGUge2pRdWVyeX0gVGFibGUgYm9keSBlbGVtZW50LiAqL1xuICB2YXIgdGJvZHkgPSB0aGlzLnJvb3REaXZfLmZpbmQoJ3Rib2R5Jyk7XG5cbiAgLy8gR2V0IGV4aXN0aW5nIHRhYmxlIHJvdyBlbGVtZW50cywgd2hpY2ggYXJlIGFscmVhZHkgc29ydGVkIGFuZCBmaWx0ZXJlZC5cbiAgdmFyIG9sZFJvd3MgPSB0Ym9keS5maW5kKCd0cicpO1xuXG4gIC8vIFNvcnQgYW5kIGZpbHRlciB0aGUgbmV3IGVudHJpZXMsIGFuZCBnZW5lcmF0ZSBET00gcm93cyBmb3IgdGhlbS5cbiAgbmV3RW50cmllcyA9IHRoaXMuZ2V0U29ydGVkRmlsdGVyZWRMb2dFbnRyaWVzKG5ld0VudHJpZXMpO1xuICB2YXIgbmV3Um93cyA9ICQobmV3RW50cmllcy5tYXAodGhpcy5tYWtlVGFibGVSb3dfLmJpbmQodGhpcykpKTtcblxuICAvLyBXYWxrIGJvdGggY29sbGVjdGlvbnMgdG8gbWVyZ2UgbmV3IHJvd3MgaW50byB0aGUgRE9NXG4gIHZhciBuZXh0T2xkID0gZ2V0TmV4dEluZm8ob2xkUm93cywgMCk7XG4gIHZhciBuZXh0TmV3ID0gZ2V0TmV4dEluZm8obmV3Um93cywgMCk7XG4gIHZhciBjb21wYXJhdG9yID0gdGhpcy5nZXRTb3J0Q29tcGFyYXRvcl8oKTtcbiAgd2hpbGUgKG5leHROZXcuaW5kZXggPCBuZXdSb3dzLmxlbmd0aCAmJiBuZXh0T2xkLmluZGV4IDwgb2xkUm93cy5sZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcihuZXh0TmV3LmxvZ0VudHJ5LCBuZXh0T2xkLmxvZ0VudHJ5KSA8PSAwKSB7XG4gICAgICBuZXh0TmV3LnRhYmxlUm93Lmluc2VydEJlZm9yZShuZXh0T2xkLnRhYmxlUm93KTtcbiAgICAgIG5leHROZXcgPSBnZXROZXh0SW5mbyhuZXdSb3dzLCBuZXh0TmV3LmluZGV4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRPbGQgPSBnZXROZXh0SW5mbyhvbGRSb3dzLCBuZXh0T2xkLmluZGV4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IHdoYXRldmVyJ3MgbGVmdCBvbiB0aGUgZW5kIG9mIHRoZSB0YWJsZVxuICB0Ym9keS5hcHBlbmQobmV3Um93cy5zbGljZShuZXh0TmV3LmluZGV4KSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGhlbHBlciBvYmplY3QgZm9yIHBlcmZvcm1pbmcgdGhlIGxvZyByb3cgbWVyZ2UuXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm93cyAtIFdyYXBwZWQgY29sbGVjdGlvbiBvZiB0YWJsZSByb3dzLlxuICogQHBhcmFtIHshbnVtYmVyfSBhdEluZGV4IC0gSW5kZXggaW50byBgcm93c2AgYXQgd2hpY2ggaW5mbyBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICogQHJldHVybnMge3tpbmRleDogbnVtYmVyLCB0YWJsZVJvdzogalF1ZXJ5LCBsb2dFbnRyeTogTmV0U2ltTG9nRW50cnl9fVxuICovXG5mdW5jdGlvbiBnZXROZXh0SW5mbyhyb3dzLCBhdEluZGV4KSB7XG4gIHZhciByb3cgPSByb3dzLmVxKGF0SW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBhdEluZGV4LFxuICAgIHRhYmxlUm93OiByb3csXG4gICAgbG9nRW50cnk6IHJvdy5sZW5ndGggPiAwID8gcm93LmRhdGEoTE9HX0VOVFJZX0RBVEFfS0VZKSA6IHt9XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHshTmV0U2ltTG9nRW50cnlbXX0gbG9nRW50cmllc1xuICogQHJldHVybnMge05ldFNpbUxvZ0VudHJ5W119IHN1YnNldCBvZiBsb2dFbnRyaWVzLCBzb3J0ZWQgYW5kIGZpbHRlcmVkXG4gKiAgICAgICAgICBhY2NvcmRpbmcgdG8gdGhlIGxvZyBicm93c2VyJ3MgY3VycmVudCBzZXR0aW5ncy5cbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLmdldFNvcnRlZEZpbHRlcmVkTG9nRW50cmllcyA9IGZ1bmN0aW9uIChsb2dFbnRyaWVzKSB7XG4gIC8vIEZpbHRlciBlbnRyaWVzIHRvIGN1cnJlbnQgbG9nIGJyb3dzZXIgZmlsdGVyIG1vZGVcbiAgdmFyIGZpbHRlcmVkTG9nRW50cmllcyA9IHRoaXMuaXNBbGxSb3V0ZXJMb2dNb2RlXyA/XG4gICAgICBsb2dFbnRyaWVzIDpcbiAgICAgIGxvZ0VudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkubm9kZUlEID09PSB0aGlzLnJvdXRlcl8uZW50aXR5SUQ7XG4gICAgICB9LCB0aGlzKTtcblxuICByZXR1cm4gZmlsdGVyZWRMb2dFbnRyaWVzLnNvcnQodGhpcy5nZXRTb3J0Q29tcGFyYXRvcl8oKSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgbG9nIGVudHJ5LCBnZW5lcmF0ZSBhIHRhYmxlIHJvdyB0aGF0IGNhbiBiZSBhZGRlZCB0byB0aGUgbG9nIG1vZGFsLlxuICogQHBhcmFtIHshTmV0U2ltTG9nRW50cnl9IGxvZ0VudHJ5XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gYSB0ciBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLm1ha2VUYWJsZVJvd18gPSBmdW5jdGlvbiAobG9nRW50cnkpIHtcbiAgdmFyIGhlYWRlckZpZWxkcyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5yb3V0ZXJFeHBlY3RzUGFja2V0SGVhZGVyO1xuXG4gIHZhciBzaG93VG9BZGRyZXNzID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuVE9fQUREUkVTUykgPiAtMTtcblxuICB2YXIgc2hvd0Zyb21BZGRyZXNzID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuRlJPTV9BRERSRVNTKSA+IC0xO1xuXG4gIHZhciBzaG93UGFja2V0SW5mbyA9IGhlYWRlckZpZWxkcy5pbmRleE9mKFBhY2tldC5IZWFkZXJUeXBlLlBBQ0tFVF9JTkRFWCkgPiAtMSAmJlxuICAgICAgaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0NPVU5UKSA+IC0xO1xuXG4gIHZhciBvcmlnaW5Ob2RlID0gbG9nRW50cnkuZ2V0T3JpZ2luTm9kZSgpO1xuXG4gIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gIC8vIFN0b3JlIHRoZSBhY3R1YWwgbG9nRW50cnkgb24gdGhlIHJvdyBmb3Igc29ydGluZy9tZXJnaW5nIGxhdGVyLlxuICAkKHJvdykuZGF0YShMT0dfRU5UUllfREFUQV9LRVksIGxvZ0VudHJ5KTtcblxuICByb3cuYXBwZW5kQ2hpbGQobWFrZUNlbGwobG9nRW50cnkuZ2V0VGltZVN0cmluZygpKSk7XG5cbiAgcm93LmFwcGVuZENoaWxkKG1ha2VDZWxsKG9yaWdpbk5vZGUgP1xuICAgICAgb3JpZ2luTm9kZS5nZXREaXNwbGF5TmFtZSgpIDogbG9nRW50cnkubm9kZUlEKSk7XG5cbiAgcm93LmFwcGVuZENoaWxkKG1ha2VDZWxsKGxvZ0VudHJ5LmdldExvY2FsaXplZFN0YXR1cygpKSk7XG5cbiAgaWYgKHNob3dGcm9tQWRkcmVzcykge1xuICAgIHJvdy5hcHBlbmRDaGlsZChtYWtlQ2VsbChsb2dFbnRyeS5nZXRIZWFkZXJGaWVsZChQYWNrZXQuSGVhZGVyVHlwZS5GUk9NX0FERFJFU1MpKSk7XG4gIH1cblxuICBpZiAoc2hvd1RvQWRkcmVzcykge1xuICAgIHJvdy5hcHBlbmRDaGlsZChtYWtlQ2VsbChsb2dFbnRyeS5nZXRIZWFkZXJGaWVsZChQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTKSkpO1xuICB9XG5cbiAgaWYgKHNob3dQYWNrZXRJbmZvKSB7XG4gICAgcm93LmFwcGVuZENoaWxkKG1ha2VDZWxsKGxvZ0VudHJ5LmdldExvY2FsaXplZFBhY2tldEluZm8oKSkpO1xuICB9XG5cbiAgdmFyIHRkTWVzc2FnZUJvZHkgPSBtYWtlQ2VsbChsb2dFbnRyeS5nZXRNZXNzYWdlQXNjaWkoKSk7XG4gIHRkTWVzc2FnZUJvZHkuY2xhc3NOYW1lID0gJ21lc3NhZ2UnO1xuICByb3cuYXBwZW5kQ2hpbGQodGRNZXNzYWdlQm9keSk7XG5cbiAgcmV0dXJuIHJvdztcbn07XG5cbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRoZSBuZXcgVEQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gbWFrZUNlbGwodGV4dCkge1xuICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICB0ZC5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gIHRkLnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIHRkO1xufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgc29ydCBzZXR0aW5ncyBhbmQgcmUtcmVuZGVyIHRoZSBsb2cgdGFibGUuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHNvcnRLZXlcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5vblNvcnRIZWFkZXJDbGlja18gPSBmdW5jdGlvbiAoc29ydEtleSkge1xuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5zb3J0QnlfID09PSBzb3J0S2V5KSB7XG4gICAgdGhpcy5zb3J0RGVzY2VuZGluZ18gPSAhdGhpcy5zb3J0RGVzY2VuZGluZ187XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zb3J0QnlfID0gc29ydEtleTtcbiAgICB0aGlzLnNvcnREZXNjZW5kaW5nXyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBieSB0aGUgc3VtdWxhdGlvbidzIG9uUm91dGVyQ29ubmVjdCBhbmQgb25Sb3V0ZXJEaXNjb25uZWN0XG4gKiBtZXRob2RzLCB0aGlzIGxvY2FsbHkgcmVtZW1iZXJzIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZSBhbmQgdHJpZ2dlcnNcbiAqIGEgcmVyZW5kZXJcbiAqIEBwYXJhbSB7TmV0U2ltUm91dGVyTm9kZX0gcm91dGVyXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5zZXRSb3V0ZXIgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gIHRoaXMucm91dGVyXyA9IHJvdXRlcjtcbiAgdGhpcy5pc0FsbFJvdXRlckxvZ01vZGVfID0gIXRoaXMuaGFzTG9jYWxSb3V0ZXJfKCk7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBjYXBhYmxlIG9mIGxvZ2dpbmcgYWxsIHJvdXRlcnMgb3Igbm90LlxuICogSXMgYWx3YXlzIHRydWUgaWYgd2UgYXJlIGluIGEgbGV2ZWwgd2l0aCBjb25uZWN0ZWQgcm91dGVycy5cbiAqIE90aGVyd2lzZSwgaXMgb25seSB0cnVlIGlmIHdlIGFyZSBub3QgbG9jYWxseSBjb25uZWN0ZWQgdG8gYSByb3V0ZXIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlckxvZ01vZGFsLnByb3RvdHlwZS5jYW5Mb2dBbGxSb3V0ZXJzXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5jb25uZWN0ZWRSb3V0ZXJzIHx8ICF0aGlzLmhhc0xvY2FsUm91dGVyXygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWZmIHdlIGFyZSBsb2NhbGx5IGNvbm5lY3RlZCB0byBhIHJvdXRlci5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLmhhc0xvY2FsUm91dGVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKHRoaXMucm91dGVyXyk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiBhbGwtcm91dGVyIGFuZCBzaW5nbGUtcm91dGVyIGxvZ1xuICogbW9kZS4gV2UgY2FuIHN3aXRjaCB0byBzaW5nbGUtcm91dGVyIGlmZiB3ZSBoYXZlIGEgbG9jYWwgcm91dGVyLCBhbmRcbiAqIHdlIGNhbiBzd2l0Y2ggdG8gYWxsLXJvdXRlciBpZmYgd2UgYXJlIGNhcGFibGUgb2YgbG9nZ2luZyBhbGwgcm91dGVyc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJMb2dNb2RhbC5wcm90b3R5cGUuY2FuVG9nZ2xlUm91dGVyTG9nTW9kZV8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzQWxsUm91dGVyTG9nTW9kZV8pIHtcbiAgICByZXR1cm4gdGhpcy5oYXNMb2NhbFJvdXRlcl8oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2dBbGxSb3V0ZXJzXygpO1xuICB9XG59O1xuXG4vKipcbiAqIFRvZ2dsZXMgdGhpcy5pc0FsbFJvdXRlckxvZ01vZGVfIGJldHdlZW4gYHRydWVgIGFuZCBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJMb2dNb2RhbC5wcm90b3R5cGUudG9nZ2xlUm91dGVyTG9nTW9kZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNBbGxSb3V0ZXJMb2dNb2RlXyA9ICF0aGlzLmlzQWxsUm91dGVyTG9nTW9kZV87XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBidXR0b24gdXNlZCB0byB0b2dnbGUgYmV0d2VlbiByb3V0ZXIgbG9nIG1vZGVzXG4gKiBAcmV0dXJucyB7alF1ZXJ5fVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLmdldFJvdXRlckxvZ1RvZ2dsZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdERpdl8uZmluZCgnYnV0dG9uI3JvdXRlcmxvZy10b2dnbGUnKTtcbn07XG5cbi8qKlxuICogR2l2ZSB0aGUgbG9nIGJyb3dzZXIgYSByZWZlcmVuY2UgdG8gdGhlIHNoYXJkLCBzbyB0aGF0IGl0IGNhbiBxdWVyeSB0aGVcbiAqIGxvZyB0YWJsZS4gIE9yLCBwYXNzIG51bGwgd2hlbiBkaXNjb25uZWN0aW5nIGZyb20gYSBzaGFyZC5cbiAqIEBwYXJhbSB7TmV0U2ltU2hhcmR8bnVsbH0gbmV3U2hhcmRcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLnNldFNoYXJkID0gZnVuY3Rpb24gKG5ld1NoYXJkKSB7XG5cbiAgaWYgKHRoaXMuZXZlbnRLZXlzXy5yZWdpc3RlcmVkV2l0aFNoYXJkKSB7XG4gICAgdGhpcy5ldmVudEtleXNfLnJlZ2lzdGVyZWRXaXRoU2hhcmQubG9nVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXNfLmxvZ1RhYmxlQ2hhbmdlKTtcbiAgICB0aGlzLmV2ZW50S2V5c18ucmVnaXN0ZXJlZFdpdGhTaGFyZCA9IG51bGw7XG4gIH1cblxuICBpZiAobmV3U2hhcmQpIHtcbiAgICB0aGlzLmV2ZW50S2V5c18ubG9nVGFibGVDaGFuZ2UgPSBuZXdTaGFyZC5sb2dUYWJsZS50YWJsZUNoYW5nZS5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5vbkxvZ1RhYmxlQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV2ZW50S2V5c18ucmVnaXN0ZXJlZFdpdGhTaGFyZCA9IG5ld1NoYXJkO1xuICB9XG5cbiAgLy8gV2hlbiBjaGFuZ2luZyBzaGFyZHMsIHJlc2V0IGxvZyBzbyB3ZSBmZXRjaCB0aGUgd2hvbGUgdGhpbmcgbmV4dCB0aW1lLlxuICB0aGlzLmxvZ0VudHJpZXNfLmxlbmd0aCA9IDA7XG4gIHRoaXMubGF0ZXN0Um93SURfID0gMDtcbiAgdGhpcy5zaGFyZF8gPSBuZXdTaGFyZDtcbn07XG5cbi8qKlxuICogSGFuZGxlIGxvZyB0YWJsZSBjaGFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTG9nTW9kYWwucHJvdG90eXBlLm9uTG9nVGFibGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZGVyU3BlYyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5yb3V0ZXJFeHBlY3RzUGFja2V0SGVhZGVyO1xuICB2YXIgbmV3Um93cyA9IHRoaXMuc2hhcmRfLmxvZ1RhYmxlLnJlYWRBbGxGcm9tSUQodGhpcy5sYXRlc3RSb3dJRF8gKyAxKTtcbiAgdmFyIG5ld0xvZ0VudHJpZXMgPSBuZXdSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgdGhpcy5sYXRlc3RSb3dJRF8gPSBNYXRoLm1heChyb3cuaWQsIHRoaXMubGF0ZXN0Um93SURfKTtcbiAgICByZXR1cm4gbmV3IE5ldFNpbUxvZ0VudHJ5KHRoaXMuc2hhcmRfLCByb3csIGhlYWRlclNwZWMpO1xuICB9LCB0aGlzKTtcbiAgLy8gTW9kaWZ5IHRoaXMubG9nRW50cmllc18gaW4tcGxhY2UsIGFwcGVuZGluZyBuZXcgbG9nIGVudHJpZXNcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5sb2dFbnRyaWVzXywgbmV3TG9nRW50cmllcyk7XG4gIHRoaXMucmVuZGVyTmV3TG9nRW50cmllc18obmV3TG9nRW50cmllcyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vUGFja2V0Jyk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG52YXIgaGVhZGVyRmllbGRzID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLnJvdXRlckV4cGVjdHNQYWNrZXRIZWFkZXI7XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbnZhciBzaG93VG9BZGRyZXNzID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuVE9fQUREUkVTUykgPiAtMTtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xudmFyIHNob3dGcm9tQWRkcmVzcyA9IGhlYWRlckZpZWxkcy5pbmRleE9mKFBhY2tldC5IZWFkZXJUeXBlLkZST01fQUREUkVTUykgPiAtMTtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xudmFyIHNob3dQYWNrZXRJbmZvID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0lOREVYKSA+IC0xICYmXG4gICAgaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0NPVU5UKSA+IC0xO1xuXG4vKipcbiAqIEBuYW1lIGlzQWxsUm91dGVyTG9nTW9kZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzb3J0QnlcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzb3J0RGVzY2VuZGluZ1xuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gc29ydE1hcmt1cEZvcihzb3J0S2V5KSB7XG4gIGlmIChzb3J0S2V5ID09PSBzb3J0QnkpIHtcbiAgICBpZiAoc29ydERlc2NlbmRpbmcpIHtcbiAgICAgIHJldHVybiAnPGkgY2xhc3M9XCJmYSBmYS1zb3J0LWRlc2NcIj48L2k+JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICc8aSBjbGFzcz1cImZhIGZhLXNvcnQtYXNjXCI+PC9pPic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgbW9kYWwtbGdcIj5cXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPjxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+PC9idXR0b24+XFxuXFxuICAgICAgJyk7NDg7IGlmIChjYW5Ub2dnbGVSb3V0ZXJMb2dNb2RlKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJyb3V0ZXJsb2ctdG9nZ2xlXCIgY2xhc3M9XCJwdWxsLXJpZ2h0IGJ0biBidG4tcHJpbWFyeSBidG4tbWluaVwiPicsIGVzY2FwZSgoNDksICAoaXNBbGxSb3V0ZXJMb2dNb2RlKSA/IGkxOG4ubG9nQnJvd3NlckhlYWRlcl90b2dnbGVNaW5lKCkgOiBpMThuLmxvZ0Jyb3dzZXJIZWFkZXJfdG9nZ2xlQWxsKCkgKSksICc8L2J1dHRvbj5cXG4gICAgICAnKTs1MDsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG4gICAgICAnKTs1MjsgaWYgKGlzQWxsUm91dGVyTG9nTW9kZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+JywgZXNjYXBlKCg1MywgIGkxOG4ubG9nQnJvd3NlckhlYWRlcl9hbGwoKSApKSwgJzwvaDQ+XFxuICAgICAgJyk7NTQ7IH0gZWxzZSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj4nLCBlc2NhcGUoKDU1LCAgaTE4bi5sb2dCcm93c2VySGVhZGVyX21pbmUoKSApKSwgJzwvaDQ+XFxuICAgICAgJyk7NTY7IH0gOyBidWYucHVzaCgnXFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxcbiAgICAgIDx0YWJsZT5cXG4gICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aCBub3dyYXAgZGF0YS1zb3J0LWtleT1cInRpbWVzdGFtcFwiPicsIGVzY2FwZSgoNjIsICBpMThuLnRpbWUoKSApKSwgJyAnLCAoNjIsICBzb3J0TWFya3VwRm9yKCd0aW1lc3RhbXAnKSApLCAnPC90aD5cXG4gICAgICAgICAgICA8dGggbm93cmFwIGRhdGEtc29ydC1rZXk9XCJsb2dnZWQtYnlcIj4nLCBlc2NhcGUoKDYzLCAgaTE4bi5sb2dnZWRCeU5vZGUoKSApKSwgJyAnLCAoNjMsICBzb3J0TWFya3VwRm9yKCdsb2dnZWQtYnknKSApLCAnPC90aD5cXG4gICAgICAgICAgICA8dGggbm93cmFwIGRhdGEtc29ydC1rZXk9XCJzdGF0dXNcIj4nLCBlc2NhcGUoKDY0LCAgaTE4bi5zdGF0dXMoKSApKSwgJyAnLCAoNjQsICBzb3J0TWFya3VwRm9yKCdzdGF0dXMnKSApLCAnPC90aD5cXG4gICAgICAgICAgICAnKTs2NTsgaWYgKHNob3dGcm9tQWRkcmVzcykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgICAgIDx0aCBub3dyYXAgZGF0YS1zb3J0LWtleT1cImZyb20tYWRkcmVzc1wiPicsIGVzY2FwZSgoNjYsICBpMThuLmZyb20oKSApKSwgJyAnLCAoNjYsICBzb3J0TWFya3VwRm9yKCdmcm9tLWFkZHJlc3MnKSApLCAnPC90aD5cXG4gICAgICAgICAgICAnKTs2NzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgICAnKTs2ODsgaWYgKHNob3dUb0FkZHJlc3MpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgICA8dGggbm93cmFwIGRhdGEtc29ydC1rZXk9XCJ0by1hZGRyZXNzXCI+JywgZXNjYXBlKCg2OSwgIGkxOG4udG8oKSApKSwgJyAnLCAoNjksICBzb3J0TWFya3VwRm9yKCd0by1hZGRyZXNzJykgKSwgJzwvdGg+XFxuICAgICAgICAgICAgJyk7NzA7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgJyk7NzE7IGlmIChzaG93UGFja2V0SW5mbykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgICAgIDx0aCBub3dyYXAgZGF0YS1zb3J0LWtleT1cInBhY2tldC1pbmZvXCI+JywgZXNjYXBlKCg3MiwgIGkxOG4ucGFja2V0KCkgKSksICcgJywgKDcyLCAgc29ydE1hcmt1cEZvcigncGFja2V0LWluZm8nKSApLCAnPC90aD5cXG4gICAgICAgICAgICAnKTs3MzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgICA8dGggbm93cmFwIGRhdGEtc29ydC1rZXk9XCJtZXNzYWdlXCI+JywgZXNjYXBlKCg3NCwgIGkxOG4ubWVzc2FnZSgpICkpLCAnICcsICg3NCwgIHNvcnRNYXJrdXBGb3IoJ21lc3NhZ2UnKSApLCAnPC90aD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICA8dGJvZHk+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwvdGFibGU+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XFxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPkNsb3NlPC9idXR0b24+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIHNsaWRlciB1c2VkIHRvIGNoYW5nZSBtYXhpbXVtIHBhY2tldCBsZW5ndGguXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltU2xpZGVyID0gcmVxdWlyZSgnLi9OZXRTaW1TbGlkZXInKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIHBhY2tldCBzaXplIHNsaWRlci9zZWxlY3RvclxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXZcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhY2tldFNpemVDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1pbmltdW1QYWNrZXRTaXplXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1TbGlkZXJcbiAqL1xudmFyIE5ldFNpbVBhY2tldFNpemVDb250cm9sID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdixcbiAgICBwYWNrZXRTaXplQ2hhbmdlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgTmV0U2ltU2xpZGVyLmNhbGwodGhpcywgcm9vdERpdiwge1xuICAgIG9uQ2hhbmdlOiBwYWNrZXRTaXplQ2hhbmdlQ2FsbGJhY2ssXG4gICAgbWluOiBvcHRpb25zLm1pbmltdW1QYWNrZXRTaXplLFxuICAgIG1heDogODE5MixcbiAgICB1cHBlckJvdW5kSW5maW5pdGU6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIEF1dG8tcmVuZGVyLCB1bmxpa2Ugb3VyIGJhc2UgY2xhc3NcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5OZXRTaW1QYWNrZXRTaXplQ29udHJvbC5pbmhlcml0cyhOZXRTaW1TbGlkZXIpO1xuXG4vKipcbiAqIEdldCBsb2NhbGl6ZWQgcGFja2V0IHNpemUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiBwYWNrZXQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWNrZXRTaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5OZXRTaW1QYWNrZXRTaXplQ29udHJvbC5wcm90b3R5cGUuZ2V0UGFja2V0U2l6ZVRleHQgPSBmdW5jdGlvbiAocGFja2V0U2l6ZSkge1xuICByZXR1cm4gaTE4bi5udW1CaXRzUGVyUGFja2V0KHsgbnVtQml0czogcGFja2V0U2l6ZSB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1lcmljIHZhbHVlIChpbiBiaXRzKSBpbnRvIGEgY29tcGFjdCBsb2NhbGl6ZWQgc3RyaW5nXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIG51bWVyaWMgdmFsdWUgb2YgdGhlIGNvbnRyb2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICogQG92ZXJyaWRlXG4gKi9cbk5ldFNpbVBhY2tldFNpemVDb250cm9sLnByb3RvdHlwZS52YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICh2YWwgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIGkxOG4udW5saW1pdGVkKCk7XG4gIH1cbiAgcmV0dXJuIGkxOG4ubnVtQml0c1BlclBhY2tldCh7bnVtQml0czogdmFsfSk7XG59O1xuXG4vKipcbiAqIEdldCBsYWJlbHMgZm9yIGVuZCBzbGlkZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQG92ZXJyaWRlXG4gKi9cbk5ldFNpbVBhY2tldFNpemVDb250cm9sLnByb3RvdHlwZS52YWx1ZVRvU2hvcnRMYWJlbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gaTE4bi51bmxpbWl0ZWQoKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbnRyb2xsZXIgZm9yIHRoZSBwYWNrZXQgZWRpdG9yIHdoaWNoIGFsbG93cyBlZGl0aW5nIG11bHRpcGxlXG4gKiAgICAgICAgICAgZW5jb2RpbmdzIGF0IG9uY2UgYW5kIGxpdmVzIGluc2lkZSB0aGUgc2VuZCBwYW5lbC5cbiAqIEBzZWUgTmV0U2ltU2VuZFBhbmVsIGZvciBob3cgdGhpcyBpcyB1c2VkLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4cGFyYW1zOiAzLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL3V0aWxzJyk7IC8vIEZvciBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMoKVxudmFyIG5ldHNpbU1zZyA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1QYWNrZXRFZGl0b3IuaHRtbC5lanMnKTtcbnZhciBLZXlDb2RlcyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLktleUNvZGVzO1xudmFyIE5ldFNpbUVuY29kaW5nQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltRW5jb2RpbmdDb250cm9sJyk7XG52YXIgTmV0U2ltTG9nUGFuZWwgPSByZXF1aXJlKCcuL05ldFNpbUxvZ1BhbmVsJyk7XG52YXIgUGFja2V0ID0gcmVxdWlyZSgnLi9QYWNrZXQnKTtcbnZhciBEYXRhQ29udmVydGVycyA9IHJlcXVpcmUoJy4vRGF0YUNvbnZlcnRlcnMnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcblxudmFyIEVuY29kaW5nVHlwZSA9IE5ldFNpbUNvbnN0YW50cy5FbmNvZGluZ1R5cGU7XG52YXIgQklUU19QRVJfQllURSA9IE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9CWVRFO1xuXG52YXIgbWluaWZ5QmluYXJ5ID0gRGF0YUNvbnZlcnRlcnMubWluaWZ5QmluYXJ5O1xudmFyIGZvcm1hdEFCID0gRGF0YUNvbnZlcnRlcnMuZm9ybWF0QUI7XG52YXIgZm9ybWF0QmluYXJ5ID0gRGF0YUNvbnZlcnRlcnMuZm9ybWF0QmluYXJ5O1xudmFyIGZvcm1hdEhleCA9IERhdGFDb252ZXJ0ZXJzLmZvcm1hdEhleDtcbnZhciBhbGlnbkRlY2ltYWwgPSBEYXRhQ29udmVydGVycy5hbGlnbkRlY2ltYWw7XG52YXIgYWJUb0JpbmFyeSA9IERhdGFDb252ZXJ0ZXJzLmFiVG9CaW5hcnk7XG52YXIgYWJUb0ludCA9IERhdGFDb252ZXJ0ZXJzLmFiVG9JbnQ7XG52YXIgYmluYXJ5VG9BQiA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQUI7XG52YXIgYmluYXJ5VG9IZXggPSBEYXRhQ29udmVydGVycy5iaW5hcnlUb0hleDtcbnZhciBiaW5hcnlUb0ludCA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvSW50O1xudmFyIGJpbmFyeVRvRGVjaW1hbCA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvRGVjaW1hbDtcbnZhciBiaW5hcnlUb0FzY2lpID0gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9Bc2NpaTtcbnZhciBoZXhUb0JpbmFyeSA9IERhdGFDb252ZXJ0ZXJzLmhleFRvQmluYXJ5O1xudmFyIGludFRvQUIgPSBEYXRhQ29udmVydGVycy5pbnRUb0FCO1xudmFyIGludFRvQmluYXJ5ID0gRGF0YUNvbnZlcnRlcnMuaW50VG9CaW5hcnk7XG52YXIgaW50VG9IZXggPSBEYXRhQ29udmVydGVycy5pbnRUb0hleDtcbnZhciBkZWNpbWFsVG9CaW5hcnkgPSBEYXRhQ29udmVydGVycy5kZWNpbWFsVG9CaW5hcnk7XG52YXIgYXNjaWlUb0JpbmFyeSA9IERhdGFDb252ZXJ0ZXJzLmFzY2lpVG9CaW5hcnk7XG5cbi8qKlxuICogVHlwZSBmb3IgdHJ1Y3R1cmVkIGFjY2VzcyB0byBqUXVlcnktd3JhcHBlZCBET00gZWxlbWVudHMuICBUd28gbGF5ZXJzIGRlZXA7XG4gKiBjYW4gYmUgdXNlZCBmb3IgcXVpY2sgYWNjZXNzIHRvIG9uZSBvZiB0aGUgZmllbGRzIGluIHRoZSBwYWNrZXQgZWRpdG9yIGdyaWRcbiAqIGJ5IHJlZmVyZW5jaW5nIHZpYSByb3cgYW5kIGNvbHVtbi5cbiAqXG4gKiBNYXAga2V5cyBhdCB0aGUgZmlyc3QgbGF5ZXIgY29ycmVzcG9uZCB0byBOZXRTaW1Db25zdGFudHMuRW5jb2RpbmdUeXBlLlxuICogTWFwIGtleXMgYXQgdGhlIHNlY29uZCBsYXllciBjb3JyZXNwb25kIHRvIFBhY2tldC5IZWFkZXJUeXBlLCBwbHVzIHRoZVxuICogICAnbWVzc2FnZScgZmllbGQuXG4gKlxuICogVXNhZ2U6XG4gKiAgIG1hcC5iaW5hcnkuZnJvbUFkZHJlc3NcbiAqICAgbWFwWydiaW5hcnknXVsnZnJvbUFkZHJlc3MnXVxuICogICBtYXBbRW5jb2RpbmdUeXBlLkJJTkFSWV1bUGFja2V0LkhlYWRlclR5cGUuRlJPTV9BRERSRVNTXVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVJTWFwXG4gKiBAcHJvcGVydHkge1VJUm93TWFwfSBhX2FuZF9iXG4gKiBAcHJvcGVydHkge1VJUm93TWFwfSBiaW5hcnlcbiAqIEBwcm9wZXJ0eSB7VUlSb3dNYXB9IGhleGFkZWNpbWFsXG4gKiBAcHJvcGVydHkge1VJUm93TWFwfSBkZWNpbWFsXG4gKiBAcHJvcGVydHkge1VJUm93TWFwfSBhc2NpaVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVUlSb3dNYXBcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fSB0b0FkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fSBmcm9tQWRkcmVzc1xuICogQHByb3BlcnR5IHtqUXVlcnl9IHBhY2tldEluZGV4XG4gKiBAcHJvcGVydHkge2pRdWVyeX0gcGFja2V0Q291bnRcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fSBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIG1lc3NhZ2Ugc2VuZGluZyB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxDb25maWdcbiAqIEBwYXJhbSB7TWVzc2FnZUdyYW51bGFyaXR5fSBpbml0aWFsQ29uZmlnLm1lc3NhZ2VHcmFudWxhcml0eVxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZVtdfSBpbml0aWFsQ29uZmlnLnBhY2tldFNwZWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbENvbmZpZy50b0FkZHJlc3NdXG4gKiBAcGFyYW0ge251bWJlcn0gW2luaXRpYWxDb25maWcuZnJvbUFkZHJlc3NdXG4gKiBAcGFyYW0ge251bWJlcn0gW2luaXRpYWxDb25maWcucGFja2V0SW5kZXhdXG4gKiBAcGFyYW0ge251bWJlcn0gW2luaXRpYWxDb25maWcucGFja2V0Q291bnRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2luaXRpYWxDb25maWcubWVzc2FnZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbENvbmZpZy5tYXhQYWNrZXRTaXplXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbml0aWFsQ29uZmlnLmNodW5rU2l6ZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbENvbmZpZy5iaXRSYXRlXVxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gW2luaXRpYWxDb25maWcuZW5hYmxlZEVuY29kaW5nc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGluaXRpYWxDb25maWcucmVtb3ZlUGFja2V0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGluaXRpYWxDb25maWcuZG9uZVNlbmRpbmdDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gaW5pdGlhbENvbmZpZy5jb250ZW50Q2hhbmdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGluaXRpYWxDb25maWcuZW50ZXJLZXlQcmVzc2VkQ2FsbGJhY2tcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltUGFja2V0RWRpdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5pdGlhbENvbmZpZykge1xuICB2YXIgbGV2ZWwgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtSb3dUeXBlW119XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5ST1dfVFlQRVMgPSBbXG4gICAge1xuICAgICAgdHlwZU5hbWU6IEVuY29kaW5nVHlwZS5BX0FORF9CLFxuICAgICAgYWRkcmVzc0ZpZWxkQWxsb3dlZENoYXJhY3RlcnM6IC9bQUJcXHNdL2ksXG4gICAgICBhZGRyZXNzRmllbGRDb252ZXJzaW9uOiBmdW5jdGlvbiAoYWJTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQWRkcmVzc1N0cmluZyhcbiAgICAgICAgICAgIERhdGFDb252ZXJ0ZXJzLmFiVG9CaW5hcnkoYWJTdHJpbmcpLCBsZXZlbC5hZGRyZXNzRm9ybWF0KTtcbiAgICAgIH0sXG4gICAgICBzaG9ydE51bWJlckFsbG93ZWRDaGFyYWN0ZXJzOiAvW0FCXS9pLFxuICAgICAgc2hvcnROdW1iZXJDb252ZXJzaW9uOiB0cnVuY2F0ZWRBQlRvSW50LFxuICAgICAgbWVzc2FnZUFsbG93ZWRDaGFyYWN0ZXJzOiAvW0FCXFxzXS9pLFxuICAgICAgbWVzc2FnZUNvbnZlcnNpb246IGFiVG9CaW5hcnlcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGVOYW1lOiBFbmNvZGluZ1R5cGUuQklOQVJZLFxuICAgICAgYWRkcmVzc0ZpZWxkQWxsb3dlZENoYXJhY3RlcnM6IC9bMDFcXHNdL2ksXG4gICAgICBhZGRyZXNzRmllbGRDb252ZXJzaW9uOiBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBEYXRhQ29udmVydGVycy5iaW5hcnlUb0FkZHJlc3NTdHJpbmcoXG4gICAgICAgICAgICBiaW5hcnlTdHJpbmcsIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xuICAgICAgfSxcbiAgICAgIHNob3J0TnVtYmVyQWxsb3dlZENoYXJhY3RlcnM6IC9bMDFdLyxcbiAgICAgIHNob3J0TnVtYmVyQ29udmVyc2lvbjogdHJ1bmNhdGVkQmluYXJ5VG9JbnQsXG4gICAgICBtZXNzYWdlQWxsb3dlZENoYXJhY3RlcnM6IC9bMDFcXHNdLyxcbiAgICAgIG1lc3NhZ2VDb252ZXJzaW9uOiBtaW5pZnlCaW5hcnlcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGVOYW1lOiBFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwsXG4gICAgICBhZGRyZXNzRmllbGRBbGxvd2VkQ2hhcmFjdGVyczogL1swLTlhLWZcXHNdL2ksXG4gICAgICBhZGRyZXNzRmllbGRDb252ZXJzaW9uOiBmdW5jdGlvbiAoaGV4U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBEYXRhQ29udmVydGVycy5iaW5hcnlUb0FkZHJlc3NTdHJpbmcoXG4gICAgICAgICAgICBEYXRhQ29udmVydGVycy5oZXhUb0JpbmFyeShoZXhTdHJpbmcpLCBsZXZlbC5hZGRyZXNzRm9ybWF0KTtcbiAgICAgIH0sXG4gICAgICBzaG9ydE51bWJlckFsbG93ZWRDaGFyYWN0ZXJzOiAvWzAtOWEtZl0vaSxcbiAgICAgIHNob3J0TnVtYmVyQ29udmVyc2lvbjogdHJ1bmNhdGVkSGV4VG9JbnQsXG4gICAgICBtZXNzYWdlQWxsb3dlZENoYXJhY3RlcnM6IC9bMC05YS1mXFxzXS9pLFxuICAgICAgbWVzc2FnZUNvbnZlcnNpb246IGhleFRvQmluYXJ5XG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlTmFtZTogRW5jb2RpbmdUeXBlLkRFQ0lNQUwsXG4gICAgICBhZGRyZXNzRmllbGRBbGxvd2VkQ2hhcmFjdGVyczogL1swLTkuXFxzXS9pLFxuICAgICAgYWRkcmVzc0ZpZWxkQ29udmVyc2lvbjogY2xlYW5BZGRyZXNzU3RyaW5nLFxuICAgICAgc2hvcnROdW1iZXJBbGxvd2VkQ2hhcmFjdGVyczogL1swLTldLyxcbiAgICAgIHNob3J0TnVtYmVyQ29udmVyc2lvbjogdHJ1bmNhdGVkRGVjaW1hbFRvSW50LFxuICAgICAgbWVzc2FnZUFsbG93ZWRDaGFyYWN0ZXJzOiAvWzAtOVxcc10vLFxuICAgICAgbWVzc2FnZUNvbnZlcnNpb246IGZ1bmN0aW9uIChkZWNpbWFsU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBkZWNpbWFsVG9CaW5hcnkoZGVjaW1hbFN0cmluZywgdGhpcy5jdXJyZW50Q2h1bmtTaXplXyk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGVOYW1lOiBFbmNvZGluZ1R5cGUuQVNDSUksXG4gICAgICBhZGRyZXNzRmllbGRBbGxvd2VkQ2hhcmFjdGVyczogL1swLTkuXFxzXS9pLFxuICAgICAgYWRkcmVzc0ZpZWxkQ29udmVyc2lvbjogY2xlYW5BZGRyZXNzU3RyaW5nLFxuICAgICAgc2hvcnROdW1iZXJBbGxvd2VkQ2hhcmFjdGVyczogL1swLTldLyxcbiAgICAgIHNob3J0TnVtYmVyQ29udmVyc2lvbjogdHJ1bmNhdGVkRGVjaW1hbFRvSW50LFxuICAgICAgbWVzc2FnZUFsbG93ZWRDaGFyYWN0ZXJzOiAvLi8sXG4gICAgICBtZXNzYWdlQ29udmVyc2lvbjogZnVuY3Rpb24gKGFzY2lpU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhc2NpaVRvQmluYXJ5KGFzY2lpU3RyaW5nLCB0aGlzLmN1cnJlbnRDaHVua1NpemVfKTtcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgIH1cbiAgXTtcblxuICAvKipcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdERpdl8gPSAkKCc8ZGl2PicpLmFkZENsYXNzKCduZXRzaW0tcGFja2V0Jyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtNZXNzYWdlR3JhbnVsYXJpdHl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1lc3NhZ2VHcmFudWxhcml0eV8gPSBpbml0aWFsQ29uZmlnLm1lc3NhZ2VHcmFudWxhcml0eTtcblxuICAvKipcbiAgICogQHR5cGUge1BhY2tldC5IZWFkZXJUeXBlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhY2tldFNwZWNfID0gaW5pdGlhbENvbmZpZy5wYWNrZXRTcGVjO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLnRvQWRkcmVzcyA9IGluaXRpYWxDb25maWcudG9BZGRyZXNzIHx8XG4gICAgICBEYXRhQ29udmVydGVycy5iaW5hcnlUb0FkZHJlc3NTdHJpbmcoJzAnLCBsZXZlbC5hZGRyZXNzRm9ybWF0KTtcblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5mcm9tQWRkcmVzcyA9IGluaXRpYWxDb25maWcuZnJvbUFkZHJlc3MgfHxcbiAgICAgIERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQWRkcmVzc1N0cmluZygnMCcsIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnBhY2tldEluZGV4ID0gaW5pdGlhbENvbmZpZy5wYWNrZXRJbmRleCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIGluaXRpYWxDb25maWcucGFja2V0SW5kZXggOiAxO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnBhY2tldENvdW50ID0gaW5pdGlhbENvbmZpZy5wYWNrZXRDb3VudCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIGluaXRpYWxDb25maWcucGFja2V0Q291bnQgOiAxO1xuXG4gIC8qKlxuICAgKiBCaW5hcnkgc3RyaW5nIG9mIG1lc3NhZ2UgYm9keSwgbGl2ZS1pbnRlcnByZXRlZCB0byBvdGhlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm1lc3NhZ2UgPSBpbml0aWFsQ29uZmlnLm1lc3NhZ2UgfHwgJyc7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gcGFja2V0IGxlbmd0aCBjb25maWd1cmFibGUgYnkgc2xpZGVyLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXhQYWNrZXRTaXplXyA9IGluaXRpYWxDb25maWcubWF4UGFja2V0U2l6ZSB8fCA4MTkyO1xuXG4gIC8qKlxuICAgKiBCaXRzIHBlciBjaHVuay9ieXRlIGZvciBwYXJzaW5nIGFuZCBmb3JtYXR0aW5nIHB1cnBvc2VzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jdXJyZW50Q2h1bmtTaXplXyA9IGluaXRpYWxDb25maWcuY2h1bmtTaXplIHx8IEJJVFNfUEVSX0JZVEU7XG5cbiAgLyoqXG4gICAqIExvY2FsIGRldmljZSBiaXRyYXRlIChicHMpLCB3aGljaCBhZmZlY3RzIHNlbmQtYW5pbWF0aW9uIHNwZWVkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iaXRSYXRlXyA9IGluaXRpYWxDb25maWcuYml0UmF0ZSB8fCBJbmZpbml0eTtcblxuICB2YXIgZW5jb2RpbmdzID0gaW5pdGlhbENvbmZpZy5lbmFibGVkRW5jb2RpbmdzIHx8IFtdO1xuICAvKipcbiAgICogV2hpY2ggZW5jb2RpbmdzIHNob3VsZCBiZSB2aXNpYmxlIGluIHRoZSBlZGl0b3IuXG4gICAqIEB0eXBlIHtPYmplY3QuPEVuY29kaW5nVHlwZSwgYm9vbGVhbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVuYWJsZWRFbmNvZGluZ3NIYXNoXyA9IE5ldFNpbUVuY29kaW5nQ29udHJvbC5lbmNvZGluZ3NBc0hhc2goZW5jb2RpbmdzKTtcblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNhbGwgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgcGFja2V0IGZyb20gaXRzIHBhcmVudC5cbiAgICogRnVuY3Rpb24gc2hvdWxkIHRha2UgdGhpcyBQYWNrZXRFZGl0b3IgYXMgYW4gYXJndW1lbnQuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVtb3ZlUGFja2V0Q2FsbGJhY2tfID0gaW5pdGlhbENvbmZpZy5yZW1vdmVQYWNrZXRDYWxsYmFjaztcblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNhbGwgd2hlbiB0aGlzIHBhY2tldCBpcyBkb25lIHBsYXlpbmcgaXRzIHNlbmRpbmcgYW5pbWF0aW9uLlxuICAgKiBGdW5jdGlvbiBzaG91bGQgdGFrZSB0aGlzIFBhY2tldEVkaXRvciBhcyBhbiBhcmd1bWVudC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kb25lU2VuZGluZ0NhbGxiYWNrXyA9IGluaXRpYWxDb25maWcuZG9uZVNlbmRpbmdDYWxsYmFjaztcblxuICAvKipcbiAgICogTWV0aG9kIHRvIG5vdGlmeSBvdXIgcGFyZW50IGNvbnRhaW5lciB0aGF0IHRoZSBwYWNrZXQncyBiaW5hcnlcbiAgICogY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jb250ZW50Q2hhbmdlQ2FsbGJhY2tfID0gaW5pdGlhbENvbmZpZy5jb250ZW50Q2hhbmdlQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBub3RpZnkgb3VyIHBhcmVudCBjb250YWluZXIgdGhhdCB0aGUgZW50ZXIga2V5IGhhcyBiZWVuXG4gICAqIHByZXNzZWRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lbnRlcktleVByZXNzZWRDYWxsYmFja18gPSBpbml0aWFsQ29uZmlnLmVudGVyS2V5UHJlc3NlZENhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZW1vdmVQYWNrZXRCdXR0b25fID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYml0Q291bnRlcl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoaXMgcGFja2V0IGVkaXRvciBpcyBpbiBhIG5vbi1pbnRlcmFjdGl2ZSBtb2RlXG4gICAqIHdoZXJlIGl0IGFuaW1hdGVzIGJpdHMgZHJhaW5pbmcvYmVpbmcgc2VudC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHdoZXRoZXIgdGhpcyBlZGl0b3IgaXMgaW4gdGhlIG1pZGRsZSBvZiBhbiBhc3luYyBzZW5kIGNvbW1hbmQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc1NlbmRpbmdQYWNrZXRUb1JlbW90ZV8gPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIGxvY2FsIGNsaWVudCBub2RlLCB1c2VkIGZvciBzZW5kaW5nIG1lc3NhZ2VzLlxuICAgKiBAdHlwZSB7TmV0U2ltTG9jYWxDbGllbnROb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5teU5vZGVfID0gbnVsbDtcblxuICAvKipcbiAgICogQ2FwdHVyZSBwYWNrZXQgYmluYXJ5IGJlZm9yZSB0aGUgc2VuZCBhbmltYXRpb24gYmVnaW5zIHNvIHRoYXQgd2UgY2FuXG4gICAqIHNlbmQgdGhlIHdob2xlIHBhY2tldCB0byByZW1vdGUgc3RvcmFnZSB3aGVuIHRoZSBhbmltYXRpb24gaXMgZG9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMub3JpZ2luYWxCaW5hcnlfID0gJyc7XG5cbiAgLyoqXG4gICAqIEluZGV4IGludG8gb3JpZ2luYWwgYmluYXJ5IGluZGljYXRpbmcgaG93IG1hbnkgYml0cyBoYXZlIGJlZW4gJ3NlbnQnXG4gICAqIGluIHRoZSBhbmltYXRpb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNlbmRBbmltYXRpb25JbmRleF8gPSAwO1xuXG4gIC8qKlxuICAgKiBTaW11bGF0aW9uLXRpbWUgdGltZXN0YW1wIChtcykgb2YgdGhlIGxhc3QgYml0LXNlbmQgYW5pbWF0aW9uLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5sYXN0Qml0U2VudFRpbWVfID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYm91bmQgVUkgZWxlbWVudHMgbWFuaXB1bGF0ZWQgYnkgdGhpcyBlZGl0b3IuICBQcm92aWRlcyBxdWlja1xuICAgKiBhY2Nlc3MgdG8gaW5wdXQgZWxlbWVudHMgaW4gdGhlIGVkaXRvciBncmlkLiAgU2VlIHR5cGUgbm90ZXMgZm9yIHVzYWdlLlxuICAgKlxuICAgKiBQb3B1bGF0ZWQgZHluYW1pY2FsbHkgaW4gYGJpbmRFbGVtZW50c19gIGR1cmluZyBgcmVuZGVyYC4gIE1heSBub3QgaW5jbHVkZVxuICAgKiBhbGwgZmllbGRzLCBhcyB3ZSB0cnkgdG8gb3B0aW1pemUgYW5kIG9taXQgZmllbGRzIG5vdCBlbmFibGVkIGluIHRoZSBsZXZlbC5cbiAgICpcbiAgICogQHR5cGUge1VJTWFwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy51aV8gPSB7fTtcblxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gcm9vdCBkaXYsIGZvciBob29raW5nIHVwIHRvIGEgcGFyZW50IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7alF1ZXJ5fVxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3REaXZfO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcGFja2V0IHBheWxvYWQgYW5kIHB1dCB0aGUgZWRpdG9yIGJhY2sgaW4gYSBzdGF0ZSB3aGVyZSBpdCdzXG4gKiByZWFkeSBmb3IgY29tcG9zaW5nIGEgbmV3IHBhY2tldC5cbiAqIEludGVudGlvbmFsbHkgcHJlc2VydmVzIHRvQWRkcmVzcyBhbmQgZnJvbUFkZHJlc3MuXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUucmVzZXRQYWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICcnO1xuICB0aGlzLnBhY2tldEluZGV4ID0gMTtcbiAgdGhpcy5wYWNrZXRDb3VudCA9IDE7XG4gIHRoaXMub3JpZ2luYWxCaW5hcnlfID0gJyc7XG4gIHRoaXMuc2VuZEFuaW1hdGlvbkluZGV4XyA9IDA7XG4gIHRoaXMubGFzdEJpdFNlbnRUaW1lXyA9IHVuZGVmaW5lZDtcbiAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG4gIHRoaXMudXBkYXRlUmVtb3ZlQnV0dG9uVmlzaWJpbGl0eV8oKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgdmlzaWJsZSBtZXNzYWdlIGJveCwgc28gdGhhdCB3ZSBjYW4gZm9jdXMoKSBvbiBpdFxuICogQHJldHVybnMge2pRdWVyeX1cbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5nZXRGaXJzdFZpc2libGVNZXNzYWdlQm94ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRSb290KCkuZmluZCgndGV4dGFyZWEubWVzc2FnZTp2aXNpYmxlJykuZmlyc3QoKTtcbn07XG5cbi8qKiBSZXBsYWNlIGNvbnRlbnRzIG9mIG91ciByb290IGVsZW1lbnQgd2l0aCBvdXIgb3duIG1hcmt1cC4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV3TWFya3VwID0gJChtYXJrdXAoe1xuICAgIG1lc3NhZ2VHcmFudWxhcml0eTogdGhpcy5tZXNzYWdlR3JhbnVsYXJpdHlfLFxuICAgIHBhY2tldFNwZWM6IHRoaXMucGFja2V0U3BlY18sXG4gICAgZW5hYmxlZEVuY29kaW5nc0hhc2g6IHRoaXMuZW5hYmxlZEVuY29kaW5nc0hhc2hfXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKG5ld01hcmt1cCk7XG4gIHRoaXMuYmluZEVsZW1lbnRzXygpO1xuICB0aGlzLnVwZGF0ZUZpZWxkc18oKTtcbiAgdGhpcy51cGRhdGVSZW1vdmVCdXR0b25WaXNpYmlsaXR5XygpO1xuICBOZXRTaW1Mb2dQYW5lbC5hZGp1c3RIZWFkZXJDb2x1bW5XaWR0aHModGhpcy5yb290RGl2Xyk7XG4gIE5ldFNpbUVuY29kaW5nQ29udHJvbC5oaWRlUm93c0J5RW5jb2RpbmcodGhpcy5yb290RGl2XyxcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZW5hYmxlZEVuY29kaW5nc0hhc2hfKSk7XG59O1xuXG4vKipcbiAqIFB1dCB0aGlzIHBhY2tldCBpbiBhIG1vZGUgd2hlcmUgaXQncyBub3QgZWRpdGFibGUuICBJbnN0ZWFkLCBpdCB3aWxsIGRyYWluXG4gKiBpdHMgYmluYXJ5IGF0IHRoZSBjdXJyZW50IGJpdHJhdGUgYW5kIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIHdoZW4gYWxsXG4gKiBvZiB0aGUgYmluYXJ5IGhhcyBiZWVuIGRyYWluZWQvXCJzZW50XCJcbiAqIEBwYXJhbSB7TmV0U2ltTG9jYWxDbGllbnROb2RlfSBteU5vZGVcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5iZWdpblNlbmRpbmcgPSBmdW5jdGlvbiAobXlOb2RlKSB7XG4gIHRoaXMuaXNQbGF5aW5nU2VuZEFuaW1hdGlvbl8gPSB0cnVlO1xuICB0aGlzLm9yaWdpbmFsQmluYXJ5XyA9IHRoaXMuZ2V0UGFja2V0QmluYXJ5KCkuc3Vic3RyKDAsIHRoaXMubWF4UGFja2V0U2l6ZV8pO1xuICB0aGlzLnNlbmRBbmltYXRpb25JbmRleF8gPSAwO1xuICB0aGlzLm15Tm9kZV8gPSBteU5vZGU7XG5cbiAgLy8gRmluaXNoIG5vdyBpZiB0aGUgcGFja2V0IGlzIGVtcHR5LlxuICBpZiAoMCA9PT0gdGhpcy5vcmlnaW5hbEJpbmFyeV8ubGVuZ3RoKSB7XG4gICAgdGhpcy5maW5pc2hTZW5kaW5nKCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2ljayBvZmYgdGhlIGFzeW5jIHNlbmQtdG8tcmVtb3RlIG9wZXJhdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHBhY2tldCBiaW5hcnkuXG4gKiBXaGVuIGl0J3MgZG9uZSwgcmVtb3ZlIHRoaXMgbm93LWVtcHR5IHBhY2tldC5cbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5maW5pc2hTZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fID0gZmFsc2U7XG4gIHRoaXMuaXNTZW5kaW5nUGFja2V0VG9SZW1vdGVfID0gdHJ1ZTtcbiAgdGhpcy5teU5vZGVfLnNlbmRNZXNzYWdlKHRoaXMub3JpZ2luYWxCaW5hcnlfLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1NlbmRpbmdQYWNrZXRUb1JlbW90ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmRvbmVTZW5kaW5nQ2FsbGJhY2tfKHRoaXMpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGlzIHBhY2tldCBpcyBjdXJyZW50bHkgYmVpbmcgc2VudC5cbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5pc1NlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzUGxheWluZ1NlbmRBbmltYXRpb25fIHx8IHRoaXMuaXNTZW5kaW5nUGFja2V0VG9SZW1vdGVfO1xufTtcblxuLyoqXG4gKiBQYWNrZXQgRWRpdG9yIHRpY2sgaXMgY2FsbGVkIChtYW51YWxseSBieSB0aGUgTmV0U2ltU2VuZFBhbmVsKSB0byBhZHZhbmNlXG4gKiBpdHMgc2VuZGluZyBhbmltYXRpb24uXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uIChjbG9jaykge1xuICAvLyBCZWZvcmUgd2Ugc3RhcnQgYW5pbWF0aW5nLCBvciBhZnRlciB3ZSBhcmUgZG9uZSBhbmltYXRpbmcsIGRvIG5vdGhpbmcuXG4gIGlmICghdGhpcy5pc1BsYXlpbmdTZW5kQW5pbWF0aW9uXyB8fCB0aGlzLmlzU2VuZGluZ1BhY2tldFRvUmVtb3RlXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5sYXN0Qml0U2VudFRpbWVfKSB7XG4gICAgdGhpcy5sYXN0Qml0U2VudFRpbWVfID0gY2xvY2sudGltZTtcbiAgfVxuXG4gIC8vIEhvdyBtYW55IGNoYXJhY3RlcnMgc2hvdWxkIGJlIGNvbnN1bWVkIHRoaXMgdGljaz9cbiAgdmFyIG1zUGVyQml0ID0gMTAwMCAqICgxIC8gdGhpcy5iaXRSYXRlXyk7XG4gIHZhciBtYXhCaXRzVG9TZW5kVGhpc1RpY2sgPSBJbmZpbml0eTtcbiAgaWYgKG1zUGVyQml0ID4gMCkge1xuICAgIHZhciBtc1NpbmNlTGFzdEJpdENvbnN1bWVkID0gY2xvY2sudGltZSAtIHRoaXMubGFzdEJpdFNlbnRUaW1lXztcbiAgICBtYXhCaXRzVG9TZW5kVGhpc1RpY2sgPSBNYXRoLmZsb29yKG1zU2luY2VMYXN0Qml0Q29uc3VtZWQgLyBtc1BlckJpdCk7XG4gIH1cblxuICBpZiAobWF4Qml0c1RvU2VuZFRoaXNUaWNrID4gMCkge1xuICAgIHRoaXMubGFzdEJpdFNlbnRUaW1lXyA9IGNsb2NrLnRpbWU7XG4gICAgdGhpcy5zZW5kQW5pbWF0aW9uSW5kZXhfICs9IG1heEJpdHNUb1NlbmRUaGlzVGljaztcbiAgICB0aGlzLnVwZGF0ZUZvckFuaW1hdGlvbl8oKTtcbiAgICBpZiAodGhpcy5zZW5kQW5pbWF0aW9uSW5kZXhfID49IHRoaXMub3JpZ2luYWxCaW5hcnlfLmxlbmd0aCkge1xuICAgICAgdGhpcy5maW5pc2hTZW5kaW5nKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvY3VzIGV2ZW50IGhhbmRsZXIuICBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIGEgJ3dhdGVybWFyaycgY2xhc3MgdGhlblxuICogaXQgY29udGFpbnMgdGV4dCB3ZSBpbnRlbmQgdG8gY2xlYXIgYmVmb3JlIGFueSBlZGl0aW5nIG9jY3Vycy4gIFRoaXNcbiAqIGhhbmRsZXIgY2xlYXJzIHRoYXQgdGV4dCBhbmQgcmVtb3ZlcyB0aGUgY2xhc3MuXG4gKiBAcGFyYW0gZm9jdXNFdmVudFxuICovXG52YXIgcmVtb3ZlV2F0ZXJtYXJrID0gZnVuY3Rpb24gKGZvY3VzRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9ICQoZm9jdXNFdmVudC50YXJnZXQpO1xuICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCd3YXRlcm1hcmsnKSkge1xuICAgIHRhcmdldC52YWwoJycpO1xuICAgIHRhcmdldC5yZW1vdmVDbGFzcygnd2F0ZXJtYXJrJyk7XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBnaXZlbiBrZXlQcmVzcyBldmVudCByZXByZXNlbnRzIGFcbiAqIENMRUFOIGVudGVyIHByZXNzLiBBcyBpbiwgb25lIHdpdGhvdXQgdGhlIFNoaWZ0IG9yIENvbnRyb2wgbW9kaWZpZXJzLlxuICogQHBhcmFtIHtFdmVudH0ganF1ZXJ5RXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmZiB0aGUgZ2l2ZW4gZXZlbnQgcmVwcmVzZW50cyBhIGNsZWFuIGVudGVyXG4gKi9cbnZhciBpc1VubW9kaWZpZWRFbnRlclByZXNzID0gZnVuY3Rpb24gKGpxdWVyeUV2ZW50KSB7XG4gIHJldHVybiAoanF1ZXJ5RXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZXMuRU5URVIgJiZcbiAgICAgICEoanF1ZXJ5RXZlbnQuY3RybEtleSB8fCBqcXVlcnlFdmVudC5zaGlmdEtleSkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEga2V5UHJlc3MgaGFuZGxlciB0aGF0IGFsbG93cyBvbmx5IHRoZSBnaXZlbiBjaGFyYWN0ZXJzIHRvIGJlXG4gKiB0eXBlZCBpbnRvIGEgdGV4dCBmaWVsZC5cbiAqIEBwYXJhbSB7UmVnRXhwfSB3aGl0ZWxpc3RSZWdleFxuICogQHJldHVybiB7ZnVuY3Rpb259IGFwcHJvcHJpYXRlIHRvIHBhc3MgdG8gLmtleXByZXNzKClcbiAqL1xudmFyIG1ha2VLZXlwcmVzc0hhbmRsZXJXaXRoV2hpdGVsaXN0ID0gZnVuY3Rpb24gKHdoaXRlbGlzdFJlZ2V4KSB7XG4gIC8qKlxuICAgKiBBIGtleVByZXNzIGhhbmRsZXIgdGhhdCBibG9ja3MgYWxsIHZpc2libGUgY2hhcmFjdGVycyBleGNlcHQgdGhvc2VcbiAgICogbWF0Y2hpbmcgdGhlIHdoaXRlbGlzdC4gIFBhc3NlcyB0aHJvdWdoIGludmlzaWJsZSBjaGFyYWN0ZXJzIChiYWNrc3BhY2UsXG4gICAqIGRlbGV0ZSkgYW5kIGNvbnRyb2wgY29tYmluYXRpb25zIChjb3B5LCBwYXN0ZSkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlFdmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIHByb3BhZ2F0ZSB0aGlzIGV2ZW50LiAgU2hvdWxkIHJldHVyblxuICAgKiAgICAgICAgICBGQUxTRSBpZiB3ZSBoYW5kbGUgdGhlIGV2ZW50IGFuZCBkb24ndCB3YW50IHRvIHBhc3MgaXQgb24sIFRSVUVcbiAgICogICAgICAgICAgaWYgd2UgYXJlIG5vdCBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKGtleUV2ZW50KSB7XG5cbiAgICAvLyBEb24ndCBibG9jayBjb250cm9sIGNvbWJpbmF0aW9ucyAoY29weSwgcGFzdGUsIGV0Yy4pXG4gICAgaWYgKGtleUV2ZW50Lm1ldGFLZXkgfHwga2V5RXZlbnQuY3RybEtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYmxvY2sgaW52aXNpYmxlIGNoYXJhY3RlcnM7IHdlIHdhbnQgdG8gYWxsb3cgYmFja3NwYWNlLCBkZWxldGUsIGV0Yy5cbiAgICBpZiAoa2V5RXZlbnQud2hpY2ggPCBLZXlDb2Rlcy5TUEFDRSB8fCBrZXlFdmVudC53aGljaCA+PSBLZXlDb2Rlcy5ERUxFVEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIGlmIHRoZSBjaGFyYWN0ZXIgZG9lc24ndCBtYXRjaCwgd2Ugc2hvdWxkIGJsb2NrIGl0LlxuICAgIHZhciBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUV2ZW50LndoaWNoKTtcbiAgICBpZiAoIXdoaXRlbGlzdFJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAga2V5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgalF1ZXJ5LWFwcHJvcHJpYXRlIGtleXVwIGhhbmRsZXIgZm9yIGEgdGV4dCBmaWVsZC5cbiAqIEdyYWJzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIHRleHQgZmllbGQsIHJ1bnMgaXQgdGhyb3VnaCB0aGUgcHJvdmlkZWRcbiAqIGNvbnZlcnRlciBmdW5jdGlvbiwgc2V0cyB0aGUgcmVzdWx0IG9uIHRoZSBTZW5kV2lkZ2V0J3MgaW50ZXJuYWwgc3RhdGVcbiAqIGFuZCB0cmlnZ2VycyBhIGZpZWxkIHVwZGF0ZSBvbiB0aGUgd2lkZ2V0IHRoYXQgc2tpcHMgdGhlIGZpZWxkIGJlaW5nIGVkaXRlZC5cbiAqXG4gKiBTaW1pbGFyIHRvIG1ha2VCbHVySGFuZGxlciwgYnV0IGRvZXMgbm90IHVwZGF0ZSB0aGUgZmllbGQgY3VycmVudGx5XG4gKiBiZWluZyBlZGl0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIG5hbWUgb2YgaW50ZXJuYWwgc3RhdGUgZmllbGQgdGhhdCB0aGUgdGV4dFxuICogICAgICAgIGZpZWxkIHNob3VsZCB1cGRhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb252ZXJ0ZXJGdW5jdGlvbiAtIFRha2VzIHRoZSB0ZXh0IGZpZWxkJ3MgdmFsdWUgYW5kXG4gKiAgICAgICAgY29udmVydHMgaXQgdG8gYSBmb3JtYXQgYXBwcm9wcmlhdGUgdG8gdGhlIGludGVybmFsIHN0YXRlIGZpZWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmaWVsZFdpZHRoXSAtIG1heGltdW0gbnVtYmVyIG9mIGJpdHMgZm9yIGZpZWxkLCBwYXNzZWRcbiAqICAgICAgICB0aHJvdWdoIGFzIHNlY29uZCBhcmd1bWVudCB0byBjb252ZXJ0ZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRoYXQgY2FuIGJlIHBhc3NlZCB0byAkLmtleXVwKClcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5tYWtlS2V5dXBIYW5kbGVyID0gZnVuY3Rpb24gKGZpZWxkTmFtZSxcbiAgICBjb252ZXJ0ZXJGdW5jdGlvbiwgZmllbGRXaWR0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGpxdWVyeUV2ZW50KSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gY29udmVydGVyRnVuY3Rpb24oanF1ZXJ5RXZlbnQudGFyZ2V0LnZhbHVlLCBmaWVsZFdpZHRoKTtcbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnc3RyaW5nJyB8fCAhaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICB0aGlzW2ZpZWxkTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlRmllbGRzXyhqcXVlcnlFdmVudC50YXJnZXQpO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGpRdWVyeS1hcHByb3ByaWF0ZSBibHVyIGhhbmRsZXIgZm9yIGEgdGV4dCBmaWVsZC5cbiAqIEdyYWJzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIHRleHQgZmllbGQsIHJ1bnMgaXQgdGhyb3VnaCB0aGUgcHJvdmlkZWRcbiAqIGNvbnZlcnRlciBmdW5jdGlvbiwgc2V0cyB0aGUgcmVzdWx0IG9uIHRoZSBTZW5kV2lkZ2V0J3MgaW50ZXJuYWwgc3RhdGVcbiAqIGFuZCB0cmlnZ2VycyBhIGZ1bGwgZmllbGQgdXBkYXRlIG9mIHRoZSB3aWRnZXQgKGluY2x1ZGluZyB0aGUgZmllbGQgdGhhdCB3YXNcbiAqIGp1c3QgZWRpdGVkKS5cbiAqXG4gKiBTaW1pbGFyIHRvIG1ha2VLZXl1cEhhbmRsZXIsIGJ1dCBhbHNvIHVwZGF0ZXMgdGhlIGZpZWxkIHRoYXQgd2FzXG4gKiBqdXN0IGVkaXRlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIC0gbmFtZSBvZiBpbnRlcm5hbCBzdGF0ZSBmaWVsZCB0aGF0IHRoZSB0ZXh0XG4gKiAgICAgICAgZmllbGQgc2hvdWxkIHVwZGF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnZlcnRlckZ1bmN0aW9uIC0gVGFrZXMgdGhlIHRleHQgZmllbGQncyB2YWx1ZSBhbmRcbiAqICAgICAgICBjb252ZXJ0cyBpdCB0byBhIGZvcm1hdCBhcHByb3ByaWF0ZSB0byB0aGUgaW50ZXJuYWwgc3RhdGUgZmllbGQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZpZWxkV2lkdGhdIC0gbWF4aW11bSBudW1iZXIgb2YgYml0cyBmb3IgZmllbGQsIHBhc3NlZFxuICogICAgICAgIHRocm91Z2ggYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGNvbnZlcnRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGhhdCBjYW4gYmUgcGFzc2VkIHRvICQuYmx1cigpXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUubWFrZUJsdXJIYW5kbGVyID0gZnVuY3Rpb24gKGZpZWxkTmFtZSxcbiAgICBjb252ZXJ0ZXJGdW5jdGlvbiwgZmllbGRXaWR0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGpxdWVyeUV2ZW50KSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gY29udmVydGVyRnVuY3Rpb24oanF1ZXJ5RXZlbnQudGFyZ2V0LnZhbHVlLCBmaWVsZFdpZHRoKTtcbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTihuZXdWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gY29udmVydGVyRnVuY3Rpb24oJzAnKTtcbiAgICB9XG4gICAgdGhpc1tmaWVsZE5hbWVdID0gbmV3VmFsdWU7XG4gICAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG4gIH0uYmluZCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWNhdGlvbiBmb3IgYW4gZW5jb2Rpbmcgcm93IGluIHRoZSBlZGl0b3IsIHdoaWNoIGRlc2lnbmF0ZXMgY2hhcmFjdGVyXG4gKiB3aGl0ZWxpc3RzIHRvIGxpbWl0IHR5cGluZyBpbiBjZXJ0YWluIGZpZWxkcywgYW5kIHJ1bGVzIGZvciBpbnRlcHJldGluZyB0aGVcbiAqIGZpZWxkIGZyb20gYmluYXJ5LlxuICogQHR5cGVkZWYge09iamVjdH0gUm93VHlwZVxuICogQHByb3BlcnR5IHtFbmNvZGluZ1R5cGV9IHR5cGVOYW1lXG4gKiBAcHJvcGVydHkge1JlZ0V4cH0gYWRkcmVzc0ZpZWxkQWxsb3dlZENoYXJhY3RlcnMgLSBXaGl0ZWxpc3Qgb2YgY2hhcmFjdGVyc1xuICogICAgICAgICAgIHRoYXQgbWF5IGJlIHR5cGVkIGludG8gYW4gYWRkcmVzcyBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGFkZHJlc3NGaWVsZENvbnZlcnNpb24gLSBIb3cgdG8gY29udmVydCBmcm9tIGJpbmFyeVxuICogICAgICAgICAgIHRvIGFuIGFkZHJlc3Mgc3RyaW5nIGluIHRoaXMgcm93IHdoZW4gdGhlIGJpbmFyeSBpcyB1cGRhdGVkLlxuICogQHByb3BlcnR5IHtSZWdFeHB9IHNob3J0TnVtYmVyQWxsb3dlZENoYXJhY3RlcnMgLSBXaGl0ZWxpc3Qgb2YgY2hhcmFjdGVyc1xuICogICAgICAgICAgIHRoYXQgbWF5IGJlIHR5cGVkIGludG8gYSBoZWFkZXIgZmllbGQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzaG9ydE51bWJlckNvbnZlcnNpb24gLSBIb3cgdG8gY29udmVydCBmcm9tIGJpbmFyeVxuICogICAgICAgICAgIHRvIGEgaGVhZGVyIHZhbHVlIGluIHRoaXMgcm93IHdoZW4gdGhlIGJpbmFyeSBpcyB1cGRhdGVkLlxuICogQHByb3BlcnR5IHtSZWdFeHB9IG1lc3NhZ2VBbGxvd2VkQ2hhcmFjdGVycyAtIFdoaXRlbGlzdCBvZiBjaGFyYWN0ZXJzXG4gKiAgICAgICAgICAgdGhhdCBtYXkgYmUgdHlwZWQgaW50byB0aGUgbWVzc2FnZSBmaWVsZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG1lc3NhZ2VDb252ZXJzaW9uIC0gSG93IHRvIGNvbnZlcnQgZnJvbSBiaW5hcnkgdG9cbiAqICAgICAgICAgICB0aGUgbWVzc2FnZSB2YWx1ZSBpbiB0aGlzIHJvdyB3aGVuIHRoZSBiaW5hcnkgaXMgdXBkYXRlZC5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYmluYXJ5IHRvIGFuIGludGVnZXIsIGludGVudGlvbmFsbHkgbGltaXRpbmcgdGhlIGJpbmFyeSB3aWR0aCBzb1xuICogdGhhdCBvdmVyZmxvdyBjYW4gb2NjdXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5U3RyaW5nIChpbnRlcnByZXRlZCBhcyB1bnNpZ25lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCBpbiBiaXRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG52YXIgdHJ1bmNhdGVkQmluYXJ5VG9JbnQgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nLCBtYXhXaWR0aCkge1xuICByZXR1cm4gYmluYXJ5VG9JbnQoYmluYXJ5U3RyaW5nLnN1YnN0cigtbWF4V2lkdGgpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBBQnMgdG8gYW4gaW50ZWdlciwgaW50ZW50aW9uYWxseSBsaW1pdGluZyB0aGUgd2lkdGggc28gdGhhdCBvdmVyZmxvd1xuICogY2FuIG9jY3VyIChhbmFsYWdvdXMgdG8gdHJ1bmNhdGVkQmluYXJ5VG9JbnQpLiAgQSBpcyB0cmVhdGVkIGFzIHplcm8sIEIgYXNcbiAqIG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhYlN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIGluIGJpdHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnZhciB0cnVuY2F0ZWRBQlRvSW50ID0gZnVuY3Rpb24gKGFiU3RyaW5nLCBtYXhXaWR0aCkge1xuICByZXR1cm4gYWJUb0ludChhYlN0cmluZy5zdWJzdHIoLW1heFdpZHRoKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBzaW5nbGUgaW50ZWdlciwgaW50ZW50aW9uYWxseSBsaW1pdGluZ1xuICogdGhlIGJpdC13aWR0aCB0byBzbyB0aGF0IG92ZXJmbG93IGNhbiBvY2N1ci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCBpbiBiaXRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG52YXIgdHJ1bmNhdGVkSGV4VG9JbnQgPSBmdW5jdGlvbiAoaGV4U3RyaW5nLCBtYXhXaWR0aCkge1xuICByZXR1cm4gdHJ1bmNhdGVkQmluYXJ5VG9JbnQoaGV4VG9CaW5hcnkoaGV4U3RyaW5nKSwgbWF4V2lkdGgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGVjaW1hbCBzdHJpbmcgdG8gYW4gaW50ZWdlciwgaW50ZW50aW9uYWxseSBsaW1pdGluZyB0aGUgYml0LXdpZHRoXG4gKiBzbyB0aGF0IG92ZXJmbG93IGNhbiBvY2N1ci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsU3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggaW4gYml0c1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xudmFyIHRydW5jYXRlZERlY2ltYWxUb0ludCA9IGZ1bmN0aW9uIChkZWNpbWFsU3RyaW5nLCBtYXhXaWR0aCkge1xuICByZXR1cm4gdHJ1bmNhdGVkQmluYXJ5VG9JbnQoaW50VG9CaW5hcnkocGFyc2VJbnQoZGVjaW1hbFN0cmluZywgMTApKSwgbWF4V2lkdGgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFkZHJlc3Mgc3RyaW5nIHRvIGJpbmFyeSBhbmQgYmFjayB1c2luZyB0aGUgbGV2ZWwncyBhZGRyZXNzXG4gKiBmb3JtYXQsIHdoaWNoIGNvZXJjZXMgaXQgdG8gdGhlIGV4YWN0IGZvcm1hdCB0aGUgbGV2ZWwgd2FudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWxTdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBjbGVhbkFkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAob3JpZ2luYWxTdHJpbmcpIHtcbiAgdmFyIGxldmVsID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuICB2YXIgYmluYXJ5Rm9ybSA9IERhdGFDb252ZXJ0ZXJzLmFkZHJlc3NTdHJpbmdUb0JpbmFyeShcbiAgICAgIG9yaWdpbmFsU3RyaW5nLCBsZXZlbC5hZGRyZXNzRm9ybWF0KTtcbiAgcmV0dXJuIERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQWRkcmVzc1N0cmluZyhcbiAgICAgIGJpbmFyeUZvcm0sIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGZpbHRlciB0aGlzLlJPV19UWVBFUyBieSBlbmFibGVkIGVuY29kaW5nc1xuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtSb3dUeXBlW119XG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUuZ2V0RW5hYmxlZFJvd1R5cGVzXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuUk9XX1RZUEVTLmZpbHRlcihmdW5jdGlvbiAocm93VHlwZSkge1xuICAgIHJldHVybiB0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhyb3dUeXBlLnR5cGVOYW1lKTtcbiAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCByZWxldmFudCBlbGVtZW50cyBmcm9tIHRoZSBwYWdlIGFuZCBiaW5kIHRoZW0gdG8gbG9jYWwgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5iaW5kRWxlbWVudHNfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV2ZWwgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG4gIHZhciBlbmNvZGVyID0gbmV3IFBhY2tldC5FbmNvZGVyKGxldmVsLmFkZHJlc3NGb3JtYXQsXG4gICAgICBsZXZlbC5wYWNrZXRDb3VudEJpdFdpZHRoLCB0aGlzLnBhY2tldFNwZWNfKTtcbiAgdmFyIHJvb3REaXYgPSB0aGlzLnJvb3REaXZfO1xuXG4gIHRoaXMuZ2V0RW5hYmxlZFJvd1R5cGVzXygpLmZvckVhY2goZnVuY3Rpb24gKHJvd1R5cGUpIHtcbiAgICB2YXIgdHIgPSByb290RGl2LmZpbmQoJ3RyLicgKyByb3dUeXBlLnR5cGVOYW1lKTtcbiAgICB0aGlzLnVpX1tyb3dUeXBlLnR5cGVOYW1lXSA9IHt9O1xuICAgIHZhciByb3dGaWVsZHMgPSB0aGlzLnVpX1tyb3dUeXBlLnR5cGVOYW1lXTtcblxuICAgIC8vIFdlIGF0dGFjaCBmb2N1cyAoc29tZXRpbWVzKSB0byBjbGVhciB0aGUgZmllbGQgd2F0ZXJtYXJrLCBpZiBwcmVzZW50XG4gICAgLy8gV2UgYXR0YWNoIGtleXByZXNzIHRvIGJsb2NrIGNlcnRhaW4gY2hhcmFjdGVyc1xuICAgIC8vIFdlIGF0dGFjaCBrZXl1cCB0byBsaXZlLXVwZGF0ZSB0aGUgd2lkZ2V0IGFzIHRoZSB1c2VyIHR5cGVzXG4gICAgLy8gV2UgYXR0YWNoIGJsdXIgdG8gcmVmb3JtYXQgdGhlIGVkaXRlZCBmaWVsZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyBpdCxcbiAgICAvLyAgICBhbmQgdG8gY2F0Y2ggbm9uLWtleXVwIGNhc2VzIGxpa2UgY29weS9wYXN0ZS5cblxuICAgIHRoaXMucGFja2V0U3BlY18uZm9yRWFjaChmdW5jdGlvbiAoZmllbGRTcGVjKSB7XG4gICAgICAvKiogQHR5cGUge1BhY2tldC5IZWFkZXJUeXBlfSAqL1xuICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkU3BlYztcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGZpZWxkV2lkdGggPSBlbmNvZGVyLmdldEZpZWxkQml0V2lkdGgoZmllbGROYW1lKTtcblxuICAgICAgdmFyIGFsbG93ZWRDaGFyYWN0ZXJGdW5jdGlvbiwgY29udmVyc2lvbkZ1bmN0aW9uO1xuICAgICAgaWYgKFBhY2tldC5pc0FkZHJlc3NGaWVsZChmaWVsZE5hbWUpKSB7XG4gICAgICAgIGFsbG93ZWRDaGFyYWN0ZXJGdW5jdGlvbiA9IHJvd1R5cGUuYWRkcmVzc0ZpZWxkQWxsb3dlZENoYXJhY3RlcnM7XG4gICAgICAgIGNvbnZlcnNpb25GdW5jdGlvbiA9IHJvd1R5cGUuYWRkcmVzc0ZpZWxkQ29udmVyc2lvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93ZWRDaGFyYWN0ZXJGdW5jdGlvbiA9IHJvd1R5cGUuc2hvcnROdW1iZXJBbGxvd2VkQ2hhcmFjdGVycztcbiAgICAgICAgY29udmVyc2lvbkZ1bmN0aW9uID0gcm93VHlwZS5zaG9ydE51bWJlckNvbnZlcnNpb247XG4gICAgICB9XG5cbiAgICAgIHJvd0ZpZWxkc1tmaWVsZE5hbWVdID0gdHIuZmluZCgnaW5wdXQuJyArIGZpZWxkTmFtZSk7XG4gICAgICByb3dGaWVsZHNbZmllbGROYW1lXS5rZXlwcmVzcyhtYWtlS2V5cHJlc3NIYW5kbGVyV2l0aFdoaXRlbGlzdChcbiAgICAgICAgICBhbGxvd2VkQ2hhcmFjdGVyRnVuY3Rpb24pKTtcbiAgICAgIHJvd0ZpZWxkc1tmaWVsZE5hbWVdLmtleXVwKHRoaXMubWFrZUtleXVwSGFuZGxlcihmaWVsZE5hbWUsXG4gICAgICAgICAgY29udmVyc2lvbkZ1bmN0aW9uLCBmaWVsZFdpZHRoKSk7XG4gICAgICByb3dGaWVsZHNbZmllbGROYW1lXS5ibHVyKHRoaXMubWFrZUJsdXJIYW5kbGVyKGZpZWxkTmFtZSxcbiAgICAgICAgICBjb252ZXJzaW9uRnVuY3Rpb24sIGZpZWxkV2lkdGgpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJvd0ZpZWxkcy5tZXNzYWdlID0gdHIuZmluZCgndGV4dGFyZWEubWVzc2FnZScpO1xuICAgIHJvd0ZpZWxkcy5tZXNzYWdlLmZvY3VzKHJlbW92ZVdhdGVybWFyayk7XG4gICAgcm93RmllbGRzLm1lc3NhZ2Uua2V5cHJlc3MoXG4gICAgICAgIG1ha2VLZXlwcmVzc0hhbmRsZXJXaXRoV2hpdGVsaXN0KHJvd1R5cGUubWVzc2FnZUFsbG93ZWRDaGFyYWN0ZXJzKSk7XG4gICAgcm93RmllbGRzLm1lc3NhZ2Uua2V5ZG93bihmdW5jdGlvbihqcXVlcnlFdmVudCl7XG4gICAgICBpZiAoaXNVbm1vZGlmaWVkRW50ZXJQcmVzcyhqcXVlcnlFdmVudCkpIHtcbiAgICAgICAgdGhpcy5lbnRlcktleVByZXNzZWRDYWxsYmFja18oanF1ZXJ5RXZlbnQpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgcm93RmllbGRzLm1lc3NhZ2Uua2V5dXAoXG4gICAgICAgIHRoaXMubWFrZUtleXVwSGFuZGxlcignbWVzc2FnZScsIHJvd1R5cGUubWVzc2FnZUNvbnZlcnNpb24pKTtcbiAgICByb3dGaWVsZHMubWVzc2FnZS5ibHVyKFxuICAgICAgICB0aGlzLm1ha2VCbHVySGFuZGxlcignbWVzc2FnZScsIHJvd1R5cGUubWVzc2FnZUNvbnZlcnNpb24pKTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5yZW1vdmVQYWNrZXRCdXR0b25fID0gcm9vdERpdi5maW5kKCcucmVtb3ZlLXBhY2tldC1idXR0b24nKTtcbiAgdGhpcy5yZW1vdmVQYWNrZXRCdXR0b25fLmNsaWNrKHRoaXMub25SZW1vdmVQYWNrZXRCdXR0b25DbGlja18uYmluZCh0aGlzKSk7XG4gIHRoaXMuYml0Q291bnRlcl8gPSByb290RGl2LmZpbmQoJy5iaXQtY291bnRlcicpO1xufTtcblxuLyoqXG4gKiBTcGVjaWFsIHVwZGF0ZSBtZXRob2QgY2FsbGVkIGR1cmluZyBzZW5kIGFuaW1hdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGVkaXRvclxuICogZGlzcGxheSB0byBzaG93IGVhY2ggZmllbGQgbGVmdC10cnVuY2F0ZWQgYXQgYW4gYXBwcm9wcmlhdGUgYW1vdW50IGZvciB0aGVcbiAqIHNpbXVsYXRlZCBzZW5kIHByb2dyZXNzLlxuICpcbiAqIFRoaXMgd29ya3MgZGlmZmVyZW50bHkgZm9yIGRpZmZlcmVudCBmaWVsZHM6XG4gKiAgLSBCaW5hcnkgYW5kIEEvQiBmaWVsZHMgc2VuZCBhIHNpbmdsZSBiaXQgYXQgYSB0aW1lLlxuICogIC0gSGV4IHNlbmRzIGEgc2luZ2xlIGhleCBkaWdpdCBhdCBhIHRpbWUsIGJ1dCBhdCB0aGUgY29ycmVjdCBzbG93ZXIgcmF0ZS5cbiAqICAtIERlY2ltYWwgYW5kIEFTQ0lJIHNlbmQgb25lIGNodW5rIGF0IGEgdGltZSwgd2hpY2ggZGVwZW5kcyBvbiB0aGUgY3VycmVudFxuICogICAgY2h1bmsgc2l6ZSwgYW5kIGlzIGFkanVzdGVkIHRvIHRoZSBjb3JyZWN0IHNsb3dlciByYXRlIGFzIHdlbGwuICBGb3JcbiAqICAgIEFTQ0lJIHRoaXMgbWFwcyB0byBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS4gIEZvciBkZWNpbWFsLCBpdCdzIG9uZVxuICogICAgd2hpdGVzcGFjZS1kZWxpbWl0ZWQgbnVtYmVyLlxuICpcbiAqIFRoaXMgYXZvaWRzIHRoZSBqdW1ibGVkIGVmZmVjdCBvZiByZWludGVycHJldGluZyBub25iaW5hcnkgZmllbGRzIHVzaW5nXG4gKiBtaXNhbGlnbmVkIGJpbmFyeSwgYW5kIGNvbW11bmljYXRlcyBpbiBhIHZpc3VhbCB3YXkgdGhhdCBpdCB0YWtlcyBsb25nZXIgdG9cbiAqIHNlbmQgYSBzaW5nbGUgY2hhcmFjdGVyIHRoYW4gaXQgZG9lcyB0byBzZW5kIGEgc2luZ2xlIGJpdC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhbHNvIGRlc2lnbmVkIHRvIHNlbmQgdGhlIHBhY2tldCBoZWFkZXIgZmllbGRzIGluIHNlcXVlbmNlXG4gKiBiZWZvcmUgc2VuZGluZyB0aGUgcGFja2V0IGJvZHkuICBCb2R5IGJpbmFyeSBpcyBuZXZlciBzZWVuIGluIHRoZSBoZWFkZXJcbiAqIGZpZWxkcywgZWFjaCBmaWVsZCBpcyB0cmVhdGVkIGFzIGFuIGluZGVwZW5kZW50IHNwYWNlLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS51cGRhdGVGb3JBbmltYXRpb25fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5jdXJyZW50Q2h1bmtTaXplXztcbiAgdmFyIGxpdmVGaWVsZHMgPSBbXTtcblxuICAvLyBUaGVyZSBtYXkgYmUgcG90ZW50aWFsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gaGVyZSwgYnV0IGl0J3Mgbm90XG4gIC8vIHBhcnRpY3VsYXJseSBoaWdoIG9uIG91ciBwZXJmIGxpc3QgcmlnaHQgbm93LlxuXG4gIHZhciBsZXZlbCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgdmFyIGVuY29kZXIgPSBuZXcgUGFja2V0LkVuY29kZXIobGV2ZWwuYWRkcmVzc0Zvcm1hdCxcbiAgICAgIGxldmVsLnBhY2tldENvdW50Qml0V2lkdGgsIHRoaXMucGFja2V0U3BlY18pO1xuXG4gIHZhciBmaWVsZFN0YXJ0ID0gMDtcblxuICB0aGlzLnBhY2tldFNwZWNfLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkU3BlYykge1xuICAgIC8qKiBAdHlwZSB7UGFja2V0LkhlYWRlclR5cGV9ICovXG4gICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkU3BlYztcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB2YXIgZmllbGRXaWR0aCA9IGVuY29kZXIuZ2V0RmllbGRCaXRXaWR0aChmaWVsZE5hbWUpO1xuXG4gICAgaWYgKHRoaXMuc2VuZEFuaW1hdGlvbkluZGV4XyA8IGZpZWxkU3RhcnQgKyBmaWVsZFdpZHRoKSB7XG4gICAgICAvLyBFaXRoZXIgd2UgaGF2ZW4ndCByZWFjaGVkIHRoaXMgZmllbGQgeWV0IG9yIHdlJ3JlIGN1cnJlbnRseSBhbmltYXRpbmdcbiAgICAgIC8vIHRocm91Z2ggaXQ7IGRvbid0IGRvIGFueXRoaW5nIHRvIHRoZSBtb3JlIGNvbXBsZXggZmllbGRzLCBhbmQgYW5pbWF0ZVxuICAgICAgLy8gdGhlIGJpbmFyeSBhcHByb3ByaWF0ZWx5LlxuICAgICAgdmFyIGZpZWxkQmluYXJ5ID0gdGhpcy5vcmlnaW5hbEJpbmFyeV8uc3Vic3RyKGZpZWxkU3RhcnQsIGZpZWxkV2lkdGgpO1xuICAgICAgdmFyIHRydW5jYXRlZEJpdHMgPSBNYXRoLm1heCgwLCB0aGlzLnNlbmRBbmltYXRpb25JbmRleF8gLSBmaWVsZFN0YXJ0KTtcblxuICAgICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5BX0FORF9CKSkge1xuICAgICAgICBsaXZlRmllbGRzLnB1c2goe1xuICAgICAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFfQU5EX0JdW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgbmV3VmFsdWU6IGJpbmFyeVRvQUIoZmllbGRCaW5hcnkpLnN1YnN0cih0cnVuY2F0ZWRCaXRzKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5CSU5BUlkpKSB7XG4gICAgICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuQklOQVJZXVtmaWVsZE5hbWVdLFxuICAgICAgICAgIG5ld1ZhbHVlOiBmaWVsZEJpbmFyeS5zdWJzdHIodHJ1bmNhdGVkQml0cylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwpKSB7XG4gICAgICAgIHZhciB0cnVuY2F0ZWRIZXhEaWdpdHMgPSBNYXRoLmZsb29yKHRydW5jYXRlZEJpdHMgLyA0KTtcbiAgICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5IRVhBREVDSU1BTF1bZmllbGROYW1lXSxcbiAgICAgICAgICBuZXdWYWx1ZTogYmluYXJ5VG9IZXgoZmllbGRCaW5hcnkpLnN1YnN0cih0cnVuY2F0ZWRIZXhEaWdpdHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBwYXN0IHRoaXMgZmllbGQgLSBpdCBzaG91bGQgYmUgYmxhbmtcbiAgICAgIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuQV9BTkRfQikpIHtcbiAgICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5BX0FORF9CXVtmaWVsZE5hbWVdLFxuICAgICAgICAgIG5ld1ZhbHVlOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5CSU5BUlkpKSB7XG4gICAgICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuQklOQVJZXVtmaWVsZE5hbWVdLFxuICAgICAgICAgIG5ld1ZhbHVlOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5IRVhBREVDSU1BTCkpIHtcbiAgICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5IRVhBREVDSU1BTF1bZmllbGROYW1lXSxcbiAgICAgICAgICBuZXdWYWx1ZTogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuREVDSU1BTCkpIHtcbiAgICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5ERUNJTUFMXVtmaWVsZE5hbWVdLFxuICAgICAgICAgIG5ld1ZhbHVlOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5BU0NJSSkpIHtcbiAgICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5BU0NJSV1bZmllbGROYW1lXSxcbiAgICAgICAgICBuZXdWYWx1ZTogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBmaWVsZFxuICAgIGZpZWxkU3RhcnQgKz0gZmllbGRXaWR0aDtcbiAgfSwgdGhpcyk7XG5cbiAgdmFyIGJvZHlCaW5hcnkgPSB0aGlzLm9yaWdpbmFsQmluYXJ5Xy5zdWJzdHIoZmllbGRTdGFydCk7XG4gIHZhciB0cnVuY2F0ZWRCaXRzID0gTWF0aC5tYXgoMCwgdGhpcy5zZW5kQW5pbWF0aW9uSW5kZXhfIC0gZmllbGRTdGFydCk7XG4gIHZhciB0cnVuY2F0ZWRDaHVua3MgPSBNYXRoLmZsb29yKHRydW5jYXRlZEJpdHMgLyBjaHVua1NpemUpO1xuICB2YXIgcGFydGlhbEJpbmFyeUF0Q2h1bmtTaXplID0gYm9keUJpbmFyeS5zdWJzdHIodHJ1bmNhdGVkQ2h1bmtzICogY2h1bmtTaXplKTtcblxuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkFfQU5EX0IpKSB7XG4gICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFfQU5EX0JdLm1lc3NhZ2UsXG4gICAgICBuZXdWYWx1ZTogZm9ybWF0QUIoYmluYXJ5VG9BQihib2R5QmluYXJ5KS5zdWJzdHIodHJ1bmNhdGVkQml0cyksXG4gICAgICAgICAgY2h1bmtTaXplLCAtdHJ1bmNhdGVkQml0cyksXG4gICAgICB3YXRlcm1hcms6IG5ldHNpbU1zZy5hX2FuZF9iKClcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuQklOQVJZKSkge1xuICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5CSU5BUlldLm1lc3NhZ2UsXG4gICAgICBuZXdWYWx1ZTogZm9ybWF0QmluYXJ5KGJvZHlCaW5hcnkuc3Vic3RyKHRydW5jYXRlZEJpdHMpLCBjaHVua1NpemUsXG4gICAgICAgICAgLXRydW5jYXRlZEJpdHMpLFxuICAgICAgd2F0ZXJtYXJrOiBuZXRzaW1Nc2cuYmluYXJ5KClcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwpKSB7XG4gICAgdmFyIHRydW5jYXRlZEhleERpZ2l0cyA9IE1hdGguZmxvb3IodHJ1bmNhdGVkQml0cyAvIDQpO1xuICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5IRVhBREVDSU1BTF0ubWVzc2FnZSxcbiAgICAgIG5ld1ZhbHVlOiBmb3JtYXRIZXgoYmluYXJ5VG9IZXgoYm9keUJpbmFyeSkuc3Vic3RyKHRydW5jYXRlZEhleERpZ2l0cyksXG4gICAgICAgICAgY2h1bmtTaXplLCAtdHJ1bmNhdGVkSGV4RGlnaXRzKSxcbiAgICAgIHdhdGVybWFyazogbmV0c2ltTXNnLmhleGFkZWNpbWFsKClcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuREVDSU1BTCkpIHtcbiAgICBsaXZlRmllbGRzLnB1c2goe1xuICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuREVDSU1BTF0ubWVzc2FnZSxcbiAgICAgIG5ld1ZhbHVlOiBhbGlnbkRlY2ltYWwoYmluYXJ5VG9EZWNpbWFsKHBhcnRpYWxCaW5hcnlBdENodW5rU2l6ZSwgY2h1bmtTaXplKSksXG4gICAgICB3YXRlcm1hcms6IG5ldHNpbU1zZy5kZWNpbWFsKClcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuQVNDSUkpKSB7XG4gICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFTQ0lJXS5tZXNzYWdlLFxuICAgICAgbmV3VmFsdWU6IGJpbmFyeVRvQXNjaWkocGFydGlhbEJpbmFyeUF0Q2h1bmtTaXplLCBjaHVua1NpemUpLFxuICAgICAgd2F0ZXJtYXJrOiBuZXRzaW1Nc2cuYXNjaWkoKVxuICAgIH0pO1xuICB9XG5cbiAgbGl2ZUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGlmIChmaWVsZC53YXRlcm1hcmsgJiYgZmllbGQubmV3VmFsdWUgPT09ICcnKSB7XG4gICAgICBmaWVsZC5pbnB1dEVsZW1lbnQudmFsKGZpZWxkLndhdGVybWFyayk7XG4gICAgICBmaWVsZC5pbnB1dEVsZW1lbnQuYWRkQ2xhc3MoJ3dhdGVybWFyaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZC5pbnB1dEVsZW1lbnQudmFsKGZpZWxkLm5ld1ZhbHVlKTtcbiAgICAgIGZpZWxkLmlucHV0RWxlbWVudC5yZW1vdmVDbGFzcygnd2F0ZXJtYXJrJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHNlbmQgd2lkZ2V0IGRpc3BsYXlcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtza2lwRWxlbWVudF0gLSBBIGZpZWxkIHRvIHNraXAgd2hpbGUgdXBkYXRpbmcsXG4gKiAgICAgICAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHRyYW5zZm9ybSBjb250ZW50IG91dCBmcm9tIHVuZGVyIHRoZVxuICogICAgICAgIHVzZXIncyBjdXJzb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnVwZGF0ZUZpZWxkc18gPSBmdW5jdGlvbiAoc2tpcEVsZW1lbnQpIHtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMuY3VycmVudENodW5rU2l6ZV87XG4gIHZhciBsaXZlRmllbGRzID0gW107XG5cbiAgdmFyIGxldmVsID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuICB2YXIgZW5jb2RlciA9IG5ldyBQYWNrZXQuRW5jb2RlcihsZXZlbC5hZGRyZXNzRm9ybWF0LFxuICAgICAgbGV2ZWwucGFja2V0Q291bnRCaXRXaWR0aCwgdGhpcy5wYWNrZXRTcGVjXyk7XG5cbiAgdGhpcy5wYWNrZXRTcGVjXy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZFNwZWMpIHtcbiAgICAvKiogQHR5cGUge1BhY2tldC5IZWFkZXJUeXBlfSAqL1xuICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZFNwZWM7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGZpZWxkV2lkdGggPSBlbmNvZGVyLmdldEZpZWxkQml0V2lkdGgoZmllbGROYW1lKTtcblxuICAgIHZhciBhYkNvbnZlcnRlciwgYmluYXJ5Q29udmVydGVyLCBoZXhDb252ZXJ0ZXIsIGRlY2ltYWxDb252ZXJ0ZXIsIGFzY2lpQ29udmVydGVyO1xuICAgIGlmIChQYWNrZXQuaXNBZGRyZXNzRmllbGQoZmllbGROYW1lKSkge1xuICAgICAgYWJDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoYWRkcmVzc1N0cmluZykge1xuICAgICAgICByZXR1cm4gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9BQihcbiAgICAgICAgICAgIERhdGFDb252ZXJ0ZXJzLmFkZHJlc3NTdHJpbmdUb0JpbmFyeShcbiAgICAgICAgICAgICAgICBhZGRyZXNzU3RyaW5nLCBsZXZlbC5hZGRyZXNzRm9ybWF0KSk7XG4gICAgICB9O1xuICAgICAgYmluYXJ5Q29udmVydGVyID0gZnVuY3Rpb24gKGFkZHJlc3NTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIERhdGFDb252ZXJ0ZXJzLmZvcm1hdEJpbmFyeUZvckFkZHJlc3NIZWFkZXIoXG4gICAgICAgICAgICBEYXRhQ29udmVydGVycy5hZGRyZXNzU3RyaW5nVG9CaW5hcnkoXG4gICAgICAgICAgICAgICAgYWRkcmVzc1N0cmluZyxcbiAgICAgICAgICAgICAgICBsZXZlbC5hZGRyZXNzRm9ybWF0KSxcbiAgICAgICAgICAgIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xuICAgICAgfTtcbiAgICAgIGhleENvbnZlcnRlciA9IGZ1bmN0aW9uIChhZGRyZXNzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBEYXRhQ29udmVydGVycy5iaW5hcnlUb0hleChcbiAgICAgICAgICAgIERhdGFDb252ZXJ0ZXJzLmFkZHJlc3NTdHJpbmdUb0JpbmFyeShcbiAgICAgICAgICAgICAgICBhZGRyZXNzU3RyaW5nLCBsZXZlbC5hZGRyZXNzRm9ybWF0KSk7XG4gICAgICB9O1xuICAgICAgZGVjaW1hbENvbnZlcnRlciA9IGNsZWFuQWRkcmVzc1N0cmluZztcbiAgICAgIGFzY2lpQ29udmVydGVyID0gY2xlYW5BZGRyZXNzU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYkNvbnZlcnRlciA9IGludFRvQUI7XG4gICAgICBiaW5hcnlDb252ZXJ0ZXIgPSBpbnRUb0JpbmFyeTtcbiAgICAgIGhleENvbnZlcnRlciA9IGludFRvSGV4O1xuICAgICAgZGVjaW1hbENvbnZlcnRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygxMCk7XG4gICAgICB9O1xuICAgICAgYXNjaWlDb252ZXJ0ZXIgPSBkZWNpbWFsQ29udmVydGVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRW5jb2RpbmdFbmFibGVkXyhFbmNvZGluZ1R5cGUuQV9BTkRfQikpIHtcbiAgICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFfQU5EX0JdW2ZpZWxkTmFtZV0sXG4gICAgICAgIG5ld1ZhbHVlOiBhYkNvbnZlcnRlcih0aGlzW2ZpZWxkTmFtZV0sIGZpZWxkV2lkdGgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkJJTkFSWSkpIHtcbiAgICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkJJTkFSWV1bZmllbGROYW1lXSxcbiAgICAgICAgbmV3VmFsdWU6IGJpbmFyeUNvbnZlcnRlcih0aGlzW2ZpZWxkTmFtZV0sIGZpZWxkV2lkdGgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkhFWEFERUNJTUFMKSkge1xuICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUxdW2ZpZWxkTmFtZV0sXG4gICAgICAgIG5ld1ZhbHVlOiBoZXhDb252ZXJ0ZXIodGhpc1tmaWVsZE5hbWVdLCBNYXRoLmNlaWwoZmllbGRXaWR0aCAvIDQpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5ERUNJTUFMKSkge1xuICAgICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuREVDSU1BTF1bZmllbGROYW1lXSxcbiAgICAgICAgbmV3VmFsdWU6IGRlY2ltYWxDb252ZXJ0ZXIodGhpc1tmaWVsZE5hbWVdLCBmaWVsZFdpZHRoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5BU0NJSSkpIHtcbiAgICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFTQ0lJXVtmaWVsZE5hbWVdLFxuICAgICAgICBuZXdWYWx1ZTogYXNjaWlDb252ZXJ0ZXIodGhpc1tmaWVsZE5hbWVdLCBmaWVsZFdpZHRoKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkFfQU5EX0IpKSB7XG4gICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkFfQU5EX0JdLm1lc3NhZ2UsXG4gICAgICBuZXdWYWx1ZTogZm9ybWF0QUIoYmluYXJ5VG9BQih0aGlzLm1lc3NhZ2UpLCBjaHVua1NpemUpLFxuICAgICAgd2F0ZXJtYXJrOiBuZXRzaW1Nc2cuYV9hbmRfYigpXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkJJTkFSWSkpIHtcbiAgICBsaXZlRmllbGRzLnB1c2goe1xuICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuQklOQVJZXS5tZXNzYWdlLFxuICAgICAgbmV3VmFsdWU6IGZvcm1hdEJpbmFyeSh0aGlzLm1lc3NhZ2UsIGNodW5rU2l6ZSksXG4gICAgICB3YXRlcm1hcms6IG5ldHNpbU1zZy5iaW5hcnkoKVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNFbmNvZGluZ0VuYWJsZWRfKEVuY29kaW5nVHlwZS5IRVhBREVDSU1BTCkpIHtcbiAgICBsaXZlRmllbGRzLnB1c2goe1xuICAgICAgaW5wdXRFbGVtZW50OiB0aGlzLnVpX1tFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUxdLm1lc3NhZ2UsXG4gICAgICBuZXdWYWx1ZTogZm9ybWF0SGV4KGJpbmFyeVRvSGV4KHRoaXMubWVzc2FnZSksIGNodW5rU2l6ZSksXG4gICAgICB3YXRlcm1hcms6IG5ldHNpbU1zZy5oZXhhZGVjaW1hbCgpXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkRFQ0lNQUwpKSB7XG4gICAgbGl2ZUZpZWxkcy5wdXNoKHtcbiAgICAgIGlucHV0RWxlbWVudDogdGhpcy51aV9bRW5jb2RpbmdUeXBlLkRFQ0lNQUxdLm1lc3NhZ2UsXG4gICAgICBuZXdWYWx1ZTogYWxpZ25EZWNpbWFsKGJpbmFyeVRvRGVjaW1hbCh0aGlzLm1lc3NhZ2UsIGNodW5rU2l6ZSkpLFxuICAgICAgd2F0ZXJtYXJrOiBuZXRzaW1Nc2cuZGVjaW1hbCgpXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5pc0VuY29kaW5nRW5hYmxlZF8oRW5jb2RpbmdUeXBlLkFTQ0lJKSkge1xuICAgIGxpdmVGaWVsZHMucHVzaCh7XG4gICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMudWlfW0VuY29kaW5nVHlwZS5BU0NJSV0ubWVzc2FnZSxcbiAgICAgIG5ld1ZhbHVlOiBiaW5hcnlUb0FzY2lpKHRoaXMubWVzc2FnZSwgY2h1bmtTaXplKSxcbiAgICAgIHdhdGVybWFyazogbmV0c2ltTXNnLmFzY2lpKClcbiAgICB9KTtcbiAgfVxuXG4gIGxpdmVGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBpZiAoZmllbGQuaW5wdXRFbGVtZW50WzBdICE9PSBza2lwRWxlbWVudCkge1xuICAgICAgaWYgKGZpZWxkLndhdGVybWFyayAmJiBmaWVsZC5uZXdWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgZmllbGQuaW5wdXRFbGVtZW50LnZhbChmaWVsZC53YXRlcm1hcmspO1xuICAgICAgICBmaWVsZC5pbnB1dEVsZW1lbnQuYWRkQ2xhc3MoJ3dhdGVybWFyaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGQuaW5wdXRFbGVtZW50LnZhbChmaWVsZC5uZXdWYWx1ZSk7XG4gICAgICAgIGZpZWxkLmlucHV0RWxlbWVudC5yZW1vdmVDbGFzcygnd2F0ZXJtYXJrJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnVwZGF0ZUJpdENvdW50ZXIoKTtcbiAgdGhpcy5jb250ZW50Q2hhbmdlQ2FsbGJhY2tfKCk7XG59O1xuXG4vKipcbiAqIElmIHRoZXJlJ3Mgb25seSBvbmUgcGFja2V0LCBhcHBsaWVzIFwiZGlzcGxheTogbm9uZVwiIHRvIHRoZSBidXR0b24gc28gdGhlXG4gKiBsYXN0IHBhY2tldCBjYW4ndCBiZSByZW1vdmVkLiAgT3RoZXJ3aXNlLCBjbGVhcnMgdGhlIENTUyBwcm9wZXJ0eSBvdmVycmlkZS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUudXBkYXRlUmVtb3ZlQnV0dG9uVmlzaWJpbGl0eV8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVtb3ZlUGFja2V0QnV0dG9uXy5jc3MoJ2Rpc3BsYXknLCAodGhpcy5wYWNrZXRDb3VudCA9PT0gMSA/ICdub25lJyA6ICcnKSk7XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGEgc2luZ2xlIGJpbmFyeSBzdHJpbmcgaW4gdGhlIGN1cnJlbnQgcGFja2V0IGZvcm1hdCwgYmFzZWRcbiAqIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB3aWRnZXQgKGNvbnRlbnQgb2YgaXRzIGludGVybmFsIGZpZWxkcykuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBwYWNrZXRcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUuZ2V0UGFja2V0QmluYXJ5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV2ZWwgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG4gIHZhciBlbmNvZGVyID0gbmV3IFBhY2tldC5FbmNvZGVyKGxldmVsLmFkZHJlc3NGb3JtYXQsXG4gICAgICBsZXZlbC5wYWNrZXRDb3VudEJpdFdpZHRoLCB0aGlzLnBhY2tldFNwZWNfKTtcbiAgcmV0dXJuIGVuY29kZXIuY29uY2F0ZW5hdGVCaW5hcnkoXG4gICAgICBlbmNvZGVyLm1ha2VCaW5hcnlIZWFkZXJzKHtcbiAgICAgICAgdG9BZGRyZXNzOiB0aGlzLnRvQWRkcmVzcyxcbiAgICAgICAgZnJvbUFkZHJlc3M6IHRoaXMuZnJvbUFkZHJlc3MsXG4gICAgICAgIHBhY2tldEluZGV4OiB0aGlzLnBhY2tldEluZGV4LFxuICAgICAgICBwYWNrZXRDb3VudDogdGhpcy5wYWNrZXRDb3VudFxuICAgICAgfSksXG4gICAgICB0aGlzLm1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBTZXRzIGVkaXRvciBmaWVsZHMgZnJvbSBhIGNvbXBsZXRlIHBhY2tldCBiaW5hcnksIGFjY29yZGluZyB0b1xuICogdGhlIGNvbmZpZ3VyZWQgaGVhZGVyIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3QmluYXJ5XG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUuc2V0UGFja2V0QmluYXJ5ID0gZnVuY3Rpb24gKHJhd0JpbmFyeSkge1xuICB2YXIgcGFja2V0ID0gbmV3IFBhY2tldCh0aGlzLnBhY2tldFNwZWNfLCByYXdCaW5hcnkpO1xuXG4gIGlmICh0aGlzLnNwZWNDb250YWluc0hlYWRlcl8oUGFja2V0LkhlYWRlclR5cGUuVE9fQUREUkVTUykpIHtcbiAgICB0aGlzLnRvQWRkcmVzcyA9IHBhY2tldC5nZXRIZWFkZXJBc0FkZHJlc3NTdHJpbmcoUGFja2V0LkhlYWRlclR5cGUuVE9fQUREUkVTUyk7XG4gIH1cblxuICBpZiAodGhpcy5zcGVjQ29udGFpbnNIZWFkZXJfKFBhY2tldC5IZWFkZXJUeXBlLkZST01fQUREUkVTUykpIHtcbiAgICB0aGlzLmZyb21BZGRyZXNzID0gcGFja2V0LmdldEhlYWRlckFzQWRkcmVzc1N0cmluZyhQYWNrZXQuSGVhZGVyVHlwZS5GUk9NX0FERFJFU1MpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3BlY0NvbnRhaW5zSGVhZGVyXyhQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpKSB7XG4gICAgdGhpcy5wYWNrZXRJbmRleCA9IHBhY2tldC5nZXRIZWFkZXJBc0ludChQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3BlY0NvbnRhaW5zSGVhZGVyXyhQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfQ09VTlQpKSB7XG4gICAgdGhpcy5wYWNrZXRDb3VudCA9IHBhY2tldC5nZXRIZWFkZXJBc0ludChQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfQ09VTlQpO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gcGFja2V0LmdldEJvZHlBc0JpbmFyeSgpO1xuXG4gIC8vIFJlLXJlbmRlciBhbGwgZW5jb2RpbmdzXG4gIHRoaXMudXBkYXRlRmllbGRzXygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBoZWFkZXJLZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5zcGVjQ29udGFpbnNIZWFkZXJfID0gZnVuY3Rpb24gKGhlYWRlcktleSkge1xuICByZXR1cm4gdGhpcy5wYWNrZXRTcGVjXy5zb21lKGZ1bmN0aW9uIChoZWFkZXJTcGVjKSB7XG4gICAgcmV0dXJuIGhlYWRlclNwZWMgPT09IGhlYWRlcktleTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBqdXN0IHRoZSBmaXJzdCBiaXQgb2YgdGhlIHBhY2tldCBiaW5hcnkgaWYgaXQgZXhpc3RzLCBmb3JcbiAqIHNpbmdsZS1iaXQgc2VuZGluZyBtb2RlLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IGEgc2luZ2xlIGJpdCBpZiBpdCBleGlzdHMsIGFzIFwiMFwiIG9yIFwiMVwiLFxuICogb3IgdW5kZWZpbmVkIGlmIG5vbmUgZG9lcy5cbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5nZXRGaXJzdEJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJpbmFyeSA9IHRoaXMuZ2V0UGFja2V0QmluYXJ5KCk7XG4gIHJldHVybiBiaW5hcnkubGVuZ3RoID4gMCA/IGJpbmFyeS5zdWJzdHIoMCwgMSkgOiB1bmRlZmluZWQ7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IGZyb21BZGRyZXNzICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnNldEZyb21BZGRyZXNzID0gZnVuY3Rpb24gKGZyb21BZGRyZXNzKSB7XG4gIHRoaXMuZnJvbUFkZHJlc3MgPSBmcm9tQWRkcmVzcztcbiAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHBhY2tldEluZGV4ICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnNldFBhY2tldEluZGV4ID0gZnVuY3Rpb24gKHBhY2tldEluZGV4KSB7XG4gIHRoaXMucGFja2V0SW5kZXggPSBwYWNrZXRJbmRleDtcbiAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG59O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHBhY2tldENvdW50ICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnNldFBhY2tldENvdW50ID0gZnVuY3Rpb24gKHBhY2tldENvdW50KSB7XG4gIHRoaXMucGFja2V0Q291bnQgPSBwYWNrZXRDb3VudDtcbiAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG4gIHRoaXMudXBkYXRlUmVtb3ZlQnV0dG9uVmlzaWJpbGl0eV8oKTtcbn07XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gbWF4UGFja2V0U2l6ZSAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5zZXRNYXhQYWNrZXRTaXplID0gZnVuY3Rpb24gKG1heFBhY2tldFNpemUpIHtcbiAgdGhpcy5tYXhQYWNrZXRTaXplXyA9IG1heFBhY2tldFNpemU7XG4gIHRoaXMudXBkYXRlQml0Q291bnRlcigpO1xufTtcblxuLyoqXG4gKiBTaG93IG9yIGhpZGUgcGFydHMgb2YgdGhlIHNlbmQgVUkgYmFzZWQgb24gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbmNvZGluZ1xuICogbW9kZS5cbiAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlW119IG5ld0VuY29kaW5nc1xuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnNldEVuY29kaW5ncyA9IGZ1bmN0aW9uIChuZXdFbmNvZGluZ3MpIHtcbiAgdGhpcy5lbmFibGVkRW5jb2RpbmdzSGFzaF8gPSBOZXRTaW1FbmNvZGluZ0NvbnRyb2wuZW5jb2RpbmdzQXNIYXNoKG5ld0VuY29kaW5ncyk7XG4gIE5ldFNpbUVuY29kaW5nQ29udHJvbC5oaWRlUm93c0J5RW5jb2RpbmcodGhpcy5yb290RGl2XywgbmV3RW5jb2RpbmdzKTtcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0aGF0IGNoZWNrcyB0aGlzLmVuYWJsZWRFbmNvZGluZ3NIYXNoXyB0byBzZWUgaWYgdGhlIGdpdmVuXG4gKiBlbmNvZGluZyBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZX0gcXVlcnlFbmNvZGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBlbmNvZGluZyBpcyBlbmFibGVkXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLmlzRW5jb2RpbmdFbmFibGVkXyA9IGZ1bmN0aW9uIChxdWVyeUVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmVuYWJsZWRFbmNvZGluZ3NIYXNoX1txdWVyeUVuY29kaW5nXSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIGhvdyBkYXRhIGlzIGludGVycHJldGVkIGFuZCBmb3JtYXR0ZWQgYnkgdGhpcyBjb21wb25lbnQsIHRyaWdnZXJpbmdcbiAqIGFuIHVwZGF0ZSBvZiBhbGwgaW5wdXQgZmllbGRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0NodW5rU2l6ZVxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnNldENodW5rU2l6ZSA9IGZ1bmN0aW9uIChuZXdDaHVua1NpemUpIHtcbiAgdGhpcy5jdXJyZW50Q2h1bmtTaXplXyA9IG5ld0NodW5rU2l6ZTtcbiAgdGhpcy51cGRhdGVGaWVsZHNfKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBsb2NhbCBkZXZpY2UgYml0cmF0ZSB3aGljaCBjaGFuZ2VzIHNlbmQgYW5pbWF0aW9uIHNwZWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0JpdFJhdGUgaW4gYml0cyBwZXIgc2Vjb25kXG4gKi9cbk5ldFNpbVBhY2tldEVkaXRvci5wcm90b3R5cGUuc2V0Qml0UmF0ZSA9IGZ1bmN0aW9uIChuZXdCaXRSYXRlKSB7XG4gIHRoaXMuYml0UmF0ZV8gPSBuZXdCaXRSYXRlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc3VhbCBzdGF0ZSBvZiB0aGUgYml0IGNvdW50ZXIgdG8gcmVmbGVjdCB0aGUgY3VycmVudFxuICogbWVzc2FnZSBiaW5hcnkgbGVuZ3RoIGFuZCBtYXhpbXVtIHBhY2tldCBzaXplLlxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLnVwZGF0ZUJpdENvdW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gdGhpcy5nZXRQYWNrZXRCaW5hcnkoKS5sZW5ndGg7XG4gIHZhciBtYXhTaXplID0gdGhpcy5tYXhQYWNrZXRTaXplXztcbiAgdGhpcy5iaXRDb3VudGVyXy5odG1sKG5ldHNpbU1zZy5iaXRDb3VudGVyKHtcbiAgICB4OiBzaXplLFxuICAgIHk6IG1heFNpemVcbiAgfSkpO1xuXG4gIHRoaXMuYml0Q291bnRlcl8udG9nZ2xlQ2xhc3MoJ292ZXJzaXplZCcsIHNpemUgPiB0aGlzLm1heFBhY2tldFNpemVfKTtcbn07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgdGhlIFwiUmVtb3ZlIFBhY2tldFwiIGJ1dHRvbi4gQ2FsbHMgaGFuZGxlciBwcm92aWRlZCBieVxuICogcGFyZW50LCBwYXNzaW5nIHNlbGYsIHNvIHRoYXQgcGFyZW50IGNhbiByZW1vdmUgdGhpcyBwYWNrZXQuXG4gKiBAcGFyYW0ge0V2ZW50fSBqUXVlcnlFdmVudFxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUGFja2V0RWRpdG9yLnByb3RvdHlwZS5vblJlbW92ZVBhY2tldEJ1dHRvbkNsaWNrXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgdGhpc0J1dHRvbiA9ICQoalF1ZXJ5RXZlbnQudGFyZ2V0KTtcbiAgLy8gV2UgYWxzbyBjaGVjayBwYXJlbnQgZWxlbWVudHMgaGVyZSwgYmVjYXVzZSB0aGlzIGJ1dHRvbiB1c2VzIGEgZm9udC1hd2Vzb21lXG4gIC8vIGdseXBoIHRoYXQgY2FuIHJlY2VpdmUgdGhlIGV2ZW50IGluc3RlYWQgb2YgdGhlIGFjdHVhbCBidXR0b24uXG4gIGlmICh0aGlzQnV0dG9uLmlzKCdbZGlzYWJsZWRdJykgfHwgdGhpc0J1dHRvbi5wYXJlbnRzKCkuaXMoJ1tkaXNhYmxlZF0nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucmVtb3ZlUGFja2V0Q2FsbGJhY2tfKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpcnN0IGJpdCBvZiB0aGUgcGFja2V0IGJpbmFyeSwgdXNlZCB3aGVuIHNlbmRpbmcgb25lIGJpdFxuICogYXQgYSB0aW1lLlxuICovXG5OZXRTaW1QYWNrZXRFZGl0b3IucHJvdG90eXBlLmNvbnN1bWVGaXJzdEJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRQYWNrZXRCaW5hcnkodGhpcy5nZXRQYWNrZXRCaW5hcnkoKS5zdWJzdHIoMSkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbiAgdmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuICB2YXIgTmV0U2ltQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9OZXRTaW1Db25zdGFudHMnKTtcbiAgdmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xuICB2YXIgUGFja2V0ID0gcmVxdWlyZSgnLi9QYWNrZXQnKTtcblxuICB2YXIgRW5jb2RpbmdUeXBlID0gTmV0U2ltQ29uc3RhbnRzLkVuY29kaW5nVHlwZTtcbiAgdmFyIE1lc3NhZ2VHcmFudWxhcml0eSA9IE5ldFNpbUNvbnN0YW50cy5NZXNzYWdlR3JhbnVsYXJpdHk7XG4gIHZhciBQYWNrZXRVSUNvbHVtblR5cGUgPSBOZXRTaW1Db25zdGFudHMuUGFja2V0VUlDb2x1bW5UeXBlO1xuXG4gIHZhciBnZXRFbmNvZGluZ0xhYmVsID0gTmV0U2ltVXRpbHMuZ2V0RW5jb2RpbmdMYWJlbDtcbiAgdmFyIGZvckVhY2hFbnVtVmFsdWUgPSBOZXRTaW1VdGlscy5mb3JFYWNoRW51bVZhbHVlO1xuXG4gIC8qKlxuICAqIEBuYW1lIGVuYWJsZWRFbmNvZGluZ3NIYXNoXG4gICogQHR5cGUge09iamVjdH1cbiAgKi9cblxuICBmdW5jdGlvbiBpc0VuY29kaW5nRW5hYmxlZChxdWVyeUVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGVuYWJsZWRFbmNvZGluZ3NIYXNoW3F1ZXJ5RW5jb2RpbmddID09PSB0cnVlO1xuICB9XG5cbiAgLyoqIEB0eXBlIHtQYWNrZXQuSGVhZGVyVHlwZVtdfSAqL1xuICB2YXIgaGVhZGVyRmllbGRzID0gcGFja2V0U3BlYztcblxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHZhciBzaG93VG9BZGRyZXNzID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuVE9fQUREUkVTUykgPiAtMTtcblxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHZhciBzaG93RnJvbUFkZHJlc3MgPSBoZWFkZXJGaWVsZHMuaW5kZXhPZihQYWNrZXQuSGVhZGVyVHlwZS5GUk9NX0FERFJFU1MpID4gLTE7XG5cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICB2YXIgc2hvd1BhY2tldEluZm8gPSBoZWFkZXJGaWVsZHMuaW5kZXhPZihQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpID4gLTEgJiZcbiAgICAgIGhlYWRlckZpZWxkcy5pbmRleE9mKFBhY2tldC5IZWFkZXJUeXBlLlBBQ0tFVF9DT1VOVCkgPiAtMTtcblxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHZhciB1c2VQYWNrZXRHcmFudWxhcml0eSA9IChtZXNzYWdlR3JhbnVsYXJpdHkgPT09IE1lc3NhZ2VHcmFudWxhcml0eS5QQUNLRVRTKTtcblxuICAvKipcbiAgICogV3JpdGUgdGhlIHRhYmxlIGhlYWRlciB0byB0aGUgcGFnZSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgcGFja2V0LWhlYWRlciBjb2x1bW5zIGVuYWJsZWQuXG4gICAqL1xuICBmdW5jdGlvbiB0YWJsZUhlYWRlcigpIHtcbiAgICA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgIDx0aCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDQ2LCAgUGFja2V0VUlDb2x1bW5UeXBlLkVOQ09ESU5HX0xBQkVMICkpLCAnXCI+PC90aD5cXG4gICAgICAgICAgJyk7NDc7IGlmIChzaG93VG9BZGRyZXNzKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICA8dGggbm93cmFwIGNsYXNzPVwiJywgZXNjYXBlKCg0OCwgIFBhY2tldFVJQ29sdW1uVHlwZS5UT19BRERSRVNTICkpLCAnXCI+JywgZXNjYXBlKCg0OCwgIGkxOG4udG8oKSApKSwgJzwvdGg+XFxuICAgICAgICAgICcpOzQ5OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICAnKTs1MDsgaWYgKHNob3dGcm9tQWRkcmVzcykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgPHRoIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoNTEsICBQYWNrZXRVSUNvbHVtblR5cGUuRlJPTV9BRERSRVNTICkpLCAnXCI+JywgZXNjYXBlKCg1MSwgIGkxOG4uZnJvbSgpICkpLCAnPC90aD5cXG4gICAgICAgICAgJyk7NTI7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICAgICcpOzUzOyBpZiAoc2hvd1BhY2tldEluZm8pIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgIDx0aCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDU0LCAgUGFja2V0VUlDb2x1bW5UeXBlLlBBQ0tFVF9JTkZPICkpLCAnXCI+JywgZXNjYXBlKCg1NCwgIGkxOG4ucGFja2V0KCkgKSksICc8L3RoPlxcbiAgICAgICAgICAnKTs1NTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgPHRoIGNsYXNzPVwiJywgZXNjYXBlKCg1NiwgIFBhY2tldFVJQ29sdW1uVHlwZS5NRVNTQUdFICkpLCAnXCI+XFxuICAgICAgICAgICAgJywgZXNjYXBlKCg1NywgIGkxOG4ubWVzc2FnZSgpICkpLCAnXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhY2tldC1jb250cm9sc1wiPlxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZXRzaW0tYnV0dG9uIHNlY29uZGFyeSByZW1vdmUtcGFja2V0LWJ1dHRvblwiIHRpdGxlPVwiJywgZXNjYXBlKCg1OSwgIGkxOG4ucmVtb3ZlUGFja2V0KCkgKSksICdcIj48aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPC90aGVhZD5cXG4gICAgJyk7NjQ7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYSB0YWJsZSByb3cgdG8gdGhlIHBhZ2UgZm9yIHRoZSBnaXZlbiBkYXRhIGVuY29kaW5nLlxuICAgKiBAcGFyYW0ge0VuY29kaW5nVHlwZX0gZW5jb2RpbmdUeXBlXG4gICAqL1xuICBmdW5jdGlvbiBlZGl0b3JSb3coZW5jb2RpbmdUeXBlKSB7XG4gICAgOyBidWYucHVzaCgnXFxuICAgICAgPHRyIGNsYXNzPVwiJywgZXNjYXBlKCg3MywgIGVuY29kaW5nVHlwZSApKSwgJ1wiPlxcbiAgICAgICAgPHRoIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoNzQsICBQYWNrZXRVSUNvbHVtblR5cGUuRU5DT0RJTkdfTEFCRUwgKSksICdcIj4nLCBlc2NhcGUoKDc0LCAgZ2V0RW5jb2RpbmdMYWJlbChlbmNvZGluZ1R5cGUpICkpLCAnPC90aD5cXG4gICAgICAgICcpOzc1OyBpZiAoc2hvd1RvQWRkcmVzcykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDx0ZCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDc2LCAgUGFja2V0VUlDb2x1bW5UeXBlLlRPX0FERFJFU1MgKSksICdcIj48aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cIicsIGVzY2FwZSgoNzYsICBQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTICkpLCAnXCIgLz48L3RkPlxcbiAgICAgICAgJyk7Nzc7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICAnKTs3ODsgaWYgKHNob3dGcm9tQWRkcmVzcykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDx0ZCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDc5LCAgUGFja2V0VUlDb2x1bW5UeXBlLkZST01fQUREUkVTUyApKSwgJ1wiPjxpbnB1dCB0eXBlPVwidGV4dFwiIHJlYWRvbmx5IGNsYXNzPVwiJywgZXNjYXBlKCg3OSwgIFBhY2tldC5IZWFkZXJUeXBlLkZST01fQUREUkVTUyApKSwgJ1wiIC8+PC90ZD5cXG4gICAgICAgICcpOzgwOyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgJyk7ODE7IGlmIChzaG93UGFja2V0SW5mbykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDx0ZCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDgyLCAgUGFja2V0VUlDb2x1bW5UeXBlLlBBQ0tFVF9JTkZPICkpLCAnXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgcmVhZG9ubHkgY2xhc3M9XCInLCBlc2NhcGUoKDgyLCAgUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0lOREVYICkpLCAnXCIgLz4nLCBlc2NhcGUoKDgyLCAgaTE4bi5fb2ZfKCkgKSksICc8aW5wdXQgdHlwZT1cInRleHRcIiByZWFkb25seSBjbGFzcz1cIicsIGVzY2FwZSgoODIsICBQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfQ09VTlQgKSksICdcIiAvPjwvdGQ+XFxuICAgICAgICAnKTs4MzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDx0ZCBjbGFzcz1cIicsIGVzY2FwZSgoODQsICBQYWNrZXRVSUNvbHVtblR5cGUuTUVTU0FHRSApKSwgJ1wiPjxkaXY+PHRleHRhcmVhIGNsYXNzPVwibWVzc2FnZVwiPjwvdGV4dGFyZWE+PC9kaXY+PC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICAnKTs4NjtcbiAgfVxuOyBidWYucHVzaCgnXFxuPHRhYmxlPlxcbiAgJyk7OTA7XG4gICAgLy8gT25seSB3cml0ZSB0aGUgaGVhZGVyIHJvdyBpZiB3ZSBhcmUgdXNpbmcgcGFja2V0c1xuICAgIGlmICh1c2VQYWNrZXRHcmFudWxhcml0eSkge1xuICAgICAgdGFibGVIZWFkZXIoKTtcbiAgICB9XG4gIDsgYnVmLnB1c2goJ1xcbiAgPHRib2R5PlxcbiAgICAnKTs5NztcbiAgICAgIC8vIFdyaXRlIGEgYm9keSByb3cgZm9yIGV2ZXJ5IHBhY2tldCBlbmNvZGluZzsgd2UgaGlkZSBzb21lIG9mIHRoZW0gcG9zdC1yZW5kZXIuXG4gICAgICBmb3JFYWNoRW51bVZhbHVlKEVuY29kaW5nVHlwZSwgZnVuY3Rpb24gKGVuY29kaW5nVHlwZSkge1xuICAgICAgICBpZiAoaXNFbmNvZGluZ0VuYWJsZWQoZW5jb2RpbmdUeXBlKSkge1xuICAgICAgICAgIGVkaXRvclJvdyhlbmNvZGluZ1R5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICA7IGJ1Zi5wdXNoKCdcXG4gIDwvdGJvZHk+XFxuPC90YWJsZT5cXG5cXG4nKTsxMDg7IGlmICh1c2VQYWNrZXRHcmFudWxhcml0eSkgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgY2xhc3M9XCJiaXQtY291bnRlclwiPjwvZGl2PlxcbicpOzExMDsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb250cm9sbGVyIGZvciB0aGUgXCJNeSBEZXZpY2VcIiB0YWIgaW4gdGhlIGxlZnQgY29sdW1uLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltTXlEZXZpY2VUYWIuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1CaXRSYXRlQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltQml0UmF0ZUNvbnRyb2wnKTtcbnZhciBOZXRTaW1QdWxzZVJhdGVDb250cm9sID0gcmVxdWlyZSgnLi9OZXRTaW1QdWxzZVJhdGVDb250cm9sJyk7XG52YXIgTmV0U2ltQ2h1bmtTaXplQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltQ2h1bmtTaXplQ29udHJvbCcpO1xudmFyIE5ldFNpbUVuY29kaW5nQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltRW5jb2RpbmdDb250cm9sJyk7XG52YXIgTmV0U2ltTWV0cm9ub21lID0gcmVxdWlyZSgnLi9OZXRTaW1NZXRyb25vbWUnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBcIk15IERldmljZVwiIHRhYi5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge1J1bkxvb3B9IHJ1bkxvb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5jaHVua1NpemVDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmJpdFJhdGVDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmVuY29kaW5nQ2hhbmdlQ2FsbGJhY2tcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltTXlEZXZpY2VUYWIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBydW5Mb29wLCBjYWxsYmFja3MpIHtcbiAgLyoqXG4gICAqIENvbXBvbmVudCByb290LCB3aGljaCB3ZSBmaWxsIHdoZW5ldmVyIHdlIGNhbGwgcmVuZGVyKClcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdERpdl8gPSByb290RGl2O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7UnVuTG9vcH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucnVuTG9vcF8gPSBydW5Mb29wO1xuXG4gIC8qKlxuICAgKiBGcmVxdWVuY3kgb2YgbWV0cm9ub21lIHB1bHNlcywgaW4gcHVsc2VzIHBlciBzZWNvbmRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYml0c1BlclNlY29uZF8gPSAxO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNodW5rU2l6ZVNsaWRlckNoYW5nZUNhbGxiYWNrXyA9IGNhbGxiYWNrcy5jaHVua1NpemVDaGFuZ2VDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iaXRSYXRlQ2hhbmdlQ2FsbGJhY2tfID0gY2FsbGJhY2tzLmJpdFJhdGVDaGFuZ2VDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lbmNvZGluZ0NoYW5nZUNhbGxiYWNrXyA9IGNhbGxiYWNrcy5lbmNvZGluZ0NoYW5nZUNhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTWV0cm9ub21lfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tZXRyb25vbWVfID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbVB1bHNlUmF0ZUNvbnRyb2x9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnB1bHNlUmF0ZUNvbnRyb2xfID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbUJpdFJhdGVDb250cm9sfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iaXRSYXRlQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltQ2h1bmtTaXplQ29udHJvbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2h1bmtTaXplQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltRW5jb2RpbmdDb250cm9sfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lbmNvZGluZ0NvbnRyb2xfID0gbnVsbDtcblxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBGaWxsIHRoZSByb290IGRpdiB3aXRoIG5ldyBlbGVtZW50cyByZWZsZWN0aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gKi9cbk5ldFNpbU15RGV2aWNlVGFiLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcblxuICB2YXIgcmVuZGVyZWRNYXJrdXAgPSAkKG1hcmt1cCh7XG4gICAgbGV2ZWw6IGxldmVsQ29uZmlnXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcblxuICBpZiAobGV2ZWxDb25maWcuc2hvd01ldHJvbm9tZSkge1xuICAgIHRoaXMubWV0cm9ub21lXyA9IG5ldyBOZXRTaW1NZXRyb25vbWUoXG4gICAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnLm1ldHJvbm9tZScpLFxuICAgICAgICB0aGlzLnJ1bkxvb3BfKTtcbiAgICB0aGlzLm1ldHJvbm9tZV8uc2V0RnJlcXVlbmN5KHRoaXMuYml0c1BlclNlY29uZF8pO1xuICB9XG5cbiAgaWYgKGxldmVsQ29uZmlnLnNob3dQdWxzZVJhdGVTbGlkZXIpIHtcbiAgICB0aGlzLnB1bHNlUmF0ZUNvbnRyb2xfID0gbmV3IE5ldFNpbVB1bHNlUmF0ZUNvbnRyb2woXG4gICAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnLnB1bHNlLXJhdGUnKSxcbiAgICAgICAgMSAvIHRoaXMuYml0c1BlclNlY29uZF8sXG4gICAgICAgIGZ1bmN0aW9uIChzZWNvbmRzUGVyQml0KSB7XG4gICAgICAgICAgdGhpcy5iaXRSYXRlQ2hhbmdlQ2FsbGJhY2tfKDEgLyBzZWNvbmRzUGVyQml0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGlmIChsZXZlbENvbmZpZy5zaG93Qml0UmF0ZUNvbnRyb2wpIHtcbiAgICB0aGlzLmJpdFJhdGVDb250cm9sXyA9IG5ldyBOZXRTaW1CaXRSYXRlQ29udHJvbChcbiAgICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcuYml0cmF0ZScpLFxuICAgICAgICB0aGlzLmJpdHNQZXJTZWNvbmRfLFxuICAgICAgICB0aGlzLmJpdFJhdGVDaGFuZ2VDYWxsYmFja18pO1xuICAgIGlmIChsZXZlbENvbmZpZy5sb2NrQml0UmF0ZUNvbnRyb2wpIHtcbiAgICAgIHRoaXMuYml0UmF0ZUNvbnRyb2xfLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cblxuICBpZiAobGV2ZWxDb25maWcuc2hvd0NodW5rU2l6ZUNvbnRyb2wpIHtcbiAgICB0aGlzLmNodW5rU2l6ZUNvbnRyb2xfID0gbmV3IE5ldFNpbUNodW5rU2l6ZUNvbnRyb2woXG4gICAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnLmNodW5rLXNpemUnKSxcbiAgICAgICAgdGhpcy5jaHVua1NpemVTbGlkZXJDaGFuZ2VDYWxsYmFja18pO1xuICAgIGlmIChsZXZlbENvbmZpZy5sb2NrQ2h1bmtTaXplQ29udHJvbCkge1xuICAgICAgdGhpcy5jaHVua1NpemVDb250cm9sXy5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxldmVsQ29uZmlnLnNob3dFbmNvZGluZ0NvbnRyb2xzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmVuY29kaW5nQ29udHJvbF8gPSBuZXcgTmV0U2ltRW5jb2RpbmdDb250cm9sKFxuICAgICAgICB0aGlzLnJvb3REaXZfLmZpbmQoJy5lbmNvZGluZycpLFxuICAgICAgICBsZXZlbENvbmZpZyxcbiAgICAgICAgdGhpcy5lbmNvZGluZ0NoYW5nZUNhbGxiYWNrXyk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgY2hhbmdpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBwdWxzZS1yYXRlIHNsaWRlclxuICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNQZXJQdWxzZSBpbiBzZWNvbmRzIHBlciBwdWxzZVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTXlEZXZpY2VUYWIucHJvdG90eXBlLnB1bHNlUmF0ZVNsaWRlckNoYW5nZV8gPSBmdW5jdGlvbiAoc2Vjb25kc1BlclB1bHNlKSB7XG4gIHRoaXMuc2V0Qml0UmF0ZSgxIC8gc2Vjb25kc1BlclB1bHNlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJTZWNvbmRcbiAqL1xuTmV0U2ltTXlEZXZpY2VUYWIucHJvdG90eXBlLnNldEJpdFJhdGUgPSBmdW5jdGlvbiAoYml0c1BlclNlY29uZCkge1xuICB0aGlzLmJpdHNQZXJTZWNvbmRfID0gYml0c1BlclNlY29uZDtcblxuICBpZiAodGhpcy5tZXRyb25vbWVfKSB7XG4gICAgdGhpcy5tZXRyb25vbWVfLnNldEZyZXF1ZW5jeShiaXRzUGVyU2Vjb25kKTtcbiAgfVxuXG4gIGlmICh0aGlzLmJpdFJhdGVDb250cm9sXykge1xuICAgIHRoaXMuYml0UmF0ZUNvbnRyb2xfLnNldFZhbHVlKGJpdHNQZXJTZWNvbmQpO1xuICB9XG5cbiAgaWYgKHRoaXMucHVsc2VSYXRlQ29udHJvbF8gJiYgYml0c1BlclNlY29uZCA8IEluZmluaXR5KSB7XG4gICAgdGhpcy5wdWxzZVJhdGVDb250cm9sXy5zZXRWYWx1ZSgxIC8gYml0c1BlclNlY29uZCk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzbGlkZXIgYW5kIGl0cyBsYWJlbCB0byBkaXNwbGF5IHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdDaHVua1NpemVcbiAqL1xuTmV0U2ltTXlEZXZpY2VUYWIucHJvdG90eXBlLnNldENodW5rU2l6ZSA9IGZ1bmN0aW9uIChuZXdDaHVua1NpemUpIHtcbiAgaWYgKHRoaXMuY2h1bmtTaXplQ29udHJvbF8pIHtcbiAgICB0aGlzLmNodW5rU2l6ZUNvbnRyb2xfLnNldFZhbHVlKG5ld0NodW5rU2l6ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gbmV3RW5jb2RpbmdzXG4gKi9cbk5ldFNpbU15RGV2aWNlVGFiLnByb3RvdHlwZS5zZXRFbmNvZGluZ3MgPSBmdW5jdGlvbiAobmV3RW5jb2RpbmdzKSB7XG4gIGlmICh0aGlzLmVuY29kaW5nQ29udHJvbF8pIHtcbiAgICB0aGlzLmVuY29kaW5nQ29udHJvbF8uc2V0RW5jb2RpbmdzKG5ld0VuY29kaW5ncyk7XG4gIH1cbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBVSSBzbGlkZXIgZm9yIGNoYW5naW5nIHRoZSBwdWxzZSByYXRlIChiaXRyYXRlKSBvZiB0aGUgbG9jYWwgZGV2aWNlLlxuICogICAgICAgICAgIERpZmZlcnMgZnJvbSB0aGUgYml0cmF0ZSBzbGlkZXIgaW4gaXRzIHNjYWxlIGFuZCB1bml0cy5cbiAqIEBzZWUgTmV0U2ltQml0UmF0ZUNvbnRyb2xcbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFV0aWxzIHJlcXVpcmVkIG9ubHkgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cygpXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIE5ldFNpbVNsaWRlciA9IHJlcXVpcmUoJy4vTmV0U2ltU2xpZGVyJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBwYWNrZXQgc2l6ZSBzbGlkZXIvc2VsZWN0b3JcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbFZhbHVlIC0gaW4gc2Vjb25kcyBwZXIgcHVsc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNsaWRlckNoYW5nZUNhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbVB1bHNlUmF0ZUNvbnRyb2wgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBpbml0aWFsVmFsdWUsXG4gICAgc2xpZGVyQ2hhbmdlQ2FsbGJhY2spIHtcbiAgTmV0U2ltU2xpZGVyLkRlY2ltYWxQcmVjaXNpb25TbGlkZXIuY2FsbCh0aGlzLCByb290RGl2LCB7XG4gICAgb25DaGFuZ2U6IHNsaWRlckNoYW5nZUNhbGxiYWNrLFxuICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgbWluOiAwLjUsXG4gICAgbWF4OiA1LjAsXG4gICAgc3RlcDogLTAuMjVcbiAgfSk7XG5cbiAgLy8gQXV0by1yZW5kZXIsIHVubGlrZSBvdXIgYmFzZSBjbGFzc1xuICB0aGlzLnJlbmRlcigpO1xufTtcbk5ldFNpbVB1bHNlUmF0ZUNvbnRyb2wuaW5oZXJpdHMoTmV0U2ltU2xpZGVyLkRlY2ltYWxQcmVjaXNpb25TbGlkZXIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtZXJpYyByYXRlIHZhbHVlIChpbiBzZWNvbmRzIHBlciBwdWxzZSkgaW50byBhXG4gKiBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gbnVtZXJpYyB2YWx1ZSBvZiB0aGUgY29udHJvbFxuICogQHJldHVybnMge3N0cmluZ30gLSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltUHVsc2VSYXRlQ29udHJvbC5wcm90b3R5cGUudmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgcm91bmRlZCA9IE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbiAgaWYgKHJvdW5kZWQgPT09IDEpIHtcbiAgICByZXR1cm4gaTE4bi54U2Vjb25kUGVyUHVsc2UoeyB4OiByb3VuZGVkIH0pO1xuICB9XG4gIHJldHVybiBpMThuLnhTZWNvbmRzUGVyUHVsc2UoeyB4OiByb3VuZGVkIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWVyaWMgcmF0ZSB2YWx1ZSAoaW4gc2Vjb25kcyBwZXIgcHVsc2UpIGludG8gYSBjb21wYWN0XG4gKiBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgdmFsdWUsIHVzZWQgZm9yIGVuZHMgb2YgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBudW1lcmljIHZhbHVlIG9mIHRoZSBjb250cm9sXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdmFsdWVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1QdWxzZVJhdGVDb250cm9sLnByb3RvdHlwZS52YWx1ZVRvU2hvcnRMYWJlbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJuZXRzaW0tbXktZGV2aWNlLXRhYlwiPlxcblxcbiAgJyk7MzsgaWYgKGxldmVsLnNob3dNZXRyb25vbWUpIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXYgY2xhc3M9XCJtZXRyb25vbWVcIj48L2Rpdj5cXG4gICcpOzU7IH0gOyBidWYucHVzaCgnXFxuXFxuICAnKTs3OyBpZiAobGV2ZWwuc2hvd1B1bHNlUmF0ZVNsaWRlcikgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGgxPlB1bHNlIHJhdGU8L2gxPlxcbiAgICA8ZGl2IGNsYXNzPVwicHVsc2UtcmF0ZVwiPjwvZGl2PlxcbiAgJyk7MTA7IH0gOyBidWYucHVzaCgnXFxuXFxuICAnKTsxMjsgaWYgKGxldmVsLnNob3dCaXRSYXRlQ29udHJvbCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGgxPkJpdHJhdGU8L2gxPlxcbiAgICA8ZGl2IGNsYXNzPVwiYml0cmF0ZVwiPjwvZGl2PlxcbiAgJyk7MTU7IH0gOyBidWYucHVzaCgnXFxuXFxuICAnKTsxNzsgaWYgKGxldmVsLnNob3dDaHVua1NpemVDb250cm9sKSB7IDsgYnVmLnB1c2goJ1xcbiAgICA8aDE+Q2h1bmsgc2l6ZTwvaDE+XFxuICAgIDxkaXYgY2xhc3M9XCJjaHVuay1zaXplXCI+PC9kaXY+XFxuICAnKTsyMDsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG4gICcpOzIyOyBpZiAobGV2ZWwuc2hvd0VuY29kaW5nQ29udHJvbHMubGVuZ3RoID4gMCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBjbGFzcz1cImVuY29kaW5nXCI+PC9kaXY+XFxuICAnKTsyNDsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb21wb25lbnQ6IEFuIGFuaW1hdGVkIFNWRyBtZXRyb25vbWUuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltTWV0cm9ub21lLmh0bWwuZWpzJyk7XG5cbi8qKlxuICogQW4gU1ZHIFwibWV0cm9ub21lXCIsIGluIHRoZSBmb3JtIG9mIGEgcmFkaWFsIG1ldGVyIHRoYXQgZmlsbHMgYW5kIHJlc2V0c1xuICogYXQgYSByZWd1bGFyIGludGVydmFsLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge1J1bkxvb3B9IHJ1bkxvb3BcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltTWV0cm9ub21lID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdiwgcnVuTG9vcCkge1xuICAvKipcbiAgICogQ29tcG9uZW50IHJvb3QsIHdoaWNoIHdlIGZpbGwgd2hlbmV2ZXIgd2UgY2FsbCByZW5kZXIoKVxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IHJvb3REaXY7XG5cbiAgLyoqXG4gICAqIFRpbWUgb2YgbGFzdCBwdWxzZSwgaW4gUnVuTG9vcCBzaW11bGF0aW9uIHRpbWVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubGFzdFB1bHNlVGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBiZXR3ZWVuIG1ldHJvbm9tZSBwdWxzZXNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucHVsc2VJbnRlcnZhbE1pbGxpc18gPSAwO1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVkIHByb2dyZXNzIHRvd2FyZCB0aGUgbmV4dCBwdWxzZSwgZnJvbSAwLjAgdG8gMS4wXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnByb2dyZXNzXyA9IDA7XG5cbiAgLyoqXG4gICAqIEhvdyBsb25nIGl0J3MgYmVlbiBzaW5jZSB0aGUgbGFzdCBwdWxzZSBpbiBtc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wdWxzZUFnZV8gPSAwO1xuXG4gIC8vIFJlZ2lzdGVyIHdpdGggcnVuIGxvb3BcbiAgcnVuTG9vcC5yZW5kZXIucmVnaXN0ZXIodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7UnVuTG9vcC5DbG9ja30gY2xvY2tcbiAqL1xuTmV0U2ltTWV0cm9ub21lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgaWYgKCF0aGlzLmxhc3RQdWxzZVRpbWVfKSB7XG4gICAgdGhpcy5sYXN0UHVsc2VUaW1lXyA9IGNsb2NrLnRpbWU7XG4gIH1cblxuICAvLyBBbiBpbmZpbml0ZSBpbnRlcnZhbCBtZWFucyB3ZSdyZSBlZmZlY3RpdmVseSBwYXVzZWQsIHNvIHNuYXAgdG8gemVyb1xuICAvLyBwcm9ncmVzcyAodmlzdWFsaXplZCBhcyBhbiBcImVtcHR5XCIgbWV0ZXIpXG4gIGlmICh0aGlzLnB1bHNlSW50ZXJ2YWxNaWxsaXNfID09PSBJbmZpbml0eSkge1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gMDtcbiAgICB0aGlzLnB1bHNlQWdlXyA9IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIC8vIEZvciBhIG5vbi1pbmZpbml0ZSBpbnRlcnZhbCwgdXBkYXRlIHRoZSBtZXRlciBwcm9ncmVzcyB2YWx1ZSBhY2NvcmRpbmdcbiAgICAvLyB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgIHRoaXMucHVsc2VBZ2VfID0gY2xvY2sudGltZSAtIHRoaXMubGFzdFB1bHNlVGltZV87XG4gICAgdGhpcy5wcm9ncmVzc18gPSBNYXRoLm1pbih0aGlzLnB1bHNlQWdlXyAvIHRoaXMucHVsc2VJbnRlcnZhbE1pbGxpc18sIDEpO1xuXG4gICAgaWYgKHRoaXMucHVsc2VBZ2VfID49IHRoaXMucHVsc2VJbnRlcnZhbE1pbGxpc18pIHtcbiAgICAgIC8vIFB1bHNlXG4gICAgICB2YXIgbWluaW11bUxhc3RQdWxzZVRpbWUgPSBjbG9jay50aW1lIC0gdGhpcy5wdWxzZUludGVydmFsTWlsbGlzXztcbiAgICAgIHdoaWxlICh0aGlzLmxhc3RQdWxzZVRpbWVfIDwgbWluaW11bUxhc3RQdWxzZVRpbWUpIHtcbiAgICAgICAgdGhpcy5sYXN0UHVsc2VUaW1lXyArPSB0aGlzLnB1bHNlSW50ZXJ2YWxNaWxsaXNfO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXJlZE1hcmt1cCA9ICQobWFya3VwKHtcbiAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzc18sXG4gICAgcHVsc2VBZ2U6IHRoaXMucHVsc2VBZ2VfXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBtZXRyb25vbWUgc3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwdWxzZXNQZXJTZWNvbmRcbiAqL1xuTmV0U2ltTWV0cm9ub21lLnByb3RvdHlwZS5zZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAocHVsc2VzUGVyU2Vjb25kKSB7XG4gIGlmIChwdWxzZXNQZXJTZWNvbmQgPT09IDAgfHwgcHVsc2VzUGVyU2Vjb25kID09PSBJbmZpbml0eSkge1xuICAgIHRoaXMucHVsc2VJbnRlcnZhbE1pbGxpc18gPSBJbmZpbml0eTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWxzZUludGVydmFsTWlsbGlzXyA9IDEwMDAgLyBwdWxzZXNQZXJTZWNvbmQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xuICBmdW5jdGlvbiBtb3ZlQ29tbWFuZCh4LCB5KSB7XG4gICAgcmV0dXJuICdNJyArIHggKyAnICcgKyB5O1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZUNvbW1hbmQoeCwgeSkge1xuICAgIHJldHVybiAnTCAnICsgeCArICcgJyArIHk7XG4gIH1cblxuICBmdW5jdGlvbiBhcmNDb21tYW5kKHJYLCByWSwgcm90LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgZmluYWxYLCBmaW5hbFkpIHtcbiAgICByZXR1cm4gJ0EgJyArIHJYICsgJyAnICsgclkgKyAnLCAnICsgcm90ICsgJywgJyArIGxhcmdlQXJjRmxhZyArICcsICcgKyBzd2VlcEZsYWcgKyAnLCAnICsgZmluYWxYICsgJyAnICsgZmluYWxZO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VTaGFwZUNvbW1hbmQoKSB7XG4gICAgcmV0dXJuICdaJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXRlciByYWRpdXMgb2YgcHJvZ3Jlc3MgbWV0ZXJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqL1xuICB2YXIgT1VURVJfUkFEVVMgPSA0NTtcblxuICAvKipcbiAgICogSW5uZXIgcmFkaXVzIG9mIHByb2dyZXNzIG1ldGVyLCBhbmQgbWF4aW11bSByYWRpdXMgb2YgcHVsc2UgZG90XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdmFyIElOTkVSX1JBRElVUyA9IDMwO1xuXG4gIC8qKlxuICAgKiBIb3cgbG9uZyAoaW4gbXMpIGl0IHRha2VzIHRoZSBwdWxzZSBjaXJjbGUgdG8gc2hyaW5rIGJhY2sgdG8gbm90aGluZyBhZnRlciBpdCBhcHBlYXJzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdmFyIFBVTFNFX0ZBTExPRkZfTVMgPSA1MDA7XG5cbiAgLyoqXG4gICAqIFJhZGl1cyBvZiB0aGUgaW5uZXIgcHVsc2UgZG90LCBiYXNlZCBvbiB0aGUgcHVsc2UgYWdlLiAgU3RhcnRzIGZ1bGwgc2l6ZSwgdGhlbiBzaHJpbmtzXG4gICAqIHRvIHI9MCBvdmVyIFBVTFNFX0ZBTExPRkZfTVMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB2YXIgcHVsc2VGYWxsb2ZmTm9ybWFsaXplZFByb2dyZXNzID0gTWF0aC5taW4ocHVsc2VBZ2UvIFBVTFNFX0ZBTExPRkZfTVMsIDEpO1xuICB2YXIgcHVsc2VEb3RSYWRpdXMgPSBJTk5FUl9SQURJVVMgKiAoMSAtIHB1bHNlRmFsbG9mZk5vcm1hbGl6ZWRQcm9ncmVzcyk7XG5cblxuICAvKipcbiAgICogR2l2ZW4gYSBjZXJ0YWluIHBlcmNlbnRhZ2UgKGFzIGEgdmFsdWUgaW4gdGhlIHJhbmdlIFswLjAtMS4wXSkgdGhpc1xuICAgKiBnZW5lcmF0ZXMgYSBkYXRhIHN0cmluZyBmb3IgYSBcInBhdGhcIiBzdmcgb2JqZWN0IHRoYXQgZHJhd3MgYSBwYXJ0aWFsbHktZmlsbGVkIGFyY1xuICAgKiBzd2VlcGluZyB0aGUgYXBwcm9wcmlhdGUgcGVyY2VudGFnZSBvZiBhIGNpcmNsZS5cbiAgICogUHJvZ3Jlc3MgYmVnaW5zIGl0cyBzd2VlcCBhdCBcImVhc3RcIiBhbmQgcHJvY2VlZHMgY2xvY2t3aXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFByb2dyZXNzIC0gbnVtYmVyIGZyb20gMC4wIHRvIDEuMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBkYXRhIHN0cmluZyBvZiBjb21tYW5kcyBmb3IgU1ZHIHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHByb2dyZXNzTWV0ZXJTdmdQYXRoRGF0YShub3JtYWxpemVkUHJvZ3Jlc3MpIHtcbiAgICB2YXIgdGVybWluYWxSYWRpYW5zID0gMiAqIE1hdGguUEkgKiBub3JtYWxpemVkUHJvZ3Jlc3NcbiAgICB2YXIgbGFyZ2VBcmMgPSAobm9ybWFsaXplZFByb2dyZXNzID49IDAuNSkgPyAxIDogMDtcbiAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbih0ZXJtaW5hbFJhZGlhbnMpO1xuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKHRlcm1pbmFsUmFkaWFucyk7XG4gICAgdmFyIG91dGVyVGVybWluYWxYID0gT1VURVJfUkFEVVMgKiBjb3NBbmdsZTtcbiAgICB2YXIgb3V0ZXJUZXJtaW5hbFkgPSBPVVRFUl9SQURVUyAqIHNpbkFuZ2xlO1xuICAgIHZhciBpbm5lclRlcm1pbmFsWCA9IElOTkVSX1JBRElVUyAqIGNvc0FuZ2xlO1xuICAgIHZhciBpbm5lclRlcm1pbmFsWSA9IElOTkVSX1JBRElVUyAqIHNpbkFuZ2xlO1xuICAgIHJldHVybiBbXG4gICAgICBtb3ZlQ29tbWFuZChPVVRFUl9SQURVUywgMCksXG4gICAgICBhcmNDb21tYW5kKE9VVEVSX1JBRFVTLCBPVVRFUl9SQURVUywgMCwgbGFyZ2VBcmMsIDEsIG91dGVyVGVybWluYWxYLCBvdXRlclRlcm1pbmFsWSksXG4gICAgICBsaW5lQ29tbWFuZChpbm5lclRlcm1pbmFsWCwgaW5uZXJUZXJtaW5hbFkpLFxuICAgICAgYXJjQ29tbWFuZChJTk5FUl9SQURJVVMsIElOTkVSX1JBRElVUywgMCwgbGFyZ2VBcmMsIDAsIElOTkVSX1JBRElVUywgMCksXG4gICAgICBjbG9zZVNoYXBlQ29tbWFuZCgpXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJuZXRzaW0tbWV0cm9ub21lXCI+XFxuICA8c3ZnIHZlcnNpb249XCIxLjFcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cXG4gICAgPGcgaWQ9XCJjZW50ZXJlZC1ncm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg1MCw1MClcIj5cXG4gICAgICA8Y2lyY2xlIHI9XCI0OFwiIGN4PVwiMFwiIGN5PVwiMFwiIGZpbGw9XCJkYXJrZ3JheVwiPjwvY2lyY2xlPlxcbiAgICAgIDxjaXJjbGUgcj1cIjQ4XCIgY3g9XCItMVwiIGN5PVwiMVwiIGZpbGw9XCJsaWdodGdyYXlcIj48L2NpcmNsZT5cXG4gICAgICA8Y2lyY2xlIHI9XCI0NlwiIGN4PVwiMFwiIGN5PVwiMFwiIGZpbGw9XCIjZjVmNWY1XCI+PC9jaXJjbGU+XFxuICAgICAgPGNpcmNsZSBjbGFzcz1cInB1bHNlLWRvdFwiIHI9XCInLCBlc2NhcGUoKDgwLCAgcHVsc2VEb3RSYWRpdXMgKSksICdcIiBjeD1cIjBcIiBjeT1cIjBcIj48L2NpcmNsZT5cXG4gICAgICA8ZyB0cmFuc2Zvcm09XCJyb3RhdGUoLTkwKVwiPlxcbiAgICAgICAgPHBhdGggY2xhc3M9XCJwcm9ncmVzcy1tZXRlclwiIGQ9XCInLCBlc2NhcGUoKDgyLCAgcHJvZ3Jlc3NNZXRlclN2Z1BhdGhEYXRhKHByb2dyZXNzKSApKSwgJ1wiPjwvcGF0aD5cXG4gICAgICA8L2c+XFxuICAgIDwvZz5cXG4gIDwvc3ZnPlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIHNsaWRlciB1c2VkIHRvIGNvbnRyb2wgcm91dGVyIG1lbW9yeSBzaXplLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIE5ldFNpbVNsaWRlciA9IHJlcXVpcmUoJy4vTmV0U2ltU2xpZGVyJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBwYWNrZXQgc2l6ZSBzbGlkZXIvc2VsZWN0b3JcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzbGlkZXJDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gc2xpZGVyU3RvcENhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbU1lbW9yeUNvbnRyb2wgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LFxuICAgIHNsaWRlckNoYW5nZUNhbGxiYWNrLCBzbGlkZXJTdG9wQ2FsbGJhY2spIHtcbiAgTmV0U2ltU2xpZGVyLkxvZ2FyaXRobWljU2xpZGVyLmNhbGwodGhpcywgcm9vdERpdiwge1xuICAgIG9uQ2hhbmdlOiBzbGlkZXJDaGFuZ2VDYWxsYmFjayxcbiAgICBvblN0b3A6IHNsaWRlclN0b3BDYWxsYmFjayxcbiAgICB2YWx1ZTogSW5maW5pdHksXG4gICAgbWluOiBOZXRTaW1Db25zdGFudHMuQklUU19QRVJfQllURSxcbiAgICBtYXg6IE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9NRUdBQllURSxcbiAgICB1cHBlckJvdW5kSW5maW5pdGU6IHRydWVcbiAgfSk7XG5cbiAgLy8gQXV0by1yZW5kZXIsIHVubGlrZSBvdXIgYmFzZSBjbGFzc1xuICB0aGlzLnJlbmRlcigpO1xufTtcbk5ldFNpbU1lbW9yeUNvbnRyb2wuaW5oZXJpdHMoTmV0U2ltU2xpZGVyLkxvZ2FyaXRobWljU2xpZGVyKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWVyaWMgbWVtb3J5IHZhbHVlIChpbiBiaXRzKSBpbnRvIGEgY29tcGFjdCBsb2NhbGl6ZWQgc3RyaW5nXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIG51bWVyaWMgdmFsdWUgb2YgdGhlIGNvbnRyb2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICogQG92ZXJyaWRlXG4gKi9cbk5ldFNpbU1lbW9yeUNvbnRyb2wucHJvdG90eXBlLnZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIE5ldFNpbVV0aWxzLmJpdHNUb0xvY2FsaXplZFJvdW5kZWRCeXRlc2l6ZSh2YWwpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbXBvbmVudCwgYSBsb2cgcGFuZWwgKHVzZWQgYXMgXCJTZW50IFBhY2tldHNcIiBhbmRcbiAqICAgICAgICAgICBcIlJlY2VpdmVkIFBhY2tldHNcIikgdGhhdCBpcyB1c2VkIGluIHRoZSBwYWNrZXQtc2VuZGluZ1xuICogICAgICAgICAgIGNvbmZpZ3VyYXRpb25zIG9mIHRoZSBzaW11bGF0b3IuXG4gKlxuICogQHNlZSBJTmV0U2ltTG9nUGFuZWwgZm9yIHRoZSBpbnRlcmZhY2UgaW1wbGVtZW50ZWQgaGVyZS5cbiAqIEBzZWUgTmV0U2ltQml0TG9nUGFuZWwgZm9yIHRoZSBjb21wb25lbnQgdXNlZCBpbiBiaXQtc2VuZGluZyBtb2RlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbUxvZ1BhbmVsLmh0bWwuZWpzJyk7XG52YXIgUGFja2V0ID0gcmVxdWlyZSgnLi9QYWNrZXQnKTtcbnZhciBwYWNrZXRNYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbUxvZ1BhY2tldC5odG1sLmVqcycpO1xudmFyIE5ldFNpbVBhbmVsID0gcmVxdWlyZSgnLi9OZXRTaW1QYW5lbCcpO1xudmFyIE5ldFNpbUVuY29kaW5nQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltRW5jb2RpbmdDb250cm9sJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG4vKipcbiAqIEhvdyBsb25nIHRoZSBcImVudHJhbmNlXCIgYW5pbWF0aW9uIGZvciBuZXcgbWVzc2FnZXMgbGFzdHMsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIE1FU1NBR0VfU0xJREVfSU5fRFVSQVRJT05fTVMgPSA0MDA7XG5cbi8qKlxuICogSG93IG1hbnkgcGFja2V0cyB0aGUgbG9nIG1heSBrZWVwIGluIGl0cyBoaXN0b3J5IChhbmQgaW4gdGhlIERPTSEpXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbnZhciBERUZBVUxUX01BWElNVU1fTE9HX1BBQ0tFVFMgPSA1MDtcblxuLyoqXG4gKiBPYmplY3QgdGhhdCBjYW4gYmUgc2VudCBkYXRhIHRvIGJlIGJyb3dzZWQgYnkgdGhlIHVzZXIgYXQgdGhlaXIgZGlzY3JldGlvblxuICogQGludGVyZmFjZVxuICogQG5hbWUgSU5ldFNpbUxvZ1BhbmVsXG4gKi9cblxuLyoqXG4gKiBQdXQgZGF0YSBpbnRvIHRoZSBsb2dcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgSU5ldFNpbUxvZ1BhbmVsI2xvZ1xuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVxuICovXG5cbi8qKlxuICogU2hvdyBvciBoaWRlIHBhcnRzIG9mIHRoZSBsb2cgYmFzZWQgb24gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbmNvZGluZyBtb2RlLlxuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBJTmV0U2ltTG9nUGFuZWwjc2V0RW5jb2RpbmdzXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBuZXdFbmNvZGluZ3NcbiAqL1xuXG4vKipcbiAqIENoYW5nZSBob3cgYmluYXJ5IGlucHV0IGluIGludGVycHJldGVkIGFuZCBmb3JtYXR0ZWQgaW4gdGhlIGxvZy5cbiAqIEBmdW5jdGlvblxuICogQG5hbWUgSU5ldFNpbUxvZ1BhbmVsI3NldENodW5rU2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0NodW5rU2l6ZVxuICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBJTmV0U2ltTG9nUGFuZWwjZ2V0SGVpZ2h0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IHBhbmVsIGN1cnJlbnRseSBjb25zdW1lcyAoaW5jbHVkaW5nXG4gKiAgICAgICAgICBtYXJnaW5zKSBpbiBwaXhlbHMuXG4gKi9cblxuLyoqXG4gKiBTZXRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IHRoaXMgbG9nIHBhbmVsIHNob3VsZCBjb25zdW1lIChpbmNsdWRpbmcgbWFyZ2lucylcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgSU5ldFNpbUxvZ1BhbmVsI3NldEhlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFBpeGVsc1xuICovXG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBtZXNzYWdlIGxvZy5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9nVGl0bGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNNaW5pbWl6ZWRdIGRlZmF1bHRzIHRvIEZBTFNFXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhhc1VucmVhZE1lc3NhZ2VzXSBkZWZhdWx0cyB0byBGQUxTRVxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZVtdfSBvcHRpb25zLnBhY2tldFNwZWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhpbXVtTG9nUGFja2V0c10gSG93IG1hbnkgcGFja2V0cyB0aGUgbG9nIHdpbGxcbiAqICAgICAgICBrZWVwIGJlZm9yZSBpdCBzdGFydHMgZHJvcHBpbmcgdGhlIG9sZGVzdCBvbmVzLiAgRGVmYXVsdHMgdG9cbiAqICAgICAgICBERUZBVUxUX01BWElNVU1fTE9HX1BBQ0tFVFMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1QYW5lbFxuICogQGltcGxlbWVudHMgSU5ldFNpbUxvZ1BhbmVsXG4gKi9cbnZhciBOZXRTaW1Mb2dQYW5lbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtQYWNrZXQuSGVhZGVyVHlwZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wYWNrZXRTcGVjXyA9IG9wdGlvbnMucGFja2V0U3BlYztcblxuICAvKipcbiAgICogTGlzdCBvZiBjb250cm9sbGVycyBmb3IgY3VycmVudGx5IGRpc3BsYXllZCBwYWNrZXRzLlxuICAgKiBAdHlwZSB7QXJyYXkuPE5ldFNpbUxvZ1BhY2tldD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhY2tldHNfID0gW107XG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBlbmNvZGluZyAoZGlzcGxheSkgc2V0dGluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY3VycmVudEVuY29kaW5nc18gPSBbXTtcblxuICAvKipcbiAgICogQ3VycmVudCBjaHVuayBzaXplIChieXRlc2l6ZSkgZm9yIGludGVycHJldGluZyBiaW5hcnkgaW4gdGhlIGxvZy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY3VycmVudENodW5rU2l6ZV8gPSA4O1xuXG4gIC8qKlxuICAgKiBMb2NhbGl6ZWQgcGFuZWwgdGl0bGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubG9nVGl0bGVfID0gb3B0aW9ucy5sb2dUaXRsZTtcblxuICAvKipcbiAgICogV2hldGhlciBuZXdseSBsb2dnZWQgbWVzc2FnZXMgaW4gdGhpcyBsb2cgc2hvdWxkIGJlIG1hcmtlZCBhcyB1bnJlYWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmhhc1VucmVhZE1lc3NhZ2VzXyA9ICEhKG9wdGlvbnMuaGFzVW5yZWFkTWVzc2FnZXMpO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGFja2V0cyB0aGlzIGxvZyBwYW5lbCB3aWxsIGtlZXAgaW4gaXRzIG1lbW9yeVxuICAgKiBhbmQgaW4gdGhlIERPTSwgc28gd2UgZG9uJ3QgaGF2ZSBhIGZvcmV2ZXItZ3Jvd2luZyBsb2cuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlLCxcbiAgICovXG4gIHRoaXMubWF4aW11bUxvZ1BhY2tldHNfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLm1heGltdW1Mb2dQYWNrZXRzLFxuICAgICAgREVGQVVMVF9NQVhJTVVNX0xPR19QQUNLRVRTKTtcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICBOZXRTaW1QYW5lbC5jYWxsKHRoaXMsIHJvb3REaXYsIHtcbiAgICBjbGFzc05hbWU6ICduZXRzaW0tbG9nLXBhbmVsJyxcbiAgICBwYW5lbFRpdGxlOiBvcHRpb25zLmxvZ1RpdGxlLFxuICAgIGJlZ2luTWluaW1pemVkOiBvcHRpb25zLmlzTWluaW1pemVkXG4gIH0pO1xufTtcbk5ldFNpbUxvZ1BhbmVsLmluaGVyaXRzKE5ldFNpbVBhbmVsKTtcblxuTmV0U2ltTG9nUGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ3JlYXRlIGJvaWxlcnBsYXRlIHBhbmVsIG1hcmt1cFxuICBOZXRTaW1Mb2dQYW5lbC5zdXBlclByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICAvLyBBZGQgb3VyIG93biBjb250ZW50IG1hcmt1cFxuICB2YXIgbmV3TWFya3VwID0gJChtYXJrdXAoe30pKTtcbiAgdGhpcy5nZXRCb2R5KCkuaHRtbChuZXdNYXJrdXApO1xuXG4gIC8vIEFkZCBhIGNsZWFyIGJ1dHRvbiB0byB0aGUgcGFuZWwgaGVhZGVyXG4gIHRoaXMuYWRkQnV0dG9uKGkxOG4uY2xlYXIoKSwgdGhpcy5vbkNsZWFyQnV0dG9uUHJlc3NfLmJpbmQodGhpcykpO1xuXG4gIC8vIEJpbmQgcmVmZXJlbmNlIHRvIHNjcm9sbEFyZWEgZm9yIHVzZSB3aGVuIGxvZ2dpbmcuXG4gIHRoaXMuc2Nyb2xsQXJlYV8gPSB0aGlzLmdldEJvZHkoKS5maW5kKCcuc2Nyb2xsLWFyZWEnKTtcblxuICB0aGlzLnVwZGF0ZVVucmVhZENvdW50KCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgcGFja2V0cyBmcm9tIHRoZSBsb2csIHJlc2V0dGluZyBpdHMgc3RhdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2dQYW5lbC5wcm90b3R5cGUub25DbGVhckJ1dHRvblByZXNzXyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zY3JvbGxBcmVhXy5lbXB0eSgpO1xuICB0aGlzLnBhY2tldHNfLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy51cGRhdGVVbnJlYWRDb3VudCgpO1xufTtcblxuLyoqXG4gKiBQdXQgYSBtZXNzYWdlIGludG8gdGhlIGxvZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWNrZXRCaW5hcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWNrZXRJRFxuICovXG5OZXRTaW1Mb2dQYW5lbC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHBhY2tldEJpbmFyeSwgcGFja2V0SUQpIHtcblxuICB2YXIgcGFja2V0QWxyZWFkeUluTG9nID0gdGhpcy5wYWNrZXRzXy5zb21lKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICByZXR1cm4gcGFja2V0LnBhY2tldElEID09PSBwYWNrZXRJRDtcbiAgfSk7XG5cbiAgaWYgKHBhY2tldEFscmVhZHlJbkxvZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgcGFja2V0cyB0aGF0IGFyZSBiZXlvbmQgb3VyIG1heGltdW0gc2l6ZVxuICB0aGlzLnBhY2tldHNfXG4gICAgICAuc3BsaWNlKHRoaXMubWF4aW11bUxvZ1BhY2tldHNfIC0gMSwgdGhpcy5wYWNrZXRzXy5sZW5ndGgpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgIHBhY2tldC5nZXRSb290KCkucmVtb3ZlKCk7XG4gICAgICB9KTtcblxuICB2YXIgbmV3UGFja2V0ID0gbmV3IE5ldFNpbUxvZ1BhY2tldChwYWNrZXRCaW5hcnksIHBhY2tldElELCB7XG4gICAgcGFja2V0U3BlYzogdGhpcy5wYWNrZXRTcGVjXyxcbiAgICBlbmNvZGluZ3M6IHRoaXMuY3VycmVudEVuY29kaW5nc18sXG4gICAgY2h1bmtTaXplOiB0aGlzLmN1cnJlbnRDaHVua1NpemVfLFxuICAgIGlzVW5yZWFkOiB0aGlzLmhhc1VucmVhZE1lc3NhZ2VzXyxcbiAgICBtYXJrQXNSZWFkQ2FsbGJhY2s6IHRoaXMudXBkYXRlVW5yZWFkQ291bnQuYmluZCh0aGlzKVxuICB9KTtcblxuICBuZXdQYWNrZXQuZ2V0Um9vdCgpLnByZXBlbmRUbyh0aGlzLnNjcm9sbEFyZWFfKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxBcmVhXy5zY3JvbGxUb3AoKTtcblxuICBpZiAoc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgLy8gSWYgc2Nyb2xsZWQgdG8gdGhlIHRvcCwgYW5pbWF0ZSBhIHByZXR0eSBzbGlkZWRvd25cbiAgICBuZXdQYWNrZXQuZ2V0Um9vdCgpLmhpZGUoKTtcbiAgICBuZXdQYWNrZXQuZ2V0Um9vdCgpLnNsaWRlRG93bihNRVNTQUdFX1NMSURFX0lOX0RVUkFUSU9OX01TKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSdyZSBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbWVzc2FnZXMsIHNjcm9sbCBcImRvd25cIlxuICAgIC8vIHRvIG1haW50YWluIG91ciBwbGFjZSByZWxhdGl2ZSB0byB0aGUgbWVzc2FnZXMgd2UncmUgbG9va2luZyBhdFxuXG4gICAgLy8gU2Nyb2xsaW5nIG9ubHkgdGFrZXMgdGhlIGJvdHRvbSBtYXJnaW4gaW50byBhY2NvdW50LCBub3QgdG9wXG4gICAgdmFyIHBhY2tldEhlaWdodCA9IG5ld1BhY2tldC5nZXRSb290KCkub3V0ZXJIZWlnaHQoKSArXG4gICAgICAgIHBhcnNlSW50KG5ld1BhY2tldC5nZXRSb290KCkuY3NzKCdtYXJnaW5Cb3R0b20nKSk7XG5cbiAgICB0aGlzLnNjcm9sbEFyZWFfLnNjcm9sbFRvcChzY3JvbGxUb3AgKyBwYWNrZXRIZWlnaHQpO1xuICB9XG5cbiAgdGhpcy5wYWNrZXRzXy51bnNoaWZ0KG5ld1BhY2tldCk7XG5cbiAgdGhpcy51cGRhdGVVbnJlYWRDb3VudCgpO1xufTtcblxuTmV0U2ltTG9nUGFuZWwucHJvdG90eXBlLnVwZGF0ZVVucmVhZENvdW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdW5yZWFkQ291bnQgPSB0aGlzLnBhY2tldHNfLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyAoY3VyLmlzVW5yZWFkID8gMSA6IDApO1xuICB9LCAwKTtcblxuICBpZiAodW5yZWFkQ291bnQgPiAwKSB7XG4gICAgdGhpcy5zZXRQYW5lbFRpdGxlKGkxOG4uYXBwZW5kQ291bnRUb1RpdGxlKHtcbiAgICAgIHRpdGxlOiB0aGlzLmxvZ1RpdGxlXyxcbiAgICAgIGNvdW50OiB1bnJlYWRDb3VudFxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldFBhbmVsVGl0bGUodGhpcy5sb2dUaXRsZV8pO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgb3IgaGlkZSBwYXJ0cyBvZiB0aGUgc2VuZCBVSSBiYXNlZCBvbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVuY29kaW5nXG4gKiBtb2RlLlxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gbmV3RW5jb2RpbmdzXG4gKi9cbk5ldFNpbUxvZ1BhbmVsLnByb3RvdHlwZS5zZXRFbmNvZGluZ3MgPSBmdW5jdGlvbiAobmV3RW5jb2RpbmdzKSB7XG4gIHRoaXMuY3VycmVudEVuY29kaW5nc18gPSBuZXdFbmNvZGluZ3M7XG4gIHRoaXMucGFja2V0c18uZm9yRWFjaChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgcGFja2V0LnNldEVuY29kaW5ncyhuZXdFbmNvZGluZ3MpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIGhvdyBiaW5hcnkgaW5wdXQgaW4gaW50ZXJwcmV0ZWQgYW5kIGZvcm1hdHRlZCBpbiB0aGUgbG9nLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld0NodW5rU2l6ZVxuICovXG5OZXRTaW1Mb2dQYW5lbC5wcm90b3R5cGUuc2V0Q2h1bmtTaXplID0gZnVuY3Rpb24gKG5ld0NodW5rU2l6ZSkge1xuICB0aGlzLmN1cnJlbnRDaHVua1NpemVfID0gbmV3Q2h1bmtTaXplO1xuICB0aGlzLnBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHBhY2tldC5zZXRDaHVua1NpemUobmV3Q2h1bmtTaXplKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEEgY29tcG9uZW50L2NvbnRyb2xsZXIgZm9yIGRpc3BsYXkgb2YgYW4gaW5kaXZpZHVhbCBwYWNrZXQgaW4gdGhlIGxvZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWNrZXRCaW5hcnkgLSByYXcgcGFja2V0IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlW119IG9wdGlvbnMucGFja2V0U3BlY1xuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gb3B0aW9ucy5lbmNvZGluZ3MgLSB3aGljaCBkaXNwbGF5IHN0eWxlIHRvIHVzZSBpbml0aWFsbHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNodW5rU2l6ZSAtIChvciBieXRlc2l6ZSkgdG8gdXNlIHdoZW4gaW50ZXJwcmV0aW5nIGFuZFxuICogICAgICAgIGZvcm1hdHRpbmcgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaXNVbnJlYWQgLSB3aGV0aGVyIHRoaXMgcGFja2V0IHNob3VsZCBiZSBzdHlsZWRcbiAqICAgICAgICBhcyBcInVucmVhZFwiIGFuZCBoYXZlIGEgXCJtYXJrIGFzIHJlYWRcIiBidXR0b25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMubWFya0FzUmVhZENhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbUxvZ1BhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXRCaW5hcnksIHBhY2tldElELCBvcHRpb25zKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnBhY2tldElEID0gcGFja2V0SUQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhY2tldEJpbmFyeV8gPSBwYWNrZXRCaW5hcnk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtQYWNrZXQuSGVhZGVyVHlwZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wYWNrZXRTcGVjXyA9IG9wdGlvbnMucGFja2V0U3BlYztcblxuICAvKipcbiAgICogQHR5cGUge0VuY29kaW5nVHlwZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lbmNvZGluZ3NfID0gb3B0aW9ucy5lbmNvZGluZ3M7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNodW5rU2l6ZV8gPSBvcHRpb25zLmNodW5rU2l6ZTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzVW5yZWFkID0gb3B0aW9ucy5pc1VucmVhZDtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzTWluaW1pemVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubWFya0FzUmVhZENhbGxiYWNrXyA9IG9wdGlvbnMubWFya0FzUmVhZENhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBXcmFwcGVyIGRpdiB0aGF0IHdlIGNyZWF0ZSBvbmNlLCBhbmQgZmlsbCByZXBlYXRlZGx5IHdpdGggcmVuZGVyKClcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdERpdl8gPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdwYWNrZXQnKTtcbiAgdGhpcy5yb290RGl2Xy5jbGljayh0aGlzLm1hcmtBc1JlYWQuYmluZCh0aGlzKSk7XG5cbiAgLy8gSW5pdGlhbCBjb250ZW50IHBvcHVsYXRpb25cbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogUmUtcmVuZGVyIGRpdiBjb250ZW50cyB0byByZXByZXNlbnQgdGhlIHBhY2tldCBpbiBhIGRpZmZlcmVudCB3YXkuXG4gKi9cbk5ldFNpbUxvZ1BhY2tldC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW5jb2RpbmdzSGFzaCA9IE5ldFNpbUVuY29kaW5nQ29udHJvbC5lbmNvZGluZ3NBc0hhc2godGhpcy5lbmNvZGluZ3NfKTtcbiAgdmFyIHJhd01hcmt1cCA9IHBhY2tldE1hcmt1cCh7XG4gICAgcGFja2V0QmluYXJ5OiB0aGlzLnBhY2tldEJpbmFyeV8sXG4gICAgcGFja2V0U3BlYzogdGhpcy5wYWNrZXRTcGVjXyxcbiAgICBlbmFibGVkRW5jb2RpbmdzSGFzaDogZW5jb2RpbmdzSGFzaCxcbiAgICBjaHVua1NpemU6IHRoaXMuY2h1bmtTaXplXyxcbiAgICBpc01pbmltaXplZDogdGhpcy5pc01pbmltaXplZFxuICB9KTtcbiAgdmFyIGpRdWVyeVdyYXAgPSAkKHJhd01hcmt1cCk7XG4gIE5ldFNpbUxvZ1BhbmVsLmFkanVzdEhlYWRlckNvbHVtbldpZHRocyhqUXVlcnlXcmFwKTtcbiAgTmV0U2ltRW5jb2RpbmdDb250cm9sLmhpZGVSb3dzQnlFbmNvZGluZyhqUXVlcnlXcmFwLCB0aGlzLmVuY29kaW5nc18pO1xuICB0aGlzLnJvb3REaXZfLmh0bWwoalF1ZXJ5V3JhcCk7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLmV4cGFuZGVyJykuY2xpY2sodGhpcy50b2dnbGVNaW5pbWl6ZWQuYmluZCh0aGlzKSk7XG4gIHRoaXMucm9vdERpdl8udG9nZ2xlQ2xhc3MoJ3VucmVhZCcsIHRoaXMuaXNVbnJlYWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gcm9vdCBkaXYsIGZvciBob29raW5nIHVwIHRvIGEgcGFyZW50IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7alF1ZXJ5fVxuICovXG5OZXRTaW1Mb2dQYWNrZXQucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3REaXZfO1xufTtcblxuLyoqXG4gKiBCZW5lYXRoIHRoZSBnaXZlbiByb290IGVsZW1lbnQsIGFkanVzdCB3aWR0aHMgb2YgcGFja2V0IGhlYWRlciBjb2x1bW5zXG4gKiBhbmQgZmllbGRzIHRvIG1hdGNoIHRoZSBsZXZlbCdzIGNvbmZpZ3VyZWQgcGFja2V0IGZvcm1hdC5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RWxlbWVudFxuICovXG5OZXRTaW1Mb2dQYW5lbC5hZGp1c3RIZWFkZXJDb2x1bW5XaWR0aHMgPSBmdW5jdGlvbiAocm9vdEVsZW1lbnQpIHtcbiAgdmFyIGxldmVsID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuICB2YXIgZW5jb2RlciA9IG5ldyBQYWNrZXQuRW5jb2RlcihcbiAgICAgIGxldmVsLmFkZHJlc3NGb3JtYXQsXG4gICAgICBsZXZlbC5wYWNrZXRDb3VudEJpdFdpZHRoLFxuICAgICAgbGV2ZWwuY2xpZW50SW5pdGlhbFBhY2tldEhlYWRlcik7XG4gIHZhciBhZGRyZXNzQml0V2lkdGggPSBlbmNvZGVyLmdldEZpZWxkQml0V2lkdGgoXG4gICAgICBQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTKTtcbiAgdmFyIHBhY2tldEluZm9CaXRXaWR0aCA9IGVuY29kZXIuZ2V0RmllbGRCaXRXaWR0aChcbiAgICAgIFBhY2tldC5IZWFkZXJUeXBlLlBBQ0tFVF9DT1VOVCk7XG5cbiAgLy8gQWRqdXN0IHdpZHRoIG9mIGFkZHJlc3MgY29sdW1uc1xuICAvLyBGb3IgY29sdW1ucywgNTBweCBpcyBzdWZmaWNpZW50IGZvciA0IGJpdHNcbiAgdmFyIFBYX1BFUl9CSVQgPSA1MCAvIDQ7XG4gIHZhciBhZGRyZXNzQ29sdW1uV2lkdGhJblB4ID0gUFhfUEVSX0JJVCAqIGFkZHJlc3NCaXRXaWR0aDtcblxuICAvLyBBZGp1c3Qgd2lkdGggb2YgYWRkcmVzcyBjb2x1bW5zXG4gIHJvb3RFbGVtZW50LmZpbmQoJ3RkLnRvQWRkcmVzcywgdGgudG9BZGRyZXNzLCB0ZC5mcm9tQWRkcmVzcywgdGguZnJvbUFkZHJlc3MnKVxuICAgICAgLmNzcygnd2lkdGgnLCBhZGRyZXNzQ29sdW1uV2lkdGhJblB4ICsgJ3B4Jyk7XG5cblxuICAvLyBBZGp1c3Qgd2lkdGggb2YgYWRkcmVzcyBpbnB1dCBmaWVsZHNcbiAgLy8gRm9yIGlucHV0cywgM2VtIGlzIHN1ZmZpY2llbnQgZm9yIDQgYml0c1xuICB2YXIgRU1TX1BFUl9CSVQgPSAzIC8gNDtcbiAgdmFyIGFkZHJlc3NGaWVsZFdpZHRoSW5FbXMgPSBFTVNfUEVSX0JJVCAqIGFkZHJlc3NCaXRXaWR0aDtcbiAgcm9vdEVsZW1lbnQuZmluZCgndGQudG9BZGRyZXNzIGlucHV0LCB0ZC5mcm9tQWRkcmVzcyBpbnB1dCcpXG4gICAgICAuY3NzKCd3aWR0aCcsIGFkZHJlc3NGaWVsZFdpZHRoSW5FbXMgKyAnZW0nKTtcblxuXG4gIC8vIEFkanVzdCB3aWR0aCBvZiBwYWNrZXQgaW5mbyBjb2x1bW5cbiAgLy8gUGFja2V0IGluZm8gY29sdW1uIHVzZXMgdHdvIGZpZWxkcyBhbmQgYW4gZXh0cmEgMjFweCBmb3IgXCIgb2YgXCJcbiAgdmFyIHBhY2tldEluZm9Db2x1bW5XaWR0aEluUHggPSAoMiAqIFBYX1BFUl9CSVQgKiBwYWNrZXRJbmZvQml0V2lkdGgpICsgMjE7XG4gIHJvb3RFbGVtZW50LmZpbmQoJ3RkLnBhY2tldEluZm8sIHRoLnBhY2tldEluZm8nKVxuICAgICAgLmNzcygnd2lkdGgnLCBwYWNrZXRJbmZvQ29sdW1uV2lkdGhJblB4ICsgJ3B4Jyk7XG5cbiAgLy8gQWRqdXN0IHdpZHRoIG9mIHBhY2tldCBpbmZvIGZpZWxkc1xuICB2YXIgcGFja2V0SW5mb0ZpZWxkV2lkdGhJbkVtcyA9IEVNU19QRVJfQklUICogcGFja2V0SW5mb0JpdFdpZHRoO1xuICByb290RWxlbWVudC5maW5kKCd0ZC5wYWNrZXRJbmZvIGlucHV0JylcbiAgICAgIC5jc3MoJ3dpZHRoJywgcGFja2V0SW5mb0ZpZWxkV2lkdGhJbkVtcyArICdlbScpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgZW5jb2RpbmctZGlzcGxheSBzZXR0aW5nIGFuZCByZS1yZW5kZXIgcGFja2V0IGNvbnRlbnRzIGFjY29yZGluZ2x5LlxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGVbXX0gbmV3RW5jb2RpbmdzXG4gKi9cbk5ldFNpbUxvZ1BhY2tldC5wcm90b3R5cGUuc2V0RW5jb2RpbmdzID0gZnVuY3Rpb24gKG5ld0VuY29kaW5ncykge1xuICB0aGlzLmVuY29kaW5nc18gPSBuZXdFbmNvZGluZ3M7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBjaHVuayBzaXplIGZvciBpbnRlcnByZXRpbmcgZGF0YSBhbmQgcmUtcmVuZGVyIHBhY2tldCBjb250ZW50c1xuICogYWNjb3JkaW5nbHkuXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3Q2h1bmtTaXplXG4gKi9cbk5ldFNpbUxvZ1BhY2tldC5wcm90b3R5cGUuc2V0Q2h1bmtTaXplID0gZnVuY3Rpb24gKG5ld0NodW5rU2l6ZSkge1xuICB0aGlzLmNodW5rU2l6ZV8gPSBuZXdDaHVua1NpemU7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIE1hcmsgdGhlIHBhY2tldCBhcyByZWFkLCBjaGFuZ2luZyBpdHMgc3R5bGUgYW5kIHJlbW92aW5nIHRoZSBcIm1hcmsgYXMgcmVhZFwiXG4gKiBidXR0b24uXG4gKi9cbk5ldFNpbUxvZ1BhY2tldC5wcm90b3R5cGUubWFya0FzUmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaXNVbnJlYWQpIHtcbiAgICB0aGlzLmlzVW5yZWFkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLm1hcmtBc1JlYWRDYWxsYmFja18oKTtcbiAgfVxufTtcblxuTmV0U2ltTG9nUGFja2V0LnByb3RvdHlwZS50b2dnbGVNaW5pbWl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNNaW5pbWl6ZWQgPSAhdGhpcy5pc01pbmltaXplZDtcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCB0aGlzIGxvZyBwYW5lbCBzaG91bGQgY29uc3VtZSAoaW5jbHVkaW5nIG1hcmdpbnMpXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0UGl4ZWxzXG4gKi9cbk5ldFNpbUxvZ1BhbmVsLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0UGl4ZWxzKSB7XG4gIHZhciByb290ID0gdGhpcy5nZXRSb290KCkuZmluZCgnLm5ldHNpbS1wYW5lbCcpO1xuICB2YXIgcGFuZWxIZWFkZXIgPSByb290LmZpbmQoJ2gxJyk7XG4gIHZhciBwYW5lbEJvZHkgPSByb290LmZpbmQoJy5wYW5lbC1ib2R5Jyk7XG5cbiAgdmFyIHBhbmVsTWFyZ2lucyA9IHBhcnNlRmxvYXQocm9vdC5jc3MoJ21hcmdpbi10b3AnKSkgK1xuICAgICAgcGFyc2VGbG9hdChyb290LmNzcygnbWFyZ2luLWJvdHRvbScpKTtcbiAgdmFyIGhlYWRlckhlaWdodCA9IHBhbmVsSGVhZGVyLm91dGVySGVpZ2h0KHRydWUpO1xuICB2YXIgcGFuZWxCb3JkZXJzID0gcGFyc2VGbG9hdChwYW5lbEJvZHkuY3NzKCdib3JkZXItdG9wLXdpZHRoJykpICtcbiAgICAgIHBhcnNlRmxvYXQocGFuZWxCb2R5LmNzcygnYm9yZGVyLWJvdHRvbS13aWR0aCcpKTtcbiAgdmFyIHNjcm9sbE1hcmdpbnMgPSBwYXJzZUZsb2F0KHRoaXMuc2Nyb2xsQXJlYV8uY3NzKCdtYXJnaW4tdG9wJykpICtcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5zY3JvbGxBcmVhXy5jc3MoJ21hcmdpbi1ib3R0b20nKSk7XG5cbiAgLy8gV2Ugc2V0IHRoZSBwYW5lbCBoZWlnaHQgYnkgZml4aW5nIHRoZSBzaXplIG9mIGl0cyBpbm5lciBzY3JvbGxhYmxlXG4gIC8vIGFyZWEuXG4gIHZhciBuZXdTY3JvbGxWaWV3cG9ydEhlaWdodCA9IGhlaWdodFBpeGVscyAtIChwYW5lbE1hcmdpbnMgKyBoZWFkZXJIZWlnaHQgK1xuICAgICAgcGFuZWxCb3JkZXJzICsgc2Nyb2xsTWFyZ2lucyk7XG4gIHRoaXMuc2Nyb2xsQXJlYV8uaGVpZ2h0KE1hdGguZmxvb3IobmV3U2Nyb2xsVmlld3BvcnRIZWlnaHQpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gdmVydGljYWwgc3BhY2UgdGhhdCBwYW5lbCBjdXJyZW50bHkgY29uc3VtZXMgKGluY2x1ZGluZ1xuICogICAgICAgICAgbWFyZ2lucykgaW4gcGl4ZWxzLlxuICovXG5OZXRTaW1Mb2dQYW5lbC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRSb290KCkuZmluZCgnLm5ldHNpbS1wYW5lbCcpLm91dGVySGVpZ2h0KHRydWUpO1xufTtcblxuLyoqXG4gKiBBZnRlciB0b2dnbGluZyBwYW5lbCB2aXNpYmlsaXR5LCB0cmlnZ2VyIGEgbGF5b3V0IHVwZGF0ZSBzbyBzZW5kL2xvZyBwYW5lbFxuICogc3BhY2UgaXMgc2hhcmVkIGNvcnJlY3RseS5cbiAqIEBwcml2YXRlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltTG9nUGFuZWwucHJvdG90eXBlLm9uTWluaW1pemVyQ2xpY2tfID0gZnVuY3Rpb24gKCkge1xuICBOZXRTaW1Mb2dQYW5lbC5zdXBlclByb3RvdHlwZS5vbk1pbmltaXplckNsaWNrXy5jYWxsKHRoaXMpO1xuICBOZXRTaW1HbG9iYWxzLnVwZGF0ZUxheW91dCgpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBjbGFzcz1cInNjcm9sbC1hcmVhXCI+XFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xuICB2YXIgTmV0U2ltQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9OZXRTaW1Db25zdGFudHMnKTtcbiAgdmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcbiAgdmFyIERhdGFDb252ZXJ0ZXJzID0gcmVxdWlyZSgnLi9EYXRhQ29udmVydGVycycpO1xuICB2YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG4gIHZhciBnZXRFbmNvZGluZ0xhYmVsID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpLmdldEVuY29kaW5nTGFiZWw7XG4gIHZhciBQYWNrZXQgPSByZXF1aXJlKCcuL1BhY2tldCcpO1xuXG4gIHZhciBsZXZlbCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcblxuICB2YXIgRW5jb2RpbmdUeXBlID0gTmV0U2ltQ29uc3RhbnRzLkVuY29kaW5nVHlwZTtcbiAgdmFyIFBhY2tldFVJQ29sdW1uVHlwZSA9IE5ldFNpbUNvbnN0YW50cy5QYWNrZXRVSUNvbHVtblR5cGU7XG5cbiAgdmFyIGZvcm1hdEFCID0gRGF0YUNvbnZlcnRlcnMuZm9ybWF0QUI7XG4gIHZhciBmb3JtYXRCaW5hcnkgPSBEYXRhQ29udmVydGVycy5mb3JtYXRCaW5hcnk7XG4gIHZhciBmb3JtYXRIZXggPSBEYXRhQ29udmVydGVycy5mb3JtYXRIZXg7XG4gIHZhciBhbGlnbkRlY2ltYWwgPSBEYXRhQ29udmVydGVycy5hbGlnbkRlY2ltYWw7XG4gIHZhciBiaW5hcnlUb0FCID0gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9BQjtcbiAgdmFyIGJpbmFyeVRvSW50ID0gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9JbnQ7XG4gIHZhciBiaW5hcnlUb0hleCA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvSGV4O1xuICB2YXIgYmluYXJ5VG9EZWNpbWFsID0gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9EZWNpbWFsO1xuICB2YXIgYmluYXJ5VG9Bc2NpaSA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQXNjaWk7XG4gIHZhciBiaW5hcnlUb0FkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nKSB7XG4gICAgcmV0dXJuIERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQWRkcmVzc1N0cmluZyhiaW5hcnlTdHJpbmcsIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xuICB9O1xuICB2YXIgZm9ybWF0QmluYXJ5Rm9yQWRkcmVzc0hlYWRlciA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcpIHtcbiAgICByZXR1cm4gRGF0YUNvbnZlcnRlcnMuZm9ybWF0QmluYXJ5Rm9yQWRkcmVzc0hlYWRlcihiaW5hcnlTdHJpbmcsIGxldmVsLmFkZHJlc3NGb3JtYXQpO1xuICB9O1xuXG4gIC8qKiBAdHlwZSB7UGFja2V0fSAqL1xuICB2YXIgcGFja2V0ID0gbmV3IFBhY2tldChwYWNrZXRTcGVjLCBwYWNrZXRCaW5hcnkpO1xuXG4gIC8qKiBAdHlwZSB7UGFja2V0LkhlYWRlclR5cGVbXX0gKi9cbiAgdmFyIGhlYWRlckZpZWxkcyA9IHBhY2tldFNwZWM7XG5cbiAgdmFyIHNob3dUb0FkZHJlc3MgPSBoZWFkZXJGaWVsZHMuaW5kZXhPZihQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTKSA+IC0xO1xuICB2YXIgc2hvd0Zyb21BZGRyZXNzID0gaGVhZGVyRmllbGRzLmluZGV4T2YoUGFja2V0LkhlYWRlclR5cGUuRlJPTV9BRERSRVNTKSA+IC0xO1xuICB2YXIgc2hvd1BhY2tldEluZm8gPSBoZWFkZXJGaWVsZHMuaW5kZXhPZihQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpID4gLTEgJiZcbiAgICAgIGhlYWRlckZpZWxkcy5pbmRleE9mKFBhY2tldC5IZWFkZXJUeXBlLlBBQ0tFVF9DT1VOVCkgPiAtMTtcblxuICAvKipcbiAgKiBAbmFtZSBlbmFibGVkRW5jb2RpbmdzSGFzaFxuICAqIEB0eXBlIHtPYmplY3R9XG4gICovXG5cbiAgZnVuY3Rpb24gaXNFbmNvZGluZ0VuYWJsZWQocXVlcnlFbmNvZGluZykge1xuICAgIHJldHVybiBlbmFibGVkRW5jb2RpbmdzSGFzaFtxdWVyeUVuY29kaW5nXSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZXQgb25lLWxpbmUgc3VtbWFyeSBzaG91bGQgb25seSB1c2UgdGhlIGhpZ2hlc3QtbGV2ZWwgZW5hYmxlZCBlbmNvZGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9uZUxpbmVQYWNrZXRTdW1tYXJ5KCkge1xuICAgIHZhciBtZXNzYWdlQmluYXJ5ID0gcGFja2V0LmdldEJvZHlBc0JpbmFyeSgpO1xuICAgIGlmIChpc0VuY29kaW5nRW5hYmxlZChFbmNvZGluZ1R5cGUuQVNDSUkpKSB7XG4gICAgICByZXR1cm4gYmluYXJ5VG9Bc2NpaShtZXNzYWdlQmluYXJ5LCBjaHVua1NpemUpO1xuICAgIH0gZWxzZSBpZiAoaXNFbmNvZGluZ0VuYWJsZWQoRW5jb2RpbmdUeXBlLkRFQ0lNQUwpKSB7XG4gICAgICByZXR1cm4gYWxpZ25EZWNpbWFsKGJpbmFyeVRvRGVjaW1hbChtZXNzYWdlQmluYXJ5LCBjaHVua1NpemUpKTtcbiAgICB9IGVsc2UgaWYgKGlzRW5jb2RpbmdFbmFibGVkKEVuY29kaW5nVHlwZS5IRVhBREVDSU1BTCkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRIZXgoYmluYXJ5VG9IZXgobWVzc2FnZUJpbmFyeSksIGNodW5rU2l6ZSk7XG4gICAgfSBlbHNlIGlmIChpc0VuY29kaW5nRW5hYmxlZChFbmNvZGluZ1R5cGUuQklOQVJZKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEJpbmFyeShtZXNzYWdlQmluYXJ5LCBjaHVua1NpemUpO1xuICAgIH0gZWxzZSBpZiAoaXNFbmNvZGluZ0VuYWJsZWQoRW5jb2RpbmdUeXBlLkFfQU5EX0IpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0QUIoYmluYXJ5VG9BQihtZXNzYWdlQmluYXJ5KSwgY2h1bmtTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VCaW5hcnk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbmNvZGluZ1R5cGV9IGVuY29kaW5nVHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9BZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tQWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFja2V0SW5mb1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKi9cbiAgZnVuY3Rpb24gbG9nUm93SWZFbmNvZGluZ0VuYWJsZWQoZW5jb2RpbmdUeXBlLCB0b0FkZHJlc3MsIGZyb21BZGRyZXNzLCBwYWNrZXRJbmZvLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzRW5jb2RpbmdFbmFibGVkKGVuY29kaW5nVHlwZSkpIHtcbiAgICAgIDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPHRyIGNsYXNzPVwiJywgZXNjYXBlKCg3OSwgIGVuY29kaW5nVHlwZSApKSwgJ1wiPlxcbiAgICAgICAgICA8dGggbm93cmFwIGNsYXNzPVwiJywgZXNjYXBlKCg4MCwgIFBhY2tldFVJQ29sdW1uVHlwZS5FTkNPRElOR19MQUJFTCApKSwgJ1wiPicsIGVzY2FwZSgoODAsICBnZXRFbmNvZGluZ0xhYmVsKGVuY29kaW5nVHlwZSkgKSksICc8L3RoPlxcbiAgICAgICAgICAnKTs4MTsgaWYgKHNob3dUb0FkZHJlc3MpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgPHRkIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoODIsICBQYWNrZXRVSUNvbHVtblR5cGUuVE9fQUREUkVTUyApKSwgJ1wiPicsIGVzY2FwZSgoODIsICB0b0FkZHJlc3MgKSksICc8L3RkPlxcbiAgICAgICAgICAnKTs4MzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgJyk7ODQ7IGlmIChzaG93RnJvbUFkZHJlc3MpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgPHRkIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoODUsICBQYWNrZXRVSUNvbHVtblR5cGUuRlJPTV9BRERSRVNTICkpLCAnXCI+JywgZXNjYXBlKCg4NSwgIGZyb21BZGRyZXNzICkpLCAnPC90ZD5cXG4gICAgICAgICAgJyk7ODY7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICAgICcpOzg3OyBpZiAoc2hvd1BhY2tldEluZm8pIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgPHRkIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoODgsICBQYWNrZXRVSUNvbHVtblR5cGUuUEFDS0VUX0lORk8gKSksICdcIj4nLCBlc2NhcGUoKDg4LCAgcGFja2V0SW5mbyApKSwgJzwvdGQ+XFxuICAgICAgICAgICcpOzg5OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICA8dGQgY2xhc3M9XCInLCBlc2NhcGUoKDkwLCAgUGFja2V0VUlDb2x1bW5UeXBlLk1FU1NBR0UgKSksICdcIj4nLCBlc2NhcGUoKDkwLCAgbWVzc2FnZSApKSwgJzwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICAnKTs5MjtcbiAgICB9XG4gIH1cbiA7IGJ1Zi5wdXNoKCdcXG4gICcpOzk2O1xuICAgIHZhciB0b0FkZHJlc3MgPSBzaG93VG9BZGRyZXNzID8gcGFja2V0LmdldEhlYWRlckFzQmluYXJ5KFBhY2tldC5IZWFkZXJUeXBlLlRPX0FERFJFU1MpIDogJyc7XG4gICAgdmFyIGZyb21BZGRyZXNzID0gc2hvd0Zyb21BZGRyZXNzID8gcGFja2V0LmdldEhlYWRlckFzQmluYXJ5KFBhY2tldC5IZWFkZXJUeXBlLkZST01fQUREUkVTUykgOiAnJztcbiAgICB2YXIgcGFja2V0SW5kZXggPSBzaG93UGFja2V0SW5mbyA/IHBhY2tldC5nZXRIZWFkZXJBc0JpbmFyeShQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpIDogJyc7XG4gICAgdmFyIHBhY2tldENvdW50ID0gc2hvd1BhY2tldEluZm8gPyBwYWNrZXQuZ2V0SGVhZGVyQXNCaW5hcnkoUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0NPVU5UKSA6ICcnO1xuICAgIHZhciBtZXNzYWdlID0gcGFja2V0LmdldEJvZHlBc0JpbmFyeSgpO1xuICA7IGJ1Zi5wdXNoKCdcXG4gICcpOzEwMzsgaWYgKGlzTWluaW1pemVkKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxkaXYgY2xhc3M9XCJtaW5pbWl6ZWQtcGFja2V0IHNpbmdsZS1saW5lLXdpdGgtZWxsaXBzaXMgdXNlci1kYXRhXCI+XFxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXBsdXMtc3F1YXJlIGV4cGFuZGVyXCI+PC9pPlxcbiAgICAgICAgJywgZXNjYXBlKCgxMDYsICBnZXRPbmVMaW5lUGFja2V0U3VtbWFyeSgpICkpLCAnXFxuICAgICAgPC9kaXY+XFxuICAnKTsxMDg7IH0gZWxzZSB7IDsgYnVmLnB1c2goJ1xcbiAgICA8dGFibGUgY2xhc3M9XCJtYXhpbWl6ZWQtcGFja2V0XCI+XFxuICAgICAgPHRoZWFkPlxcbiAgICAgICAgPHRyPlxcbiAgICAgICAgICA8dGggbm93cmFwIGNsYXNzPVwiJywgZXNjYXBlKCgxMTIsICBQYWNrZXRVSUNvbHVtblR5cGUuRU5DT0RJTkdfTEFCRUwgKSksICdcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLW1pbnVzLXNxdWFyZSBleHBhbmRlclwiPjwvaT5cXG4gICAgICAgICAgPC90aD5cXG4gICAgICAgICAgJyk7MTE1OyBpZiAoc2hvd1RvQWRkcmVzcykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgICA8dGggbm93cmFwIGNsYXNzPVwiJywgZXNjYXBlKCgxMTYsICBQYWNrZXRVSUNvbHVtblR5cGUuVE9fQUREUkVTUyApKSwgJ1wiPicsIGVzY2FwZSgoMTE2LCAgaTE4bi50bygpICkpLCAnPC90aD5cXG4gICAgICAgICAgJyk7MTE3OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICAnKTsxMTg7IGlmIChzaG93RnJvbUFkZHJlc3MpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgPHRoIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoMTE5LCAgUGFja2V0VUlDb2x1bW5UeXBlLkZST01fQUREUkVTUyApKSwgJ1wiPicsIGVzY2FwZSgoMTE5LCAgaTE4bi5mcm9tKCkgKSksICc8L3RoPlxcbiAgICAgICAgICAnKTsxMjA7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICAgICcpOzEyMTsgaWYgKHNob3dQYWNrZXRJbmZvKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgICAgIDx0aCBub3dyYXAgY2xhc3M9XCInLCBlc2NhcGUoKDEyMiwgIFBhY2tldFVJQ29sdW1uVHlwZS5QQUNLRVRfSU5GTyApKSwgJ1wiPicsIGVzY2FwZSgoMTIyLCAgaTE4bi5wYWNrZXQoKSApKSwgJzwvdGg+XFxuICAgICAgICAgICcpOzEyMzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgPHRoIGNsYXNzPVwiJywgZXNjYXBlKCgxMjQsICBQYWNrZXRVSUNvbHVtblR5cGUuTUVTU0FHRSApKSwgJ1wiPlxcbiAgICAgICAgICAgICcsIGVzY2FwZSgoMTI1LCAgaTE4bi5tZXNzYWdlKCkgKSksICdcXG4gICAgICAgICAgPC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPC90aGVhZD5cXG4gICAgICA8dGJvZHk+XFxuICAgICAgJyk7MTMwO1xuICAgICAgICBsb2dSb3dJZkVuY29kaW5nRW5hYmxlZChFbmNvZGluZ1R5cGUuQVNDSUksXG4gICAgICAgICAgICBiaW5hcnlUb0FkZHJlc3NTdHJpbmcodG9BZGRyZXNzKSxcbiAgICAgICAgICAgIGJpbmFyeVRvQWRkcmVzc1N0cmluZyhmcm9tQWRkcmVzcyksXG4gICAgICAgICAgICBpMThuLnhPZllQYWNrZXRzKHtcbiAgICAgICAgICAgICAgeDogYmluYXJ5VG9JbnQocGFja2V0SW5kZXgpLFxuICAgICAgICAgICAgICB5OiBiaW5hcnlUb0ludChwYWNrZXRDb3VudClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmluYXJ5VG9Bc2NpaShtZXNzYWdlLCBjaHVua1NpemUpKTtcblxuICAgICAgICBsb2dSb3dJZkVuY29kaW5nRW5hYmxlZChFbmNvZGluZ1R5cGUuREVDSU1BTCxcbiAgICAgICAgICAgIGJpbmFyeVRvQWRkcmVzc1N0cmluZyh0b0FkZHJlc3MpLFxuICAgICAgICAgICAgYmluYXJ5VG9BZGRyZXNzU3RyaW5nKGZyb21BZGRyZXNzKSxcbiAgICAgICAgICAgIGkxOG4ueE9mWVBhY2tldHMoe1xuICAgICAgICAgICAgICB4OiBiaW5hcnlUb0ludChwYWNrZXRJbmRleCksXG4gICAgICAgICAgICAgIHk6IGJpbmFyeVRvSW50KHBhY2tldENvdW50KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhbGlnbkRlY2ltYWwoYmluYXJ5VG9EZWNpbWFsKG1lc3NhZ2UsIGNodW5rU2l6ZSkpKTtcblxuICAgICAgICBsb2dSb3dJZkVuY29kaW5nRW5hYmxlZChFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwsXG4gICAgICAgICAgICBiaW5hcnlUb0hleCh0b0FkZHJlc3MpLFxuICAgICAgICAgICAgYmluYXJ5VG9IZXgoZnJvbUFkZHJlc3MpLFxuICAgICAgICAgICAgaTE4bi54T2ZZUGFja2V0cyh7XG4gICAgICAgICAgICAgIHg6IGJpbmFyeVRvSGV4KHBhY2tldEluZGV4KSxcbiAgICAgICAgICAgICAgeTogYmluYXJ5VG9IZXgocGFja2V0Q291bnQpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZvcm1hdEhleChiaW5hcnlUb0hleChtZXNzYWdlKSwgY2h1bmtTaXplKSk7XG5cbiAgICAgICAgbG9nUm93SWZFbmNvZGluZ0VuYWJsZWQoRW5jb2RpbmdUeXBlLkJJTkFSWSxcbiAgICAgICAgICAgIGZvcm1hdEJpbmFyeUZvckFkZHJlc3NIZWFkZXIodG9BZGRyZXNzLCA0KSxcbiAgICAgICAgICAgIGZvcm1hdEJpbmFyeUZvckFkZHJlc3NIZWFkZXIoZnJvbUFkZHJlc3MsIDQpLFxuICAgICAgICAgICAgZm9ybWF0QmluYXJ5KHBhY2tldEluZGV4ICsgcGFja2V0Q291bnQsIGxldmVsLnBhY2tldENvdW50Qml0V2lkdGgpLFxuICAgICAgICAgICAgZm9ybWF0QmluYXJ5KG1lc3NhZ2UsIGNodW5rU2l6ZSkpO1xuXG4gICAgICAgIGxvZ1Jvd0lmRW5jb2RpbmdFbmFibGVkKEVuY29kaW5nVHlwZS5BX0FORF9CLFxuICAgICAgICAgICAgYmluYXJ5VG9BQih0b0FkZHJlc3MpLFxuICAgICAgICAgICAgYmluYXJ5VG9BQihmcm9tQWRkcmVzcyksXG4gICAgICAgICAgICBmb3JtYXRBQihiaW5hcnlUb0FCKHBhY2tldEluZGV4ICsgcGFja2V0Q291bnQpLCBsZXZlbC5wYWNrZXRDb3VudEJpdFdpZHRoKSxcbiAgICAgICAgICAgIGZvcm1hdEFCKGJpbmFyeVRvQUIobWVzc2FnZSksIGNodW5rU2l6ZSkpO1xuICAgICAgIDsgYnVmLnB1c2goJ1xcbiAgICAgIDwvdGJvZHk+XFxuICAgIDwvdGFibGU+XFxuICAnKTsxNzI7IH0gOyBidWYucHVzaCgnXFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgU2ltdWxhdGlvbiBlbnRpdHkgY29udHJvbGxlciByZXNlcnZlZCBmb3IgdGhlIGxvY2FsIGNsaWVudCdzXG4gKiAgICAgICAgICAgc2ltdWxhdGlvbiBub2RlLlxuICogQHNlZSBOZXRTaW1DbGllbnROb2RlIGZvciB0aGUgY29udHJvbGxlciB1c2VkIGZvciBvdGhlciBjbGllbnQgbm9kZXNcbiAqICAgICAgaW4gdGhlIHNpbXVsYXRpb24uXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltQ2xpZW50Tm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ2xpZW50Tm9kZScpO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgTmV0U2ltQWxlcnQgPSByZXF1aXJlKCcuL05ldFNpbUFsZXJ0Jyk7XG52YXIgTmV0U2ltTWVzc2FnZSA9IHJlcXVpcmUoJy4vTmV0U2ltTWVzc2FnZScpO1xudmFyIE5ldFNpbUxvZ2dlciA9IHJlcXVpcmUoJy4vTmV0U2ltTG9nZ2VyJyk7XG52YXIgTmV0U2ltUm91dGVyTm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltUm91dGVyTm9kZScpO1xudmFyIE9ic2VydmFibGVFdmVudCA9IHJlcXVpcmUoJy4uL09ic2VydmFibGVFdmVudCcpO1xuXG52YXIgbG9nZ2VyID0gTmV0U2ltTG9nZ2VyLmdldFNpbmdsZXRvbigpO1xudmFyIE5ldFNpbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG52YXIgTWVzc2FnZUdyYW51bGFyaXR5ID0gTmV0U2ltQ29uc3RhbnRzLk1lc3NhZ2VHcmFudWxhcml0eTtcblxuLyoqXG4gKiBDbGllbnQgbW9kZWwgb2Ygbm9kZSBiZWluZyBzaW11bGF0ZWQgb24gdGhlIGxvY2FsIGNsaWVudC5cbiAqXG4gKiBQcm92aWRlcyBzcGVjaWFsIGFjY2VzcyBmb3IgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbGx5LW93bmVkIGNsaWVudCBub2RlIGluXG4gKiB3YXlzIHRoYXQgeW91IGFyZW4ndCBhbGxvd2VkIHRvIG1hbmlwdWxhdGUgb3RoZXIgY2xpZW50IG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHtPYmplY3R9IFtjbGllbnRSb3ddIC0gTG9iYnkgcm93IGZvciB0aGlzIHJvdXRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbUNsaWVudE5vZGVcbiAqL1xudmFyIE5ldFNpbUxvY2FsQ2xpZW50Tm9kZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNoYXJkLCBjbGllbnRSb3cpIHtcbiAgTmV0U2ltQ2xpZW50Tm9kZS5jYWxsKHRoaXMsIHNoYXJkLCBjbGllbnRSb3cpO1xuXG4gIC8vIFRPRE8gKGJidWNoYW5hbik6IENvbnNpZGVyOlxuICAvLyAgICAgIERvIHdlIGJlbmVmaXQgZnJvbSBpbmhlcml0YW5jZSBoZXJlPyAgV291bGQgaXQgYmUgY2xlYW5lciB0byBtYWtlIHRoaXNcbiAgLy8gICAgICBub3QtYW4tZW50aXR5IHRoYXQgbWFuaXB1bGF0ZXMgYSBzdG9jayBOZXRTaW1DbGllbnROb2RlPyAgV2lsbCBhbm90aGVyXG4gIC8vICAgICAgZGV2ZWxvcGVyIGZpbmQgaXQgZWFzeSB0byB1bmRlcnN0YW5kIGhvdyB0aGlzIGNsYXNzIHdvcmtzP1xuXG4gIC8qKlxuICAgKiBDbGllbnQgbm9kZXMgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBjbGllbnRzLlxuICAgKiBAdHlwZSB7TmV0U2ltQ2xpZW50Tm9kZX1cbiAgICovXG4gIHRoaXMubXlSZW1vdGVDbGllbnQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgcm91dGVyIHRoaXMgY2xpZW50IG5vZGUgaXMgY29ubmVjdGVkIHRvLiAgVW5kZWZpbmVkIGlmXG4gICAqIG5vdCBjb25uZWN0ZWQgdG8gYSByb3V0ZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5teVJvdXRlcklEXyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogU2V0IG9mIHJvdXRlciBjb250cm9sbGVycyBlbmFibGVkIGZvciBzaW11bGF0aW9uIGJ5IHRoaXMgbm9kZS5cbiAgICogQHR5cGUge05ldFNpbVJvdXRlck5vZGVbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm91dGVyc18gPSBbXTtcblxuICAvKipcbiAgICogV2lkZ2V0IHdoZXJlIHdlIHdpbGwgcG9zdCBzZW50IG1lc3NhZ2VzLlxuICAgKiBAdHlwZSB7TmV0U2ltTG9nUGFuZWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNlbnRMb2dfID0gbnVsbDtcblxuICAvKipcbiAgICogV2lkZ2V0IHdoZXJlIHdlIHdpbGwgcG9zdCByZWNlaXZlZCBtZXNzYWdlc1xuICAgKiBAdHlwZSB7TmV0U2ltTG9nUGFuZWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlY2VpdmVkTG9nXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIENoYW5nZSBldmVudCBvdGhlcnMgY2FuIG9ic2VydmUsIHdoaWNoIHdlIHdpbGwgZmlyZSB3aGVuIHdlXG4gICAqIGNvbm5lY3Qgb3IgZGlzY29ubmVjdCBmcm9tIGEgcm91dGVyIG9yIHJlbW90ZSBjbGllbnRcbiAgICogQHR5cGUge09ic2VydmFibGVFdmVudH1cbiAgICovXG4gIHRoaXMucmVtb3RlQ2hhbmdlID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3Igd2hlbiBzb21ldGhpbmcgaW5kaWNhdGVzIHRoYXQgdGhpcyBub2RlIGhhcyBiZWVuXG4gICAqIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5vbk5vZGVMb3N0Q29ubmVjdGlvbl8gPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogRXZlbnQgcmVnaXN0cmF0aW9uIGluZm9ybWF0aW9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50S2V5cyA9IHt9O1xufTtcbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5pbmhlcml0cyhOZXRTaW1DbGllbnROb2RlKTtcblxuLyoqXG4gKiBTdGF0aWMgYXN5bmMgY3JlYXRpb24gbWV0aG9kLiBTZWUgTmV0U2ltRW50aXR5LmNyZWF0ZSgpLlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheU5hbWVcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIC0gTWV0aG9kIHRoYXQgd2lsbCBiZSBnaXZlbiB0aGVcbiAqICAgICAgICBjcmVhdGVkIGVudGl0eSwgb3IgbnVsbCBpZiBlbnRpdHkgY3JlYXRpb24gZmFpbGVkLlxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUuY3JlYXRlID0gZnVuY3Rpb24gKHNoYXJkLCBkaXNwbGF5TmFtZSwgb25Db21wbGV0ZSkge1xuICAvLyBUT0RPIChiYnVjaGFuYW4pOiBNb2RpZnkgYW5kIHJldHVybiB0aGUgdGVtcGxhdGUgbm9kZSBpbnN0ZWFkIG9mXG4gIC8vIG1ha2luZyB0d28gaW4gdGhpcyBtZXRob2QuXG4gIHZhciB0ZW1wbGF0ZU5vZGUgPSBuZXcgTmV0U2ltTG9jYWxDbGllbnROb2RlKHNoYXJkKTtcbiAgdGVtcGxhdGVOb2RlLmRpc3BsYXlOYW1lXyA9IGRpc3BsYXlOYW1lO1xuICB0ZW1wbGF0ZU5vZGUuZ2V0VGFibGUoKS5jcmVhdGUodGVtcGxhdGVOb2RlLmJ1aWxkUm93KCksIGZ1bmN0aW9uIChlcnIsIHJvdykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG9uQ29tcGxldGUoZXJyLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZSA9IG5ldyBOZXRTaW1Mb2NhbENsaWVudE5vZGUoc2hhcmQsIHJvdyk7XG4gICAgb25Db21wbGV0ZShudWxsLCBuZXdOb2RlKTtcbiAgfSk7XG59O1xuXG4vKiogU2V0IG5vZGUncyBkaXNwbGF5IG5hbWUuICBEb2VzIG5vdCB0cmlnZ2VyIGFuIHVwZGF0ZSEgKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUuc2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgdGhpcy5kaXNwbGF5TmFtZV8gPSBkaXNwbGF5TmFtZTtcbn07XG5cbi8qKlxuICogQ29uZmlndXJlIHRoaXMgbm9kZSBjb250cm9sbGVyIHRvIGFjdGl2ZWx5IHNpbXVsYXRlLCBhbmQgdG8gcG9zdCBzZW50IGFuZFxuICogcmVjZWl2ZWQgbWVzc2FnZXMgdG8gdGhlIGdpdmVuIGxvZyB3aWRnZXRzLlxuICogQHBhcmFtIHshTmV0U2ltTG9nUGFuZWx9IHNlbnRMb2dcbiAqIEBwYXJhbSB7IU5ldFNpbUxvZ1BhbmVsfSByZWNlaXZlZExvZ1xuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLmluaXRpYWxpemVTaW11bGF0aW9uID0gZnVuY3Rpb24gKHNlbnRMb2csXG4gICAgcmVjZWl2ZWRMb2cpIHtcbiAgdGhpcy5zZW50TG9nXyA9IHNlbnRMb2c7XG4gIHRoaXMucmVjZWl2ZWRMb2dfID0gcmVjZWl2ZWRMb2c7XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHRhYmxlIGNoYW5nZXNcbiAgdGhpcy5ldmVudEtleXMubm9kZVRhYmxlID0gdGhpcy5zaGFyZF8ubm9kZVRhYmxlLnRhYmxlQ2hhbmdlLnJlZ2lzdGVyKFxuICAgICAgdGhpcy5vbk5vZGVUYWJsZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gIHRoaXMuZXZlbnRLZXlzLndpcmVUYWJsZSA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS50YWJsZUNoYW5nZS5yZWdpc3RlcihcbiAgICAgIHRoaXMub25XaXJlVGFibGVDaGFuZ2VfLmJpbmQodGhpcykpO1xuICB0aGlzLmV2ZW50S2V5cy5tZXNzYWdlVGFibGUgPSB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGUudGFibGVDaGFuZ2UucmVnaXN0ZXIoXG4gICAgICB0aGlzLm9uTWVzc2FnZVRhYmxlQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZE9uU2hhcmQgPSB0aGlzLnNoYXJkXztcblxuICAvLyBTZXQgdXAgaW5pdGlhbCBzdGF0ZSBmcm9tIGNhY2hlZCByb3dzXG4gIHRoaXMub25Ob2RlVGFibGVDaGFuZ2VfKCk7XG59O1xuXG4vKipcbiAqIEdpdmVzIHRoZSBzaW11bGF0aW5nIG5vZGUgYSBjaGFuY2UgdG8gdW5yZWdpc3RlciBmcm9tIGFueXRoaW5nIGl0IHdhc1xuICogb2JzZXJ2aW5nLlxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLnN0b3BTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZE9uU2hhcmQpIHtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkT25TaGFyZC5ub2RlVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMubm9kZVRhYmxlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkT25TaGFyZC53aXJlVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMud2lyZVRhYmxlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkT25TaGFyZC5tZXNzYWdlVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMubWVzc2FnZVRhYmxlKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkT25TaGFyZCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGlja3MgdGhlIHNpbXVsYXRpb24gcm91dGVyc1xuICogQHBhcmFtIHshUnVuTG9vcC5DbG9ja30gY2xvY2tcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIC8vIFRPRE8gKGJidWNoYW5hbik6IE1vdmUgdGhlIHJvdXRlciBjb2xsZWN0aW9uIGFuZCB0aWNraW5nIHRoZVxuICAvLyByb3V0ZXJzIHVwIHRvIG5ldHNpbS5qcyAob3IgZWxzZXdoZXJlKVxuICB0aGlzLnJvdXRlcnNfLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci50aWNrKGNsb2NrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdpdmUgdGhpcyBub2RlIGFuIGFjdGlvbiB0byB0YWtlIGlmIGl0IGRldGVjdHMgdGhhdCBpdCBpcyBubyBsb25nZXIgcGFydFxuICogb2YgdGhlIHNoYXJkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25Ob2RlTG9zdENvbm5lY3Rpb25cbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5zZXRMb3N0Q29ubmVjdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKFxuICAgIG9uTm9kZUxvc3RDb25uZWN0aW9uKSB7XG4gIHRoaXMub25Ob2RlTG9zdENvbm5lY3Rpb25fID0gb25Ob2RlTG9zdENvbm5lY3Rpb247XG59O1xuXG4vKipcbiAqIElmIGEgY2xpZW50IHVwZGF0ZSBmYWlscywgc2hvdWxkIGF0dGVtcHQgYW4gYXV0b21hdGljIHJlY29ubmVjdC5cbiAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IFtvbkNvbXBsZXRlXVxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIG9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgTmV0U2ltTG9jYWxDbGllbnROb2RlLnN1cGVyUHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkxvY2FsIG5vZGUgdXBkYXRlIGZhaWxlZDogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICBzZWxmLm9uTm9kZUxvc3RDb25uZWN0aW9uXygpO1xuICAgIH1cbiAgICBvbkNvbXBsZXRlKGVyciwgcmVzdWx0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgdG8gYSByZW1vdGUgY2xpZW50IG5vZGUuXG4gKiBAcGFyYW0ge05ldFNpbUNsaWVudE5vZGV9IGNsaWVudFxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5jb25uZWN0VG9DbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50LCBvbkNvbXBsZXRlKSB7XG4gIHRoaXMuY29ubmVjdFRvTm9kZShjbGllbnQsIGZ1bmN0aW9uIChlcnIsIHdpcmUpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBvbkNvbXBsZXRlKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBXRSBqdXN0IGVzdGFibGlzaGVkIGEgbXV0dWFsIGNvbm5lY3Rpb24gd2l0aCBhIHJlbW90ZSBjbGllbnQuXG4gICAgdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnJlZnJlc2goKS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5vbldpcmVUYWJsZUNoYW5nZV8odGhpcy5zaGFyZF8ud2lyZVRhYmxlLnJlYWRBbGwoKSk7XG4gICAgICBvbkNvbXBsZXRlKGVyciwgd2lyZSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshTmV0U2ltUm91dGVyTm9kZX0gcm91dGVyXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUuY29ubmVjdFRvUm91dGVyID0gZnVuY3Rpb24gKHJvdXRlciwgb25Db21wbGV0ZSkge1xuICBvbkNvbXBsZXRlID0gb25Db21wbGV0ZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICBsb2dnZXIuaW5mbyh0aGlzLmdldERpc3BsYXlOYW1lKCkgKyBcIjogQ29ubmVjdGluZyB0byBcIiArIHJvdXRlci5nZXREaXNwbGF5TmFtZSgpKTtcbiAgdGhpcy5jb25uZWN0VG9Ob2RlKHJvdXRlciwgZnVuY3Rpb24gKGVyciwgd2lyZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG9uQ29tcGxldGUoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm15Um91dGVySURfID0gcm91dGVyLmVudGl0eUlEO1xuXG4gICAgdGhpcy5yZW1vdGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKHRoaXMuZ2V0T3V0Z29pbmdXaXJlKCksIHRoaXMuZ2V0TXlSb3V0ZXIoKSk7XG4gICAgb25Db21wbGV0ZShudWxsLCB3aXJlKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFwcHJvcHJpYXRlIGluaXRpYWwgd2lyZSByb3cgZm9yIGNvbm5lY3RpbmcgdG8gdGhlIGdpdmVuIG5vZGUuXG4gKiBPdmVycmlkZXMgTmV0U2ltTm9kZSB2ZXJzaW9uIHRvIGFkZCBpbXByb3ZlZCBjb25uZWN0LXRvLXJvdXRlciBmdW5jdGlvbmFsaXR5LlxuICogQHBhcmFtIHshTmV0U2ltTm9kZX0gb3RoZXJOb2RlXG4gKiBAcmV0dXJucyB7V2lyZVJvd31cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLm1ha2VXaXJlUm93Rm9yQ29ubmVjdGluZ1RvID0gZnVuY3Rpb24gKG90aGVyTm9kZSkge1xuICBpZiAob3RoZXJOb2RlIGluc3RhbmNlb2YgTmV0U2ltUm91dGVyTm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbE5vZGVJRDogdGhpcy5lbnRpdHlJRCxcbiAgICAgIHJlbW90ZU5vZGVJRDogb3RoZXJOb2RlLmVudGl0eUlELFxuICAgICAgbG9jYWxBZGRyZXNzOiBvdGhlck5vZGUuZ2V0UmFuZG9tQXZhaWxhYmxlQ2xpZW50QWRkcmVzcygpLFxuICAgICAgcmVtb3RlQWRkcmVzczogb3RoZXJOb2RlLmdldEFkZHJlc3MoKSxcbiAgICAgIGxvY2FsSG9zdG5hbWU6IHRoaXMuZ2V0SG9zdG5hbWUoKSxcbiAgICAgIHJlbW90ZUhvc3RuYW1lOiBvdGhlck5vZGUuZ2V0SG9zdG5hbWUoKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIE5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5zdXBlclByb3RvdHlwZVxuICAgICAgLm1ha2VXaXJlUm93Rm9yQ29ubmVjdGluZ1RvLmNhbGwodGhpcywgb3RoZXJOb2RlKTtcbn07XG5cbi8qKlxuICogSGVscGVyL2FjY2Vzc29yIGZvciByb3V0ZXIgY29udHJvbGxlciBpbnN0YW5jZSBmb3IgdGhlIHJvdXRlciB0aGF0IHRoaXNcbiAqIGNsaWVudCBpcyBkaXJlY3RseSBjb25uZWN0ZWQgdG8uXG4gKiBAcmV0dXJucyB7TmV0U2ltUm91dGVyTm9kZXxudWxsfSBSb3V0ZXIgd2UgYXJlIGNvbm5lY3RlZCB0byBvciBudWxsIGlmIG5vdFxuICogICAgICAgICAgY29ubmVjdGVkIHRvIGEgcm91dGVyIGF0IGFsbC5cbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5nZXRNeVJvdXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubXlSb3V0ZXJJRF8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIF8uZmluZCh0aGlzLnJvdXRlcnNfLCBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcmV0dXJuIHJvdXRlci5lbnRpdHlJRCA9PT0gdGhpcy5teVJvdXRlcklEXztcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlU3R5bGVDYWxsYmFja30gW29uQ29tcGxldGVdXG4gKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdFJlbW90ZSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIG9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIC8vIHNhdmUgdGhlIHdpcmUgc28gd2UgY2FuIGRlc3Ryb3kgaXRcbiAgdmFyIHdpcmUgPSB0aGlzLmdldE91dGdvaW5nV2lyZSgpO1xuXG4gIC8vIHJlbW92ZSBhbGwgbG9jYWwgcmVmZXJlbmNlcyB0byBjb25uZWN0aW9uc1xuICB0aGlzLmNsZWFuVXBCZWZvcmVEZXN0cm95aW5nV2lyZV8oKTtcblxuICAvLyBkZXN0cm95IHdpcmUgb24gQVBJXG4gIHdpcmUuZGVzdHJveShmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHN0b3AgaWYgYW4gZXJyb3Igb2NjdXJyZWQgaGVyZTsgdGhlIGVycm9yIG1pZ2h0XG4gICAgLy8ganVzdCBiZSB0aGF0IHRoZSB3aXJlIHdhcyBhbHJlYWR5IGNsZWFuZWQgdXAgYnkgYW5vdGhlciBub2RlLlxuICAgIC8vIEFzIGxvbmcgYXMgd2UgbWFrZSBhIGdvb2QtZmFpdGggZGlzY29ubmVjdCBlZmZvcnQsIHRoZSBjbGVhbnVwIHN5c3RlbVxuICAgIC8vIHdpbGwgY29ycmVjdCBhbnkgbWlzdGFrZXMgYW5kIHdlIHdvbid0IGxvY2sgdXAgb3VyIGNsaWVudCB0cnlpbmcgdG9cbiAgICAvLyByZS1kaXNjb25uZWN0LlxuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiRXJyb3Igd2hpbGUgZGlzY29ubmVjdGluZzogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENvbW1vbiBjbGVhbnVwIGJlaGF2aW9yIHNoYXJlZCBiZXR3ZWVuIHRoZSBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXG4gKiBkaXNjb25uZWN0IHBhdGhzLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5jbGVhblVwQmVmb3JlRGVzdHJveWluZ1dpcmVfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm15UmVtb3RlQ2xpZW50ID0gbnVsbDtcbiAgdGhpcy5teVJvdXRlcklEXyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yZW1vdGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKG51bGwsIG51bGwpO1xufTtcblxuLyoqXG4gKiBQdXQgYSBtZXNzYWdlIG9uIG91ciBvdXRnb2luZyB3aXJlLCB0byB3aGF0ZXZlciB3ZSBhcmUgY29ubmVjdGVkIHRvXG4gKiBhdCB0aGUgbW9tZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHBheWxvYWRcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAocGF5bG9hZCwgb25Db21wbGV0ZSkge1xuICB2YXIgbXlXaXJlID0gdGhpcy5nZXRPdXRnb2luZ1dpcmUoKTtcbiAgaWYgKCFteVdpcmUpIHtcbiAgICBvbkNvbXBsZXRlKG5ldyBFcnJvcignQ2Fubm90IHNlbmQgbWVzc2FnZTsgbm90IGNvbm5lY3RlZC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxvY2FsTm9kZUlEID0gbXlXaXJlLmxvY2FsTm9kZUlEO1xuICB2YXIgcmVtb3RlTm9kZUlEID0gbXlXaXJlLnJlbW90ZU5vZGVJRDtcblxuICAvLyBXaG8gd2lsbCBiZSByZXNwb25zaWJsZSBmb3IgcGlja2luZyB1cC9jbGVhbmluZyB1cCB0aGlzIG1lc3NhZ2U/XG4gIHZhciBzaW11bGF0aW5nTm9kZUlEID0gdGhpcy5zZWxlY3RTaW11bGF0aW5nTm9kZV8obG9jYWxOb2RlSUQsIHJlbW90ZU5vZGVJRCk7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgdmFyIGV4dHJhSG9wcyA9IGxldmVsQ29uZmlnLm1pbmltdW1FeHRyYUhvcHM7XG4gIGlmIChsZXZlbENvbmZpZy5taW5pbXVtRXh0cmFIb3BzICE9PSBsZXZlbENvbmZpZy5tYXhpbXVtRXh0cmFIb3BzKSB7XG4gICAgZXh0cmFIb3BzID0gTmV0U2ltR2xvYmFscy5yYW5kb21JbnRJblJhbmdlKFxuICAgICAgICBsZXZlbENvbmZpZy5taW5pbXVtRXh0cmFIb3BzLFxuICAgICAgICBsZXZlbENvbmZpZy5tYXhpbXVtRXh0cmFIb3BzICsgMSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIE5ldFNpbU1lc3NhZ2Uuc2VuZChcbiAgICAgIHRoaXMuc2hhcmRfLFxuICAgICAge1xuICAgICAgICBmcm9tTm9kZUlEOiBsb2NhbE5vZGVJRCxcbiAgICAgICAgdG9Ob2RlSUQ6IHJlbW90ZU5vZGVJRCxcbiAgICAgICAgc2ltdWxhdGVkQnk6IHNpbXVsYXRpbmdOb2RlSUQsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIGV4dHJhSG9wc1JlbWFpbmluZzogZXh0cmFIb3BzXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVyciwgcm93KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzZW5kIG1lc3NhZ2U6ICcgKyBlcnIubWVzc2FnZSArIFwiXFxuXCIgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgICAgTmV0U2ltQWxlcnQuZXJyb3IoaTE4bi5zZW5kTWVzc2FnZUVycm9yKCkpO1xuICAgICAgICAgIG9uQ29tcGxldGUoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIuaW5mbyh0aGlzLmdldERpc3BsYXlOYW1lKCkgKyAnOiBTZW50IG1lc3NhZ2U6JyArXG4gICAgICAgICAgICAnXFxuZnJvbTogJyArIGxvY2FsTm9kZUlEICtcbiAgICAgICAgICAgICdcXG50byAgOiAnICsgcmVtb3RlTm9kZUlEICtcbiAgICAgICAgICAgICdcXG5zaW0gOiAnICsgc2ltdWxhdGluZ05vZGVJRCArXG4gICAgICAgICAgICAnXFxuaG9wczogJyArIGV4dHJhSG9wcyk7XG5cbiAgICAgICAgaWYgKHNlbGYuc2VudExvZ18pIHtcbiAgICAgICAgICBzZWxmLnNlbnRMb2dfLmxvZyhwYXlsb2FkLCByb3cuaWQpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgKTtcbn07XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgdGhlIGxvY2FsIG5vZGUgb3IgdGhlIHJlbW90ZSBub2RlIHdpbGwgYmUgcmVzcG9uc2libGVcbiAqIGZvciBwaWNraW5nIHVwIGFuZCBjbGVhbmluZyB1cCB0aGlzIG1lc3NhZ2UgZnJvbSByZW1vdGUgc3RvcmFnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2NhbE5vZGVJRFxuICogQHBhcmFtIHtudW1iZXJ9IHJlbW90ZU5vZGVJRFxuICogQHJldHVybnMge251bWJlcn0gb25lIG9mIHRoZSB0d28gSURzIHByb3ZpZGVkXG4gKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUuc2VsZWN0U2ltdWxhdGluZ05vZGVfID0gZnVuY3Rpb24gKGxvY2FsTm9kZUlELFxuICAgIHJlbW90ZU5vZGVJRCkge1xuICBpZiAoTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLm1lc3NhZ2VHcmFudWxhcml0eSA9PT0gTWVzc2FnZUdyYW51bGFyaXR5LkJJVFMpIHtcbiAgICAvLyBJbiBzaW1wbGV4IHdpcmUgbW9kZSwgdGhlIGxvY2FsIG5vZGUgY2xlYW5zIHVwIGl0cyBvd24gbWVzc2FnZXNcbiAgICAvLyB3aGVuIGl0IGtub3dzIHRoZXkgYXJlIG5vIGxvbmdlciBjdXJyZW50LlxuICAgIHJldHVybiBsb2NhbE5vZGVJRDtcbiAgfSBlbHNlIGlmICh0aGlzLm15Um91dGVySURfICE9PSB1bmRlZmluZWQgJiYgdGhpcy5teVJvdXRlcklEXyA9PT0gcmVtb3RlTm9kZUlEKSB7XG4gICAgLy8gSWYgc2VuZGluZyB0byBhIHJvdXRlciwgd2Ugd2lsbCBkbyBvdXIgb3duIHNpbXVsYXRpb24gb24gdGhlIHJvdXRlcidzXG4gICAgLy8gYmVoYWxmXG4gICAgcmV0dXJuIGxvY2FsTm9kZUlEO1xuICB9XG4gIC8vIERlZmF1bHQgY2FzZTogVGhlIGRlc2lnbmF0ZWQgcmVjaXBpZW50IG11c3QgcGljayB1cCB0aGUgbWVzc2FnZS5cbiAgcmV0dXJuIHJlbW90ZU5vZGVJRDtcbn07XG5cbi8qKlxuICogU2VxdWVudGlhbGx5IHB1dHMgYSBsaXN0IG9mIG1lc3NhZ2VzIG9udG8gdGhlIG91dGdvaW5nIHdpcmUsIHRvIHdoYXRldmVyXG4gKiB3ZSBhcmUgY29ubmVjdGVkIHRvIGF0IHRoZSBtb21lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXlsb2Fkc1xuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5zZW5kTWVzc2FnZXMgPSBmdW5jdGlvbiAocGF5bG9hZHMsIG9uQ29tcGxldGUpIHtcbiAgaWYgKHBheWxvYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zZW5kTWVzc2FnZShwYXlsb2Fkc1swXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZW5kTWVzc2FnZXMocGF5bG9hZHMuc2xpY2UoMSksIG9uQ29tcGxldGUpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBXaGVuZXZlciB0aGUgbm9kZSB0YWJsZSBjaGFuZ2VzLCBtYWtlIG5lZWRlZCBjaGFuZ2VzIHRvIG91ciBjb2xsZWN0aW9uIG9mXG4gKiByb3V0ZXJzIGNvbmZpZ3VyZWQgdG8gc2ltdWxhdGUgZm9yIHRoZSBsb2NhbCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5vbk5vZGVUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlUm93cyA9IHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCk7XG5cbiAgLy8gSWYgb3VyIG93biByb3cgaXMgZ29uZSwgZHJvcCBldmVyeXRoaW5nIGFuZCBoYW5kbGUgZGlzY29ubmVjdC5cbiAgaWYgKCF0aGlzLmNhbkZpbmRPd25Sb3dJbihub2RlUm93cykpIHtcbiAgICB0aGlzLm9uTm9kZUxvc3RDb25uZWN0aW9uXygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbW92ZSBzaW11bGF0aW5nIHJvdXRlcnMgdGhhdCBoYXZlIHZhbmlzaGVkIGZyb20gcmVtb3RlIHN0b3JhZ2UuXG4gIHRoaXMucm91dGVyc18gPSB0aGlzLnJvdXRlcnNfLmZpbHRlcihmdW5jdGlvbiAoc2ltdWxhdGluZ1JvdXRlcikge1xuICAgIHZhciBzdGlsbEV4aXN0cyA9IG5vZGVSb3dzLnNvbWUoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5pZCA9PT0gc2ltdWxhdGluZ1JvdXRlci5lbnRpdHlJRDtcbiAgICB9KTtcbiAgICBpZiAoIXN0aWxsRXhpc3RzKSB7XG4gICAgICBzaW11bGF0aW5nUm91dGVyLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICAvLyBDcmVhdGUgYW5kIHNpbXVsYXRlIG5ldyByb3V0ZXJzXG4gIG5vZGVSb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvdy50eXBlID09PSBOZXRTaW1Db25zdGFudHMuTm9kZVR5cGUuUk9VVEVSO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICB2YXIgYWxyZWFkeVNpbXVsYXRpbmcgPSB0aGlzLnJvdXRlcnNfLnNvbWUoZnVuY3Rpb24gKHNpbXVsYXRpbmdSb3V0ZXIpIHtcbiAgICAgIHJldHVybiByb3cuaWQgPT09IHNpbXVsYXRpbmdSb3V0ZXIuZW50aXR5SUQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFscmVhZHlTaW11bGF0aW5nKSB7XG4gICAgICB2YXIgbmV3Um91dGVyID0gbmV3IE5ldFNpbVJvdXRlck5vZGUodGhpcy5zaGFyZF8sIHJvdyk7XG4gICAgICBuZXdSb3V0ZXIuaW5pdGlhbGl6ZVNpbXVsYXRpb24odGhpcy5lbnRpdHlJRCk7XG4gICAgICB0aGlzLnJvdXRlcnNfLnB1c2gobmV3Um91dGVyKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBub2RlUm93c1xuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgb3duIHJvdyBpcyBpbiBnaXZlbiByb3cgY29sbGVjdGlvblxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLmNhbkZpbmRPd25Sb3dJbiA9IGZ1bmN0aW9uIChub2RlUm93cykge1xuICByZXR1cm4gbm9kZVJvd3Muc29tZShmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvdy5pZCA9PT0gdGhpcy5lbnRpdHlJRCAmJiByb3cudXVpZCA9PT0gdGhpcy51dWlkO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYW55IHdpcmUgdGFibGUgY2hhbmdlLiAgVXNlZCBoZXJlIHRvIGRldGVjdCBtdXR1YWxcbiAqIGNvbm5lY3Rpb25zIGJldHdlZW4gY2xpZW50IG5vZGVzIHRoYXQgaW5kaWNhdGUgd2UgY2FuIG1vdmUgdG8gYVxuICogXCJjb25uZWN0ZWRcIiBzdGF0ZSBvciBzdG9wIHRyeWluZyB0byBjb25uZWN0LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9jYWxDbGllbnROb2RlLnByb3RvdHlwZS5vbldpcmVUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBteVdpcmUgPSB0aGlzLmdldE91dGdvaW5nV2lyZSgpO1xuICBpZiAoIW15V2lyZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB3aXJlUm93cyA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWFkQWxsKCk7XG4gIHZhciBteUNvbm5lY3Rpb25UYXJnZXRXaXJlUm93LCBpc1RhcmdldENvbm5lY3RlZFRvU29tZW9uZUVsc2U7XG5cbiAgLy8gTG9vayBmb3IgbXV0dWFsIGNvbm5lY3Rpb25cbiAgdmFyIG11dHVhbENvbm5lY3Rpb25Sb3cgPSBfLmZpbmQod2lyZVJvd3MsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93LnJlbW90ZU5vZGVJRCA9PT0gbXlXaXJlLmxvY2FsTm9kZUlEICYmXG4gICAgICAgIHJvdy5sb2NhbE5vZGVJRCA9PT0gbXlXaXJlLnJlbW90ZU5vZGVJRDtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAobXV0dWFsQ29ubmVjdGlvblJvdyAmJiAhdGhpcy5teVJlbW90ZUNsaWVudCkge1xuICAgIC8vIE5ldyBtdXR1YWwgY29ubmVjdGlvbiEgR2V0IHRoZSBub2RlIGZvciBvdXIgb3duIHVzZS5cbiAgICBOZXRTaW1DbGllbnROb2RlLmdldChtdXR1YWxDb25uZWN0aW9uUm93LmxvY2FsTm9kZUlELCB0aGlzLnNoYXJkXyxcbiAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVtb3RlQ2xpZW50KSB7XG4gICAgICAgICAgdGhpcy5teVJlbW90ZUNsaWVudCA9IHJlbW90ZUNsaWVudDtcbiAgICAgICAgICB0aGlzLnJlbW90ZUNoYW5nZS5ub3RpZnlPYnNlcnZlcnMobXlXaXJlLCB0aGlzLm15UmVtb3RlQ2xpZW50KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgfSBlbHNlIGlmICghbXV0dWFsQ29ubmVjdGlvblJvdyAmJiB0aGlzLm15UmVtb3RlQ2xpZW50KSB7XG4gICAgLy8gUmVtb3RlIGNsaWVudCBkaXNjb25uZWN0ZWQgb3Igd2UgZGlzY29ubmVjdGVkOyBlaXRoZXIgd2F5IHdlIGFyZVxuICAgIC8vIG5vIGxvbmdlciBjb25uZWN0ZWQuXG4gICAgTmV0U2ltQWxlcnQuaW5mbyhpMThuLmFsZXJ0UGFydG5lckRpc2Nvbm5lY3RlZCgpKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RSZW1vdGUoKTtcbiAgfSBlbHNlIGlmICghbXV0dWFsQ29ubmVjdGlvblJvdyAmJiAhdGhpcy5teVJlbW90ZUNsaWVudCkge1xuICAgIC8vIFRoZSBjbGllbnQgd2UncmUgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gbWlnaHQgaGF2ZSBjb25uZWN0ZWQgdG9cbiAgICAvLyBzb21lb25lIGVsc2U7IGNoZWNrIGlmIHRoZXkgZGlkIGFuZCBpZiBzbywgc3RvcCB0cnlpbmcgdG8gY29ubmVjdFxuICAgIG15Q29ubmVjdGlvblRhcmdldFdpcmVSb3cgPSBfLmZpbmQod2lyZVJvd3MsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5sb2NhbE5vZGVJRCA9PT0gbXlXaXJlLnJlbW90ZU5vZGVJRCAmJlxuICAgICAgICAgIHJvdy5yZW1vdGVOb2RlSUQgIT09IG15V2lyZS5sb2NhbE5vZGVJRDtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIGlzVGFyZ2V0Q29ubmVjdGVkVG9Tb21lb25lRWxzZSA9IG15Q29ubmVjdGlvblRhcmdldFdpcmVSb3cgP1xuICAgICAgICB3aXJlUm93cy5zb21lKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LnJlbW90ZU5vZGVJRCA9PT0gbXlDb25uZWN0aW9uVGFyZ2V0V2lyZVJvdy5sb2NhbE5vZGVJRCAmJlxuICAgICAgICAgICAgICByb3cubG9jYWxOb2RlSUQgPT09IG15Q29ubmVjdGlvblRhcmdldFdpcmVSb3cucmVtb3RlTm9kZUlEO1xuICAgICAgICB9KSA6IHVuZGVmaW5lZDtcbiAgICBpZiAobXlDb25uZWN0aW9uVGFyZ2V0V2lyZVJvdyAmJiBpc1RhcmdldENvbm5lY3RlZFRvU29tZW9uZUVsc2UpIHtcbiAgICAgIE5ldFNpbUFsZXJ0LmluZm8oaTE4bi5hbGVydENvbm5lY3Rpb25SZWZ1c2VkKCkpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0UmVtb3RlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpc3RlbnMgZm9yIGNoYW5nZXMgdG8gdGhlIG1lc3NhZ2UgdGFibGUuICBEZXRlY3RzIGFuZCBoYW5kbGVzIG1lc3NhZ2VzXG4gKiBzZW50IHRvIHRoaXMgbm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbUxvY2FsQ2xpZW50Tm9kZS5wcm90b3R5cGUub25NZXNzYWdlVGFibGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIU5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5hdXRvbWF0aWNSZWNlaXZlKSB7XG4gICAgLy8gSW4gdGhpcyBsZXZlbCwgd2Ugd2lsbCBub3QgYXV0b21hdGljYWxseSBwaWNrIHVwIG1lc3NhZ2VzIGRpcmVjdGVkXG4gICAgLy8gYXQgdXMuICBXZSBtdXN0IG1hbnVhbGx5IGNhbGwgYSByZWNlaXZlIG1ldGhvZCBpbnN0ZWFkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmlzUHJvY2Vzc2luZ01lc3NhZ2VzXykge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgaW4gdGhpcyBtZXRob2QsIGdldHRpbmcgY2FsbGVkIHJlY3Vyc2l2ZWx5IGJlY2F1c2VcbiAgICAvLyB3ZSBhcmUgbWFraW5nIGNoYW5nZXMgdG8gdGhlIHRhYmxlLiAgSWdub3JlIHRoaXMgY2FsbC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWVzc2FnZXMgPSB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGUucmVhZEFsbCgpXG4gICAgICAubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXRTaW1NZXNzYWdlKHRoaXMuc2hhcmRfLCByb3cpO1xuICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS50b05vZGVJRCA9PT0gdGhpcy5lbnRpdHlJRCAmJlxuICAgICAgICAgICAgbWVzc2FnZS5zaW11bGF0ZWRCeSA9PT0gdGhpcy5lbnRpdHlJRDtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vIG1lc3NhZ2VzIGZvciB1cywgbm8gd29yayB0byBkb1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNldHVwIChzeW5jKTogU2V0IHByb2Nlc3NpbmcgZmxhZ1xuICBsb2dnZXIuaW5mbyhcIkxvY2FsIG5vZGUgcmVjZWl2ZWQgXCIgKyBtZXNzYWdlcy5sZW5ndGggKyBcIiBtZXNzYWdlc1wiKTtcbiAgdGhpcy5pc1Byb2Nlc3NpbmdNZXNzYWdlc18gPSB0cnVlO1xuXG4gIC8vIFN0ZXAgMSAoYXN5bmMpOiBQdWxsIGFsbCBvdXIgbWVzc2FnZXMgb3V0IG9mIHN0b3JhZ2VcbiAgTmV0U2ltRW50aXR5LmRlc3Ryb3lFbnRpdGllcyhtZXNzYWdlcywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgcHVsbGluZyBtZXNzYWdlIG9mZiB0aGUgd2lyZTogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgIHRoaXMuaXNQcm9jZXNzaW5nTWVzc2FnZXNfID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RlcCAyIChzeW5jKTogSGFuZGxlIGFsbCBtZXNzYWdlc1xuICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZV8obWVzc2FnZSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBDbGVhbnVwIChzeW5jKTogQ2xlYXIgcHJvY2Vzc2luZyBmbGFnXG4gICAgbG9nZ2VyLmluZm8oXCJMb2NhbCBub2RlIGZpbmlzaGVkIHByb2Nlc3NpbmcgXCIgKyBtZXNzYWdlcy5sZW5ndGggKyBcIiBtZXNzYWdlc1wiKTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZ01lc3NhZ2VzXyA9IGZhbHNlO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBQb3N0IG1lc3NhZ2UgdG8gJ3JlY2VpdmVkJyBsb2cuXG4gKiBAcGFyYW0geyFOZXRTaW1NZXNzYWdlfSBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2VfID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgbG9nZ2VyLmluZm8odGhpcy5nZXREaXNwbGF5TmFtZSgpICsgJzogSGFuZGxpbmcgaW5jb21pbmcgbWVzc2FnZScpO1xuICAvLyBUT0RPOiBIb3cgbXVjaCB2YWxpZGF0aW9uIHNob3VsZCB3ZSBkbyBoZXJlP1xuICBpZiAodGhpcy5yZWNlaXZlZExvZ18pIHtcbiAgICB0aGlzLnJlY2VpdmVkTG9nXy5sb2cobWVzc2FnZS5wYXlsb2FkLCBtZXNzYWdlLmVudGl0eUlEKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZWNlaXZlIHRoZSBsYXRlc3QgbWVzc2FnZSBzaGFyZWQgYmV0d2VlbiB0aGlzIG5vZGVcbiAqIGFuZCBpdHMgY29ubmVjdGVkIHJlbW90ZSBub2RlLlxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgLSBnaXZlbiB0aGUgbWVzc2FnZSBhcyBhIHJlc3VsdCwgb3JcbiAqICAgICAgICBOVUxMIGlmIG5vIG1lc3NhZ2VzIGV4aXN0LlxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLmdldExhdGVzdE1lc3NhZ2VPblNpbXBsZXhXaXJlID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgdmFyIG15V2lyZSA9IHRoaXMuZ2V0T3V0Z29pbmdXaXJlKCk7XG4gIGlmICghbXlXaXJlKSB7XG4gICAgb25Db21wbGV0ZShuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmV0cmlldmUgbWVzc2FnZTsgbm90IGNvbm5lY3RlZC5cIikpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERvZXMgYW4gYXN5bmNocm9ub3VzIHJlcXVlc3QgdG8gdGhlIG1lc3NhZ2UgdGFibGUgdG8gZW5zdXJlIHdlIGhhdmVcbiAgLy8gdGhlIGxhdGVzdCBjb250ZW50c1xuICB2YXIgbWVzc2FnZVRhYmxlID0gdGhpcy5zaGFyZF8ubWVzc2FnZVRhYmxlO1xuICBtZXNzYWdlVGFibGUucmVmcmVzaCgpXG4gICAgLmZhaWwob25Db21wbGV0ZSlcbiAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgY2FyZSBhYm91dCByb3dzIG9uIG91ciAoc2ltcGxleCkgd2lyZVxuICAgICAgICB2YXIgcm93c09uV2lyZSA9IG1lc3NhZ2VUYWJsZS5yZWFkQWxsKCkuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gbXlXaXJlLmlzTWVzc2FnZVJvd09uU2ltcGxleFdpcmUocm93KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcm93cywgY29tcGxldGUgc3VjY2Vzc2Z1bGx5IGJ1dCBwYXNzIG51bGwgcmVzdWx0LlxuICAgICAgICBpZiAocm93c09uV2lyZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKG51bGwsIG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0Um93ID0gcm93c09uV2lyZVtyb3dzT25XaXJlLmxlbmd0aCAtIDFdO1xuICAgICAgICBvbkNvbXBsZXRlKG51bGwsIG5ldyBOZXRTaW1NZXNzYWdlKHRoaXMuc2hhcmRfLCBsYXN0Um93KSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzZXQgdGhlIHN0YXRlIG9mIHRoZSBzaGFyZWQgd2lyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZSAtIHByb2JhYmx5IG91Z2h0IHRvIGJlIFwiMFwiIG9yIFwiMVwiXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZVxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLnNldFNpbXBsZXhXaXJlU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUsIG9uQ29tcGxldGUpIHtcbiAgdGhpcy5zZW5kTWVzc2FnZShuZXdTdGF0ZSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGxvZ2dlci53YXJuKGVyci5tZXNzYWdlKTtcbiAgICAgIG9uQ29tcGxldGUobmV3IEVycm9yKFwiRmFpbGVkIHRvIHNldCB3aXJlIHN0YXRlLlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UncmUgbm90IGRvbmUhICBBbHNvIGRvIG91ciBwYXJ0IHRvIGtlZXAgdGhlIG1lc3NhZ2UgdGFibGUgY2xlYW4uXG4gICAgdGhpcy5yZW1vdmVNeU9sZE1lc3NhZ2VzRnJvbVdpcmVfKG9uQ29tcGxldGUpO1xuICB9LmJpbmQodGhpcykpO1xuXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIG1lc3NhZ2VzIG9uIHRoZSBjdXJyZW50IHdpcmUgdGhhdCBhcmUgc2ltdWxhdGVkIGJ5IHRoZSBsb2NhbFxuICogbm9kZSBhbmQgYXJlIG5vdCB0aGUgbGF0ZXN0IG1lc3NhZ2Ugb24gdGhlIHdpcmUuXG4gKiBVc2VkIGJ5IHNpbXBsZXggY29uZmlndXJhdGlvbnMgd2hlcmUgd2Ugb25seSBjYXJlIGFib3V0IHRoZSB3aXJlJ3MgY3VycmVudFxuICogKGxhdGVzdCkgc3RhdGUuXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZVxuICovXG5OZXRTaW1Mb2NhbENsaWVudE5vZGUucHJvdG90eXBlLnJlbW92ZU15T2xkTWVzc2FnZXNGcm9tV2lyZV8gPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICB2YXIgbXlXaXJlID0gdGhpcy5nZXRPdXRnb2luZ1dpcmUoKTtcbiAgaWYgKCFteVdpcmUpIHtcbiAgICBvbkNvbXBsZXRlKG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXRyaWV2ZSBtZXNzYWdlOyBub3QgY29ubmVjdGVkLlwiKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRG9lcyBhbiBhc3luY2hyb25vdXMgcmVxdWVzdCB0byB0aGUgbWVzc2FnZSB0YWJsZSB0byBlbnN1cmUgd2UgaGF2ZVxuICAvLyB0aGUgbGF0ZXN0IGNvbnRlbnRzXG4gIHZhciBtZXNzYWdlVGFibGUgPSB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGU7XG4gIG1lc3NhZ2VUYWJsZS5yZWZyZXNoKClcbiAgICAuZmFpbChvbkNvbXBsZXRlKVxuICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IHJvd3Mgb24gb3VyIChzaW1wbGV4KSB3aXJlXG4gICAgICAgIHZhciByb3dzT25XaXJlID0gbWVzc2FnZVRhYmxlLnJlYWRBbGwoKS5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHJldHVybiBteVdpcmUuaXNNZXNzYWdlUm93T25TaW1wbGV4V2lyZShyb3cpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBcIk9sZFwiIHJvd3MgYXJlIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCAodGhlIGxhdGVzdCBvbmUpXG4gICAgICAgIHZhciBvbGRSb3dzT25XaXJlID0gcm93c09uV2lyZS5zbGljZSgwLCAtMSk7XG5cbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgaW4gY2hhcmdlIG9mIGRlbGV0aW5nIG1lc3NhZ2VzIHRoYXQgd2UgYXJlIHNpbXVsYXRpbmdcbiAgICAgICAgdmFyIG15T2xkUm93c09uV2lyZSA9IG9sZFJvd3NPbldpcmUuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LnNpbXVsYXRlZEJ5ID09PSB0aGlzLmVudGl0eUlEO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIG1lc3NhZ2UgZW50aXRpZXMgc28gd2UgY2FuIGRlc3Ryb3kgdGhlbVxuICAgICAgICB2YXIgbXlPbGRNZXNzYWdlc09uV2lyZSA9IG15T2xkUm93c09uV2lyZS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHJldHVybiBuZXcgTmV0U2ltTWVzc2FnZSh0aGlzLnNoYXJkXywgcm93KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgTmV0U2ltRW50aXR5LmRlc3Ryb3lFbnRpdGllcyhteU9sZE1lc3NhZ2VzT25XaXJlLCBvbkNvbXBsZXRlKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgVUkgY29udHJvbGxlciBmb3IgbG9iYnkgLSBoYW5kbGVzIGZsb3cgZm9yIG5hbWUgZW50cnksIHNlY3Rpb25cbiAqICAgICAgICAgICBzZWxlY3Rpb24sIGFuZCByZW1vdGUgbm9kZSBzZWxlY3Rpb24uXG4gKiBAc2VlIE5ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwgZm9yIG5hbWUgZW50cnkgYW5kIHNoYXJkIHNlbGVjdGlvbi5cbiAqIEBzZWUgTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsIGZvciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWN0dWFsXG4gKiAgICAgIGxvYmJ5IHRhYmxlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltTm9kZUZhY3RvcnkgPSByZXF1aXJlKCcuL05ldFNpbU5vZGVGYWN0b3J5Jyk7XG52YXIgTmV0U2ltQ2xpZW50Tm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ2xpZW50Tm9kZScpO1xudmFyIE5ldFNpbUFsZXJ0ID0gcmVxdWlyZSgnLi9OZXRTaW1BbGVydCcpO1xudmFyIE5ldFNpbUFwaUVycm9yID0gcmVxdWlyZSgnLi9OZXRTaW1BcGlFcnJvcicpO1xudmFyIE5ldFNpbVJvdXRlck5vZGUgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlck5vZGUnKTtcbnZhciBOZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsID0gcmVxdWlyZSgnLi9OZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsJyk7XG52YXIgTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsID0gcmVxdWlyZSgnLi9OZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwnKTtcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4vTmV0U2ltTG9nZ2VyJykuZ2V0U2luZ2xldG9uKCk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNoYXJkQ2hvaWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2hhcmRTZWVkIC0gdW5pcXVlIGtleSBmb3Igc2hhcmQgd2l0aGluIGxldmVsLCB1c2VkIGluXG4gKiAgICAgICAgICAgc2hhcmUgVVJMc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHNoYXJkSUQgLSB1bmlxdWUga2V5IGZvciBzaGFyZCBpbiB0YWJsZXMgQVBJLCB1c2VkIGFzXG4gKiAgICAgICAgICAgcHJlZml4IHRvIHRhYmxlIG5hbWVzLiAgTXVzdCBiZSA0OCBjaGFyYWN0ZXJzIG9yIGxlc3MsIGFuZFxuICogICAgICAgICAgIGNvbnNpc3RlbnRseSBnZW5lcmF0YWJsZSBmcm9tIGEgbGV2ZWwgSUQgYW5kIHNlZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlzcGxheU5hbWUgLSBsb2NhbGl6ZWQgc2hhcmQgbmFtZVxuICovXG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBsb2JieS9jb25uZWN0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge05ldFNpbX0gY29ubmVjdGlvbiAtIFRoZSBzaGFyZCBjb25uZWN0aW9uIHRoYXQgdGhpc1xuICogICAgICAgIGxvYmJ5IGNvbnRyb2wgd2lsbCBtYW5pcHVsYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RGFzaGJvYXJkVXNlcn0gb3B0aW9ucy51c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZXZlbEtleVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2hhcmVkU2hhcmRTZWVkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1QYW5lbFxuICovXG52YXIgTmV0U2ltTG9iYnkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBuZXRzaW0sIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogU2hhcmQgY29ubmVjdGlvbiB0aGF0IHRoaXMgbG9iYnkgY29udHJvbCB3aWxsIG1hbmlwdWxhdGUuXG4gICAqIEB0eXBlIHtOZXRTaW19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm5ldHNpbV8gPSBuZXRzaW07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmxldmVsS2V5XyA9IG9wdGlvbnMubGV2ZWxLZXk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaGFyZFNlbGVjdGlvblBhbmVsXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm5vZGVTZWxlY3Rpb25QYW5lbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltU2hhcmR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNoYXJkXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOZXRTaW1Mb2NhbENsaWVudE5vZGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm15Tm9kZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTdG9yYWdlIGZvciBPYnNlcnZhYmxlRXZlbnQgcmVnaXN0cmF0aW9uIGtleXMsIHRvIG1ha2Ugc3VyZSB3ZVxuICAgKiBjYW4gdW5yZWdpc3RlciBhcyBuZWVkZWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50S2V5cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7RGFzaGJvYXJkVXNlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudXNlcl8gPSBvcHRpb25zLnVzZXI7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRpc3BsYXlOYW1lXyA9IChvcHRpb25zLnVzZXIuaXNTaWduZWRJbikgPyBvcHRpb25zLnVzZXIubmFtZSA6ICcnO1xuXG4gIC8qKlxuICAgKiBTaGFyZCBvcHRpb25zIGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAqIEB0eXBlIHtTaGFyZENob2ljZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaGFyZENob2ljZXNfID0gW107XG5cbiAgLyoqXG4gICAqIFdoaWNoIHNoYXJkIElEIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zZWxlY3RlZFNoYXJkSURfID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTm9kZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ub2Rlc09uU2hhcmRfID0gW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOZXRTaW1Ob2RlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmluY29taW5nQ29ubmVjdGlvbk5vZGVzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVtb3RlTm9kZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgbXVsdGlwbGUgbWV0aG9kcyB0byBoYXZlIGEgJ2Rpc2FibGUnIGxvY2sgb24gdGhlIGxvYmJ5LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kaXNhYmxlRXZlcnl0aGluZ0tleXNfID0ge307XG5cbiAgLy8gRmlndXJlIG91dCB0aGUgbGlzdCBvZiB1c2VyIHNlY3Rpb25zLCB3aGljaCByZXF1aXJlcyBhbiBhc3luYyByZXF1ZXN0XG4gIC8vIGFuZCByZS1yZW5kZXIgaWYgdGhlIHVzZXIgaXMgc2lnbmVkIGluLlxuICBpZiAob3B0aW9ucy51c2VyLmlzU2lnbmVkSW4pIHtcbiAgICB0aGlzLmdldFVzZXJTZWN0aW9uc18oZnVuY3Rpb24gKHNlY3Rpb25MaXN0KSB7XG4gICAgICB0aGlzLmJ1aWxkU2hhcmRDaG9pY2VMaXN0XyhzZWN0aW9uTGlzdCwgb3B0aW9ucy5zaGFyZWRTaGFyZFNlZWQpO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnVpbGRTaGFyZENob2ljZUxpc3RfKFtdLCBvcHRpb25zLnNoYXJlZFNoYXJkU2VlZCk7XG4gIH1cblxuICAvLyBJbml0aWFsIHJlbmRlclxuICB0aGlzLnJlbmRlcigpO1xuXG4gIC8vIFJlZ2lzdGVyIGZvciBldmVudHNcbiAgdGhpcy5uZXRzaW1fLnNoYXJkQ2hhbmdlLnJlZ2lzdGVyKHRoaXMub25TaGFyZENoYW5nZV8uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFJlY3JlYXRlIG1hcmt1cCB3aXRoaW4gcGFuZWwgYm9keS5cbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlzQ29ubmVjdGVkVG9TaGFyZCA9ICh0aGlzLnNoYXJkXyAhPT0gbnVsbCk7XG4gIGlmICghaXNDb25uZWN0ZWRUb1NoYXJkKSB7XG5cbiAgICAvLyBTaGFyZCBzZWxlY3Rpb24gcGFuZWw6IENvbnRyb2xzIGZvciBzZXR0aW5nIGRpc3BsYXkgbmFtZSBhbmQgcGlja2luZ1xuICAgIC8vIGEgc2VjdGlvbiwgaWYgdGhleSBhcmVuJ3Qgc2V0IGF1dG9tYXRpY2FsbHkuXG4gICAgdGhpcy5zaGFyZFNlbGVjdGlvblBhbmVsXyA9IG5ldyBOZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsKFxuICAgICAgICB0aGlzLnJvb3REaXZfLFxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWVfLFxuICAgICAgICAgIHNoYXJkQ2hvaWNlczogdGhpcy5zaGFyZENob2ljZXNfLFxuICAgICAgICAgIHNlbGVjdGVkU2hhcmRJRDogdGhpcy5zZWxlY3RlZFNoYXJkSURfLFxuICAgICAgICAgIGRpc2FibGVDb250cm9sczogdGhpcy5pc0V2ZXJ5dGhpbmdEaXNhYmxlZCgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZXROYW1lQ2FsbGJhY2s6IHRoaXMuc2V0RGlzcGxheU5hbWUuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRTaGFyZENhbGxiYWNrOiB0aGlzLnNldFNoYXJkSUQuYmluZCh0aGlzKVxuICAgICAgICB9KTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gTm9kZSBzZWxlY3Rpb24gcGFuZWw6IFRoZSBsb2JieSBsaXN0IG9mIHdobyB3ZSBjYW4gY29ubmVjdCB0bywgYW5kXG4gICAgLy8gY29udHJvbHMgZm9yIHBpY2tpbmcgb25lIGFuZCBjb25uZWN0aW5nLlxuICAgIHRoaXMubm9kZVNlbGVjdGlvblBhbmVsXyA9IG5ldyBOZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwoXG4gICAgICAgIHRoaXMucm9vdERpdl8sXG4gICAgICAgIHtcbiAgICAgICAgICB1c2VyOiB0aGlzLnVzZXJfLFxuICAgICAgICAgIHNoYXJkSUQ6IHRoaXMuc2hhcmRfLmlkLFxuICAgICAgICAgIG5vZGVzT25TaGFyZDogdGhpcy5ub2Rlc09uU2hhcmRfLFxuICAgICAgICAgIGluY29taW5nQ29ubmVjdGlvbk5vZGVzOiB0aGlzLmluY29taW5nQ29ubmVjdGlvbk5vZGVzXyxcbiAgICAgICAgICByZW1vdGVOb2RlOiB0aGlzLnJlbW90ZU5vZGVfLFxuICAgICAgICAgIG15Tm9kZUlEOiB0aGlzLm15Tm9kZV8uZW50aXR5SUQsXG4gICAgICAgICAgZGlzYWJsZUNvbnRyb2xzOiB0aGlzLmlzRXZlcnl0aGluZ0Rpc2FibGVkKClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGFkZFJvdXRlckNhbGxiYWNrOiB0aGlzLmFkZFJvdXRlclRvTG9iYnkuYmluZCh0aGlzKSxcbiAgICAgICAgICBjYW5jZWxCdXR0b25DYWxsYmFjazogdGhpcy5vbkNhbmNlbEJ1dHRvbkNsaWNrXy5iaW5kKHRoaXMpLFxuICAgICAgICAgIGpvaW5CdXR0b25DYWxsYmFjazogdGhpcy5vbkpvaW5CdXR0b25DbGlja18uYmluZCh0aGlzKSxcbiAgICAgICAgICByZXNldFNoYXJkQ2FsbGJhY2s6IHRoaXMub25SZXNldFNoYXJkQnV0dG9uQ2xpY2tfLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG5cbiAgfVxuXG4gIHRoaXMubmV0c2ltXy5kZWJvdW5jZWRSZXNpemVGb290ZXIoKTtcbn07XG5cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm5vZGVTZWxlY3Rpb25QYW5lbF8pIHtcbiAgICB0aGlzLm5vZGVTZWxlY3Rpb25QYW5lbF8udXBkYXRlTGF5b3V0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BsYXlOYW1lXG4gKi9cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS5zZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICB0aGlzLmRpc3BsYXlOYW1lXyA9IGRpc3BsYXlOYW1lO1xuICB0aGlzLnJlbmRlcigpO1xuXG4gIGlmICh0aGlzLnNlbGVjdGVkU2hhcmRJRF8gJiYgdGhpcy5kaXNwbGF5TmFtZV8gJiZcbiAgICAgICF0aGlzLm5ldHNpbV8uaXNDb25uZWN0ZWRUb1NoYXJkSUQodGhpcy5zZWxlY3RlZFNoYXJkSURfKSkge1xuICAgIHRoaXMubmV0c2ltXy5jb25uZWN0VG9TaGFyZCh0aGlzLnNlbGVjdGVkU2hhcmRJRF8sIHRoaXMuZGlzcGxheU5hbWVfKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhcmRJRFxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUuc2V0U2hhcmRJRCA9IGZ1bmN0aW9uIChzaGFyZElEKSB7XG4gIHRoaXMuc2VsZWN0ZWRTaGFyZElEXyA9IHNoYXJkSUQ7XG4gIHRoaXMucmVuZGVyKCk7XG5cbiAgaWYgKHRoaXMuc2VsZWN0ZWRTaGFyZElEXyAmJiB0aGlzLmRpc3BsYXlOYW1lXyAmJlxuICAgICAgIXRoaXMubmV0c2ltXy5pc0Nvbm5lY3RlZFRvU2hhcmRJRCh0aGlzLnNlbGVjdGVkU2hhcmRJRF8pKSB7XG4gICAgdGhpcy5uZXRzaW1fLmNvbm5lY3RUb1NoYXJkKHRoaXMuc2VsZWN0ZWRTaGFyZElEXywgdGhpcy5kaXNwbGF5TmFtZV8pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0ge05ldFNpbUxvY2FsQ2xpZW50Tm9kZX0gbXlOb2RlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUub25TaGFyZENoYW5nZV8gPSBmdW5jdGlvbiAoc2hhcmQsIG15Tm9kZSkge1xuICAvLyBVbnJlZ2lzdGVyIG9sZCBoYW5kbGVyc1xuICBpZiAodGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFNoYXJkKSB7XG4gICAgdGhpcy5ldmVudEtleXMucmVnaXN0ZXJlZFNoYXJkLm5vZGVUYWJsZS50YWJsZUNoYW5nZS51bnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLmV2ZW50S2V5cy5ub2RlVGFibGUpO1xuICAgIHRoaXMuZXZlbnRLZXlzLnJlZ2lzdGVyZWRTaGFyZC53aXJlVGFibGUudGFibGVDaGFuZ2UudW5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5ldmVudEtleXMud2lyZVRhYmxlKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaGFyZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuc2hhcmRfID0gc2hhcmQ7XG4gIHRoaXMubXlOb2RlXyA9IG15Tm9kZTtcblxuICBpZiAodGhpcy5zaGFyZF8pIHtcbiAgICAvLyBXZSBnb3QgY29ubmVjdGVkIHRvIGEgc2hhcmQhXG4gICAgLy8gUmVnaXN0ZXIgZm9yIGV2ZW50c1xuICAgIHRoaXMuZXZlbnRLZXlzLm5vZGVUYWJsZSA9IHRoaXMuc2hhcmRfLm5vZGVUYWJsZS50YWJsZUNoYW5nZS5yZWdpc3RlcihcbiAgICAgICAgdGhpcy5vbk5vZGVUYWJsZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ldmVudEtleXMud2lyZVRhYmxlID0gdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnRhYmxlQ2hhbmdlLnJlZ2lzdGVyKFxuICAgICAgICB0aGlzLm9uV2lyZVRhYmxlQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV2ZW50S2V5cy5yZWdpc3RlcmVkU2hhcmQgPSB0aGlzLnNoYXJkXztcblxuICAgIC8vIFRyaWdnZXIgYSBmb3JjZWQgcmVhZCBvZiB0aGUgbm9kZSB0YWJsZVxuICAgIHRoaXMuZmV0Y2hJbml0aWFsTG9iYnlEYXRhXygpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlJ3ZlIGJlZW4gZGlzY29ubmVjdGVkIGZyb20gYSBzaGFyZFxuICAgIC8vIENsZWFyIG91ciBzZWxlY3RlZCBzaGFyZCBJRFxuICAgIHRoaXMuc2VsZWN0ZWRTaGFyZElEXyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIENsZWFyIGNhY2hlZCBsb2JieSBkYXRhXG4gICAgdGhpcy5ub2Rlc09uU2hhcmRfLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pbmNvbWluZ0Nvbm5lY3Rpb25Ob2Rlc18ubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHJhdyB0aGUgbG9iYnlcbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBvcHRpb24sIHRyeSB0byBhdXRvLXJlY29ubmVjdFxuICAgIGlmICh0aGlzLnNoYXJkQ2hvaWNlc18ubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnNldFNoYXJkSUQodGhpcy5zaGFyZENob2ljZXNfWzBdLnNoYXJkSUQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcG9uIGNvbm5lY3RpbmcgdG8gYSBuZXcgc2hhcmQsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIG1hbnVhbCByZWFkIG9mIHRoZVxuICogbm9kZSBhbmQgd2lyZSB0YWJsZXMgdG8gZW5zdXJlIG91ciBsb2JieSBsaXN0aW5nIGlzIGNvcnJlY3QuICBPdGhlcndpc2Ugd2UnZFxuICogaGF2ZSB0byB3YWl0IHVudGlsIGEgY2hhbmdlIHdhcyBkZXRlY3RlZCBpbiBvbmUgb2YgdGhvc2UgdGFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLmZldGNoSW5pdGlhbExvYmJ5RGF0YV8gPSBmdW5jdGlvbiAoKSB7XG4gICQud2hlbih0aGlzLnNoYXJkXy5ub2RlVGFibGUucmVmcmVzaCgpLCB0aGlzLnNoYXJkXy53aXJlVGFibGUucmVmcmVzaCgpKVxuICAgICAgLmZhaWwoZnVuY3Rpb24gKG5vZGVFcnIsIHdpcmVFcnIpIHtcbiAgICAgICAgaWYgKG5vZGVFcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignTm9kZSB0YWJsZSByZWZyZXNoIGZhaWxlZDogJyArIG5vZGVFcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpcmVFcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignV2lyZSB0YWJsZSByZWZyZXNoIGZhaWxlZDogJyArIHdpcmVFcnIpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpXG4gICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIGxvYmJ5IG1heSBub3QgZ2V0IHRhYmxlLWNoYW5nZSBldmVudHMgZnJvbSB0aGlzIHJlZnJlc2gsXG4gICAgICAgIC8vIG1hbnVhbGx5IHBhc3MgdGhlIGNhY2hlZCB0YWJsZSBjb250ZW50cyBpbi5cbiAgICAgICAgdGhpcy5vbk5vZGVUYWJsZUNoYW5nZV8oKTtcbiAgICAgICAgdGhpcy5vbldpcmVUYWJsZUNoYW5nZV8oKTtcblxuICAgICAgICAvLyBJZiB3ZSB1c2Ugcm91dGVycyBhbmQgdGhlcmUncyBubyByb3V0ZXIsIGNyZWF0ZSBhIHJvdXRlci5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGxvZ2ljIHRvIHRoZSBzZXJ2ZXIsIHNvbWVob3cuXG4gICAgICAgIGlmIChOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCkuY2FuQ29ubmVjdFRvUm91dGVycyAmJlxuICAgICAgICAgICAgIXRoaXMuZG9lc1NoYXJkQ29udGFpblJvdXRlcigpKSB7XG4gICAgICAgICAgdGhpcy5hZGRSb3V0ZXJUb0xvYmJ5KCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBjdXJyZW50bHkgY2FjaGVkIG5vZGUgZGF0YSBmb3IgdGhlIHNoYXJkXG4gKiAgICAgICAgICBpbmNsdWRlcyBhIHJvdXRlciBub2RlLlxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUuZG9lc1NoYXJkQ29udGFpblJvdXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHVuZGVmaW5lZCAhPT0gXy5maW5kKHRoaXMubm9kZXNPblNoYXJkXywgZnVuY3Rpb24gKHNoYXJkTm9kZSkge1xuICAgICAgICByZXR1cm4gc2hhcmROb2RlIGluc3RhbmNlb2YgTmV0U2ltUm91dGVyTm9kZTtcbiAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyByb3V0ZXIgbm9kZSwgY29uZmlndXJlZCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgbGV2ZWwuXG4gKiBUaGUgY2hhbmdlIHRvIHRoZSBub2RlIHRhYmxlIHNob3VsZCB0cmlnZ2VyIGFwcHJvcHJpYXRlIHVwZGF0ZXMgdG8gdmFyaW91c1xuICogVUkgZWxlbWVudHMuXG4gKi9cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS5hZGRSb3V0ZXJUb0xvYmJ5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW5hYmxlQ2FsbGJhY2sgPSB0aGlzLmRpc2FibGVFdmVyeXRoaW5nKCk7XG4gIE5ldFNpbVJvdXRlck5vZGUuY3JlYXRlKHRoaXMuc2hhcmRfLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgZW5hYmxlQ2FsbGJhY2soKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB2YXIgVmFsaWRhdGlvbkVycm9yID0gTmV0U2ltQXBpRXJyb3IuVmFsaWRhdGlvbkVycm9yO1xuICAgICAgc3dpdGNoIChlcnIuZGV0YWlscykge1xuICAgICAgICBjYXNlIFZhbGlkYXRpb25FcnJvci5DT05GTElDVDpcbiAgICAgICAgICAvLyBBbm90aGVyIHJvdXRlciB3aXRoIHRoZSBzYW1lIHJvdXRlck51bWJlciBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAvLyBJZ25vcmUgdGhpczsgdG8gdGhlIHVzZXIgaXQgbG9va3MgbGlrZSBpdCB3b3JrZWQhXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0RpZCBub3QgY3JlYXRlIHJvdXRlcjsgJyArXG4gICAgICAgICAgICAgICdBbm90aGVyIHVzZXIgY3JlYXRlZCBhIHJvdXRlciBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVmFsaWRhdGlvbkVycm9yLkxJTUlUX1JFQUNIRUQ6XG4gICAgICAgICAgLy8gVGhlIHNlcnZlcidzIHJvdXRlciBsaW1pdCBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAgIC8vIFVzdWFsbHkgdGhlIGNsaWVudCB3aWxsIHJlbW92ZSB0aGUgXCJBZGQgUm91dGVyXCIgYnV0dG9uIGZpcnN0LlxuICAgICAgICAgIGxvZ2dlci53YXJuKCdEaWQgbm90IGNyZWF0ZSByb3V0ZXI7IFJvdXRlciBsaW1pdCByZWFjaGVkLicpO1xuICAgICAgICAgIE5ldFNpbUFsZXJ0Lndhcm4oaTE4bi5yb3V0ZXJMaW1pdFJlYWNoZWRFcnJvcigpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIE1hbGZvcm1lZCByb3cgb3Igc29tZSBvdGhlciB1bmV4cGVjdGVkIGVycm9yLlxuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgcm91dGVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICBOZXRTaW1BbGVydC5lcnJvcihpMThuLmFkZFJvdXRlclRvTG9iYnlFcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIGFueXRoaW5nIGhhcyByZXF1ZXN0ZWQgdGhlIHdob2xlIGxvYmJ5IHRvIGJlXG4gKiAgICAgICAgICBkaXNhYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUuaXNFdmVyeXRoaW5nRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRpc2FibGVFdmVyeXRoaW5nS2V5c18pLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIERpc2FibGUgYWxsIG9mIHRoZSBsb2JieSBjb250cm9scyB0b2dldGhlci5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gQ2FsbGJhY2sgZm9yIHJlLWVuYWJsaW5nIHRoZSBsb2JieS5cbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLmRpc2FibGVFdmVyeXRoaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVxdWVzdEtleSA9IHV0aWxzLmNyZWF0ZVV1aWQoKTtcbiAgdGhpcy5kaXNhYmxlRXZlcnl0aGluZ0tleXNfW3JlcXVlc3RLZXldID0gdHJ1ZTtcblxuICBpZiAodGhpcy5ub2RlU2VsZWN0aW9uUGFuZWxfKSB7XG4gICAgdGhpcy5ub2RlU2VsZWN0aW9uUGFuZWxfLmRpc2FibGVFdmVyeXRoaW5nKCk7XG4gIH1cblxuICAvLyBSZXR1cm4gYW4gJ2VuYWJsZScgY2FsbGJhY2tcbiAgcmV0dXJuIHRoaXMuZW5hYmxlRXZlcnl0aGluZ18uYmluZCh0aGlzLCByZXF1ZXN0S2V5KTtcbn07XG5cbi8qKlxuICogUmVsZWFzZSBhICdkaXNhYmxlLWhvbGQnIG9uIHRoZSBsb2JieSBhbmQgcmUtZW5hYmxlIHRoZSBsb2JieSBjb250cm9scyBpZlxuICogaXQgd2FzIHRoZSBsYXN0IHN1Y2ggZGlzYWJsZS1ob2xkLlxuICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHBhcnRpY3VsYXIgZGlzYWJsZSByZXF1ZXN0LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLmVuYWJsZUV2ZXJ5dGhpbmdfID0gZnVuY3Rpb24gKGtleSkge1xuICBkZWxldGUgdGhpcy5kaXNhYmxlRXZlcnl0aGluZ0tleXNfW2tleV07XG4gIGlmICghdGhpcy5pc0V2ZXJ5dGhpbmdEaXNhYmxlZCgpKSB7XG4gICAgaWYgKHRoaXMubm9kZVNlbGVjdGlvblBhbmVsXykge1xuICAgICAgdGhpcy5ub2RlU2VsZWN0aW9uUGFuZWxfLmVuYWJsZUV2ZXJ5dGhpbmcoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgY2xpY2tpbmcgdGhlIFwiSm9pblwiIGJ1dHRvbi5cbiAqIEBwYXJhbSB7TmV0U2ltQ2xpZW50Tm9kZXxOZXRTaW1Sb3V0ZXJOb2RlfSBub2RlVG9Kb2luXG4gKi9cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS5vbkpvaW5CdXR0b25DbGlja18gPSBmdW5jdGlvbiAobm9kZVRvSm9pbikge1xuICB2YXIgZW5hYmxlQ2FsbGJhY2sgPSB0aGlzLmRpc2FibGVFdmVyeXRoaW5nKCk7XG4gIGlmIChub2RlVG9Kb2luIGluc3RhbmNlb2YgTmV0U2ltUm91dGVyTm9kZSkge1xuICAgIHRoaXMubmV0c2ltXy5jb25uZWN0VG9Sb3V0ZXIobm9kZVRvSm9pbi5lbnRpdHlJRCwgZW5hYmxlQ2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKG5vZGVUb0pvaW4gaW5zdGFuY2VvZiBOZXRTaW1DbGllbnROb2RlKSB7XG4gICAgdGhpcy5teU5vZGVfLmNvbm5lY3RUb0NsaWVudChub2RlVG9Kb2luLCBlbmFibGVDYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgY2xpY2tpbmcgdGhlIFwiQ2FuY2VsXCIgYnV0dG9uIHRvIHN0b3AgdHJ5aW5nIHRvIGNvbm5lY3QgdG9cbiAqIGFub3RoZXIgY2xpZW50LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLm9uQ2FuY2VsQnV0dG9uQ2xpY2tfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW5hYmxlQ2FsbGJhY2sgPSB0aGlzLmRpc2FibGVFdmVyeXRoaW5nKCk7XG4gIHRoaXMubmV0c2ltXy5kaXNjb25uZWN0RnJvbVJlbW90ZShlbmFibGVDYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBmb3IgY2xpY2tpbmcgdGhlIHJlc2V0IHNoYXJkIGJ1dHRvbi5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS5vblJlc2V0U2hhcmRCdXR0b25DbGlja18gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubmV0c2ltXy5yZXNldFNoYXJkKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuZXZlciBhIGNoYW5nZSBpcyBkZXRlY3RlZCBpbiB0aGUgbm9kZXMgdGFibGUgLSB3aGljaCBzaG91bGRcbiAqIHRyaWdnZXIgYSByZWZyZXNoIG9mIHRoZSBsb2JieSBsaXN0aW5nXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUub25Ob2RlVGFibGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzT25TaGFyZF8gPSBOZXRTaW1Ob2RlRmFjdG9yeS5ub2Rlc0Zyb21Sb3dzKHRoaXMuc2hhcmRfLFxuICAgICAgdGhpcy5zaGFyZF8ubm9kZVRhYmxlLnJlYWRBbGwoKSk7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuZXZlciBhIGNoYW5nZSBpcyBkZXRlY3RlZCBpbiB0aGUgd2lyZXMgdGFibGUuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUub25XaXJlVGFibGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcm93cyA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWFkQWxsKCk7XG4gIC8vIFVwZGF0ZSB0aGUgY29sbGVjdGlvbiBvZiBub2RlcyB3aXRoIGNvbm5lY3Rpb25zIHBvaW50aW5nIHRvd2FyZCB1cy5cbiAgdGhpcy5pbmNvbWluZ0Nvbm5lY3Rpb25Ob2Rlc18gPSByb3dzLmZpbHRlcihmdW5jdGlvbiAod2lyZVJvdykge1xuICAgIHJldHVybiB3aXJlUm93LnJlbW90ZU5vZGVJRCA9PT0gdGhpcy5teU5vZGVfLmVudGl0eUlEO1xuICB9LCB0aGlzKS5tYXAoZnVuY3Rpb24gKHdpcmVSb3cpIHtcbiAgICByZXR1cm4gXy5maW5kKHRoaXMubm9kZXNPblNoYXJkXywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmVudGl0eUlEID09PSB3aXJlUm93LmxvY2FsTm9kZUlEO1xuICAgIH0pO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBJbiBjYXNlIHRoZSB3aXJlIHRhYmxlIGNoYW5nZSBjb21lcyBpbiBiZWZvcmUgdGhlIG5vZGUgdGFibGUgY2hhbmdlLlxuICAgIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIC8vIEZpbmQgb3V0Z29pbmcgd2lyZXNcbiAgdmFyIG91dGdvaW5nV2lyZVJvdyA9IF8uZmluZChyb3dzLCBmdW5jdGlvbiAod2lyZVJvdykge1xuICAgIHJldHVybiB3aXJlUm93LmxvY2FsTm9kZUlEID09PSB0aGlzLm15Tm9kZV8uZW50aXR5SUQ7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5yZW1vdGVOb2RlXyA9IG91dGdvaW5nV2lyZVJvdyA/XG4gICAgICBfLmZpbmQodGhpcy5ub2Rlc09uU2hhcmRfLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbnRpdHlJRCA9PT0gb3V0Z29pbmdXaXJlUm93LnJlbW90ZU5vZGVJRDtcbiAgICAgIH0pIDogbnVsbDtcblxuICAvLyBSZS1yZW5kZXIgd2l0aCBuZXcgaW5mb3JtYXRpb25cbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cblxuLyoqXG4gKiBTZW5kIGEgcmVxdWVzdCB0byBkYXNoYm9hcmQgYW5kIHJldHJpZXZlIGEgSlNPTiBhcnJheSBsaXN0aW5nIHRoZVxuICogc2VjdGlvbnMgdGhpcyB1c2VyIGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLmdldFVzZXJTZWN0aW9uc18gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIG1lbWJlclNlY3Rpb25zUmVxdWVzdCA9ICQuYWpheCh7XG4gICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICB1cmw6ICcvdjIvc2VjdGlvbnMvbWVtYmVyc2hpcCdcbiAgfSk7XG5cbiAgdmFyIG93bmVkU2VjdGlvbnNSZXF1ZXN0ID0gJC5hamF4KHtcbiAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgIHVybDogJy92Mi9zZWN0aW9ucydcbiAgfSk7XG5cbiAgJC53aGVuKG1lbWJlclNlY3Rpb25zUmVxdWVzdCwgb3duZWRTZWN0aW9uc1JlcXVlc3QpLmRvbmUoZnVuY3Rpb24gKHJlc3VsdDEsIHJlc3VsdDIpIHtcbiAgICB2YXIgbWVtYmVyU2VjdGlvbkRhdGEgPSByZXN1bHQxWzBdO1xuICAgIHZhciBvd25lZFNlY3Rpb25EYXRhID0gcmVzdWx0MlswXTtcbiAgICBjYWxsYmFjayhtZW1iZXJTZWN0aW9uRGF0YS5jb25jYXQob3duZWRTZWN0aW9uRGF0YSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUG9wdWxhdGUgdGhlIGludGVybmFsIGNhY2hlIG9mIHNoYXJkIG9wdGlvbnMsIGdpdmVuIGEgc2V0IG9mIHRoZSBjdXJyZW50XG4gKiB1c2VyJ3Mgc2VjdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBzZWN0aW9uTGlzdCAtIGxpc3Qgb2Ygc2VjdGlvbnMgdGhpcyB1c2VyIGlzIGEgbWVtYmVyIG9yXG4gKiAgICAgICAgYWRtaW5pc3RyYXRvciBvZi4gIEVhY2ggc2VjdGlvbiBoYXMgYW4gaWQgYW5kIGEgbmFtZS4gIE1heSBiZSBlbXB0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFyZWRTaGFyZFNlZWQgLSBhIHNoYXJkIElEIHByZXNlbnQgaWYgd2UgcmVhY2hlZCBuZXRzaW1cbiAqICAgICAgICB2aWEgYSBzaGFyZSBsaW5rLiAgV2Ugc2hvdWxkIG1ha2Ugc3VyZSB0aGlzIHNoYXJkIGlzIGFuIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbUxvYmJ5LnByb3RvdHlwZS5idWlsZFNoYXJkQ2hvaWNlTGlzdF8gPSBmdW5jdGlvbiAoXG4gICAgc2VjdGlvbkxpc3QsIHNoYXJlZFNoYXJkU2VlZCkge1xuICB0aGlzLnNoYXJkQ2hvaWNlc18ubGVuZ3RoID0gMDtcblxuICAvLyBJZiB3ZSBoYXZlIGEgc2hhcmVkIHNoYXJkIHNlZWQsIHB1dCBpdCBmaXJzdCBpbiB0aGUgbGlzdDpcbiAgaWYgKHNoYXJlZFNoYXJkU2VlZCkge1xuICAgIHZhciBzaGFyZWRTaGFyZElEID0gdGhpcy5tYWtlU2hhcmRJREZyb21TZWVkXyhzaGFyZWRTaGFyZFNlZWQpO1xuICAgIHRoaXMuc2hhcmRDaG9pY2VzXy5wdXNoKHtcbiAgICAgIHNoYXJkU2VlZDogc2hhcmVkU2hhcmRTZWVkLFxuICAgICAgc2hhcmRJRDogc2hhcmVkU2hhcmRJRCxcbiAgICAgIGRpc3BsYXlOYW1lOiBzaGFyZWRTaGFyZFNlZWRcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCB1c2VyJ3Mgc2VjdGlvbnMgdG8gdGhlIHNoYXJkIGxpc3RcbiAgdGhpcy5zaGFyZENob2ljZXNfID0gdGhpcy5zaGFyZENob2ljZXNfLmNvbmNhdChcbiAgICAgIHNlY3Rpb25MaXN0Lm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNoYXJkU2VlZDogc2VjdGlvbi5pZCxcbiAgICAgICAgICBzaGFyZElEOiB0aGlzLm1ha2VTaGFyZElERnJvbVNlZWRfKHNlY3Rpb24uaWQpLFxuICAgICAgICAgIGRpc3BsYXlOYW1lOiBzZWN0aW9uLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0uYmluZCh0aGlzKSkpO1xuXG4gIC8vIElmIHRoZXJlIHN0aWxsIGFyZW4ndCBhbnkgb3B0aW9ucywgZ2VuZXJhdGUgYSByYW5kb20gc2hhcmRcbiAgaWYgKHRoaXMuc2hhcmRDaG9pY2VzXy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgc2VlZCA9IHV0aWxzLmNyZWF0ZVV1aWQoKTtcbiAgICB2YXIgcmFuZG9tU2hhcmRJRCA9IHRoaXMubWFrZVNoYXJkSURGcm9tU2VlZF8oc2VlZCk7XG4gICAgdGhpcy5zaGFyZENob2ljZXNfLnB1c2goe1xuICAgICAgc2hhcmRTZWVkOiBzZWVkLFxuICAgICAgc2hhcmRJRDogcmFuZG9tU2hhcmRJRCxcbiAgICAgIGRpc3BsYXlOYW1lOiBpMThuLm15UHJpdmF0ZU5ldHdvcmsoKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBwb3NzaWJsZSBzaGFyZCwgc2VsZWN0IGl0IGJ5IGRlZmF1bHRcbiAgaWYgKHRoaXMuc2hhcmRDaG9pY2VzXy5sZW5ndGggPT09IDEgJiYgIXRoaXMuc2VsZWN0ZWRTaGFyZElEXykge1xuICAgIHRoaXMuc2V0U2hhcmRJRCh0aGlzLnNoYXJkQ2hvaWNlc19bMF0uc2hhcmRJRCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgc2hhcmQga2V5IGZyb20gdGhlIGdpdmVuIHNlZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Mb2JieS5wcm90b3R5cGUubWFrZVNoYXJkSURGcm9tU2VlZF8gPSBmdW5jdGlvbiAoc2VlZCkge1xuICAvLyBUT0RPIChiYnVjaGFuYW4pIDogSGFzaCBzaGFyZCBJRCwgbW9yZSBsaWtlbHkgdG8gZW5zdXJlIGl0J3MgdW5pcXVlXG4gIC8vICAgICAgICAgICAgICAgICAgICBhbmQgZml0cyB3aXRoaW4gNDggY2hhcmFjdGVycy5cbiAgLy8gTWF5YmUgZ3JhYiB0aGlzIE1JVC1saWNlbnNlZCBpbXBsZW1lbnRhdGlvbiB2aWEgbm9kZT9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAgcmV0dXJuICgnbnNfJyArIHRoaXMubGV2ZWxLZXlfICsgJ18nICsgc2VlZCkuc3Vic3RyKDAsIDQ4KTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNoYXJlIFVSTCBmb3IgdGhlIGN1cnJlbnRseS1zZWxlY3RlZCBzaGFyZCBJRC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IG9yIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBzaGFyZCBzZWxlY3RlZC5cbiAqL1xuTmV0U2ltTG9iYnkucHJvdG90eXBlLmdldFNoYXJlTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXlOYW1lXykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBzZWxlY3RlZFNoYXJkID0gXy5maW5kKHRoaXMuc2hhcmRDaG9pY2VzXywgZnVuY3Rpb24gKHNoYXJkKSB7XG4gICAgcmV0dXJuIHNoYXJkLnNoYXJkSUQgPT09IHRoaXMuc2VsZWN0ZWRTaGFyZElEXztcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAoc2VsZWN0ZWRTaGFyZCkge1xuICAgIHZhciBiYXNlTG9jYXRpb24gPSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgK1xuICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5ob3N0ICsgZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgcmV0dXJuIGJhc2VMb2NhdGlvbiArICc/cz0nICsgc2VsZWN0ZWRTaGFyZC5zaGFyZFNlZWQ7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgTG9iYnkgVUkgY29tcG9uZW50IHVzZWQgZm9yIG5hbWUgZW50cnkgYW5kIHNlbGVjdGluZyBhIHNoYXJkL2NsYXNzXG4gKiAgICAgICAgICAgc2VjdGlvbi5cbiAqIEBzZWUgTmV0U2ltTG9iYnkgZm9yIHVzYWdlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwuaHRtbC5lanMnKTtcbnZhciBOZXRTaW1QYW5lbCA9IHJlcXVpcmUoJy4vTmV0U2ltUGFuZWwnKTtcblxudmFyIEtleUNvZGVzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuS2V5Q29kZXM7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG52YXIgU0VMRUNUT1JfTk9ORV9WQUxVRSA9ICcnO1xuXG4vKipcbiAqIEdlbmVyYXRvciBhbmQgY29udHJvbGxlciBmb3IgbWVzc2FnZSBsb2cuXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXZcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGlzcGxheU5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2hhcmRDaG9pY2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZWxlY3RlZFNoYXJkSURcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3Muc2V0TmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3Muc2V0U2hhcmRDYWxsYmFja1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbVBhbmVsXG4gKi9cbnZhciBOZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdiwgb3B0aW9ucyxcbiAgICBjYWxsYmFja3MpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRpc3BsYXlOYW1lXyA9IG9wdGlvbnMuZGlzcGxheU5hbWU7XG5cbiAgLyoqXG4gICAqIFNoYXJkIG9wdGlvbnMgZm9yIHRoZSBjdXJyZW50IHVzZXJcbiAgICogQHR5cGUge1NoYXJkQ2hvaWNlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNoYXJkQ2hvaWNlc18gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMuc2hhcmRDaG9pY2VzLCBbXSk7XG5cbiAgLyoqXG4gICAqIFdoaWNoIHNoYXJkIElEIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zZWxlY3RlZFNoYXJkSURfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLnNlbGVjdGVkU2hhcmRJRCwgU0VMRUNUT1JfTk9ORV9WQUxVRSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc2V0TmFtZUNhbGxiYWNrXyA9IGNhbGxiYWNrcy5zZXROYW1lQ2FsbGJhY2s7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc2V0U2hhcmRDYWxsYmFja18gPSBjYWxsYmFja3Muc2V0U2hhcmRDYWxsYmFjaztcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICBOZXRTaW1QYW5lbC5jYWxsKHRoaXMsIHJvb3REaXYsIHtcbiAgICBjbGFzc05hbWU6ICduZXRzaW0tc2hhcmQtc2VsZWN0aW9uLXBhbmVsJyxcbiAgICBwYW5lbFRpdGxlOiBpMThuLnBpY2tBU2VjdGlvbigpLFxuICAgIHVzZXJUb2dnbGVhYmxlOiBmYWxzZVxuICB9KTtcbn07XG5OZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsLmluaGVyaXRzKE5ldFNpbVBhbmVsKTtcblxuLyoqXG4gKiBSZWNyZWF0ZSBtYXJrdXAgd2l0aGluIHBhbmVsIGJvZHkuXG4gKi9cbk5ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ3JlYXRlIGJvaWxlcnBsYXRlIHBhbmVsIG1hcmt1cFxuICBOZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsLnN1cGVyUHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIEFkZCBvdXIgb3duIGNvbnRlbnQgbWFya3VwXG4gIHZhciBuZXdNYXJrdXAgPSAkKG1hcmt1cCh7XG4gICAgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWVfLFxuICAgIHNlbGVjdGVkU2hhcmRJRDogdGhpcy5zZWxlY3RlZFNoYXJkSURfLFxuICAgIHNoYXJkQ2hvaWNlczogdGhpcy5zaGFyZENob2ljZXNfLFxuICAgIFNFTEVDVE9SX05PTkVfVkFMVUU6IFNFTEVDVE9SX05PTkVfVkFMVUVcbiAgfSkpO1xuICB0aGlzLmdldEJvZHkoKS5odG1sKG5ld01hcmt1cCk7XG5cbiAgLy8gQmluZCBoYW5kbGVyc1xuICB2YXIgbmFtZUZpZWxkID0gdGhpcy5nZXRCb2R5KCkuZmluZCgnI25ldHNpbS1sb2JieS1uYW1lJyk7XG4gIG5hbWVGaWVsZC5rZXl1cCh0aGlzLm9uTmFtZUtleVVwXy5iaW5kKHRoaXMpKTtcblxuICB2YXIgc2V0TmFtZUJ1dHRvbiA9IHRoaXMuZ2V0Qm9keSgpLmZpbmQoJyNuZXRzaW0tbG9iYnktc2V0LW5hbWUtYnV0dG9uJyk7XG4gIHNldE5hbWVCdXR0b24uY2xpY2sodGhpcy5zZXROYW1lQnV0dG9uQ2xpY2tfLmJpbmQodGhpcykpO1xuXG4gIHZhciBzaGFyZFNlbGVjdCA9IHRoaXMuZ2V0Qm9keSgpLmZpbmQoJyNuZXRzaW0tc2hhcmQtc2VsZWN0Jyk7XG4gIHNoYXJkU2VsZWN0LmNoYW5nZSh0aGlzLm9uU2hhcmRTZWxlY3RDaGFuZ2VfLmJpbmQodGhpcykpO1xuICBzaGFyZFNlbGVjdC5rZXl1cCh0aGlzLm9uU2hhcmRTZWxlY3RLZXlVcF8uYmluZCh0aGlzKSk7XG5cbiAgdmFyIHNldFNoYXJkQnV0dG9uID0gdGhpcy5nZXRCb2R5KCkuZmluZCgnI25ldHNpbS1zaGFyZC1jb25maXJtLWJ1dHRvbicpO1xuICBzZXRTaGFyZEJ1dHRvbi5jbGljayh0aGlzLnNldFNoYXJkQnV0dG9uQ2xpY2tfLmJpbmQodGhpcykpO1xuXG4gIC8vIEF0IHRoZSBlbmQgb2YgYW55IHJlbmRlciB3ZSBzaG91bGQgZm9jdXMgb24gdGhlIGVhcmxpZXN0IHVuc2F0aXNmaWVkXG4gIC8vIGZpZWxkLCBvciBpZiBhbGwgZmllbGRzIGFyZSBzYXRpc2ZpZWQsIHRyeSBjb25uZWN0aW5nIHRvIHRoZSBzcGVjaWZpZWRcbiAgLy8gc2hhcmQuXG4gIGlmICh0aGlzLmRpc3BsYXlOYW1lXy5sZW5ndGggPT09IDApIHtcbiAgICBuYW1lRmllbGQuZm9jdXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkU2hhcmRJRF8gPT09IFNFTEVDVE9SX05PTkVfVkFMVUUpIHtcbiAgICBzaGFyZFNlbGVjdC5mb2N1cygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGpRdWVyeUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5vbk5hbWVLZXlVcF8gPSBmdW5jdGlvbiAoalF1ZXJ5RXZlbnQpIHtcbiAgdmFyIG5hbWUgPSBqUXVlcnlFdmVudC50YXJnZXQudmFsdWU7XG4gIHZhciBzZXROYW1lQnV0dG9uID0gdGhpcy5nZXRCb2R5KCkuZmluZCgnI25ldHNpbS1sb2JieS1zZXQtbmFtZS1idXR0b24nKTtcbiAgc2V0TmFtZUJ1dHRvbi5hdHRyKCdkaXNhYmxlZCcsIG5hbWUubGVuZ3RoID09PSAwKTtcblxuICBpZiAobmFtZS5sZW5ndGggPiAwICYmIGpRdWVyeUV2ZW50LndoaWNoID09PSBLZXlDb2Rlcy5FTlRFUikge1xuICAgIHRoaXMuc2V0TmFtZUJ1dHRvbkNsaWNrXygpO1xuICB9XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbk5ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwucHJvdG90eXBlLnNldE5hbWVCdXR0b25DbGlja18gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0TmFtZUNhbGxiYWNrXyh0aGlzLmdldEJvZHkoKS5maW5kKCcjbmV0c2ltLWxvYmJ5LW5hbWUnKS52YWwoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGpRdWVyeUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TaGFyZFNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5vblNoYXJkU2VsZWN0Q2hhbmdlXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgc2hhcmRJRCA9IGpRdWVyeUV2ZW50LnRhcmdldC52YWx1ZTtcbiAgdmFyIHNldFNoYXJkQnV0dG9uID0gdGhpcy5nZXRCb2R5KCkuZmluZCgnI25ldHNpbS1zaGFyZC1jb25maXJtLWJ1dHRvbicpO1xuICBzZXRTaGFyZEJ1dHRvbi5hdHRyKCdkaXNhYmxlZCcsICFzaGFyZElEIHx8IHNoYXJkSUQgPT09IFNFTEVDVE9SX05PTkVfVkFMVUUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fSBqUXVlcnlFdmVudFxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltU2hhcmRTZWxlY3Rpb25QYW5lbC5wcm90b3R5cGUub25TaGFyZFNlbGVjdEtleVVwXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgc2hhcmRJRCA9IGpRdWVyeUV2ZW50LnRhcmdldC52YWx1ZTtcbiAgaWYgKHNoYXJkSUQgJiYgc2hhcmRJRCAhPT0gU0VMRUNUT1JfTk9ORV9WQUxVRSAmJlxuICAgICAgalF1ZXJ5RXZlbnQud2hpY2ggPT09IEtleUNvZGVzLkVOVEVSKSB7XG4gICAgdGhpcy5zZXRTaGFyZEJ1dHRvbkNsaWNrXygpO1xuICB9XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbk5ldFNpbVNoYXJkU2VsZWN0aW9uUGFuZWwucHJvdG90eXBlLnNldFNoYXJkQnV0dG9uQ2xpY2tfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldFNoYXJkQ2FsbGJhY2tfKHRoaXMuZ2V0Qm9keSgpLmZpbmQoJyNuZXRzaW0tc2hhcmQtc2VsZWN0JykudmFsKCkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbiAgdmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cImNvbnRlbnQtd3JhcFwiPlxcbiAgPGRpdiBjbGFzcz1cImZpZWxkLWJveCBkaXNwbGF5LW5hbWUtY29udHJvbFwiPlxcbiAgICA8bGFiZWwgZm9yPVwibmV0c2ltLWxvYmJ5LW5hbWVcIj4nLCBlc2NhcGUoKDYsICBpMThuLm15TmFtZSgpICkpLCAnPC9sYWJlbD5cXG4gICAgPGlucHV0IGlkPVwibmV0c2ltLWxvYmJ5LW5hbWVcIiB0eXBlPVwidGV4dFwiIHZhbHVlPVwiJywgZXNjYXBlKCg3LCAgZGlzcGxheU5hbWUgKSksICdcIiAnKTs3OyBpZiAoZGlzcGxheU5hbWUubGVuZ3RoID4gMCkgeyA7IGJ1Zi5wdXNoKCdkaXNhYmxlZCcpOzc7IH0gOyBidWYucHVzaCgnIC8+XFxuICAgICcpOzg7IGlmIChkaXNwbGF5TmFtZS5sZW5ndGggPT09IDApIHsgOyBidWYucHVzaCgnXFxuICAgICAgPGlucHV0IGlkPVwibmV0c2ltLWxvYmJ5LXNldC1uYW1lLWJ1dHRvblwiIHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIicsIGVzY2FwZSgoOSwgIGkxOG4uc2V0TmFtZSgpICkpLCAnXCIgZGlzYWJsZWQgLz5cXG4gICAgJyk7MTA7IH0gOyBidWYucHVzaCgnXFxuICA8L2Rpdj5cXG4gICcpOzEyOyBpZiAoZGlzcGxheU5hbWUubGVuZ3RoID4gMCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBjbGFzcz1cImZpZWxkLWJveCBzaGFyZC1jb250cm9sXCI+XFxuICAgICAgPGxhYmVsIGZvcj1cIm5ldHNpbS1zaGFyZC1zZWxlY3RcIj4nLCBlc2NhcGUoKDE0LCAgaTE4bi5teVNlY3Rpb24oKSApKSwgJzwvbGFiZWw+XFxuICAgICAgPHNlbGVjdCBpZD1cIm5ldHNpbS1zaGFyZC1zZWxlY3RcIiAnKTsxNTsgaWYgKHNlbGVjdGVkU2hhcmRJRCkgeyA7IGJ1Zi5wdXNoKCdkaXNhYmxlZCcpOzE1OyB9IDsgYnVmLnB1c2goJz5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCInLCBlc2NhcGUoKDE2LCAgU0VMRUNUT1JfTk9ORV9WQUxVRSApKSwgJ1wiPicsIGVzY2FwZSgoMTYsICBpMThuLmRyb3Bkb3duUGlja09uZSgpICkpLCAnPC9vcHRpb24+XFxuICAgICAgICAnKTsxNztcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRBbnlTaGFyZCA9IGZhbHNlO1xuICAgICAgICAgIHNoYXJkQ2hvaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFyZENob2ljZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAnJztcbiAgICAgICAgICAgIGlmIChzaGFyZENob2ljZS5zaGFyZElEID09PSBzZWxlY3RlZFNoYXJkSUQpIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlcyA9ICdzZWxlY3RlZCc7XG4gICAgICAgICAgICAgIHNlbGVjdGVkQW55U2hhcmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBidWYucHVzaCgnXFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJywgZXNjYXBlKCgyNiwgIHNoYXJkQ2hvaWNlLnNoYXJkSUQgKSksICdcIiAnLCBlc2NhcGUoKDI2LCAgYXR0cmlidXRlcyApKSwgJz4nLCBlc2NhcGUoKDI2LCAgc2hhcmRDaG9pY2UuZGlzcGxheU5hbWUgKSksICc8L29wdGlvbj5cXG4gICAgICAgICAgICAnKTsyNztcbiAgICAgICAgICB9KTtcbiAgICAgICAgOyBidWYucHVzaCgnXFxuICAgICAgPC9zZWxlY3Q+XFxuICAgICAgJyk7MzE7IGlmICghc2VsZWN0ZWRTaGFyZElEKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPGlucHV0IGlkPVwibmV0c2ltLXNoYXJkLWNvbmZpcm0tYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiJywgZXNjYXBlKCgzMiwgIGkxOG4uam9pblNlY3Rpb24oKSApKSwgJ1wiICcpOzMyOyBpZiAoIXNlbGVjdGVkQW55U2hhcmQpIHsgOyBidWYucHVzaCgnZGlzYWJsZWQnKTszMjsgfSA7IGJ1Zi5wdXNoKCcgLz5cXG4gICAgICAnKTszMzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgPC9kaXY+XFxuICAnKTszNTsgfSA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IExvYmJ5IHRhYmxlIFVJIGNvbXBvbmVudC5cbiAqIEBzZWUgTmV0U2ltTG9iYnkgZm9yIHVzYWdlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltUGFuZWwgPSByZXF1aXJlKCcuL05ldFNpbVBhbmVsJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwuaHRtbC5lanMnKTtcbnZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuTm9kZVR5cGU7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIE5ldFNpbVJvdXRlck5vZGUgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlck5vZGUnKTtcblxuLyoqXG4gKiBBcHBseSBhIHZlcnkgc21hbGwgZGVib3VuY2UgdG8gbG9iYnkgYnV0dG9ucyB0byBhdm9pZCBkb2luZyBleHRyYSB3b3JrXG4gKiBhcyBhIHJlc3VsdCBvZiBkb3VibGUtY2xpY2tzIGFuZC9vciBzY3JpcHRzIHRoYXQgd2FudCB0byBjbGljayBidXR0b25zIGFcbiAqIGZldyB0aG91c2FuZCB0aW1lcy5cbiAqIEBjb25zdCB7bnVtYmVyfVxuICovXG52YXIgQlVUVE9OX0RFQk9VTkNFX0RVUkFUSU9OX01TID0gMTAwO1xuXG4vKipcbiAqIEdlbmVyYXRvciBhbmQgY29udHJvbGxlciBmb3IgbG9iYnkgbm9kZSBsaXN0aW5nLCBzZWxlY3Rpb24sIGFuZCBjb25uZWN0aW9uXG4gKiBjb250cm9scy5cbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Rhc2hib2FyZFVzZXJ9IG9wdGlvbnMudXNlclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2hhcmRJRFxuICogQHBhcmFtIHtOZXRTaW1Ob2RlW119IG9wdGlvbnMubm9kZXNPblNoYXJkXG4gKiBAcGFyYW0ge05ldFNpbU5vZGVbXX0gb3B0aW9ucy5pbmNvbWluZ0Nvbm5lY3Rpb25Ob2Rlc1xuICogQHBhcmFtIHtOZXRTaW1Ob2RlfSBvcHRpb25zLnJlbW90ZU5vZGUgLSBudWxsIGlmIG5vdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm15Tm9kZUlEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZGlzYWJsZUNvbnRyb2xzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmFkZFJvdXRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuY2FuY2VsQnV0dG9uQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5qb2luQnV0dG9uQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5yZXNldFNoYXJkQ2FsbGJhY2tcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1QYW5lbFxuICovXG52YXIgTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdixcbiAgICBvcHRpb25zLCBjYWxsYmFja3MpIHtcblxuICAvKipcbiAgICogQHR5cGUge0Rhc2hib2FyZFVzZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnVzZXJfID0gb3B0aW9ucy51c2VyO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaGFyZElEXyA9IG9wdGlvbnMuc2hhcmRJRDtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbU5vZGVbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubm9kZXNPblNoYXJkXyA9IG9wdGlvbnMubm9kZXNPblNoYXJkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTm9kZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pbmNvbWluZ0Nvbm5lY3Rpb25Ob2Rlc18gPSBvcHRpb25zLmluY29taW5nQ29ubmVjdGlvbk5vZGVzO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltTm9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVtb3RlTm9kZV8gPSBvcHRpb25zLnJlbW90ZU5vZGU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm15Tm9kZUlEXyA9IG9wdGlvbnMubXlOb2RlSUQ7XG5cbiAgZnVuY3Rpb24gYnV0dG9uRGVib3VuY2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gXy5kZWJvdW5jZShjYWxsYmFjaywgQlVUVE9OX0RFQk9VTkNFX0RVUkFUSU9OX01TLCB7XG4gICAgICBsZWFkaW5nOiB0cnVlLFxuICAgICAgdHJhaWxpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgXCJBZGQgUm91dGVyXCIgYnV0dG9uXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYWRkUm91dGVyQ2FsbGJhY2tfID0gYnV0dG9uRGVib3VuY2UoY2FsbGJhY2tzLmFkZFJvdXRlckNhbGxiYWNrKTtcblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgY2FuY2VsIGJ1dHRvbiAoYmFja3Mgb3V0IG9mIG5vbi1tdXR1YWwgY29ubmVjdGlvbilcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jYW5jZWxCdXR0b25DYWxsYmFja18gPSBidXR0b25EZWJvdW5jZShjYWxsYmFja3MuY2FuY2VsQnV0dG9uQ2FsbGJhY2spO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciBcImpvaW5cIiBidXR0b24gbmV4dCB0byBlYWNoIGNvbm5lY3RhYmxlIG5vZGUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuam9pbkJ1dHRvbkNhbGxiYWNrXyA9IGJ1dHRvbkRlYm91bmNlKGNhbGxiYWNrcy5qb2luQnV0dG9uQ2FsbGJhY2spO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciBcInJlc2V0IHNoYXJkXCIgYnV0dG9uIGNsaWNrLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlc2V0U2hhcmRDYWxsYmFja18gPSBidXR0b25EZWJvdW5jZShjYWxsYmFja3MucmVzZXRTaGFyZENhbGxiYWNrKTtcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICBOZXRTaW1QYW5lbC5jYWxsKHRoaXMsIHJvb3REaXYsIHtcbiAgICBjbGFzc05hbWU6ICduZXRzaW0tbG9iYnktcGFuZWwnLFxuICAgIHBhbmVsVGl0bGU6IHRoaXMuZ2V0TG9jYWxpemVkUGFuZWxUaXRsZSgpLFxuICAgIHVzZXJUb2dnbGVhYmxlOiBmYWxzZVxuICB9KTtcblxuICBpZiAob3B0aW9ucy5kaXNhYmxlQ29udHJvbHMpIHtcbiAgICB0aGlzLmRpc2FibGVFdmVyeXRoaW5nKCk7XG4gIH1cbn07XG5OZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwuaW5oZXJpdHMoTmV0U2ltUGFuZWwpO1xuXG4vKipcbiAqIFJlY3JlYXRlIG1hcmt1cCB3aXRoaW4gcGFuZWwgYm9keS5cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENsb25lIHRoZSByZWZlcmVuY2UgYXJlYSAod2l0aCBoYW5kbGVycykgYmVmb3JlIHdlIHJlLXJlbmRlclxuICB2YXIgcmVmZXJlbmNlQXJlYSA9ICQoJyNyZWZlcmVuY2VfYXJlYScpLmZpcnN0KCkuY2xvbmUodHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGJvaWxlcnBsYXRlIHBhbmVsIG1hcmt1cFxuICBOZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwuc3VwZXJQcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gQWRkIG91ciBvd24gY29udGVudCBtYXJrdXBcbiAgdmFyIG5ld01hcmt1cCA9ICQobWFya3VwKHtcbiAgICBjb250cm9sbGVyOiB0aGlzLFxuICAgIG5vZGVzT25TaGFyZDogdGhpcy5ub2Rlc09uU2hhcmRfLFxuICAgIGluY29taW5nQ29ubmVjdGlvbk5vZGVzOiB0aGlzLmluY29taW5nQ29ubmVjdGlvbk5vZGVzXyxcbiAgICByZW1vdGVOb2RlOiB0aGlzLnJlbW90ZU5vZGVfXG4gIH0pKTtcbiAgdGhpcy5nZXRCb2R5KCkuaHRtbChuZXdNYXJrdXApO1xuXG4gIHRoaXMudXBkYXRlTGF5b3V0KCk7XG5cbiAgLy8gTW92ZSB0aGUgcmVmZXJlbmNlIGFyZWEgdG8gYmVuZWF0aCB0aGUgaW5zdHJ1Y3Rpb25zXG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJy5yZWZlcmVuY2UtYXJlYS1wbGFjZWhvbGRlcicpLmFwcGVuZChyZWZlcmVuY2VBcmVhKTtcblxuICAvLyBUZWFjaGVycyBhbmQgYWRtaW5zIGdldCBhIHNwZWNpYWwgXCJSZXNldCBTaW11bGF0aW9uXCIgYnV0dG9uXG4gIGlmICh0aGlzLmNhbkN1cnJlbnRVc2VyUmVzZXRTaGFyZCgpKSB7XG4gICAgdGhpcy5hZGRCdXR0b24oaTE4bi5zaGFyZFJlc2V0QnV0dG9uKCksIHRoaXMucmVzZXRTaGFyZENhbGxiYWNrXyk7XG4gIH1cblxuICAvLyBCdXR0b24gdGhhdCB0YWtlcyB5b3UgdG8gdGhlIG5leHQgbGV2ZWwuXG4gIE5ldFNpbVV0aWxzLm1ha2VDb250aW51ZUJ1dHRvbih0aGlzKTtcblxuICB0aGlzLmFkZFJvdXRlckJ1dHRvbl8gPSB0aGlzLmdldEJvZHkoKS5maW5kKCcjbmV0c2ltLWxvYmJ5LWFkZC1yb3V0ZXInKTtcbiAgdGhpcy5hZGRSb3V0ZXJCdXR0b25fLmNsaWNrKHVubGVzc0Rpc2FibGVkKHRoaXMuYWRkUm91dGVyQ2FsbGJhY2tfKSk7XG5cbiAgdGhpcy5nZXRCb2R5KCkuZmluZCgnLmpvaW4tYnV0dG9uJykuY2xpY2soXG4gICAgICB1bmxlc3NEaXNhYmxlZCh0aGlzLm9uSm9pbkNsaWNrXy5iaW5kKHRoaXMpKSk7XG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJy5hY2NlcHQtYnV0dG9uJykuY2xpY2soXG4gICAgICB1bmxlc3NEaXNhYmxlZCh0aGlzLm9uSm9pbkNsaWNrXy5iaW5kKHRoaXMpKSk7XG4gIHRoaXMuZ2V0Qm9keSgpLmZpbmQoJy5jYW5jZWwtYnV0dG9uJykuY2xpY2soXG4gICAgICB1bmxlc3NEaXNhYmxlZCh0aGlzLmNhbmNlbEJ1dHRvbkNhbGxiYWNrXykpO1xufTtcblxuLyoqXG4gKiBXcmFwIHRoZSBwcm92aWRlZCBjYWxsYmFjayBpbiBhIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IGlzIG5vdCBkaXNhYmxlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHVubGVzc0Rpc2FibGVkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoalF1ZXJ5RXZlbnQpIHtcbiAgICBpZiAoISQoalF1ZXJ5RXZlbnQudGFyZ2V0KS5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICBjYWxsYmFjayhqUXVlcnlFdmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxheW91dCBvZiB0aGUgbWFya3VwLCB1c3VhbGx5IGluIHJlc3BvbnNlIHRvIGEgd2luZG93XG4gKiByZXNpemUuIEN1cnJlbnRseSBqdXN0IGFkanVzdHMgdGhlIGhlaWdodCBvZiB0aGUgbG9iYnkgdGFibGUgdG8ga2VlcFxuICogZXZlcnl0aGluZyBvbnNjcmVlbi5cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxvYmJ5VGFibGUgPSB0aGlzLmdldEJvZHkoKS5maW5kKCcjbmV0c2ltLXNjcm9sbGluZy1sb2JieScpO1xuICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRCb2R5KCkuY2xvc2VzdCgnI25ldHNpbS1kaXNjb25uZWN0ZWQnKTtcblxuICBpZiAobG9iYnlUYWJsZS5pcygnOnZpc2libGUnKSkge1xuICAgIGxvYmJ5VGFibGUuaGVpZ2h0KFwibm9uZVwiKTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBjb250YWluZXIucHJvcCgnc2Nyb2xsSGVpZ2h0JykgLSBjb250YWluZXIucHJvcCgnY2xpZW50SGVpZ2h0Jyk7XG5cbiAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gbG9iYnlUYWJsZS5oZWlnaHQoKSAtIG92ZXJmbG93O1xuICAgICAgdmFyIG1pbkhlaWdodCA9IGxvYmJ5VGFibGUuZmluZCgndHInKS5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgbG9iYnlUYWJsZS5oZWlnaHQoTWF0aC5tYXgobmV3SGVpZ2h0LCBtaW5IZWlnaHQpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gYSBsb2NhbGl6ZWQgcGFuZWwgdGl0bGUgYXBwcm9wcmlhdGUgdG8gdGhlIGN1cnJlbnQgbGV2ZWxcbiAqICAgICAgICAgIGNvbmZpZ3VyYXRpb25cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5nZXRMb2NhbGl6ZWRQYW5lbFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV2ZWxDb25maWcgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG5cbiAgaWYgKGxldmVsQ29uZmlnLmNhbkNvbm5lY3RUb0NsaWVudHMgJiZcbiAgICAgIGxldmVsQ29uZmlnLmNhbkNvbm5lY3RUb1JvdXRlcnMpIHtcbiAgICByZXR1cm4gaTE4bi5jb25uZWN0VG9BTm9kZSgpO1xuICB9IGVsc2UgaWYgKGxldmVsQ29uZmlnLmNhbkNvbm5lY3RUb0NsaWVudHMpIHtcbiAgICByZXR1cm4gaTE4bi5jb25uZWN0VG9BUGVlcigpO1xuICB9IGVsc2UgaWYgKGxldmVsQ29uZmlnLmNhbkNvbm5lY3RUb1JvdXRlcnMpIHtcbiAgICBpZiAobGV2ZWxDb25maWcuYnJvYWRjYXN0TW9kZSkge1xuICAgICAgcmV0dXJuIGkxOG4uY29ubmVjdFRvQVJvb20oKTtcbiAgICB9XG4gICAgcmV0dXJuIGkxOG4uY29ubmVjdFRvQVJvdXRlcigpO1xuICB9XG4gIHJldHVybiBpMThuLmNvbm5lY3RUb0FOb2RlKCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGxvY2FsaXplZCBsb2JieSBpbnN0cnVjdGlvbnMgYXBwcm9wcmlhdGUgdG8gdGhlIGN1cnJlbnRcbiAqICAgICAgICAgIGxldmVsIGNvbmZpZ3VyYXRpb25cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5nZXRMb2NhbGl6ZWRMb2JieUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxldmVsQ29uZmlnID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuXG4gIGlmIChsZXZlbENvbmZpZy5jYW5Db25uZWN0VG9DbGllbnRzICYmXG4gICAgICBsZXZlbENvbmZpZy5jYW5Db25uZWN0VG9Sb3V0ZXJzKSB7XG4gICAgcmV0dXJuIGkxOG4ubG9iYnlJbnN0cnVjdGlvbnNHZW5lcmFsKCk7XG4gIH0gZWxzZSBpZiAobGV2ZWxDb25maWcuY2FuQ29ubmVjdFRvQ2xpZW50cykge1xuICAgIHJldHVybiBpMThuLmxvYmJ5SW5zdHJ1Y3Rpb25zRm9yUGVlcnMoKTtcbiAgfSBlbHNlIGlmIChsZXZlbENvbmZpZy5jYW5Db25uZWN0VG9Sb3V0ZXJzKSB7XG4gICAgaWYgKGxldmVsQ29uZmlnLmJyb2FkY2FzdE1vZGUpIHtcbiAgICAgIHJldHVybiBpMThuLmxvYmJ5SW5zdHJ1Y3Rpb25zRm9yUm9vbXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGkxOG4ubG9iYnlJbnN0cnVjdGlvbnNGb3JSb3V0ZXJzKCk7XG4gIH1cbiAgcmV0dXJuIGkxOG4ubG9iYnlJbnN0cnVjdGlvbnNHZW5lcmFsKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGpRdWVyeUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1SZW1vdGVOb2RlU2VsZWN0aW9uUGFuZWwucHJvdG90eXBlLm9uSm9pbkNsaWNrXyA9IGZ1bmN0aW9uIChqUXVlcnlFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gJChqUXVlcnlFdmVudC50YXJnZXQpO1xuICB2YXIgbm9kZUlEID0gdGFyZ2V0LmRhdGEoJ25vZGVJZCcpO1xuICB2YXIgY2xpY2tlZE5vZGUgPSBfLmZpbmQodGhpcy5ub2Rlc09uU2hhcmRfLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmVudGl0eUlEID09PSBub2RlSUQ7XG4gIH0pO1xuXG4gIHRoaXMuam9pbkJ1dHRvbkNhbGxiYWNrXyhjbGlja2VkTm9kZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltTm9kZX0gbm9kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbk5ldFNpbVJlbW90ZU5vZGVTZWxlY3Rpb25QYW5lbC5wcm90b3R5cGUuaXNNeU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5teU5vZGVJRF8gPT09IG5vZGUuZW50aXR5SUQ7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGxldmVsIGNvbmZpZ3VyYXRpb24gYWxsb3dzIGNvbm5lY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWRcbiAqIG5vZGUuXG4gKiBAcGFyYW0ge05ldFNpbU5vZGV9IGNvbm5lY3Rpb25UYXJnZXRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGNvbm5lY3Rpb24gdG8gdGhlIHRhcmdldCBpcyBhbGxvd2VkXG4gKi9cbk5ldFNpbVJlbW90ZU5vZGVTZWxlY3Rpb25QYW5lbC5wcm90b3R5cGUuY2FuQ29ubmVjdFRvTm9kZSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uVGFyZ2V0KSB7XG4gIC8vIENhbid0IGNvbm5lY3QgdG8gb3duIG5vZGVcbiAgaWYgKHRoaXMuaXNNeU5vZGUoY29ubmVjdGlvblRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNDbGllbnQgPSAoY29ubmVjdGlvblRhcmdldC5nZXROb2RlVHlwZSgpID09PSBOb2RlVHlwZS5DTElFTlQpO1xuICB2YXIgaXNSb3V0ZXIgPSAoY29ubmVjdGlvblRhcmdldC5nZXROb2RlVHlwZSgpID09PSBOb2RlVHlwZS5ST1VURVIpO1xuXG4gIC8vIENhbid0IGNvbm5lY3QgdG8gZnVsbCByb3V0ZXJzXG4gIGlmIChjb25uZWN0aW9uVGFyZ2V0LmlzRnVsbCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUGVybWlzc2libGUgY29ubmVjdGlvbiBsaW1pdGVkIGJ5IGxldmVsIGNvbmZpZ3VyYXRpb25cbiAgdmFyIGxldmVsQ29uZmlnID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuICB2YXIgYWxsb3dDbGllbnRzID0gbGV2ZWxDb25maWcuY2FuQ29ubmVjdFRvQ2xpZW50cztcbiAgdmFyIGFsbG93Um91dGVycyA9IGxldmVsQ29uZmlnLmNhbkNvbm5lY3RUb1JvdXRlcnM7XG4gIHJldHVybiAoaXNDbGllbnQgJiYgYWxsb3dDbGllbnRzKSB8fCAoaXNSb3V0ZXIgJiYgYWxsb3dSb3V0ZXJzKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgd2UgaGF2ZSBhbiBvcGVuIG91dGdvaW5nIGNvbm5lY3Rpb24gcmVxdWVzdC5cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5oYXNPdXRnb2luZ1JlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhISh0aGlzLnJlbW90ZU5vZGVfKTtcbn07XG5cbi8qKlxuICogRm9yIHVzZSB3aXRoIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoKVxuICogQHBhcmFtIHtOZXRTaW1Ob2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgZ2l2ZW4gbm9kZSBzaG91bGQgc2hvdyB1cCBpbiB0aGUgbG9iYnlcbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5zaG91bGRTaG93Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgdmFyIGlzQ2xpZW50ID0gKG5vZGUuZ2V0Tm9kZVR5cGUoKSA9PT0gTm9kZVR5cGUuQ0xJRU5UKTtcbiAgdmFyIGlzUm91dGVyID0gKG5vZGUuZ2V0Tm9kZVR5cGUoKSA9PT0gTm9kZVR5cGUuUk9VVEVSKTtcbiAgdmFyIHNob3dDbGllbnRzID0gbGV2ZWxDb25maWcuc2hvd0NsaWVudHNJbkxvYmJ5O1xuICB2YXIgc2hvd1JvdXRlcnMgPSBsZXZlbENvbmZpZy5zaG93Um91dGVyc0luTG9iYnk7XG4gIHJldHVybiAoaXNDbGllbnQgJiYgc2hvd0NsaWVudHMpIHx8IChpc1JvdXRlciAmJiBzaG93Um91dGVycyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHdlIGV4cGVjdCB0aGUgY3VycmVudCB1c2VyIHRvIGhhdmUgcGVybWlzc2lvbiB0b1xuICogICAgICAgICAgcGVyZm9ybSBhIHNoYXJkIHJlc2V0LiAgT25seSBnb3Zlcm5zIGRpc3BsYXkgb2Ygc2hhcmQgcmVzZXQgYnV0dG9uLFxuICogICAgICAgICAgYWN0dWFsIHJlc2V0IGlzIGF1dGhlbnRpY2F0ZWQgb24gdGhlIHNlcnZlci5cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5jYW5DdXJyZW50VXNlclJlc2V0U2hhcmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy51c2VyXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICh0aGlzLnVzZXJfLmlzQWRtaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZpbmQgYSBzZWN0aW9uIElEIGluIHRoZSBjdXJyZW50IHNoYXJkIElEXG4gIHZhciBtYXRjaGVzID0gL18oXFxkKykkLy5leGVjKHRoaXMuc2hhcmRJRF8pO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXRjaGVzWzFdIGlzIHRoZSBmaXJzdCBjYXB0dXJlIGdyb3VwIChcXGQrKSwgdGhlIG51bWVyaWMgc2VjdGlvbiBJRC5cbiAgdmFyIHNlY3Rpb25JRCA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgcmV0dXJuIHRoaXMudXNlcl8ub3duc1NlY3Rpb24oc2VjdGlvbklEKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgaXQncyBjdXJyZW50bHkgcG9zc2libGUgdG8gYWRkIGEgbmV3IHJvdXRlci5cbiAqICAgICAgICAgIERyaXZlcyB3aGV0aGVyIHRoZSBcIkFkZCBSb3V0ZXJcIiBidXR0b24gc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5jYW5BZGRSb3V0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgaWYgKHRoaXMuaGFzT3V0Z29pbmdSZXF1ZXN0KCkgfHwgIWxldmVsQ29uZmlnLnNob3dBZGRSb3V0ZXJCdXR0b24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcm91dGVyTGltaXQgPSBOZXRTaW1Sb3V0ZXJOb2RlLmdldE1heGltdW1Sb3V0ZXJzUGVyU2hhcmQoKTtcbiAgdmFyIHJvdXRlckNvdW50ID0gdGhpcy5ub2Rlc09uU2hhcmRfLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBOb2RlVHlwZS5ST1VURVIgPT09IG5vZGUuZ2V0Tm9kZVR5cGUoKTtcbiAgfSkubGVuZ3RoO1xuICByZXR1cm4gcm91dGVyQ291bnQgPCByb3V0ZXJMaW1pdDtcbn07XG5cbi8qKlxuICogRGlzYWJsZSBhbGwgb2YgdGhlIGJ1dHRvbnMgd2l0aGluIHRoZSBwYW5lbCAoZG9lcyBub3QgYXBwbHkgdG8gcGFuZWwtaGVhZGVyXG4gKiBidXR0b25zISlcbiAqL1xuTmV0U2ltUmVtb3RlTm9kZVNlbGVjdGlvblBhbmVsLnByb3RvdHlwZS5kaXNhYmxlRXZlcnl0aGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5nZXRCb2R5KCkuZmluZCgnLm5ldHNpbS1idXR0b24nKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgYWxsIG9mIHRoZSBidXR0b25zIHdpdGhpbiB0aGUgcGFuZWwgKGRvZXMgbm90IGFwcGx5IHRvIHBhbmVsLWhlYWRlclxuICogYnV0dG9ucyEpXG4gKi9cbk5ldFNpbVJlbW90ZU5vZGVTZWxlY3Rpb25QYW5lbC5wcm90b3R5cGUuZW5hYmxlRXZlcnl0aGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5nZXRCb2R5KCkuZmluZCgnLm5ldHNpbS1idXR0b24nKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgXyA9IHV0aWxzLmdldExvZGFzaCgpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcbnZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuTm9kZVR5cGU7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb259ICovXG52YXIgZ2V0QXNzZXRVcmwgPSBOZXRTaW1HbG9iYWxzLmdldEFzc2V0VXJsRnVuY3Rpb24oKTtcblxuLyoqIEB0eXBlIHtOZXRTaW1MZXZlbENvbmZpZ3VyYXRpb259ICovXG52YXIgbGV2ZWxDb25maWcgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUm93TWV0YWRhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBub2RlSURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjbGFzc0F0dHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaXNwbGF5TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1c1xuICovXG5cbi8qKlxuICogRm9yIHVzZSB3aXRoIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoKVxuICogQHBhcmFtIHtOZXRTaW1Ob2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIG9taXRJbmNvbWluZ0Nvbm5lY3Rpb25Ob2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB1bmRlZmluZWQgPT09IF8uZmluZChpbmNvbWluZ0Nvbm5lY3Rpb25Ob2RlcywgZnVuY3Rpb24gKGNvbm5lY3Rpb25SZXF1ZXN0Tm9kZSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblJlcXVlc3ROb2RlLmVudGl0eUlEID09PSBub2RlLmVudGl0eUlEO1xuICAgICAgfSk7XG59O1xuXG4vKipcbiAqIEZvciB1c2Ugd2l0aCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKClcbiAqIEBwYXJhbSB7TmV0U2ltTm9kZX0gbm9kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBvbWl0T3V0Z29pbmdSZXF1ZXN0VGFyZ2V0cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiAhcmVtb3RlTm9kZSB8fCAocmVtb3RlTm9kZS5lbnRpdHlJRCAhPT0gbm9kZS5lbnRpdHlJRCk7XG59O1xuXG4vKipcbiAqIEZvciB1c2Ugd2l0aCBBcnJheS5wcm90b3R5cGUubWFwKClcbiAqIEBwYXJhbSB7TmV0U2ltTm9kZX0gbm9kZVxuICogQHJldHVybnMge1Jvd01ldGFkYXRhfVxuICovXG52YXIgbm9kZVRvUm93TWV0YWRhdGEgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBub2RlLmdldERpc3BsYXlOYW1lKCk7XG4gIHZhciBzb3J0S2V5ID0gZGlzcGxheU5hbWU7XG4gIHZhciBjbGFzc2VzID0gWyd1c2VyLXJvdyddO1xuXG4gIGlmIChub2RlLmdldE5vZGVUeXBlKCkgPT09IE5vZGVUeXBlLlJPVVRFUikge1xuICAgIC8vIFNvcnQgcm91dGVycyBieSBsZWZ0LXBhZGRlZCByb3V0ZXIgbnVtYmVyIChsb29rcyBsaWtlIG5hdHVyYWwgc29ydClcbiAgICBzb3J0S2V5ID0gKCcwMDAnICsgbm9kZS5yb3V0ZXJOdW1iZXIpLnNsaWNlKC0zKTtcbiAgICBjbGFzc2VzID0gWydyb3V0ZXItcm93J107XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5pc015Tm9kZShub2RlKSkge1xuICAgIGNsYXNzZXMucHVzaCgnb3duLXJvdycpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlSUQ6IG5vZGUuZW50aXR5SUQsXG4gICAgc29ydEtleTogc29ydEtleSxcbiAgICBjbGFzc0F0dHI6IGNsYXNzZXMuam9pbignICcpLFxuICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICBob3N0bmFtZTogbm9kZS5nZXRIb3N0bmFtZSgpLFxuICAgIHN0YXR1czogbm9kZS5nZXRTdGF0dXMoKSxcbiAgICBpc0Z1bGw6IG5vZGUuaXNGdWxsKCksXG4gICAgY2FuQ29ubmVjdFRvTm9kZTogY29udHJvbGxlci5jYW5Db25uZWN0VG9Ob2RlKG5vZGUpXG4gIH07XG59O1xuXG4vKipcbiAqIEZvciB1c2Ugd2l0aCBBcnJheS5wcm90b3R5cGUuc29ydCgpXG4gKiBAcGFyYW0ge1Jvd01ldGFkYXRhfSBhXG4gKiBAcGFyYW0ge1Jvd01ldGFkYXRhfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG52YXIgbG9iYnlTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIChhLnNvcnRLZXkgPiBiLnNvcnRLZXkpID8gMSA6IC0xO1xufTtcblxudmFyIGxvYmJ5Um93cyA9IG5vZGVzT25TaGFyZFxuICAgIC5maWx0ZXIoY29udHJvbGxlci5zaG91bGRTaG93Tm9kZS5iaW5kKGNvbnRyb2xsZXIpKVxuICAgIC5maWx0ZXIob21pdEluY29taW5nQ29ubmVjdGlvbk5vZGVzKVxuICAgIC5maWx0ZXIob21pdE91dGdvaW5nUmVxdWVzdFRhcmdldHMpXG4gICAgLm1hcChub2RlVG9Sb3dNZXRhZGF0YSlcbiAgICAuc29ydChsb2JieVNvcnQpO1xuXG52YXIgcmVxdWVzdFJvd3MgPSBpbmNvbWluZ0Nvbm5lY3Rpb25Ob2Rlc1xuICAgIC5maWx0ZXIoY29udHJvbGxlci5zaG91bGRTaG93Tm9kZS5iaW5kKGNvbnRyb2xsZXIpKVxuICAgIC5maWx0ZXIob21pdE91dGdvaW5nUmVxdWVzdFRhcmdldHMpXG4gICAgLm1hcChub2RlVG9Sb3dNZXRhZGF0YSlcbiAgICAuc29ydChsb2JieVNvcnQpO1xuXG52YXIgb3V0Z29pbmdSZXF1ZXN0Um93cyA9IChyZW1vdGVOb2RlID8gWyByZW1vdGVOb2RlIF0gOiBbXSlcbiAgICAuZmlsdGVyKGNvbnRyb2xsZXIuc2hvdWxkU2hvd05vZGUuYmluZChjb250cm9sbGVyKSlcbiAgICAubWFwKG5vZGVUb1Jvd01ldGFkYXRhKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnV0dG9uVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGJ1dHRvbklEXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHRyYUNsYXNzZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYUF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG1hcmt1cCBmb3IgTmV0U2ltLXN0eWxlIGJ1dHRvblxuICovXG5mdW5jdGlvbiBidXR0b25NYXJrdXAoYnV0dG9uVGV4dCwgYnV0dG9uSUQsIGV4dHJhQ2xhc3NlcywgZXh0cmFBdHRyaWJ1dGVzKSB7XG4gIHZhciBjbGFzc2VzID0gdXRpbHMudmFsdWVPcihleHRyYUNsYXNzZXMsIFtdKTtcbiAgY2xhc3Nlcy5wdXNoKCduZXRzaW0tYnV0dG9uJyk7XG4gIGNsYXNzZXMucHVzaCgnbGFyZ2UtYnV0dG9uJyk7XG5cbiAgZXh0cmFBdHRyaWJ1dGVzID0gdXRpbHMudmFsdWVPcihleHRyYUF0dHJpYnV0ZXMsIHt9KTtcblxuICB2YXIgbWFya3VwID0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiICc7XG5cbiAgLy8gSUQgYXR0cmlidXRlIGZvciBzcGFuIHRhZ1xuICBpZiAoYnV0dG9uSUQpIHtcbiAgICBtYXJrdXAgKz0gJ2lkPVwiJyArIGJ1dHRvbklEICsgJ1wiICc7XG4gIH1cblxuICAvLyBFeHRyYSBhdHRyaWJ1dGVzIGZvciBzcGFuIHRhZ1xuICBmb3IgKHZhciBrZXkgaW4gZXh0cmFBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGV4dHJhQXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBtYXJrdXAgKz0ga2V5ICsgJz1cIicgKyBleHRyYUF0dHJpYnV0ZXNba2V5XSArICdcIiAnO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSAnPicgKyBidXR0b25UZXh0ICsgJzwvc3Bhbj4nO1xuICByZXR1cm4gbWFya3VwO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJlZ2luVGFibGUoY2xhc3NuYW1lKSB7XG4gIGlmIChjbGFzc25hbWUpIHtcbiAgICA7IGJ1Zi5wdXNoKCc8dGFibGUgY2xhc3M9XCInLCBlc2NhcGUoKDEzNSwgY2xhc3NuYW1lKSksICdcIj4nKTsxMzU7XG4gIH0gZWxzZSB7XG4gICAgOyBidWYucHVzaCgnPHRhYmxlPicpOzEzNztcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUVuZFRhYmxlKCkge1xuICA7IGJ1Zi5wdXNoKCc8L3RhYmxlPicpOzE0Mjtcbn1cblxuZnVuY3Rpb24gd3JpdGVCZWdpblRib2R5KCkge1xuICA7IGJ1Zi5wdXNoKCc8dGJvZHk+Jyk7MTQ2O1xufVxuXG5mdW5jdGlvbiB3cml0ZUVuZFRib2R5KCkge1xuICA7IGJ1Zi5wdXNoKCc8L3Rib2R5PicpOzE1MDtcbn1cblxuZnVuY3Rpb24gd3JpdGVIZWFkZXIoaGVhZGVyVGV4dCkge1xuICA7IGJ1Zi5wdXNoKCdcXG4gICAgPHRoZWFkPlxcbiAgICAgIDx0cj5cXG4gICAgICAgIDx0aCBjb2xzcGFuPVwiM1wiPicsIGVzY2FwZSgoMTU3LCAgaGVhZGVyVGV4dCApKSwgJzwvdGg+XFxuICAgICAgPC90cj5cXG4gICAgPC90aGVhZD5cXG4gICcpOzE2MDtcbn1cblxuZnVuY3Rpb24gd3JpdGVFbXB0eVJvdyhjb250ZW50cykge1xuICBjb250ZW50cyA9IHV0aWxzLnZhbHVlT3IoY29udGVudHMsICcnKTtcbiAgOyBidWYucHVzaCgnXFxuICAgIDx0cj5cXG4gICAgICA8dGQgY29sc3Bhbj1cIjNcIiBjbGFzcz1cImVtcHR5LXJvd1wiPicsICgxNjcsICBjb250ZW50cyApLCAnPC90ZD5cXG4gICAgPC90cj5cXG4gICcpOzE2OTtcbn1cblxuZnVuY3Rpb24gd3JpdGVOb2RlUm93KHJvdywgbm9kZVN0YXR1cywgYnV0dG9uVHlwZSwgYWRkbENsYXNzKSB7XG4gICAgdmFyIGJ1dHRvbjtcbiAgICBpZiAoYnV0dG9uVHlwZSA9PT0gJ2pvaW4tYnV0dG9uJykge1xuICAgICAgYnV0dG9uID0gYnV0dG9uTWFya3VwKGkxOG4uYnV0dG9uSm9pbigpLCB1bmRlZmluZWQsIFtidXR0b25UeXBlLCBhZGRsQ2xhc3NdLCB7ICdkYXRhLW5vZGUtaWQnOiByb3cubm9kZUlEIH0pO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uVHlwZSA9PT0gJ2FjY2VwdC1idXR0b24nKSB7XG4gICAgICBidXR0b24gPSBidXR0b25NYXJrdXAoaTE4bi5idXR0b25BY2NlcHQoKSwgdW5kZWZpbmVkLCBbYnV0dG9uVHlwZSwgYWRkbENsYXNzXSwgeyAnZGF0YS1ub2RlLWlkJzogcm93Lm5vZGVJRCB9KTtcbiAgICB9IGVsc2UgaWYgKGJ1dHRvblR5cGUgPT09ICdjYW5jZWwtYnV0dG9uJykge1xuICAgICAgYnV0dG9uID0gYnV0dG9uTWFya3VwKGkxOG4uYnV0dG9uQ2FuY2VsKCksIHVuZGVmaW5lZCwgW2J1dHRvblR5cGUsIGFkZGxDbGFzcywgJ3NlY29uZGFyeSddLCB7ICdkYXRhLW5vZGUtaWQnOiByb3cubm9kZUlEIH0pO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uVHlwZSA9PT0gJ2Z1bGwtYnV0dG9uJykge1xuICAgICAgYnV0dG9uID0gYnV0dG9uTWFya3VwKGkxOG4uYnV0dG9uRnVsbCgpLCB1bmRlZmluZWQsIFtidXR0b25UeXBlLCBhZGRsQ2xhc3NdLCB7ICdkaXNhYmxlZCc6ICdkaXNhYmxlZCcgfSk7XG4gICAgfVxuICA7IGJ1Zi5wdXNoKCdcXG4gICAgPHRyPlxcbiAgICAgIDx0ZCBub3dyYXA+JywgZXNjYXBlKCgxODUsICByb3cuZGlzcGxheU5hbWUgKSksICcgPHNtYWxsPignLCBlc2NhcGUoKDE4NSwgIHJvdy5ob3N0bmFtZSApKSwgJyk8L3NtYWxsPjwvdGQ+XFxuICAgICAgJyk7MTg2OyBpZiAoYnV0dG9uKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAgICAgPHRkPicsICgxODcsICBub2RlU3RhdHVzICksICc8L3RkPlxcbiAgICAgICAgPHRkIGNsYXNzPVwiYnV0dG9uLWNvbHVtblwiPlxcbiAgICAgICAgICAnLCAoMTg5LCAgYnV0dG9uICksICdcXG4gICAgICAgIDwvdGQ+XFxuICAgICAgJyk7MTkxOyB9IGVsc2UgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiPicsICgxOTIsICBub2RlU3RhdHVzICksICc8L3RkPlxcbiAgICAgICcpOzE5MzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgPC90cj5cXG4gICcpOzE5NTtcbn1cblxuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cImNvbnRlbnQtd3JhcFwiPlxcbiAgPGRpdiBjbGFzcz1cImluc3RydWN0aW9uc1wiPlxcbiAgICAnLCBlc2NhcGUoKDIwMSwgIGNvbnRyb2xsZXIuZ2V0TG9jYWxpemVkTG9iYnlJbnN0cnVjdGlvbnMoKSApKSwgJ1xcbiAgICA8ZGl2IGNsYXNzPVwicmVmZXJlbmNlLWFyZWEtcGxhY2Vob2xkZXJcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImNvbnRyb2xzXCI+XFxuXFxuICAgICcpOzIwNjtcbiAgICAgIC8vIE91dGdvaW5nIHJlcXVlc3QgdGFibGUgKGhpZGRlbiBpZiBlbXB0eSlcbiAgICAgIGlmIChvdXRnb2luZ1JlcXVlc3RSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd3JpdGVCZWdpblRhYmxlKCk7XG4gICAgICAgIHdyaXRlSGVhZGVyKGkxOG4ub3V0Z29pbmdDb25uZWN0aW9uUmVxdWVzdHMoKSk7XG4gICAgICAgIHdyaXRlQmVnaW5UYm9keSgpO1xuICAgICAgICBvdXRnb2luZ1JlcXVlc3RSb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHZhciBvdXRnb2luZ1N0YXR1cyA9IGkxOG4ubG9iYnlTdGF0dXNXYWl0aW5nRm9yT3RoZXIoe1xuICAgICAgICAgICAgc3Bpbm5lcjogJzxpbWcgc3JjPVwiJyArIGdldEFzc2V0VXJsKCdtZWRpYS9uZXRzaW0vbG9hZGluZy5naWYnKSArICdcIiAvPicsXG4gICAgICAgICAgICBvdGhlck5hbWU6IHJvdy5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIG90aGVyU3RhdHVzOiByb3cuc3RhdHVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd3JpdGVOb2RlUm93KHJvdywgb3V0Z29pbmdTdGF0dXMsICdjYW5jZWwtYnV0dG9uJywgcm93LmNsYXNzQXR0cik7XG4gICAgICAgIH0pO1xuICAgICAgICB3cml0ZUVuZFRib2R5KCk7XG4gICAgICAgIHdyaXRlRW5kVGFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5jb21pbmcgcmVxdWVzdHMgdGFibGUgKGhpZGRlbiBpZiBlbXB0eSlcbiAgICAgIGlmIChyZXF1ZXN0Um93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdyaXRlQmVnaW5UYWJsZSgpO1xuICAgICAgICB3cml0ZUhlYWRlcihpMThuLmluY29taW5nQ29ubmVjdGlvblJlcXVlc3RzKCkpO1xuICAgICAgICB3cml0ZUJlZ2luVGJvZHkoKTtcbiAgICAgICAgcmVxdWVzdFJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgdmFyIGJ1dHRvblR5cGU7XG4gICAgICAgICAgaWYgKCFjb250cm9sbGVyLmhhc091dGdvaW5nUmVxdWVzdCgpICYmIHJvdy5jYW5Db25uZWN0VG9Ob2RlKSB7XG4gICAgICAgICAgICBidXR0b25UeXBlID0gJ2FjY2VwdC1idXR0b24nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5jb21pbmdTdGF0dXMgPSBpMThuLmxvYmJ5U3RhdHVzV2FpdGluZ0ZvcllvdSgpO1xuICAgICAgICAgIHdyaXRlTm9kZVJvdyhyb3csIGluY29taW5nU3RhdHVzLCBidXR0b25UeXBlLCByb3cuY2xhc3NBdHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlRW5kVGJvZHkoKTtcbiAgICAgICAgd3JpdGVFbmRUYWJsZSgpO1xuICAgICAgfVxuICAgIDsgYnVmLnB1c2goJ1xcblxcbiAgICAnKTsyNDI7XG4gICAgICAvLyBQcmltYXJ5IGxvYmJ5IGxpc3RcbiAgICAgIHdyaXRlQmVnaW5UYWJsZShcIm5vbWFyZ2luXCIpO1xuICAgICAgd3JpdGVIZWFkZXIoaTE4bi5sb2JieSgpKTtcbiAgICAgIHdyaXRlRW5kVGFibGUoKTtcbiAgICA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBpZD1cIm5ldHNpbS1zY3JvbGxpbmctbG9iYnlcIj5cXG4gICAgJyk7MjQ5O1xuICAgICAgd3JpdGVCZWdpblRhYmxlKCk7XG4gICAgICB3cml0ZUJlZ2luVGJvZHkoKTtcbiAgICAgIGxvYmJ5Um93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGJ1dHRvblR5cGU7XG4gICAgICAgIGlmICghY29udHJvbGxlci5oYXNPdXRnb2luZ1JlcXVlc3QoKSkge1xuICAgICAgICAgIGlmIChyb3cuaXNGdWxsKSB7XG4gICAgICAgICAgICBidXR0b25UeXBlID0gJ2Z1bGwtYnV0dG9uJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvdy5jYW5Db25uZWN0VG9Ob2RlKSB7XG4gICAgICAgICAgICBidXR0b25UeXBlID0gJ2pvaW4tYnV0dG9uJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVOb2RlUm93KHJvdywgcm93LnN0YXR1cywgYnV0dG9uVHlwZSwgcm93LmNsYXNzQXR0cik7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGJ1dHRvbnMgPSBbXTtcblxuICAgICAgaWYgKGNvbnRyb2xsZXIuY2FuQWRkUm91dGVyKCkpIHtcbiAgICAgICAgdmFyIGJ1dHRvblRleHQgPSBsZXZlbENvbmZpZy5icm9hZGNhc3RNb2RlID8gaTE4bi5hZGRSb29tKCkgOiBpMThuLmFkZFJvdXRlcigpO1xuICAgICAgICBidXR0b25zLnB1c2goYnV0dG9uTWFya3VwKFxuICAgICAgICAgICAgYnV0dG9uVGV4dCxcbiAgICAgICAgICAgICduZXRzaW0tbG9iYnktYWRkLXJvdXRlcicsXG4gICAgICAgICAgICBbJ3NlY29uZGFyeSddXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWxDb25maWcuc2hvd0xvZ0Jyb3dzZXJCdXR0b24pIHtcbiAgICAgICAgYnV0dG9ucy5wdXNoKGJ1dHRvbk1hcmt1cChcbiAgICAgICAgICAgIGkxOG4ubG9nQnJvd3NlckJ1dHRvbigpLFxuICAgICAgICAgICAgJ3Nob3ctcm91dGVyLWxvZy1tb2RhbCcsXG4gICAgICAgICAgICBbJ3NlY29uZGFyeSddLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAnZGF0YS10b2dnbGUnOidtb2RhbCcsXG4gICAgICAgICAgICAgICdkYXRhLXRhcmdldCc6JyNyb3V0ZXItbG9nLW1vZGFsJ1xuICAgICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB3cml0ZUVtcHR5Um93KGJ1dHRvbnMuam9pbignICcpKTtcbiAgICAgIH0gZWxzZSBpZiAobG9iYnlSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3cml0ZUVtcHR5Um93KGkxOG4ubG9iYnlJc0VtcHR5KCkpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZUVuZFRib2R5KCk7XG4gICAgICB3cml0ZUVuZFRhYmxlKCk7XG4gICAgOyBidWYucHVzaCgnXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiY2xlYXJcIj48L2Rpdj5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBVdGlsaXR5IG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgdGhlIHJpZ2h0IGtpbmRzIG9mIG5vZGUgY29udHJvbGxlcnNcbiAqICAgICAgICAgICBmcm9tIHJhdyBub2RlIHRhYmxlIHJvd3MuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE5ldFNpbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJyk7XG5cbnZhciBOb2RlVHlwZSA9IE5ldFNpbUNvbnN0YW50cy5Ob2RlVHlwZTtcblxudmFyIE5ldFNpbU5vZGVGYWN0b3J5ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogR2l2ZW4gYSBzZXQgb2Ygcm93cyBmcm9tIHRoZSBub2RlIHRhYmxlIG9uIGEgc2hhcmQsIGdpdmVzIGJhY2sgYSBzZXQgb2Ygbm9kZVxuICogY29udHJvbGxlcnMgKG9mIGFwcHJvcHJpYXRlIHR5cGVzKS5cbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHshQXJyYXkuPE9iamVjdD59IG5vZGVSb3dzXG4gKiBAdGhyb3dzIHdoZW4gYSByb3cgZG9lc24ndCBoYXZlIGEgbWFwcGFibGUgbm9kZSB0eXBlLlxuICogQHJldHVybiB7QXJyYXkuPE5ldFNpbU5vZGU+fSBub2RlcyBmb3IgdGhlIHJvd3NcbiAqL1xuTmV0U2ltTm9kZUZhY3Rvcnkubm9kZXNGcm9tUm93cyA9IGZ1bmN0aW9uIChzaGFyZCwgbm9kZVJvd3MpIHtcbiAgcmV0dXJuIG5vZGVSb3dzLm1hcChOZXRTaW1Ob2RlRmFjdG9yeS5ub2RlRnJvbVJvdy5iaW5kKHRoaXMsIHNoYXJkKSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgcm93IGZyb20gdGhlIG5vZGUgdGFibGUgb24gYSBzaGFyZCwgZ2l2ZXMgYmFjayBhIG5vZGUgY29udHJvbGxlcnNcbiAqIChvZiBhcHByb3ByaWF0ZSB0eXBlcykuXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmRcbiAqIEBwYXJhbSB7IU9iamVjdH0gbm9kZVJvd1xuICogQHRocm93cyB3aGVuIHRoZSByb3cgZG9lc24ndCBoYXZlIGEgbWFwcGFibGUgbm9kZSB0eXBlLlxuICogQHJldHVybiB7TmV0U2ltTm9kZX0gbm9kZSBmb3IgdGhlIHJvd3NcbiAqL1xuTmV0U2ltTm9kZUZhY3Rvcnkubm9kZUZyb21Sb3cgPSBmdW5jdGlvbiAoc2hhcmQsIG5vZGVSb3cpIHtcbiAgaWYgKG5vZGVSb3cudHlwZSA9PT0gTm9kZVR5cGUuQ0xJRU5UKSB7XG4gICAgdmFyIE5ldFNpbUNsaWVudE5vZGUgPSByZXF1aXJlKCcuL05ldFNpbUNsaWVudE5vZGUnKTtcbiAgICByZXR1cm4gbmV3IE5ldFNpbUNsaWVudE5vZGUoc2hhcmQsIG5vZGVSb3cpO1xuICB9IGVsc2UgaWYgKG5vZGVSb3cudHlwZSA9PT0gTm9kZVR5cGUuUk9VVEVSKSB7XG4gICAgdmFyIE5ldFNpbVJvdXRlck5vZGUgPSByZXF1aXJlKCcuL05ldFNpbVJvdXRlck5vZGUnKTtcbiAgICByZXR1cm4gbmV3IE5ldFNpbVJvdXRlck5vZGUoc2hhcmQsIG5vZGVSb3cpO1xuICB9XG5cbiAgLy8gT29wcyEgIFdlIHByb2JhYmx5IHNob3VsZG4ndCBldmVyIGdldCBoZXJlLlxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbWFwIHJvdyB0byBub2RlLlwiKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBSb3V0ZXIgbm9kZSBzaW11bGF0aW9uIGVudGl0eS4gIEFsc28gY29udGFpbnMgbG9naWMgZm9yIHRoZVxuICogICAgICAgICAgIGF1dG8tRE5TIHN5c3RlbS5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIE5ldFNpbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJyk7XG52YXIgTmV0U2ltVXRpbHMgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJyk7XG52YXIgTmV0U2ltTm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltTm9kZScpO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgTmV0U2ltTG9nRW50cnkgPSByZXF1aXJlKCcuL05ldFNpbUxvZ0VudHJ5Jyk7XG52YXIgTmV0U2ltTG9nZ2VyID0gcmVxdWlyZSgnLi9OZXRTaW1Mb2dnZXInKTtcbnZhciBOZXRTaW1XaXJlID0gcmVxdWlyZSgnLi9OZXRTaW1XaXJlJyk7XG52YXIgTmV0U2ltTWVzc2FnZSA9IHJlcXVpcmUoJy4vTmV0U2ltTWVzc2FnZScpO1xudmFyIE9ic2VydmFibGVFdmVudCA9IHJlcXVpcmUoJy4uL09ic2VydmFibGVFdmVudCcpO1xudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vUGFja2V0Jyk7XG52YXIgRGF0YUNvbnZlcnRlcnMgPSByZXF1aXJlKCcuL0RhdGFDb252ZXJ0ZXJzJyk7XG52YXIgTmV0U2ltTm9kZUZhY3RvcnkgPSByZXF1aXJlKCcuL05ldFNpbU5vZGVGYWN0b3J5Jyk7XG5cbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG5cbnZhciBzZXJpYWxpemVOdW1iZXIgPSBOZXRTaW1VdGlscy5zZXJpYWxpemVOdW1iZXI7XG52YXIgZGVzZXJpYWxpemVOdW1iZXIgPSBOZXRTaW1VdGlscy5kZXNlcmlhbGl6ZU51bWJlcjtcblxudmFyIGFzY2lpVG9CaW5hcnkgPSBEYXRhQ29udmVydGVycy5hc2NpaVRvQmluYXJ5O1xuXG52YXIgRG5zTW9kZSA9IE5ldFNpbUNvbnN0YW50cy5EbnNNb2RlO1xudmFyIE5vZGVUeXBlID0gTmV0U2ltQ29uc3RhbnRzLk5vZGVUeXBlO1xudmFyIEJJVFNfUEVSX0JZVEUgPSBOZXRTaW1Db25zdGFudHMuQklUU19QRVJfQllURTtcblxudmFyIGxvZ2dlciA9IE5ldFNpbUxvZ2dlci5nZXRTaW5nbGV0b24oKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEByZWFkb25seVxuICovXG52YXIgTUFYX0NMSUVOVF9DT05ORUNUSU9OUyA9IDY7XG5cbi8qKlxuICogQ29udmVuaWVudGx5LCBhIHJvdXRlcidzIGFkZHJlc3MgaW4gaXRzIGxvY2FsIG5ldHdvcmsgaXMgYWx3YXlzIHplcm8uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHJlYWRvbmx5XG4gKi9cbnZhciBST1VURVJfTE9DQUxfQUREUkVTUyA9IDA7XG5cbi8qKlxuICogQWRkcmVzcyB0aGF0IGNhbiBvbmx5IGJlIHVzZWQgZm9yIHRoZSBhdXRvLWRucyBub2RlLlxuICogTWF5IGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgd2l0aCBhIGR5bmFtaWNhbGx5IGFzc2lnbmVkIGFkZHJlc3MuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHJlYWRvbmx5XG4gKi9cbnZhciBBVVRPX0ROU19SRVNFUlZFRF9BRERSRVNTID0gMTU7XG5cbi8qKlxuICogSG9zdG5hbWUgYXNzaWduZWQgdG8gdGhlIGF1dG9tYXRpYyBkbnMgJ25vZGUnIGluIHRoZSBsb2NhbCBuZXR3b3JrLlxuICogVGhlcmUgd2lsbCBvbmx5IGJlIG9uZSBvZiB0aGVzZSwgc28gaXQgY2FuIGJlIHNpbXBsZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIEFVVE9fRE5TX0hPU1ROQU1FID0gJ2Rucyc7XG5cbi8qKlxuICogVmFsdWUgdGhlIGF1dG8tRE5TIHdpbGwgcmV0dXJuIGluc3RlYWQgb2YgYW4gYWRkcmVzcyB3aGVuIGl0IGNhbid0XG4gKiBsb2NhdGUgYSBub2RlIHdpdGggdGhlIGdpdmVuIGhvc3RuYW1lIGluIHRoZSBsb2NhbCBuZXR3b3JrLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEByZWFkb25seVxuICovXG52YXIgQVVUT19ETlNfTk9UX0ZPVU5EID0gJ05PVF9GT1VORCc7XG5cbi8qKlxuICogTWF4aW11bSBwYWNrZXQgbGlmZXRpbWUgaW4gdGhlIHJvdXRlciBxdWV1ZSwgc29ydCBvZiBhIHByaW1pdGl2ZSBUaW1lLVRvLUxpdmVcbiAqIHN5c3RlbSB0aGF0IGhlbHBzIHByZXZlbnQgYSBxdWV1ZSBmcm9tIGJlaW5nIGluZGVmaW5pdGVseSBibG9ja2VkIGJ5IGEgdmVyeVxuICogbGFyZ2UgcGFja2V0LiAgUGFja2V0cyB0aGF0IGV4Y2VlZCB0aGlzIHRpbWUgd2lsbCBzaWxlbnRseSBmYWlsIGRlbGl2ZXJ5LlxuICogQHR5cGUge251bWJlcn1cbiAqIEByZWFkb25seVxuICovXG52YXIgUEFDS0VUX01BWF9MSUZFVElNRV9NUyA9IDEwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIFRvIGF2b2lkIGNhbGN1bGF0aW5nIGEgdG90YWxseSB1bnJlYXNvbmFibGUgbnVtYmVyIG9mIGFkZHJlc3NlcywgdGhpcyBpc1xuICogdGhlIG1vc3QgYWRkcmVzc2VzIHdlIHdpbGwgY29uc2lkZXIgd2hlbiBwaWNraW5nIG9uZSBmb3IgYSBuZXcgaG9zdC5cbiAqIFRoaXMgbWVhbnMgZnVsbCBzdXBwb3J0IHVwIHRvIGEgMTItYml0IGFkZHJlc3MgcGFydCwgd2hpY2ggc2hvdWxkIGJlIG1vcmVcbiAqIHRoYW4gZW5vdWdoLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIEFERFJFU1NfT1BUSU9OX0xJTUlUID0gNDA5NjtcblxuLyoqXG4gKiBDbGllbnQgbW9kZWwgb2Ygc2ltdWxhdGVkIHJvdXRlclxuICpcbiAqIFJlcHJlc2VudHMgdGhlIGNsaWVudCdzIHZpZXcgb2YgYSBnaXZlbiByb3V0ZXIsIHByb3ZpZGVzIG1ldGhvZHMgZm9yXG4gKiAgIGxldHRpbmcgdGhlIGNsaWVudCBpbnRlcmFjdCB3aXRoIHRoZSByb3V0ZXIsIGFuZCB3cmFwcyB0aGUgY2xpZW50J3NcbiAqICAgd29yayBkb2luZyBwYXJ0IG9mIHRoZSByb3V0ZXIgc2ltdWxhdGlvbi5cbiAqXG4gKiBBIHJvdXRlciAtZXhpc3RzLSB3aGVuIGl0IGhhcyBhIHJvdyBpbiB0aGUgbG9iYnkgdGFibGUgb2YgdHlwZSAncm91dGVyJ1xuICogQSByb3V0ZXIgaXMgY29ubmVjdGVkIHRvIGEgdXNlciB3aGVuIGEgJ3VzZXInIHJvdyBleGlzdHMgaW4gdGhlIGxvYmJ5XG4gKiAgIHRhYmxlIHRoYXQgaGFzIGEgc3RhdHVzICdDb25uZWN0ZWQgdG8ge3JvdXRlciBJRH0gYnkgd2lyZXMge1gsIFl9Jy5cbiAqIEEgcm91dGVyIHdpbGwgYWxzbyBzaGFyZSBhIHdpcmUgKHNpbXBsZXgpIG9yIHdpcmVzIChkdXBsZXgpIHdpdGggZWFjaCB1c2VyLFxuICogICB3aGljaCBhcHBlYXIgaW4gdGhlIHdpcmUgdGFibGUuXG4gKlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0ge1JvdXRlclJvd30gW3JvdXRlclJvd10gLSBMb2JieSByb3cgZm9yIHRoaXMgcm91dGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgTmV0U2ltTm9kZVxuICovXG52YXIgTmV0U2ltUm91dGVyTm9kZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNoYXJkLCByb3cpIHtcbiAgcm93ID0gcm93ICE9PSB1bmRlZmluZWQgPyByb3cgOiB7fTtcbiAgTmV0U2ltTm9kZS5jYWxsKHRoaXMsIHNoYXJkLCByb3cpO1xuXG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcblxuICAvKipcbiAgICogVGhpcyByb3V0ZXIncyBpZGVudGlmeWluZyBudW1iZXIsIHdoaWNoIGdldHMgdHJhbnNsYXRlZCBpbnRvIGl0cyBhZGRyZXNzLlxuICAgKiBTaG91bGQgYmUgdW5pcXVlIGFtb25nIHJvdXRlcnMgb24gdGhlIHNoYXJkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5yb3V0ZXJOdW1iZXIgPSByb3cucm91dGVyTnVtYmVyO1xuXG4gIC8qKlxuICAgKiBVbml4IHRpbWVzdGFtcCAobG9jYWwpIG9mIHJvdXRlciBjcmVhdGlvbiB0aW1lLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5jcmVhdGlvblRpbWUgPSB1dGlscy52YWx1ZU9yKHJvdy5jcmVhdGlvblRpbWUsIERhdGUubm93KCkpO1xuXG4gIC8qKlxuICAgKiBTZXRzIGN1cnJlbnQgRE5TIG1vZGUgZm9yIHRoZSByb3V0ZXIncyBsb2NhbCBuZXR3b3JrLlxuICAgKiBUaGlzIHZhbHVlIGlzIG1hbmlwdWxhdGVkIGJ5IGFsbCBjbGllbnRzLlxuICAgKiBAdHlwZSB7RG5zTW9kZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTW9kZSA9IHV0aWxzLnZhbHVlT3Iocm93LmRuc01vZGUsIGxldmVsQ29uZmlnLmRlZmF1bHREbnNNb2RlKTtcblxuICAvKipcbiAgICogU2V0cyBjdXJyZW50IEROUyBub2RlIElEIGZvciB0aGUgcm91dGVyJ3MgbG9jYWwgbmV0d29yay5cbiAgICogVGhpcyB2YWx1ZSBpcyBtYW5pcHVsYXRlZCBieSBhbGwgY2xpZW50cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTm9kZUlEID0gcm93LmRuc05vZGVJRDtcblxuICAvKipcbiAgICogU3BlZWQgKGluIGJpdHMgcGVyIHNlY29uZCkgYXQgd2hpY2ggbWVzc2FnZXMgYXJlIHByb2Nlc3NlZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuYmFuZHdpZHRoID0gdXRpbHMudmFsdWVPcihkZXNlcmlhbGl6ZU51bWJlcihyb3cuYmFuZHdpZHRoKSxcbiAgICAgIGxldmVsQ29uZmlnLmRlZmF1bHRSb3V0ZXJCYW5kd2lkdGgpO1xuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgZGF0YSAoaW4gYml0cykgdGhhdCB0aGUgcm91dGVyIHF1ZXVlIGNhbiBob2xkIGJlZm9yZSBpdCBzdGFydHNcbiAgICogZHJvcHBpbmcgcGFja2V0cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWVtb3J5ID0gdXRpbHMudmFsdWVPcihkZXNlcmlhbGl6ZU51bWJlcihyb3cubWVtb3J5KSxcbiAgICAgIGxldmVsQ29uZmlnLmRlZmF1bHRSb3V0ZXJNZW1vcnkpO1xuXG4gIC8qKlxuICAgKiBQZXJjZW50IGNoYW5jZSAoMC0xKSB0aGF0IGEgcGFja2V0IGJlaW5nIHJvdXRlZCB3aWxsIGJlIGRyb3BwZWQgZm9yIG5vXG4gICAqIHJlYXNvbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMucmFuZG9tRHJvcENoYW5jZSA9IHV0aWxzLnZhbHVlT3Iocm93LnJhbmRvbURyb3BDaGFuY2UsXG4gICAgICBsZXZlbENvbmZpZy5kZWZhdWx0UmFuZG9tRHJvcENoYW5jZSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgYSBzdWJzZXQgb2YgY29ubmVjdGlvbiBhbmQgbWVzc2FnZSBldmVudHMgdGhhdCB0aGlzXG4gICAqIHJvdXRlciB3aWxsIHJlc3BvbmQgdG8sIG9ubHkgbWFuYWdpbmcgZXZlbnRzIGZyb20gdGhlIGdpdmVuIG5vZGUgSUQsXG4gICAqIHRvIGF2b2lkIGNvbmZsaWN0aW5nIHdpdGggb3RoZXIgY2xpZW50cyBhbHNvIHNpbXVsYXRpbmcgdGhpcyByb3V0ZXIuXG4gICAqXG4gICAqIE5vdCBwZXJzaXN0ZWQgb24gc2VydmVyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaW11bGF0ZUZvclNlbmRlcl8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIExvY2FsIGNhY2hlIG9mIHRoZSBsYXN0IHRpY2sgdGltZSBpbiB0aGUgbG9jYWwgc2ltdWxhdGlvbi5cbiAgICogQWxsb3dzIHVzIHRvIHNjaGVkdWxlL3RpbWVzdGFtcCBldmVudHMgdGhhdCBkb24ndCBoYXBwZW4gaW5zaWRlIHRoZVxuICAgKiB0aWNrIGV2ZW50LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaW11bGF0aW9uVGltZV8gPSAwO1xuXG4gIC8qKlxuICAgKiBQYWNrZXQgZm9ybWF0IHNwZWNpZmljYXRpb24gdGhpcyByb3V0ZXIgd2lsbCB1c2UgdG8gcGFyc2UsIHJvdXRlLCBhbmQgbG9nXG4gICAqIHBhY2tldHMgdGhhdCBpdCByZWNlaXZlcy4gIFNldCBvbiByb3V0ZXIgdGhhdCBpcyBzaW11bGF0ZWQgYnkgY2xpZW50LlxuICAgKlxuICAgKiBOb3QgcGVyc2lzdGVkIG9uIHNlcnZlci5cbiAgICpcbiAgICogQHR5cGUge1BhY2tldC5IZWFkZXJUeXBlW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhY2tldFNwZWNfID0gW107XG5cbiAgLyoqXG4gICAqIExvY2FsIGNhY2hlIG9mIG91ciByZW1vdGUgcm93LCB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIG91ciBzdGF0ZSBoYXNcbiAgICogY2hhbmdlZC5cbiAgICogXG4gICAqIE5vdCBwZXJzaXN0ZWQgdG8gc2VydmVyLlxuICAgKiBcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc3RhdGVDYWNoZV8gPSB7fTtcbiAgXG4gIC8qKlxuICAgKiBFdmVudCBvdGhlcnMgY2FuIG9ic2VydmUsIHdoaWNoIHdlIGZpcmUgd2hlbiBvdXIgb3duIHJlbW90ZSByb3cgY2hhbmdlcy5cbiAgICogXG4gICAqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9XG4gICAqL1xuICB0aGlzLnN0YXRlQ2hhbmdlID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIC8qKlxuICAgKiBFdmVudCBvdGhlcnMgY2FuIG9ic2VydmUsIHdoaWNoIHdlIGZpcmUgd2hlbiB0aGUgcm91dGVyIHN0YXRpc3RpY3NcbiAgICogY2hhbmdlICh3aGljaCBtYXkgYmUgdmVyeSBmcmVxdWVudC4uLilcbiAgICpcbiAgICogQHR5cGUge09ic2VydmFibGVFdmVudH1cbiAgICovXG4gIHRoaXMuc3RhdHNDaGFuZ2UgPSBuZXcgT2JzZXJ2YWJsZUV2ZW50KCk7XG5cbiAgLyoqXG4gICAqIExvY2FsIGNhY2hlIG9mIHdpcmVzIGF0dGFjaGVkIHRvIHRoaXMgcm91dGVyLCB1c2VkIGZvciBkZXRlY3RpbmcgYW5kXG4gICAqIGJyb2FkY2FzdGluZyByZWxldmFudCBjaGFuZ2VzLlxuICAgKlxuICAgKiBOb3QgcGVyc2lzdGVkIG9uIHNlcnZlci5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5teVdpcmVSb3dDYWNoZV8gPSBbXTtcblxuICAvKipcbiAgICogRXZlbnQgb3RoZXJzIGNhbiBvYnNlcnZlLCB3aGljaCB3ZSBmaXJlIHdoZW4gdGhlIHJvdXRlcidzIHNldCBvZiB3aXJlc1xuICAgKiBjaGFuZ2VzIGluZGljYXRpbmcgYSBjaGFuZ2UgaW4gdGhlIGxvY2FsIG5ldHdvcmsuXG4gICAqXG4gICAqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9XG4gICAqL1xuICB0aGlzLndpcmVzQ2hhbmdlID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIC8qKlxuICAgKiBMb2NhbCBjYWNoZSBvZiBsb2cgcm93cyBhc3NvY2lhdGVkIHdpdGggdGhpcyByb3V0ZXIsIHVzZWQgZm9yIGRldGVjdGluZ1xuICAgKiBhbmQgYnJvYWRjYXN0aW5nIHJlbGV2YW50IGNoYW5nZXMuXG4gICAqIFxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm15TG9nUm93Q2FjaGVfID0gW107XG4gIFxuICAvKipcbiAgICogRXZlbnQgb3RoZXJzIGNhbiBvYnNlcnZlLCB3aGljaCB3ZSBmaXJlIHdoZW4gdGhlIHJvdXRlcidzIGxvZyBjb250ZW50XG4gICAqIGNoYW5nZXMuXG4gICAqIFxuICAgKiBAdHlwZSB7T2JzZXJ2YWJsZUV2ZW50fVxuICAgKi9cbiAgdGhpcy5sb2dDaGFuZ2UgPSBuZXcgT2JzZXJ2YWJsZUV2ZW50KCk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgcm91dGVyIGlzIGluIHRoZSBtaWRkbGUgb2Ygd29yay4gIEtlZXBzIHJvdXRlciBmcm9tIHBpY2tpbmcgdXBcbiAgICogaXRzIG93biBjaGFuZ2Ugbm90aWZpY2F0aW9ucyBvciBpbnRlcnJ1cHRpbmcgaXRzIG93biBwcm9jZXNzZXMuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc1JvdXRlclByb2Nlc3NpbmdfID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIExvY2FsIGNhY2hlIG9mIG1lc3NhZ2VzIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQgYnkgKGFueSBzaW11bGF0aW9uXG4gICAqIG9mKSB0aGUgcm91dGVyLiAgVXNlZCBmb3IgdHJhY2tpbmcgcm91dGVyIG1lbW9yeSwgdGhyb3VnaHB1dCwgZXRjLlxuICAgKiBAdHlwZSB7TmV0U2ltTWVzc2FnZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb3V0ZXJRdWV1ZUNhY2hlXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBTZXQgb2Ygc2NoZWR1bGVkICdyb3V0aW5nIGV2ZW50cydcbiAgICogQHR5cGUge09iamVjdFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5sb2NhbFJvdXRpbmdTY2hlZHVsZV8gPSBbXTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzQXV0b0Ruc1Byb2Nlc3NpbmdfID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIExvY2FsIGNhY2hlIG9mIG1lc3NhZ2VzIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQgYnkgKGFueSBzaW11bGF0aW9uXG4gICAqIG9mKSB0aGUgYXV0by1ETlMuIFVzZWQgZm9yIHN0YXRzIGFuZCBsaW1pdGluZy5cbiAgICogQHR5cGUge05ldFNpbU1lc3NhZ2VbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYXV0b0Ruc1F1ZXVlXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBNb3N0IGNsaWVudHMgdGhhdCBjYW4gYmUgY29ubmVjdGVkIHRvIHRoaXMgcm91dGVyLlxuICAgKiBNb3ZlZCB0byBpbnN0YW5jZSB2YXJpYWJsZSBzbyB0aGF0IHRlc3RzIGNhbiBvdmVycmlkZSBpdCBpbiBjZXJ0YWluIGNhc2VzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXhDbGllbnRDb25uZWN0aW9uc18gPSBNQVhfQ0xJRU5UX0NPTk5FQ1RJT05TO1xufTtcbk5ldFNpbVJvdXRlck5vZGUuaW5oZXJpdHMoTmV0U2ltTm9kZSk7XG5cbi8qKlxuICogU3RhdGljIGFzeW5jIGNyZWF0aW9uIG1ldGhvZC4gU2VlIE5ldFNpbUVudGl0eS5jcmVhdGUoKS5cbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgLSBNZXRob2QgdGhhdCB3aWxsIGJlIGdpdmVuIHRoZVxuICogICAgICAgIGNyZWF0ZWQgZW50aXR5LCBvciBudWxsIGlmIGVudGl0eSBjcmVhdGlvbiBmYWlsZWQuXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUuY3JlYXRlID0gZnVuY3Rpb24gKHNoYXJkLCBvbkNvbXBsZXRlKSB7XG4gIHZhciBuZXh0Um91dGVyTnVtYmVyID0gMTtcbiAgc2hhcmQubm9kZVRhYmxlLnJlYWRBbGwoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKE5vZGVUeXBlLlJPVVRFUiA9PT0gbm9kZS50eXBlICYmIG5vZGUucm91dGVyTnVtYmVyID49IG5leHRSb3V0ZXJOdW1iZXIpIHtcbiAgICAgIG5leHRSb3V0ZXJOdW1iZXIgPSBub2RlLnJvdXRlck51bWJlciArIDE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50aXR5ID0gbmV3IE5ldFNpbVJvdXRlck5vZGUoc2hhcmQsIHsgcm91dGVyTnVtYmVyOiBuZXh0Um91dGVyTnVtYmVyIH0pO1xuICBlbnRpdHkuZ2V0VGFibGUoKS5jcmVhdGUoZW50aXR5LmJ1aWxkUm93KCksIGZ1bmN0aW9uIChlcnIsIHJvdykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG9uQ29tcGxldGUoZXJyLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Db21wbGV0ZShudWxsLCBuZXcgTmV0U2ltUm91dGVyTm9kZShzaGFyZCwgcm93KSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgYXN5bmMgcmV0cmlldmFsIG1ldGhvZC4gIFNlZSBOZXRTaW1FbnRpdHkuZ2V0KCkuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvdXRlcklEIC0gVGhlIHJvdyBJRCBmb3IgdGhlIGVudGl0eSB5b3UnZCBsaWtlIHRvIGZpbmQuXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmRcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIC0gTWV0aG9kIHRoYXQgd2lsbCBiZSBnaXZlbiB0aGVcbiAqICAgICAgICBmb3VuZCBlbnRpdHksIG9yIG51bGwgaWYgZW50aXR5IHNlYXJjaCBmYWlsZWQuXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUuZ2V0ID0gZnVuY3Rpb24gKHJvdXRlcklELCBzaGFyZCwgb25Db21wbGV0ZSkge1xuICBOZXRTaW1FbnRpdHkuZ2V0KE5ldFNpbVJvdXRlck5vZGUsIHJvdXRlcklELCBzaGFyZCwgb25Db21wbGV0ZSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJvdXRlclJvd1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNyZWF0aW9uVGltZSAtIFVuaXggdGltZXN0YW1wIChsb2NhbClcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYW5kd2lkdGggLSBSb3V0ZXIgbWF4IHRyYW5zbWlzc2lvbi9wcm9jZXNzaW5nIHJhdGVcbiAqICAgICAgICAgICBpbiBiaXRzL3NlY29uZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1lbW9yeSAtIFJvdXRlciBtYXggcXVldWUgY2FwYWNpdHkgaW4gYml0c1xuICogQHByb3BlcnR5IHtEbnNNb2RlfSBkbnNNb2RlIC0gQ3VycmVudCBETlMgbW9kZSBmb3IgdGhlIGxvY2FsIG5ldHdvcmtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkbnNOb2RlSUQgLSBFbnRpdHkgSUQgb2YgdGhlIGN1cnJlbnQgRE5TIG5vZGUgaW4gdGhlXG4gKiAgICAgICAgICAgbG9jYWwgbmV0d29yay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYW5kb21Ecm9wQ2hhbmNlIC0gT2RkcyAoMC0xKSB0aGF0IGEgcGFja2V0IGJlaW5nIHJvdXRlZFxuICogICAgICAgICAgIHdpbGwgYmUgZHJvcHBlZCBmb3Igbm8gcmVhc29uLlxuICovXG5cbi8qKlxuICogQnVpbGQgdGFibGUgcm93IGZvciB0aGlzIG5vZGUuXG4gKiBAcmV0dXJucyB7Um91dGVyUm93fVxuICogQHByaXZhdGVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5idWlsZFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHV0aWxzLmV4dGVuZChcbiAgICAgIE5ldFNpbVJvdXRlck5vZGUuc3VwZXJQcm90b3R5cGUuYnVpbGRSb3cuY2FsbCh0aGlzKSxcbiAgICAgIHtcbiAgICAgICAgcm91dGVyTnVtYmVyOiB0aGlzLnJvdXRlck51bWJlcixcbiAgICAgICAgY3JlYXRpb25UaW1lOiB0aGlzLmNyZWF0aW9uVGltZSxcbiAgICAgICAgYmFuZHdpZHRoOiBzZXJpYWxpemVOdW1iZXIodGhpcy5iYW5kd2lkdGgpLFxuICAgICAgICBtZW1vcnk6IHNlcmlhbGl6ZU51bWJlcih0aGlzLm1lbW9yeSksXG4gICAgICAgIGRuc01vZGU6IHRoaXMuZG5zTW9kZSxcbiAgICAgICAgZG5zTm9kZUlEOiB0aGlzLmRuc05vZGVJRCxcbiAgICAgICAgcmFuZG9tRHJvcENoYW5jZTogdGhpcy5yYW5kb21Ecm9wQ2hhbmNlXG4gICAgICB9XG4gICk7XG59O1xuXG4vKipcbiAqIExvYWQgc3RhdGUgZnJvbSByZW1vdGVSb3cgaW50byBsb2NhbCBtb2RlbCwgdGhlbiBub3RpZnkgYW55dGhpbmcgb2JzZXJ2aW5nXG4gKiB1cyB0aGF0IHdlJ3ZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge1JvdXRlclJvd30gcmVtb3RlUm93XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5vbk15U3RhdGVDaGFuZ2VfID0gZnVuY3Rpb24gKHJlbW90ZVJvdykge1xuICB0aGlzLnJvdXRlck51bWJlciA9IHJlbW90ZVJvdy5yb3V0ZXJOdW1iZXI7XG4gIHRoaXMuY3JlYXRpb25UaW1lID0gcmVtb3RlUm93LmNyZWF0aW9uVGltZTtcbiAgdGhpcy5iYW5kd2lkdGggPSBkZXNlcmlhbGl6ZU51bWJlcihyZW1vdGVSb3cuYmFuZHdpZHRoKTtcbiAgdGhpcy5tZW1vcnkgPSBkZXNlcmlhbGl6ZU51bWJlcihyZW1vdGVSb3cubWVtb3J5KTtcbiAgdGhpcy5kbnNNb2RlID0gcmVtb3RlUm93LmRuc01vZGU7XG4gIHRoaXMuZG5zTm9kZUlEID0gcmVtb3RlUm93LmRuc05vZGVJRDtcbiAgdGhpcy5yYW5kb21Ecm9wQ2hhbmNlID0gcmVtb3RlUm93LnJhbmRvbURyb3BDaGFuY2U7XG4gIHRoaXMuc3RhdGVDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBxdWV1ZWQgcm91dGluZyBhbmQgRE5TIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgdGhpcy5zaW11bGF0aW9uVGltZV8gPSBjbG9jay50aW1lO1xuICB0aGlzLnJvdXRlT3ZlcmR1ZU1lc3NhZ2VzXyhjbG9jayk7XG4gIGlmICh0aGlzLmRuc01vZGUgPT09IERuc01vZGUuQVVUT01BVElDKSB7XG4gICAgdGhpcy50aWNrQXV0b0Ruc18oY2xvY2spO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbmFtZSBpcyBhIGJpdCBvZiBhIG1pc25vbWVyLCBidXQgaXQncyBtZW1vcmFibGU7IHdlIGFjdHVhbGx5IHJvdXRlXG4gKiBhbGwgbWVzc2FnZXMgdGhhdCBhcmUgRFVFIG9yIE9WRVJEVUUuXG4gKiBAcGFyYW0ge1J1bkxvb3AuQ2xvY2t9IGNsb2NrXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5yb3V0ZU92ZXJkdWVNZXNzYWdlc18gPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgaWYgKHRoaXMuaXNSb3V0ZXJQcm9jZXNzaW5nXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNlcGFyYXRlIG91dCBtZXNzYWdlcyB3aG9zZSBzY2hlZHVsZWQgdGltZSBoYXMgYXJyaXZlZCBvciBpcyBwYXN0LlxuICAvLyBGbGFnIHRoZW0gc28gd2UgY2FuIHJlbW92ZSB0aGVtIGxhdGVyLlxuICB2YXIgcmVhZHlTY2hlZHVsZU1lc3NhZ2VzID0gW107XG4gIHZhciBleHBpcmVkU2NoZWR1bGVNZXNzYWdlcyA9IFtdO1xuICB0aGlzLmxvY2FsUm91dGluZ1NjaGVkdWxlXy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGNsb2NrLnRpbWUgPj0gaXRlbS5jb21wbGV0aW9uVGltZSkge1xuICAgICAgaXRlbS5iZWluZ1JvdXRlZCA9IHRydWU7XG4gICAgICByZWFkeVNjaGVkdWxlTWVzc2FnZXMucHVzaChpdGVtLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoY2xvY2sudGltZSA+PSBpdGVtLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBpdGVtLmJlaW5nUm91dGVkID0gdHJ1ZTtcbiAgICAgIGV4cGlyZWRTY2hlZHVsZU1lc3NhZ2VzLnB1c2goaXRlbS5tZXNzYWdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIG5vIG1lc3NhZ2VzIGFyZSByZWFkeSwgd2UncmUgZG9uZS5cbiAgaWYgKHJlYWR5U2NoZWR1bGVNZXNzYWdlcy5sZW5ndGggKyBleHBpcmVkU2NoZWR1bGVNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaXJzdCwgcmVtb3ZlIHRoZSBleHBpcmVkIGl0ZW1zLiAgVGhleSBqdXN0IHNpbGVudGx5IHZhbmlzaFxuICB0aGlzLmlzUm91dGVyUHJvY2Vzc2luZ18gPSB0cnVlO1xuICBOZXRTaW1FbnRpdHkuZGVzdHJveUVudGl0aWVzKGV4cGlyZWRTY2hlZHVsZU1lc3NhZ2VzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBOZXh0LCBwcm9jZXNzIHRoZSBtZXNzYWdlcyB0aGF0IGFyZSByZWFkeSBmb3Igcm91dGluZ1xuICAgIHRoaXMucm91dGVNZXNzYWdlc18ocmVhZHlTY2hlZHVsZU1lc3NhZ2VzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIEZpbmFsbHksIHJlbW92ZSBhbGwgdGhlIHNjaGVkdWxlIGVudHJpZXMgdGhhdCB3ZSBmbGFnZ2VkIGVhcmxpZXJcbiAgICAgIHRoaXMubG9jYWxSb3V0aW5nU2NoZWR1bGVfID0gdGhpcy5sb2NhbFJvdXRpbmdTY2hlZHVsZV8uZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAhaXRlbS5iZWluZ1JvdXRlZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pc1JvdXRlclByb2Nlc3NpbmdfID0gZmFsc2U7XG5cbiAgICB9LmJpbmQodGhpcykpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBFeGFtaW5lIHRoZSBxdWV1ZSwgYW5kIGFkZC9hZGp1c3Qgc2NoZWR1bGUgZW50cmllcyBmb3IgcGFja2V0cyB0aGF0XG4gKiBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgbG9jYWwgc2ltdWxhdGlvbi4gIElmIGEgcGFja2V0IGhhcyBubyBlbnRyeSxcbiAqIGl0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgc2NoZWR1bGUuICBJZiBpdCBkb2VzIGFuZCB3ZSBjYW4gc2VlIHRoYXQgaXRzXG4gKiBzY2hlZHVsZWQgY29tcGxldGlvbiB0aW1lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIG1vdmUgaXQgdXAuXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnJlY2FsY3VsYXRlU2NoZWR1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRvIGNhbGN1bGF0ZSBvdXIgc2NoZWR1bGUsIHdlIGtlZXAgYSByb2xsaW5nIFwiUGVzc2ltaXN0aWMgY29tcGxldGlvbiB0aW1lXCJcbiAgLy8gYXMgd2Ugd2FsayBkb3duIHRoZSBxdWV1ZS4gIFRoaXMgXCJwZXNzaW1pc3RpYyB0aW1lXCIgaXMgd2hlbiB0aGUgcGFja2V0XG4gIC8vIHdvdWxkIGZpbmlzaCBwcm9jZXNzaW5nLCBhc3N1bWluZyBhbGwgb2YgdGhlIHBhY2tldHMgYWhlYWQgb2YgaXQgaW4gdGhlXG4gIC8vIHF1ZXVlIG11c3QgYmUgcHJvY2Vzc2VkIGZpcnN0IGFuZCB0aGUgZmlyc3QgcGFja2V0IGluIHRoZSBxdWV1ZSBpcyBqdXN0XG4gIC8vIHN0YXJ0aW5nIHRvIHByb2Nlc3Mgbm93LiAgV2UgZG8gdGhpcyBiZWNhdXNlIHRoZSBmaXJzdCBwYWNrZXQgbWlnaHQgYmVcbiAgLy8gb3duZWQgYnkgYSByZW1vdGUgY2xpZW50LCBzbyB3ZSB3b24ndCBoYXZlIHBhcnRpYWwgcHJvZ3Jlc3MgaW5mb3JtYXRpb25cbiAgLy8gb24gaXQuXG4gIC8vXG4gIC8vIFRodXMsIHRoZSBwZXNzaW1pc3RpYyB0aW1lIGlzIHRoZSBfbGF0ZXN0XyB3ZSB3b3VsZCBleHBlY3QgdGhlIHJvdXRlclxuICAvLyB0byBiZSBkb25lIHByb2Nlc3NpbmcgdGhlIHBhY2tldCBnaXZlbiB0aGUgY3VycmVudCBiYW5kd2lkdGggc2V0dGluZyxcbiAgLy8gaWYgdGhlIHJvdXRlciB3YXMgYW4gYWN0dWFsIGhhcmR3YXJlIGRldmljZS5cbiAgLy9cbiAgLy8gVGhlIGVzdGltYXRlIGlzIGFjdHVhbGx5IF9vcHRpbWlzdGljXyBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBkb2Vzbid0IHdhaXRcbiAgLy8gZm9yIG5vdGlmaWNhdGlvbiB0aGF0IGEgcmVtb3RlbHktc2ltdWxhdGVkIHBhY2tldCBpcyBkb25lIGJlZm9yZVxuICAvLyBwcm9jZXNzaW5nIGEgbG9jYWxseS1zaW11bGF0ZWQgb25lLiAgV2UncmUgbWFraW5nIG91ciBiZXN0IGd1ZXNzIGFib3V0XG4gIC8vIGhvdyB0aGUgcGFja2V0cyB3b3VsZCBiZSB0aW1lZCB3aXRoIG5vIGxhdGVuY3kgaW50cm9kdWNpbmcgZ2FwcyBiZXR3ZWVuXG4gIC8vIHBhY2tldHMuXG4gIC8vXG4gIC8vIElmIHRoZSBjbGllbnQgc2ltdWxhdGluZyB0aGUgcGFja2V0IGF0IHRoZSBoZWFkIG9mIHRoZSBxdWV1ZSBkaXNjb25uZWN0c1xuICAvLyBpdCB3b24ndCBibG9jayBvdGhlciBwYWNrZXRzIGZyb20gYmVpbmcgc2VudCwgYnV0IGl0IHdpbGwgaW5jcmVhc2UgdGhlaXJcbiAgLy8gXCJwZXNzaW1pc3RpYyBlc3RpbWF0ZXNcIiB1bnRpbCB0aGF0IG9ycGhhbmVkIHBhY2tldCBnZXRzIGNsZWFuZWQgdXAuXG5cbiAgdmFyIHF1ZXVlU2l6ZUluQml0cyA9IDA7XG4gIHZhciBwZXNzaW1pc3RpY0NvbXBsZXRpb25UaW1lID0gdGhpcy5zaW11bGF0aW9uVGltZV87XG4gIHZhciBxdWV1ZWRNZXNzYWdlO1xuICB2YXIgcHJvY2Vzc2luZ0R1cmF0aW9uO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm91dGVyUXVldWVDYWNoZV8ubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZWRNZXNzYWdlID0gdGhpcy5yb3V0ZXJRdWV1ZUNhY2hlX1tpXTtcbiAgICBxdWV1ZVNpemVJbkJpdHMgKz0gcXVldWVkTWVzc2FnZS5wYXlsb2FkLmxlbmd0aDtcbiAgICBwcm9jZXNzaW5nRHVyYXRpb24gPSB0aGlzLmNhbGN1bGF0ZVByb2Nlc3NpbmdEdXJhdGlvbkZvck1lc3NhZ2VfKHF1ZXVlZE1lc3NhZ2UpO1xuICAgIHBlc3NpbWlzdGljQ29tcGxldGlvblRpbWUgKz0gcHJvY2Vzc2luZ0R1cmF0aW9uO1xuXG4gICAgLy8gRG9uJ3Qgc2NoZWR1bGUgYmV5b25kIG1lbW9yeSBjYXBhY2l0eTsgd2UncmUgZ29pbmcgdG8gZHJvcCB0aG9zZSBwYWNrZXRzXG4gICAgaWYgKHRoaXMubG9jYWxTaW11bGF0aW9uT3duc01lc3NhZ2VfKHF1ZXVlZE1lc3NhZ2UpICYmXG4gICAgICAgIHF1ZXVlU2l6ZUluQml0cyA8PSB0aGlzLm1lbW9yeSkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJvdXRpbmdGb3JNZXNzYWdlKHF1ZXVlZE1lc3NhZ2UsIHBlc3NpbWlzdGljQ29tcGxldGlvblRpbWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHNjaGVkdWxlIGZvciB0aGUgcXVldWVkIHJvdy4gIElmIG5vIHNjaGVkdWxlIGVudHJ5IGV4aXN0cywgYWRkc1xuICogYSBuZXcgb25lIHdpdGggdGhlIHByb3ZpZGVkIHBlc3NpbWlzdGljIGNvbXBsZXRpb24gdGltZS4gIElmIGl0J3MgYWxyZWFkeVxuICogc2NoZWR1bGVkIGFuZCB0aGUgcGVzc2ltaXN0aWMgdGltZSBnaXZlbiBpcyBCRVRURVIgdGhhbiB0aGUgcHJldmlvdXNseVxuICogc2NoZWR1bGVkIGNvbXBsZXRpb24gdGltZSwgd2lsbCB1cGRhdGUgdGhlIHNjaGVkdWxlIGVudHJ5IHdpdGggdGhlIGJldHRlclxuICogdGltZS5cbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZX0gcXVldWVkTWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IHBlc3NpbWlzdGljQ29tcGxldGlvblRpbWUgLSBpbiBsb2NhbCBzaW11bGF0aW9uIHRpbWVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuc2NoZWR1bGVSb3V0aW5nRm9yTWVzc2FnZSA9IGZ1bmN0aW9uIChxdWV1ZWRNZXNzYWdlLFxuICAgIHBlc3NpbWlzdGljQ29tcGxldGlvblRpbWUpIHtcbiAgdmFyIHNjaGVkdWxlSXRlbSA9IF8uZmluZCh0aGlzLmxvY2FsUm91dGluZ1NjaGVkdWxlXywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5tZXNzYWdlLmVudGl0eUlEID09PSBxdWV1ZWRNZXNzYWdlLmVudGl0eUlEO1xuICB9KTtcblxuICBpZiAoc2NoZWR1bGVJdGVtKSB7XG4gICAgLy8gV2hlbiBvdXIgcGVzc2ltaXN0aWMgdGltZSBpcyBiZXR0ZXIgdGhhbiBvdXIgc2NoZWR1bGVkIHRpbWUgd2VcbiAgICAvLyBzaG91bGQgdXBkYXRlIHRoZSBzY2hlZHVsZWQgdGltZS4gIFRoaXMgY2FuIGhhcHBlbiB3aGVuIG1lc3NhZ2VzXG4gICAgLy8gZWFybGllciBpbiB0aGUgcXVldWUgZXhwaXJlLCBvciBhcmUgb3RoZXJ3aXNlIHJlbW92ZWQgZWFybGllciB0aGFuXG4gICAgLy8gdGhlaXIgc2l6ZSBsZWQgdXMgdG8gZXhwZWN0LlxuICAgIGlmIChwZXNzaW1pc3RpY0NvbXBsZXRpb25UaW1lIDwgc2NoZWR1bGVJdGVtLmNvbXBsZXRpb25UaW1lKSB7XG4gICAgICBzY2hlZHVsZUl0ZW0uY29tcGxldGlvblRpbWUgPSBwZXNzaW1pc3RpY0NvbXBsZXRpb25UaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgaXRlbSBkb2Vzbid0IGhhdmUgYSBzY2hlZHVsZSBlbnRyeSBhdCBhbGwsIGFkZCBpdFxuICAgIHRoaXMuYWRkTWVzc2FnZVRvU2NoZWR1bGVfKHF1ZXVlZE1lc3NhZ2UsIHBlc3NpbWlzdGljQ29tcGxldGlvblRpbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIHJvdXRpbmcgc2NoZWR1bGUsIHdpdGggYSBkZWZhdWx0IGV4cGlyYXRpb24gdGltZS5cbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZX0gcXVldWVkTWVzc2FnZSAtIG1lc3NhZ2UgdG8gcm91dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wbGV0aW9uVGltZSAtIGluIHNpbXVsYXRpb24gdGltZVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuYWRkTWVzc2FnZVRvU2NoZWR1bGVfID0gZnVuY3Rpb24gKHF1ZXVlZE1lc3NhZ2UsXG4gICAgY29tcGxldGlvblRpbWUpIHtcbiAgdGhpcy5sb2NhbFJvdXRpbmdTY2hlZHVsZV8ucHVzaCh7XG4gICAgbWVzc2FnZTogcXVldWVkTWVzc2FnZSxcbiAgICBjb21wbGV0aW9uVGltZTogY29tcGxldGlvblRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuc2ltdWxhdGlvblRpbWVfICsgUEFDS0VUX01BWF9MSUZFVElNRV9NUyxcbiAgICBiZWluZ1JvdXRlZDogZmFsc2VcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbWVzc2FnZSBvdXQgb2YgdGhlIHJvdXRpbmcgc2NoZWR1bGUuICBNb2RpZmllcyB0aGUgc2NoZWR1bGUsXG4gKiBzaG91bGQgbm90IGJlIGNhbGxlZCB3aGlsZSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgc2NoZWR1bGUhXG4gKiBEb2VzIG5vdGhpbmcgaWYgdGhlIG1lc3NhZ2UgaXNuJ3QgcHJlc2VudCBpbiB0aGUgc2NoZWR1bGUuXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IHF1ZXVlZE1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnJlbW92ZU1lc3NhZ2VGcm9tU2NoZWR1bGVfID0gZnVuY3Rpb24gKHF1ZXVlZE1lc3NhZ2UpIHtcbiAgdmFyIHNjaGVkdWxlSWR4O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWxSb3V0aW5nU2NoZWR1bGVfLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMubG9jYWxSb3V0aW5nU2NoZWR1bGVfW2ldLm1lc3NhZ2UuZW50aXR5SUQgPT09IHF1ZXVlZE1lc3NhZ2UuZW50aXR5SUQpIHtcbiAgICAgIHNjaGVkdWxlSWR4ID0gaTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjaGVkdWxlSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmxvY2FsUm91dGluZ1NjaGVkdWxlXy5zcGxpY2Uoc2NoZWR1bGVJZHgsIDEpO1xuICB9XG59O1xuXG4vKipcbiAqIExldHMgdGhlIGF1dG8tRE5TIHBhcnQgb2YgdGhlIHJvdXRlciBzaW11bGF0aW9uIGhhbmRsZSBpdHMgcmVxdWVzdHMuXG4gKiBGb3Igbm93LCBhdXRvLUROUyBjYW4gZG8gXCJiYXRjaFwiIHByb2Nlc3NpbmcsIG5vIHRocm91Z2hwdXQgbGltaXRzLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUudGlja0F1dG9EbnNfID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0F1dG9EbnNQcm9jZXNzaW5nXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpbHRlciBETlMgcXVldWUgZG93biB0byByZXF1ZXN0cyB0aGUgbG9jYWwgc2ltdWxhdGlvbiBzaG91bGQgaGFuZGxlLlxuICB2YXIgbG9jYWxTaW1EbnNSZXF1ZXN0cyA9IHRoaXMuYXV0b0Ruc1F1ZXVlX1xuICAgICAgLmZpbHRlcih0aGlzLmxvY2FsU2ltdWxhdGlvbk93bnNNZXNzYWdlXy5iaW5kKHRoaXMpKTtcblxuICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIHByb2Nlc3MsIHdlJ3JlIGRvbmUuXG4gIGlmIChsb2NhbFNpbURuc1JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFByb2Nlc3MgRE5TIHJlcXVlc3RzXG4gIHRoaXMuaXNBdXRvRG5zUHJvY2Vzc2luZ18gPSB0cnVlO1xuICB0aGlzLnByb2Nlc3NBdXRvRG5zUmVxdWVzdHNfKGxvY2FsU2ltRG5zUmVxdWVzdHMsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzQXV0b0Ruc1Byb2Nlc3NpbmdfID0gZmFsc2U7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKiogQGluaGVyaXRkb2MgKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLmJyb2FkY2FzdE1vZGUpIHtcbiAgICByZXR1cm4gaTE4bi5yb29tTnVtYmVyWCh7XG4gICAgICB4OiB0aGlzLmdldFJvdXRlck51bWJlcigpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaTE4bi5yb3V0ZXJOdW1iZXJYKHtcbiAgICB4OiB0aGlzLmdldFJvdXRlck51bWJlcigpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHaXZlbiB0aGUgbGV2ZWwgYWRkcmVzcyBmb3JtYXQgc3RyaW5nIChlLmcuIFwiNC40LjQuNFwiKSB3aGljaCBpdCBwdWxscyBmcm9tXG4gKiBnbG9iYWxzLCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwYXJzZWQgbGVuZ3RocyBvZiBlYWNoIGZvcm1hdCBwYXJ0IGluIG9yZGVyXG4gKiAoZS5nLiBbNCwgNCwgNCwgNF0pLlxuICogQHJldHVybnMge251bWJlcltdfVxuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzRm9ybWF0UGFydHMoKSB7XG4gIHJldHVybiBOZXRTaW1HbG9iYWxzXG4gICAgICAuZ2V0TGV2ZWxDb25maWcoKVxuICAgICAgLmFkZHJlc3NGb3JtYXRcbiAgICAgIC5zcGxpdCgvXFxEKy8pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0Lmxlbmd0aCA+IDA7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocGFydCwgMTApO1xuICAgICAgfSk7XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcHJldmVudHMgdGhlIHJvdXRlcidzIGRpc3BsYXkgbnVtYmVyIG9yIGFkZHJlc3MgZnJvbSBiZWluZyBiZXlvbmRcbiAqIHRoZSByZXByZXNlbnRhYmxlIHNpemUgb2YgdGhlIHRoZSByb3V0ZXIgcGFydCBpbiB0aGUgYWRkcmVzcyBmb3JtYXQgKGlmXG4gKiB0d28tcGFydCBhZGRyZXNzZXMgYXJlIGJlaW5nIHVzZWQpLlxuICogRG9lcyBub3QgZG8gYW55dGhpbmcgc3BlY2lhbCB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIGp1c3QgcmV0dXJucyBlbnRpdHlJRFxuICogbW9kdWxvIHRoZSBhc3NpZ25hYmxlIGFkZHJlc3Mgc3BhY2UgLSBidXQgdGhpcyB3aWxsIGJlIGJldHRlciB0aGFuIGhhdmluZ1xuICogbm9uLWNvbmZsaWN0aW5nIHJvdXRlcnMgeW91IGNhbiBuZXZlciBhZGRyZXNzIGF0IGFsbC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldFJvdXRlck51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSWYgdHdvIG9yIG1vcmUgcGFydHMsIGxpbWl0IG91ciByb3V0ZXIgbnVtYmVyIHRvIHRoZSBtYXhpbXVtIHZhbHVlIG9mXG4gIC8vIHRoZSBzZWNvbmQtdG8tbGFzdCBhZGRyZXNzIHBhcnQuXG4gIHZhciBhZGRyZXNzRm9ybWF0UGFydHMgPSBnZXRBZGRyZXNzRm9ybWF0UGFydHMoKTtcbiAgaWYgKGFkZHJlc3NGb3JtYXRQYXJ0cy5sZW5ndGggPj0gMikge1xuICAgIHZhciBhc3NpZ25hYmxlQWRkcmVzc1ZhbHVlcyA9IE1hdGgucG93KDIsIGFkZHJlc3NGb3JtYXRQYXJ0cy5yZXZlcnNlKClbMV0pO1xuICAgIHJldHVybiB0aGlzLnJvdXRlck51bWJlciAlIGFzc2lnbmFibGVBZGRyZXNzVmFsdWVzO1xuICB9XG4gIHJldHVybiB0aGlzLnJvdXRlck51bWJlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3V0ZXJzIHRoYXQgd2lsbCBiZSBhbGxvd2VkIG9uIHRoZSBzaGFyZC5cbiAqIEluIG1vc3QgbGV2ZWxzIHRoaXMgaXMgYSBzdHJpY3QgZ2xvYmFsIHZhbHVlIChwcm9iYWJseSAyMCkuXG4gKiBJbiBsZXZlbHMgdXNpbmcgYW4gYWRkcmVzcyBmb3JtYXQgd2l0aCB0d28gb3IgbW9yZSBwYXJ0cyB0aGUgc2Vjb25kLXRvLWxhc3RcbiAqIHBhcnQgZGV0ZXJtaW5lcyB0aGUgYWRkcmVzc2FibGUgc3BhY2UgZm9yIHJvdXRlcnMsIGFuZCB0aGUgbWF4IHJvdXRlcnNcbiAqIHdpbGwgYmUgdGhlIG1pbmltdW0gb2YgdGhlIGdsb2JhbCBtYXggYW5kIHRoZSBhZGRyZXNzYWJsZSBzcGFjZS5cbiAqXG4gKiBAZXhhbXBsZSBJZiB0aGUgZ2xvYmFsIG1heCByb3V0ZXJzIGlzIDIwLCBidXQgdGhlIGFkZHJlc3MgZm9ybWF0IGlzIDQuNCxcbiAqICAgICAgICAgIHdlIGNhbiBvbmx5IGFkZHJlc3MgMTYgcm91dGVycyAobGVzcyB0aGFuIDIwKSBzbyAxNiBpcyBvdXIgbWF4XG4gKiAgICAgICAgICByb3V0ZXJzIHBlciBzaGFyZCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLmdldE1heGltdW1Sb3V0ZXJzUGVyU2hhcmQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElmIHR3byBvciBtb3JlIHBhcnRzLCBsaW1pdCBvdXIgcm91dGVycyB0byB0aGUgbWF4aW11bSB2YWx1ZSBvZlxuICAvLyB0aGUgc2Vjb25kLXRvLWxhc3QgYWRkcmVzcyBwYXJ0LlxuICB2YXIgYWRkcmVzc0Zvcm1hdFBhcnRzID0gZ2V0QWRkcmVzc0Zvcm1hdFBhcnRzKCk7XG4gIGlmIChhZGRyZXNzRm9ybWF0UGFydHMubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTmV0U2ltR2xvYmFscy5nZXRHbG9iYWxNYXhSb3V0ZXJzKCksXG4gICAgICAgIE1hdGgucG93KDIsIGFkZHJlc3NGb3JtYXRQYXJ0cy5yZXZlcnNlKClbMV0pKTtcbiAgfVxuICByZXR1cm4gTmV0U2ltR2xvYmFscy5nZXRHbG9iYWxNYXhSb3V0ZXJzKCk7XG59O1xuXG4vKipcbiAqIEdldCBub2RlJ3Mgb3duIGFkZHJlc3MsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGUgYWRkcmVzcyBmb3JtYXRcbiAqIGNvbmZpZ3VyZWQgaW4gdGhlIGxldmVsIGJ1dCBmb3Igcm91dGVycyBhbHdheXMgZW5kcyBpbiB6ZXJvLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFrZUxvY2FsTmV0d29ya0FkZHJlc3NfKFJPVVRFUl9MT0NBTF9BRERSRVNTKTtcbn07XG5cbi8qKlxuICogR2V0IGxvY2FsIG5ldHdvcmsncyBhdXRvLWRucyBhZGRyZXNzLCB3aGljaCBpcyBkZXBlbmRlbnQgb24gdGhlIGFkZHJlc3NcbiAqIGZvcm1hdCBjb25maWd1cmVkIGZvciB0aGUgbGV2ZWwgYnV0IHRoZSBsYXN0IHBhcnQgc2hvdWxkIGFsd2F5cyBiZSAxNS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldEF1dG9EbnNBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYWtlTG9jYWxOZXR3b3JrQWRkcmVzc18oQVVUT19ETlNfUkVTRVJWRURfQUREUkVTUyk7XG59O1xuXG4vKipcbiAqIEdldCBub2RlJ3MgaG9zdG5hbWUsIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBpdHMgZGlzcGxheSBuYW1lLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXRIb3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVXNlIHJlZ2V4IHRvIHN0cmlwIGFueXRoaW5nIHRoYXQncyBub3QgYSB3b3JkLWNoYXJhY3RlciBvciBhIGRpZ2l0XG4gIC8vIGZyb20gdGhlIG5vZGUncyBkaXNwbGF5IG5hbWUuICBGb3Igcm91dGVycywgd2UgZG9uJ3QgYXBwZW5kIHRoZSBub2RlIElEXG4gIC8vIGJlY2F1c2UgaXQncyBhbHJlYWR5IHBhcnQgb2YgdGhlIGRpc3BsYXkgbmFtZS5cbiAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheU5hbWUoKS5yZXBsYWNlKC9bXlxcd1xcZF0vZywgJycpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKiogQGluaGVyaXRkb2MgKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldE5vZGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTm9kZVR5cGUuUk9VVEVSO1xufTtcblxuLyoqIEBpbmhlcml0ZG9jICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgdmFyIGNvbm5lY3Rpb25Db3VudCA9IHRoaXMuY291bnRDb25uZWN0aW9ucygpO1xuICBpZiAoY29ubmVjdGlvbkNvdW50ID09PSAwKSB7XG4gICAgaWYgKGxldmVsQ29uZmlnLmJyb2FkY2FzdE1vZGUpIHtcbiAgICAgIHJldHVybiBpMThuLnJvb21TdGF0dXNOb0Nvbm5lY3Rpb25zKHtcbiAgICAgICAgbWF4aW11bUNsaWVudHM6IHRoaXMubWF4Q2xpZW50Q29ubmVjdGlvbnNfXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaTE4bi5yb3V0ZXJTdGF0dXNOb0Nvbm5lY3Rpb25zKHtcbiAgICAgIG1heGltdW1DbGllbnRzOiB0aGlzLm1heENsaWVudENvbm5lY3Rpb25zX1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNvbm5lY3RlZE5vZGVOYW1lcyA9IHRoaXMuZ2V0Q29ubmVjdGVkTm9kZU5hbWVzXygpLmpvaW4oJywgJyk7XG4gIGlmIChjb25uZWN0aW9uQ291bnQgPj0gdGhpcy5tYXhDbGllbnRDb25uZWN0aW9uc18pIHtcbiAgICBpZiAobGV2ZWxDb25maWcuYnJvYWRjYXN0TW9kZSkge1xuICAgICAgcmV0dXJuIGkxOG4ucm9vbVN0YXR1c0Z1bGwoe1xuICAgICAgICBjb25uZWN0ZWRDbGllbnRzOiBjb25uZWN0ZWROb2RlTmFtZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpMThuLnJvdXRlclN0YXR1c0Z1bGwoe1xuICAgICAgY29ubmVjdGVkQ2xpZW50czogY29ubmVjdGVkTm9kZU5hbWVzXG4gICAgfSk7XG4gIH1cblxuICBpZiAobGV2ZWxDb25maWcuYnJvYWRjYXN0TW9kZSkge1xuICAgIHJldHVybiBpMThuLnJvb21TdGF0dXMoe1xuICAgICAgY29ubmVjdGVkQ2xpZW50czogY29ubmVjdGVkTm9kZU5hbWVzLFxuICAgICAgcmVtYWluaW5nU3BhY2U6ICh0aGlzLm1heENsaWVudENvbm5lY3Rpb25zXyAtIGNvbm5lY3Rpb25Db3VudClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBpMThuLnJvdXRlclN0YXR1cyh7XG4gICAgY29ubmVjdGVkQ2xpZW50czogY29ubmVjdGVkTm9kZU5hbWVzLFxuICAgIHJlbWFpbmluZ1NwYWNlOiAodGhpcy5tYXhDbGllbnRDb25uZWN0aW9uc18gLSBjb25uZWN0aW9uQ291bnQpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBuYW1lcyBvZiBhbGwgdGhlIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIHJvdXRlci5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldENvbm5lY3RlZE5vZGVOYW1lc18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWNoZWROb2RlUm93cyA9IHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCk7XG4gIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb25zKCkubWFwKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgdmFyIG5vZGVSb3cgPSBfLmZpbmQoY2FjaGVkTm9kZVJvd3MsIGZ1bmN0aW9uIChub2RlUm93KSB7XG4gICAgICByZXR1cm4gbm9kZVJvdy5pZCA9PT0gd2lyZS5sb2NhbE5vZGVJRDtcbiAgICB9KTtcbiAgICBpZiAobm9kZVJvdykge1xuICAgICAgcmV0dXJuIG5vZGVSb3cubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGkxOG4udW5rbm93bk5vZGUoKTtcbiAgfSk7XG59O1xuXG4vKiogQGluaGVyaXRkb2MgKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmlzRnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZXJtaW5lIHN0YXR1cyBiYXNlZCBvbiBjYWNoZWQgd2lyZSBkYXRhXG4gIHZhciBjYWNoZWRXaXJlUm93cyA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWFkQWxsKCk7XG4gIHZhciBpbmNvbWluZ1dpcmVSb3dzID0gY2FjaGVkV2lyZVJvd3MuZmlsdGVyKGZ1bmN0aW9uICh3aXJlUm93KSB7XG4gICAgcmV0dXJuIHdpcmVSb3cucmVtb3RlTm9kZUlEID09PSB0aGlzLmVudGl0eUlEO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gaW5jb21pbmdXaXJlUm93cy5sZW5ndGggPj0gdGhpcy5tYXhDbGllbnRDb25uZWN0aW9uc187XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgZ2l2ZW4gc3BlY2lmaWNhdGlvbiBjb250YWlucyB0aGUgZmllbGRzIHRoYXQgdGhpc1xuICogcm91dGVyIG5lZWRzIHRvIGRvIGl0cyBqb2IuXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlW119IHBhY2tldFNwZWNcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnZhbGlkYXRlUGFja2V0U3BlY18gPSBmdW5jdGlvbiAocGFja2V0U3BlYykge1xuICAvLyBUaGVyZSBhcmUgbm8gcmVxdWlyZW1lbnRzIGluIGJyb2FkY2FzdCBtb2RlXG4gIGlmIChOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCkuYnJvYWRjYXN0TW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlcXVpcmUgVE9fQUREUkVTUyBmb3Igcm91dGluZ1xuICBpZiAoIXBhY2tldFNwZWMuc29tZShmdW5jdGlvbiAoaGVhZGVyRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckZpZWxkID09PSBQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTO1xuICAgICAgfSkpIHtcbiAgICBsb2dnZXIud2FybihcIlBhY2tldCBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGhhdmUgYSB0b0FkZHJlc3MgZmllbGQuXCIpO1xuICB9XG5cbiAgLy8gUmVxdWlyZSBGUk9NX0FERFJFU1MgZm9yIGF1dG8tRE5TIHRhc2tzXG4gIGlmICghcGFja2V0U3BlYy5zb21lKGZ1bmN0aW9uIChoZWFkZXJGaWVsZCkge1xuICAgICAgICByZXR1cm4gaGVhZGVyRmllbGQgPT09IFBhY2tldC5IZWFkZXJUeXBlLkZST01fQUREUkVTUztcbiAgICAgIH0pKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJQYWNrZXQgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBoYXZlIGEgZnJvbUFkZHJlc3MgZmllbGQuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIFB1dHMgdGhpcyByb3V0ZXIgY29udHJvbGxlciBpbnRvIGEgbW9kZSB3aGVyZSBpdCB3aWxsIG9ubHlcbiAqIHNpbXVsYXRlIGZvciBjb25uZWN0aW9uIGFuZCBtZXNzYWdlcyAtZnJvbS0gdGhlIGdpdmVuIG5vZGUuXG4gKiBAcGFyYW0geyFudW1iZXJ9IG5vZGVJRFxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5pbml0aWFsaXplU2ltdWxhdGlvbiA9IGZ1bmN0aW9uIChub2RlSUQpIHtcbiAgdGhpcy5zaW11bGF0ZUZvclNlbmRlcl8gPSBub2RlSUQ7XG4gIHRoaXMucGFja2V0U3BlY18gPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCkucm91dGVyRXhwZWN0c1BhY2tldEhlYWRlcjtcbiAgdGhpcy52YWxpZGF0ZVBhY2tldFNwZWNfKHRoaXMucGFja2V0U3BlY18pO1xuXG4gIGlmIChub2RlSUQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBub2RlQ2hhbmdlRXZlbnQgPSB0aGlzLnNoYXJkXy5ub2RlVGFibGUudGFibGVDaGFuZ2U7XG4gICAgdmFyIG5vZGVDaGFuZ2VIYW5kbGVyID0gdGhpcy5vbk5vZGVUYWJsZUNoYW5nZV8uYmluZCh0aGlzKTtcbiAgICB0aGlzLm5vZGVDaGFuZ2VLZXlfID0gbm9kZUNoYW5nZUV2ZW50LnJlZ2lzdGVyKG5vZGVDaGFuZ2VIYW5kbGVyKTtcbiAgICBcbiAgICB2YXIgd2lyZUNoYW5nZUV2ZW50ID0gdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnRhYmxlQ2hhbmdlO1xuICAgIHZhciB3aXJlQ2hhbmdlSGFuZGxlciA9IHRoaXMub25XaXJlVGFibGVDaGFuZ2VfLmJpbmQodGhpcyk7XG4gICAgdGhpcy53aXJlQ2hhbmdlS2V5XyA9IHdpcmVDaGFuZ2VFdmVudC5yZWdpc3Rlcih3aXJlQ2hhbmdlSGFuZGxlcik7XG5cbiAgICB2YXIgbG9nQ2hhbmdlRXZlbnQgPSB0aGlzLnNoYXJkXy5sb2dUYWJsZS50YWJsZUNoYW5nZTtcbiAgICB2YXIgbG9nQ2hhbmdlSGFuZGxlciA9IHRoaXMub25Mb2dUYWJsZUNoYW5nZV8uYmluZCh0aGlzKTtcbiAgICB0aGlzLmxvZ0NoYW5nZUtleV8gPSBsb2dDaGFuZ2VFdmVudC5yZWdpc3Rlcihsb2dDaGFuZ2VIYW5kbGVyKTtcblxuICAgIHZhciBuZXdNZXNzYWdlRXZlbnQgPSB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGUudGFibGVDaGFuZ2U7XG4gICAgdmFyIG5ld01lc3NhZ2VIYW5kbGVyID0gdGhpcy5vbk1lc3NhZ2VUYWJsZUNoYW5nZV8uYmluZCh0aGlzKTtcbiAgICB0aGlzLm5ld01lc3NhZ2VFdmVudEtleV8gPSBuZXdNZXNzYWdlRXZlbnQucmVnaXN0ZXIobmV3TWVzc2FnZUhhbmRsZXIpO1xuXG4gICAgLy8gUG9wdWxhdGUgcm91dGVyIHdpcmUgY2FjaGUgd2l0aCBpbml0aWFsIGRhdGFcbiAgICB0aGlzLm9uV2lyZVRhYmxlQ2hhbmdlXygpO1xuXG4gICAgLy8gUG9wdWxhdGUgcm91dGVyIGxvZyBjYWNoZSB3aXRoIGluaXRpYWwgZGF0YVxuICAgIHRoaXMub25Mb2dUYWJsZUNoYW5nZV8oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHaXZlcyB0aGUgc2ltdWxhdGluZyBub2RlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIgZnJvbSBhbnl0aGluZyBpdFxuICogd2FzIG9ic2VydmluZy5cbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm5vZGVDaGFuZ2VLZXlfICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbm9kZUNoYW5nZUV2ZW50ID0gdGhpcy5zaGFyZF8ubm9kZVRhYmxlLnRhYmxlQ2hhbmdlO1xuICAgIG5vZGVDaGFuZ2VFdmVudC51bnJlZ2lzdGVyKHRoaXMubm9kZUNoYW5nZUtleV8pO1xuICAgIHRoaXMubm9kZUNoYW5nZUtleV8gPSB1bmRlZmluZWQ7XG4gIH1cbiAgXG4gIGlmICh0aGlzLndpcmVDaGFuZ2VLZXlfICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgd2lyZUNoYW5nZUV2ZW50ID0gdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnRhYmxlQ2hhbmdlO1xuICAgIHdpcmVDaGFuZ2VFdmVudC51bnJlZ2lzdGVyKHRoaXMud2lyZUNoYW5nZUtleV8pO1xuICAgIHRoaXMud2lyZUNoYW5nZUtleV8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodGhpcy5sb2dDaGFuZ2VLZXlfICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbG9nQ2hhbmdlRXZlbnQgPSB0aGlzLnNoYXJkXy5sb2dUYWJsZS50YWJsZUNoYW5nZTtcbiAgICBsb2dDaGFuZ2VFdmVudC51bnJlZ2lzdGVyKHRoaXMubG9nQ2hhbmdlS2V5Xyk7XG4gICAgdGhpcy5sb2dDaGFuZ2VLZXlfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHRoaXMubmV3TWVzc2FnZUV2ZW50S2V5XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG5ld01lc3NhZ2VFdmVudCA9IHRoaXMuc2hhcmRfLm1lc3NhZ2VUYWJsZS50YWJsZUNoYW5nZTtcbiAgICBuZXdNZXNzYWdlRXZlbnQudW5yZWdpc3Rlcih0aGlzLm5ld01lc3NhZ2VFdmVudEtleV8pO1xuICAgIHRoaXMubmV3TWVzc2FnZUV2ZW50S2V5XyA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLyoqXG4gKiBQdXRzIHRoZSByb3V0ZXIgaW50byB0aGUgZ2l2ZW4gRE5TIG1vZGUsIHRyaWdnZXJzIGEgcmVtb3RlIHVwZGF0ZSxcbiAqIGFuZCBjcmVhdGVzL2Rlc3Ryb3lzIHRoZSBuZXR3b3JrJ3MgYXV0b21hdGljIEROUyBub2RlLlxuICogQHBhcmFtIHtEbnNNb2RlfSBuZXdEbnNNb2RlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnNldERuc01vZGUgPSBmdW5jdGlvbiAobmV3RG5zTW9kZSkge1xuICBpZiAodGhpcy5kbnNNb2RlID09PSBuZXdEbnNNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuZG5zTW9kZSA9PT0gRG5zTW9kZS5OT05FKSB7XG4gICAgdGhpcy5kbnNOb2RlSUQgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodGhpcy5kbnNNb2RlID09PSBEbnNNb2RlLkFVVE9NQVRJQykge1xuICAgIHRoaXMuZG5zTm9kZUlEID0gQVVUT19ETlNfUkVTRVJWRURfQUREUkVTUztcbiAgfVxuXG4gIHRoaXMuZG5zTW9kZSA9IG5ld0Ruc01vZGU7XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdCYW5kd2lkdGggaW4gYml0cyBwZXIgc2Vjb25kXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnNldEJhbmR3aWR0aCA9IGZ1bmN0aW9uIChuZXdCYW5kd2lkdGgpIHtcbiAgaWYgKHRoaXMuYmFuZHdpZHRoID09PSBuZXdCYW5kd2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmJhbmR3aWR0aCA9IG5ld0JhbmR3aWR0aDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVNjaGVkdWxlKCk7XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNZW1vcnkgaW4gYml0c1xuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5zZXRNZW1vcnkgPSBmdW5jdGlvbiAobmV3TWVtb3J5KSB7XG4gIGlmICh0aGlzLm1lbW9yeSA9PT0gbmV3TWVtb3J5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5tZW1vcnkgPSBuZXdNZW1vcnk7XG4gIHRoaXMuZW5mb3JjZU1lbW9yeUxpbWl0XygpO1xuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7TmV0U2ltV2lyZVtdfSBhbGwgb2YgdGhlIHdpcmVzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgcm91dGVyLlxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXRDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNoYXJkID0gdGhpcy5zaGFyZF87XG4gIHZhciByb3V0ZXJJRCA9IHRoaXMuZW50aXR5SUQ7XG4gIHJldHVybiBzaGFyZC53aXJlVGFibGUucmVhZEFsbCgpLmZpbHRlcihmdW5jdGlvbiAod2lyZVJvdykge1xuICAgIHJldHVybiB3aXJlUm93LnJlbW90ZU5vZGVJRCA9PT0gcm91dGVySUQ7XG4gIH0pLm1hcChmdW5jdGlvbiAod2lyZVJvdykge1xuICAgIHJldHVybiBuZXcgTmV0U2ltV2lyZShzaGFyZCwgd2lyZVJvdyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0b3RhbCBudW1iZXIgb2Ygd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgcm91dGVyLlxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5jb3VudENvbm5lY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRDb25uZWN0aW9ucygpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgcm91dGVyIGxvZyBlbnRyeSAobm90IGRldmVsb3BtZW50IGxvZ2dpbmcsIHRoaXMgaXMgdXNlci1mYWNpbmchKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhY2tldCAtIGJpbmFyeSBsb2cgcGF5bG9hZFxuICogQHBhcmFtIHtOZXRTaW1Mb2dFbnRyeS5Mb2dTdGF0dXN9IHN0YXR1c1xuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAocGFja2V0LCBzdGF0dXMpIHtcbiAgTmV0U2ltTG9nRW50cnkuY3JlYXRlKFxuICAgICAgdGhpcy5zaGFyZF8sXG4gICAgICB0aGlzLmVudGl0eUlELFxuICAgICAgcGFja2V0LFxuICAgICAgc3RhdHVzLFxuICAgICAgZnVuY3Rpb24gKCkge30pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBoYXlzdGFja1xuICogQHBhcmFtIHsqfSBuZWVkbGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIG5lZWRsZSBmb3VuZCBpbiBoYXlzdGFja1xuICovXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZSkge1xuICByZXR1cm4gaGF5c3RhY2suc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ID09PSBuZWVkbGU7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbm90aGVyIG5vZGUgZXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoaXMgb25lLCBnaXZpbmcgdGhpc1xuICogbm9kZSBhIGNoYW5jZSB0byByZWplY3QgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogVGhlIHJvdXRlciBjaGVja3MgYWdhaW5zdCBpdHMgY29ubmVjdGlvbiBsaW1pdCwgYW5kIHJlamVjdHMgdGhlIGNvbm5lY3Rpb25cbiAqIGlmIGl0cyBsaW1pdCBpcyBub3cgZXhjZWVkZWQuXG4gKlxuICogQHBhcmFtIHshTmV0U2ltTm9kZX0gb3RoZXJOb2RlIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGlzIG9uZVxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgcmVzcG9uc2UgbWV0aG9kIC0gc2hvdWxkIGNhbGwgd2l0aCBUUlVFXG4gKiAgICAgICAgaWYgY29ubmVjdGlvbiBpcyBhbGxvd2VkLCBGQUxTRSBpZiBjb25uZWN0aW9uIGlzIHJlamVjdGVkLlxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5hY2NlcHRDb25uZWN0aW9uID0gZnVuY3Rpb24gKG90aGVyTm9kZSwgb25Db21wbGV0ZSkge1xuICB2YXIgcmVqZWN0aW9uUmVhc29uID0gbnVsbDtcblxuICAvLyBGb3JjZSBhIHJlZnJlc2ggdG8gdmVyaWZ5IHRoYXQgd2UgaGF2ZSBub3QgZXhjZWVkZWQgdGhlIGNvbm5lY3Rpb24gbGltaXQuXG4gIHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWZyZXNoKClcbiAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5nZXRDb25uZWN0aW9ucygpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBjb25uZWN0aW9uIGxpbWl0IGV4Y2VlZGVkXG4gICAgICAgIGlmIChjb25uZWN0aW9ucy5sZW5ndGggPiB0aGlzLm1heENsaWVudENvbm5lY3Rpb25zXykge1xuICAgICAgICAgIHJlamVjdGlvblJlYXNvbiA9IG5ldyBFcnJvcihcIlRvbyBtYW55IGNvbm5lY3Rpb25zLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgYWRkcmVzcyBjb2xsaXNpb25zXG4gICAgICAgIHZhciBhZGRyZXNzZXNTb0ZhciA9IHt9O1xuICAgICAgICBhZGRyZXNzZXNTb0Zhclt0aGlzLmdldEFkZHJlc3MoKV0gPSB0cnVlO1xuICAgICAgICBhZGRyZXNzZXNTb0Zhclt0aGlzLmdldEF1dG9EbnNBZGRyZXNzKCldID0gdHJ1ZTtcbiAgICAgICAgdmFyIGFkZHJlc3NDb2xsaXNpb24gPSBjb25uZWN0aW9ucy5zb21lKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgICAgICAgdmFyIGNvbGxpZGVzID0gYWRkcmVzc2VzU29GYXIuaGFzT3duUHJvcGVydHkod2lyZS5sb2NhbEFkZHJlc3MpO1xuICAgICAgICAgIGFkZHJlc3Nlc1NvRmFyW3dpcmUubG9jYWxBZGRyZXNzXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNvbGxpZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3NDb2xsaXNpb24pIHtcbiAgICAgICAgICByZWplY3Rpb25SZWFzb24gPSBuZXcgRXJyb3IoXCJBZGRyZXNzIGNvbGxpc2lvbiBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgLmZhaWwoZnVuY3Rpb24gKGVycikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIlJlamVjdGVkIGNvbm5lY3Rpb24gZnJvbSBcIiArIG90aGVyTm9kZS5nZXREaXNwbGF5TmFtZSgpICtcbiAgICAgICAgICAgIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uID0gZXJyO1xuICAgICAgfSlcbiAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkNvbXBsZXRlKHJlamVjdGlvblJlYXNvbiwgbnVsbCA9PT0gcmVqZWN0aW9uUmVhc29uKTtcbiAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgYXZhaWxhYmxlIGFkZHJlc3NlcywgdGhlbiBwaWNrIG9uZSBhdCByYW5kb20gYW5kIHJldHVybiBpdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IGEgbmV3IGF2YWlsYWJsZSBhZGRyZXNzLlxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXRSYW5kb21BdmFpbGFibGVDbGllbnRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWRkcmVzc0xpc3QgPSB0aGlzLmdldENvbm5lY3Rpb25zKCkuZmlsdGVyKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgcmV0dXJuIHdpcmUubG9jYWxBZGRyZXNzICE9PSB1bmRlZmluZWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAod2lyZSkge1xuICAgIHJldHVybiB3aXJlLmxvY2FsQWRkcmVzcztcbiAgfSk7XG5cbiAgLy8gR2VuZXJhdGUgYSBsaXN0IG9mIHVudXNlZCBhZGRyZXNzZXMgaW4gdGhlIGFkZHJlc3NhYmxlIHNwYWNlICh0byBhIGxpbWl0KVxuICB2YXIgYWRkcmVzc0Zvcm1hdCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKS5hZGRyZXNzRm9ybWF0O1xuICB2YXIgYWRkcmVzc1BhcnRTaXplcyA9IGFkZHJlc3NGb3JtYXQuc3BsaXQoL1xcRCsvKS5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC5sZW5ndGggPiAwO1xuICB9KS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocGFydCwgMTApO1xuICB9KS5yZXZlcnNlKCk7XG4gIHZhciBtYXhMb2NhbEFkZHJlc3NlcyA9IE1hdGgubWluKE1hdGgucG93KDIsIGFkZHJlc3NQYXJ0U2l6ZXNbMF0pLFxuICAgICAgQUREUkVTU19PUFRJT05fTElNSVQpO1xuXG4gIHZhciBwb3NzaWJsZUFkZHJlc3NlcyA9IFtdO1xuICB2YXIgbmV4dEFkZHJlc3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TG9jYWxBZGRyZXNzZXM7IGkrKykge1xuICAgIG5leHRBZGRyZXNzID0gdGhpcy5tYWtlTG9jYWxOZXR3b3JrQWRkcmVzc18oaSk7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGFkZHJlc3MgaW4gcXVlc3Rpb24gaXMgbm90IHRha2VuIGFscmVhZHkuXG4gICAgaWYgKCEobmV4dEFkZHJlc3MgPT09IHRoaXMuZ2V0QWRkcmVzcygpIHx8XG4gICAgICAgIG5leHRBZGRyZXNzID09PSB0aGlzLmdldEF1dG9EbnNBZGRyZXNzKCkgfHxcbiAgICAgICAgY29udGFpbnMoYWRkcmVzc0xpc3QsIG5leHRBZGRyZXNzKSkpIHtcbiAgICAgIHBvc3NpYmxlQWRkcmVzc2VzLnB1c2gobmV4dEFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByYW5kb21JbmRleCA9IE5ldFNpbUdsb2JhbHMucmFuZG9tSW50SW5SYW5nZSgwLCBwb3NzaWJsZUFkZHJlc3Nlcy5sZW5ndGgpO1xuICByZXR1cm4gcG9zc2libGVBZGRyZXNzZXNbcmFuZG9tSW5kZXhdO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhZGRyZXNzIG1hdGNoaW5nIHRoZSBsZXZlbCdzIGNvbmZpZ3VyZWQgYWRkcmVzcyBmb3JtYXQsIHRoYXRcbiAqIGZhbGxzIHdpdGhpbiB0aGlzIHJvdXRlcidzIGxvY2FsIG5ldHdvcmsgYW5kIGVuZHMgaW4gdGhlIGdpdmVuIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGxhc3RQYXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUubWFrZUxvY2FsTmV0d29ya0FkZHJlc3NfID0gZnVuY3Rpb24gKGxhc3RQYXJ0KSB7XG4gIHZhciBhZGRyZXNzRm9ybWF0ID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpLmFkZHJlc3NGb3JtYXQ7XG4gIHZhciB1c2VkTGFzdFBhcnQgPSBmYWxzZTtcbiAgdmFyIHVzZWRSb3V0ZXJJRCA9IGZhbHNlO1xuXG4gIHJldHVybiBhZGRyZXNzRm9ybWF0LnNwbGl0KC8oXFxEKykvKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIGJpdFdpZHRoID0gcGFyc2VJbnQocGFydCwgMTApO1xuICAgIGlmIChpc05hTihiaXRXaWR0aCkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBub24tbnVtYmVyIHBhcnQsIHBhc3MgaXQgdGhyb3VnaCB0byB0aGUgcmVzdWx0XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG5cbiAgICBpZiAoIXVzZWRMYXN0UGFydCkge1xuICAgICAgdXNlZExhc3RQYXJ0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsYXN0UGFydC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlZFJvdXRlcklEKSB7XG4gICAgICB1c2VkUm91dGVySUQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyTnVtYmVyKCkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJzAnO1xuICB9LmJpbmQodGhpcykpLnJldmVyc2UoKS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0FycmF5fSBBIGxpc3Qgb2YgcmVtb3RlIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIHJvdXRlciwgaW5jbHVkaW5nXG4gKiAgICAgICAgICB0aGVpciBob3N0bmFtZSwgYWRkcmVzcywgd2hldGhlciB0aGV5IGFyZSB0aGUgbG9jYWwgbm9kZSwgYW5kXG4gKiAgICAgICAgICB3aGV0aGVyIHRoZXkgYXJlIHRoZSBjdXJyZW50IEROUyBub2RlIGZvciB0aGUgbmV0d29yay5cbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzc1RhYmxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWRkcmVzc1RhYmxlID0gdGhpcy5teVdpcmVSb3dDYWNoZV8ubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG9zdG5hbWU6IHJvdy5sb2NhbEhvc3RuYW1lLFxuICAgICAgYWRkcmVzczogcm93LmxvY2FsQWRkcmVzcyxcbiAgICAgIGlzTG9jYWw6IChyb3cubG9jYWxOb2RlSUQgPT09IHRoaXMuc2ltdWxhdGVGb3JTZW5kZXJfKSxcbiAgICAgIGlzRG5zTm9kZTogKHJvdy5sb2NhbE5vZGVJRCA9PT0gdGhpcy5kbnNOb2RlSUQpXG4gICAgfTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICAvLyBTcGVjaWFsIGNhc2U6IEluIGF1dG8tZG5zIG1vZGUgd2UgYWRkIHRoZSBETlMgZW50cnkgdG8gdGhlIGFkZHJlc3MgdGFibGVcbiAgaWYgKHRoaXMuZG5zTW9kZSA9PT0gRG5zTW9kZS5BVVRPTUFUSUMpIHtcbiAgICBhZGRyZXNzVGFibGUucHVzaCh7XG4gICAgICBob3N0bmFtZTogQVVUT19ETlNfSE9TVE5BTUUsXG4gICAgICBhZGRyZXNzOiB0aGlzLmdldEF1dG9EbnNBZGRyZXNzKCksXG4gICAgICBpc0xvY2FsOiBmYWxzZSxcbiAgICAgIGlzRG5zTm9kZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFkZHJlc3NUYWJsZTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBub2RlIElELCBmaW5kcyB0aGUgbG9jYWwgbmV0d29yayBhZGRyZXNzIG9mIHRoYXQgbm9kZS4gIENhbm5vdFxuICogYmUgdXNlZCB0byBmaW5kIHRoZSBhZGRyZXNzIG9mIHRoZSByb3V0ZXIgb3IgYXV0by1kbnMgbm9kZSAoc2luY2UgdGhlaXJcbiAqIG5vZGUgSURzIGFyZSBub3QgdW5pcXVlKS4gIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgbm9kZSBJRCBpcyBub3RcbiAqIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSURcbiAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzc0Zvck5vZGVJRF8gPSBmdW5jdGlvbiAobm9kZUlEKSB7XG4gIHZhciB3aXJlUm93ID0gXy5maW5kKHRoaXMubXlXaXJlUm93Q2FjaGVfLCBmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvdy5sb2NhbE5vZGVJRCA9PT0gbm9kZUlEO1xuICB9KTtcblxuICBpZiAod2lyZVJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdpcmVSb3cubG9jYWxBZGRyZXNzO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgaG9zdG5hbWUsIGZpbmRzIHRoZSBsb2NhbCBuZXR3b3JrIGFkZHJlc3Mgb2YgdGhlIG5vZGUgd2l0aCB0aGF0XG4gKiBob3N0bmFtZS4gIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiBubyBub2RlIHdpdGggdGhhdCBob3N0bmFtZSBpcyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzc0Zvckhvc3RuYW1lXyA9IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICBpZiAoaG9zdG5hbWUgPT09IHRoaXMuZ2V0SG9zdG5hbWUoKSkge1xuICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3MoKTtcbiAgfVxuXG4gIGlmICh0aGlzLmRuc01vZGUgPT09IERuc01vZGUuQVVUT01BVElDICYmIGhvc3RuYW1lID09PSBBVVRPX0ROU19IT1NUTkFNRSkge1xuICAgIHJldHVybiB0aGlzLmdldEF1dG9EbnNBZGRyZXNzKCk7XG4gIH1cblxuICB2YXIgd2lyZVJvdyA9IF8uZmluZCh0aGlzLm15V2lyZVJvd0NhY2hlXywgZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3cubG9jYWxIb3N0bmFtZSA9PT0gaG9zdG5hbWU7XG4gIH0pO1xuXG4gIGlmICh3aXJlUm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gd2lyZVJvdy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNvbm5lY3RlZCByb3V0ZXJzLCB0aGlzIGlzIGFzIGZhciBhcyB0aGUgYXV0by1ETlMgY2FuIHNlZS5cbiAgaWYgKCFOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCkuY29ubmVjdGVkUm91dGVycykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJcyBpdCBzb21lIG5vZGUgZWxzZXdoZXJlIG9uIHRoZSBzaGFyZD9cbiAgdmFyIG5vZGVzID0gTmV0U2ltTm9kZUZhY3Rvcnkubm9kZXNGcm9tUm93cyh0aGlzLnNoYXJkXyxcbiAgICAgIHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCkpO1xuICB2YXIgbm9kZSA9IF8uZmluZChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5nZXRIb3N0bmFtZSgpID09PSBob3N0bmFtZTtcbiAgfSk7XG4gIGlmIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QWRkcmVzcygpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBsb2NhbCBuZXR3b3JrIGFkZHJlc3MsIGZpbmRzIHRoZSBub2RlIElEIG9mIHRoZSBub2RlIGF0IHRoYXRcbiAqIGFkZHJlc3MuICBXaWxsIHJldHVybiB1bmRlZmluZWQgaWYgbm8gbm9kZSBpcyBmb3VuZCBhdCB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXROb2RlSURGb3JBZGRyZXNzXyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIGlmIChhZGRyZXNzID09PSB0aGlzLmdldEFkZHJlc3MoKSkge1xuICAgIHJldHVybiB0aGlzLmVudGl0eUlEO1xuICB9XG5cbiAgaWYgKHRoaXMuZG5zTW9kZSA9PT0gRG5zTW9kZS5BVVRPTUFUSUMgJiZcbiAgICAgIGFkZHJlc3MgPT09IHRoaXMuZ2V0QXV0b0Ruc0FkZHJlc3MoKSkge1xuICAgIHJldHVybiB0aGlzLmVudGl0eUlEO1xuICB9XG5cbiAgdmFyIHdpcmVSb3cgPSBfLmZpbmQodGhpcy5teVdpcmVSb3dDYWNoZV8sIGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93LmxvY2FsQWRkcmVzcyA9PT0gYWRkcmVzcztcbiAgfSk7XG5cbiAgaWYgKHdpcmVSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3aXJlUm93LmxvY2FsTm9kZUlEO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgbmV0d29yayBhZGRyZXNzLCBmaW5kcyB0aGUgbm9kZSB0aGF0IGlzIHRoZSBuZXh0IHN0ZXAgYWxvbmcgdGhlXG4gKiBjb3JyZWN0IHBhdGggZnJvbSB0aGlzIHJvdXRlciB0byB0aGF0IGFkZHJlc3MuICBXaWxsIHJldHVybiBudWxsIGlmIG5vXG4gKiBwYXRoIHRvIHRoZSBhZGRyZXNzIGlzIGZvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBob3BzUmVtYWluaW5nXG4gKiBAcGFyYW0ge251bWJlcltdfSB2aXNpdGVkTm9kZUlEc1xuICogQHJldHVybnMge05ldFNpbU5vZGV8bnVsbH1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldE5leHROb2RlVG93YXJkQWRkcmVzc18gPSBmdW5jdGlvbiAoYWRkcmVzcyxcbiAgICBob3BzUmVtYWluaW5nLCB2aXNpdGVkTm9kZUlEcykge1xuICAvLyBJcyBpdCB1cz9cbiAgaWYgKGFkZHJlc3MgPT09IHRoaXMuZ2V0QWRkcmVzcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBJcyBpdCBvdXIgQXV0by1ETlMgbm9kZT9cbiAgaWYgKHRoaXMuZG5zTW9kZSA9PT0gRG5zTW9kZS5BVVRPTUFUSUMgJiYgYWRkcmVzcyA9PT0gdGhpcy5nZXRBdXRvRG5zQWRkcmVzcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBJcyBpdCBhIGxvY2FsIGNsaWVudD9cbiAgdmFyIG5vZGVzID0gTmV0U2ltTm9kZUZhY3Rvcnkubm9kZXNGcm9tUm93cyh0aGlzLnNoYXJkXyxcbiAgICAgIHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCkpO1xuICB2YXIgd2lyZVJvdyA9IF8uZmluZCh0aGlzLm15V2lyZVJvd0NhY2hlXywgZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3cubG9jYWxBZGRyZXNzID09PSBhZGRyZXNzO1xuICB9KTtcbiAgaWYgKHdpcmVSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBsb2NhbENsaWVudCA9IF8uZmluZChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmVudGl0eUlEID09PSB3aXJlUm93LmxvY2FsTm9kZUlEO1xuICAgIH0pO1xuICAgIGlmIChsb2NhbENsaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbG9jYWxDbGllbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5kIG9mIGxvY2FsIHN1Ym5ldCBjYXNlczpcbiAgLy8gSW4gbGV2ZWxzIHdoZXJlIHJvdXRlcnMgYXJlIG5vdCBjb25uZWN0ZWQsIHRoaXMgaXMgYXMgZmFyIGFzIHdlIGdvLlxuICB2YXIgbGV2ZWxDb25maWcgPSBOZXRTaW1HbG9iYWxzLmdldExldmVsQ29uZmlnKCk7XG4gIGlmICghbGV2ZWxDb25maWcuY29ubmVjdGVkUm91dGVycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSXMgaXQgYW5vdGhlciBub2RlP1xuICB2YXIgZGVzdGluYXRpb25Ob2RlID0gXy5maW5kKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBhZGRyZXNzID09PSBub2RlLmdldEFkZHJlc3MoKSB8fFxuICAgICAgICAobm9kZS5kbnNNb2RlID09PSBEbnNNb2RlLkFVVE9NQVRJQyAmJlxuICAgICAgICAgIG5vZGUuZ2V0Tm9kZVR5cGUoKSA9PT0gTm9kZVR5cGUuUk9VVEVSICYmXG4gICAgICAgICAgYWRkcmVzcyA9PT0gbm9kZS5nZXRBdXRvRG5zQWRkcmVzcygpKTtcbiAgfSk7XG5cbiAgLy8gSWYgdGhlIG5vZGUgd2UncmUgYWZ0ZXIgZG9lc24ndCBleGlzdCBhbnl3aGVyZSwgd2Ugc2hvdWxkIHN0b3Agbm93LlxuICBpZiAoIWRlc3RpbmF0aW9uTm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2UgYXJlIHRyeWluZyB0byBnZXQgc29tZXdoZXJlIGVsc2UhICBGaWd1cmUgb3V0IHdoYXQgdGhlIHRhcmdldCByb3V0ZXJcbiAgLy8gZm9yIG91ciBkZXN0aW5hdGlvbiBpcy5cbiAgdmFyIGRlc3RpbmF0aW9uUm91dGVyID0gbnVsbDtcbiAgaWYgKGRlc3RpbmF0aW9uTm9kZS5nZXROb2RlVHlwZSgpID09PSBOb2RlVHlwZS5ST1VURVIpIHtcbiAgICBkZXN0aW5hdGlvblJvdXRlciA9IGRlc3RpbmF0aW9uTm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVzdGluYXRpb25XaXJlID0gZGVzdGluYXRpb25Ob2RlLmdldE91dGdvaW5nV2lyZSgpO1xuICAgIGlmIChkZXN0aW5hdGlvbldpcmUpIHtcbiAgICAgIGRlc3RpbmF0aW9uUm91dGVyID0gdXRpbHMudmFsdWVPcihfLmZpbmQobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmVudGl0eUlEID09PSBkZXN0aW5hdGlvbldpcmUucmVtb3RlTm9kZUlEO1xuICAgICAgfSksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZGVzdGluYXRpb25Sb3V0ZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZXh0cmEgaG9wcywgd2Ugc2hvdWxkIHRyeSBhbmQgZ28gdG8gYSByb3V0ZXIgdGhhdCBpcyBOT1RcbiAgLy8gdGhlIHRhcmdldCByb3V0ZXIuXG4gIGlmIChob3BzUmVtYWluaW5nID4gMCkge1xuICAgIC8vIEdlbmVyYXRlIHRoZSBzZXQgb2YgcG9zc2libGUgdGFyZ2V0IHJvdXRlcnNcbiAgICB2YXIgcG9zc2libGVEZXN0aW5hdGlvblJvdXRlcnMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmdldE5vZGVUeXBlKCkgPT09IE5vZGVUeXBlLlJPVVRFUiAmJlxuICAgICAgICAgIG5vZGUuZW50aXR5SUQgIT09IGRlc3RpbmF0aW9uUm91dGVyLmVudGl0eUlEICYmXG4gICAgICAgICAgbm9kZS5lbnRpdHlJRCAhPT0gdGhpcy5lbnRpdHlJRCAmJlxuICAgICAgICAgICF2aXNpdGVkTm9kZUlEcy5zb21lKGZ1bmN0aW9uICh2aXNpdGVkSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmVudGl0eUlEID09PSB2aXNpdGVkSUQ7XG4gICAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHBvc3NpYmxlRGVzdGluYXRpb25Sb3V0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBOZXRTaW1HbG9iYWxzLnJhbmRvbVBpY2tPbmUocG9zc2libGVEZXN0aW5hdGlvblJvdXRlcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm93aGVyZSBlbHNlIHRvIGdvIG9yIHdlIGFyZSBvdXQgb2YgZXh0cmEgaG9wcywgZ28gdG8gdGhlXG4gIC8vIHRhcmdldCByb3V0ZXIuXG4gIHJldHVybiBkZXN0aW5hdGlvblJvdXRlcjtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgbm9kZSB0YWJsZSBjaGFuZ2VzLCB3ZSBjaGVjayB3aGV0aGVyIG91ciBvd24gcm93IGhhcyBjaGFuZ2VkXG4gKiBhbmQgcHJvcGFnYXRlIHRob3NlIGNoYW5nZXMgYXMgYXBwcm9wcmlhdGUuXG4gKiBAcHJpdmF0ZVxuICogQHRocm93c1xuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5vbk5vZGVUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBteVJvdyA9IF8uZmluZCh0aGlzLnNoYXJkXy5ub2RlVGFibGUucmVhZEFsbCgpLCBmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvdy5pZCA9PT0gdGhpcy5lbnRpdHlJRDtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAobXlSb3cgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBub3csIHRvIG5vbi1wcmltYXJ5IHJvdXRlcnMsIGJlY2F1c2UgZGV0ZWN0aW9uXG4gICAgLy8gb2YgdGhlIHJvdXRlcidzIHJlbW92YWwgKHN0b3BwaW5nIGl0cyBzaW11bGF0aW9uKSBpbiBOZXRTaW1Mb2NhbENsaWVudE5vZGVcbiAgICAvLyBhbmQgdGhpcyBtZXRob2QgaGFwcGVuIGluIGFuIHVuY2VydGFpbiBvcmRlci5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIV8uaXNFcXVhbCh0aGlzLnN0YXRlQ2FjaGVfLCBteVJvdykpIHtcbiAgICB0aGlzLnN0YXRlQ2FjaGVfID0gbXlSb3c7XG4gICAgdGhpcy5vbk15U3RhdGVDaGFuZ2VfKG15Um93KTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGVuIHRoZSB3aXJlcyB0YWJsZSBjaGFuZ2VzLCB3ZSBtYXkgaGF2ZSBhIG5ldyBjb25uZWN0aW9uIG9yIGhhdmUgbG9zdFxuICogYSBjb25uZWN0aW9uLiAgUHJvcGFnYXRlIHVwZGF0ZXMgYWJvdXQgb3VyIGNvbm5lY3Rpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5vbldpcmVUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBteVdpcmVSb3dzID0gdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnJlYWRBbGwoKS5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3cucmVtb3RlTm9kZUlEID09PSB0aGlzLmVudGl0eUlEO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIGlmICghXy5pc0VxdWFsKHRoaXMubXlXaXJlUm93Q2FjaGVfLCBteVdpcmVSb3dzKSkge1xuICAgIHRoaXMubXlXaXJlUm93Q2FjaGVfID0gbXlXaXJlUm93cztcbiAgICB0aGlzLndpcmVzQ2hhbmdlLm5vdGlmeU9ic2VydmVycygpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIGxvZ3MgdGFibGUgY2hhbmdlcywgd2UgbWF5IGhhdmUgYSBuZXcgY29ubmVjdGlvbiBvciBoYXZlIGxvc3RcbiAqIGEgY29ubmVjdGlvbi4gIFByb3BhZ2F0ZSB1cGRhdGVzIGFib3V0IG91ciBjb25uZWN0aW9uc1xuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUub25Mb2dUYWJsZUNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBteUxvZ1Jvd3MgPSB0aGlzLnNoYXJkXy5sb2dUYWJsZS5yZWFkQWxsKCkuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93Lm5vZGVJRCA9PT0gdGhpcy5lbnRpdHlJRDtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAoIV8uaXNFcXVhbCh0aGlzLm15TG9nUm93Q2FjaGVfLCBteUxvZ1Jvd3MpKSB7XG4gICAgdGhpcy5teUxvZ1Jvd0NhY2hlXyA9IG15TG9nUm93cztcbiAgICB0aGlzLmxvZ0NoYW5nZS5ub3RpZnlPYnNlcnZlcnMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgbGlzdCBvZiBsb2cgZW50cmllcyBpbiB0aGlzIHJvdXRlcidzIG1lbW9yeS5cbiAqIEByZXR1cm5zIHtOZXRTaW1Mb2dFbnRyeVtdfVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZXRMb2cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm15TG9nUm93Q2FjaGVfLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIG5ldyBOZXRTaW1Mb2dFbnRyeSh0aGlzLnNoYXJkXywgcm93LCB0aGlzLnBhY2tldFNwZWNfKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gdGhlIG51bWJlciBvZiBwYWNrZXRzIGluIHRoZSByb3V0ZXIgcXVldWVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0UXVldWVkUGFja2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvdXRlclF1ZXVlQ2FjaGVfLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gcm91dGVyIG1lbW9yeSBjdXJyZW50bHkgaW4gdXNlLCBpbiBiaXRzXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdldE1lbW9yeUluVXNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb3V0ZXJRdWV1ZUNhY2hlXy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnBheWxvYWQubGVuZ3RoO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gZXhwZWN0ZWQgcm91dGVyIGRhdGEgcmF0ZSAoaW4gYml0cyBwZXIgc2Vjb25kKSBvdmVyIHRoZVxuICogICAgICAgICAgbmV4dCBzZWNvbmRcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZ2V0Q3VycmVudERhdGFSYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UncmUgZGVmaW5pbmcgdGhlICdjdXJlbnQgZGF0YSByYXRlJyBhcyBob3cgbWFueSBiaXRzXG4gIC8vIHdlIGV4cGVjdCB0byBnZXQgcHJvY2Vzc2VkIGluIHRoZSBuZXh0IHNlY29uZDsgd2hpY2ggaXMgb3VyIHF1ZXVlIHNpemUsXG4gIC8vIGNhcHBlZCBhdCBvdXIgYmFuZHdpZHRoLlxuICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXRNZW1vcnlJblVzZSgpLCB0aGlzLmJhbmR3aWR0aCk7XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIG1lc3NhZ2UgdGFibGUgY2hhbmdlcywgd2UgbWlnaHQgaGF2ZSBhIG5ldyBtZXNzYWdlIHRvIGhhbmRsZS5cbiAqIENoZWNrIGZvciBhbmQgaGFuZGxlIHVuaGFuZGxlZCBtZXNzYWdlcy5cbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIGlmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBhIG5vbi1zaW11bGF0aW5nIHJvdXRlci5cbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUub25NZXNzYWdlVGFibGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuc2ltdWxhdGVGb3JTZW5kZXJfKSB7XG4gICAgLy8gV2hhdD8gIE9ubHkgc2ltdWxhdGluZyByb3V0ZXJzIHNob3VsZCBiZSBob29rZWQgdXAgdG8gbWVzc2FnZSBub3RpZmljYXRpb25zLlxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1zaW11bGF0aW5nIHJvdXRlciBnb3QgbWVzc2FnZSB0YWJsZSBjaGFuZ2Ugbm90aWZpY3Rpb25cIik7XG4gIH1cblxuICB2YXIgbWVzc2FnZXMgPSB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGUucmVhZEFsbCgpLm1hcChmdW5jdGlvbihyb3cpe1xuICAgIHJldHVybiBuZXcgTmV0U2ltTWVzc2FnZSh0aGlzLnNoYXJkXywgcm93KTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnVwZGF0ZVJvdXRlclF1ZXVlXyhtZXNzYWdlcyk7XG5cbiAgaWYgKHRoaXMuZG5zTW9kZSA9PT0gRG5zTW9kZS5BVVRPTUFUSUMpIHtcbiAgICB0aGlzLnVwZGF0ZUF1dG9EbnNRdWV1ZV8obWVzc2FnZXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyBvdXIgY2FjaGUgb2YgYWxsIG1lc3NhZ2VzIHRoYXQgYXJlIGdvaW5nIHRvIHRoZSByb3V0ZXIgKHJlZ2FyZGxlc3NcbiAqIG9mIHdoaWNoIHNpbXVsYXRpb24gd2lsbCBoYW5kbGUgdGhlbSksIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHN0YXRzIGFuZCByYXRlXG4gKiBsaW1pdGluZy5cbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZVtdfSBtZXNzYWdlc1xuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS51cGRhdGVSb3V0ZXJRdWV1ZV8gPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgdmFyIG5ld1F1ZXVlID0gbWVzc2FnZXNcbiAgICAuZmlsdGVyKE5ldFNpbU1lc3NhZ2UuaXNWYWxpZClcbiAgICAuZmlsdGVyKHRoaXMuaXNNZXNzYWdlVG9Sb3V0ZXJfLmJpbmQodGhpcykpO1xuICBpZiAoXy5pc0VxdWFsKHRoaXMucm91dGVyUXVldWVDYWNoZV8sIG5ld1F1ZXVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZ2dlci5pbmZvKHRoaXMuZ2V0RGlzcGxheU5hbWUoKSArICc6IE1lc3NhZ2UgcXVldWUgdXBkYXRlZCAoc2l6ZSAnICtcbiAgICAgIG5ld1F1ZXVlLmxlbmd0aCArICcpJyk7XG5cbiAgdGhpcy5yb3V0ZXJRdWV1ZUNhY2hlXyA9IG5ld1F1ZXVlO1xuICB0aGlzLnJlY2FsY3VsYXRlU2NoZWR1bGUoKTtcbiAgdGhpcy5lbmZvcmNlTWVtb3J5TGltaXRfKCk7XG4gIHRoaXMuc3RhdHNDaGFuZ2Uubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHJvdXRlciBxdWV1ZSBmb3IgcGFja2V0cyBiZXlvbmQgdGhlIHJvdXRlcidzIG1lbW9yeSBsaW1pdCxcbiAqIGFuZCBkcm9wcyB0aGUgZmlyc3Qgb25lIHdlIHNpbXVsYXRlIGxvY2FsbHkuICBTaW5jZSB0aGlzIHdpbGwgdHJpZ2dlclxuICogYSB0YWJsZSBjaGFuZ2UsIHRoaXMgd2lsbCBvY2N1ciBhc3luYy1yZWN1cnNpdmVseSB1bnRpbCBhbGwgcGFja2V0c1xuICogb3ZlciB0aGUgbWVtb3J5IGxpbWl0IGFyZSBkcm9wcGVkLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZW5mb3JjZU1lbW9yeUxpbWl0XyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSBwcm9jZWVkIGlmIGEgcGFja2V0IHdlIHNpbXVsYXRlIGV4aXN0cyBiZXlvbmQgdGhlIG1lbW9yeSBsaW1pdFxuICB2YXIgZHJvcHBhYmxlUGFja2V0ID0gdGhpcy5maW5kRmlyc3RMb2NhbGx5U2ltdWxhdGVkUGFja2V0T3Zlck1lbW9yeUxpbWl0KCk7XG4gIGlmICghZHJvcHBhYmxlUGFja2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5yZW1vdmVNZXNzYWdlRnJvbVNjaGVkdWxlXyhkcm9wcGFibGVQYWNrZXQpO1xuICBkcm9wcGFibGVQYWNrZXQuZGVzdHJveShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gUmFyZWx5LCB0aGlzIGNvdWxkIGZpcmUgdHdpY2UgZm9yIG9uZSBwYWNrZXQgYW5kIGhhdmUgb25lIGRyb3AgZmFpbC5cbiAgICAgIC8vIFRoYXQncyBmaW5lOyBqdXN0IGRvbid0IGxvZyBpZiB3ZSBkaWRuJ3Qgc3VjY2Vzc2Z1bGx5IGRyb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2coZHJvcHBhYmxlUGFja2V0LnBheWxvYWQsIE5ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1cy5EUk9QUEVEKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogV2FsayB0aGUgcm91dGVyIHF1ZXVlLCBhbmQgcmV0dXJuIHRoZSBmaXJzdCBwYWNrZXQgd2UgZmluZCBiZXlvbmQgdGhlIHJvdXRlcidzXG4gKiBtZW1vcnkgY2FwYWNpdHkgdGhhdCB0aGUgbG9jYWwgc2ltdWxhdGlvbiBjb250cm9scyBhbmQgaXMgYWJsZSB0byBkcm9wLlxuICogQHJldHVybnMge05ldFNpbU1lc3NhZ2V8bnVsbH0gbnVsbCBpZiBubyBzdWNoIG1lc3NhZ2UgaXMgZm91bmQuXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmZpbmRGaXJzdExvY2FsbHlTaW11bGF0ZWRQYWNrZXRPdmVyTWVtb3J5TGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQ7XG4gIHZhciB1c2VkTWVtb3J5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvdXRlclF1ZXVlQ2FjaGVfLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFja2V0ID0gdGhpcy5yb3V0ZXJRdWV1ZUNhY2hlX1tpXTtcbiAgICB1c2VkTWVtb3J5ICs9IHBhY2tldC5wYXlsb2FkLmxlbmd0aDtcbiAgICBpZiAodXNlZE1lbW9yeSA+IHRoaXMubWVtb3J5ICYmIHRoaXMubG9jYWxTaW11bGF0aW9uT3duc01lc3NhZ2VfKHBhY2tldCkpIHtcbiAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHRoaXMgbWVzc2FnZSBpcyBkZXN0aW5lZCBmb3IgdGhlIHJvdXRlciAobm90IHRoZVxuICogICAgICAgICAgYXV0by1ETlMgcGFydCB0aG91Z2ghKSBhbmQgRkFMU0UgaWYgZGVzdGluZWQgYW55d2hlcmUgZWxzZS5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmlzTWVzc2FnZVRvUm91dGVyXyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmRuc01vZGUgPT09IERuc01vZGUuQVVUT01BVElDICYmIHRoaXMuaXNNZXNzYWdlVG9BdXRvRG5zXyhtZXNzYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlLnRvTm9kZUlEID09PSB0aGlzLmVudGl0eUlEO1xufTtcblxuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUucm91dGVNZXNzYWdlc18gPSBmdW5jdGlvbiAobWVzc2FnZXMsIG9uQ29tcGxldGUpIHtcbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5yb3V0ZU1lc3NhZ2VfKG1lc3NhZ2VzWzBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBvbkNvbXBsZXRlKGVyciwgcmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJvdXRlTWVzc2FnZXNfKG1lc3NhZ2VzLnNsaWNlKDEpLCBvbkNvbXBsZXRlKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZX0gbWVzc2FnZVxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnJvdXRlTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSwgb25Db21wbGV0ZSkge1xuICBtZXNzYWdlLmRlc3Ryb3koZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcmFuZG9tIGNoYW5jZSB0byBkcm9wIHBhY2tldCwgcmlnaHQgYXMgd2UgYXJlIGFib3V0IHRvIGZvcndhcmQgaXRcbiAgICBpZiAodGhpcy5yYW5kb21Ecm9wQ2hhbmNlID4gMCAmJiBOZXRTaW1HbG9iYWxzLnJhbmRvbSgpIDw9IHRoaXMucmFuZG9tRHJvcENoYW5jZSkge1xuICAgICAgdGhpcy5sb2cobWVzc2FnZS5wYXlsb2FkLCBOZXRTaW1Mb2dFbnRyeS5Mb2dTdGF0dXMuRFJPUFBFRCk7XG4gICAgICBvbkNvbXBsZXRlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbENvbmZpZyA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcbiAgICBpZiAobGV2ZWxDb25maWcuYnJvYWRjYXN0TW9kZSkge1xuICAgICAgdGhpcy5mb3J3YXJkTWVzc2FnZVRvQWxsXyhtZXNzYWdlLCBvbkNvbXBsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3J3YXJkTWVzc2FnZVRvUmVjaXBpZW50XyhtZXNzYWdlLCBvbkNvbXBsZXRlKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEZvcndhcmQgdGhlIGdpdmVuIG1lc3NhZ2UgdG8gYWxsIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGlzIHJvdXRlci5cbiAqIFRoaXMgaXMgZWZmZWN0aXZlbHkgXCJodWJcIiBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5mb3J3YXJkTWVzc2FnZVRvQWxsXyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvbkNvbXBsZXRlKSB7XG4gIC8vIEFzc3VtcHRpb25zIGZvciBicm9hZGNhc3QgbW9kZTpcbiAgLy8gMS4gV2UgY2FuIHRvdGFsbHkgaWdub3JlIHBhY2tldCBoZWFkZXJzLCBiZWNhdXNlIGFkZHJlc3NlcyBkb24ndCBtYXR0ZXJcbiAgLy8gMi4gV2Ugd29uJ3Qgc2VuZCB0byB0aGUgQXV0by1ETlMsIHNpbmNlIEROUyBtYWtlIG5vIHNlbnNlIHdpdGggbm8gYWRkcmVzc2VzXG5cbiAgLy8gR3JhYiB0aGUgbGlzdCBvZiBhbGwgY29ubmVjdGVkIG5vZGVzXG4gIHZhciBjb25uZWN0ZWROb2RlSURzID0gdGhpcy5teVdpcmVSb3dDYWNoZV8ubWFwKGZ1bmN0aW9uICh3aXJlUm93KSB7XG4gICAgcmV0dXJuIHdpcmVSb3cubG9jYWxOb2RlSUQ7XG4gIH0pO1xuXG4gIHRoaXMuZm9yd2FyZE1lc3NhZ2VUb05vZGVJRHNfKG1lc3NhZ2UsIGNvbm5lY3RlZE5vZGVJRHMsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMubG9nKG1lc3NhZ2UucGF5bG9hZCwgTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLkRST1BQRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhtZXNzYWdlLnBheWxvYWQsIE5ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1cy5TVUNDRVNTKTtcbiAgICB9XG4gICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEZvcndhcmQgdGhlIGdpdmVuIG1lc3NhZ2UgdG8gdGhlIGxpc3Qgb2Ygbm9kZSBJRHMgcHJvdmlkZWQuXG4gKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGJ5IGNhbGxpbmcgaXRzZWxmIHJlY3Vyc2l2ZWx5IHdpdGggdGhlIHRhaWwgb2YgdGhlXG4gKiBub2RlIElEIGxpc3QgZWFjaCB0aW1lIGl0IGZpbmlzaGVzIHNlbmRpbmcgb25lIG9mIHRoZSBtZXNzYWdlcywgc29cbiAqIHRpbWluZyBvbiB0aGlzIFwiYnJvYWRjYXN0XCIgd29uJ3QgYmUgZXhhY3RseSBjb3JyZWN0IC0gdGhhdCdzIHByb2JhYmx5IG9rYXlcbiAqIHRob3VnaCwgZXNwZWNpYWxseSBhdCB0aGUgcG9pbnQgaW4gdGhlIGN1cnJpY3VsdW0gd2hlcmUgdGhpcyBpcyB1c2VkLlxuICogQHBhcmFtIHtOZXRTaW1NZXNzYWdlfSBtZXNzYWdlXG4gKiBAcGFyYW0ge251bWJlcltdfSBub2RlSURzXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuZm9yd2FyZE1lc3NhZ2VUb05vZGVJRHNfID0gZnVuY3Rpb24gKG1lc3NhZ2UsXG4gICAgbm9kZUlEcywgb25Db21wbGV0ZSkge1xuXG4gIHZhciBtZXNzYWdlcyA9IG5vZGVJRHMubWFwKGZ1bmN0aW9uKG5vZGVJRCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21Ob2RlSUQ6IHRoaXMuZW50aXR5SUQsXG4gICAgICAgIHRvTm9kZUlEOiBub2RlSUQsXG4gICAgICAgIHNpbXVsYXRlZEJ5OiBub2RlSUQsXG4gICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZFxuICAgICAgfTtcbiAgfSwgdGhpcyk7XG5cbiAgTmV0U2ltTWVzc2FnZS5zZW5kTWFueSh0aGlzLnNoYXJkXywgbWVzc2FnZXMsIG9uQ29tcGxldGUpO1xufTtcblxuLyoqXG4gKiBSZWFkIHRoZSBnaXZlbiBtZXNzYWdlIHRvIGZpbmQgaXRzIGRlc3RpbmF0aW9uIGFkZHJlc3MsIHRyeSBhbmQgbWFwIHRoYXRcbiAqIGFkZHJlc3MgdG8gb25lIG9mIG91ciBjb25uZWN0aW9ucywgYW5kIHNlbmQgdGhlIG1lc3NhZ2UgcGF5bG9hZCB0b1xuICogdGhlIG5ldyBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZX0gbWVzc2FnZVxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmZvcndhcmRNZXNzYWdlVG9SZWNpcGllbnRfID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9uQ29tcGxldGUpIHtcbiAgdmFyIHRvQWRkcmVzcztcbiAgdmFyIHJvdXRlck5vZGVJRCA9IHRoaXMuZW50aXR5SUQ7XG5cbiAgLy8gRmluZCBhIGNvbm5lY3Rpb24gdG8gcm91dGUgdGhpcyBtZXNzYWdlIHRvLlxuICB0cnkge1xuICAgIHZhciBwYWNrZXQgPSBuZXcgUGFja2V0KHRoaXMucGFja2V0U3BlY18sIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgdG9BZGRyZXNzID0gcGFja2V0LmdldEhlYWRlckFzQWRkcmVzc1N0cmluZyhQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIud2FybihcIlBhY2tldCBub3QgcmVhZGFibGUgYnkgcm91dGVyXCIpO1xuICAgIHRoaXMubG9nKG1lc3NhZ2UucGF5bG9hZCwgTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLkRST1BQRUQpO1xuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZ2V0TmV4dE5vZGVUb3dhcmRBZGRyZXNzXyh0b0FkZHJlc3MsXG4gICAgICBtZXNzYWdlLmV4dHJhSG9wc1JlbWFpbmluZywgbWVzc2FnZS52aXNpdGVkTm9kZUlEcyk7XG4gIGlmIChkZXN0aW5hdGlvbk5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBDYW4ndCBmaW5kIG9yIHJlYWNoIHRoZSBhZGRyZXNzIHdpdGhpbiB0aGUgc2ltdWxhdGlvblxuICAgIGxvZ2dlci53YXJuKFwiRGVzdGluYXRpb24gYWRkcmVzcyBub3QgcmVhY2hhYmxlXCIpO1xuICAgIHRoaXMubG9nKG1lc3NhZ2UucGF5bG9hZCwgTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLkRST1BQRUQpO1xuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uTm9kZSA9PT0gdGhpcyAmJiB0b0FkZHJlc3MgPT09IHRoaXMuZ2V0QWRkcmVzcygpKSB7XG4gICAgLy8gVGhpcyByb3V0ZXIgSVMgdGhlIHBhY2tldCdzIGRlc3RpbmF0aW9uLCBpdCdzIGRvbmUuXG4gICAgbG9nZ2VyLndhcm4oXCJQYWNrZXQgc3RvcHBlZCBhdCByb3V0ZXIuXCIpO1xuICAgIHRoaXMubG9nKG1lc3NhZ2UucGF5bG9hZCwgTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLlNVQ0NFU1MpO1xuICAgIG9uQ29tcGxldGUobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogSGFuZGxlIGJhZCBzdGF0ZSB3aGVyZSBtb3JlIHRoYW4gb25lIHdpcmUgbWF0Y2hlcyBkZXN0IGFkZHJlc3M/XG5cbiAgLy8gVGhlIHNlbmRlciBzaW11bGF0ZXMgYSBtZXNzYWdlIHVudGlsIGl0IHJlYWNoZXMgdGhlIGZpbmFsIGxlZyBvZiBpdHMgdHJpcCxcbiAgLy8gd2hlbiBpdCdzIGdvaW5nIHRvIGEgY2xpZW50IG5vZGUuICBBdCB0aGF0IHBvaW50LCB0aGUgcmVjaXBpZW50IHRha2VzIG92ZXIuXG4gIHZhciBzaW11bGF0aW5nTm9kZUlEID0gbWVzc2FnZS5zaW11bGF0ZWRCeTtcbiAgaWYgKGRlc3RpbmF0aW9uTm9kZS5nZXROb2RlVHlwZSgpID09PSBOb2RlVHlwZS5DTElFTlQpIHtcbiAgICBzaW11bGF0aW5nTm9kZUlEID0gZGVzdGluYXRpb25Ob2RlLmVudGl0eUlEO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG1lc3NhZ2Ugd2l0aCBhIG5ldyBwYXlsb2FkLlxuICBOZXRTaW1NZXNzYWdlLnNlbmQoXG4gICAgICB0aGlzLnNoYXJkXyxcbiAgICAgIHtcbiAgICAgICAgZnJvbU5vZGVJRDogcm91dGVyTm9kZUlELFxuICAgICAgICB0b05vZGVJRDogZGVzdGluYXRpb25Ob2RlLmVudGl0eUlELFxuICAgICAgICBzaW11bGF0ZWRCeTogc2ltdWxhdGluZ05vZGVJRCxcbiAgICAgICAgcGF5bG9hZDogbWVzc2FnZS5wYXlsb2FkLFxuICAgICAgICBleHRyYUhvcHNSZW1haW5pbmc6IE1hdGgubWF4KDAsIG1lc3NhZ2UuZXh0cmFIb3BzUmVtYWluaW5nIC0gMSksXG4gICAgICAgIHZpc2l0ZWROb2RlSURzOiBtZXNzYWdlLnZpc2l0ZWROb2RlSURzLmNvbmNhdCh0aGlzLmVudGl0eUlEKVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICB0aGlzLmxvZyhtZXNzYWdlLnBheWxvYWQsIE5ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1cy5TVUNDRVNTKTtcbiAgICAgICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gICAgICB9LmJpbmQodGhpcylcbiAgKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOZXRTaW1NZXNzYWdlfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBzaG91bGQgYmUgb3BlcmF0ZWQgb24gYnkgdGhlIGxvY2FsXG4gKiAgICAgICAgICBzaW11bGF0aW9uLCBGQUxTRSBpZiBhbm90aGVyIHVzZXIncyBzaW11bGF0aW9uIHNob3VsZCBoYW5kbGUgaXQuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5sb2NhbFNpbXVsYXRpb25Pd25zTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5zaW11bGF0ZUZvclNlbmRlcl8gJiZcbiAgICAgIG1lc3NhZ2Uuc2ltdWxhdGVkQnkgPT09IHRoaXMuc2ltdWxhdGVGb3JTZW5kZXJfO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbWUgcmVxdWlyZWQgdG8gcHJvY2VzcyB0aGlzIG1lc3NhZ2UsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmNhbGN1bGF0ZVByb2Nlc3NpbmdEdXJhdGlvbkZvck1lc3NhZ2VfID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuYmFuZHdpZHRoID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBtZXNzYWdlLnBheWxvYWQubGVuZ3RoICogMTAwMCAvIHRoaXMuYmFuZHdpZHRoO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcXVldWUgb2YgYWxsIGF1dG8tZG5zIG1lc3NhZ2VzLCB3aGljaCBjYW4gYmUgdXNlZCBmb3Igc3RhdHMgb3IgbGltaXRpbmcuXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2VbXX0gbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnVwZGF0ZUF1dG9EbnNRdWV1ZV8gPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgdmFyIG5ld1F1ZXVlID0gbWVzc2FnZXMuZmlsdGVyKHRoaXMuaXNNZXNzYWdlVG9BdXRvRG5zXy5iaW5kKHRoaXMpKTtcbiAgaWYgKF8uaXNFcXVhbCh0aGlzLmF1dG9EbnNRdWV1ZV8sIG5ld1F1ZXVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYXV0b0Ruc1F1ZXVlXyA9IG5ld1F1ZXVlO1xuICAvLyBQcm9wYWdhdGUgbm90aWZpY2F0aW9uIG9mIHF1ZXVlIGNoYW5nZT9cbiAgLy8gV29yayB3aWxsIHByb2NlZWQgb24gbmV4dCB0aWNrXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZX0gbWVzc2FnZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuTmV0U2ltUm91dGVyTm9kZS5wcm90b3R5cGUuaXNNZXNzYWdlVG9BdXRvRG5zXyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwYWNrZXQsIHRvQWRkcmVzcztcbiAgdHJ5IHtcbiAgICBwYWNrZXQgPSBuZXcgUGFja2V0KHRoaXMucGFja2V0U3BlY18sIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgdG9BZGRyZXNzID0gcGFja2V0LmdldEhlYWRlckFzQWRkcmVzc1N0cmluZyhQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIud2FybihcIlBhY2tldCBub3QgcmVhZGFibGUgYnkgYXV0by1ETlM6IFwiICsgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1lc3NhZ2VzIHRvIHRoZSBhdXRvLWRucyBhcmUgYm90aCB0byBhbmQgZnJvbSB0aGUgcm91dGVyIG5vZGUsIGFuZFxuICAvLyBhZGRyZXNzZWQgdG8gdGhlIEROUy5cbiAgcmV0dXJuIG1lc3NhZ2UudG9Ob2RlSUQgPT09IHRoaXMuZW50aXR5SUQgJiZcbiAgICAgIG1lc3NhZ2UuZnJvbU5vZGVJRCA9PT0gdGhpcy5lbnRpdHlJRCAmJlxuICAgICAgdG9BZGRyZXNzID09PSB0aGlzLmdldEF1dG9EbnNBZGRyZXNzKCk7XG59O1xuXG4vKipcbiAqIEJhdGNoLXByb2Nlc3MgRE5TIHJlcXVlc3RzLCBnZW5lcmF0aW5nIHJlc3BvbnNlcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZVtdfSBtZXNzYWdlc1xuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLnByb2Nlc3NBdXRvRG5zUmVxdWVzdHNfID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBvbkNvbXBsZXRlKSB7XG4gIC8vIDEuIFJlbW92ZSB0aGUgcmVxdWVzdHMgZnJvbSB0aGUgd2lyZVxuICBOZXRTaW1FbnRpdHkuZGVzdHJveUVudGl0aWVzKG1lc3NhZ2VzLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBvbkNvbXBsZXRlKGVyciwgcmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAyLiBHZW5lcmF0ZSBhbGwgcmVzcG9uc2VzLCBhc3luY2hyb25vdXNseS5cbiAgICB0aGlzLmdlbmVyYXRlRG5zUmVzcG9uc2VzXyhtZXNzYWdlcywgb25Db21wbGV0ZSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltTWVzc2FnZVtdfSBtZXNzYWdlc1xuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGVcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVJvdXRlck5vZGUucHJvdG90eXBlLmdlbmVyYXRlRG5zUmVzcG9uc2VzXyA9IGZ1bmN0aW9uIChtZXNzYWdlcywgb25Db21wbGV0ZSkge1xuICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgb25Db21wbGV0ZShudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQcm9jZXNzIGhlYWRcbiAgdGhpcy5nZW5lcmF0ZURuc1Jlc3BvbnNlXyhtZXNzYWdlc1swXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb25Db21wbGV0ZShlcnIsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0YWlsXG4gICAgdGhpcy5nZW5lcmF0ZURuc1Jlc3BvbnNlc18obWVzc2FnZXMuc2xpY2UoMSksIG9uQ29tcGxldGUpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1Sb3V0ZXJOb2RlLnByb3RvdHlwZS5nZW5lcmF0ZURuc1Jlc3BvbnNlXyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvbkNvbXBsZXRlKSB7XG4gIHZhciBwYWNrZXQsIGZyb21BZGRyZXNzLCBxdWVyeSwgcmVzcG9uc2VIZWFkZXJzLCByZXNwb25zZUJvZHksIHJlc3BvbnNlQmluYXJ5O1xuICB2YXIgcm91dGVyTm9kZUlEID0gdGhpcy5lbnRpdHlJRDtcbiAgdmFyIGF1dG9EbnNOb2RlSUQgPSB0aGlzLmVudGl0eUlEO1xuXG4gIC8vIEV4dHJhY3QgbWVzc2FnZSBjb250ZW50c1xuICB0cnkge1xuICAgIHBhY2tldCA9IG5ldyBQYWNrZXQodGhpcy5wYWNrZXRTcGVjXywgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICBmcm9tQWRkcmVzcyA9IHBhY2tldC5nZXRIZWFkZXJBc0FkZHJlc3NTdHJpbmcoUGFja2V0LkhlYWRlclR5cGUuRlJPTV9BRERSRVNTKTtcbiAgICBxdWVyeSA9IHBhY2tldC5nZXRCb2R5QXNBc2NpaShCSVRTX1BFUl9CWVRFKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBNYWxmb3JtZWQgcGFja2V0LCBpZ25vcmVcbiAgICBvbkNvbXBsZXRlKGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IHRoZSBxdWVyeSBpcyB3ZWxsLWZvcm1lZFxuICAvLyBSZWdleCBtYXRjaCBcIkdFVCBbaG9zdG5hbWVzLi4uXVwiXG4gIC8vIFRoZW4gYmVsb3csIHdlJ2xsIHNwbGl0IHRoZSBob3N0bmFtZXMgb24gd2hpdGVzcGFjZSB0byBwcm9jZXNzIHRoZW0uXG4gIHZhciByZXF1ZXN0TWF0Y2ggPSBxdWVyeS5tYXRjaCgvR0VUXFxzKyhcXFMuKikvKTtcbiAgaWYgKHJlcXVlc3RNYXRjaCAhPT0gbnVsbCkge1xuICAgIC8vIEdvb2QgcmVxdWVzdCwgbG9vayB1cCBhbGwgYWRkcmVzc2VzIGFuZCBidWlsZCB1cCByZXNwb25zZVxuICAgIC8vIFNraXBwaW5nIGZpcnN0IG1hdGNoLCB3aGljaCBpcyB0aGUgZnVsbCByZWdleFxuICAgIHZhciByZXNwb25zZXMgPSByZXF1ZXN0TWF0Y2hbMV0uc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKHF1ZXJ5SG9zdG5hbWUpIHtcbiAgICAgIHZhciBhZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRm9ySG9zdG5hbWVfKHF1ZXJ5SG9zdG5hbWUpO1xuICAgICAgcmV0dXJuIHF1ZXJ5SG9zdG5hbWUgKyAnOicgKyB1dGlscy52YWx1ZU9yKGFkZHJlc3MsIEFVVE9fRE5TX05PVF9GT1VORCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICByZXNwb25zZUJvZHkgPSByZXNwb25zZXMuam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIC8vIE1hbGZvcm1lZCByZXF1ZXN0LCBzZW5kIGJhY2sgaW5zdHJ1Y3Rpb25zXG4gICAgcmVzcG9uc2VCb2R5ID0gaTE4bi5hdXRvRG5zVXNhZ2VNZXNzYWdlKCk7XG4gIH1cblxuICByZXNwb25zZUhlYWRlcnMgPSB7XG4gICAgZnJvbUFkZHJlc3M6dGhpcy5nZXRBdXRvRG5zQWRkcmVzcygpLFxuICAgIHRvQWRkcmVzczogZnJvbUFkZHJlc3MsXG4gICAgcGFja2V0SW5kZXg6IDEsXG4gICAgcGFja2V0Q291bnQ6IDFcbiAgfTtcblxuICByZXNwb25zZUJpbmFyeSA9IHBhY2tldC5lbmNvZGVyLmNvbmNhdGVuYXRlQmluYXJ5KFxuICAgICAgcGFja2V0LmVuY29kZXIubWFrZUJpbmFyeUhlYWRlcnMocmVzcG9uc2VIZWFkZXJzKSxcbiAgICAgIGFzY2lpVG9CaW5hcnkocmVzcG9uc2VCb2R5LCBCSVRTX1BFUl9CWVRFKSk7XG5cbiAgTmV0U2ltTWVzc2FnZS5zZW5kKFxuICAgICAgdGhpcy5zaGFyZF8sXG4gICAgICB7XG4gICAgICAgIGZyb21Ob2RlSUQ6IGF1dG9EbnNOb2RlSUQsXG4gICAgICAgIHRvTm9kZUlEOiByb3V0ZXJOb2RlSUQsXG4gICAgICAgIHNpbXVsYXRlZEJ5OiBtZXNzYWdlLnNpbXVsYXRlZEJ5LFxuICAgICAgICBwYXlsb2FkOiByZXNwb25zZUJpbmFyeVxuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGUpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFNpbXVsYXRpb24gZW50aXR5IGZvciBhIG1lc3NhZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgRGF0YUNvbnZlcnRlcnMgPSByZXF1aXJlKCcuL0RhdGFDb252ZXJ0ZXJzJyk7XG52YXIgYmFzZTY0VG9CaW5hcnkgPSBEYXRhQ29udmVydGVycy5iYXNlNjRUb0JpbmFyeTtcbnZhciBiaW5hcnlUb0Jhc2U2NCA9IERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQmFzZTY0O1xudmFyIE5ldFNpbUxvZ2dlciA9IHJlcXVpcmUoJy4vTmV0U2ltTG9nZ2VyJyk7XG5cbnZhciBsb2dnZXIgPSBOZXRTaW1Mb2dnZXIuZ2V0U2luZ2xldG9uKCk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZURhdGFcbiAqIEBwcm9wZXJ0eSB7IW51bWJlcn0gZnJvbU5vZGVJRCAtIHNlbmRlciBub2RlIElEXG4gKiBAcHJvcGVydHkgeyFudW1iZXJ9IHRvTm9kZUlEIC0gZGVzdGluYXRpb24gbm9kZSBJRFxuICogQHByb3BlcnR5IHshbnVtYmVyfSBzaW11bGF0ZWRCeSAtIG5vZGUgSUQgb2YgY2xpZW50IHNpbXVsYXRpbmcgbWVzc2FnZVxuICogQHByb3BlcnR5IHshc3RyaW5nfSBwYXlsb2FkIC0gbWVzc2FnZSBjb250ZW50IGluIGEgYmluYXJ5IHN0cmluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGV4dHJhSG9wc1JlbWFpbmluZ1xuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdmlzaXRlZE5vZGVJRHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1lc3NhZ2VSb3dcbiAqIEBwcm9wZXJ0eSB7IW51bWJlcn0gZnJvbU5vZGVJRCAtIHRoaXMgbWVzc2FnZSBpbi1mbGlnaHQtZnJvbSBub2RlXG4gKiBAcHJvcGVydHkgeyFudW1iZXJ9IHRvTm9kZUlEIC0gdGhpcyBtZXNzYWdlIGluLWZsaWdodC10byBub2RlXG4gKiBAcHJvcGVydHkgeyFudW1iZXJ9IHNpbXVsYXRlZEJ5IC0gTm9kZSBJRCBvZiB0aGUgY2xpZW50IHJlc3BvbnNpYmxlIGZvclxuICogICAgICAgICAgIGFsbCBvcGVyYXRpb25zIGludm9sdmluZyB0aGlzIG1lc3NhZ2UuXG4gKiBAcHJvcGVydHkgeyFCYXNlNjRQYXlsb2FkfSBiYXNlNjRQYXlsb2FkIC0gYmFzZTY0LWVuY29kZWQgYmluYXJ5XG4gKiAgICAgICAgICAgbWVzc2FnZSBjb250ZW50LCBhbGwgb2Ygd2hpY2ggY2FuIGJlIGV4cG9zZWQgdG8gdGhlXG4gKiAgICAgICAgICAgc3R1ZGVudC4gIE1heSBjb250YWluIGhlYWRlcnMgb2YgaXRzIG93bi5cbiAqIEBwcm9wZXJ0eSB7IW51bWJlcn0gZXh0cmFIb3BzUmVtYWluaW5nXG4gKiBAcHJvcGVydHkgeyFudW1iZXJbXX0gdmlzaXRlZE5vZGVJRHNcbiAqL1xuXG4vKipcbiAqIExvY2FsIGNvbnRyb2xsZXIgZm9yIGEgbWVzc2FnZSB0aGF0IGlzICdvbiB0aGUgd2lyZSdcbiAqXG4gKiBEb2Vzbid0IGFjdHVhbGx5IGhhdmUgYW55IGFzc29jaWF0aW9uIHdpdGggdGhlIHdpcmUgLSBvbmUgY291bGQsXG4gKiB0aGVvcmV0aWNhbGx5LCBzZW5kIGEgbWVzc2FnZSBmcm9tIGFueSBub2RlIGluIHRoZSBzaW11bGF0aW9uIHRvIGFueSBvdGhlclxuICogbm9kZSBpbiB0aGUgc2ltdWxhdGlvbi5cbiAqXG4gKiBBbnkgbWVzc2FnZSB0aGF0IGV4aXN0cyBpbiB0aGUgdGFibGUgaXMgJ2luIHRyYW5zaXQnIHRvIGEgbm9kZS4gIE5vZGVzXG4gKiBzaG91bGQgcmVtb3ZlIG1lc3NhZ2VzIGFzIHNvb24gYXMgdGhleSByZWNlaXZlIHRoZW0uXG4gKlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkIC0gVGhlIHNoYXJkIHdoZXJlIHRoaXMgd2lyZSBsaXZlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZVJvd30gW21lc3NhZ2VSb3ddIC0gQSByb3cgb3V0IG9mIHRoZSBfbWVzc2FnZSB0YWJsZSBvbiB0aGVcbiAqICAgICAgICBzaGFyZC4gIElmIHByb3ZpZGVkLCB3aWxsIGluaXRpYWxpemUgdGhpcyBtZXNzYWdlIHdpdGggdGhlIGdpdmVuXG4gKiAgICAgICAgZGF0YS4gIElmIG5vdCwgdGhpcyBtZXNzYWdlIHdpbGwgaW5pdGlhbGl6ZSB0byBkZWZhdWx0IHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbUVudGl0eVxuICogQGltcGxlbWVudHMgTWVzc2FnZURhdGFcbiAqL1xudmFyIE5ldFNpbU1lc3NhZ2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaGFyZCwgbWVzc2FnZVJvdykge1xuICBtZXNzYWdlUm93ID0gbWVzc2FnZVJvdyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZVJvdyA6IHt9O1xuICBOZXRTaW1FbnRpdHkuY2FsbCh0aGlzLCBzaGFyZCwgbWVzc2FnZVJvdyk7XG5cbiAgLyoqXG4gICAqIE5vZGUgSUQgdGhhdCB0aGlzIG1lc3NhZ2UgaXMgJ2luIHRyYW5zaXQnIGZyb20uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmZyb21Ob2RlSUQgPSBtZXNzYWdlUm93LmZyb21Ob2RlSUQ7XG5cbiAgLyoqXG4gICAqIE5vZGUgSUQgdGhhdCB0aGlzIG1lc3NhZ2UgaXMgJ2luIHRyYW5zaXQnIHRvLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy50b05vZGVJRCA9IG1lc3NhZ2VSb3cudG9Ob2RlSUQ7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBub2RlIHJlc3BvbnNpYmxlIGZvciBvcGVyYXRpb25zIG9uIHRoaXMgbWVzc2FnZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuc2ltdWxhdGVkQnkgPSBtZXNzYWdlUm93LnNpbXVsYXRlZEJ5O1xuXG4gIC8qKlxuICAgKiBBbGwgb3RoZXIgbWVzc2FnZSBjb250ZW50LCBpbmNsdWRpbmcgdGhlICdwYWNrZXRzJyBzdHVkZW50cyB3aWxsIHNlbmQuXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgdGhpcy5wYXlsb2FkID0gJyc7XG4gIGlmIChtZXNzYWdlUm93LmJhc2U2NFBheWxvYWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXlsb2FkID0gYmFzZTY0VG9CaW5hcnkobWVzc2FnZVJvdy5iYXNlNjRQYXlsb2FkLnN0cmluZyxcbiAgICAgICAgICBtZXNzYWdlUm93LmJhc2U2NFBheWxvYWQubGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyBpcyBhbiBpbnRlci1yb3V0ZXIgbWVzc2FnZSwgdGhlIG51bWJlciBvZiByb3V0ZXJzIHRoaXNcbiAgICogbWVzc2FnZSBzaG91bGQgdHJ5IHRvIHZpc2l0IGJlZm9yZSBnb2luZyB0byB0aGUgcm91dGVyIHRoYXRcbiAgICogd2lsbCBhY3R1YWxseSBsZWFkIHRvIGl0cyBkZXN0aW5hdGlvbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZXh0cmFIb3BzUmVtYWluaW5nID0gdXRpbHMudmFsdWVPcihtZXNzYWdlUm93LmV4dHJhSG9wc1JlbWFpbmluZywgMCk7XG5cbiAgLyoqXG4gICAqIEEgaGlzdG9yeSBvZiByb3V0ZXIgbm9kZSBJRHMgdGhpcyBtZXNzYWdlIGhhcyB2aXNpdGVkLlxuICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAqL1xuICB0aGlzLnZpc2l0ZWROb2RlSURzID0gdXRpbHMudmFsdWVPcihtZXNzYWdlUm93LnZpc2l0ZWROb2RlSURzLCBbXSk7XG59O1xuTmV0U2ltTWVzc2FnZS5pbmhlcml0cyhOZXRTaW1FbnRpdHkpO1xuXG4vKipcbiAqIFN0YXRpYyByb3cgY29uc3RydWN0aW9uIG1ldGhvZC4gVXNlZCBieSBkeW5hbWljIGJ1aWxkUm93IG1ldGhvZCBhbmRcbiAqIGJ5IHN0YXRpYyBhc3luYyBBUEkgY3JlYXRpb24gbWV0aG9kcyB0byBjcmVhdGUgYSBwcm9wZXJseS1mb3JtYXR0ZWRcbiAqIHJvdyBmb3IgZGF0YWJhc2UgaW5zZXJ0aW9uXG4gKiBAcGFyYW0ge01lc3NhZ2VEYXRhfSBtZXNzYWdlRGF0YVxuICogQHJldHVybnMge01lc3NhZ2VSb3d9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHBheWxvYWQgaXMgaW52YWxpZFxuICovXG5OZXRTaW1NZXNzYWdlLmJ1aWxkUm93RnJvbURhdGEgPSBmdW5jdGlvbiAobWVzc2FnZURhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICBmcm9tTm9kZUlEOiBtZXNzYWdlRGF0YS5mcm9tTm9kZUlELFxuICAgIHRvTm9kZUlEOiBtZXNzYWdlRGF0YS50b05vZGVJRCxcbiAgICBzaW11bGF0ZWRCeTogbWVzc2FnZURhdGEuc2ltdWxhdGVkQnksXG4gICAgYmFzZTY0UGF5bG9hZDogYmluYXJ5VG9CYXNlNjQobWVzc2FnZURhdGEucGF5bG9hZCksXG4gICAgZXh0cmFIb3BzUmVtYWluaW5nOiB1dGlscy52YWx1ZU9yKG1lc3NhZ2VEYXRhLmV4dHJhSG9wc1JlbWFpbmluZywgMCksXG4gICAgdmlzaXRlZE5vZGVJRHM6IHV0aWxzLnZhbHVlT3IobWVzc2FnZURhdGEudmlzaXRlZE5vZGVJRHMsIFtdKVxuICB9O1xufTtcblxuLyoqXG4gKiBTdGF0aWMgYXN5bmMgY3JlYXRpb24gbWV0aG9kLiAgQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9uIHRoZSBnaXZlbiBzaGFyZCxcbiAqIGFuZCB0aGVuIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIGEgc3VjY2VzcyBib29sZWFuLlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0geyFNZXNzYWdlRGF0YX0gbWVzc2FnZURhdGFcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIChzdWNjZXNzKVxuICovXG5OZXRTaW1NZXNzYWdlLnNlbmQgPSBmdW5jdGlvbiAoc2hhcmQsIG1lc3NhZ2VEYXRhLCBvbkNvbXBsZXRlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJvdyA9IE5ldFNpbU1lc3NhZ2UuYnVpbGRSb3dGcm9tRGF0YShtZXNzYWdlRGF0YSk7XG4gICAgc2hhcmQubWVzc2FnZVRhYmxlLmNyZWF0ZShyb3csIG9uQ29tcGxldGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBvbkNvbXBsZXRlKGVyciwgbnVsbCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhdGljIGFzeW5jIG11bHRpLWNyZWF0ZSBtZXRob2QuIENyZWF0ZXMgbmV3IG1lc3NhZ2VzIG9uIHRoZSBnaXZlbiBzaGFyZCxcbiAqIGFuZCB0aGVuIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIGEgc3VjY2VzcyBib29sZWFuLlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0ge01lc3NhZ2VEYXRhW119IG1lc3NhZ2VEYXRhc1xuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgKHN1Y2Nlc3MpXG4gKi9cbk5ldFNpbU1lc3NhZ2Uuc2VuZE1hbnkgPSBmdW5jdGlvbiAoc2hhcmQsIG1lc3NhZ2VEYXRhcywgb25Db21wbGV0ZSkge1xuICB0cnkge1xuICAgIHZhciByb3dzID0gbWVzc2FnZURhdGFzLm1hcChOZXRTaW1NZXNzYWdlLmJ1aWxkUm93RnJvbURhdGEpO1xuICAgIHNoYXJkLm1lc3NhZ2VUYWJsZS5tdWx0aUNyZWF0ZShyb3dzLCBvbkNvbXBsZXRlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25Db21wbGV0ZShlcnIsIG51bGwpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXRpYyBoZWxwZXIuXG4gKiBAcGFyYW0ge05ldFNpbU1lc3NhZ2V9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyB3ZWxsLWZvcm1lZC5cbiAqL1xuTmV0U2ltTWVzc2FnZS5pc1ZhbGlkID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIC9eWzAxXSokLy50ZXN0KG1lc3NhZ2UucGF5bG9hZCk7XG59O1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IGdldHMgdGhlIHdpcmVzIHRhYmxlIGZvciB0aGUgY29uZmlndXJlZCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtOZXRTaW1UYWJsZX1cbiAqL1xuTmV0U2ltTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNoYXJkXy5tZXNzYWdlVGFibGU7XG59O1xuXG4vKipcbiAqIEJ1aWxkIG93biByb3cgZm9yIHRoZSBtZXNzYWdlIHRhYmxlXG4gKiBAcmV0dXJucyB7TWVzc2FnZVJvd31cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgcGF5bG9hZCBpcyBpbnZhbGlkXG4gKi9cbk5ldFNpbU1lc3NhZ2UucHJvdG90eXBlLmJ1aWxkUm93ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTmV0U2ltTWVzc2FnZS5idWlsZFJvd0Zyb21EYXRhKHRoaXMpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFNpbXVsYXRpb24gZW50aXR5IGZvciByb3V0ZXIgbG9nIGVudHJpZXMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDUsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltRW50aXR5ID0gcmVxdWlyZSgnLi9OZXRTaW1FbnRpdHknKTtcbnZhciBQYWNrZXQgPSByZXF1aXJlKCcuL1BhY2tldCcpO1xudmFyIE5ldFNpbU5vZGVGYWN0b3J5ID0gcmVxdWlyZSgnLi9OZXRTaW1Ob2RlRmFjdG9yeScpO1xudmFyIERhdGFDb252ZXJ0ZXJzID0gcmVxdWlyZSgnLi9EYXRhQ29udmVydGVycycpO1xudmFyIGZvcm1hdEJpbmFyeSA9IERhdGFDb252ZXJ0ZXJzLmZvcm1hdEJpbmFyeTtcbnZhciBiYXNlNjRUb0JpbmFyeSA9IERhdGFDb252ZXJ0ZXJzLmJhc2U2NFRvQmluYXJ5O1xudmFyIGJpbmFyeVRvQmFzZTY0ID0gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9CYXNlNjQ7XG52YXIgTmV0U2ltTG9nZ2VyID0gcmVxdWlyZSgnLi9OZXRTaW1Mb2dnZXInKTtcblxudmFyIEJJVFNfUEVSX0JZVEUgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLkJJVFNfUEVSX0JZVEU7XG52YXIgbG9nZ2VyID0gTmV0U2ltTG9nZ2VyLmdldFNpbmdsZXRvbigpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExvZ0VudHJ5Um93XG4gKiBAcHJvcGVydHkge251bWJlcn0gbm9kZUlEXG4gKiBAcHJvcGVydHkge0Jhc2U2NFBheWxvYWR9IGJhc2U2NEJpbmFyeSAtIGJhc2U2NC1lbmNvZGVkIGJpbmFyeVxuICogICAgICAgICAgIG1lc3NhZ2UgY29udGVudCwgYWxsIG9mIHdoaWNoIGNhbiBiZSBleHBvc2VkIHRvIHRoZVxuICogICAgICAgICAgIHN0dWRlbnQuICBNYXkgY29udGFpbiBoZWFkZXJzIG9mIGl0cyBvd24uXG4gKiBAcHJvcGVydHkge05ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1c30gc3RhdHVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0YW1wXG4gKi9cblxuLyoqXG4gKiBFbnRyeSBpbiBzaGFyZWQgbG9nIGZvciBhIG5vZGUgb24gdGhlIG5ldHdvcmsuXG4gKlxuICogT25jZSBjcmVhdGVkLCBzaG91bGQgbm90IGJlIG1vZGlmaWVkIHVudGlsL3VubGVzcyBhIGNsZWFudXAgcHJvY2Vzc1xuICogcmVtb3ZlcyBpdC5cbiAqXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmQgLSBUaGUgc2hhcmQgd2hlcmUgdGhpcyBsb2cgZW50cnkgbGl2ZXMuXG4gKiBAcGFyYW0ge0xvZ0VudHJ5Um93fSBbcm93XSAtIEEgcm93IG91dCBvZiB0aGUgbG9nIHRhYmxlIG9uIHRoZVxuICogICAgICAgIHNoYXJkLiAgSWYgcHJvdmlkZWQsIHdpbGwgaW5pdGlhbGl6ZSB0aGlzIGxvZyB3aXRoIHRoZSBnaXZlblxuICogICAgICAgIGRhdGEuICBJZiBub3QsIHRoaXMgbG9nIHdpbGwgaW5pdGlhbGl6ZSB0byBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7UGFja2V0LkhlYWRlclR5cGVbXX0gW3BhY2tldFNwZWNdIC0gUGFja2V0IGxheW91dCBzcGVjIHVzZWQgdG9cbiAqICAgICAgICBpbnRlcnByZXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBsb2dnZWQgcGFja2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1FbnRpdHlcbiAqL1xudmFyIE5ldFNpbUxvZ0VudHJ5ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2hhcmQsIHJvdywgcGFja2V0U3BlYykge1xuICByb3cgPSByb3cgIT09IHVuZGVmaW5lZCA/IHJvdyA6IHt9O1xuICBOZXRTaW1FbnRpdHkuY2FsbCh0aGlzLCBzaGFyZCwgcm93KTtcblxuICAvKipcbiAgICogTm9kZSBJRCBvZiB0aGUgbm9kZSB0aGF0IG93bnMgdGhpcyBsb2cgZW50cnkgKGUuZy4gYSByb3V0ZXIgbm9kZSlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubm9kZUlEID0gcm93Lm5vZGVJRDtcblxuICAvKipcbiAgICogQmluYXJ5IGNvbnRlbnQgb2YgdGhlIGxvZyBlbnRyeS4gIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuYmluYXJ5ID0gJyc7XG4gIGlmIChyb3cuYmFzZTY0QmluYXJ5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmluYXJ5ID0gYmFzZTY0VG9CaW5hcnkocm93LmJhc2U2NEJpbmFyeS5zdHJpbmcsIHJvdy5iYXNlNjRCaW5hcnkubGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhdHVzIHZhbHVlIGZvciBsb2cgZW50cnk7IGZvciByb3V0ZXIgbG9nLCB1c3VhbGx5IFNVQ0NFU1MgZm9yIGNvbXBsZXRpb25cbiAgICogb2Ygcm91dGluZyBvciBEUk9QUEVEIGlmIHJvdXRpbmcgZmFpbGVkLlxuICAgKiBAdHlwZSB7TmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzfVxuICAgKi9cbiAgdGhpcy5zdGF0dXMgPSB1dGlscy52YWx1ZU9yKHJvdy5zdGF0dXMsIE5ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1cy5TVUNDRVNTKTtcblxuICAvKipcbiAgICogQHR5cGUge1BhY2tldH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucGFja2V0XyA9IG5ldyBQYWNrZXQodXRpbHMudmFsdWVPcihwYWNrZXRTcGVjLCBbXSksIHRoaXMuYmluYXJ5KTtcblxuICAvKipcbiAgICogVW5peCB0aW1lc3RhbXAgKGxvY2FsKSBvZiBsb2cgY3JlYXRpb24gdGltZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMudGltZXN0YW1wID0gKHJvdy50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkgPyByb3cudGltZXN0YW1wIDogRGF0ZS5ub3coKTtcbn07XG5OZXRTaW1Mb2dFbnRyeS5pbmhlcml0cyhOZXRTaW1FbnRpdHkpO1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xuTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzID0ge1xuICBTVUNDRVNTOiAnc3VjY2VzcycsXG4gIERST1BQRUQ6ICdkcm9wcGVkJ1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCBnZXRzIHRoZSBsb2cgdGFibGUgZm9yIHRoZSBjb25maWd1cmVkIGluc3RhbmNlLlxuICogQHJldHVybnMge05ldFNpbVRhYmxlfVxuICovXG5OZXRTaW1Mb2dFbnRyeS5wcm90b3R5cGUuZ2V0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNoYXJkXy5sb2dUYWJsZTtcbn07XG5cbi8qKlxuICogQnVpbGQgb3duIHJvdyBmb3IgdGhlIGxvZyB0YWJsZVxuICogQHJldHVybnMge0xvZ0VudHJ5Um93fVxuICovXG5OZXRTaW1Mb2dFbnRyeS5wcm90b3R5cGUuYnVpbGRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZUlEOiB0aGlzLm5vZGVJRCxcbiAgICBiYXNlNjRCaW5hcnk6IGJpbmFyeVRvQmFzZTY0KHRoaXMuYmluYXJ5KSxcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXBcbiAgfTtcbn07XG5cbi8qKlxuICogU3RhdGljIGFzeW5jIGNyZWF0aW9uIG1ldGhvZC4gIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvbiB0aGUgZ2l2ZW4gc2hhcmQsXG4gKiBhbmQgdGhlbiBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhIHN1Y2Nlc3MgYm9vbGVhbi5cbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHshbnVtYmVyfSBub2RlSUQgLSBhc3NvY2lhdGVkIG5vZGUncyByb3cgSURcbiAqIEBwYXJhbSB7IXN0cmluZ30gYmluYXJ5IC0gbG9nIGNvbnRlbnRzXG4gKiBAcGFyYW0ge05ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1c30gc3RhdHVzXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZSAoc3VjY2VzcylcbiAqL1xuTmV0U2ltTG9nRW50cnkuY3JlYXRlID0gZnVuY3Rpb24gKHNoYXJkLCBub2RlSUQsIGJpbmFyeSwgc3RhdHVzLCBvbkNvbXBsZXRlKSB7XG4gIHZhciBlbnRpdHkgPSBuZXcgTmV0U2ltTG9nRW50cnkoc2hhcmQpO1xuICBlbnRpdHkubm9kZUlEID0gbm9kZUlEO1xuICBlbnRpdHkuYmluYXJ5ID0gYmluYXJ5O1xuICBlbnRpdHkuc3RhdHVzID0gc3RhdHVzO1xuICBlbnRpdHkudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgZW50aXR5LmdldFRhYmxlKCkuY3JlYXRlKGVudGl0eS5idWlsZFJvdygpLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBvbkNvbXBsZXRlKGVyciwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uQ29tcGxldGUoZXJyLCBuZXcgTmV0U2ltTG9nRW50cnkoc2hhcmQsIHJlc3VsdCkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3RlZCBwYWNrZXQgaGVhZGVyIGZpZWxkIGFzIGEgc3RyaW5nLiAgUmV0dXJucyBlbXB0eSBzdHJpbmdcbiAqIGlmIHRoZSByZXF1ZXN0ZWQgZmllbGQgaXMgbm90IGluIHRoZSBjdXJyZW50IHBhY2tldCBmb3JtYXQuXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBmaWVsZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTmV0U2ltTG9nRW50cnkucHJvdG90eXBlLmdldEhlYWRlckZpZWxkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHRyeSB7XG4gICAgaWYgKFBhY2tldC5pc0FkZHJlc3NGaWVsZChmaWVsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tldF8uZ2V0SGVhZGVyQXNBZGRyZXNzU3RyaW5nKGZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2V0Xy5nZXRIZWFkZXJBc0ludChmaWVsZCkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qKiBHZXQgcGFja2V0IG1lc3NhZ2UgYXMgYmluYXJ5LiAqL1xuTmV0U2ltTG9nRW50cnkucHJvdG90eXBlLmdldE1lc3NhZ2VCaW5hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmb3JtYXRCaW5hcnkodGhpcy5wYWNrZXRfLmdldEJvZHlBc0JpbmFyeSgpLCBCSVRTX1BFUl9CWVRFKTtcbn07XG5cbi8qKiBHZXQgcGFja2V0IG1lc3NhZ2UgYXMgQVNDSUkgKi9cbk5ldFNpbUxvZ0VudHJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlQXNjaWkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhY2tldF8uZ2V0Qm9keUFzQXNjaWkoQklUU19QRVJfQllURSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IExvY2FsaXplZCBwYWNrZXQgc3RhdHVzLCBcInN1Y2Nlc3NcIiBvciBcImRyb3BwZWRcIlxuICovXG5OZXRTaW1Mb2dFbnRyeS5wcm90b3R5cGUuZ2V0TG9jYWxpemVkU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdGF0dXMgPT09IE5ldFNpbUxvZ0VudHJ5LkxvZ1N0YXR1cy5TVUNDRVNTKSB7XG4gICAgcmV0dXJuIGkxOG4ubG9nU3RhdHVzX3N1Y2Nlc3MoKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gTmV0U2ltTG9nRW50cnkuTG9nU3RhdHVzLkRST1BQRUQpIHtcbiAgICByZXR1cm4gaTE4bi5sb2dTdGF0dXNfZHJvcHBlZCgpO1xuICB9XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gTG9jYWxpemVkIFwiWCBvZiBZXCIgcGFja2V0IGNvdW50IGluZm8gZm9yIHRoaXMgZW50cnkuXG4gKi9cbk5ldFNpbUxvZ0VudHJ5LnByb3RvdHlwZS5nZXRMb2NhbGl6ZWRQYWNrZXRJbmZvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaTE4bi54T2ZZUGFja2V0cyh7XG4gICAgeDogdGhpcy5nZXRIZWFkZXJGaWVsZChQYWNrZXQuSGVhZGVyVHlwZS5QQUNLRVRfSU5ERVgpLFxuICAgIHk6IHRoaXMuZ2V0SGVhZGVyRmllbGQoUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0NPVU5UKVxuICB9KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gMTItaG91ciB0aW1lIHdpdGggbWlsbGlzZWNvbmRzXG4gKi9cbk5ldFNpbUxvZ0VudHJ5LnByb3RvdHlwZS5nZXRUaW1lU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbW9tZW50KHRoaXMudGltZXN0YW1wKS5mb3JtYXQoJ2g6bW06c3MuU1NTIEEnKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY29udHJvbGxlciBmb3IgdGhlIG5vZGUgdGhhdCBnZW5lcmF0ZWQgdGhpcyBsb2cgZW50cnlcbiAqIEByZXR1cm5zIHtOZXRTaW1DbGllbnROb2RlfE5ldFNpbVJvdXRlck5vZGV8bnVsbH1cbiAqL1xuTmV0U2ltTG9nRW50cnkucHJvdG90eXBlLmdldE9yaWdpbk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlUm93cyA9IHRoaXMuc2hhcmRfLm5vZGVUYWJsZS5yZWFkQWxsKCk7XG4gIHZhciBvcmlnaW5Ob2RlUm93ID0gXy5maW5kKG5vZGVSb3dzLCBmdW5jdGlvbiAocm93KSB7XG4gICAgcmV0dXJuIHJvdy5pZCA9PT0gdGhpcy5ub2RlSUQ7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgaWYgKCFvcmlnaW5Ob2RlUm93KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gTmV0U2ltTm9kZUZhY3Rvcnkubm9kZUZyb21Sb3codGhpcy5zaGFyZF8sIG9yaWdpbk5vZGVSb3cpO1xufTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xMC42XG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNBTW9tZW50T2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3N0cmljdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl90em0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNVVEMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX29mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9wZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2xvY2FsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXSB8fCBuZXcgTG9jYWxlKCk7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHVuaXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHVuaXQgaW4gdW5pdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCh1bml0LCB1bml0c1t1bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1t1bml0c10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UXxZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKHN0aCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjMyNVxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0aCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0aCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgaGVyZSFcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuXG4gICAgdmFyIGZyb21fc3RyaW5nX19pc29SZWdleCA9IC9eXFxzKig/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyhbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGR7Mn0tXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvKFR8IClcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGZyb21fc3RyaW5nX19pc29SZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzZdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mICs9IChtYXRjaFs2XSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gobWF0Y2hPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9mICs9ICdaJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgYWNjZXB0IHllYXJzIDwgMTk3MFxuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gZmlyc3REYXlPZldlZWsgICAgICAgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBkYXkgb2YgdGhlIHdlZWsgdGhhdCBzdGFydHMgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAodXN1YWxseSBzdW5kYXkgb3IgbW9uZGF5KVxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3Qgd2VlayBpcyB0aGUgd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgZGF5IG9mIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKGVnLiBJU08gd2Vla3MgdXNlIHRodXJzZGF5ICg0KSlcbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZmlyc3REYXlPZldlZWssIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyKSB7XG4gICAgICAgIHZhciBlbmQgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBtb20uZGF5KCksXG4gICAgICAgICAgICBhZGp1c3RlZE1vbWVudDtcblxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPiBlbmQpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayAtPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA8IGVuZCAtIDcpIHtcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0ZWRNb21lbnQgPSBsb2NhbF9fY3JlYXRlTG9jYWwobW9tKS5hZGQoZGF5c1RvRGF5T2ZXZWVrLCAnZCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogTWF0aC5jZWlsKGFkanVzdGVkTW9tZW50LmRheU9mWWVhcigpIC8gNyksXG4gICAgICAgICAgICB5ZWFyOiBhZGp1c3RlZE1vbWVudC55ZWFyKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZmlyc3REYXlPZldlZWtPZlllYXIsIGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgIHZhciB3ZWVrMUphbiA9IDYgKyBmaXJzdERheU9mV2VlayAtIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBqYW5YID0gY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCAxICsgd2VlazFKYW4pLCBkID0gamFuWC5nZXRVVENEYXkoKSwgZGF5T2ZZZWFyO1xuICAgICAgICBpZiAoZCA8IGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgICAgICBkICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWVrZGF5ID0gd2Vla2RheSAhPSBudWxsID8gMSAqIHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcblxuICAgICAgICBkYXlPZlllYXIgPSAxICsgd2VlazFKYW4gKyA3ICogKHdlZWsgLSAxKSAtIGQgKyB3ZWVrZGF5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiBkYXlPZlllYXIgPiAwID8geWVhciA6IHllYXIgLSAxLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiBkYXlPZlllYXIgPiAwID8gIGRheU9mWWVhciA6IGRheXNJblllYXIoeWVhciAtIDEpICsgZGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0VVRDRnVsbFllYXIoKSwgbm93LmdldFVUQ01vbnRoKCksIG5vdy5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcDtcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCBkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgKyt3ZWVrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRveSwgZG93KTtcblxuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF07XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbF9fY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICB9XG4gICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDM2ZTU7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaE9mZnNldCkgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkpIC0gKCtyZXMpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUoK3Jlcy5fZCArIGRpZmYpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyh0aGlzLl9pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pc0RTVFNoaWZ0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faXNVVEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwO1xuICAgIH1cblxuICAgIHZhciBhc3BOZXRSZWdleCA9IC8oXFwtKT8oPzooXFxkKilcXC4pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT8pPy87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICB2YXIgY3JlYXRlX19pc29SZWdleCA9IC9eKC0pP1AoPzooPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilEKT8oPzpUKD86KFswLTksLl0qKUgpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopUyk/KT98KFswLTksLl0qKVcpJC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBjcmVhdGVfX2lzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGR1cmF0aW9uLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gZHVyYXRpb24uX21vbnRocztcbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKCttb20uX2QgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZihzb2QsICdkYXlzJywgdHJ1ZSksXG4gICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZm9ybWF0cyAmJiBmb3JtYXRzW2Zvcm1hdF0gfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBsb2NhbF9fY3JlYXRlTG9jYWwobm93KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzID4gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0TXMgPCArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA8ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBpc01vbWVudChpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSA8IGlucHV0TXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSAmJiB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPT09ICtpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9ICsodGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNCxcbiAgICAgICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KTtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nIHx8IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gK3RoaXMuX2QgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoW3llYXIsIDExLCAzMSArIGRvdyAtIGRveV0pLCBkb3csIGRveSkud2VlaztcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KS55ZWFyO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsIDAsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IHRoaXMuX3dlZWtkYXlzUGFyc2UgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICBtb20gPSBsb2NhbF9fY3JlYXRlTG9jYWwoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgID0gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNsb25lICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICA9IGVuZE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZm9ybWF0ICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICA9IGZyb21Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50byAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaW52YWxpZEF0ICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICA9IGlzQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZXR3ZWVuICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgID0gbGFuZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW4gICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdGFydE9mICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICA9IHRvQXJyYXk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b09iamVjdCAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgPSB0b190eXBlX192YWx1ZU9mO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuICAgIC8vIFRpbWV6b25lXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNzc5JywgZ2V0U2V0Wm9uZSk7XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9zZXRfX3NldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZV9fcHJvdG8gPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG90eXBlX19wcm90by5fY2FsZW5kYXIgICAgICAgPSBkZWZhdWx0Q2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgPSBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2xvbmdEYXRlRm9ybWF0ID0gZGVmYXVsdExvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5faW52YWxpZERhdGUgICAgPSBkZWZhdWx0SW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsICAgICAgICA9IGRlZmF1bHRPcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsUGFyc2UgICA9IGRlZmF1bHRPcmRpbmFsUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fcmVsYXRpdmVUaW1lICAgPSBkZWZhdWx0UmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydCAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnQgPSBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNNaW4gICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIC8vIEhvdXJzXG4gICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tZXJpZGllbVBhcnNlID0gZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIGNvdW50LCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRocycsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzID09PSAxICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA9PT0gMSAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPT09IDEgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgID09PSAxICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA9PT0gMSAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb25fcHJvdG90eXBlX19wcm90byA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICA9IGR1cmF0aW9uX2dldF9fZ2V0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICB1dGlsc19ob29rc19faG9va3MudmVyc2lvbiA9ICcyLjEwLjYnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGxvY2FsX19jcmVhdGVMb2NhbCk7XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICB1dGlsc19ob29rc19faG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIvKipcbiAqIEBvdmVydmlldyBVdGlsaXR5IGNsYXNzIGZvciBlbmNvZGluZyBhbmQgZGVjb2Rpbmcgc2ltdWxhdGVkIHBhY2tldHMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIERhdGFDb252ZXJ0ZXJzID0gcmVxdWlyZSgnLi9EYXRhQ29udmVydGVycycpO1xudmFyIE5ldFNpbUdsb2JhbHMgPSByZXF1aXJlKCcuL05ldFNpbUdsb2JhbHMnKTtcblxuLyoqXG4gKiBXcmFwcyBiaW5hcnkgcGFja2V0IGNvbnRlbnQgd2l0aCB0aGUgZm9ybWF0IGluZm9ybWF0aW9uIHJlcXVpcmVkIHRvXG4gKiBpbnRlcnByZXQgaXQuXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlW119IGZvcm1hdFNwZWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUGFja2V0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm9ybWF0U3BlYywgYmluYXJ5KSB7XG4gIHZhciBsZXZlbCA9IE5ldFNpbUdsb2JhbHMuZ2V0TGV2ZWxDb25maWcoKTtcblxuICAvKiogQHR5cGUge1BhY2tldC5FbmNvZGVyfSAqL1xuICB0aGlzLmVuY29kZXIgPSBuZXcgUGFja2V0LkVuY29kZXIobGV2ZWwuYWRkcmVzc0Zvcm1hdCxcbiAgICAgIGxldmVsLnBhY2tldENvdW50Qml0V2lkdGgsIGZvcm1hdFNwZWMpO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBvZiBiaW5hcnkgY29udGVudCAqL1xuICB0aGlzLmJpbmFyeSA9IGJpbmFyeTtcbn07XG5cbi8qKlxuICogUG9zc2libGUgcGFja2V0IGhlYWRlciBmaWVsZHMuICBWYWx1ZXMgdG8gdGhpcyBlbnVtIGJlY29tZSBrZXlzXG4gKiB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gZGVmaW5pbmcgYSBsZXZlbCBjb25maWd1cmF0aW9uLiAgVGhleSBhbHNvIGNvcnJlc3BvbmRcbiAqIHRvIGNsYXNzIG5hbWVzIHRoYXQgZ2V0IGFwcGxpZWQgdG8gZmllbGRzIHJlcHJlc2VudGluZyBkYXRhIGluIHRoYXQgY29sdW1uLlxuICogQGVudW0ge3N0cmluZ31cbiAqIEByZWFkb25seVxuICovXG5QYWNrZXQuSGVhZGVyVHlwZSA9IHtcbiAgVE9fQUREUkVTUzogJ3RvQWRkcmVzcycsXG4gIEZST01fQUREUkVTUzogJ2Zyb21BZGRyZXNzJyxcbiAgUEFDS0VUX0lOREVYOiAncGFja2V0SW5kZXgnLFxuICBQQUNLRVRfQ09VTlQ6ICdwYWNrZXRDb3VudCdcbn07XG5cbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gaGVhZGVyIGZpZWxkIHR5cGUgd2lsbCB1c2UgdGhlIGFkZHJlc3MgZm9ybWF0LlxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZX0gaGVhZGVyVHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBhY2tldC5pc0FkZHJlc3NGaWVsZCA9IGZ1bmN0aW9uIChoZWFkZXJUeXBlKSB7XG4gIHJldHVybiBoZWFkZXJUeXBlID09PSBQYWNrZXQuSGVhZGVyVHlwZS5UT19BRERSRVNTIHx8XG4gICAgICBoZWFkZXJUeXBlID09PSBQYWNrZXQuSGVhZGVyVHlwZS5GUk9NX0FERFJFU1M7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIGhlYWRlciBmaWVsZCB3aWxsIHVzZSB0aGUgcGFja2V0Q291bnQgYml0IHdpZHRoLlxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZX0gaGVhZGVyVHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBhY2tldC5pc1BhY2tldEZpZWxkID0gZnVuY3Rpb24gKGhlYWRlclR5cGUpIHtcbiAgcmV0dXJuIGhlYWRlclR5cGUgPT09IFBhY2tldC5IZWFkZXJUeXBlLlBBQ0tFVF9JTkRFWCB8fFxuICAgICAgaGVhZGVyVHlwZSA9PT0gUGFja2V0LkhlYWRlclR5cGUuUEFDS0VUX0NPVU5UO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBoZWFkZXJUeXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBvZiBiaW5hcnkgY29udGVudFxuICovXG5QYWNrZXQucHJvdG90eXBlLmdldEhlYWRlckFzQmluYXJ5ID0gZnVuY3Rpb24gKGhlYWRlclR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5nZXRIZWFkZXIoaGVhZGVyVHlwZSwgdGhpcy5iaW5hcnkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBoZWFkZXJUeXBlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5QYWNrZXQucHJvdG90eXBlLmdldEhlYWRlckFzSW50ID0gZnVuY3Rpb24gKGhlYWRlclR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5nZXRIZWFkZXJBc0ludChoZWFkZXJUeXBlLCB0aGlzLmJpbmFyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UGFja2V0LkhlYWRlclR5cGV9IGhlYWRlclR5cGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBhY2tldC5wcm90b3R5cGUuZ2V0SGVhZGVyQXNBZGRyZXNzU3RyaW5nID0gZnVuY3Rpb24gKGhlYWRlclR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5nZXRIZWFkZXJBc0FkZHJlc3NTdHJpbmcoaGVhZGVyVHlwZSwgdGhpcy5iaW5hcnkpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgY29udGVudFxuICovXG5QYWNrZXQucHJvdG90eXBlLmdldEJvZHlBc0JpbmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5nZXRCb2R5KHRoaXMuYmluYXJ5KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhc2NpaSBjb250ZW50XG4gKi9cblBhY2tldC5wcm90b3R5cGUuZ2V0Qm9keUFzQXNjaWkgPSBmdW5jdGlvbiAoYml0c1BlckNoYXIpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5nZXRCb2R5QXNBc2NpaSh0aGlzLmJpbmFyeSwgYml0c1BlckNoYXIpO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhcnRpY3VsYXIgcGFja2V0IGZvcm1hdCwgY2FuIGNvbnZlcnQgYSBzZXQgb2YgZmllbGRzIGRvd25cbiAqIGludG8gYSBiaW5hcnkgc3RyaW5nIG1hdGNoaW5nIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBleHRyYWN0IGZpZWxkc1xuICogb24gZGVtYW5kIGZyb20gYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtBZGRyZXNzSGVhZGVyRm9ybWF0fSBhZGRyZXNzRm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFja2V0Q291bnRCaXRXaWR0aFxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZVtdfSBoZWFkZXJTcGVjIC0gU3BlY2lmaWNhdGlvbiBvZiBwYWNrZXQgZm9ybWF0LCBhblxuICogICAgICAgIG9yZGVyZWQgc2V0IG9mIG9iamVjdHMgaW4gdGhlIGZvcm0ge2tleTpzdHJpbmcsIGJpdHM6bnVtYmVyfSB3aGVyZVxuICogICAgICAgIGtleSBpcyB0aGUgZmllbGQgbmFtZSB5b3UnbGwgdXNlIHRvIHJldHJpZXZlIHRoZSBpbmZvcm1hdGlvbiwgYW5kXG4gKiAgICAgICAgYml0cyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBmaWVsZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QYWNrZXQuRW5jb2RlciA9IGZ1bmN0aW9uIChhZGRyZXNzRm9ybWF0LCBwYWNrZXRDb3VudEJpdFdpZHRoLCBoZWFkZXJTcGVjKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLmFkZHJlc3NGb3JtYXRfID0gYWRkcmVzc0Zvcm1hdDtcblxuICB0aGlzLmFkZHJlc3NCaXRXaWR0aF8gPSB0aGlzLmNhbGN1bGF0ZUJpdFdpZHRoKHRoaXMuYWRkcmVzc0Zvcm1hdF8pO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnBhY2tldENvdW50Qml0V2lkdGhfID0gcGFja2V0Q291bnRCaXRXaWR0aDtcblxuICAvKiogQHR5cGUge1BhY2tldC5IZWFkZXJUeXBlW119ICovXG4gIHRoaXMuaGVhZGVyU3BlY18gPSBoZWFkZXJTcGVjO1xuXG4gIHRoaXMudmFsaWRhdGVTcGVjKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWRkcmVzc0hlYWRlckZvcm1hdH0gYWRkcmVzc0Zvcm1hdFxuICogQHByaXZhdGVcbiAqL1xuUGFja2V0LkVuY29kZXIucHJvdG90eXBlLmNhbGN1bGF0ZUJpdFdpZHRoID0gZnVuY3Rpb24gKGFkZHJlc3NGb3JtYXQpIHtcbiAgcmV0dXJuIGFkZHJlc3NGb3JtYXQuc3BsaXQoL1xcRCsvKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2ICsgKHBhcnNlSW50KGN1ciwgMTApIHx8IDApO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIGNvbmZpZ3VyZWQgZm9ybWF0IHNwZWNpZmljYXRpb24gZGVzY3JpYmVzIGEgdmFsaWQgZm9ybWF0IHRoYXRcbiAqIGNhbiBiZSB1c2VkIGJ5IHRoZSBQYWNrZXQuRW5jb2RlciBvYmplY3QuXG4gKi9cblBhY2tldC5FbmNvZGVyLnByb3RvdHlwZS52YWxpZGF0ZVNwZWMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlDYWNoZSA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oZWFkZXJTcGVjXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpc0FkZHJlc3NGaWVsZCA9IFBhY2tldC5pc0FkZHJlc3NGaWVsZCh0aGlzLmhlYWRlclNwZWNfW2ldKTtcbiAgICB2YXIgaXNQYWNrZXRGaWVsZCA9IFBhY2tldC5pc1BhY2tldEZpZWxkKHRoaXMuaGVhZGVyU3BlY19baV0pO1xuXG4gICAgaWYgKGlzQWRkcmVzc0ZpZWxkICYmIHRoaXMuYWRkcmVzc0JpdFdpZHRoXyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYWNrZXQgZm9ybWF0OiBJbmNsdWRlcyBhbiBhZGRyZXNzIGZpZWxkIGJ1dCBcIiArXG4gICAgICAgIFwiIGFkZHJlc3MgZm9ybWF0IGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIGlmIChpc1BhY2tldEZpZWxkICYmIHRoaXMucGFja2V0Q291bnRCaXRXaWR0aF8gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFja2V0IGZvcm1hdDogSW5jbHVkZXMgYSBwYWNrZXQgY291bnQgZmllbGQgXCIgK1xuICAgICAgICAgIFwiIGJ1dCBwYWNrZXQgZmllbGQgYml0IHdpZHRoIGlzIHplcm9cIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FkZHJlc3NGaWVsZCAmJiAhaXNQYWNrZXRGaWVsZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYWNrZXQgZm9ybWF0OiBVbnJlY29nbml6ZWQgcGFja2V0IGhlYWRlciBmaWVsZCBcIiArXG4gICAgICAgICAgdGhpcy5oZWFkZXJTcGVjX1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKGtleUNhY2hlLmhhc093blByb3BlcnR5KHRoaXMuaGVhZGVyU3BlY19baV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhY2tldCBmb3JtYXQ6IEZpZWxkIGtleXMgbXVzdCBiZSB1bmlxdWUuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlDYWNoZVt0aGlzLmhlYWRlclNwZWNfW2ldXSA9ICd1c2VkJztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgcmVxdWVzdGVkIGhlYWRlciBmaWVsZCBieSBrZXkgZnJvbSB0aGUgcHJvdmlkZWQgYmluYXJ5IGJsb2IuXG4gKlxuICogQHBhcmFtIHtQYWNrZXQuSGVhZGVyVHlwZX0ga2V5IC0gd2hpY2ggaGVhZGVyIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5IGZvciBlbnRpcmUgcGFja2V0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgc3RyaW5nIHZhbHVlIGZvciBoZWFkZXIgZmllbGRcbiAqIEB0aHJvd3Mgd2hlbiByZXF1ZXN0ZWQga2V5IGlzIG5vdCBpbiB0aGUgY29uZmlndXJlZCBwYWNrZXQgc3BlY1xuICovXG5QYWNrZXQuRW5jb2Rlci5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSwgYmluYXJ5KSB7XG4gIHZhciBydWxlSW5kZXggPSAwLCBiaW5hcnlJbmRleCA9IDA7XG5cbiAgLy8gU3RyaXAgd2hpdGVzcGFjZSBzbyB3ZSBkb24ndCB3b3JyeSBhYm91dCBiZWluZyBwYXNzZWQgZm9ybWF0dGVkIGJpbmFyeVxuICBiaW5hcnkgPSBEYXRhQ29udmVydGVycy5taW5pZnlCaW5hcnkoYmluYXJ5KTtcblxuICB3aGlsZSAodGhpcy5oZWFkZXJTcGVjX1tydWxlSW5kZXhdICE9PSBrZXkpIHtcbiAgICBiaW5hcnlJbmRleCArPSB0aGlzLmdldEZpZWxkQml0V2lkdGgodGhpcy5oZWFkZXJTcGVjX1tydWxlSW5kZXhdKTtcbiAgICBydWxlSW5kZXgrKztcblxuICAgIGlmIChydWxlSW5kZXggPj0gdGhpcy5oZWFkZXJTcGVjXy5sZW5ndGgpIHtcbiAgICAgIC8vIERpZG4ndCBmaW5kIGtleVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgXCInICsga2V5ICsgJ1wiIG5vdCBmb3VuZCBpbiBwYWNrZXQgc3BlYy4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIHZhbHVlXG4gIHZhciBiaXRXaWR0aCA9IHRoaXMuZ2V0RmllbGRCaXRXaWR0aCh0aGlzLmhlYWRlclNwZWNfW3J1bGVJbmRleF0pO1xuICB2YXIgYml0cyA9IGJpbmFyeS5zbGljZShiaW5hcnlJbmRleCwgYmluYXJ5SW5kZXggKyBiaXRXaWR0aCk7XG5cbiAgLy8gUmlnaHQtcGFkIHdpdGggemVyb2VzIHRvIGRlc2lyZWQgc2l6ZVxuICBpZiAoYml0V2lkdGggIT09IEluZmluaXR5KSB7XG4gICAgd2hpbGUgKGJpdHMubGVuZ3RoIDwgYml0V2lkdGgpIHtcbiAgICAgIGJpdHMgKz0gJzAnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiaXRzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBrZXkgLSBmaWVsZCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5IC0gZW50aXJlIHBhY2tldCBhcyBhIGJpbmFyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gcmVxdWVzdGVkIGZpZWxkLCBpbnRlcnByZXRlZCBhcyBhbiBpbnQuXG4gKi9cblBhY2tldC5FbmNvZGVyLnByb3RvdHlwZS5nZXRIZWFkZXJBc0ludCA9IGZ1bmN0aW9uIChrZXksIGJpbmFyeSkge1xuICByZXR1cm4gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9JbnQodGhpcy5nZXRIZWFkZXIoa2V5LCBiaW5hcnkpKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYW4gYWRkcmVzcyBoZWFkZXIgYXMgYSBzdHJpbmcsIHNvIHdlIGNhbiBnaXZlIHRoZSBtdWx0aS1wYXJ0XG4gKiByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7UGFja2V0LkhlYWRlclR5cGV9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeSBmb3Igd2hvbGUgcGFja2V0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5QYWNrZXQuRW5jb2Rlci5wcm90b3R5cGUuZ2V0SGVhZGVyQXNBZGRyZXNzU3RyaW5nID0gZnVuY3Rpb24gKGtleSwgYmluYXJ5KSB7XG4gIHJldHVybiBEYXRhQ29udmVydGVycy5iaW5hcnlUb0FkZHJlc3NTdHJpbmcoXG4gICAgICB0aGlzLmdldEhlYWRlcihrZXksIGJpbmFyeSksIHRoaXMuYWRkcmVzc0Zvcm1hdF8pO1xufTtcblxuLyoqXG4gKiBTa2lwIG92ZXIgaGVhZGVycyBnaXZlbiBpbiBzcGVjIGFuZCByZXR1cm4gcmVtYWluZGVyIG9mIGJpbmFyeSB3aGljaFxuICogbXVzdCBiZSB0aGUgbWVzc2FnZSBib2R5LlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeSAtIGVudGlyZSBwYWNrZXQgYXMgYSBiaW5hcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwYWNrZXQgYm9keSBiaW5hcnkgc3RyaW5nXG4gKi9cblBhY2tldC5FbmNvZGVyLnByb3RvdHlwZS5nZXRCb2R5ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICByZXR1cm4gRGF0YUNvbnZlcnRlcnMubWluaWZ5QmluYXJ5KGJpbmFyeSlcbiAgICAgIC5zbGljZSh0aGlzLmdldEhlYWRlckxlbmd0aCgpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gSG93IG1hbnkgYml0cyB0aGUgaGVhZGVyIHRha2VzIHVwXG4gKi9cblBhY2tldC5FbmNvZGVyLnByb3RvdHlwZS5nZXRIZWFkZXJMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlclNwZWNfLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyB0aGlzLmdldEZpZWxkQml0V2lkdGgoY3VyKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8qKlxuICogU2tpcCBvdmVyIGhlYWRlcnMgZ2l2ZW4gaW4gc3BlYywgYW5kIHJldHVybiByZW1haW5kZXIgb2YgcGFja2V0IGludGVycHJldGVkXG4gKiB0byBhc2NpaSB3aXRoIHRoZSBnaXZlbiBjaGFyYWN0ZXIgd2lkdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5IC0gZW50aXJlIHBhY2tldCBhcyBhIGJpbmFyeSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhciAtIGJpdHMgdG8gcmVwcmVzZW50IGFzIGEgc2luZ2xlIGNoYXJhY3RlcixcbiAqICAgICAgICByZWNvbW1lbmRlZCB0byB1c2UgOCBmb3Igbm9ybWFsIEFTQ0lJLlxuICovXG5QYWNrZXQuRW5jb2Rlci5wcm90b3R5cGUuZ2V0Qm9keUFzQXNjaWkgPSBmdW5jdGlvbiAoYmluYXJ5LCBiaXRzUGVyQ2hhcikge1xuICByZXR1cm4gRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9Bc2NpaSh0aGlzLmdldEJvZHkoYmluYXJ5KSwgYml0c1BlckNoYXIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1BhY2tldC5IZWFkZXJUeXBlfSBoZWFkZXJUeXBlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBob3cgbWFueSBiaXRzIHRoYXQgZmllbGQgc2hvdWxkIHRha2UgaW4gdGhlIHBhY2tldCBoZWFkZXJcbiAqL1xuUGFja2V0LkVuY29kZXIucHJvdG90eXBlLmdldEZpZWxkQml0V2lkdGggPSBmdW5jdGlvbiAoaGVhZGVyVHlwZSkge1xuICBpZiAoUGFja2V0LmlzQWRkcmVzc0ZpZWxkKGhlYWRlclR5cGUpKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc0JpdFdpZHRoXztcbiAgfVxuXG4gIGlmIChQYWNrZXQuaXNQYWNrZXRGaWVsZChoZWFkZXJUeXBlKSkge1xuICAgIHJldHVybiB0aGlzLnBhY2tldENvdW50Qml0V2lkdGhfO1xuICB9XG5cbiAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLlxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2VsZWN0IGEgYml0LXdpZHRoIGZvciBmaWVsZCBcIiArIGhlYWRlclR5cGUpO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIFwiaGVhZGVyc1wiIG9iamVjdCB3aGVyZSB0aGUgdmFsdWVzIGFyZSBudW1iZXJzLCByZXR1cm5zIGEgY29ycmVzcG9uZGluZ1xuICogXCJoZWFkZXJzXCIgb2JqZWN0IHdoZXJlIHRoZSB2YWx1ZXMgaGF2ZSBhbGwgYmVlbiBjb252ZXJ0ZWQgdG8gYmluYXJ5XG4gKiByZXByZXNlbnRhdGlvbnMgYXQgdGhlIGFwcHJvcHJpYXRlIHdpZHRoLiAgT25seSBoZWFkZXIgZmllbGRzIHRoYXQgYXBwZWFyIGluXG4gKiB0aGUgY29uZmlndXJlZCBwYWNrZXQgaGVhZGVyIGZvcm1hdCB3aWxsIGJlIGNvbnZlcnRlZCBhbmQgcGFzc2VkIHRocm91Z2ggdG9cbiAqIG91dHB1dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gd2l0aCBudW1iZXIgdmFsdWVzXG4gKi9cblBhY2tldC5FbmNvZGVyLnByb3RvdHlwZS5tYWtlQmluYXJ5SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIHZhciBiaW5hcnlIZWFkZXJzID0ge307XG4gIHRoaXMuaGVhZGVyU3BlY18uZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyRmllbGQpe1xuICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlckZpZWxkKSkge1xuICAgICAgLy8gQ29udmVydCBkaWZmZXJlbnRseSBmb3IgYWRkcmVzcyBhbmQgcGFja2V0IGZpZWxkcz9cbiAgICAgIGlmIChQYWNrZXQuaXNBZGRyZXNzRmllbGQoaGVhZGVyRmllbGQpKSB7XG4gICAgICAgIGJpbmFyeUhlYWRlcnNbaGVhZGVyRmllbGRdID0gdGhpcy5hZGRyZXNzU3RyaW5nVG9CaW5hcnkoaGVhZGVyc1toZWFkZXJGaWVsZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluYXJ5SGVhZGVyc1toZWFkZXJGaWVsZF0gPSBEYXRhQ29udmVydGVycy5pbnRUb0JpbmFyeShcbiAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVyRmllbGRdLCB0aGlzLmdldEZpZWxkQml0V2lkdGgoaGVhZGVyRmllbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xuICByZXR1cm4gYmluYXJ5SGVhZGVycztcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBhZGRyZXNzIHN0cmluZyAocG9zc2libHkgbXVsdGktcGFydCkgaW50byBiaW5hcnkgYmFzZWQgb24gdGhlXG4gKiBjb25maWd1cmVkIGFkZHJlc3MgZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSByZXByZXNlbnRhdGlvblxuICovXG5QYWNrZXQuRW5jb2Rlci5wcm90b3R5cGUuYWRkcmVzc1N0cmluZ1RvQmluYXJ5ID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIERhdGFDb252ZXJ0ZXJzLmFkZHJlc3NTdHJpbmdUb0JpbmFyeShhZGRyZXNzLCB0aGlzLmFkZHJlc3NGb3JtYXRfKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgYmluYXJ5IGhlYWRlcnMgYW5kIGEgYmluYXJ5IGJvZHksIGFuZCBnZW5lcmF0ZXMgYSBjb21wbGV0ZVxuICogcGFja2V0IGJpbmFyeSBtYXRjaGluZyB0aGUgY29uZmlndXJlZCBwYWNrZXQgc3BlYyBpbiB0ZXJtcyBvZiBoZWFkZXIgd2lkdGhcbiAqIGFuZCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmluYXJ5SGVhZGVycyAtIGhhc2ggY29udGFpbmluZyBwYWNrZXQgaGVhZGVycyBpbiBiaW5hcnksIHdoZXJlXG4gKiAgICAgICAgdGhlIGhhc2gga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBcImtleVwiIHZhbHVlcyBpbiB0aGUgcGFja2V0IHNwZWMsIGFuZFxuICogICAgICAgIHRoZSBoYXNoIHZhbHVlcyBhcmUgYmluYXJ5IHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9keSAtIGJpbmFyeSBzdHJpbmcgb2YgdGhlIHVubGltaXRlZC1sZW5ndGggYm9keSBvZiB0aGVcbiAqICAgICAgICBwYWNrZXQsIHdoaWNoIHdpbGwgYmUgcGxhY2VkIGFmdGVyIHRoZSBwYWNrZXQgaGVhZGVycy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgc3RyaW5nIG9mIHByb3ZpZGVkIGRhdGEsIGNvbmZvcm1pbmcgdG8gY29uZmlndXJlZFxuICogICAgICAgICAgcGFja2V0IGZvcm1hdC5cbiAqL1xuUGFja2V0LkVuY29kZXIucHJvdG90eXBlLmNvbmNhdGVuYXRlQmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeUhlYWRlcnMsIGJvZHkpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgdGhpcy5oZWFkZXJTcGVjXy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZFNwZWMpIHtcbiAgICB2YXIgZmllbGRXaWR0aCA9IHRoaXMuZ2V0RmllbGRCaXRXaWR0aChmaWVsZFNwZWMpO1xuXG4gICAgLy8gR2V0IGhlYWRlciB2YWx1ZSBmcm9tIHByb3ZpZGVkIGhlYWRlcnMsIGlmIGl0IGV4aXN0cy5cbiAgICAvLyBJZiBub3QsIHdlJ2xsIHN0YXJ0IHdpdGggYW4gZW1wdHkgc3RyaW5nIGFuZCBwYWQgaXQgdG8gdGhlIGNvcnJlY3RcbiAgICAvLyBsZW5ndGgsIGJlbG93LlxuICAgIHZhciBmaWVsZEJpdHMgPSBiaW5hcnlIZWFkZXJzLmhhc093blByb3BlcnR5KGZpZWxkU3BlYykgP1xuICAgICAgICBiaW5hcnlIZWFkZXJzW2ZpZWxkU3BlY10gOiAnJztcblxuICAgIC8vIFJpZ2h0LXRydW5jYXRlIHRvIHRoZSBkZXNpcmVkIHNpemVcbiAgICBmaWVsZEJpdHMgPSBmaWVsZEJpdHMuc2xpY2UoMCwgZmllbGRXaWR0aCk7XG5cbiAgICAvLyBMZWZ0LXBhZCB0byBkZXNpcmVkIHNpemVcbiAgICBmaWVsZEJpdHMgPSBOZXRTaW1VdGlscy56ZXJvUGFkTGVmdChmaWVsZEJpdHMsIGZpZWxkV2lkdGgpO1xuXG4gICAgcGFydHMucHVzaChmaWVsZEJpdHMpO1xuICB9LCB0aGlzKTtcblxuICBwYXJ0cy5wdXNoKGJvZHkpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb250cm9sbGVyIGZvciB0aGUgRE5TIHRhYiBpbiB0aGUgbGVmdCBjb2x1bW4uXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1EbnNUYWIuaHRtbC5lanMnKTtcbnZhciBEbnNNb2RlID0gcmVxdWlyZSgnLi9OZXRTaW1Db25zdGFudHMnKS5EbnNNb2RlO1xudmFyIE5ldFNpbURuc01vZGVDb250cm9sID0gcmVxdWlyZSgnLi9OZXRTaW1EbnNNb2RlQ29udHJvbCcpO1xudmFyIE5ldFNpbURuc01hbnVhbENvbnRyb2wgPSByZXF1aXJlKCcuL05ldFNpbURuc01hbnVhbENvbnRyb2wnKTtcbnZhciBOZXRTaW1EbnNUYWJsZSA9IHJlcXVpcmUoJy4vTmV0U2ltRG5zVGFibGUnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBcIkROU1wiIHRhYi5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkbnNNb2RlQ2hhbmdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGJlY29tZURuc0NhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbURuc1RhYiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsIGRuc01vZGVDaGFuZ2VDYWxsYmFjayxcbiAgICBiZWNvbWVEbnNDYWxsYmFjaykge1xuICAvKipcbiAgICogQ29tcG9uZW50IHJvb3QsIHdoaWNoIHdlIGZpbGwgd2hlbmV2ZXIgd2UgY2FsbCByZW5kZXIoKVxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IHJvb3REaXY7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTW9kZUNoYW5nZUNhbGxiYWNrXyA9IGRuc01vZGVDaGFuZ2VDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iZWNvbWVEbnNDYWxsYmFja18gPSBiZWNvbWVEbnNDYWxsYmFjaztcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbURuc01vZGVDb250cm9sfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kbnNNb2RlQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltRG5zTWFudWFsQ29udHJvbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTWFudWFsQ29udHJvbF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7TmV0U2ltRG5zVGFibGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRuc1RhYmxlXyA9IG51bGw7XG5cbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogRmlsbCB0aGUgcm9vdCBkaXYgd2l0aCBuZXcgZWxlbWVudHMgcmVmbGVjdGluZyB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5OZXRTaW1EbnNUYWIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxldmVsQ29uZmlnID0gTmV0U2ltR2xvYmFscy5nZXRMZXZlbENvbmZpZygpO1xuXG4gIHZhciByZW5kZXJlZE1hcmt1cCA9ICQobWFya3VwKHtcbiAgICBsZXZlbDogbGV2ZWxDb25maWdcbiAgfSkpO1xuICB0aGlzLnJvb3REaXZfLmh0bWwocmVuZGVyZWRNYXJrdXApO1xuXG4gIGlmIChsZXZlbENvbmZpZy5zaG93RG5zTW9kZUNvbnRyb2wpIHtcbiAgICB0aGlzLmRuc01vZGVDb250cm9sXyA9IG5ldyBOZXRTaW1EbnNNb2RlQ29udHJvbChcbiAgICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcuZG5zX21vZGUnKSxcbiAgICAgICAgdGhpcy5kbnNNb2RlQ2hhbmdlQ2FsbGJhY2tfKTtcbiAgfVxuXG4gIHRoaXMuZG5zTWFudWFsQ29udHJvbF8gPSBuZXcgTmV0U2ltRG5zTWFudWFsQ29udHJvbChcbiAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnLmRuc19tYW51YWxfY29udHJvbCcpLFxuICAgICAgdGhpcy5iZWNvbWVEbnNDYWxsYmFja18pO1xuXG4gIHRoaXMuZG5zVGFibGVfID0gbmV3IE5ldFNpbURuc1RhYmxlKFxuICAgICAgdGhpcy5yb290RGl2Xy5maW5kKCcuZG5zX3RhYmxlJykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Ruc01vZGV9IG5ld0Ruc01vZGVcbiAqL1xuTmV0U2ltRG5zVGFiLnByb3RvdHlwZS5zZXREbnNNb2RlID0gZnVuY3Rpb24gKG5ld0Ruc01vZGUpIHtcbiAgaWYgKHRoaXMuZG5zTW9kZUNvbnRyb2xfKSB7XG4gICAgdGhpcy5kbnNNb2RlQ29udHJvbF8uc2V0RG5zTW9kZShuZXdEbnNNb2RlKTtcbiAgfVxuXG4gIHRoaXMuZG5zVGFibGVfLnNldERuc01vZGUobmV3RG5zTW9kZSk7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLmRuc19tYW51YWxfY29udHJvbCcpLnRvZ2dsZShuZXdEbnNNb2RlID09PSBEbnNNb2RlLk1BTlVBTCk7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLmRucy1ub3RlcycpLnRvZ2dsZShuZXdEbnNNb2RlICE9PSBEbnNNb2RlLk5PTkUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRG5zTm9kZVxuICovXG5OZXRTaW1EbnNUYWIucHJvdG90eXBlLnNldElzRG5zTm9kZSA9IGZ1bmN0aW9uIChpc0Ruc05vZGUpIHtcbiAgdGhpcy5kbnNNYW51YWxDb250cm9sXy5zZXRJc0Ruc05vZGUoaXNEbnNOb2RlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFibGVDb250ZW50c1xuICovXG5OZXRTaW1EbnNUYWIucHJvdG90eXBlLnNldERuc1RhYmxlQ29udGVudHMgPSBmdW5jdGlvbiAodGFibGVDb250ZW50cykge1xuICB0aGlzLmRuc1RhYmxlXy5zZXREbnNUYWJsZUNvbnRlbnRzKHRhYmxlQ29udGVudHMpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIHRhYmxlIG9mIGxvY2FsIHN1Ym5ldCwgZGlzcGxheWluZyBob3N0bmFtZSA9PiBhZGRyZXNzIG1hcC5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbURuc1RhYmxlLmh0bWwuZWpzJyk7XG52YXIgRG5zTW9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuRG5zTW9kZTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIEROUyBuZXR3b3JrIGxvb2t1cCB0YWJsZSBjb21wb25lbnQuXG4gKiBTaG93cyBkaWZmZXJlbnQgYW1vdW50cyBvZiBpbmZvcm1hdGlvbiBkZXBlbmRpbmcgb24gdGhlIEROUyBtb2RlLlxuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbURuc1RhYmxlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdERpdikge1xuICAvKipcbiAgICogQ29tcG9uZW50IHJvb3QsIHdoaWNoIHdlIGZpbGwgd2hlbmV2ZXIgd2UgY2FsbCByZW5kZXIoKVxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IHJvb3REaXY7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtEbnNNb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kbnNNb2RlXyA9IERuc01vZGUuTk9ORTtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5hZGRyZXNzVGFibGVEYXRhXyA9IFtdO1xuXG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqL1xuTmV0U2ltRG5zVGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlbmRlcmVkTWFya3VwID0gJChtYXJrdXAoe1xuICAgIGRuc01vZGU6IHRoaXMuZG5zTW9kZV8sXG4gICAgdGFibGVEYXRhOiB0aGlzLmFkZHJlc3NUYWJsZURhdGFfXG4gIH0pKTtcbiAgdGhpcy5yb290RGl2Xy5odG1sKHJlbmRlcmVkTWFya3VwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEbnNNb2RlfSBuZXdEbnNNb2RlXG4gKi9cbk5ldFNpbURuc1RhYmxlLnByb3RvdHlwZS5zZXREbnNNb2RlID0gZnVuY3Rpb24gKG5ld0Ruc01vZGUpIHtcbiAgdGhpcy5kbnNNb2RlXyA9IG5ld0Ruc01vZGU7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhYmxlQ29udGVudHNcbiAqL1xuTmV0U2ltRG5zVGFibGUucHJvdG90eXBlLnNldERuc1RhYmxlQ29udGVudHMgPSBmdW5jdGlvbiAodGFibGVDb250ZW50cykge1xuICB0aGlzLmFkZHJlc3NUYWJsZURhdGFfID0gdGFibGVDb250ZW50cztcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7XG52YXIgRG5zTW9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuRG5zTW9kZTtcbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJuZXRzaW0tZG5zLXRhYmxlXCI+XFxuICA8aDE+TXkgTmV0d29yazwvaDE+XFxuICA8dGFibGU+XFxuICAgIDx0aGVhZD5cXG4gICAgPHRyPlxcbiAgICAgIDx0aD5Ib3N0bmFtZTwvdGg+XFxuICAgICAgPHRoPkFkZHJlc3M8L3RoPlxcbiAgICA8L3RyPlxcbiAgICA8L3RoZWFkPlxcbiAgICA8dGJvZHk+XFxuICAgICcpOzE0O1xuICAgIHRhYmxlRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHZhciBkaXNwbGF5SG9zdG5hbWUgPSByb3cuaG9zdG5hbWU7XG4gICAgICB2YXIgZGlzcGxheUFkZHJlc3MgPSAnJztcbiAgICAgIHZhciByb3dDbGFzc2VzID0gW107XG5cbiAgICAgIGlmIChkbnNNb2RlID09PSBEbnNNb2RlLk5PTkUgfHwgcm93LmlzRG5zTm9kZSB8fCByb3cuaXNMb2NhbCkge1xuICAgICAgICBkaXNwbGF5QWRkcmVzcyA9IHJvdy5hZGRyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAocm93LmlzTG9jYWwpIHtcbiAgICAgICAgZGlzcGxheUhvc3RuYW1lICs9IFwiIChNZSlcIjtcbiAgICAgICAgcm93Q2xhc3Nlcy5wdXNoKCdsb2NhbC1ub2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3cuaXNEbnNOb2RlICYmIGRuc01vZGUgIT09IERuc01vZGUuTk9ORSkge1xuICAgICAgICBkaXNwbGF5SG9zdG5hbWUgKz0gXCIgKEROUylcIjtcbiAgICAgICAgcm93Q2xhc3Nlcy5wdXNoKCdkbnMtbm9kZScpO1xuICAgICAgfVxuICAgICAgOyBidWYucHVzaCgnXFxuICAgICAgICA8dHIgY2xhc3M9XCInLCBlc2NhcGUoKDM0LCAgcm93Q2xhc3Nlcy5qb2luKCcgJykgKSksICdcIj5cXG4gICAgICAgICAgPHRkPicsIGVzY2FwZSgoMzUsICBkaXNwbGF5SG9zdG5hbWUgKSksICc8L3RkPlxcbiAgICAgICAgICA8dGQ+JywgZXNjYXBlKCgzNiwgIGRpc3BsYXlBZGRyZXNzICkpLCAnPC90ZD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgJyk7Mzg7XG4gICAgfSk7XG4gICAgOyBidWYucHVzaCgnXFxuICAgIDwvdGJvZHk+XFxuICA8L3RhYmxlPlxcbjwvZGl2PicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBjbGFzcz1cIm5ldHNpbS1kbnMtdGFiXCI+XFxuICAnKTsyOyBpZiAobGV2ZWwuc2hvd0Ruc01vZGVDb250cm9sKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBjbGFzcz1cImRuc19tb2RlXCI+PC9kaXY+XFxuICAnKTs0OyB9IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBjbGFzcz1cImRuc19tYW51YWxfY29udHJvbFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImRuc190YWJsZVwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImRucy1ub3Rlc1wiPlxcbiAgICA8aDE+Tm90ZXM8L2gxPlxcbiAgICA8ZGl2PlxcbiAgICAgIDx0ZXh0YXJlYT48L3RleHRhcmVhPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFVJIGNvbXBvbmVudCB1c2VkIHRvIHNlbGVjdCBhIEROUyBtb2RlIGF0IHJ1bnRpbWUuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1EbnNNb2RlQ29udHJvbC5odG1sLmVqcycpO1xudmFyIERuc01vZGUgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLkRuc01vZGU7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBETlMgbW9kZSBzZWxlY3RvclxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXZcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRuc01vZGVDaGFuZ2VDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXRTaW1EbnNNb2RlQ29udHJvbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsXG4gICAgZG5zTW9kZUNoYW5nZUNhbGxiYWNrKSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kbnNNb2RlQ2hhbmdlQ2FsbGJhY2tfID0gZG5zTW9kZUNoYW5nZUNhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgYWxsIEROUyBtb2RlIHJhZGlvIGJ1dHRvbnNcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZG5zTW9kZVJhZGlvc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBzdGF0ZTogQ3VycmVudCBETlMgbW9kZS5cbiAgICogQHR5cGUge0Ruc01vZGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmN1cnJlbnREbnNNb2RlXyA9IERuc01vZGUuTk9ORTtcblxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBGaWxsIHRoZSByb290IGRpdiB3aXRoIG5ldyBlbGVtZW50cyByZWZsZWN0aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gKi9cbk5ldFNpbURuc01vZGVDb250cm9sLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZW5kZXJlZE1hcmt1cCA9ICQobWFya3VwKHt9KSk7XG4gIHRoaXMucm9vdERpdl8uaHRtbChyZW5kZXJlZE1hcmt1cCk7XG5cbiAgdGhpcy5kbnNNb2RlUmFkaW9zXyA9IHRoaXMucm9vdERpdl8uZmluZCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCJkbnNfbW9kZVwiXScpO1xuICB0aGlzLmRuc01vZGVSYWRpb3NfLmNoYW5nZSh0aGlzLm9uRG5zTW9kZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gIHRoaXMuc2V0RG5zTW9kZSh0aGlzLmN1cnJlbnREbnNNb2RlXyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGEgbmV3IHJhZGlvIGJ1dHRvbiBiZWluZyBzZWxlY3RlZC5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbURuc01vZGVDb250cm9sLnByb3RvdHlwZS5vbkRuc01vZGVDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV3RG5zTW9kZSA9IHRoaXMuZG5zTW9kZVJhZGlvc18uZmlsdGVyKCc6Y2hlY2tlZCcpLnZhbCgpO1xuICB0aGlzLmRuc01vZGVDaGFuZ2VDYWxsYmFja18obmV3RG5zTW9kZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG5zTW9kZX0gbmV3RG5zTW9kZVxuICovXG5OZXRTaW1EbnNNb2RlQ29udHJvbC5wcm90b3R5cGUuc2V0RG5zTW9kZSA9IGZ1bmN0aW9uIChuZXdEbnNNb2RlKSB7XG4gIHRoaXMuY3VycmVudERuc01vZGVfID0gbmV3RG5zTW9kZTtcbiAgdGhpcy5kbnNNb2RlUmFkaW9zX1xuICAgICAgLmZpbHRlcignW3ZhbHVlPVwiJyArIG5ld0Ruc01vZGUgKyAnXCJdJylcbiAgICAgIC5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xuICB2YXIgRG5zTW9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuRG5zTW9kZTtcbiAgdmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2V4cG9ydHMuRG5zTW9kZX0gbW9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VSYWRpbyhtb2RlLCBsYWJlbCkge1xuICAgIDsgYnVmLnB1c2goJ1xcbiAgICA8ZGl2IGNsYXNzPVwiZG5zX21vZGVfJywgZXNjYXBlKCgxMSwgIG1vZGUgKSksICdcIj5cXG4gICAgICA8aW5wdXQgaWQ9XCJkbnNfbW9kZV8nLCBlc2NhcGUoKDEyLCAgbW9kZSApKSwgJ1wiXFxuICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXFxuICAgICAgICAgICAgICAgICAgIG5hbWU9XCJkbnNfbW9kZVwiXFxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVwiJywgZXNjYXBlKCgxNSwgIG1vZGUgKSksICdcIiAvPlxcbiAgICAgIDxsYWJlbCBmb3I9XCJkbnNfbW9kZV8nLCBlc2NhcGUoKDE2LCAgbW9kZSApKSwgJ1wiPicsIGVzY2FwZSgoMTYsICBsYWJlbCApKSwgJzwvbGFiZWw+XFxuICAgIDwvZGl2PlxcbiAgICAnKTsxODtcbiAgfVxuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cImRucy1tb2RlLWNvbnRyb2xcIj5cXG4gIDxoMT4nLCBlc2NhcGUoKDIyLCAgaTE4bi5kbnNNb2RlKCkgKSksICc8L2gxPlxcbiAgJyk7MjM7IG1ha2VSYWRpbyhEbnNNb2RlLk5PTkUsIGkxOG4uZG5zTW9kZV9OT05FKCkpOyA7IGJ1Zi5wdXNoKCdcXG4gICcpOzI0OyBtYWtlUmFkaW8oRG5zTW9kZS5NQU5VQUwsIGkxOG4uZG5zTW9kZV9NQU5VQUwoKSk7IDsgYnVmLnB1c2goJ1xcbiAgJyk7MjU7IG1ha2VSYWRpbyhEbnNNb2RlLkFVVE9NQVRJQywgaTE4bi5kbnNNb2RlX0FVVE9NQVRJQygpKTsgOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgVUkgYnV0dG9uIHVzZWQgYmVjb21lIHRoZSBjdXJyZW50IEROUyBub2RlIGluIG1hbnVhbCBETlMgbW9kZS5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL05ldFNpbURuc01hbnVhbENvbnRyb2wuaHRtbC5lanMnKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIEROUyBtb2RlIHNlbGVjdG9yXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdlxuICogQHBhcmFtIHtmdW5jdGlvbn0gYmVjb21lRG5zQ2FsbGJhY2tcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTmV0U2ltRG5zTWFudWFsQ29udHJvbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsXG4gICAgYmVjb21lRG5zQ2FsbGJhY2spIHtcbiAgLyoqXG4gICAqIENvbXBvbmVudCByb290LCB3aGljaCB3ZSBmaWxsIHdoZW5ldmVyIHdlIGNhbGwgcmVuZGVyKClcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdERpdl8gPSByb290RGl2O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJlY29tZURuc0NhbGxiYWNrXyA9IGJlY29tZURuc0NhbGxiYWNrO1xuXG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqL1xuTmV0U2ltRG5zTWFudWFsQ29udHJvbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVuZGVyZWRNYXJrdXAgPSAkKG1hcmt1cCh7fSkpO1xuICB0aGlzLnJvb3REaXZfLmh0bWwocmVuZGVyZWRNYXJrdXApO1xuICB0aGlzLnJvb3REaXZfLmZpbmQoJ2lucHV0W3R5cGU9XCJidXR0b25cIl0nKS5jbGljayhcbiAgICAgIHRoaXMub25CZWNvbWVEbnNCdXR0b25DbGlja18uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGJ1dHRvbiBjbGljay5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbURuc01hbnVhbENvbnRyb2wucHJvdG90eXBlLm9uQmVjb21lRG5zQnV0dG9uQ2xpY2tfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJlY29tZURuc0NhbGxiYWNrXygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRG5zTm9kZVxuICovXG5OZXRTaW1EbnNNYW51YWxDb250cm9sLnByb3RvdHlwZS5zZXRJc0Ruc05vZGUgPSBmdW5jdGlvbiAoaXNEbnNOb2RlKSB7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnaW5wdXRbdHlwZT1cImJ1dHRvblwiXScpLmF0dHIoJ2Rpc2FibGVkJywgaXNEbnNOb2RlKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJuZXRzaW1fZG5zX21hbnVhbF9jb250cm9sXCI+XFxuICA8aDE+TWFudWFsIENvbnRyb2w8L2gxPlxcbiAgPGlucHV0IGlkPVwiYmVjb21lX2Ruc19idXR0b25cIiB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJUYWtlIG92ZXIgYXMgRE5TXCIgLz5cXG48L2Rpdj4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBTaW11bGF0ZWQgY2xpZW50IG5vZGUuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLk5vZGVUeXBlO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgTmV0U2ltTm9kZSA9IHJlcXVpcmUoJy4vTmV0U2ltTm9kZScpO1xudmFyIE5ldFNpbVdpcmUgPSByZXF1aXJlKCcuL05ldFNpbVdpcmUnKTtcblxuLyoqXG4gKiBDbGllbnQgbW9kZWwgb2Ygc2ltdWxhdGVkIG5vZGVcbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBjbGllbnQncyB2aWV3IG9mIGEgbm9kZSB0aGF0IGlzIGNvbnRyb2xsZWQgYnkgYSB1c2VyIGNsaWVudCxcbiAqIGVpdGhlciBieSBvdXIgb3duIGNsaWVudCBvciBzb21lYm9keSBlbHNlJ3MuICBJcyBhIE5ldFNpbUVudGl0eSwgbWVhbmluZ1xuICogaXQgd3JhcHMgYSByb3cgaW4gdGhlIG5vZGUgdGFibGUgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgYXJvdW5kIGl0LlxuICpcbiAqIFlvdSBtYXkgYmUgbG9va2luZyBmb3IgTmV0U2ltTG9jYWxDbGllbnROb2RlIGlmIHlvdSdyZSB0cnlpbmcgdG8gbWFuaXB1bGF0ZVxuICogeW91ciBsb2NhbCBjbGllbnQgbm9kZS5cbiAqXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2xpZW50Um93XSAtIExvYmJ5IHJvdyBmb3IgdGhpcyByb3V0ZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1Ob2RlXG4gKi9cbnZhciBOZXRTaW1DbGllbnROb2RlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2hhcmQsIGNsaWVudFJvdykge1xuICBOZXRTaW1Ob2RlLmNhbGwodGhpcywgc2hhcmQsIGNsaWVudFJvdyk7XG59O1xuTmV0U2ltQ2xpZW50Tm9kZS5pbmhlcml0cyhOZXRTaW1Ob2RlKTtcblxuLyoqIEBpbmhlcml0ZG9jICovXG5OZXRTaW1DbGllbnROb2RlLnByb3RvdHlwZS5nZXROb2RlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE5vZGVUeXBlLkNMSUVOVDtcbn07XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuTmV0U2ltQ2xpZW50Tm9kZS5wcm90b3R5cGUuZ2V0U3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0Z29pbmdXaXJlID0gdGhpcy5nZXRPdXRnb2luZ1dpcmUoKTtcbiAgaWYgKCFvdXRnb2luZ1dpcmUpIHtcbiAgICByZXR1cm4gaTE4bi5ub3RDb25uZWN0ZWQoKTtcbiAgfVxuXG4gIC8vIEdldCByZW1vdGUgbm9kZSBmb3IgZGlzcGxheSBuYW1lIC8gaG9zdG5hbWVcbiAgdmFyIGNhY2hlZE5vZGVSb3dzID0gdGhpcy5zaGFyZF8ubm9kZVRhYmxlLnJlYWRBbGwoKTtcbiAgdmFyIHJlbW90ZU5vZGVSb3cgPSBfLmZpbmQoY2FjaGVkTm9kZVJvd3MsIGZ1bmN0aW9uIChub2RlUm93KSB7XG4gICAgcmV0dXJuIG5vZGVSb3cuaWQgPT09IG91dGdvaW5nV2lyZS5yZW1vdGVOb2RlSUQ7XG4gIH0pO1xuXG4gIHZhciByZW1vdGVOb2RlTmFtZSA9IGkxOG4udW5rbm93bk5vZGUoKTtcbiAgaWYgKHJlbW90ZU5vZGVSb3cpIHtcbiAgICByZW1vdGVOb2RlTmFtZSA9IHJlbW90ZU5vZGVSb3cubmFtZTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBjb25uZWN0aW9uIHN0YXRlXG4gIHZhciBtdXR1YWxDb25uZWN0aW9uO1xuICBpZiAocmVtb3RlTm9kZVJvdyAmJiByZW1vdGVOb2RlUm93LnR5cGUgPT09IE5vZGVUeXBlLlJPVVRFUikge1xuICAgIG11dHVhbENvbm5lY3Rpb24gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBjYWNoZWRXaXJlUm93cyA9IHRoaXMuc2hhcmRfLndpcmVUYWJsZS5yZWFkQWxsKCk7XG4gICAgbXV0dWFsQ29ubmVjdGlvbiA9IGNhY2hlZFdpcmVSb3dzLnNvbWUoZnVuY3Rpb24gKHdpcmVSb3cpIHtcbiAgICAgIHJldHVybiB3aXJlUm93LmxvY2FsTm9kZUlEID09PSBvdXRnb2luZ1dpcmUucmVtb3RlTm9kZUlEICYmXG4gICAgICAgICAgd2lyZVJvdy5yZW1vdGVOb2RlSUQgPT09IG91dGdvaW5nV2lyZS5sb2NhbE5vZGVJRDtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChtdXR1YWxDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGkxOG4uY29ubmVjdGVkVG9Ob2RlTmFtZSh7bm9kZU5hbWU6cmVtb3RlTm9kZU5hbWV9KTtcbiAgfVxuICByZXR1cm4gaTE4bi5jb25uZWN0aW5nVG9Ob2RlTmFtZSh7bm9kZU5hbWU6cmVtb3RlTm9kZU5hbWV9KTtcbn07XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuTmV0U2ltQ2xpZW50Tm9kZS5wcm90b3R5cGUuaXNGdWxsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0Z29pbmdXaXJlID0gdGhpcy5nZXRPdXRnb2luZ1dpcmUoKTtcbiAgaWYgKCFvdXRnb2luZ1dpcmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGNhY2hlZFdpcmVSb3dzID0gdGhpcy5zaGFyZF8ud2lyZVRhYmxlLnJlYWRBbGwoKTtcbiAgcmV0dXJuIGNhY2hlZFdpcmVSb3dzLnNvbWUoZnVuY3Rpb24gKHdpcmVSb3cpIHtcbiAgICByZXR1cm4gd2lyZVJvdy5sb2NhbE5vZGVJRCA9PT0gb3V0Z29pbmdXaXJlLnJlbW90ZU5vZGVJRCAmJlxuICAgICAgICB3aXJlUm93LnJlbW90ZU5vZGVJRCA9PT0gb3V0Z29pbmdXaXJlLmxvY2FsTm9kZUlEO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoYXQgYWRkcmVzcyBoYXMgYmVlbiBhc3NpZ25lZCB0byB0aGlzIGNsaWVudCBvbiBpdHMgb3V0Z29pbmdcbiAqIHdpcmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuTmV0U2ltQ2xpZW50Tm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdpcmUgPSB0aGlzLmdldE91dGdvaW5nV2lyZSgpO1xuICBpZiAoIXdpcmUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB3aXJlLmxvY2FsQWRkcmVzcztcbn07XG5cbi8qKlxuICogQmFzZWQgb24gY2FjaGVkIHdpcmUgZGF0YSwgcmV0cmlldmUgdGhpcyBub2RlJ3Mgb3V0Z29pbmcgd2lyZS5cbiAqIEByZXR1cm5zIHtOZXRTaW1XaXJlfG51bGx9IG51bGwgaWYgd2lyZSBkb2VzIG5vdCBleGlzdC5cbiAqL1xuTmV0U2ltQ2xpZW50Tm9kZS5wcm90b3R5cGUuZ2V0T3V0Z29pbmdXaXJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2FjaGVkV2lyZVJvd3MgPSB0aGlzLnNoYXJkXy53aXJlVGFibGUucmVhZEFsbCgpO1xuICB2YXIgb3V0Z29pbmdXaXJlUm93ID0gXy5maW5kKGNhY2hlZFdpcmVSb3dzLCBmdW5jdGlvbiAod2lyZVJvdykge1xuICAgIHJldHVybiB3aXJlUm93LmxvY2FsTm9kZUlEID09PSB0aGlzLmVudGl0eUlEO1xuICB9LCB0aGlzKTtcbiAgaWYgKG91dGdvaW5nV2lyZVJvdykge1xuICAgIHJldHVybiBuZXcgTmV0U2ltV2lyZSh0aGlzLnNoYXJkXywgb3V0Z29pbmdXaXJlUm93KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU3RhdGljIGFzeW5jIHJldHJpZXZhbCBtZXRob2QuICBTZWUgTmV0U2ltRW50aXR5LmdldCgpLlxuICogQHBhcmFtIHshbnVtYmVyfSBub2RlSUQgLSBUaGUgcm93IElEIGZvciB0aGUgZW50aXR5IHlvdSdkIGxpa2UgdG8gZmluZC5cbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHshTm9kZVN0eWxlQ2FsbGJhY2t9IG9uQ29tcGxldGUgLSBNZXRob2QgdGhhdCB3aWxsIGJlIGdpdmVuIHRoZVxuICogICAgICAgIGZvdW5kIGVudGl0eSwgb3IgbnVsbCBpZiBlbnRpdHkgc2VhcmNoIGZhaWxlZC5cbiAqL1xuTmV0U2ltQ2xpZW50Tm9kZS5nZXQgPSBmdW5jdGlvbiAobm9kZUlELCBzaGFyZCwgb25Db21wbGV0ZSkge1xuICBOZXRTaW1FbnRpdHkuZ2V0KE5ldFNpbUNsaWVudE5vZGUsIG5vZGVJRCwgc2hhcmQsIG9uQ29tcGxldGUpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IEEgYmFzZSBjbGFzcyBmb3IgYWxsIHNpbXVsYXRpb24gbm9kZSBlbnRpdGllcy5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgTmV0U2ltV2lyZSA9IHJlcXVpcmUoJy4vTmV0U2ltV2lyZScpO1xuXG4vKipcbiAqIENsaWVudCBtb2RlbCBvZiBzaW11bGF0ZWQgbmV0d29yayBlbnRpdHksIHdoaWNoIGxpdmVzXG4gKiBpbiBhIHNoYXJkIHRhYmxlLlxuICpcbiAqIFdyYXBzIHRoZSBlbnRpdHkgcm93IHdpdGggaGVscGVyIG1ldGhvZHMgZm9yIGV4YW1pbmluZyBhbmQgbWFpbnRhaW5pbmdcbiAqIHRoZSBlbnRpdHkgc3RhdGUgaW4gc2hhcmVkIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0ge09iamVjdH0gW25vZGVSb3ddIEpTT04gcm93IGZyb20gdGFibGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBOZXRTaW1FbnRpdHlcbiAqL1xudmFyIE5ldFNpbU5vZGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaGFyZCwgbm9kZVJvdykge1xuICBub2RlUm93ID0gbm9kZVJvdyAhPT0gdW5kZWZpbmVkID8gbm9kZVJvdyA6IHt9O1xuICBOZXRTaW1FbnRpdHkuY2FsbCh0aGlzLCBzaGFyZCwgbm9kZVJvdyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRpc3BsYXlOYW1lXyA9IG5vZGVSb3cubmFtZTtcbn07XG5OZXRTaW1Ob2RlLmluaGVyaXRzKE5ldFNpbUVudGl0eSk7XG5cbi8qKlxuICogR2V0IHNoYXJlZCB0YWJsZSBmb3Igbm9kZXNcbiAqIEByZXR1cm5zIHtTaGFyZWRUYWJsZX1cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbU5vZGUucHJvdG90eXBlLmdldFRhYmxlPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNoYXJkXy5ub2RlVGFibGU7XG59O1xuXG4vKiogQnVpbGQgdGFibGUgcm93IGZvciB0aGlzIG5vZGUgKi9cbk5ldFNpbU5vZGUucHJvdG90eXBlLmJ1aWxkUm93ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHRoaXMuZ2V0Tm9kZVR5cGUoKSxcbiAgICBuYW1lOiB0aGlzLmdldERpc3BsYXlOYW1lKClcbiAgfTtcbn07XG5cbi8qKlxuICogR2V0IG5vZGUncyBkaXNwbGF5IG5hbWUsIHdoaWNoIGlzIHN0b3JlZCBpbiB0YWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk5ldFNpbU5vZGUucHJvdG90eXBlLmdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZV8gPyB0aGlzLmRpc3BsYXlOYW1lXyA6IGkxOG4uZGVmYXVsdE5vZGVOYW1lKCk7XG59O1xuXG4vKipcbiAqIEdldCBub2RlJ3Mgc2hvcnQgZGlzcGxheSBuYW1lLCB3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgZGlzcGxheSBuYW1lXG4gKiBidXQgdHJ1bmNhdGVkIHRvIHRoZSBmaXJzdCB3b3JkIGlmIGl0J3Mgb3ZlciBhIGNlcnRhaW4gbGVuZ3RoLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTmV0U2ltTm9kZS5wcm90b3R5cGUuZ2V0U2hvcnREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSWYgdGhlIG5hbWUgaXMgbG9uZ2VyIHRoYW4gdGVuIGNoYXJhY3RlcnMgKGxvbmdlciB0aGFuIFwiUm91dGVyIDk5OVwiKVxuICAvLyB0aGVuIG9ubHkgc2hvdyB1cCB0byB0aGUgZmlyc3Qgd2hpdGVzcGFjZS5cbiAgdmFyIHNob3J0TmFtZSA9IHRoaXMuZ2V0RGlzcGxheU5hbWUoKTtcbiAgaWYgKHNob3J0TmFtZS5sZW5ndGggPiAxMCkge1xuICAgIHNob3J0TmFtZSA9IHNob3J0TmFtZS5zcGxpdCgvXFxzLylbMF07XG4gIH1cbiAgcmV0dXJuIHNob3J0TmFtZTtcbn07XG5cbi8qKlxuICogR2V0IG5vZGUncyBob3N0bmFtZSwgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGl0cyBkaXNwbGF5IG5hbWUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5OZXRTaW1Ob2RlLnByb3RvdHlwZS5nZXRIb3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RyaXAgZXZlcnl0aGluZyB0aGF0J3Mgbm90IGEgd29yZC1jaGFyYWN0ZXIgb3IgYSBkaWdpdCBmcm9tIHRoZSBkaXNwbGF5XG4gIC8vIG5hbWUsIHRoZW4gYXBwZW5kIHRoZSBub2RlIElEIHNvIHRoYXQgaG9zdG5hbWVzIGFyZSBtb3JlIGxpa2VseSB0b1xuICAvLyBiZSB1bmlxdWUuXG4gIHJldHVybiB0aGlzLmdldFNob3J0RGlzcGxheU5hbWUoKS5yZXBsYWNlKC9bXlxcd1xcZF0vZywgJycpLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgdGhpcy5lbnRpdHlJRDtcbn07XG5cbi8qKlxuICogR2V0IG5vZGUncyB0eXBlLlxuICogQHJldHVybnMge05vZGVUeXBlfVxuICovXG5OZXRTaW1Ob2RlLnByb3RvdHlwZS5nZXROb2RlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdnZXROb2RlVHlwZSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG4vKipcbiAqIEdldCBsb2NhbGl6ZWQgZGVzY3JpcHRpb24gb2Ygbm9kZSBzdGF0dXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5OZXRTaW1Ob2RlLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignZ2V0U3RhdHVzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBub2RlIGNhbiBhY2NlcHQgYW55IG1vcmUgY29ubmVjdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5OZXRTaW1Ob2RlLnByb3RvdHlwZS5pc0Z1bGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignaXNGdWxsIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbi8qKlxuICogRXN0YWJsaXNoIGEgY29ubmVjdGlvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW5vdGhlciBub2RlLFxuICogYnkgY3JlYXRpbmcgYSB3aXJlIGJldHdlZW4gdGhlbSwgYW5kIHZlcmlmeWluZyB0aGF0IHRoZSByZW1vdGUgbm9kZVxuICogY2FuIGFjY2VwdCB0aGUgY29ubmVjdGlvbi5cbiAqIFdoZW4gZmluaXNoZWQsIGNhbGxzIG9uQ29tcGxldGUoe3RoZSBuZXcgd2lyZX0pXG4gKiBPbiBmYWlsdXJlLCBjYWxscyBvbkNvbXBsZXRlKG51bGwpXG4gKiBAcGFyYW0geyFOZXRTaW1Ob2RlfSBvdGhlck5vZGVcbiAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IFtvbkNvbXBsZXRlXVxuICovXG5OZXRTaW1Ob2RlLnByb3RvdHlwZS5jb25uZWN0VG9Ob2RlID0gZnVuY3Rpb24gKG90aGVyTm9kZSwgb25Db21wbGV0ZSkge1xuICBvbkNvbXBsZXRlID0gb25Db21wbGV0ZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIE5ldFNpbVdpcmUuY3JlYXRlKHRoaXMuc2hhcmRfLFxuICAgICAgdGhpcy5tYWtlV2lyZVJvd0ZvckNvbm5lY3RpbmdUbyhvdGhlck5vZGUpLFxuICAgICAgZnVuY3Rpb24gKGVyciwgd2lyZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgb25Db21wbGV0ZShlcnIsIG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyTm9kZS5hY2NlcHRDb25uZWN0aW9uKHNlbGYsIGZ1bmN0aW9uIChlcnIsIGlzQWNjZXB0ZWQpIHtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFpc0FjY2VwdGVkKSB7XG4gICAgICAgICAgICB3aXJlLmRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlKG5ldyBFcnJvcignQ29ubmVjdGlvbiByZWplY3RlZDogJyArIGVyci5tZXNzYWdlKSwgbnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbkNvbXBsZXRlKG51bGwsIHdpcmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXBwcm9wcmlhdGUgaW5pdGlhbCB3aXJlIHJvdyBmb3IgY29ubmVjdGluZyB0byB0aGUgZ2l2ZW4gbm9kZS5cbiAqIEBwYXJhbSB7IU5ldFNpbU5vZGV9IG90aGVyTm9kZVxuICogQHJldHVybnMge1dpcmVSb3d9XG4gKi9cbk5ldFNpbU5vZGUucHJvdG90eXBlLm1ha2VXaXJlUm93Rm9yQ29ubmVjdGluZ1RvID0gZnVuY3Rpb24gKG90aGVyTm9kZSkge1xuICByZXR1cm4ge1xuICAgIGxvY2FsTm9kZUlEOiB0aGlzLmVudGl0eUlELFxuICAgIHJlbW90ZU5vZGVJRDogb3RoZXJOb2RlLmVudGl0eUlEXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFub3RoZXIgbm9kZSBlc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gdGhpcyBvbmUsIGdpdmluZyB0aGlzXG4gKiBub2RlIGEgY2hhbmNlIHRvIHJlamVjdCB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7IU5ldFNpbU5vZGV9IG90aGVyTm9kZSBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gdGhpcyBvbmVcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIHJlc3BvbnNlIG1ldGhvZCAtIHNob3VsZCBjYWxsIHdpdGggVFJVRVxuICogICAgICAgIGlmIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCwgRkFMU0UgaWYgY29ubmVjdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuTmV0U2ltTm9kZS5wcm90b3R5cGUuYWNjZXB0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChvdGhlck5vZGUsIG9uQ29tcGxldGUpIHtcbiAgb25Db21wbGV0ZShudWxsLCB0cnVlKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBTaW11bGF0aW9uIEVudGl0eTogQSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIG5vZGVzIGFuZCByZWxhdGVkXG4gKiAgICAgICAgICAgbWV0YWRhdGEuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIE5ldFNpbUVudGl0eSA9IHJlcXVpcmUoJy4vTmV0U2ltRW50aXR5Jyk7XG52YXIgQXJndW1lbnRVdGlscyA9IHJlcXVpcmUoJy4vQXJndW1lbnRVdGlscycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdpcmVSb3dcbiAqIEBwcm9wZXJ0eSB7IW51bWJlcn0gbG9jYWxOb2RlSURcbiAqIEBwcm9wZXJ0eSB7IW51bWJlcn0gcmVtb3RlTm9kZUlEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbG9jYWxBZGRyZXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVtb3RlQWRkcmVzc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGxvY2FsSG9zdG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZW1vdGVIb3N0bmFtZVxuICovXG5cbi8qKlxuICogTG9jYWwgY29udHJvbGxlciBmb3IgYSBzaW11bGF0ZWQgY29ubmVjdGlvbiBiZXR3ZWVuIG5vZGVzLFxuICogd2hpY2ggaXMgc3RvcmVkIGluIHRoZSB3aXJlIHRhYmxlIG9uIHRoZSBzaGFyZC4gIFRoZSBjb250cm9sbGVyIGNhblxuICogYmUgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgSlNPTiByb3cgZnJvbSB0aGUgdGFibGUsIGVmZmVjdGl2ZWx5IHdyYXBwaW5nIHRoYXRcbiAqIGRhdGEgaW4gaGVscGZ1bCBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZCAtIFRoZSBzaGFyZCB3aGVyZSB0aGlzIHdpcmUgbGl2ZXMuXG4gKiBAcGFyYW0ge1dpcmVSb3d9IFt3aXJlUm93XSAtIEEgcm93IG91dCBvZiB0aGUgX3dpcmUgdGFibGUgb24gdGhlIHNoYXJkLlxuICogICAgICAgIElmIHByb3ZpZGVkLCB3aWxsIGluaXRpYWxpemUgdGhpcyB3aXJlIHdpdGggdGhlIGdpdmVuIGRhdGEuICBJZiBub3QsXG4gKiAgICAgICAgdGhpcyB3aXJlIHdpbGwgaW5pdGlhbGl6ZSB0byBkZWZhdWx0IHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbUVudGl0eVxuICovXG52YXIgTmV0U2ltV2lyZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNoYXJkLCB3aXJlUm93KSB7XG4gIHdpcmVSb3cgPSB3aXJlUm93ICE9PSB1bmRlZmluZWQgPyB3aXJlUm93IDoge307XG4gIE5ldFNpbUVudGl0eS5jYWxsKHRoaXMsIHNoYXJkLCB3aXJlUm93KTtcblxuICAvKipcbiAgICogQ29ubmVjdGVkIG5vZGUgcm93IElEcyB3aXRoaW4gdGhlIF9sb2JieSB0YWJsZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sb2NhbE5vZGVJRCA9IHdpcmVSb3cubG9jYWxOb2RlSUQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnJlbW90ZU5vZGVJRCA9IHdpcmVSb3cucmVtb3RlTm9kZUlEO1xuXG4gIC8qKlxuICAgKiBBc3NpZ25lZCBsb2NhbCBhZGRyZXNzZXMgZm9yIHRoZSBlbmRzIG9mIHRoaXMgd2lyZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMubG9jYWxBZGRyZXNzID0gd2lyZVJvdy5sb2NhbEFkZHJlc3M7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB3aXJlUm93LnJlbW90ZUFkZHJlc3M7XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgaG9zdG5hbWVzIGZvciB0aGUgZW5kcyBvZiB0aGlzIHdpcmUuXG4gICAqIEdlbmVyYWxseSwgZWFjaCBlbmRwb2ludCBzaG91bGQgc2V0IGl0cyBvd24gaG9zdG5hbWUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmxvY2FsSG9zdG5hbWUgPSB3aXJlUm93LmxvY2FsSG9zdG5hbWU7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLnJlbW90ZUhvc3RuYW1lID0gd2lyZVJvdy5yZW1vdGVIb3N0bmFtZTtcbn07XG5OZXRTaW1XaXJlLmluaGVyaXRzKE5ldFNpbUVudGl0eSk7XG5cbi8qKlxuICogU3RhdGljIGFzeW5jIGNyZWF0aW9uIG1ldGhvZC4gIFNlZSBOZXRTaW1FbnRpdHkuY3JlYXRlKCkuXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmRcbiAqIEBwYXJhbSB7IVdpcmVSb3d9IGluaXRpYWxSb3dcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIC0gTWV0aG9kIHRoYXQgd2lsbCBiZSBnaXZlbiB0aGVcbiAqICAgICAgICBjcmVhdGVkIGVudGl0eSwgb3IgbnVsbCBpZiBlbnRpdHkgY3JlYXRpb24gZmFpbGVkLlxuICovXG5OZXRTaW1XaXJlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzaGFyZCwgaW5pdGlhbFJvdywgb25Db21wbGV0ZSkge1xuICBBcmd1bWVudFV0aWxzLnZhbGlkYXRlUmVxdWlyZWQoaW5pdGlhbFJvdywgXCJpbml0aWFsUm93XCIpO1xuICBBcmd1bWVudFV0aWxzLnZhbGlkYXRlUmVxdWlyZWQoaW5pdGlhbFJvdy5sb2NhbE5vZGVJRCwgXCJsb2NhbE5vZGVJRFwiLFxuICAgICAgQXJndW1lbnRVdGlscy5pc1Bvc2l0aXZlTm9uaW5maW5pdGVOdW1iZXIpO1xuICBBcmd1bWVudFV0aWxzLnZhbGlkYXRlUmVxdWlyZWQoaW5pdGlhbFJvdy5yZW1vdGVOb2RlSUQsIFwicmVtb3RlTm9kZUlEXCIsXG4gICAgICBBcmd1bWVudFV0aWxzLmlzUG9zaXRpdmVOb25pbmZpbml0ZU51bWJlcik7XG4gIHZhciBlbnRpdHkgPSBuZXcgTmV0U2ltV2lyZShzaGFyZCwgaW5pdGlhbFJvdyk7XG4gIGVudGl0eS5nZXRUYWJsZSgpLmNyZWF0ZShlbnRpdHkuYnVpbGRSb3coKSwgZnVuY3Rpb24gKGVyciwgcm93KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb25Db21wbGV0ZShlcnIsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbkNvbXBsZXRlKG51bGwsIG5ldyBOZXRTaW1XaXJlKHNoYXJkLCByb3cpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IGdldHMgdGhlIHdpcmVzIHRhYmxlIGZvciB0aGUgY29uZmlndXJlZCBzaGFyZC5cbiAqIEByZXR1cm5zIHtOZXRTaW1UYWJsZX1cbiAqL1xuTmV0U2ltV2lyZS5wcm90b3R5cGUuZ2V0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNoYXJkXy53aXJlVGFibGU7XG59O1xuXG4vKipcbiAqIEJ1aWxkIG93biByb3cgZm9yIHRoZSB3aXJlIHRhYmxlXG4gKiBAcmV0dXJucyB7V2lyZVJvd31cbiAqL1xuTmV0U2ltV2lyZS5wcm90b3R5cGUuYnVpbGRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbG9jYWxOb2RlSUQ6IHRoaXMubG9jYWxOb2RlSUQsXG4gICAgcmVtb3RlTm9kZUlEOiB0aGlzLnJlbW90ZU5vZGVJRCxcbiAgICBsb2NhbEFkZHJlc3M6IHRoaXMubG9jYWxBZGRyZXNzLFxuICAgIHJlbW90ZUFkZHJlc3M6IHRoaXMucmVtb3RlQWRkcmVzcyxcbiAgICBsb2NhbEhvc3RuYW1lOiB0aGlzLmxvY2FsSG9zdG5hbWUsXG4gICAgcmVtb3RlSG9zdG5hbWU6IHRoaXMucmVtb3RlSG9zdG5hbWVcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNZXNzYWdlUm93fSBtZXNzYWdlUm93XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyB0cmF2ZWxsaW5nIGJldHdlZW4gdGhlIG5vZGVzXG4gKiAgICAgICAgICB0aGF0IHRoaXMgd2lyZSBjb25uZWN0cywgaW4gdGhlIHdpcmUncyBkaXJlY3Rpb24uXG4gKi9cbk5ldFNpbVdpcmUucHJvdG90eXBlLmlzTWVzc2FnZVJvd09uRHVwbGV4V2lyZSA9IGZ1bmN0aW9uIChtZXNzYWdlUm93KSB7XG4gIHJldHVybiB0aGlzLmxvY2FsTm9kZUlEID09PSBtZXNzYWdlUm93LmZyb21Ob2RlSUQgJiZcbiAgICAgIHRoaXMucmVtb3RlTm9kZUlEID09PSBtZXNzYWdlUm93LnRvTm9kZUlEO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01lc3NhZ2VSb3d9IG1lc3NhZ2VSb3dcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIHRyYXZlbGxpbmcgYmV0d2VlbiB0aGUgbm9kZXNcbiAqICAgICAgICAgIHRoYXQgdGhpcyB3aXJlIGNvbm5lY3RzLCBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICovXG5OZXRTaW1XaXJlLnByb3RvdHlwZS5pc01lc3NhZ2VSb3dPblNpbXBsZXhXaXJlID0gZnVuY3Rpb24gKG1lc3NhZ2VSb3cpIHtcbiAgdmFyIG9uV2lyZSA9IHRoaXMuaXNNZXNzYWdlUm93T25EdXBsZXhXaXJlKG1lc3NhZ2VSb3cpO1xuICB2YXIgb25SZXZlcnNlV2lyZSA9IHRoaXMubG9jYWxOb2RlSUQgPT09IG1lc3NhZ2VSb3cudG9Ob2RlSUQgJiZcbiAgICAgIHRoaXMucmVtb3RlTm9kZUlEID09PSBtZXNzYWdlUm93LmZyb21Ob2RlSUQ7XG4gIHJldHVybiBvbldpcmUgfHwgb25SZXZlcnNlV2lyZTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBiYXNlIGNsYXNzIGZvciBhbGwgc2ltdWxhdGlvbiBlbnRpdGllcy5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xpZW50IG1vZGVsIG9mIHNpbXVsYXRlZCBuZXR3b3JrIGVudGl0eSwgd2hpY2ggbGl2ZXMgaW4gYSBzaGFyZCB0YWJsZS5cbiAqXG4gKiBXcmFwcyB0aGUgZW50aXR5IHJvdyB3aXRoIGhlbHBlciBtZXRob2RzIGZvciBleGFtaW5pbmcgYW5kIG1haW50YWluaW5nXG4gKiB0aGUgZW50aXR5IHN0YXRlIGluIHNoYXJlZCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7IU5ldFNpbVNoYXJkfSBzaGFyZFxuICogQHBhcmFtIHtPYmplY3R9IFtlbnRpdHlSb3ddIEpTT04gcm93IGZyb20gdGFibGUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbUVudGl0eSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNoYXJkLCBlbnRpdHlSb3cpIHtcbiAgaWYgKGVudGl0eVJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW50aXR5Um93ID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbVNoYXJkfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLnNoYXJkXyA9IHNoYXJkO1xuXG4gIC8qKlxuICAgKiBOb2RlJ3Mgcm93IElEIHdpdGhpbiB0aGUgX2xvYmJ5IHRhYmxlLiAgVW5pcXVlIHdpdGhpbiBpbnN0YW5jZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZW50aXR5SUQgPSBlbnRpdHlSb3cuaWQ7XG5cbiAgLyoqXG4gICAqIE5vZGUncyBVVUlEIGFzc2lnbmVkIHdoZW4gaXQgd2FzIGluaXRpYWxseSBpbnNlcnRlZCBpbnRvIHRoZSB0YWJsZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMudXVpZCA9IGVudGl0eVJvdy51dWlkO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgYXN5bmMgY3JlYXRpb24gbWV0aG9kLiAgQ3JlYXRlcyBhIG5ldyBlbnRpdHkgb24gdGhlIGdpdmVuIHNoYXJkLFxuICogYW5kIHRoZW4gY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggYSBsb2NhbCBjb250cm9sbGVyIGZvciB0aGUgbmV3IGVudGl0eS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBFbnRpdHlUeXBlIC0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgZW50aXR5IHR5cGUgeW91IHdhbnRcbiAqICAgICAgICB0byBjcmVhdGUuXG4gKiBAcGFyYW0geyFOZXRTaW1TaGFyZH0gc2hhcmRcbiAqIEBwYXJhbSB7IU5vZGVTdHlsZUNhbGxiYWNrfSBvbkNvbXBsZXRlIC0gTWV0aG9kIHRoYXQgd2lsbCBiZSBnaXZlbiB0aGVcbiAqICAgICAgICBjcmVhdGVkIGVudGl0eSwgb3IgbnVsbCBpZiBlbnRpdHkgY3JlYXRpb24gZmFpbGVkLlxuICovXG5OZXRTaW1FbnRpdHkuY3JlYXRlID0gZnVuY3Rpb24gKEVudGl0eVR5cGUsIHNoYXJkLCBvbkNvbXBsZXRlKSB7XG4gIHZhciBlbnRpdHkgPSBuZXcgRW50aXR5VHlwZShzaGFyZCk7XG4gIGVudGl0eS5nZXRUYWJsZSgpLmNyZWF0ZShlbnRpdHkuYnVpbGRSb3coKSwgZnVuY3Rpb24gKGVyciwgcm93KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgb25Db21wbGV0ZShlcnIsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkNvbXBsZXRlKG51bGwsIG5ldyBFbnRpdHlUeXBlKHNoYXJkLCByb3cpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgYXN5bmMgcmV0cmlldmFsIG1ldGhvZC4gIFNlYXJjaGVzIGZvciBhIG5ldyBlbnRpdHkgb24gdGhlIGdpdmVuXG4gKiBzaGFyZCwgYW5kIHRoZW4gY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggYSBsb2NhbCBjb250cm9sbGVyIGZvciB0aGVcbiAqIGZvdW5kIGVudGl0eS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBFbnRpdHlUeXBlIC0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgZW50aXR5IHR5cGUgeW91IHdhbnRcbiAqICAgICAgICB0byBmaW5kLlxuICogQHBhcmFtIHshbnVtYmVyfSBlbnRpdHlJRCAtIFRoZSByb3cgSUQgZm9yIHRoZSBlbnRpdHkgeW91J2QgbGlrZSB0byBmaW5kLlxuICogQHBhcmFtIHshTmV0U2ltU2hhcmR9IHNoYXJkXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZSAtIE1ldGhvZCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdGhlXG4gKiAgICAgICAgZm91bmQgZW50aXR5LCBvciBudWxsIGlmIGVudGl0eSBzZWFyY2ggZmFpbGVkLlxuICovXG5OZXRTaW1FbnRpdHkuZ2V0ID0gZnVuY3Rpb24gKEVudGl0eVR5cGUsIGVudGl0eUlELCBzaGFyZCwgb25Db21wbGV0ZSkge1xuICB2YXIgZW50aXR5ID0gbmV3IEVudGl0eVR5cGUoc2hhcmQpO1xuICBlbnRpdHkuZ2V0VGFibGUoKS5yZWFkKGVudGl0eUlELCBmdW5jdGlvbiAoZXJyLCByb3cpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBvbkNvbXBsZXRlKGVyciwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQ29tcGxldGUoZXJyLCBuZXcgRW50aXR5VHlwZShzaGFyZCwgcm93KSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUHVzaCBlbnRpdHkgc3RhdGUgaW50byByZW1vdGUgc3RvcmFnZS5cbiAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IFtvbkNvbXBsZXRlXSAtIE9wdGlvbmFsIGNvbXBsZXRpb24gY2FsbGJhY2suXG4gKi9cbk5ldFNpbUVudGl0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgb25Db21wbGV0ZSA9IG9uQ29tcGxldGUgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgdGhpcy5nZXRUYWJsZSgpLnVwZGF0ZSh0aGlzLmVudGl0eUlELCB0aGlzLmJ1aWxkUm93KCksIG9uQ29tcGxldGUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZW50aXR5IGZyb20gcmVtb3RlIHN0b3JhZ2UuXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBbb25Db21wbGV0ZV0gLSBPcHRpb25hbCBjb21wbGV0aW9uIGNhbGxiYWNrXG4gKi9cbk5ldFNpbUVudGl0eS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIG9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHRoaXMuZ2V0VGFibGUoKS5kZWxldGUodGhpcy5lbnRpdHlJRCwgb25Db21wbGV0ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBlbnRpdHkgZnJvbSByZW1vdGUgc3RvcmFnZSwgdXNpbmcgYSBzeW5jaHJvbm91cyBjYWxsLlxuICogRm9yIHVzZSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlOyBvdGhlcndpc2UsIGFzeW5jIHZlcnNpb25cbiAqIGlzIHByZWZlcnJlZC5cbiAqIEByZXR1cm5zIHtFcnJvcnxudWxsfSBlcnJvciBpZiBlbnRpdHkgZGVsZXRlIGZhaWxzXG4gKi9cbk5ldFNpbUVudGl0eS5wcm90b3R5cGUuc3luY2hyb25vdXNEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRUYWJsZSgpLnN5bmNocm9ub3VzRGVsZXRlKHRoaXMuZW50aXR5SUQpO1xufTtcblxuLyoqIEdldCBzdG9yYWdlIHRhYmxlIGZvciB0aGlzIGVudGl0eSB0eXBlLiAqL1xuTmV0U2ltRW50aXR5LnByb3RvdHlwZS5nZXRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGEgY2hpbGQgY2xhc3MuXG4gIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGdldFRhYmxlIGlzIG5vdCBpbXBsZW1lbnRlZC4nKTtcbn07XG5cbi8qKiBDb25zdHJ1Y3QgdGFibGUgcm93IGZvciB0aGlzIGVudGl0eS4gKi9cbk5ldFNpbUVudGl0eS5wcm90b3R5cGUuYnVpbGRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7fTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgYWxsIHByb3ZpZGVkIGVudGl0aWVzIChmcm9tIHJlbW90ZSBzdG9yYWdlKSBhc3luY2hyb25vdXNseSwgYW5kXG4gKiBjYWxscyBvbkNvbXBsZXRlIHdoZW4gYWxsIGVudGl0aWVzIGhhdmUgYmVlbiBkZXN0cm95ZWQgYW5kL29yIGFuIGVycm9yIG9jY3Vycy5cbiAqIEBwYXJhbSB7TmV0U2ltRW50aXR5W119IGVudGl0aWVzXG4gKiBAcGFyYW0geyFOb2RlU3R5bGVDYWxsYmFja30gb25Db21wbGV0ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIGFsbCBwYXNzZWQgZW50aXRpZXMgZG8gbm90IGJlbG9uZyB0byB0aGUgc2FtZSB0YWJsZS5cbiAqL1xuTmV0U2ltRW50aXR5LmRlc3Ryb3lFbnRpdGllcyA9IGZ1bmN0aW9uIChlbnRpdGllcywgb25Db21wbGV0ZSkge1xuICBpZiAoZW50aXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgb25Db21wbGV0ZShudWxsLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFibGUgPSBlbnRpdGllc1swXS5nZXRUYWJsZSgpO1xuICB2YXIgZW50aXR5SURzID0gZW50aXRpZXMubWFwKGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICBpZiAoZW50aXR5LmdldFRhYmxlKCkgIT09IHRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXN0cm95RW50aXRpZXMgcmVxdWlyZXMgYWxsIGVudGl0aWVzIHRvIGJlIGluIHRoZSBzYW1lIHRhYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZW50aXR5LmVudGl0eUlEO1xuICB9KTtcblxuICB0YWJsZS5kZWxldGVNYW55KGVudGl0eUlEcywgb25Db21wbGV0ZSk7XG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgVUkgc2xpZGVyIHVzZWQgdG8gY2hhbmdlIHRoZSBsb2NhbCBkZXZpY2UncyBjaHVuayBzaXplLCB3aGljaFxuICogICAgICAgICAgIGlzIHVzZWQgd2hlbiBpbnRlcnByZXRpbmcgYmluYXJ5IHRvIG90aGVyIGZvcm1hdHMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltU2xpZGVyID0gcmVxdWlyZSgnLi9OZXRTaW1TbGlkZXInKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIGNodW5rIHNpemUgc2xpZGVyL3NlbGVjdG9yXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2h1bmtTaXplQ2hhbmdlQ2FsbGJhY2tcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1Z21lbnRzIE5ldFNpbVNsaWRlclxuICovXG52YXIgTmV0U2ltQ2h1bmtTaXplQ29udHJvbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsXG4gICAgY2h1bmtTaXplQ2hhbmdlQ2FsbGJhY2spIHtcbiAgTmV0U2ltU2xpZGVyLmNhbGwodGhpcywgcm9vdERpdiwge1xuICAgIG9uQ2hhbmdlOiBjaHVua1NpemVDaGFuZ2VDYWxsYmFjayxcbiAgICBtaW46IDEsXG4gICAgbWF4OiAzMlxuICB9KTtcblxuICAvLyBBdXRvLXJlbmRlciwgdW5saWtlIG91ciBwYXJlbnQgY2xhc3NcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5OZXRTaW1DaHVua1NpemVDb250cm9sLmluaGVyaXRzKE5ldFNpbVNsaWRlcik7XG5cbi8qKlxuICogQ29udmVydHMgYW4gZXh0ZXJuYWwtZmFjaW5nIG51bWVyaWMgdmFsdWUgaW50byBhIGxvY2FsaXplZCBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gbnVtZXJpYyB2YWx1ZSBvZiB0aGUgY29udHJvbFxuICogQHJldHVybnMge3N0cmluZ30gLSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltQ2h1bmtTaXplQ29udHJvbC5wcm90b3R5cGUudmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gaTE4bi5udW1CaXRzUGVyQ2h1bmsoe1xuICAgIG51bUJpdHM6IHZhbFxuICB9KTtcbn07XG5cbi8qKlxuICogQWx0ZXJuYXRlIGxhYmVsIGNvbnZlcnRlciwgdXNlZCBmb3Igc2xpZGVyIGVuZCBsYWJlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gbnVtZXJpYyB2YWx1ZSBvZiB0aGUgY29udHJvbFxuICogQHJldHVybnMge3N0cmluZ30gLSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltQ2h1bmtTaXplQ29udHJvbC5wcm90b3R5cGUudmFsdWVUb1Nob3J0TGFiZWwgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBVSSBzbGlkZXIgdXNlZCB0byBjaGFuZ2UgdGhlIGxvY2FsIGRldmljZSdzIGJpdHJhdGUuXG4gKiAgICAgICAgICAgRGlmZmVycyBmcm9tIHRoZSBwdWxzZSByYXRlIHNsaWRlciBpbiBzY2FsZSBhbmQgdW5pdHMuXG4gKiBAc2VlIE5ldFNpbVB1bHNlUmF0ZUNvbnRyb2xcbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFV0aWxzIHJlcXVpcmVkIG9ubHkgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cygpXG5yZXF1aXJlKCcuLi91dGlscycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIE5ldFNpbVNsaWRlciA9IHJlcXVpcmUoJy4vTmV0U2ltU2xpZGVyJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBwYWNrZXQgc2l6ZSBzbGlkZXIvc2VsZWN0b3JcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbFZhbHVlIC0gaW4gYml0cyBwZXIgc2Vjb25kXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzbGlkZXJDaGFuZ2VDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXRTaW1CaXRSYXRlQ29udHJvbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsIGluaXRpYWxWYWx1ZSxcbiAgICBzbGlkZXJDaGFuZ2VDYWxsYmFjaykge1xuICBOZXRTaW1TbGlkZXIuY2FsbCh0aGlzLCByb290RGl2LCB7XG4gICAgb25DaGFuZ2U6IHNsaWRlckNoYW5nZUNhbGxiYWNrLFxuICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgbWluOiAxLFxuICAgIG1heDogMjAsXG4gICAgdXBwZXJCb3VuZEluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIC8vIEF1dG8tcmVuZGVyLCB1bmxpa2Ugb3VyIGJhc2UgY2xhc3NcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5OZXRTaW1CaXRSYXRlQ29udHJvbC5pbmhlcml0cyhOZXRTaW1TbGlkZXIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtZXJpYyByYXRlIHZhbHVlIChpbiBiaXRzIHBlcnMgc2Vjb25kKSBpbnRvIGFcbiAqIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhhdCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBudW1lcmljIHZhbHVlIG9mIHRoZSBjb250cm9sXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdmFsdWVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1CaXRSYXRlQ29udHJvbC5wcm90b3R5cGUudmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gTmV0U2ltVXRpbHMuYml0cmF0ZVRvTG9jYWxpemVkUm91bmRlZEJpdHJhdGUodmFsKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb21wb25lbnQsIGEgbG9nIHBhbmVsICh1c2VkIGFzIFwiU2VudCBCaXRzXCIgYW5kIFwiUmVjZWl2ZWQgQml0c1wiKVxuICogICAgICAgICAgIHRoYXQgaXMgdXNlZCBpbiB0aGUgc2luZ2xlLWJpdC1zZW5kaW5nIGNvbmZpZ3VyYXRpb25zIG9mIHRoZSBzaW11bGF0b3IuXG4gKlxuICogQHNlZSBJTmV0U2ltTG9nUGFuZWwgZm9yIHRoZSBpbnRlcmZhY2UgaW1wbGVtZW50ZWQgaGVyZS5cbiAqIEBzZWUgTmV0U2ltTG9nUGFuZWwgZm9yIHRoZSBjb21wb25lbnQgdXNlZCBpbiBwYWNrZXQtc2VuZGluZyBtb2RlLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vdXRpbHMnKTsgLy8gRm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cygpXG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1CaXRMb2dQYW5lbC5odG1sLmVqcycpO1xudmFyIE5ldFNpbVBhbmVsID0gcmVxdWlyZSgnLi9OZXRTaW1QYW5lbCcpO1xudmFyIE5ldFNpbUVuY29kaW5nQ29udHJvbCA9IHJlcXVpcmUoJy4vTmV0U2ltRW5jb2RpbmdDb250cm9sJyk7XG52YXIgTmV0U2ltR2xvYmFscyA9IHJlcXVpcmUoJy4vTmV0U2ltR2xvYmFscycpO1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi9OZXRTaW1Mb2dnZXInKS5nZXRTaW5nbGV0b24oKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIGJpdC1sb2csIHdoaWNoIHJlY2VpdmVzIGJpdHMgb25lIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9nVGl0bGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNNaW5pbWl6ZWRdIGRlZmF1bHRzIHRvIEZBTFNFXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dSZWFkV2lyZUJ1dHRvbl0gZGVmYXVsdHMgdG8gRkFMU0VcbiAqIEBwYXJhbSB7TmV0U2ltfSBvcHRpb25zLm5ldHNpbVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgTmV0U2ltUGFuZWxcbiAqIEBpbXBsZW1lbnRzIElOZXRTaW1Mb2dQYW5lbFxuICovXG52YXIgTmV0U2ltQml0TG9nUGFuZWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBiaW5hcnkgY29udGVudHMgb2YgdGhlIGxvZyBwYW5lbFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iaW5hcnlfID0gJyc7XG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBlbmNvZGluZyAoZGlzcGxheSkgc2V0dGluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZW5jb2RpbmdzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGNodW5rIHNpemUgKGJ5dGVzaXplKSBmb3IgaW50ZXJwcmV0aW5nIGJpbmFyeSBpbiB0aGUgbG9nLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jaHVua1NpemVfID0gODtcblxuICAvKipcbiAgICogTG9jYWxpemVkIHBhbmVsIHRpdGxlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmxvZ1RpdGxlXyA9IG9wdGlvbnMubG9nVGl0bGU7XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIE5ldFNpbSBjb250cm9sbGVyIGZvciByZWFkaW5nIGJpdHMgYW5kXG4gICAqIHRyaWdnZXJpbmcgYW5pbWF0aW9ucy5cbiAgICogQHR5cGUge05ldFNpbX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubmV0c2ltXyA9IG9wdGlvbnMubmV0c2ltO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgbG9nIHNob3VsZCBoYXZlIGEgXCJSZWFkIFdpcmVcIiBidXR0b24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zaG93UmVhZFdpcmVCdXR0b25fID0gb3B0aW9ucy5zaG93UmVhZFdpcmVCdXR0b247XG5cbiAgLyoqXG4gICAqIEhvdyB0YWxsIHRoZSBvdmVyYWxsIHBhbmVsIHNob3VsZCBiZSB3aGVuIGl0J3Mgb3BlbiAoaW4gcGl4ZWxzKS5cbiAgICogU2V0IGJ5IGEgZHluYW1pYyByZXNpemUgc3lzdGVtLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5vcGVuSGVpZ2h0XyA9IDA7XG5cbiAgLy8gSW5pdGlhbCByZW5kZXJcbiAgTmV0U2ltUGFuZWwuY2FsbCh0aGlzLCByb290RGl2LCB7XG4gICAgY2xhc3NOYW1lOiAnbmV0c2ltLWxvZy1wYW5lbCcsXG4gICAgcGFuZWxUaXRsZTogb3B0aW9ucy5sb2dUaXRsZSxcbiAgICBiZWdpbk1pbmltaXplZDogb3B0aW9ucy5pc01pbmltaXplZFxuICB9KTtcbn07XG5OZXRTaW1CaXRMb2dQYW5lbC5pbmhlcml0cyhOZXRTaW1QYW5lbCk7XG5cbk5ldFNpbUJpdExvZ1BhbmVsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENyZWF0ZSBib2lsZXJwbGF0ZSBwYW5lbCBtYXJrdXBcbiAgTmV0U2ltQml0TG9nUGFuZWwuc3VwZXJQcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gQWRkIG91ciBvd24gY29udGVudCBtYXJrdXBcbiAgdmFyIG5ld01hcmt1cCA9ICQobWFya3VwKHtcbiAgICBiaW5hcnk6IHRoaXMuYmluYXJ5XyxcbiAgICBlbmFibGVkRW5jb2RpbmdzOiB0aGlzLmVuY29kaW5nc18sXG4gICAgY2h1bmtTaXplOiB0aGlzLmNodW5rU2l6ZV8sXG4gICAgc2hvd1JlYWRXaXJlQnV0dG9uOiB0aGlzLnNob3dSZWFkV2lyZUJ1dHRvbl9cbiAgfSkpO1xuICB0aGlzLmdldEJvZHkoKS5odG1sKG5ld01hcmt1cCk7XG4gIE5ldFNpbUVuY29kaW5nQ29udHJvbC5oaWRlUm93c0J5RW5jb2RpbmcodGhpcy5nZXRCb2R5KCksIHRoaXMuZW5jb2RpbmdzXyk7XG5cblxuICB0aGlzLmdldEJvZHkoKS5maW5kKCcjcmVhZC13aXJlLWJ1dHRvbicpXG4gICAgICAuY2xpY2sodGhpcy5vblJlY2VpdmVCdXR0b25QcmVzc18uYmluZCh0aGlzKSk7XG5cbiAgLy8gQWRkIGEgY2xlYXIgYnV0dG9uIHRvIHRoZSBwYW5lbCBoZWFkZXJcbiAgdGhpcy5hZGRCdXR0b24oaTE4bi5jbGVhcigpLCB0aGlzLm9uQ2xlYXJCdXR0b25QcmVzc18uYmluZCh0aGlzKSk7XG5cbiAgLy8gU25hcCBiYWNrIHRvIHRoZSBkeW5hbWljIHNpemUgd2UndmUgYmVlbiBnaXZlbi5cbiAgdGhpcy5zaXplVG9PcGVuSGVpZ2h0XygpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHBhY2tldHMgZnJvbSB0aGUgbG9nLCByZXNldHRpbmcgaXRzIHN0YXRlLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLm9uQ2xlYXJCdXR0b25QcmVzc18gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmluYXJ5XyA9ICcnO1xuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBmZXRjaCB0aGUgd2lyZSBzdGF0ZSBmcm9tIHJlbW90ZSBzdG9yYWdlLCBhbmQgbG9nIGl0LlxuICogQHBhcmFtIHtFdmVudH0galF1ZXJ5RXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbUJpdExvZ1BhbmVsLnByb3RvdHlwZS5vblJlY2VpdmVCdXR0b25QcmVzc18gPSBmdW5jdGlvbiAoalF1ZXJ5RXZlbnQpIHtcbiAgdmFyIHRoaXNCdXR0b24gPSAkKGpRdWVyeUV2ZW50LnRhcmdldCk7XG4gIGlmICh0aGlzQnV0dG9uLmlzKCdbZGlzYWJsZWRdJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzQnV0dG9uLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gIHRoaXMubmV0c2ltXy5yZWNlaXZlQml0KGZ1bmN0aW9uIChlcnIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBsb2dnZXIud2FybihcIkVycm9yIHJlYWRpbmcgd2lyZSBzdGF0ZTogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICB0aGlzQnV0dG9uLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQSBzdWNjZXNzZnVsIGZldGNoIHdpdGggYSBudWxsIG1lc3NhZ2UgbWVhbnMgdGhlcmUncyBub3RoaW5nXG4gICAgLy8gb24gdGhlIHdpcmUuICBXZSBzaG91bGQgbG9nIGl0cyBkZWZhdWx0IHN0YXRlOiBvZmYvemVyb1xuICAgIHZhciByZWNlaXZlZEJpdCA9ICcwJztcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgcmVjZWl2ZWRCaXQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgfVxuXG4gICAgdGhpcy5sb2cocmVjZWl2ZWRCaXQpO1xuICAgIHRoaXMubmV0c2ltXy5hbmltYXRlUmVhZFdpcmVTdGF0ZShyZWNlaXZlZEJpdCk7XG4gICAgdGhpc0J1dHRvbi5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBQdXQgYSBtZXNzYWdlIGludG8gdGhlIGxvZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlCaXRcbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChiaW5hcnlCaXQpIHtcbiAgdGhpcy5iaW5hcnlfICs9IGJpbmFyeUJpdC50b1N0cmluZygpO1xuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBTaG93IG9yIGhpZGUgcGFydHMgb2YgdGhlIHNlbmQgVUkgYmFzZWQgb24gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbmNvZGluZ1xuICogbW9kZS5cbiAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlW119IG5ld0VuY29kaW5nc1xuICovXG5OZXRTaW1CaXRMb2dQYW5lbC5wcm90b3R5cGUuc2V0RW5jb2RpbmdzID0gZnVuY3Rpb24gKG5ld0VuY29kaW5ncykge1xuICB0aGlzLmVuY29kaW5nc18gPSBuZXdFbmNvZGluZ3M7XG4gIHRoaXMucmVuZGVyKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBob3cgYmluYXJ5IGlucHV0IGluIGludGVycHJldGVkIGFuZCBmb3JtYXR0ZWQgaW4gdGhlIGxvZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdDaHVua1NpemVcbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLnNldENodW5rU2l6ZSA9IGZ1bmN0aW9uIChuZXdDaHVua1NpemUpIHtcbiAgdGhpcy5jaHVua1NpemVfID0gbmV3Q2h1bmtTaXplO1xuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IHRoaXMgbG9nIHBhbmVsIHNob3VsZCBjb25zdW1lIChpbmNsdWRpbmcgbWFyZ2lucylcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRQaXhlbHNcbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHRQaXhlbHMpIHtcbiAgdGhpcy5vcGVuSGVpZ2h0XyA9IGhlaWdodFBpeGVscztcbiAgdGhpcy5zaXplVG9PcGVuSGVpZ2h0XygpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgc2Nyb2xsIGFyZWEgaW5zaWRlIHRoZSBwYW5lbCBzbyB0aGF0IHRoZSB3aG9sZSBwYW5lbFxuICogaXMgdGhlIGRlc2lyZWQgaGVpZ2h0LlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLnNpemVUb09wZW5IZWlnaHRfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpLmZpbmQoJy5uZXRzaW0tcGFuZWwnKTtcbiAgdmFyIHBhbmVsSGVhZGVyID0gcm9vdC5maW5kKCdoMScpO1xuICB2YXIgcGFuZWxCb2R5ID0gcm9vdC5maW5kKCcucGFuZWwtYm9keScpO1xuICB2YXIgc2Nyb2xsQXJlYSA9IHJvb3QuZmluZCgnLnNjcm9sbC1hcmVhJyk7XG5cbiAgdmFyIHBhbmVsTWFyZ2lucyA9IHBhcnNlRmxvYXQocm9vdC5jc3MoJ21hcmdpbi10b3AnKSkgK1xuICAgICAgcGFyc2VGbG9hdChyb290LmNzcygnbWFyZ2luLWJvdHRvbScpKTtcbiAgdmFyIGhlYWRlckhlaWdodCA9IHBhbmVsSGVhZGVyLm91dGVySGVpZ2h0KHRydWUpO1xuICB2YXIgcGFuZWxCb3JkZXJzID0gcGFyc2VGbG9hdChwYW5lbEJvZHkuY3NzKCdib3JkZXItdG9wLXdpZHRoJykpICtcbiAgICAgIHBhcnNlRmxvYXQocGFuZWxCb2R5LmNzcygnYm9yZGVyLWJvdHRvbS13aWR0aCcpKTtcbiAgdmFyIHNjcm9sbE1hcmdpbnMgPSBwYXJzZUZsb2F0KHNjcm9sbEFyZWEuY3NzKCdtYXJnaW4tdG9wJykpICtcbiAgICAgIHBhcnNlRmxvYXQoc2Nyb2xsQXJlYS5jc3MoJ21hcmdpbi1ib3R0b20nKSk7XG5cbiAgLy8gV2Ugc2V0IHRoZSBwYW5lbCBoZWlnaHQgYnkgZml4aW5nIHRoZSBzaXplIG9mIGl0cyBpbm5lciBzY3JvbGxhYmxlXG4gIC8vIGFyZWEuXG4gIHZhciBuZXdTY3JvbGxWaWV3cG9ydEhlaWdodCA9IHRoaXMub3BlbkhlaWdodF8gLSAocGFuZWxNYXJnaW5zICsgaGVhZGVySGVpZ2h0ICtcbiAgICAgIHBhbmVsQm9yZGVycyArIHNjcm9sbE1hcmdpbnMpO1xuICBzY3JvbGxBcmVhLmhlaWdodChNYXRoLmZsb29yKG5ld1Njcm9sbFZpZXdwb3J0SGVpZ2h0KSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZlcnRpY2FsIHNwYWNlIHRoYXQgcGFuZWwgY3VycmVudGx5IGNvbnN1bWVzIChpbmNsdWRpbmdcbiAqIG1hcmdpbnMpIGluIHBpeGVscy5cbiAqL1xuTmV0U2ltQml0TG9nUGFuZWwucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0Um9vdCgpLmZpbmQoJy5uZXRzaW0tcGFuZWwnKS5vdXRlckhlaWdodCh0cnVlKTtcbn07XG5cbi8qKlxuICogQWZ0ZXIgdG9nZ2xpbmcgcGFuZWwgdmlzaWJpbGl0eSwgdHJpZ2dlciBhIGxheW91dCB1cGRhdGUgc28gc2VuZC9sb2cgcGFuZWxcbiAqIHNwYWNlIGlzIHNoYXJlZCBjb3JyZWN0bHkuXG4gKiBAcHJpdmF0ZVxuICogQG92ZXJyaWRlXG4gKi9cbk5ldFNpbUJpdExvZ1BhbmVsLnByb3RvdHlwZS5vbk1pbmltaXplckNsaWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgTmV0U2ltQml0TG9nUGFuZWwuc3VwZXJQcm90b3R5cGUub25NaW5pbWl6ZXJDbGlja18uY2FsbCh0aGlzKTtcbiAgTmV0U2ltR2xvYmFscy51cGRhdGVMYXlvdXQoKTtcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBiYXNlIGNsYXNzIGZvciBhbGwgXCJwYW5lbHNcIiAodmlzdWFsIGJveGVzKSBpbiB0aGUgTmV0U2ltXG4gKiAgICAgICAgICAgaW50ZXJmYWNlLCBwcm92aWRlcyBzb21lIGNvbW1vbiBleHBhbmQvY29sbGFwc2UgZnVuY3Rpb25hbGl0eS5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1QYW5lbC5odG1sLmVqcycpO1xudmFyIEFyZ3VtZW50VXRpbHMgPSByZXF1aXJlKCcuL0FyZ3VtZW50VXRpbHMnKTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIGEgTmV0U2ltIFBhbmVsLCBhIHNpbmdsZSBzZWN0aW9uIG9uIHRoZVxuICogcGFnZSB3aGljaCBtYXkgYmUgY29sbGFwc2libGUuXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdiAtIEVsZW1lbnQgd2l0aGluIHdoaWNoIHRoZSBwYW5lbCBpcyByZWNyZWF0ZWRcbiAqICAgICAgICBldmVyeSB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZC4gIFdpbGwgd2lwZSBvdXQgY29udGVudHMgb2YgdGhpc1xuICogICAgICAgIGVsZW1lbnQsIGJ1dCBub3QgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsYXNzTmFtZV0gLSBhbiBhZGRpdGlvbmFsIGNsYXNzIHRvIGJlIGFwcGVuZGVkIHRvXG4gKiAgICAgICAgdGhlIHBhbmVsJ3Mgcm9vdCAob25lIGxheWVyIGluc2lkZSByb290RGl2KSBmb3Igc3R5bGUgcnVsZXMuXG4gKiAgICAgICAgRGVmYXVsdHMgdG8gbm8gY2xhc3MsIHNvIG9ubHkgdGhlICduZXRzaW0tcGFuZWwnIGNsYXNzIHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wYW5lbFRpdGxlXSAtIExvY2FsaXplZCBpbml0aWFsIHBhbmVsIHRpdGxlLlxuICogICAgICAgIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlclRvZ2dsZWFibGVdIC0gV2hldGhlciB0aGlzIHBhbmVsIGNhbiBiZSBtaW5pbWl6ZWRcbiAqICAgICAgICAoY2xvc2VkKSBieSBjbGlja2luZyBvbiB0aGUgdGl0bGUuIERlZmF1bHRzIHRvIFRSVUUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJlZ2luTWluaW1pemVkXSAtIFdoZXRoZXIgdGhpcyBwYW5lbCBzaG91bGQgYmVcbiAqICAgICAgICBtaW5pbWl6ZWQgKGNsb3NlZCkgd2hlbiBpdCBpcyBpbml0aWFsbHkgY3JlYXRlZC4gIERlZmF1bHRzIHRvIEZBTFNFLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXRTaW1QYW5lbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3REaXYsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpbnN0YW5jZSBJRCBmb3IgdGhpcyBwYW5lbCwgaW4gY2FzZSB3ZSBoYXZlIHNldmVyYWxcbiAgICogb2YgdGhlbSBvbiBhIHBhZ2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmluc3RhbmNlSURfID0gTmV0U2ltUGFuZWwudW5pcXVlSURDb3VudGVyO1xuICBOZXRTaW1QYW5lbC51bmlxdWVJRENvdW50ZXIrKztcblxuICAvKipcbiAgICogQ29tcG9uZW50IHJvb3QsIHdoaWNoIHdlIGZpbGwgd2hlbmV2ZXIgd2UgY2FsbCByZW5kZXIoKVxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290RGl2XyA9IHJvb3REaXY7XG5cbiAgLyoqXG4gICAqIEFuIGFkZGl0aW9uYWwgY2xhc3NOYW1lIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBwYW5lbCdzIHJvb3QgKG9uZSBsYXllclxuICAgKiBpbnNpZGUgcm9vdERpdiksIGZvciBzdHlsZSBydWxlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2xhc3NOYW1lXyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy5jbGFzc05hbWUsICcnKTtcblxuICAvKipcbiAgICogUGFuZWwgdGl0bGUsIGRpc3BsYXllZCBpbiBoZWFkZXIuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBhbmVsVGl0bGVfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLnBhbmVsVGl0bGUsICcnKTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHBhbmVsIGNhbiBiZSBtaW5pbWl6ZWQgKGNsb3NlZCkgYnkgY2xpY2tpbmcgb24gdGhlIHRpdGxlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudXNlclRvZ2dsZWFibGVfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLnVzZXJUb2dnbGVhYmxlLCB0cnVlKTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIG1pbmltaXplZCwgZm9yIGNvbnNpc3RlbnRcbiAgICogc3RhdGUgYWNyb3NzIHJlLXJlbmRlcnMuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc01pbmltaXplZF8gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMuYmVnaW5NaW5pbWl6ZWQsIGZhbHNlKTtcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICB0aGlzLnJlbmRlcigpO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgY291bnRlciB1c2VkIHRvIGdlbmVyYXRlL3VuaXF1ZWx5IGlkZW50aWZ5IGRpZmZlcmVudCBpbnN0YW5jZXNcbiAqIG9mIHRoaXMgbG9nIHdpZGdldCBvbiB0aGUgcGFnZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbk5ldFNpbVBhbmVsLnVuaXF1ZUlEQ291bnRlciA9IDA7XG5cbi8qKlxuICogUmVidWlsZCB0aGUgcGFuZWwgY29udGVudHMgaW5zaWRlIG9mIHRoZSByb290RGl2XG4gKi9cbk5ldFNpbVBhbmVsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZXdNYXJrdXAgPSAkKG1hcmt1cCh7XG4gICAgaW5zdGFuY2VJRDogdGhpcy5pbnN0YW5jZUlEXyxcbiAgICBjbGFzc05hbWU6IHRoaXMuY2xhc3NOYW1lXyxcbiAgICBwYW5lbFRpdGxlOiB0aGlzLnBhbmVsVGl0bGVfLFxuICAgIHVzZXJUb2dnbGVhYmxlOiB0aGlzLnVzZXJUb2dnbGVhYmxlX1xuICB9KSk7XG4gIHRoaXMucm9vdERpdl8uaHRtbChuZXdNYXJrdXApO1xuXG4gIGlmICh0aGlzLnVzZXJUb2dnbGVhYmxlXykge1xuICAgIHRoaXMucm9vdERpdl8uZmluZCgnLm1pbmltaXplcicpLmNsaWNrKHRoaXMub25NaW5pbWl6ZXJDbGlja18uYmluZCh0aGlzKSk7XG4gIH1cbiAgdGhpcy5zZXRNaW5pbWl6ZWQodGhpcy5pc01pbmltaXplZF8pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7alF1ZXJ5fSBhIGhhbmRsZSBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciB0aGlzIHBhbmVsXG4gKi9cbk5ldFNpbVBhbmVsLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb290RGl2Xztcbn07XG5cbi8qKlxuICogU2V0IHBhbmVsIHRpdGxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1RpdGxlIC0gTG9jYWxpemVkIHBhbmVsIHRpdGxlLlxuICovXG5OZXRTaW1QYW5lbC5wcm90b3R5cGUuc2V0UGFuZWxUaXRsZSA9IGZ1bmN0aW9uIChuZXdUaXRsZSkge1xuICB0aGlzLnBhbmVsVGl0bGVfID0gbmV3VGl0bGU7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLnRpdGxlLXRleHQnKS50ZXh0KG5ld1RpdGxlKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIHdoZXRoZXIgdGhpcyBwYW5lbCBpcyBtaW5pbWl6ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1QYW5lbC5wcm90b3R5cGUub25NaW5pbWl6ZXJDbGlja18gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0TWluaW1pemVkKCF0aGlzLmlzTWluaW1pemVkXyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmVjb21lTWluaW1pemVkXG4gKi9cbk5ldFNpbVBhbmVsLnByb3RvdHlwZS5zZXRNaW5pbWl6ZWQgPSBmdW5jdGlvbiAoYmVjb21lTWluaW1pemVkKSB7XG4gIHZhciBwYW5lbERpdiA9IHRoaXMucm9vdERpdl8uZmluZCgnLm5ldHNpbS1wYW5lbCcpO1xuICB2YXIgbWluaW1pemVyID0gcGFuZWxEaXYuZmluZCgnLm1pbmltaXplcicpO1xuICBpZiAoYmVjb21lTWluaW1pemVkKSB7XG4gICAgcGFuZWxEaXYuYWRkQ2xhc3MoJ21pbmltaXplZCcpO1xuICAgIG1pbmltaXplci5maW5kKCcuZmEnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2ZhLXBsdXMtc3F1YXJlJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdmYS1taW51cy1zcXVhcmUnKTtcbiAgfSBlbHNlIHtcbiAgICBwYW5lbERpdi5yZW1vdmVDbGFzcygnbWluaW1pemVkJyk7XG4gICAgbWluaW1pemVyLmZpbmQoJy5mYScpXG4gICAgICAgIC5hZGRDbGFzcygnZmEtbWludXMtc3F1YXJlJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdmYS1wbHVzLXNxdWFyZScpO1xuICB9XG4gIHRoaXMuaXNNaW5pbWl6ZWRfID0gYmVjb21lTWluaW1pemVkO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoaXMgcGFuZWwgaXMgY3VycmVudGx5IG1pbmltaXplZCAoc2hvd2luZyBvbmx5IGl0cyBoZWFkZXIpIG9yIG5vdC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5OZXRTaW1QYW5lbC5wcm90b3R5cGUuaXNNaW5pbWl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzTWluaW1pemVkXztcbn07XG5cbi8qKlxuICogQWRkIGEgYnV0dG9uIHRvIHRoZSByaWdodCBlbmQgb2YgdGhlIHBhbmVsIGhlYWRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBidXR0b25UZXh0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVzc0NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY29uZGFyeV0gLSBkZWZhdWx0IFRSVUUsIHNlY29uZGFyeSBidXR0b24gc3R5bGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmNsYXNzZXNdIC0gZGVmYXVsdCBbXSwgYWRkaXRpb25hbCBjbGFzc2VzIG9uIHRoZVxuICogICAgICAgIGJ1dHRvbiBlbGVtZW50LlxuICovXG5OZXRTaW1QYW5lbC5wcm90b3R5cGUuYWRkQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uVGV4dCwgcHJlc3NDYWxsYmFjaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gQXJndW1lbnRVdGlscy5leHRlbmRPcHRpb25zT2JqZWN0KG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBidXR0b24gPSAkKCc8c3Bhbj4nKVxuICAgICAgLmFkZENsYXNzKCduZXRzaW0tYnV0dG9uJylcbiAgICAgIC5odG1sKGJ1dHRvblRleHQpXG4gICAgICAuY2xpY2socHJlc3NDYWxsYmFjayk7XG5cbiAgaWYgKG9wdGlvbnMuZ2V0KCdzZWNvbmRhcnknLCBBcmd1bWVudFV0aWxzLmlzQm9vbGVhbiwgdHJ1ZSkpIHtcbiAgICBidXR0b24uYWRkQ2xhc3MoJ3NlY29uZGFyeScpO1xuICB9XG5cbiAgb3B0aW9ucy5nZXQoJ2NsYXNzZXMnLCBBcmd1bWVudFV0aWxzLmlzQXJyYXlPZlN0cmluZ3MoKSwgW10pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGJ1dHRvbi5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgfSk7XG5cbiAgYnV0dG9uLmFwcGVuZFRvKHRoaXMucm9vdERpdl8uZmluZCgnLnBhbmVsLWNvbnRyb2xzJykpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7alF1ZXJ5fSB0aGUgYm9keSBEaXYgb2YgdGhlIHBhbmVsLCBmb3IgcGFuZWwgY29udGVudC5cbiAqL1xuTmV0U2ltUGFuZWwucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3REaXZfLmZpbmQoJy5wYW5lbC1ib2R5Jyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8ZGl2IGlkPVwibmV0c2ltLXBhbmVsLScsIGVzY2FwZSgoMSwgIGluc3RhbmNlSUQgKSksICdcIlxcbiAgICAgY2xhc3M9XCJuZXRzaW0tcGFuZWwgJywgZXNjYXBlKCgyLCAgY2xhc3NOYW1lICkpLCAnXCI+XFxuICA8aDE+XFxuICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1jb250cm9sc1wiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwic2luZ2xlLWxpbmUtd2l0aC1lbGxpcHNpcyBwYWQtbGVmdCcpOzU7IGlmICh1c2VyVG9nZ2xlYWJsZSkgeyA7IGJ1Zi5wdXNoKCcgbWluaW1pemVyJyk7NTsgfSA7IGJ1Zi5wdXNoKCdcIj5cXG4gICAgICAnKTs2OyBpZiAodXNlclRvZ2dsZWFibGUpIHsgOyBidWYucHVzaCgnXFxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLW1pbnVzLXNxdWFyZVwiPjwvaT5cXG4gICAgICAnKTs4OyB9IDsgYnVmLnB1c2goJ1xcbiAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGUtdGV4dFwiPicsIGVzY2FwZSgoOSwgIHBhbmVsVGl0bGUgKSksICc8L3NwYW4+XFxuICAgIDwvZGl2PlxcbiAgPC9oMT5cXG4gIDxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKipcbiAqIEBvdmVydmlldyBVSSBjb250cm9sbGVyIGZvciBzZXQgb2YgcmFkaW8gYnV0dG9ucyB1c2VkIHRvIHNlbGVjdCBkaXNwbGF5IGVuY29kaW5ncy5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9OZXRTaW1FbmNvZGluZ0NvbnRyb2wuaHRtbC5lanMnKTtcbnZhciBFbmNvZGluZ1R5cGUgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpLkVuY29kaW5nVHlwZTtcblxuLyoqXG4gKiBHZW5lcmF0b3IgYW5kIGNvbnRyb2xsZXIgZm9yIG1lc3NhZ2UgZW5jb2Rpbmcgc2VsZWN0b3I6IEEgZHJvcGRvd24gdGhhdFxuICogY29udHJvbHMgd2hldGhlciBtZXNzYWdlcyBhcmUgZGlzcGxheWVkIGluIHNvbWUgY29tYmluYXRpb24gb2YgYmluYXJ5LCBoZXgsXG4gKiBkZWNpbWFsLCBhc2NpaSwgZXRjLlxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXZcbiAqIEBwYXJhbSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufSBsZXZlbENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2hhbmdlRW5jb2RpbmdDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXRTaW1FbmNvZGluZ0NvbnRyb2wgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBsZXZlbENvbmZpZyxcbiAgICBjaGFuZ2VFbmNvZGluZ0NhbGxiYWNrKSB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgcm9vdCwgd2hpY2ggd2UgZmlsbCB3aGVuZXZlciB3ZSBjYWxsIHJlbmRlcigpXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gcm9vdERpdjtcblxuICAvKipcbiAgICogQHR5cGUge05ldFNpbUxldmVsQ29uZmlndXJhdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubGV2ZWxDb25maWdfID0gbGV2ZWxDb25maWc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2hhbmdlRW5jb2RpbmdDYWxsYmFja18gPSBjaGFuZ2VFbmNvZGluZ0NhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jaGVja2JveGVzXyA9IG51bGw7XG5cbiAgLy8gSW5pdGlhbCByZW5kZXJcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5cbi8qKlxuICogRmlsbCB0aGUgcm9vdCBkaXYgd2l0aCBuZXcgZWxlbWVudHMgcmVmbGVjdGluZyB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5OZXRTaW1FbmNvZGluZ0NvbnRyb2wucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlbmRlcmVkTWFya3VwID0gJChtYXJrdXAoe1xuICAgIGxldmVsOiB0aGlzLmxldmVsQ29uZmlnX1xuICB9KSk7XG4gIHRoaXMucm9vdERpdl8uaHRtbChyZW5kZXJlZE1hcmt1cCk7XG4gIHRoaXMuY2hlY2tib3hlc18gPSB0aGlzLnJvb3REaXZfLmZpbmQoXG4gICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdW25hbWU9XCJlbmNvZGluZ19jaGVja2JveGVzXCJdJyk7XG4gIHRoaXMuY2hlY2tib3hlc18uY2hhbmdlKHRoaXMub25DaGVja2JveGVzQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VuZCBuZXcgc2VsZWN0ZWQgZW5jb2RpbmdzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2sgb24gY2hhbmdlLlxuICogQHByaXZhdGVcbiAqL1xuTmV0U2ltRW5jb2RpbmdDb250cm9sLnByb3RvdHlwZS5vbkNoZWNrYm94ZXNDaGFuZ2VfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZWN0ZWRFbmNvZGluZ3MgPSBbXTtcbiAgdGhpcy5jaGVja2JveGVzXy5maWx0ZXIoJzpjaGVja2VkJykuZWFjaChmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgIHNlbGVjdGVkRW5jb2RpbmdzLnB1c2goZWxlbWVudC52YWx1ZSk7XG4gIH0pO1xuICB0aGlzLmNoYW5nZUVuY29kaW5nQ2FsbGJhY2tfKHNlbGVjdGVkRW5jb2RpbmdzKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHNlbGVjdG9yIHZhbHVlIHRvIHRoZSBuZXcgcHJvdmlkZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBuZXdFbmNvZGluZ3NcbiAqL1xuTmV0U2ltRW5jb2RpbmdDb250cm9sLnByb3RvdHlwZS5zZXRFbmNvZGluZ3MgPSBmdW5jdGlvbiAobmV3RW5jb2RpbmdzKSB7XG4gIHRoaXMuY2hlY2tib3hlc18uZWFjaChmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkuYXR0cignY2hlY2tlZCcsIChuZXdFbmNvZGluZ3MuaW5kZXhPZihlbGVtZW50LnZhbHVlKSA+IC0xKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgdGhhdCB3aWxsIGdldCBhbGwgcm93cyB0aGF0XG4gKiBoYXZlIEFOWSBvZiB0aGUgcHJvdmlkZWQgY2xhc3Nlcy5cbiAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlW119IGVuY29kaW5nc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIG1ha2VFbmNvZGluZ1Jvd1NlbGVjdG9yID0gZnVuY3Rpb24gKGVuY29kaW5ncykge1xuICByZXR1cm4gZW5jb2RpbmdzLm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuICd0ci4nICsgY2xhc3NOYW1lO1xuICB9KS5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgaGVscGVyLCBzaG93cy9oaWRlcyByb3dzIHVuZGVyIHByb3ZpZGVkIGVsZW1lbnQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlblxuICogZW5jb2Rpbmcgc2V0dGluZy5cbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RWxlbWVudCAtIHJvb3Qgb2YgZWxlbWVudHMgdG8gc2hvdy9oaWRlXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBlbmNvZGluZ3MgLSBhIG1lc3NhZ2UgZW5jb2Rpbmcgc2V0dGluZ1xuICovXG5OZXRTaW1FbmNvZGluZ0NvbnRyb2wuaGlkZVJvd3NCeUVuY29kaW5nID0gZnVuY3Rpb24gKHJvb3RFbGVtZW50LCBlbmNvZGluZ3MpIHtcbiAgdmFyIGhpZGRlbkVuY29kaW5ncyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gRW5jb2RpbmdUeXBlKSB7XG4gICAgaWYgKEVuY29kaW5nVHlwZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgIGVuY29kaW5ncy5pbmRleE9mKEVuY29kaW5nVHlwZVtrZXldKSA9PT0gLTEpIHtcbiAgICAgIGhpZGRlbkVuY29kaW5ncy5wdXNoKEVuY29kaW5nVHlwZVtrZXldKTtcbiAgICB9XG4gIH1cbiAgcm9vdEVsZW1lbnQuZmluZChtYWtlRW5jb2RpbmdSb3dTZWxlY3RvcihlbmNvZGluZ3MpKS5zaG93KCk7XG4gIHJvb3RFbGVtZW50LmZpbmQobWFrZUVuY29kaW5nUm93U2VsZWN0b3IoaGlkZGVuRW5jb2RpbmdzKSkuaGlkZSgpO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgaGVscGVyIHRoYXQgY29udmVydHMgYSBnaXZlbiBhcnJheSBvZiBlbmNvZGluZ3MgdG8gYW4gb2JqZWN0XG4gKiBtYXBwaW5nIGVhY2ggZW5jb2RpbmcgdG8gYHRydWVgLiBVc2VkIGZvciBtb3JlIGVmZmljaWVudFxuICogaXNFbmNvZGluZ0VuYWJsZWQgY2hlY2tzXG4gKiBAcGFyYW0ge0VuY29kaW5nVHlwZVtdfSBlbmNvZGluZ3NcbiAqIEByZXR1cm5zIHtPYmplY3QuPEVuY29kaW5nVHlwZSwgYm9vbGVhbj59XG4gKi9cbk5ldFNpbUVuY29kaW5nQ29udHJvbC5lbmNvZGluZ3NBc0hhc2ggPSBmdW5jdGlvbiAoZW5jb2RpbmdzKSB7XG4gIHJldHVybiBlbmNvZGluZ3MucmVkdWNlKGZ1bmN0aW9uIChoYXNoLCBlbmNvZGluZykge1xuICAgIGhhc2hbZW5jb2RpbmddID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbiAgfSwge30pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbiAgdmFyIEVuY29kaW5nVHlwZSA9IHJlcXVpcmUoJy4vTmV0U2ltQ29uc3RhbnRzJykuRW5jb2RpbmdUeXBlO1xuICB2YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlfSBlbmNvZGluZ1R5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nTGFiZWxcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VDaGVja2JveChlbmNvZGluZ1R5cGUsIGVuY29kaW5nTGFiZWwpIHtcbiAgICB2YXIgZGl2Q2xhc3NlcyA9IFsnZW5jb2RpbmdfY2hlY2tib3hlc18nICsgZW5jb2RpbmdUeXBlXTtcbiAgICBpZiAobGV2ZWwuc2hvd0VuY29kaW5nQ29udHJvbHMuaW5kZXhPZihlbmNvZGluZ1R5cGUpID09PSAtMSkge1xuICAgICAgZGl2Q2xhc3Nlcy5wdXNoKCdoaWRkZW4tY29udHJvbCcpO1xuICAgIH1cbiAgICA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBjbGFzcz1cIicsIGVzY2FwZSgoMTUsICBkaXZDbGFzc2VzLmpvaW4oJyAnKSApKSwgJ1wiPlxcbiAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxcbiAgICAgICAgICAgICBuYW1lPVwiZW5jb2RpbmdfY2hlY2tib3hlc1wiXFxuICAgICAgICAgICAgIGlkPVwiZW5jb2RpbmdfY2hlY2tib3hlc18nLCBlc2NhcGUoKDE4LCAgZW5jb2RpbmdUeXBlICkpLCAnXCJcXG4gICAgICAgICAgICAgdmFsdWU9XCInLCBlc2NhcGUoKDE5LCAgZW5jb2RpbmdUeXBlICkpLCAnXCJcXG4gICAgICAgICAgLz5cXG4gICAgICA8bGFiZWwgZm9yPVwiZW5jb2RpbmdfY2hlY2tib3hlc18nLCBlc2NhcGUoKDIxLCAgZW5jb2RpbmdUeXBlICkpLCAnXCI+JywgZXNjYXBlKCgyMSwgIGVuY29kaW5nTGFiZWwgKSksICc8L2xhYmVsPlxcbiAgICA8L2Rpdj5cXG4gICAgJyk7MjM7XG4gIH1cbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJuZXRzaW0tZW5jb2Rpbmctc2VsZWN0b3JcIj5cXG4gIDxoMT4nLCBlc2NhcGUoKDI3LCAgaTE4bi5lbmNvZGluZygpICkpLCAnPC9oMT5cXG4gICcpOzI4OyBtYWtlQ2hlY2tib3goRW5jb2RpbmdUeXBlLkFTQ0lJLCBpMThuLmFzY2lpKCkpOyA7IGJ1Zi5wdXNoKCdcXG4gICcpOzI5OyBtYWtlQ2hlY2tib3goRW5jb2RpbmdUeXBlLkRFQ0lNQUwsIGkxOG4uZGVjaW1hbCgpKTsgOyBidWYucHVzaCgnXFxuICAnKTszMDsgbWFrZUNoZWNrYm94KEVuY29kaW5nVHlwZS5IRVhBREVDSU1BTCwgaTE4bi5oZXhhZGVjaW1hbCgpKTsgOyBidWYucHVzaCgnXFxuICAnKTszMTsgbWFrZUNoZWNrYm94KEVuY29kaW5nVHlwZS5CSU5BUlksIGkxOG4uYmluYXJ5KCkpOyA7IGJ1Zi5wdXNoKCdcXG4gICcpOzMyOyBtYWtlQ2hlY2tib3goRW5jb2RpbmdUeXBlLkFfQU5EX0IsIGkxOG4uYV9hbmRfYigpKTsgOyBidWYucHVzaCgnXFxuPC9kaXY+Jyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxO1xuICB2YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG4gIHZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xuICB2YXIgRGF0YUNvbnZlcnRlcnMgPSByZXF1aXJlKCcuL0RhdGFDb252ZXJ0ZXJzJyk7XG5cbiAgdmFyIGdldEVuY29kaW5nTGFiZWwgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJykuZ2V0RW5jb2RpbmdMYWJlbDtcblxuICB2YXIgRW5jb2RpbmdUeXBlID0gTmV0U2ltQ29uc3RhbnRzLkVuY29kaW5nVHlwZTtcbiAgdmFyIFBhY2tldFVJQ29sdW1uVHlwZSA9IE5ldFNpbUNvbnN0YW50cy5QYWNrZXRVSUNvbHVtblR5cGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RW5jb2RpbmdUeXBlfSBlbmNvZGluZ1R5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRDb250ZW50XG4gICAqL1xuICBmdW5jdGlvbiBsb2dSb3coZW5jb2RpbmdUeXBlLCBlbmNvZGVkQ29udGVudCkge1xuICAgIDsgYnVmLnB1c2goJ1xcbiAgICA8dHIgY2xhc3M9XCInLCBlc2NhcGUoKDE3LCAgZW5jb2RpbmdUeXBlICkpLCAnXCI+XFxuICAgICAgPHRoIG5vd3JhcCBjbGFzcz1cIicsIGVzY2FwZSgoMTgsICBQYWNrZXRVSUNvbHVtblR5cGUuRU5DT0RJTkdfTEFCRUwgKSksICdcIj4nLCBlc2NhcGUoKDE4LCAgZ2V0RW5jb2RpbmdMYWJlbChlbmNvZGluZ1R5cGUpICkpLCAnPC90aD5cXG4gICAgICA8dGQgY2xhc3M9XCInLCBlc2NhcGUoKDE5LCAgUGFja2V0VUlDb2x1bW5UeXBlLk1FU1NBR0UgKSksICdcIj4nLCBlc2NhcGUoKDE5LCAgZW5jb2RlZENvbnRlbnQgKSksICc8L3RkPlxcbiAgICA8L3RyPlxcbiAgICAnKTsyMTtcbiAgfVxuOyBidWYucHVzaCgnXFxuPGRpdiBjbGFzcz1cInNjcm9sbC1hcmVhIGJpdC1sb2ctc2Nyb2xsLWFyZWFcIj5cXG4gIDxkaXYgY2xhc3M9XCJwYWNrZXRcIj5cXG4gICAgPHRhYmxlPlxcbiAgICAgIDx0Ym9keT5cXG4gICAgICAgICcpOzI4O1xuICAgICAgICAgIGxvZ1JvdyhFbmNvZGluZ1R5cGUuQVNDSUksIERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvQXNjaWkoYmluYXJ5LCBjaHVua1NpemUpKTtcblxuICAgICAgICAgIGxvZ1JvdyhFbmNvZGluZ1R5cGUuREVDSU1BTCwgRGF0YUNvbnZlcnRlcnMuYWxpZ25EZWNpbWFsKERhdGFDb252ZXJ0ZXJzLmJpbmFyeVRvRGVjaW1hbChiaW5hcnksIGNodW5rU2l6ZSkpKTtcblxuICAgICAgICAgIGxvZ1JvdyhFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwsIERhdGFDb252ZXJ0ZXJzLmZvcm1hdEhleChEYXRhQ29udmVydGVycy5iaW5hcnlUb0hleChiaW5hcnkpLCBjaHVua1NpemUpKTtcblxuICAgICAgICAgIGxvZ1JvdyhFbmNvZGluZ1R5cGUuQklOQVJZLCBEYXRhQ29udmVydGVycy5mb3JtYXRCaW5hcnkoYmluYXJ5LCBjaHVua1NpemUpKTtcblxuICAgICAgICAgIGxvZ1JvdyhFbmNvZGluZ1R5cGUuQV9BTkRfQiwgRGF0YUNvbnZlcnRlcnMuZm9ybWF0QUIoRGF0YUNvbnZlcnRlcnMuYmluYXJ5VG9BQihiaW5hcnkpLCBjaHVua1NpemUpKTtcbiAgICAgICAgOyBidWYucHVzaCgnXFxuICAgICAgPC90Ym9keT5cXG4gICAgPC90YWJsZT5cXG4gIDwvZGl2PlxcbiAgJyk7NDI7IGlmIChzaG93UmVhZFdpcmVCdXR0b24pIHsgOyBidWYucHVzaCgnXFxuICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1mb290ZXIgYml0LWxvZy1wYW5lbC1mb290ZXJcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVwicmlnaHQtc2lkZS1jb250cm9sc1wiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJuZXRzaW0tYnV0dG9uIGxhcmdlLWJ1dHRvblwiIGlkPVwicmVhZC13aXJlLWJ1dHRvblwiPicsIGVzY2FwZSgoNDUsICBpMThuLnJlYWRXaXJlKCkgKSksICc8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgJyk7NDg7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgVUkgU2xpZGVyIGNvbnRyb2wgdXNlZCBmb3IgY2hhbmdpbmcgc2ltdWxhdGVkIHJvdXRlciBiYW5kd2lkdGguXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBVdGlscyByZXF1aXJlZCBvbmx5IGZvciBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMoKVxucmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBOZXRTaW1Db25zdGFudHMgPSByZXF1aXJlKCcuL05ldFNpbUNvbnN0YW50cycpO1xudmFyIE5ldFNpbVV0aWxzID0gcmVxdWlyZSgnLi9OZXRTaW1VdGlscycpO1xudmFyIE5ldFNpbVNsaWRlciA9IHJlcXVpcmUoJy4vTmV0U2ltU2xpZGVyJyk7XG5cbi8qKlxuICogR2VuZXJhdG9yIGFuZCBjb250cm9sbGVyIGZvciBwYWNrZXQgc2l6ZSBzbGlkZXIvc2VsZWN0b3JcbiAqIEBwYXJhbSB7alF1ZXJ5fSByb290RGl2XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzbGlkZXJDaGFuZ2VDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gc2xpZGVyU3RvcENhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldFNpbUJhbmR3aWR0aENvbnRyb2wgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LFxuICAgIHNsaWRlckNoYW5nZUNhbGxiYWNrLCBzbGlkZXJTdG9wQ2FsbGJhY2spIHtcbiAgTmV0U2ltU2xpZGVyLkxvZ2FyaXRobWljU2xpZGVyLmNhbGwodGhpcywgcm9vdERpdiwge1xuICAgIG9uQ2hhbmdlOiBzbGlkZXJDaGFuZ2VDYWxsYmFjayxcbiAgICBvblN0b3A6IHNsaWRlclN0b3BDYWxsYmFjayxcbiAgICB2YWx1ZTogSW5maW5pdHksXG4gICAgbWluOiA0LFxuICAgIG1heDogMTI4ICogTmV0U2ltQ29uc3RhbnRzLkJJVFNfUEVSX0tJTE9CSVQsXG4gICAgdXBwZXJCb3VuZEluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIC8vIEF1dG8tcmVuZGVyLCB1bmxpa2Ugb3VyIGJhc2UgY2xhc3NcbiAgdGhpcy5yZW5kZXIoKTtcbn07XG5OZXRTaW1CYW5kd2lkdGhDb250cm9sLmluaGVyaXRzKE5ldFNpbVNsaWRlci5Mb2dhcml0aG1pY1NsaWRlcik7XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1lcmljIGJhbmR3aWR0aCB2YWx1ZSAoaW4gYml0cykgaW50byBhIGNvbXBhY3QgbG9jYWxpemVkIHN0cmluZ1xuICogcmVwcmVzZW50YXRpb24gb2YgdGhhdCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBudW1lcmljIHZhbHVlIG9mIHRoZSBjb250cm9sXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdmFsdWVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1CYW5kd2lkdGhDb250cm9sLnByb3RvdHlwZS52YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBOZXRTaW1VdGlscy5iaXRyYXRlVG9Mb2NhbGl6ZWRSb3VuZGVkQml0cmF0ZSh2YWwpO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IEJhc2UgaW1wbGVtZW50YXRpb24gb2YgTmV0U2ltIFVJIHNsaWRlcnMuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltU2xpZGVyLmh0bWwuZWpzJyk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgU0xJREVSX0RFRkFVTFRfTUlOX1ZBTFVFID0gMDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbnZhciBTTElERVJfREVGQVVMVF9NQVhfVkFMVUUgPSAxMDA7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXYgLSBlbGVtZW50IHdob3NlIGNvbnRlbnQgd2UgcmVwbGFjZSB3aXRoIHRoZSBzbGlkZXJcbiAqICAgICAgICBvbiByZW5kZXIoKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLm9uQ2hhbmdlXSAtIGEgZnVuY3Rpb24gaW52b2tlZCB3aGVuZXZlciB0aGVcbiAqICAgICAgICBzbGlkZXItdmFsdWUgaXMgY2hhbmdlZCBieSB0aGUgc3R1ZGVudC4gIFBhc3NlZCB0aGUgbmV3IHZhbHVlIGFzIGFuXG4gKiAgICAgICAgYXJndW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5vblN0b3BdIC0gYSBmdW5jdGlvbiBpbnZva2VkIG9ubHkgd2hlbiB0aGVcbiAqICAgICAgICBzbGlkZXItaGFuZGxlIGlzIHJlbGVhc2VkIGJ5IHRoZSBzdHVkZW50LiAgUGFzc2VkIHRoZSBuZXcgdmFsdWUgYXMgYW5cbiAqICAgICAgICBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy52YWx1ZV0gLSBJbml0aWFsIHZhbHVlIG9mIHRoZSBzbGlkZXIuICBEZWZhdWx0cyB0b1xuICogICAgICAgIHNsaWRlciBtaW5pbXVtIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbl0gLSBMb3dlc3QgcG9zc2libGUgdmFsdWUgb2YgdGhlIHNsaWRlcjtcbiAqICAgICAgICBuZXh0LXRvLWxvd2VzdCBpZiBsb3dlckJvdW5kSW5maW5pdGUgaXMgdHJ1ZS4gIERlZmF1bHRzIHRvIHplcm8uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4XSAtIEhpZ2hlc3QgcG9zc2libGUgdmFsdWUgb2YgdGhlIHNsaWRlcjtcbiAqICAgICAgICBuZXh0LXRvLWhpZ2hlc3QgaWYgdXBwZXJCb3VuZEluZmluaXRlIGlzIHRydWUuICBEZWZhdWx0cyB0byAxMDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RlcF0gLSBTdGVwLXZhbHVlIG9mIGpRdWVyeVVJIHNsaWRlciAtIG5vdFxuICogICAgICAgIG5lY2Vzc2FyaWx5IHJlbGF0ZWQgdG8gbWluIGFuZCBtYXggdmFsdWVzIGlmIHlvdSBwcm92aWRlIGN1c3RvbSB2YWx1ZVxuICogICAgICAgIGNvbnZlcnRlcnMuIERlZmF1bHRzIHRvIDEuICBJZiBuZWdhdGl2ZSwgdGhlIHNsaWRlciBpcyByZXZlcnNlZCBhbmRcbiAqICAgICAgICBwdXRzIHRoZSBtaW4gdmFsdWUgb24gdGhlIHJpZ2h0LiAgQ2Fubm90IGJlIHplcm8gb3Igbm9uaW50ZWdlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXBwZXJCb3VuZEluZmluaXRlXSAtIGlmIFRSVUUsIHRoZSBoaWdoZXN0IHZhbHVlXG4gKiAgICAgICAgb24gdGhlIHNsaWRlciB3aWxsIGJlIEluZmluaXR5L1VubGltaXRlZC4gIERlZmF1bHQgRkFMU0UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvd2VyQm91bmRJbmZpbml0ZV0gLSBpZiBUUlVFLCB0aGUgbG93ZXN0IHZhbHVlXG4gKiAgICAgICAgb24gdGhlIHNsaWRlciB3aWxsIGJlIC1JbmZpbml0eS9VbmxpbWl0ZWQuICBEZWZhdWx0IEZBTFNFLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Rpc2FibGVkXSAtIGlmIFRSVUUgdGhlIHNsaWRlciB2YWx1ZSBpcyBsb2NrZWRcbiAqICAgICAgICBhbmQgY2Fubm90IGJlIGNoYW5nZWQuXG4gKi9cbnZhciBOZXRTaW1TbGlkZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290RGl2LCBvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBVbmlxdWUgaW5zdGFuY2UgSUQgZm9yIHRoaXMgcGFuZWwsIGluIGNhc2Ugd2UgaGF2ZSBzZXZlcmFsXG4gICAqIG9mIHRoZW0gb24gYSBwYWdlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pbnN0YW5jZUlEXyA9IE5ldFNpbVNsaWRlci51bmlxdWVJRENvdW50ZXI7XG4gIE5ldFNpbVNsaWRlci51bmlxdWVJRENvdW50ZXIrKztcblxuICAvKipcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdERpdl8gPSByb290RGl2O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIGludm9rZWQgd2hlbmV2ZXIgdGhlIHNsaWRlci12YWx1ZSBpcyBjaGFuZ2VkIGJ5IHRoZSBzdHVkZW50LlxuICAgKiBQYXNzZWQgdGhlIG5ldyB2YWx1ZSAobm90IHNsaWRlciBwb3NpdGlvbikgYXMgYW4gYXJndW1lbnQuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2hhbmdlQ2FsbGJhY2tfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLm9uQ2hhbmdlLCBmdW5jdGlvbiAoKSB7fSk7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gaW52b2tlZCBvbmx5IHdoZW4gdGhlIHNsaWRlci1oYW5kbGUgaXMgcmVsZWFzZWQgYnkgdGhlIHN0dWRlbnQuXG4gICAqIFBhc3NlZCB0aGUgbmV3IHZhbHVlIChub3Qgc2xpZGVyIHBvc2l0aW9uKSBhcyBhbiBhcmd1bWVudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnN0b3BDYWxsYmFja18gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMub25TdG9wLCBmdW5jdGlvbiAoKSB7fSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1pblZhbHVlXyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy5taW4sIFNMSURFUl9ERUZBVUxUX01JTl9WQUxVRSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1heFZhbHVlXyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy5tYXgsIFNMSURFUl9ERUZBVUxUX01BWF9WQUxVRSk7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IChvdXR3YXJkLWZhY2luZykgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudmFsdWVfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLnZhbHVlLCB0aGlzLm1pblZhbHVlXyk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciBtYXhpbXVtIHZhbHVlIHNob3VsZCBiZSBJbmZpbml0eS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzVXBwZXJCb3VuZEluZmluaXRlXyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy51cHBlckJvdW5kSW5maW5pdGUsIGZhbHNlKTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIG1pbmltaW11bSB2YWx1ZSBzaG91bGQgYmUgLUluZmluaXR5LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuaXNMb3dlckJvdW5kSW5maW5pdGVfID0gdXRpbHMudmFsdWVPcihvcHRpb25zLmxvd2VyQm91bmRJbmZpbml0ZSwgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zdGVwXyA9IHV0aWxzLnZhbHVlT3Iob3B0aW9ucy5zdGVwLCAxKTtcbiAgaWYgKHRoaXMuc3RlcF8gPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXRTaW1TbGlkZXIgZG9lcyBub3Qgc3VwcG9ydCB6ZXJvIHN0ZXAgdmFsdWVzLlwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0ZXBfICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldFNpbVNsaWRlciBkb2VzIG5vdCBzdXBwb3J0IG5vbi1pbnRlZ2VyIHN0ZXAgdmFsdWVzLiBcIiArXG4gICAgICAgIFwiIFVzZSBEZWNpbWFsUHJlY2lzaW9uU2xpZGVyIGluc3RlYWQuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBkaXNhYmxlZCBhbmQgbm9uaW50ZXJhY3RhYmxlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuaXNEaXNhYmxlZF8gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMuaXNEaXNhYmxlZCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgY291bnRlciB1c2VkIHRvIGdlbmVyYXRlL3VuaXF1ZWx5IGlkZW50aWZ5IGRpZmZlcmVudCBpbnN0YW5jZXNcbiAqIG9mIHRoaXMgY29tcG9uZW50IG9uIHRoZSBwYWdlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5OZXRTaW1TbGlkZXIudW5pcXVlSURDb3VudGVyID0gMDtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiB0aGUgc3RlcCB2YWx1ZSBpcyBsZXNzIHRoYW4gemVyby5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVNsaWRlci5wcm90b3R5cGUuaXNTdGVwTmVnYXRpdmVfID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zdGVwXyA8IDA7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIHJvb3QgZGl2IHdpdGggbmV3IGVsZW1lbnRzIHJlZmxlY3RpbmcgdGhlIGN1cnJlbnQgc3RhdGVcbiAqL1xuTmV0U2ltU2xpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtaW5WYWx1ZSA9IHRoaXMuaXNMb3dlckJvdW5kSW5maW5pdGVfID8gLUluZmluaXR5IDogdGhpcy5taW5WYWx1ZV87XG4gIHZhciBtYXhWYWx1ZSA9IHRoaXMuaXNVcHBlckJvdW5kSW5maW5pdGVfID8gSW5maW5pdHkgOiB0aGlzLm1heFZhbHVlXztcbiAgdmFyIG1pblBvc2l0aW9uID0gdGhpcy52YWx1ZVRvU2xpZGVyUG9zaXRpb24oXG4gICAgICB0aGlzLmlzU3RlcE5lZ2F0aXZlXygpID8gbWF4VmFsdWUgOiBtaW5WYWx1ZSk7XG4gIHZhciBtYXhQb3NpdGlvbiA9IHRoaXMudmFsdWVUb1NsaWRlclBvc2l0aW9uKFxuICAgICAgdGhpcy5pc1N0ZXBOZWdhdGl2ZV8oKSA/IG1pblZhbHVlIDogbWF4VmFsdWUpO1xuXG4gIHZhciByZW5kZXJlZE1hcmt1cCA9ICQobWFya3VwKHtcbiAgICBpbnN0YW5jZUlEOiB0aGlzLmluc3RhbmNlSURfLFxuICAgIG1pblZhbHVlOiB0aGlzLnZhbHVlVG9TaG9ydExhYmVsKHRoaXMuaXNTdGVwTmVnYXRpdmVfKCkgPyBtYXhWYWx1ZSA6IG1pblZhbHVlKSxcbiAgICBtYXhWYWx1ZTogdGhpcy52YWx1ZVRvU2hvcnRMYWJlbCh0aGlzLmlzU3RlcE5lZ2F0aXZlXygpID8gbWluVmFsdWUgOiBtYXhWYWx1ZSlcbiAgfSkpO1xuICB0aGlzLnJvb3REaXZfLmh0bWwocmVuZGVyZWRNYXJrdXApO1xuXG4gIHRoaXMucm9vdERpdl8uZmluZCgnLnNsaWRlcicpXG4gICAgICAuc2xpZGVyKHtcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVUb1NsaWRlclBvc2l0aW9uKHRoaXMudmFsdWVfKSxcbiAgICAgICAgbWluOiBtaW5Qb3NpdGlvbixcbiAgICAgICAgbWF4OiBtYXhQb3NpdGlvbixcbiAgICAgICAgc3RlcDogTWF0aC5hYnModGhpcy5zdGVwXyksXG4gICAgICAgIHNsaWRlOiB0aGlzLm9uU2xpZGVyVmFsdWVDaGFuZ2VfLmJpbmQodGhpcyksXG4gICAgICAgIHN0b3A6IHRoaXMub25TbGlkZXJTdG9wXy5iaW5kKHRoaXMpLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkX1xuICAgICAgfSk7XG5cbiAgLy8gVXNlIHdpZGVyIGxhYmVscyBpZiB3ZSBoYXZlIGFuIGluZmluaXRlIGJvdW5kXG4gIGlmICh0aGlzLmlzTG93ZXJCb3VuZEluZmluaXRlXyB8fCB0aGlzLmlzVXBwZXJCb3VuZEluZmluaXRlXykge1xuICAgIHRoaXMucm9vdERpdl8uZmluZCgnLnNsaWRlci1sYWJlbHMnKS5hZGRDbGFzcygnd2lkZS1sYWJlbHMnKTtcbiAgfVxuXG4gIHRoaXMuc2V0TGFiZWxGcm9tVmFsdWVfKHRoaXMudmFsdWVfKTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGlzIHNsaWRlciwgc28gdGhlIHVzZXIgY2FuJ3QgY2hhbmdlIGl0cyB2YWx1ZVxuICovXG5OZXRTaW1TbGlkZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNEaXNhYmxlZF8gPSB0cnVlO1xuICB0aGlzLnJvb3REaXZfLmZpbmQoJy5zbGlkZXInKS5zbGlkZXIoJ29wdGlvbicsICdkaXNhYmxlZCcsIHRydWUpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdGhpcyBzbGlkZXIsIHNvIHRoZSB1c2VyIGNhbiBjaGFuZ2UgaXRzIHZhbHVlXG4gKi9cbk5ldFNpbVNsaWRlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzRGlzYWJsZWRfID0gZmFsc2U7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLnNsaWRlcicpLnNsaWRlcignb3B0aW9uJywgJ2Rpc2FibGVkJywgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBFeHRlcm5hbCBhY2Nlc3MgdG8gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlXG4gKi9cbk5ldFNpbVNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgaWYgKHRoaXMudmFsdWVfID09PSBuZXdWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gIHRoaXMucm9vdERpdl8uZmluZCgnLnNsaWRlcicpLnNsaWRlcignb3B0aW9uJywgJ3ZhbHVlJyxcbiAgICAgIHRoaXMudmFsdWVUb1NsaWRlclBvc2l0aW9uKG5ld1ZhbHVlKSk7XG4gIHRoaXMuc2V0TGFiZWxGcm9tVmFsdWVfKG5ld1ZhbHVlKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuTmV0U2ltU2xpZGVyLnByb3RvdHlwZS5vblNsaWRlclZhbHVlQ2hhbmdlXyA9IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcbiAgdmFyIG5ld1ZhbHVlID0gdGhpcy5zbGlkZXJQb3NpdGlvblRvVmFsdWUodWkudmFsdWUpO1xuICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICB0aGlzLnNldExhYmVsRnJvbVZhbHVlXyhuZXdWYWx1ZSk7XG4gIHRoaXMuY2hhbmdlQ2FsbGJhY2tfKG5ld1ZhbHVlKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuTmV0U2ltU2xpZGVyLnByb3RvdHlwZS5vblNsaWRlclN0b3BfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BDYWxsYmFja18odGhpcy52YWx1ZV8pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzbGlkZXIgbGFiZWwgdG8gbG9jYWxpemUgYW5kIGRpc3BsYXkgdGhlIGdpdmVuIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIHNsaWRlciB2YWx1ZSB0byBkaXNwbGF5XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TbGlkZXIucHJvdG90eXBlLnNldExhYmVsRnJvbVZhbHVlXyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdGhpcy5yb290RGl2Xy5maW5kKCcuc2xpZGVyLXZhbHVlJykudGV4dCh0aGlzLnZhbHVlVG9MYWJlbCh2YWwpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZXJuYWwgdmFsdWUgd2UgY2FuIHBhc3MgdG8gdGhlXG4gKiBqUXVlcnlVSSBzbGlkZXIgY29udHJvbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBleHRlcm5hbC1mYWNpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gaW50ZXJuYWwgc2xpZGVyIHZhbHVlXG4gKi9cbk5ldFNpbVNsaWRlci5wcm90b3R5cGUudmFsdWVUb1NsaWRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAodGhpcy5pc1VwcGVyQm91bmRJbmZpbml0ZV8gJiYgdmFsID4gdGhpcy5tYXhWYWx1ZV8pIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVRvU2xpZGVyUG9zaXRpb24odGhpcy5tYXhWYWx1ZV8pICsgdGhpcy5zdGVwXztcbiAgfSBlbHNlIGlmICh0aGlzLmlzTG93ZXJCb3VuZEluZmluaXRlXyAmJiB2YWwgPCB0aGlzLm1pblZhbHVlXykge1xuICAgIHJldHVybiB0aGlzLnZhbHVlVG9TbGlkZXJQb3NpdGlvbih0aGlzLm1pblZhbHVlXykgLSB0aGlzLnN0ZXBfO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCh0aGlzLm1pblZhbHVlXywgTWF0aC5taW4odGhpcy5tYXhWYWx1ZV8sIHZhbCkpICpcbiAgICAgICh0aGlzLmlzU3RlcE5lZ2F0aXZlXygpID8gLTEgOiAxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGludGVybmFsIGpRdWVyeVVJIHNsaWRlciB2YWx1ZSBpbnRvIGFuIGV4dGVybmFsLWZhY2luZ1xuICogdmFsdWUgZm9yIHRoaXMgY29udHJvbC5cbiAqIFNob3VsZCBiZSBhbiBpbnZlcnNlIG9mIHZhbHVlVG9TbGlkZXJQb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyAtIGludGVybmFsIHNsaWRlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gLSBleHRlcm5hbC1mYWNpbmcgdmFsdWVcbiAqL1xuTmV0U2ltU2xpZGVyLnByb3RvdHlwZS5zbGlkZXJQb3NpdGlvblRvVmFsdWUgPSBmdW5jdGlvbiAocG9zKSB7XG4gIGlmICh0aGlzLmlzU3RlcE5lZ2F0aXZlXygpKSB7XG4gICAgaWYgKHBvcyA8IHRoaXMudmFsdWVUb1NsaWRlclBvc2l0aW9uKHRoaXMubWF4VmFsdWVfKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNVcHBlckJvdW5kSW5maW5pdGVfID8gSW5maW5pdHkgOiB0aGlzLm1heFZhbHVlXztcbiAgICB9IGVsc2UgaWYgKHBvcyA+IHRoaXMudmFsdWVUb1NsaWRlclBvc2l0aW9uKHRoaXMubWluVmFsdWVfKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNMb3dlckJvdW5kSW5maW5pdGVfID8gLUluZmluaXR5IDogdGhpcy5taW5WYWx1ZV87XG4gICAgfVxuICAgIHJldHVybiAtcG9zO1xuICB9IGVsc2Uge1xuICAgIGlmIChwb3MgPiB0aGlzLnZhbHVlVG9TbGlkZXJQb3NpdGlvbih0aGlzLm1heFZhbHVlXykpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVXBwZXJCb3VuZEluZmluaXRlXyA/IEluZmluaXR5IDogdGhpcy5tYXhWYWx1ZV87XG4gICAgfSBlbHNlIGlmIChwb3MgPCB0aGlzLnZhbHVlVG9TbGlkZXJQb3NpdGlvbih0aGlzLm1pblZhbHVlXykpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTG93ZXJCb3VuZEluZmluaXRlXyA/IC1JbmZpbml0eSA6IHRoaXMubWluVmFsdWVfO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGV4dGVybmFsLWZhY2luZyBudW1lcmljIHZhbHVlIGludG8gYSBsb2NhbGl6ZWQgc3RyaW5nXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIG51bWVyaWMgdmFsdWUgb2YgdGhlIGNvbnRyb2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICovXG5OZXRTaW1TbGlkZXIucHJvdG90eXBlLnZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gSW5maW5pdHkgfHwgdmFsID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gaTE4bi51bmxpbWl0ZWQoKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBbHRlcm5hdGUgbGFiZWwgY29udmVydGVyLCB1c2VkIGZvciBzbGlkZXIgZW5kIGxhYmVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBudW1lcmljIHZhbHVlIG9mIHRoZSBjb250cm9sXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdmFsdWVcbiAqL1xuTmV0U2ltU2xpZGVyLnByb3RvdHlwZS52YWx1ZVRvU2hvcnRMYWJlbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVUb0xhYmVsKHZhbCk7XG59O1xuXG4vKipcbiAqIFNpbmNlIGpRdWVyeVVJIHNsaWRlcnMgZG9uJ3Qgc3VwcG9ydCBub25pbnRlZ2VyIHN0ZXAgdmFsdWVzLCB0aGlzIGlzXG4gKiBhIHNpbXBsZSBoZWxwZXIgd3JhcHBlZCBhcm91bmQgTmV0U2ltU2xpZGVyIHRoYXQgYWRkcyBzdXBwb3J0IGZvclxuICogZnJhY3Rpb25hbCBzdGVwIHZhbHVlcyBkb3duIHRvIGEgZ2l2ZW4gcHJlY2lzaW9uLlxuICogQHBhcmFtIHtqUXVlcnl9IHJvb3REaXZcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGFrZXMgTmV0U2ltU2xpZGVyIG9wdGlvbnMsIGV4Y2VwdDpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVwXSAtIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEgYXJlIGFsbG93ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucHJlY2lzaW9uXSAtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiBwcmVjaXNpb25cbiAqICAgICAgICB0aGlzIHNsaWRlciBuZWVkcyAoY2FuIG1hdGNoIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaW4geW91clxuICogICAgICAgIHN0ZXAgdmFsdWUpLiAgRGVmYXVsdCAyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbk5ldFNpbVNsaWRlci5EZWNpbWFsUHJlY2lzaW9uU2xpZGVyID0gZnVuY3Rpb24gKHJvb3REaXYsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiBwcmVjaXNpb24gYWRkZWQgdG8gdGhlIGRlZmF1bHQgc2xpZGVyXG4gICAqIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnByZWNpc2lvbl8gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMucHJlY2lzaW9uLCAyKTtcblxuICAvLyBXZSBjb252ZXJ0IHRoZSBnaXZlbiBzdGVwIHZhbHVlIGJ5IHRoZSByZXF1ZXN0ZWQgcHJlY2lzaW9uIGJlZm9yZSBwYXNzaW5nXG4gIC8vIGl0IG9uIHRvIE5ldFNpbVNsaWRlciwgc28gdGhhdCB3ZSBnaXZlIE5ldFNpbVNsaWRlciBhbiBpbnRlZ2VyIHN0ZXAgdmFsdWUuXG4gIG9wdGlvbnMuc3RlcCA9IG9wdGlvbnMuc3RlcCAqIE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbl8pO1xuXG4gIE5ldFNpbVNsaWRlci5jYWxsKHRoaXMsIHJvb3REaXYsIG9wdGlvbnMpO1xufTtcbk5ldFNpbVNsaWRlci5EZWNpbWFsUHJlY2lzaW9uU2xpZGVyLmluaGVyaXRzKE5ldFNpbVNsaWRlcik7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIGV4dGVybmFsLWZhY2luZyB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gLSBpbnRlcm5hbCBzbGlkZXIgdmFsdWVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1TbGlkZXIuRGVjaW1hbFByZWNpc2lvblNsaWRlci5wcm90b3R5cGUudmFsdWVUb1NsaWRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAvLyBVc2UgY2xhbXBpbmcgZnJvbSBwYXJlbnQgY2xhc3MsIHdoaWNoIHNob3VsZCBiZSBhcHBsaWVkIGJlZm9yZSBvdXIgdHJhbnNmb3JtLlxuICByZXR1cm4gTmV0U2ltU2xpZGVyLnByb3RvdHlwZS52YWx1ZVRvU2xpZGVyUG9zaXRpb24uY2FsbCh0aGlzLCB2YWwpICpcbiAgICAgIE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbl8pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgYW4gaW52ZXJzZSBvZiB2YWx1ZVRvU2xpZGVyUG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgLSBpbnRlcm5hbCBzbGlkZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gZXh0ZXJuYWwtZmFjaW5nIHZhbHVlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltU2xpZGVyLkRlY2ltYWxQcmVjaXNpb25TbGlkZXIucHJvdG90eXBlLnNsaWRlclBvc2l0aW9uVG9WYWx1ZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgLy8gVXNlIGNsYW1waW5nIGZyb20gcGFyZW50IGNsYXNzLCB3aGljaCBzaG91bGQgYmUgYXBwbGllZCBiZWZvcmUgb3VyIHRyYW5zZm9ybS5cbiAgcmV0dXJuIE5ldFNpbVNsaWRlci5wcm90b3R5cGUuc2xpZGVyUG9zaXRpb25Ub1ZhbHVlLmNhbGwodGhpcywgcG9zKSAvXG4gICAgICBNYXRoLnBvdygxMCwgdGhpcy5wcmVjaXNpb25fKTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBtaW5pbXVtIG9mIHplcm8gaXMgdXNlbGVzcyB0byBhIGxvZ2FyaXRobWljIHNjYWxlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbnZhciBMT0dBUklUSE1JQ19ERUZBVUxUX01JTl9WQUxVRSA9IDE7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgYSBsb2dhcml0aG1pYyBzY2FsZSBzbGlkZXIgaW5jcmVhc2VzIGJ5IGEgZmFjdG9yIG9mIDJcbiAqIGV2ZXJ5IHN0ZXAuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgTE9HQVJJVEhNSUNfREVGQVVMVF9CQVNFID0gMjtcblxuLyoqXG4gKiBAcGFyYW0ge2pRdWVyeX0gcm9vdERpdlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0YWtlcyBOZXRTaW1TbGlkZXIgb3B0aW9ucywgZXhjZXB0OlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbl0gLSBzYW1lIGFzIGJhc2Ugc2xpZGVyLCBidXQgZGVmYXVsdHMgdG8gMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb2dCYXNlXSAtIGZhY3RvciBieSB3aGljaCB0aGUgdmFsdWUgaW5jcmVhc2VzXG4gKiAgICAgICAgd2l0aCBldmVyeSBzbGlkZXIgc3RlcC4gIERlZmF1bHQgYmFzZSAyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgTmV0U2ltU2xpZGVyXG4gKi9cbk5ldFNpbVNsaWRlci5Mb2dhcml0aG1pY1NsaWRlciA9IGZ1bmN0aW9uIChyb290RGl2LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMubWluID0gdXRpbHMudmFsdWVPcihvcHRpb25zLm1pbiwgTE9HQVJJVEhNSUNfREVGQVVMVF9NSU5fVkFMVUUpO1xuICBOZXRTaW1TbGlkZXIuY2FsbCh0aGlzLCByb290RGl2LCBvcHRpb25zKTtcblxuICAvKipcbiAgICogRmFjdG9yIGJ5IHdoaWNoIHRoZSB2YWx1ZSBpbmNyZWFzZXMgd2l0aCBldmVyeSBzbGlkZXIgc3RlcC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubG9nQmFzZV8gPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMubG9nQmFzZSwgTE9HQVJJVEhNSUNfREVGQVVMVF9CQVNFKTtcblxuICAvKipcbiAgICogUHJlY2FsY3VsYXRlIG5hdHVyYWwgbG9nIG9mIG91ciBiYXNlIHZhbHVlLCBiZWNhdXNlIHdlJ2xsIHVzZSBpdCBhIGxvdC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMubG5Mb2dCYXNlXyA9IE1hdGgubG9nKHRoaXMubG9nQmFzZV8pO1xuXG4gIHRoaXMuY2FsY3VsYXRlU2xpZGVyQm91bmRzXygpO1xufTtcbk5ldFNpbVNsaWRlci5Mb2dhcml0aG1pY1NsaWRlci5pbmhlcml0cyhOZXRTaW1TbGlkZXIpO1xuXG4vKipcbiAqIEZvciB0aGUgbG9nYXJpdGhtaWMgc2xpZGVyLCBpdCdzIGVhc2llc3QgdG8gY2FsY3VsYXRlIHRoZSBzbGlkZXJcbiAqIGJvdW5kYXJ5IHZhbHVlcyBvbmNlIGFuZCB1c2UgdGhlbSBsYXRlci5cbiAqIEBwcml2YXRlXG4gKi9cbk5ldFNpbVNsaWRlci5Mb2dhcml0aG1pY1NsaWRlci5wcm90b3R5cGUuY2FsY3VsYXRlU2xpZGVyQm91bmRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGljayBib3VuZGFyeSBzbGlkZXIgdmFsdWVzXG4gIHRoaXMubWF4U2xpZGVyUG9zaXRpb24gPSB0aGlzLmxvZ0Zsb29yXyh0aGlzLm1heFZhbHVlXyk7XG4gIC8vIEFkZCBhIHN0ZXAgaWYgd2UgZG9uJ3QgYWxyZWFkeSBsYW5kIGV4YWN0bHkgb24gYSBzdGVwLCB0b1xuICAvLyBjb21wZW5zYXRlIGZvciB0aGUgZmxvb3IoKSBvcGVyYXRpb25cbiAgaWYgKE1hdGgucG93KHRoaXMubG9nQmFzZV8sIHRoaXMubWF4U2xpZGVyUG9zaXRpb24pICE9PSB0aGlzLm1heFZhbHVlXykge1xuICAgIHRoaXMubWF4U2xpZGVyUG9zaXRpb24gKz0gdGhpcy5zdGVwXztcbiAgfVxuICB0aGlzLm1pblNsaWRlclBvc2l0aW9uID0gdGhpcy5sb2dGbG9vcl8odGhpcy5taW5WYWx1ZV8pO1xuXG4gIC8vIFBpY2sgaW5maW5pdHkgc2xpZGVyIHZhbHVlc1xuICB0aGlzLmluZmluaXR5U2xpZGVyUG9zaXRpb24gPSB0aGlzLm1heFNsaWRlclBvc2l0aW9uICsgdGhpcy5zdGVwXztcbiAgdGhpcy5uZWdJbmZpbml0eVNsaWRlclBvc2l0aW9uID0gdGhpcy5taW5TbGlkZXJQb3NpdGlvbiAtIHRoaXMuc3RlcF87XG59O1xuXG4vKipcbiAqIENoZWF0ZXIgXCJmbG9vcihsb2dfYmFzZV9uKHgpKVwiIG1ldGhvZCB3aXRoIGEgaGFja3kgd29ya2Fyb3VuZCBmb3JcbiAqIGZsb2F0aW5nLXBvaW50IGVycm9ycy4gIFVzZXMgdGhlIGxvZ2FyaXRobWljIGJhc2UgZmFjdG9yIHRoYXQgdGhlIHNsaWRlclxuICogaXMgY29uZmlndXJlZCBmb3IgKHRoaXMubG9nQmFzZV8pLiBHb29kIGVub3VnaCBmb3IgdGhlIHNsaWRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5OZXRTaW1TbGlkZXIuTG9nYXJpdGhtaWNTbGlkZXIucHJvdG90eXBlLmxvZ0Zsb29yXyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLy8gSmF2YVNjcmlwdCBmbG9hdGluZy1wb2ludCBtYXRoIGNhdXNlcyB0aGlzIGxvZ2FyaXRobSBjYWxjdWxhdGlvbiB0b1xuICAvLyBzb21ldGltZXMgcmV0dXJuIHNsaWdodGx5IGltcHJlY2lzZSB2YWx1ZXMuIEZvciBleGFtcGxlOlxuICAvLyBsb2coMTAwMCkgLyBsb2coMTApID09PSAyLjk5OTk5OTk5OTk5OTk5OTZcbiAgLy8gQWx0aG91Z2ggd2UgdXN1YWxseSB3YW50IHRvIGZsb29yIG5vbmludGVnZXIgdmFsdWVzLCB0aGUgYWJvdmUgY2FsY3VsYXRpb25cbiAgLy8gaXMgc3VwcG9zZWQgdG8gY29tZSBvdXQgYXMgZXhhY3RseSAzLlxuICAvLyBUaGUgZnVkZ2UgZmFjdG9yIGJlbG93IGdpdmVzIGEgdGhyZXNob2xkIGF0IHdoaWNoIHdlIHdpbGwgY2VpbCgpIGEgcmVzdWx0XG4gIC8vIHJhdGhlciB0aGFuIGZsb29yKCkgaXQsIHRvIGFjY291bnQgZm9yIHRoaXMgaW1wcmVjaXNpb24uXG4gIC8vIFRoZSBfcmlnaHRfIHdheSB0byBmaXggdGhpcyBpcyB0byB1c2UgYSBiZXR0ZXIgbnVtYmVyIHR5cGUgbGlrZSBCaWdEZWNpbWFsLFxuICAvLyBidXQgaXQncyBub3QgcmVhbGx5IHdvcnRoIGl0IGZvciB0aGlzIHVzZSBjYXNlLiAgU2l4IGRpZ2l0cyBpcyBtb3JlIHRoYW5cbiAgLy8gZW5vdWdoIHByZWNpc2lvbiBmb3IgdGhlIHNsaWRlciB3aGVuIHdlJ3JlIHRyeWluZyB0byB3b3JrIHdpdGggd2hvbGVcbiAgLy8gbnVtYmVycyBhbnl3YXkuXG4gIHZhciBjZWlsVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICByZXR1cm4gTWF0aC5mbG9vcihjZWlsVGhyZXNob2xkICsgKE1hdGgubG9nKHZhbCkgLyB0aGlzLmxuTG9nQmFzZV8pKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZXJuYWwgdmFsdWUgd2UgY2FuIHBhc3MgdG8gdGhlXG4gKiBqUXVlcnlVSSBzbGlkZXIgY29udHJvbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBleHRlcm5hbC1mYWNpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gaW50ZXJuYWwgc2xpZGVyIHZhbHVlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTmV0U2ltU2xpZGVyLkxvZ2FyaXRobWljU2xpZGVyLnByb3RvdHlwZS52YWx1ZVRvU2xpZGVyUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICh2YWwgPiB0aGlzLm1heFZhbHVlXykge1xuICAgIHJldHVybiB0aGlzLmlzVXBwZXJCb3VuZEluZmluaXRlXyA/XG4gICAgICAgIHRoaXMuaW5maW5pdHlTbGlkZXJQb3NpdGlvbiA6IHRoaXMubWF4U2xpZGVyUG9zaXRpb247XG4gIH0gZWxzZSBpZiAodmFsID09PSB0aGlzLm1heFZhbHVlXykge1xuICAgIHJldHVybiAgdGhpcy5tYXhTbGlkZXJQb3NpdGlvbjtcbiAgfSBlbHNlIGlmICh2YWwgPCB0aGlzLm1pblZhbHVlXykge1xuICAgIHJldHVybiB0aGlzLmlzTG93ZXJCb3VuZEluZmluaXRlXyA/XG4gICAgICAgIHRoaXMubmVnSW5maW5pdHlTbGlkZXJQb3NpdGlvbiA6IHRoaXMubWluU2xpZGVyUG9zaXRpb247XG4gIH0gZWxzZSBpZiAodmFsID09PSB0aGlzLm1pblZhbHVlXykge1xuICAgIHJldHVybiB0aGlzLm1pblNsaWRlclBvc2l0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCh0aGlzLm1pblNsaWRlclBvc2l0aW9uLCB0aGlzLmxvZ0Zsb29yXyh2YWwpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGludGVybmFsIGpRdWVyeVVJIHNsaWRlciB2YWx1ZSBpbnRvIGFuIGV4dGVybmFsLWZhY2luZ1xuICogdmFsdWUgZm9yIHRoaXMgY29udHJvbC5cbiAqIFNob3VsZCBiZSBhbiBpbnZlcnNlIG9mIHZhbHVlVG9TbGlkZXJQb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyAtIGludGVybmFsIHNsaWRlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gLSBleHRlcm5hbC1mYWNpbmcgdmFsdWVcbiAqIEBvdmVycmlkZVxuICovXG5OZXRTaW1TbGlkZXIuTG9nYXJpdGhtaWNTbGlkZXIucHJvdG90eXBlLnNsaWRlclBvc2l0aW9uVG9WYWx1ZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgaWYgKHBvcyA+IHRoaXMubWF4U2xpZGVyUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5pc1VwcGVyQm91bmRJbmZpbml0ZV8gPyBJbmZpbml0eSA6IHRoaXMubWF4VmFsdWVfO1xuICB9IGVsc2UgaWYgKHBvcyA9PT0gdGhpcy5tYXhTbGlkZXJQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm1heFZhbHVlXztcbiAgfSBlbHNlIGlmIChwb3MgPCB0aGlzLm1pblNsaWRlclBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb3dlckJvdW5kSW5maW5pdGVfID8gLUluZmluaXR5IDogdGhpcy5taW5WYWx1ZV87XG4gIH0gZWxzZSBpZiAocG9zID09PSB0aGlzLm1pblNsaWRlclBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubWluVmFsdWVfO1xuICB9XG4gIHJldHVybiBNYXRoLnBvdyh0aGlzLmxvZ0Jhc2VfLCBwb3MpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBpZD1cIm5ldHNpbV9zbGlkZXJfJywgZXNjYXBlKCgxLCAgaW5zdGFuY2VJRCApKSwgJ1wiIGNsYXNzPVwibmV0c2ltLXNsaWRlclwiPlxcbiAgPGRpdiBjbGFzcz1cInNsaWRlci1pbmxpbmUtd3JhcFwiPlxcbiAgICA8ZGl2IGNsYXNzPVwic2xpZGVyXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJzbGlkZXItbGFiZWxzXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cIm1heC12YWx1ZVwiPicsIGVzY2FwZSgoNSwgIG1heFZhbHVlICkpLCAnPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cIm1pbi12YWx1ZVwiPicsIGVzY2FwZSgoNiwgIG1pblZhbHVlICkpLCAnPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cImN1cnJlbnQtdmFsdWVcIj5cXG4gICAgICAgIDxsYWJlbD48c3BhbiBjbGFzcz1cInNsaWRlci12YWx1ZVwiPjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFdyYXBzIE5ldFNpbSBSRVNUIEFQSXMgZm9yIG9wZXJhdGlvbnMgb2YgXCJ0YWJsZXNcIiBhbmQgXCJzaGFyZHMuXCJcbiAqIEBzZWUgbmV0X3NpbV9hcGkucmJcbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4cGFyYW1zOiAzLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOZXRTaW1BcGlFcnJvciA9IHJlcXVpcmUoJy4vTmV0U2ltQXBpRXJyb3InKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnZhciBORVRTSU1fQVBJX0JBU0VfVVJMID0gJy92My9uZXRzaW0nO1xuXG4vKipcbiAqIEBuYW1lIE5ldFNpbVNoYXJkQXBpXG4gKi9cbnZhciBzaGFyZEFwaSA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluaXRpYWxpemVkIE5ldFNpbSBTaGFyZCBBUEkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFyZElEXG4gICAqIEByZXR1cm5zIHtOZXRTaW1TaGFyZEFwaX1cbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24gKHNoYXJkSUQpIHtcbiAgICByZXR1cm4gJC5leHRlbmQoe30sIHNoYXJkQXBpLCB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hhcmQgaWRlbnRpZmllci5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHNoYXJkSUQ6IHNoYXJkSUQsXG5cbiAgICAgIC8qKlxuICAgICAgICogQmVnaW5uaW5nIHBhcnQgb2YgVVJMIGZvciBhbGwgY2FsbHMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBzaGFyZC5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGJhc2VVcmw6IE5FVFNJTV9BUElfQkFTRV9VUkwgKyAnLycgKyBzaGFyZElEXG4gICAgfSk7XG4gIH0sXG5cbiAgbWFrZVRhYmxlQXBpOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIHRhYmxlQXBpLmNyZWF0ZSh0aGlzLnNoYXJkSUQsIHRhYmxlTmFtZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQG5hbWUgTmV0U2ltVGFibGVBcGlcbiAqL1xudmFyIHRhYmxlQXBpID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5pdGlhbGl6ZWQgTmV0U2ltIFRhYmxlIEFQSSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXJkSURcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcmV0dXJucyB7TmV0U2ltVGFibGVBcGl9XG4gICAqL1xuICBjcmVhdGU6IGZ1bmN0aW9uIChzaGFyZElELCB0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gJC5leHRlbmQoe30sIHRhYmxlQXBpLCB7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hhcmQgaWRlbnRpZmllci5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHNoYXJkSUQ6IHNoYXJkSUQsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGFibGUgbmFtZS5cbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHRhYmxlTmFtZTogdGFibGVOYW1lLFxuXG4gICAgICAvKipcbiAgICAgICAqIEJlZ2lubmluZyBwYXJ0IG9mIFVSTCBmb3IgYWxsIGNhbGxzIHRoYXQgaW50ZXJhY3Qgb25seSB3aXRoXG4gICAgICAgKiB0aGlzIHRhYmxlLlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgYmFzZVVybDogTkVUU0lNX0FQSV9CQVNFX1VSTCArICcvJyArIHNoYXJkSUQgKyAnLycgKyB0YWJsZU5hbWVcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVxdWVzdCBhbGwgcm93cyBmcm9tIHRoZSBnaXZlbiB0YWJsZS5cbiAgICogQHBhcmFtIHtOb2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2sgLSBFeHBlY3RlZCByZXN1bHQgaXMgYW4gYXJyYXkgb2ZcbiAgICogICAgICAgIHJvdyBvYmplY3RzLlxuICAgKi9cbiAgYWxsUm93czogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB0aGlzLmJhc2VVcmwsXG4gICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgZGF0YVR5cGU6IFwianNvblwiXG4gICAgfSkuZG9uZShmdW5jdGlvbihkYXRhLCB0ZXh0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uKHJlcXVlc3QsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBOZXRTaW1BcGlFcnJvcihyZXF1ZXN0KSwgbnVsbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYWxsIHJvd3MgaW5jbHVkaW5nIGFuZCBmb2xsb3dpbmcgdGhlIGdpdmVuIHJvdyBJRCBmcm9tIHRoZSB0YWJsZS5cbiAgICogQHBhcmFtIHtpbnR9IHJvd0lEIC0gbG93ZXIgYm91bmQgb24gcm93IElEcyB0byBmZXRjaFxuICAgKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFjayAtIEV4cGVjdGVkIHJlc3VsdCBpcyBhbiBhcnJheSBvZlxuICAgKiAgICAgICAgdGFibGUgcm93cy5cbiAgICovXG4gIGFsbFJvd3NGcm9tSUQ6IGZ1bmN0aW9uKHJvd0lELCBjYWxsYmFjaykge1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6IHRoaXMuYmFzZVVybCArICdAJyArIHJvd0lELFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGRhdGFUeXBlOiBcImpzb25cIlxuICAgIH0pLmRvbmUoZnVuY3Rpb24oZGF0YSwgdGV4dCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSkuZmFpbChmdW5jdGlvbihyZXF1ZXN0LCBzdGF0dXMsIGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhuZXcgTmV0U2ltQXBpRXJyb3IocmVxdWVzdCksIG51bGwpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSByb3cgb3Igcm93cyBpbnRvIHRoZSB0YWJsZS5cbiAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlIC0gZGVzaXJlZCByb3cgY29udGVudHMsIGFzIGVpdGhlciBhblxuICAgKiAgICAgICAgT2JqZWN0IGZvciBhIHNpbmdsZSByb3cgb3IgYW4gQXJyYXkgb2YgT2JqZWN0cyBmb3IgbXVsdGlwbGUuXG4gICAqICAgICAgICBNdXN0IGJlIEpTT04uc3RyaW5naWZ5LWFibGUuXG4gICAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gRXhwZWN0ZWQgcmVzdWx0IGlzIHRoZSBjcmVhdGVkXG4gICAqICAgICAgICByb3cgb2JqZWN0IG9yIG9iamVjdHMgKHdoaWNoIHdpbGwgaW5jbHVkZSBhbiBhc3NpZ25lZCAnaWQnXG4gICAqICAgICAgICBrZXkpLlxuICAgKi9cbiAgY3JlYXRlUm93OiBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YTtcblxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUsIHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdGhpcy5iYXNlVXJsLFxuICAgICAgdHlwZTogXCJwb3N0XCIsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkuZG9uZShmdW5jdGlvbihib2R5LCB0ZXh0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uKHJlcXVlc3QsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBOZXRTaW1BcGlFcnJvcihyZXF1ZXN0KSwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIG11bHRpcGxlIHJvd3MgYXQgb25jZS5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gaWRzIC0gVGhlIHJvdyBJRHMgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFjayAtIEV4cGVjdGVkIHJlc3VsdCBpcyBUUlVFLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luY10gZGVmYXVsdCBUUlVFLlxuICAgKi9cbiAgZGVsZXRlUm93czogZnVuY3Rpb24oaWRzLCBjYWxsYmFjaywgYXN5bmMpIHtcbiAgICBhc3luYyA9IGFzeW5jICE9PSBmYWxzZTsgLy8gYHVuZGVmaW5lZGAgbWFwcyB0byB0cnVlXG5cbiAgICAvLyBHZW5lcmF0ZSBxdWVyeSBzdHJpbmcgaW4gdGhlIGZvcm0gXCJpZFtdPTEmaWRbXT0yJi4uLlwiXG4gICAgdmFyIHF1ZXJ5U3RyaW5nID0gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiAnaWRbXT0nICsgaWQ7XG4gICAgfSkuam9pbignJicpO1xuXG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdGhpcy5iYXNlVXJsICsgJz8nICsgcXVlcnlTdHJpbmcsXG4gICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICBhc3luYzogYXN5bmNcbiAgICB9KS5kb25lKGZ1bmN0aW9uKGRhdGEsIHRleHQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24ocmVxdWVzdCwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgY2FsbGJhY2sobmV3IE5ldFNpbUFwaUVycm9yKHJlcXVlc3QpLCBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgcm93LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgcm93IGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gRXhwZWN0ZWQgcmVzdWx0IGlzIHRoZSByZXF1ZXN0ZWRcbiAgICogICAgICAgIHJvdyBvYmplY3QuXG4gICAqL1xuICBmZXRjaFJvdzogZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdGhpcy5iYXNlVXJsICsgXCIvXCIgKyBpZCxcbiAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICB9KS5kb25lKGZ1bmN0aW9uKGRhdGEsIHRleHQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24ocmVxdWVzdCwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgY2FsbGJhY2sobmV3IE5ldFNpbUFwaUVycm9yKHJlcXVlc3QpLCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIGEgcm93LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgcm93IGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRoZSBuZXcgcm93IGNvbnRlbnRzLlxuICAgKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFjayAtIEV4cGVjdGVkIHJlc3VsdCBpcyB0aGUgbmV3IHJvdyBvYmplY3QuXG4gICAqL1xuICB1cGRhdGVSb3c6IGZ1bmN0aW9uKGlkLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB0aGlzLmJhc2VVcmwgKyBcIi9cIiArIGlkLFxuICAgICAgdHlwZTogXCJwb3N0XCIsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICB9KS5kb25lKGZ1bmN0aW9uKGRhdGEsIHRleHQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24ocmVxdWVzdCwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgY2FsbGJhY2sobmV3IE5ldFNpbUFwaUVycm9yKHJlcXVlc3QpLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgTmV0U2ltIFNoYXJkIEFQSSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIHNoYXJkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcmRJRFxuICAgKiBAcmV0dXJucyB7TmV0U2ltU2hhcmRBcGl9XG4gICAqL1xuICBtYWtlU2hhcmRBcGk6IGZ1bmN0aW9uIChzaGFyZElEKSB7XG4gICAgcmV0dXJuIHNoYXJkQXBpLmNyZWF0ZShzaGFyZElEKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgTmV0U2ltIFRhYmxlIEFQSSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIHNoYXJkIGFuZCB0YWJsZSBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcmRJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gICAqIEByZXR1cm5zIHtOZXRTaW1UYWJsZUFwaX1cbiAgICovXG4gIG1ha2VUYWJsZUFwaTogZnVuY3Rpb24gKHNoYXJkSUQsIHRhYmxlTmFtZSkge1xuICAgIHJldHVybiB0YWJsZUFwaS5jcmVhdGUoc2hhcmRJRCwgdGFibGVOYW1lKTtcbiAgfVxufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IEV4dGVuZGVkIGVycm9yIHR5cGUgcmV0dXJuZWQgZm9yIGZhaWxlZCBpbnRlcmFjdGlvbnMgd2l0aCBOZXRTaW1cbiAqIHNlcnZlciBBUEkgKG5ldF9zaW1fYXBpLnJiKSB0aGF0IGV4dHJhY3RzIGFuZCBleHBvc2VzIGFkZGl0aW9uYWwgZXJyb3IgaW5mby5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi91dGlscycpOyAvLyBwcm92aWRlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0c1xuXG4vKipcbiAqIFNwZWNpYWwgZXJyb3IgdHlwZSBmb3IgZmFpbGVkIHNlcnZlciByZXF1ZXN0cywgd2hpY2ggdHJpZXMgdG8gZXh0cmFjdFxuICogYWRkaXRpb25hbCBlcnJvciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIncyByZXNwb25zZS5cbiAqIEBwYXJhbSB7anFYSFJ9IHJlcXVlc3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xudmFyIE5ldFNpbUFwaUVycm9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5uYW1lID0gJ05ldFNpbUFwaUVycm9yJztcblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5tZXNzYWdlID0gJ1JlcXVlc3QgZmFpbGVkJztcblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZXJyb3IgaW5mb3JtYXRpb24gcmV0dXJuZWQgYnkgdGhlIHNlcnZlciwgd2hpY2ggY2FuIGRyaXZlXG4gICAqIHNwZWNpZmljIHJlc3BvbnNlcyBieSB0aGUgY2xpZW50LlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5fVxuICAgKi9cbiAgdGhpcy5kZXRhaWxzID0gdW5kZWZpbmVkO1xuXG4gIC8vIEF0dGVtcHQgdG8gZXh0cmFjdCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlcXVlc3Qgb2JqZWN0XG4gIGlmIChyZXF1ZXN0KSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ3N0YXR1czogJyArIHJlcXVlc3Quc3RhdHVzICsgJzsgZXJyb3I6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgaWYgKHJlc3BvbnNlLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gcmVzcG9uc2UuZGV0YWlscztcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9ICc7IGRldGFpbHM6ICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldGFpbHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuTmV0U2ltQXBpRXJyb3IuaW5oZXJpdHMoRXJyb3IpO1xuXG4vKipcbiAqIFdheXMgdGhhdCBhIHJvdyBpbnNlcnQgb3BlcmF0aW9uIGNhbiBmYWlsIHZpYSBOZXRTaW1BcGkuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5OZXRTaW1BcGlFcnJvci5WYWxpZGF0aW9uRXJyb3IgPSB7XG4gIE1BTEZPUk1FRDogJ21hbGZvcm1lZCcsXG4gIENPTkZMSUNUOiAnY29uZmxpY3QnLFxuICBMSU1JVF9SRUFDSEVEOiAnbGltaXRfcmVhY2hlZCdcbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBDb250cm9sbGVyIGZvciBjcmVhdGluZyBncm93bC1zdHlsZSBCb290c3RyYXAgYWxlcnRzXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuLyogZ2xvYmFsIHNldFRpbWVvdXQgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vTmV0U2ltQWxlcnQuaHRtbC5lanMnKTtcbnZhciBBcmd1bWVudFV0aWxzID0gcmVxdWlyZSgnLi9Bcmd1bWVudFV0aWxzJyk7XG52YXIgTmV0U2ltTG9nZ2VyID0gcmVxdWlyZSgnLi9OZXRTaW1Mb2dnZXInKTtcblxudmFyIGxvZ2dlciA9IE5ldFNpbUxvZ2dlci5nZXRTaW5nbGV0b24oKTtcblxudmFyIE5ldFNpbUFsZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGVydCBjb250YWluZXIsIG9yIGNyZWF0ZXMgYW5kIGluc2VydHMgb25lIGlmIGl0IGRvZXNcbiAqIG5vdCBleGlzdC4gQWxzbyBhdHRhY2hlcyBhIGNsb3NlIGhhbmRsZXIgc28gdGhlIGNvbnRhaW5lciB3aWxsXG4gKiByZW1vdmUgaXRzZWxmIHdoZW4gaXQgZW1wdGllc1xuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2pRdWVyeX1cbiAqL1xuTmV0U2ltQWxlcnQuZ2V0T3JDcmVhdGVBbGVydENvbnRhaW5lcl8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGVydENvbnRhaW5lciA9ICQoJy5uZXRzaW0tYWxlcnQtY29udGFpbmVyJyk7XG5cbiAgaWYgKGFsZXJ0Q29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsZXJ0Q29udGFpbmVyID0gJCgnPGRpdj4nKS5hZGRDbGFzcyhcIm5ldHNpbS1hbGVydC1jb250YWluZXJcIik7XG4gICAgJCgnI25ldHNpbScpLmFwcGVuZChhbGVydENvbnRhaW5lcik7XG5cbiAgICBhbGVydENvbnRhaW5lci5vbignY2xvc2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJCh0aGlzKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFsZXJ0Q29udGFpbmVyO1xufTtcblxuLyoqXG4gKiBTaW1wbGUgY2hlY2sgdG8gc2VlIGlmIEJvb3RzdHJhcCdzIEFsZXJ0IGZ1bmN0aW9uIGlzIGF0dGFjaGVkIHRvIHRoZVxuICogZ2xvYmFsIGpRdWVyeSBvYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCBib290c3RyYXAncyBgYWxlcnRgIGZ1bmN0aW9uIGlzXG4gKiAgICAgICAgICAgICAgICAgICBsb2FkZWQgYW5kIGF2YWlsYWJsZVxuICovXG5OZXRTaW1BbGVydC5pc0Jvb3RzdHJhcEFsZXJ0TG9hZGVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0eXBlb2YgJCgpLmFsZXJ0ID09PSAnZnVuY3Rpb24nKTtcbn07XG5cbi8qKlxuICogUHJpbWFyeSBhbGVydCBjcmVhdGlvbiBtZXRob2QuIEV4cGVjdHMgYSBib2R5IG9mIGNvbnRlbnQgZm9yIHRoZVxuICogYWxlcnQgYW5kIGEgZmxhdm9yIGZvciB0aGUgYWxlcnQgdHlwZS4gQ2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhIHRpdGxlXG4gKiBhbmQgYSB0aW1lb3V0IHRpbWUuXG4gKlxuICogQHBhcmFtIHtib2R5fSBzdHJpbmdcbiAqIEBwYXJhbSB7Zmxhdm9yfSBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGltZW91dCBUaW1lb3V0IGluIG1zLiBkZWZhdWx0cyB0byA1MDAwLlxuICogQHJldHVybiB7alF1ZXJ5fSB0aGUgY3JlYXRlZCBhbGVydCBlbGVtZW50XG4gKi9cbk5ldFNpbUFsZXJ0LmNyZWF0ZV8gPSBmdW5jdGlvbiAoYm9keSwgZmxhdm9yLCBvcHRpb25zKSB7XG5cbiAgaWYgKCFOZXRTaW1BbGVydC5pc0Jvb3RzdHJhcEFsZXJ0TG9hZGVkXygpKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJCb290c3RyYXAgQWxlcnQgbm90IGxvYWRlZDsgTmV0U2ltQWxlcnQgcmVmdXNpbmcgdG8gY3JlYXRlIGFsZXJ0XCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIEFyZ3VtZW50VXRpbHMudmFsaWRhdGVSZXF1aXJlZChib2R5LCAnYm9keScsIEFyZ3VtZW50VXRpbHMuaXNTdHJpbmcpO1xuICBBcmd1bWVudFV0aWxzLnZhbGlkYXRlUmVxdWlyZWQoZmxhdm9yLCAnZmxhdm9yJywgQXJndW1lbnRVdGlscy5pc1N0cmluZyk7XG4gIG9wdGlvbnMgPSBBcmd1bWVudFV0aWxzLmV4dGVuZE9wdGlvbnNPYmplY3Qob3B0aW9ucyk7XG5cbiAgdmFyICRjb250YWluZXIgPSBOZXRTaW1BbGVydC5nZXRPckNyZWF0ZUFsZXJ0Q29udGFpbmVyXygpO1xuXG4gIHZhciBib290c3RyYXBBbGVydCA9ICQobWFya3VwKHtcbiAgICBmbGF2b3I6IGZsYXZvcixcbiAgICBib2R5OiBib2R5LFxuICAgIHRpdGxlOiBvcHRpb25zLmdldCgndGl0bGUnLCBBcmd1bWVudFV0aWxzLmlzU3RyaW5nKVxuICB9KSk7XG5cbiAgJGNvbnRhaW5lci5hcHBlbmQoYm9vdHN0cmFwQWxlcnQpO1xuICBib290c3RyYXBBbGVydC5hbGVydCgpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGJvb3RzdHJhcEFsZXJ0LmFsZXJ0KCdjbG9zZScpO1xuICB9LCBvcHRpb25zLmdldCgndGltZW91dCcsIEFyZ3VtZW50VXRpbHMuaXNQb3NpdGl2ZU5vbmluZmluaXRlTnVtYmVyLCA1MDAwKSk7XG5cbiAgcmV0dXJuIGJvb3RzdHJhcEFsZXJ0O1xufTtcblxuLyoqIFdyYXBwZXIgbWV0aG9kIHRvIGNhbGwgY3JlYXRlIHdpdGggYW4gXCJhbGVydC13YXJuXCIgZmxhdm9yICovXG5OZXRTaW1BbGVydC53YXJuID0gZnVuY3Rpb24gKGJvZHksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE5ldFNpbUFsZXJ0LmNyZWF0ZV8oYm9keSwgXCJhbGVydC13YXJuXCIsIG9wdGlvbnMpO1xufTtcblxuLyoqIFdyYXBwZXIgbWV0aG9kIHRvIGNhbGwgY3JlYXRlIHdpdGggYW4gXCJhbGVydC1pbmZvXCIgZmxhdm9yICovXG5OZXRTaW1BbGVydC5pbmZvID0gZnVuY3Rpb24gKGJvZHksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE5ldFNpbUFsZXJ0LmNyZWF0ZV8oYm9keSwgXCJhbGVydC1pbmZvXCIsIG9wdGlvbnMpO1xufTtcblxuLyoqIFdyYXBwZXIgbWV0aG9kIHRvIGNhbGwgY3JlYXRlIHdpdGggYW4gXCJhbGVydC1lcnJvclwiIGZsYXZvciAqL1xuTmV0U2ltQWxlcnQuZXJyb3IgPSBmdW5jdGlvbiAoYm9keSwgb3B0aW9ucykge1xuICByZXR1cm4gTmV0U2ltQWxlcnQuY3JlYXRlXyhib2R5LCBcImFsZXJ0LWVycm9yXCIsIG9wdGlvbnMpO1xufTtcblxuLyoqIFdyYXBwZXIgbWV0aG9kIHRvIGNhbGwgY3JlYXRlIHdpdGggYW4gXCJhbGVydC1zdWNjZXNzXCIgZmxhdm9yICovXG5OZXRTaW1BbGVydC5zdWNjZXNzID0gZnVuY3Rpb24gKGJvZHksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE5ldFNpbUFsZXJ0LmNyZWF0ZV8oYm9keSwgXCJhbGVydC1zdWNjZXNzXCIsIG9wdGlvbnMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbiAgLyoqXG4gICAqIEBuYW1lIGJvZHlcbiAgICogQHR5cGUgeyFzdHJpbmd9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmbGF2b3JcbiAgICogQHR5cGUgeyFzdHJpbmd9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbmFtZSB0aXRsZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbjsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJhbGVydCBuZXRzaW0tYWxlcnQgJywgZXNjYXBlKCgxNywgIGZsYXZvciApKSwgJyBmYWRlIGluXCI+XFxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5ldHNpbS1hbGVydC1idXR0b24gY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJhbGVydFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPjxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+PC9idXR0b24+XFxuICAnKTsxOTsgaWYgKHRpdGxlKSB7IDsgYnVmLnB1c2goJzxzdHJvbmc+JywgZXNjYXBlKCgxOSwgIHRpdGxlICkpLCAnPC9zdHJvbmc+Jyk7MTk7IH0gOyBidWYucHVzaCgnXFxuICAnLCBlc2NhcGUoKDIwLCAgYm9keSApKSwgJ1xcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IFByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyBmb3IgY29udmVydGluZyB1c2VyIGRhdGEgYmV0d2VlblxuICogICAgICAgICAgIGRpZmZlcmVudCBlbmNvZGluZ3MsIGFuZCBmb3JtYXR0aW5nIHRob3NlIGVuY29kaW5nczogYmluYXJ5LFxuICogICAgICAgICAgIGhleCwgZGVjaW1hbCwgQVNDSUkuICBcIkEgYW5kIEJcIiBpcyBhIHNwZWNpYWwgZW5jb2RpbmcgdGhhdCBpc1xuICogICAgICAgICAgIGp1c3QgYmluYXJ5IHdpdGggXCJBXCIgc3ViJ2QgZm9yIDAgYW5kIFwiQlwiIHN1YidkIGZvciAxLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4cGFyYW1zOiAzLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgd2luZG93ICovXG4vKiBnbG9iYWwgcmVxdWlyZSAqL1xuLyogZ2xvYmFsIGV4cG9ydHMgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTsgLy8gRm9yIFN0cmluZy5wcm90b3R5cGUucmVwZWF0IHBvbHlmaWxsXG52YXIgTmV0U2ltVXRpbHMgPSByZXF1aXJlKCcuL05ldFNpbVV0aWxzJyk7XG5cbi8vIHdpbmRvdy57YnRvYSwgYXRvYn0gcG9seWZpbGxzXG5pZiAoISh3aW5kb3cuYXRvYiAmJiB3aW5kb3cuYnRvYSkpIHtcbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJ0Jhc2U2NCcpO1xuICB3aW5kb3cuYnRvYSA9IHdpbmRvdy5idG9hIHx8IGJhc2U2NC5idG9hO1xuICB3aW5kb3cuYXRvYiA9IHdpbmRvdy5hdG9iIHx8IGJhc2U2NC5hdG9iO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEFkZHJlc3NIZWFkZXJGb3JtYXRcbiAqIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHBhcnRzIG9mIGFuIGFkZHJlc3MgZmllbGQgaW4gdGhlIHBhY2tldCBoZWFkZXIsXG4gKiB0aGVpciByZXNwZWN0aXZlIGJ5dGUtd2lkdGhzLCBhbmQgdGhlIHNlcGFyYXRvcnMgdG8gYmUgdXNlZCB3aGVuIGNvbnZlcnRpbmdcbiAqIGJpbmFyeSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAqIEV4YW1wbGVzOlxuICogXCI0XCIgaW5kaWNhdGVzIGEgc2luZ2xlIDQtYnl0ZSBudW1iZXIsIGUuZy4gNSAvIDAxMDFcbiAqIFwiOC40XCIgaW5kaWNhdGVzIGFuIDgtYnl0ZSBudW1iZXIgZm9sbG93ZWQgYnkgYSA0LWJ5dGUgbnVtYmVyLCBzZXBhcmF0ZWRcbiAqICAgYnkgYSBwZXJpb2QsIGUuZy4gMS4xIC8gMDAwMDAwMDEwMDAxIG9yIDE4LjkgLyAwMDAxMDAxMCAxMDAxXG4gKiBcIjguOC44LjhcIiB3b3VsZCBiZSBhbiBJUHY0IGFkZHJlc3MsIGUuZy5cbiAqICAgMTI3LjAuMC4xIC8gMDExMTExMTEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFzIGFuZCBCcyBzdHJpbmcgaW50byBpdHMgbW9zdCBjb21wYWN0IHJlcHJlc2VudGF0aW9uLCBmb3JjZWRcbiAqIHRvIHVwcGVyY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhYlN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5taW5pZnlBQiA9IGZ1bmN0aW9uIChhYlN0cmluZykge1xuICByZXR1cm4gYWJTdHJpbmcucmVwbGFjZSgvW15BQl0vZ2ksICcnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBQi1iaW5hcnkgc3RyaW5nIHRvIGEgZm9ybWF0dGVkIHJlcHJlc2VudGF0aW9uLCB3aXRoIGNodW5rc1xuICogb2YgYSBzZXQgc2l6ZSBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhYlN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIGJpdC1vZmZzZXQgZm9yIGZvcm1hdHRpbmcgZWZmZWN0OyBkZWZhdWx0IDAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmVyc2lvblxuICovXG5leHBvcnRzLmZvcm1hdEFCID0gZnVuY3Rpb24gKGFiU3RyaW5nLCBjaHVua1NpemUsIG9mZnNldCkge1xuICByZXR1cm4gZXhwb3J0cy5mb3JtYXRCaW5hcnkoZXhwb3J0cy5hYlRvQmluYXJ5KGFiU3RyaW5nKSwgY2h1bmtTaXplLCBvZmZzZXQpXG4gICAgICAucmVwbGFjZSgvMC9nLCAnQScpXG4gICAgICAucmVwbGFjZSgvMS9nLCAnQicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgaW50byBpdHMgbW9zdCBjb21wYWN0IHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlTdHJpbmcgdGhhdCBtYXkgY29udGFpbiB3aGl0ZXNwYWNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgc3RyaW5nIHdpdGggbm8gd2hpdGVzcGFjZVxuICovXG5leHBvcnRzLm1pbmlmeUJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcpIHtcbiAgcmV0dXJuIGJpbmFyeVN0cmluZy5yZXBsYWNlKC9bXjAxXS9nLCAnJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmluYXJ5IHN0cmluZyB0byBhIGZvcm1hdHRlZCByZXByZXNlbnRhdGlvbiwgd2l0aCBjaHVua3Mgb2ZcbiAqIGEgc2V0IHNpemUgc2VwYXJhdGVkIGJ5IGEgc3BhY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5U3RyaW5nIC0gbWF5IGJlIHVuZm9ybWF0dGVkIGFscmVhZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgLSBob3cgbWFueSBiaXRzIHBlciBmb3JtYXQgY2h1bmtcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBiaXQtb2Zmc2V0IGZvciBmb3JtYXR0aW5nIGVmZmVjdDsgZGVmYXVsdCAwLlxuICogQHJldHVybnMge3N0cmluZ30gcHJldHR5IGZvcm1hdHRlZCBiaW5hcnkgc3RyaW5nXG4gKi9cbmV4cG9ydHMuZm9ybWF0QmluYXJ5ID0gZnVuY3Rpb24gKGJpbmFyeVN0cmluZywgY2h1bmtTaXplLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gdXRpbHMudmFsdWVPcihvZmZzZXQsIDApO1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBhcmFtZXRlciBjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyb1wiKTtcbiAgfVxuXG4gIHZhciBiaW5hcnkgPSBleHBvcnRzLm1pbmlmeUJpbmFyeShiaW5hcnlTdHJpbmcpO1xuXG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIGZpcnN0Q2h1bmtMZW5ndGggPSB1dGlscy5tb2Qob2Zmc2V0LCBjaHVua1NpemUpO1xuICBpZiAoZmlyc3RDaHVua0xlbmd0aCA+IDApIHtcbiAgICBjaHVua3MucHVzaChiaW5hcnkuc3Vic3RyKDAsIGZpcnN0Q2h1bmtMZW5ndGgpKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBmaXJzdENodW5rTGVuZ3RoOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICBjaHVua3MucHVzaChiaW5hcnkuc3Vic3RyKGksIGNodW5rU2l6ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rcy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGludG8gaXRzIG1vc3QgY29tcGFjdCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBTdHJpcHMgd2hpdGVzcGFjZSBhbmQgbm9uLWhleCBjaGFyYWN0ZXJzLCBhbmQgY29lcmNlcyBsZXR0ZXJzIHRvIHVwcGVyY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMubWluaWZ5SGV4ID0gZnVuY3Rpb24gKGhleFN0cmluZykge1xuICByZXR1cm4gaGV4U3RyaW5nLnJlcGxhY2UoL1teMC05QS1GXS9naSwgJycpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFJlZHVjZXMgYWxsIHdoaXRlc3BhY2UgdG8gc2luZ2xlIGNoYXJhY3RlcnMgYW5kIHN0cmlwcyBub24tZGlnaXRzLlxuICogQHBhcmFtIGRlY2ltYWxTdHJpbmdcbiAqL1xuZXhwb3J0cy5taW5pZnlEZWNpbWFsID0gZnVuY3Rpb24gKGRlY2ltYWxTdHJpbmcpIHtcbiAgcmV0dXJuIGRlY2ltYWxTdHJpbmcucmVwbGFjZSgvKF5cXHMrfFxccyskfFteMC05XFxzXSkvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgZm9ybWF0dGVkIHJlcHJlc2VudGF0aW9uLCB3aXRoIGNodW5rcyBvZlxuICogYSBzZXQgc2l6ZSBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgLSBpbiBiaXRzIVxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIGhleC1kaWdpdC1vZmZzZXQgZm9yIGZvcm1hdHRpbmcgZWZmZWN0OyBkZWZhdWx0IDAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgaGV4XG4gKi9cbmV4cG9ydHMuZm9ybWF0SGV4ID0gZnVuY3Rpb24gKGhleFN0cmluZywgY2h1bmtTaXplLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gdXRpbHMudmFsdWVPcihvZmZzZXQsIDApO1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBhcmFtZXRlciBjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyb1wiKTtcbiAgfVxuXG4gIC8vIERvbid0IGZvcm1hdCBoZXggd2hlbiB0aGUgY2h1bmtTaXplIGRvZXNuJ3QgYWxpZ24gd2l0aCBoZXggY2hhcmFjdGVycy5cbiAgaWYgKGNodW5rU2l6ZSAlIDQgIT09IDApIHtcbiAgICByZXR1cm4gaGV4U3RyaW5nO1xuICB9XG5cbiAgdmFyIGhleENodW5rU2l6ZSA9IGNodW5rU2l6ZSAvIDQ7XG4gIHZhciBoZXggPSBleHBvcnRzLm1pbmlmeUhleChoZXhTdHJpbmcpO1xuXG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIGZpcnN0Q2h1bmtMZW5ndGggPSB1dGlscy5tb2Qob2Zmc2V0LCBoZXhDaHVua1NpemUpO1xuICBpZiAoZmlyc3RDaHVua0xlbmd0aCA+IDApIHtcbiAgICBjaHVua3MucHVzaChoZXguc3Vic3RyKDAsIGZpcnN0Q2h1bmtMZW5ndGgpKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBmaXJzdENodW5rTGVuZ3RoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSBoZXhDaHVua1NpemUpIHtcbiAgICBjaHVua3MucHVzaChoZXguc3Vic3RyKGksIGhleENodW5rU2l6ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rcy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHdoaXRlc3BhY2Utc2VwYXJhdGVkIG51bWJlcnMgYW5kIHBhZHMgdGhlIHNwYWNpbmcgYmV0d2VlblxuICogdGhlbSB0byB0aGUgd2lkdGggb2YgdGhlIHdpZGVzdCBudW1iZXIsIHNvIHRoYXQgdGhleSBsaW5lIHVwIHdoZW4gdGhleVxuICogd3JhcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsU3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhbGlnbmVkIGRlY2ltYWwgc3RyaW5nXG4gKi9cbmV4cG9ydHMuYWxpZ25EZWNpbWFsID0gZnVuY3Rpb24gKGRlY2ltYWxTdHJpbmcpIHtcbiAgaWYgKGRlY2ltYWxTdHJpbmcucmVwbGFjZSgvXFxEL2csICcnKSA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbnVtYmVycyA9IGV4cG9ydHMubWluaWZ5RGVjaW1hbChkZWNpbWFsU3RyaW5nKS5zcGxpdCgvXFxzKy8pO1xuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBudW1iZXJcbiAgdmFyIG1vc3REaWdpdHMgPSBudW1iZXJzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBpZiAoY3VyLmxlbmd0aCA+IHByZXYpIHtcbiAgICAgIHJldHVybiBjdXIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcHJldjtcbiAgfSwgMCk7XG5cbiAgdmFyIHplcm9QYWRkaW5nID0gJzAnLnJlcGVhdChtb3N0RGlnaXRzKTtcblxuICByZXR1cm4gbnVtYmVycy5tYXAoZnVuY3Rpb24gKG51bVN0cmluZykge1xuICAgIC8vIExlZnQtcGFkIGVhY2ggbnVtYmVyIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB1cCB0byBtYXggd2lkdGguXG4gICAgcmV0dXJuICh6ZXJvUGFkZGluZyArIG51bVN0cmluZykuc2xpY2UoLW1vc3REaWdpdHMpO1xuICB9KS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIEludGVycHJldHMgYSBzdHJpbmcgb2YgQXMgYW5kIEJzIGFzIGJpbmFyeSB3aGVyZSBBIGlzIDAgYW5kIEIgaXMgMSwgdGhlblxuICogaW50ZXJwcmV0cyB0aGF0IGJpbmFyeSBhcyBhIHNpbmdsZSBudW1iZXIsIGFuZCByZXR1cm5zIHRoYXQgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGFiU3RyaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmFiVG9JbnQgPSBmdW5jdGlvbiAoYWJTdHJpbmcpIHtcbiAgcmV0dXJuIGV4cG9ydHMuYmluYXJ5VG9JbnQoZXhwb3J0cy5hYlRvQmluYXJ5KGFiU3RyaW5nKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGFuIEFCIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmludFRvQUIgPSBmdW5jdGlvbiAobnVtLCB3aWR0aCkge1xuICByZXR1cm4gZXhwb3J0cy5iaW5hcnlUb0FCKGV4cG9ydHMuaW50VG9CaW5hcnkobnVtLCB3aWR0aCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBBcyBhbmQgQnMgdG8gYSBiaW5hcnkgc3RyaW5nLCB3aGVyZSBBIGlzIDAgYW5kIEIgaXMgMS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhYlN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5hYlRvQmluYXJ5ID0gZnVuY3Rpb24gKGFiU3RyaW5nKSB7XG4gIHJldHVybiBleHBvcnRzLm1pbmlmeUFCKGFiU3RyaW5nKS5yZXBsYWNlKC9BL2csICcwJykucmVwbGFjZSgvQi9nLCAnMScpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBiaW5hcnkgaW50byBBcyBhbmQgQnMsIHdoZXJlIDAgaXMgQSBhbmQgMSBpcyBCLlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5iaW5hcnlUb0FCID0gZnVuY3Rpb24gKGJpbmFyeVN0cmluZykge1xuICByZXR1cm4gZXhwb3J0cy5taW5pZnlCaW5hcnkoYmluYXJ5U3RyaW5nKS5yZXBsYWNlKC8wL2csICdBJykucmVwbGFjZSgvMS9nLCAnQicpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYmluYXJ5IHN0cmluZyBhcyBhIHNpbmdsZSBudW1iZXIsIGFuZCByZXR1cm5zIHRoYXQgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVN0cmluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5iaW5hcnlUb0ludCA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGV4cG9ydHMubWluaWZ5QmluYXJ5KGJpbmFyeVN0cmluZyksIDIpO1xufTtcblxudmFyIGludFRvU3RyaW5nID0gZnVuY3Rpb24gKGludCwgYmFzZSwgd2lkdGgpIHtcbiAgaWYgKHdpZHRoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dHB1dCB3aWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXCIpO1xuICB9XG4gIHJldHVybiBOZXRTaW1VdGlscy56ZXJvUGFkTGVmdChpbnQudG9TdHJpbmcoYmFzZSksIHdpZHRoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBiaW5hcnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHdpdGggdGhlIGdpdmVuIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGludCAtIG51bWJlciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBudW1iZXIgb2YgYml0cyB0byB1c2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gYmluYXJ5IHJlcHJlc2VudGF0aW9uIHdpdGggbGVuZ3RoIG9mIFwid2lkdGhcIlxuICovXG5leHBvcnRzLmludFRvQmluYXJ5ID0gZnVuY3Rpb24gKGludCwgd2lkdGgpIHtcbiAgcmV0dXJuIGludFRvU3RyaW5nKGludCwgMiwgd2lkdGgpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgaGV4IHN0cmluZyBhcyBhIHNpbmdsZSBudW1iZXIsIGFuZCByZXR1cm5zIHRoYXQgbnVtYmVyLlxuICogQHBhcmFtIGhleGFkZWNpbWFsU3RyaW5nXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnRzLmhleFRvSW50ID0gZnVuY3Rpb24gKGhleGFkZWNpbWFsU3RyaW5nKSB7XG4gIHJldHVybiBwYXJzZUludChleHBvcnRzLm1pbmlmeUhleChoZXhhZGVjaW1hbFN0cmluZyksIDE2KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW5cbiAqIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGludCAtIG51bWJlciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byB1c2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gaGV4IHJlcHJlc2VudGF0aW9uIHdpdGggbGVuZ3RoIG9mIFwid2lkdGhcIlxuICovXG5leHBvcnRzLmludFRvSGV4ID0gZnVuY3Rpb24gKGludCwgd2lkdGgpIHtcbiAgcmV0dXJuIGludFRvU3RyaW5nKGludCwgMTYsIHdpZHRoKS50b1VwcGVyQ2FzZSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLCBieSBtYXBwaW5nIGVhY2ggaGV4IGNoYXJhY3RlclxuICogdG8gZm91ciBiaXRzIG9mIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhhZGVjaW1hbFN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gYmluYXJ5IHJlcHJlc2VudGF0aW9uLlxuICovXG5leHBvcnRzLmhleFRvQmluYXJ5ID0gZnVuY3Rpb24gKGhleGFkZWNpbWFsU3RyaW5nKSB7XG4gIHZhciB1Z2x5SGV4ID0gZXhwb3J0cy5taW5pZnlIZXgoaGV4YWRlY2ltYWxTdHJpbmcpO1xuICB2YXIgYmluYXJ5ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1Z2x5SGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IGV4cG9ydHMuaW50VG9CaW5hcnkoZXhwb3J0cy5oZXhUb0ludCh1Z2x5SGV4LnN1YnN0cihpLCAxKSksIDQpO1xuICB9XG5cbiAgcmV0dXJuIGJpbmFyeTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiaW5hcnkgc3RyaW5nIHRvIGEgaGV4IHN0cmluZywgbWFwcGluZyBlYWNoIGZvdXIgYml0cyBpbnRvXG4gKiBhIGhleCBjaGFyYWN0ZXIgYW5kIHJpZ2h0LXBhZGRpbmcgd2l0aCB6ZXJvZXMgdG8gcm91bmQgb3V0IHRoZSBiaW5hcnkgbGVuZ3RoLlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5iaW5hcnlUb0hleCA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcpIHtcbiAgdmFyIGN1cnJlbnROaWJibGU7XG4gIHZhciBuaWJibGVXaWR0aCA9IDQ7XG4gIHZhciBjaGFycyA9IFtdO1xuICB2YXIgdWdseUJpbmFyeSA9IGV4cG9ydHMubWluaWZ5QmluYXJ5KGJpbmFyeVN0cmluZyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdWdseUJpbmFyeS5sZW5ndGg7IGkgKz0gbmliYmxlV2lkdGgpIHtcbiAgICBjdXJyZW50TmliYmxlID0gTmV0U2ltVXRpbHMuemVyb1BhZFJpZ2h0KFxuICAgICAgICB1Z2x5QmluYXJ5LnN1YnN0cihpLCBuaWJibGVXaWR0aCksIG5pYmJsZVdpZHRoKTtcbiAgICBjaGFycy5wdXNoKGV4cG9ydHMuaW50VG9IZXgoZXhwb3J0cy5iaW5hcnlUb0ludChjdXJyZW50TmliYmxlKSwgMSkpO1xuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgc2V0IG9mIG51bWJlcnMgdG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhvc2UgbnVtYmVyc1xuICogdXNpbmcgdGhlIGdpdmVuIGJ5dGUtc2l6ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsU3RyaW5nIC0gQSBzZXQgb2YgbnVtYmVycyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlU2l6ZSAtIEhvdyBtYW55IGJpdHMgdG8gdXNlIHRvIHJlcHJlc2VudCBlYWNoIG51bWJlci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0cy5kZWNpbWFsVG9CaW5hcnkgPSBmdW5jdGlvbiAoZGVjaW1hbFN0cmluZywgYnl0ZVNpemUpIHtcbiAgLy8gU3BlY2lhbCBjYXNlOiBObyBudW1iZXJzXG4gIGlmIChkZWNpbWFsU3RyaW5nLnJlcGxhY2UoL1xcRC9nLCAnJykgPT09ICcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMubWluaWZ5RGVjaW1hbChkZWNpbWFsU3RyaW5nKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKG51bVN0cmluZykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5pbnRUb0JpbmFyeShwYXJzZUludChudW1TdHJpbmcsIDEwKSwgYnl0ZVNpemUpO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYmluYXJ5IHRvIGEgc3RyaW5nIG9mIGRlY2ltYWwgbnVtYmVycyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlU2l6ZSAtIEhvdyBtYW55IGJpdHMgdG8gcmVhZCBmb3IgZWFjaCBudW1iZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGRlY2ltYWwgbnVtYmVyc1xuICovXG5leHBvcnRzLmJpbmFyeVRvRGVjaW1hbCA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcsIGJ5dGVTaXplKSB7XG4gIHZhciBjdXJyZW50Qnl0ZTtcbiAgdmFyIG51bWJlcnMgPSBbXTtcbiAgdmFyIGJpbmFyeSA9IGV4cG9ydHMubWluaWZ5QmluYXJ5KGJpbmFyeVN0cmluZyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSArPSBieXRlU2l6ZSkge1xuICAgIGN1cnJlbnRCeXRlID0gTmV0U2ltVXRpbHMuemVyb1BhZFJpZ2h0KGJpbmFyeS5zdWJzdHIoaSwgYnl0ZVNpemUpLCBieXRlU2l6ZSk7XG4gICAgbnVtYmVycy5wdXNoKGV4cG9ydHMuYmluYXJ5VG9JbnQoY3VycmVudEJ5dGUpKTtcbiAgfVxuICByZXR1cm4gbnVtYmVycy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFzY2lpIHRvIGJpbmFyeSwgdXNpbmcgdGhlIGdpdmVuIGJ5dGVzaXplIGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqIE92ZXJmbG93IGlzIGlnbm9yZWQgKGxlZnQtdHJpbW1lZCk7IHJlY29tbWVuZCB1c2luZyBhIGJ5dGVzaXplIG9mIDggaW5cbiAqIG1vc3QgY2lyY3Vtc3RhbmNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhc2NpaVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVTaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmFzY2lpVG9CaW5hcnkgPSBmdW5jdGlvbiAoYXNjaWlTdHJpbmcsIGJ5dGVTaXplKSB7XG4gIHZhciBieXRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFzY2lpU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXMucHVzaChleHBvcnRzLmludFRvQmluYXJ5KGFzY2lpU3RyaW5nLmNoYXJDb2RlQXQoaSksIGJ5dGVTaXplKSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBiaW5hcnkgdG8gYW4gYXNjaWkgc3RyaW5nLCB1c2luZyB0aGUgZ2l2ZW4gYnl0ZXNpemUgZm9yIGVhY2hcbiAqIGNoYXJhY3Rlci4gIElmIHRoZSBiaW5hcnkgaXMgbm90IGRpdmlzaWJsZSBieSBieXRlc2l6ZSwgdGhlIGZpbmFsIGNoYXJhY3RlclxuICogaXMgcmlnaHQtcGFkZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVTaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBU0NJSSBzdHJpbmdcbiAqL1xuZXhwb3J0cy5iaW5hcnlUb0FzY2lpID0gZnVuY3Rpb24gKGJpbmFyeVN0cmluZywgYnl0ZVNpemUpIHtcbiAgaWYgKGJ5dGVTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBhcmFtZXRlciBieXRlU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXCIpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRCeXRlO1xuICB2YXIgY2hhcnMgPSBbXTtcbiAgdmFyIGJpbmFyeSA9IGV4cG9ydHMubWluaWZ5QmluYXJ5KGJpbmFyeVN0cmluZyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSArPSBieXRlU2l6ZSkge1xuICAgIGN1cnJlbnRCeXRlID0gTmV0U2ltVXRpbHMuemVyb1BhZFJpZ2h0KGJpbmFyeS5zdWJzdHIoaSwgYnl0ZVNpemUpLCBieXRlU2l6ZSk7XG4gICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGV4cG9ydHMuYmluYXJ5VG9JbnQoY3VycmVudEJ5dGUpKSk7XG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCYXNlNjRQYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RyaW5nIC0gdGhlIGJhc2U2NC1lbmNvZGVkIHBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW4gLSB0aGUgbGVuZ3RoIG9mIHRoZSBvcmlnaW5hbCBiaW5hcnkgcGF5bG9hZFxuICovXG5cbi8qKlxuICogQ29udmVydHMgYmluYXJ5IHRvIGEgYmFzZTY0IHN0cmluZyBmb3IgbW9yZSBlZmZpY2llbnQgbmV0d29ya1xuICogdHJhbnNmZXIuIEJlY2F1c2UgYmFzZTY0IGV4cGVjdHMgZXZlbiBieXRlcywgd2UgcGFkIHRoZSBiaW5hcnkgc3RyaW5nXG4gKiB0byB0aGUgbmVhcmVzdCBieXRlIGFuZCByZXR1cm4gdGhlIG9yaWdpbmFsIGxlbmd0aC4gVGhlIHJldmVyc2VcbiAqIGNvbnZlcnNpb24gZXhwZWN0cyB0byBiZSBnaXZlbiB0aGF0IG9yaWdpbmFsIGxlbmd0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlTdHJpbmdcbiAqIEByZXR1cm5zIHtCYXNlNjRQYXlsb2FkfSBPYmplY3QgY29udGFpbmluZyB0aGUgYmFzZTY0IHN0cmluZyBhbmQgdGhlXG4gKiAgICAgICAgICBsZW5ndGggb2Ygb2YgdGhlIG9yaWdpbmFsIGJpbmFyeVN0cmluZ1xuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBiaW5hcnlTdHJpbmcgYXJndW1lbnQgaXMgbm90IGFcbiAqICAgICAgICAgcHJvcGVybHktZm9ybWF0dGVkIHN0cmluZyBvZiB6ZXJvZXMgYW5kIG9uZXMuXG4gKiBAZXhhbXBsZVxuICogLy8gcmV0dXJucyB7IHN0cmluZzogXCJrZz09XCIsIGxlbjogNyB9XG4gKiBEYXRhQ29udmVydGVycy5iaW5hcnlUb0Jhc2U2NChcIjEwMDEwMDFcIik7XG4gKi9cbmV4cG9ydHMuYmluYXJ5VG9CYXNlNjQgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nKSB7XG5cbiAgaWYgKC9eWzAxXSokLy50ZXN0KGJpbmFyeVN0cmluZykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGJpbmFyeVN0cmluZyB0byBtZXRob2QgYmluYXJ5VG9CYXNlNjRcIiArXG4gICAgICBcIm11c3QgYmUgYSBiaW5hcnkgc3RyaW5nOyByZWNlaXZlZCBcXFwiXCIgKyBiaW5hcnlTdHJpbmcgKyBcIlxcXCIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHZhciBieXRlTGVuID0gTWF0aC5jZWlsKGJpbmFyeVN0cmluZy5sZW5ndGgvOC4wKSAqIDg7XG4gIHZhciBwYWRkZWRCaW5hcnlTdHJpbmcgPSBOZXRTaW1VdGlscy56ZXJvUGFkUmlnaHQoYmluYXJ5U3RyaW5nLCBieXRlTGVuKTtcbiAgdmFyIHBheWxvYWQgPSB3aW5kb3cuYnRvYShleHBvcnRzLmJpbmFyeVRvQXNjaWkocGFkZGVkQmluYXJ5U3RyaW5nLCA4KSk7XG5cbiAgcmV0dXJuIHsgc3RyaW5nOiBwYXlsb2FkLCBsZW46IGJpbmFyeVN0cmluZy5sZW5ndGggfTtcblxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U2NCBzdHJpbmcgYmFjayBpbnRvIGEgYmluYXJ5IHN0cmluZyBvZiB0aGUgc3BlY2lmaWVkXG4gKiBsZW5ndGguXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0c3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnlTdHJpbmdcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgYmFzZTY0c3RyaW5nIGFyZ3VtZW50IGlzIG5vdCBhXG4gKiAgICAgICAgIHByb3Blcmx5IGJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgXCIxMDAxMDAxXCJcbiAqIERhdGFDb252ZXJ0ZXJzLmJhc2U2NFRvQmluYXJ5KFwia2c9PVwiLCA3KTtcbiAqL1xuZXhwb3J0cy5iYXNlNjRUb0JpbmFyeSA9IGZ1bmN0aW9uIChiYXNlNjRzdHJpbmcsIGxlbikge1xuICB2YXIgZGVjb2RlZERhdGE7XG4gIHRyeSB7XG4gICAgZGVjb2RlZERhdGEgPSB3aW5kb3cuYXRvYihiYXNlNjRzdHJpbmcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGJhc2U2NHN0cmluZyB0byBtZXRob2QgYmFzZTY0VG9CaW5hcnlcIiArXG4gICAgICAgIFwibXVzdCBiZSBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZ1wiKTtcbiAgfVxuICByZXR1cm4gZXhwb3J0cy5hc2NpaVRvQmluYXJ5KGRlY29kZWREYXRhLCA4KS5zdWJzdHIoMCwgbGVuKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYmluYXJ5IHRvIGFuIGFkZHJlc3Mgc3RyaW5nIHVzaW5nIHRoZSBwcm92aWRlZCBhZGRyZXNzIGZvcm1hdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlTdHJpbmdcbiAqIEBwYXJhbSB7QWRkcmVzc0hlYWRlckZvcm1hdH0gYWRkcmVzc0Zvcm1hdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5iaW5hcnlUb0FkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nLCBhZGRyZXNzRm9ybWF0KSB7XG4gIHZhciBiaW5hcnkgPSBleHBvcnRzLm1pbmlmeUJpbmFyeShiaW5hcnlTdHJpbmcpO1xuICBpZiAoYmluYXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpbmRleEludG9CaW5hcnkgPSAwO1xuXG4gIC8vIFBhcmVudGhlc2VzIGluIHRoZSBzcGxpdCgpIHJlZ2V4IGNhdXNlIHRoZSBkaXZpZGluZyBlbGVtZW50cyB0byBiZSBjYXB0dXJlZFxuICAvLyBhbmQgYWxzbyBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuIHZhbHVlLlxuICByZXR1cm4gYWRkcmVzc0Zvcm1hdC5zcGxpdCgvKFxcRCspLykubWFwKGZ1bmN0aW9uIChmb3JtYXRQYXJ0KSB7XG4gICAgdmFyIGJpdFdpZHRoID0gcGFyc2VJbnQoZm9ybWF0UGFydCwgMTApO1xuICAgIGlmIChpc05hTihiaXRXaWR0aCkpIHtcbiAgICAgIC8vIFBhc3Mgbm9uLW51bWJlciBwYXJ0cyBvZiB0aGUgZm9ybWF0IHRocm91Z2gsIHNvIHdlIHVzZSB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGVudGVyZWQgY2hhcmFjdGVycy9sYXlvdXQgZm9yIGZvcm1hdHRpbmcuXG4gICAgICByZXR1cm4gZm9ybWF0UGFydDtcbiAgICB9XG5cbiAgICB2YXIgYmluYXJ5U2xpY2UgPSBiaW5hcnkuc3Vic3RyKGluZGV4SW50b0JpbmFyeSwgYml0V2lkdGgpO1xuICAgIHZhciBpbnRWYWwgPSBiaW5hcnlTbGljZS5sZW5ndGggPiAwID9cbiAgICAgICAgZXhwb3J0cy5iaW5hcnlUb0ludChiaW5hcnlTbGljZSkgOiAwO1xuICAgIGluZGV4SW50b0JpbmFyeSArPSBiaXRXaWR0aDtcbiAgICByZXR1cm4gaW50VmFsLnRvU3RyaW5nKCk7XG4gIH0pLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGZvcm1hdHRlZCBhZGRyZXNzIHN0cmluZyAoZGVjaW1hbCBudW1iZXJzIHdpdGggc2VwYXJhdG9ycykgaW50b1xuICogYmluYXJ5IHdpdGggYml0LXdpZHRocyBmb3IgZWFjaCBwYXJ0IG1hdGNoaW5nIHRoZSBnaXZlbiBmb3JtYXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1N0cmluZ1xuICogQHBhcmFtIHtBZGRyZXNzSGVhZGVyRm9ybWF0fSBhZGRyZXNzRm9ybWF0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmFkZHJlc3NTdHJpbmdUb0JpbmFyeSA9IGZ1bmN0aW9uIChhZGRyZXNzU3RyaW5nLCBhZGRyZXNzRm9ybWF0KSB7XG4gIGlmIChhZGRyZXNzU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEFjdHVhbCB1c2VyIGlucHV0LCBjb252ZXJ0ZWQgdG8gYSBudW1iZXJbXVxuICB2YXIgYWRkcmVzc1BhcnRzID0gYWRkcmVzc1N0cmluZy50b1N0cmluZygpLnNwbGl0KC9cXEQrLykubWFwKGZ1bmN0aW9uIChzdHJpbmdQYXJ0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZ1BhcnQsIDEwKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChudW1iZXJQYXJ0KSB7XG4gICAgcmV0dXJuICFpc05hTihudW1iZXJQYXJ0KTtcbiAgfSk7XG5cbiAgLy8gRm9ybWF0LCBjb252ZXJ0ZWQgdG8gYSBudW1iZXJbXSB3aGVyZSB0aGUgbnVtYmVycyBhcmUgYml0LXdpZHRoc1xuICB2YXIgcGFydFdpZHRocyA9IGFkZHJlc3NGb3JtYXQuc3BsaXQoL1xcRCsvKS5tYXAoZnVuY3Rpb24oc3RyaW5nUGFydCkge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmdQYXJ0LCAxMCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAobnVtYmVyUGFydCkge1xuICAgIHJldHVybiAhaXNOYU4obnVtYmVyUGFydCk7XG4gIH0pO1xuXG4gIHZhciBwYXJ0VmFsdWU7XG4gIHZhciBiaW5hcnkgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0V2lkdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydFZhbHVlID0gaSA8IGFkZHJlc3NQYXJ0cy5sZW5ndGggPyBhZGRyZXNzUGFydHNbaV0gOiAwO1xuICAgIGJpbmFyeSA9IGJpbmFyeSArIGV4cG9ydHMuaW50VG9CaW5hcnkocGFydFZhbHVlLCBwYXJ0V2lkdGhzW2ldKTtcbiAgfVxuICByZXR1cm4gYmluYXJ5O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgYmluYXJ5IHN0cmluZyB0byBhIGZvcm1hdHRlZCByZXByZXNlbnRhdGlvbiwgd2l0aCBjaHVua3MgdGhhdFxuICogY29ycmVzcG9uZCB0byB0aGUgcGFydHMgb2YgdGhlIGFkZHJlc3MgaGVhZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeVN0cmluZ1xuICogQHBhcmFtIHtBZGRyZXNzSGVhZGVyRm9ybWF0fSBhZGRyZXNzRm9ybWF0XG4gKi9cbmV4cG9ydHMuZm9ybWF0QmluYXJ5Rm9yQWRkcmVzc0hlYWRlciA9IGZ1bmN0aW9uIChiaW5hcnlTdHJpbmcsIGFkZHJlc3NGb3JtYXQpIHtcbiAgdmFyIGJpbmFyeSA9IGV4cG9ydHMubWluaWZ5QmluYXJ5KGJpbmFyeVN0cmluZyk7XG5cbiAgdmFyIHBhcnRXaWR0aHMgPSBhZGRyZXNzRm9ybWF0LnNwbGl0KC9cXEQrLykubWFwKGZ1bmN0aW9uKHN0cmluZ1BhcnQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nUGFydCwgMTApO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKG51bWJlclBhcnQpIHtcbiAgICByZXR1cm4gIWlzTmFOKG51bWJlclBhcnQpO1xuICB9KTtcblxuICB2YXIgY2h1bmtzID0gW107XG4gIHZhciBpbmRleCA9IDA7XG4gIHBhcnRXaWR0aHMuZm9yRWFjaChmdW5jdGlvbiAoYml0V2lkdGgpIHtcbiAgICB2YXIgbmV4dCA9IGJpbmFyeS5zdWJzdHIoaW5kZXgsIGJpdFdpZHRoKTtcbiAgICBpZiAobmV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBjaHVua3MucHVzaChuZXh0KTtcbiAgICB9XG4gICAgaW5kZXggKz0gYml0V2lkdGg7XG4gIH0pO1xuXG4gIHZhciBuZXh0ID0gYmluYXJ5LnN1YnN0cihpbmRleCk7XG4gIGlmIChuZXh0Lmxlbmd0aCA+IDApIHtcbiAgICBjaHVua3MucHVzaChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjaHVua3Muam9pbignICcpO1xufTtcbiIsIjsoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzOyAvLyAjODogd2ViIHdvcmtlcnNcbiAgdmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuICBmdW5jdGlvbiBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbiAgLy8gZW5jb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTk5MTY2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL25pZ25hZ11cbiAgb2JqZWN0LmJ0b2EgfHwgKFxuICBvYmplY3QuYnRvYSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnMsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICAgKSB7XG4gICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGlkeCArPSAzLzQpO1xuICAgICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2J0b2EnIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBlbmNvZGVkIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3V0c2lkZSBvZiB0aGUgTGF0aW4xIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxuICAvLyBkZWNvZGVyXG4gIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDIwMzk2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL2F0a11cbiAgb2JqZWN0LmF0b2IgfHwgKFxuICBvYmplY3QuYXRvYiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoc3RyLmxlbmd0aCAlIDQgPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIidhdG9iJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICB2YXIgYmMgPSAwLCBicywgYnVmZmVyLCBpZHggPSAwLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICAgICAgYnVmZmVyID0gc3RyLmNoYXJBdChpZHgrKyk7XG4gICAgICAvLyBjaGFyYWN0ZXIgZm91bmQgaW4gdGFibGU/IGluaXRpYWxpemUgYml0IHN0b3JhZ2UgYW5kIGFkZCBpdHMgYXNjaWkgdmFsdWU7XG4gICAgICB+YnVmZmVyICYmIChicyA9IGJjICUgNCA/IGJzICogNjQgKyBidWZmZXIgOiBidWZmZXIsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgZmlyc3Qgb2YgZWFjaCA0IGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIGZpcnN0IDggYml0cyB0byBvbmUgYXNjaWkgY2hhcmFjdGVyXG4gICAgICAgIGJjKysgJSA0KSA/IG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmIGJzID4+ICgtMiAqIGJjICYgNikpIDogMFxuICAgICkge1xuICAgICAgLy8gdHJ5IHRvIGZpbmQgY2hhcmFjdGVyIGluIHRhYmxlICgwLTYzLCBub3QgZm91bmQgPT4gLTEpXG4gICAgICBidWZmZXIgPSBjaGFycy5pbmRleE9mKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xuXG59KCkpO1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgU3RhdGljIGhlbHBlciBtZXRob2RzIGZvciBOZXRTaW0uXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgTmV0U2ltQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9OZXRTaW1Db25zdGFudHMnKTtcbnZhciBOZXRTaW1HbG9iYWxzID0gcmVxdWlyZSgnLi9OZXRTaW1HbG9iYWxzJyk7XG5cbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuL05ldFNpbUxvZ2dlcicpLmdldFNpbmdsZXRvbigpO1xuXG52YXIgRW5jb2RpbmdUeXBlID0gTmV0U2ltQ29uc3RhbnRzLkVuY29kaW5nVHlwZTtcblxuLyoqXG4gKiBNYWtlIGEgbmV3IFNWRyBlbGVtZW50LCBhcHByb3ByaWF0ZWx5IG5hbWVzcGFjZWQsIHdyYXBwZWQgaW4gYSBqUXVlcnlcbiAqIG9iamVjdCBmb3IgKHNlbWktKWVhc3kgbWFuaXB1bGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB0aGUgdGFnbmFtZSBmb3IgdGhlIHN2ZyBlbGVtZW50LlxuICogQHJldHVybnMge2pRdWVyeX0gZm9yIGNoYWluaW5nXG4gKi9cbmV4cG9ydHMualF1ZXJ5U3ZnRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdHlwZSkpO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBhZGRDbGFzcyBzaW5jZSBqUXVlcnkgYWRkQ2xhc3MgZG9lc24ndCB3b3JrIG9uIHN2Zy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgbmV3RWxlbWVudC5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICB2YXIgb2xkQ2xhc3NlcyA9IG5ld0VsZW1lbnQuYXR0cignY2xhc3MnKTtcbiAgICBpZiAoIW9sZENsYXNzZXMpIHtcbiAgICAgIG5ld0VsZW1lbnQuYXR0cignY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgIH0gZWxzZSBpZiAoIW5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xuICAgICAgbmV3RWxlbWVudC5hdHRyKCdjbGFzcycsIG9sZENsYXNzZXMgKyAnICcgKyBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgcmVtb3ZlQ2xhc3Mgc2luY2UgalF1ZXJ5IHJlbW92ZUNsYXNzIGRvZXNuJ3Qgd29yayBvbiBzdmcuXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzbmFtZSBpZiBpdCBleGlzdHMgb24gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge2pRdWVyeX0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBuZXdFbGVtZW50LnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHZhciBvbGRDbGFzc2VzID0gbmV3RWxlbWVudC5hdHRyKCdjbGFzcycpO1xuICAgIGlmIChvbGRDbGFzc2VzKSB7XG4gICAgICB2YXIgbmV3Q2xhc3NlcyA9IG9sZENsYXNzZXNcbiAgICAgICAgICAuc3BsaXQoL1xccysvZylcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gd29yZCAhPT0gY2xhc3NOYW1lO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgIG5ld0VsZW1lbnQuYXR0cignY2xhc3MnLCBuZXdDbGFzc2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGhhc0NsYXNzIHNpbmNlIGpRdWVyeSBoYXNDbGFzcyBkb2Vzbid0IHdvcmsgb24gc3ZnLlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgbmV3RWxlbWVudC5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICB2YXIgb2xkQ2xhc3NlcyA9IG5ld0VsZW1lbnQuYXR0cignY2xhc3MnKTtcbiAgICByZXR1cm4gb2xkQ2xhc3NlcyAmJiBvbGRDbGFzc2VzLnNwbGl0KC9cXHMrL2cpXG4gICAgICAgIC5zb21lKGZ1bmN0aW9uIChleGlzdGluZ0NsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2xhc3MgPT09IGNsYXNzTmFtZTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRvZ2dsZUNsYXNzIHNpbmNlIGpRdWVyeSB0b2dnbGVDbGFzcyBkb2Vzbid0IHdvcmsgb24gc3ZnLlxuICAgKlxuICAgKiBUd28gdmVyc2lvbnM6XG4gICAqXG4gICAqIHRvZ2dsZUNsYXNzKGNsYXNzTmFtZSkgcmV2ZXJzZXMgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcyBvbiB0aGUgZWxlbWVudDtcbiAgICogICBpZiBpdCBoYXMgdGhlIGNsYXNzIGl0IGdldHMgcmVtb3ZlZCwgaWYgaXQgZG9lc24ndCBoYXZlIHRoZSBjbGFzcyBpdFxuICAgKiAgIGdldHMgYWRkZWQuXG4gICAqXG4gICAqIHRvZ2dsZUNsYXNzKGNsYXNzTmFtZSwgc2hvdWxkSGF2ZUNsYXNzKSBhZGRzIG9yIHJlbW92ZXMgdGhlIGNsYXNzIG9uIHRoZVxuICAgKiAgIGVsZW1lbnQgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZEhhdmVDbGFzc11cbiAgICogQHJldHVybnMge2pRdWVyeX0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBuZXdFbGVtZW50LnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgc2hvdWxkSGF2ZUNsYXNzKSB7XG4gICAgLy8gRGVmYXVsdCBzZWNvbmQgYXJndW1lbnQgLSBpZiBub3QgcHJvdmlkZWQsIHdlIGZsaXAgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICBzaG91bGRIYXZlQ2xhc3MgPSB1dGlscy52YWx1ZU9yKHNob3VsZEhhdmVDbGFzcywgIW5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lKSk7XG5cbiAgICBpZiAoc2hvdWxkSGF2ZUNsYXNzKSB7XG4gICAgICBuZXdFbGVtZW50LmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBjb25maWd1cmF0aW9uIGFnYWluc3QgdGFiIHR5cGUgdG8gZGVjaWRlIHdoZXRoZXIgdGFiXG4gKiBvZiB0eXBlIHNob3VsZCBiZSBzaG93bi5cbiAqIEBwYXJhbSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufSBsZXZlbENvbmZpZ1xuICogQHBhcmFtIHtOZXRTaW1UYWJUeXBlfSB0YWJUeXBlXG4gKi9cbmV4cG9ydHMuc2hvdWxkU2hvd1RhYiA9IGZ1bmN0aW9uIChsZXZlbENvbmZpZywgdGFiVHlwZSkge1xuICByZXR1cm4gbGV2ZWxDb25maWcuc2hvd1RhYnMuaW5kZXhPZih0YWJUeXBlKSA+IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxvY2FsaXplZCBzdHJpbmcgZm9yIHRoZSBnaXZlbiBlbmNvZGluZyB0eXBlLlxuICogQHBhcmFtIHtFbmNvZGluZ1R5cGV9IGVuY29kaW5nVHlwZVxuICogQHJldHVybnMge3N0cmluZ30gbG9jYWxpemVkIGVuY29kaW5nIG5hbWVcbiAqL1xuZXhwb3J0cy5nZXRFbmNvZGluZ0xhYmVsID0gZnVuY3Rpb24gKGVuY29kaW5nVHlwZSkge1xuICBpZiAoZW5jb2RpbmdUeXBlID09PSBFbmNvZGluZ1R5cGUuQVNDSUkpIHtcbiAgICByZXR1cm4gaTE4bi5hc2NpaSgpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nVHlwZSA9PT0gRW5jb2RpbmdUeXBlLkRFQ0lNQUwpIHtcbiAgICByZXR1cm4gaTE4bi5kZWNpbWFsKCk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmdUeXBlID09PSBFbmNvZGluZ1R5cGUuSEVYQURFQ0lNQUwpIHtcbiAgICByZXR1cm4gaTE4bi5oZXgoKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZ1R5cGUgPT09IEVuY29kaW5nVHlwZS5CSU5BUlkpIHtcbiAgICByZXR1cm4gaTE4bi5iaW5hcnkoKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZ1R5cGUgPT09IEVuY29kaW5nVHlwZS5BX0FORF9CKSB7XG4gICAgcmV0dXJuIGkxOG4uYV9hbmRfYigpO1xuICB9XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGVudW1PYmogLSBUZWNobmljYWxseSBhbnkgb2JqZWN0LCBidXQgc2hvdWxkIGJlIHVzZWQgd2l0aFxuICogICAgICAgIGFuIGVudW0gbGlrZSB0aG9zZSBmb3VuZCBpbiBOZXRTaW1Db25zdGFudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBBIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGVudW0sXG4gKiAgICAgICAgd2hpY2ggZ2V0cyBwYXNzZWQgdGhlIGVudW0gdmFsdWUuXG4gKi9cbmV4cG9ydHMuZm9yRWFjaEVudW1WYWx1ZSA9IGZ1bmN0aW9uIChlbnVtT2JqLCBmdW5jKSB7XG4gIGZvciAodmFyIGVudW1LZXkgaW4gZW51bU9iaikge1xuICAgIGlmIChlbnVtT2JqLmhhc093blByb3BlcnR5KGVudW1LZXkpKSB7XG4gICAgICBmdW5jKGVudW1PYmpbZW51bUtleV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSdWxlcyB1c2VkIGJ5IHNlcmlhbGl6ZU51bWJlciBhbmQgZGVzZXJpYWxpemVOdW1iZXIgdG8gbWFwIHVuc3VwcG9ydGVkXG4gKiBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvIEpTT04gYW5kIGJhY2suXG4gKiBAdHlwZSB7e2pzVmFsOiBudW1iZXIsIGpzb25WYWw6IHN0cmluZ31bXX1cbiAqIEByZWFkb25seVxuICovXG52YXIgTlVNQkVSX1NFUklBTElaQVRJT05fUlVMRVMgPSBbXG4gIHsganNWYWw6IEluZmluaXR5LCBqc29uVmFsOiAnSW5maW5pdHknIH0sXG4gIHsganNWYWw6IC1JbmZpbml0eSwganNvblZhbDogJy1JbmZpbml0eScgfSxcbiAgeyBqc1ZhbDogTmFOLCBqc29uVmFsOiAnTmFOJyB9LFxuICB7IGpzVmFsOiB1bmRlZmluZWQsIGpzb25WYWw6ICd1bmRlZmluZWQnIH1cbl07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFjdHVhbGx5IHRoZSBzcGVjaWFsIHZhbHVlIE5hTiwgdW5saWtlXG4gKiBzdGFuZGFyZCBpc05hTiB3aGljaCByZXR1cm5zIHRydWUgZm9yIGFueXRoaW5nIHRoYXQncyBub3QgYSBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbCAtIGFueSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc0V4YWN0bHlOYU4gPSBmdW5jdGlvbiAodmFsKSB7XG4gIC8vIE5hTiBpcyB0aGUgb25seSB2YWx1ZSBpbiBKYXZhU2NyaXB0IHRoYXQgaXMgbm90IGV4YWN0bHkgZXF1YWwgdG8gaXRzZWxmLlxuICAvLyBUaGVyZWZvcmUsIGlmIHZhbCAhPT0gdmFsLCB0aGVuIHZhbCBtdXN0IGJlIE5hTi5cbiAgcmV0dXJuIHZhbCAhPT0gdmFsO1xufTtcblxuLyoqXG4gKiBCZWNhdXNlIEpTT04gZG9lc24ndCBzdXBwb3J0IHRoZSB2YWx1ZXMgSW5maW5pdHksIE5hTiwgb3IgdW5kZWZpbmVkLCB5b3UgY2FuXG4gKiB1c2UgdGhpcyBtZXRob2QgdG8gc3RvcmUgdGhvc2UgdmFsdWVzIGluIEpTT04gYXMgc3RyaW5ncy5cbiAqIEBwYXJhbSB7bnVtYmVyfE5hTn0gbnVtXG4gKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ31cbiAqL1xuZXhwb3J0cy5zZXJpYWxpemVOdW1iZXIgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHZhciBhcHBsaWNhYmxlUnVsZSA9IF8uZmluZChOVU1CRVJfU0VSSUFMSVpBVElPTl9SVUxFUywgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICByZXR1cm4gcnVsZS5qc1ZhbCA9PT0gbnVtIHx8IChpc0V4YWN0bHlOYU4ocnVsZS5qc1ZhbCkgJiYgaXNFeGFjdGx5TmFOKG51bSkpO1xuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2FibGVSdWxlID8gYXBwbGljYWJsZVJ1bGUuanNvblZhbCA6IG51bTtcbn07XG5cbi8qKlxuICogQmVjYXVzZSBKU09OIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgdmFsdWVzIEluZmluaXR5LCBOYU4sIG9yIHVuZGVmaW5lZCwgeW91IGNhblxuICogdXNlIHRoaXMgbWV0aG9kIHRvIHJldHJpZXZlIGEgdmFsdWUgZnJvbSBKU09OIHRoYXQgaXMgZWl0aGVyIGEgbnVtYmVyIG9yIG9uZVxuICogb2YgdGhvc2UgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBzdG9yZWROdW1cbiAqIEByZXR1cm5zIHtudW1iZXJ8TmFOfVxuICovXG5leHBvcnRzLmRlc2VyaWFsaXplTnVtYmVyID0gZnVuY3Rpb24gKHN0b3JlZE51bSkge1xuICB2YXIgYXBwbGljYWJsZVJ1bGUgPSBfLmZpbmQoTlVNQkVSX1NFUklBTElaQVRJT05fUlVMRVMsIGZ1bmN0aW9uIChydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUuanNvblZhbCA9PT0gc3RvcmVkTnVtO1xuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2FibGVSdWxlID8gYXBwbGljYWJsZVJ1bGUuanNWYWwgOiBzdG9yZWROdW07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY29udmVydGluZyBmcm9tIGFuIG9sZGVyIGhlYWRlci1zcGVjIGZvcm1hdCB0byBhIG5ldywgc2ltcGxlciBvbmUuXG4gKiBPbGQgZm9ybWF0OiB7a2V5OntzdHJpbmd9LCBiaXRzOntudW1iZXJ9fVtdXG4gKiBOZXcgZm9ybWF0OiBzdHJpbmdbXVxuICogSWYgd2UgZGV0ZWN0IHRoZSBvbGQgZm9ybWF0LCB3ZSByZXR1cm4gYSBzcGVjIGluIHRoZSBuZXcgZm9ybWF0LlxuICogQHBhcmFtIHtBcnJheX0gc3BlY1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLnNjcnViSGVhZGVyU3BlY0ZvckJhY2t3YXJkc0NvbXBhdGliaWxpdHkgPSBmdW5jdGlvbiAoc3BlYykge1xuICB2YXIgZm91bmRPbGRGb3JtYXQgPSBmYWxzZTtcbiAgdmFyIHNjcnViYmVkU3BlYyA9IFtdO1xuICBzcGVjLmZvckVhY2goZnVuY3Rpb24gKHNwZWNFbnRyeSkge1xuICAgIGlmICh0eXBlb2Ygc3BlY0VudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBpcyBuZXcgbmV3IGZvcm1hdCwgd2UgY2FuIGp1c3QgY29weSBpdCBvdmVyLlxuICAgICAgc2NydWJiZWRTcGVjLnB1c2goc3BlY0VudHJ5KTtcbiAgICB9IGVsc2UgaWYgKHNwZWNFbnRyeSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3BlY0VudHJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgb2xkIHtrZXk6JycsIGJpdHM6MH0gZm9ybWF0LiAgV2UganVzdCB3YW50IHRoZSBrZXkuXG4gICAgICBzY3J1YmJlZFNwZWMucHVzaChzcGVjRW50cnkua2V5KTtcbiAgICAgIGZvdW5kT2xkRm9ybWF0ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElzc3VlIGEgd2FybmluZyBpZiBhbiBvbGQgZm9ybWF0IGdvdCBjb252ZXJ0ZWQsIHNvIHdlIGtub3cgdG8gdXBkYXRlXG4gIC8vIHRoZSBsZXZlbC5cbiAgaWYgKGZvdW5kT2xkRm9ybWF0KSB7XG4gICAgbG9nZ2VyLndhcm4oXCJDb252ZXJ0aW5nIG9sZCBoZWFkZXIgc3BlY2lmaWNhdGlvbiBmb3JtYXQgdG8gbmV3IGZvcm1hdC5cIiArXG4gICAgICAgIFwiIFRoaXMgbGV2ZWwgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBuZXcgZm9ybWF0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBzY3J1YmJlZFNwZWM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufSBsZXZlbENvbmZpZ1xuICogQHJldHVybnMge05ldFNpbUxldmVsQ29uZmlndXJhdGlvbn0gc2FtZSB0aGluZywgYnV0IHdpdGggY2VydGFpbiB2YWx1ZXNcbiAqICAgICAgICAgIGNvbnZlcnRlZCBvciBjbGVhbmVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zY3J1YkxldmVsQ29uZmlndXJhdGlvbl8gPSBmdW5jdGlvbiAobGV2ZWxDb25maWcpIHtcbiAgdmFyIHNjcnViYmVkTGV2ZWwgPSBfLmNsb25lKGxldmVsQ29uZmlnLCB0cnVlKTtcblxuICAvLyBDb252ZXJ0IG9sZCBoZWFkZXIgc3BlYyBmb3JtYXQgdG8gbmV3IGhlYWRlciBzcGVjIGZvcm1hdFxuICBzY3J1YmJlZExldmVsLnJvdXRlckV4cGVjdHNQYWNrZXRIZWFkZXIgPVxuICAgICAgZXhwb3J0cy5zY3J1YkhlYWRlclNwZWNGb3JCYWNrd2FyZHNDb21wYXRpYmlsaXR5KFxuICAgICAgICAgIHNjcnViYmVkTGV2ZWwucm91dGVyRXhwZWN0c1BhY2tldEhlYWRlcik7XG4gIHNjcnViYmVkTGV2ZWwuY2xpZW50SW5pdGlhbFBhY2tldEhlYWRlciA9XG4gICAgICBleHBvcnRzLnNjcnViSGVhZGVyU3BlY0ZvckJhY2t3YXJkc0NvbXBhdGliaWxpdHkoXG4gICAgICAgICAgc2NydWJiZWRMZXZlbC5jbGllbnRJbml0aWFsUGFja2V0SGVhZGVyKTtcblxuICAvLyBDb2VyY2UgY2VydGFpbiB2YWx1ZXMgdG8gc3RyaW5nIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIG1pc3Rha2VuIGZvciBudW1iZXJzXG4gIHNjcnViYmVkTGV2ZWwuYWRkcmVzc0Zvcm1hdCA9IHNjcnViYmVkTGV2ZWwuYWRkcmVzc0Zvcm1hdC50b1N0cmluZygpO1xuXG4gIC8vIEV4cGxpY2l0bHkgbGlzdCBmaWVsZHMgdGhhdCB3ZSBzdXNwZWN0IG1heSBoYXZlIGEgc3RyaW5nIHZhbHVlIHRoYXRcbiAgLy8gbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCBsaWtlIFwiSW5maW5pdHlcIlxuICBzY3J1YmJlZExldmVsLmRlZmF1bHRQYWNrZXRTaXplTGltaXQgPSBleHBvcnRzLmRlc2VyaWFsaXplTnVtYmVyKFxuICAgICAgc2NydWJiZWRMZXZlbC5kZWZhdWx0UGFja2V0U2l6ZUxpbWl0KTtcblxuICAvLyBQYWNrZXQgU2l6ZSBjYW5ub3QgYmUgaW5maW5pdHk7IGRlZmF1bHRzIHRvIDhrYlxuICBpZiAoc2NydWJiZWRMZXZlbC5kZWZhdWx0UGFja2V0U2l6ZUxpbWl0ID09PSBJbmZpbml0eSkge1xuICAgIHNjcnViYmVkTGV2ZWwuZGVmYXVsdFBhY2tldFNpemVMaW1pdCA9IDgxOTI7XG4gIH1cblxuICBzY3J1YmJlZExldmVsLmRlZmF1bHRCaXRSYXRlQml0c1BlclNlY29uZCA9IGV4cG9ydHMuZGVzZXJpYWxpemVOdW1iZXIoXG4gICAgICBzY3J1YmJlZExldmVsLmRlZmF1bHRCaXRSYXRlQml0c1BlclNlY29uZCk7XG4gIHNjcnViYmVkTGV2ZWwuZGVmYXVsdENodW5rU2l6ZUJpdHMgPSBleHBvcnRzLmRlc2VyaWFsaXplTnVtYmVyKFxuICAgICAgc2NydWJiZWRMZXZlbC5kZWZhdWx0Q2h1bmtTaXplQml0cyk7XG4gIHNjcnViYmVkTGV2ZWwuZGVmYXVsdFJvdXRlckJhbmR3aWR0aCA9IGV4cG9ydHMuZGVzZXJpYWxpemVOdW1iZXIoXG4gICAgICBzY3J1YmJlZExldmVsLmRlZmF1bHRSb3V0ZXJCYW5kd2lkdGgpO1xuICBzY3J1YmJlZExldmVsLmRlZmF1bHRSb3V0ZXJNZW1vcnkgPSBleHBvcnRzLmRlc2VyaWFsaXplTnVtYmVyKFxuICAgICAgc2NydWJiZWRMZXZlbC5kZWZhdWx0Um91dGVyTWVtb3J5KTtcblxuICAvLyBHZW5lcmF0ZSBhIHdhcm5pbmcgaWYgd2Ugc2VlIGEgcG9zc2libGUgbWlzc2VkIHN0cmluZy10by1udW1iZXIgY29udmVyc2lvblxuICBPYmplY3Qua2V5cyhzY3J1YmJlZExldmVsKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIElnbm9yZSBsZXZlbCBwYXJhbXMgd2l0aCB1bmRlcnNjb3JlcywgdGhleSBhcmUgdGhlIGRhc2hib2FyZCB2ZXJzaW9uc1xuICAgIC8vIG9mIHRoZSBjYW1lbENhc2UgcGFyYW1ldGVycyB0aGF0IHRoZSBhcHAgYWN0dWFsbHkgdXNlcy5cbiAgICByZXR1cm4gIS9fLy50ZXN0KGtleSk7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB1bmNvbnZlcnRlZFZhbHVlID0gTlVNQkVSX1NFUklBTElaQVRJT05fUlVMRVMuc29tZShmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcmV0dXJuIHNjcnViYmVkTGV2ZWxba2V5XSA9PT0gcnVsZS5qc29uVmFsO1xuICAgIH0pO1xuICAgIGlmICh1bmNvbnZlcnRlZFZhbHVlKSB7XG4gICAgICBsb2dnZXIud2FybihcIkxldmVsIG9wdGlvbiAnXCIgKyBrZXkgK1xuICAgICAgXCInIGhhcyB1bmNvbnZlcnRlZCBzdHJpbmcgdmFsdWUgJ1wiICsgc2NydWJiZWRMZXZlbFtrZXldICsgXCInXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNjcnViYmVkTGV2ZWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9mIGJpdHMgaW50byBhIGxvY2FsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGF0IGRhdGFcbiAqIHNpemUgaW4gYnl0ZXMsIGtpbG9ieXRlcywgbWVnYWJ5dGVzLCBnaWdhYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICogQHJldHVybnMge3N0cmluZ30gLSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHNpemUgaW4gYnl0ZXNcbiAqL1xuZXhwb3J0cy5iaXRzVG9Mb2NhbGl6ZWRSb3VuZGVkQnl0ZXNpemUgPSBmdW5jdGlvbiAoYml0cykge1xuICBpZiAoYml0cyA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gaTE4bi51bmxpbWl0ZWQoKTtcbiAgfVxuXG4gIHZhciBnYnl0ZXMgPSBNYXRoLmZsb29yKGJpdHMgLyBOZXRTaW1Db25zdGFudHMuQklUU19QRVJfR0lHQUJZVEUpO1xuICBpZiAoZ2J5dGVzID4gMCkge1xuICAgIHJldHVybiBpMThuLnhfR0J5dGVzKHsgeDogZ2J5dGVzIH0pO1xuICB9XG5cbiAgdmFyIG1ieXRlcyA9IE1hdGguZmxvb3IoYml0cyAvIE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9NRUdBQllURSk7XG4gIGlmIChtYnl0ZXMgPiAwKSB7XG4gICAgcmV0dXJuIGkxOG4ueF9NQnl0ZXMoeyB4OiBtYnl0ZXMgfSk7XG4gIH1cblxuICB2YXIga2J5dGVzID0gTWF0aC5mbG9vcihiaXRzIC8gTmV0U2ltQ29uc3RhbnRzLkJJVFNfUEVSX0tJTE9CWVRFKTtcbiAgaWYgKGtieXRlcyA+IDApIHtcbiAgICByZXR1cm4gaTE4bi54X0tCeXRlcyh7IHg6IGtieXRlcyB9KTtcbiAgfVxuXG4gIHZhciBieXRlcyA9IE1hdGguZmxvb3IoYml0cyAvIE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9CWVRFKTtcbiAgaWYgKGJ5dGVzID4gMCkge1xuICAgIHJldHVybiBpMThuLnhfQnl0ZXMoeyB4OiBieXRlcyB9KTtcbiAgfVxuXG4gIHJldHVybiBpMThuLnhfYml0cyh7IHg6IGJpdHMgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYml0cmF0ZSBpbnRvIGEgbG9jYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgZGF0YVxuICogc2l6ZSBpbiBiaXRzL3NlYywga2lsb2JpdHMsIG1lZ2FiaXRzLCBnaWdhYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyU2Vjb25kXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc3BlZWQgaW4gYml0c1xuICovXG5leHBvcnRzLmJpdHJhdGVUb0xvY2FsaXplZFJvdW5kZWRCaXRyYXRlID0gZnVuY3Rpb24gKGJpdHNQZXJTZWNvbmQpIHtcbiAgaWYgKGJpdHNQZXJTZWNvbmQgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIGkxOG4udW5saW1pdGVkKCk7XG4gIH1cblxuICB2YXIgZ2JwcyA9IE1hdGguZmxvb3IoYml0c1BlclNlY29uZCAvIE5ldFNpbUNvbnN0YW50cy5CSVRTX1BFUl9HSUdBQklUKTtcbiAgaWYgKGdicHMgPiAwKSB7XG4gICAgcmV0dXJuIGkxOG4ueF9HYnBzKHsgeDogZ2JwcyB9KTtcbiAgfVxuXG4gIHZhciBtYnBzID0gTWF0aC5mbG9vcihiaXRzUGVyU2Vjb25kIC8gTmV0U2ltQ29uc3RhbnRzLkJJVFNfUEVSX01FR0FCSVQpO1xuICBpZiAobWJwcyA+IDApIHtcbiAgICByZXR1cm4gaTE4bi54X01icHMoeyB4OiBtYnBzIH0pO1xuICB9XG5cbiAgdmFyIGticHMgPSBNYXRoLmZsb29yKGJpdHNQZXJTZWNvbmQgLyBOZXRTaW1Db25zdGFudHMuQklUU19QRVJfS0lMT0JJVCk7XG4gIGlmIChrYnBzID4gMCkge1xuICAgIHJldHVybiBpMThuLnhfS2Jwcyh7IHg6IGticHMgfSk7XG4gIH1cblxuICB2YXIgYnBzID0gTWF0aC5mbG9vcihiaXRzUGVyU2Vjb25kICogMTAwKSAvIDEwMDtcbiAgcmV0dXJuIGkxOG4ueF9icHMoeyB4OiBicHMgfSk7XG59O1xuXG5leHBvcnRzLnplcm9QYWRMZWZ0ID0gZnVuY3Rpb24gKHN0cmluZywgZGVzaXJlZFdpZHRoKSB7XG4gIHZhciBwYWRkaW5nID0gJzAnLnJlcGVhdChkZXNpcmVkV2lkdGgpO1xuICByZXR1cm4gKHBhZGRpbmcgKyBzdHJpbmcpLnNsaWNlKC1kZXNpcmVkV2lkdGgpO1xufTtcblxuZXhwb3J0cy56ZXJvUGFkUmlnaHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBkZXNpcmVkV2lkdGgpIHtcbiAgdmFyIHBhZGRpbmcgPSAnMCcucmVwZWF0KGRlc2lyZWRXaWR0aCk7XG4gIHJldHVybiAoc3RyaW5nICsgcGFkZGluZykuc3Vic3RyKDAsIGRlc2lyZWRXaWR0aCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDb250aW51ZS9GaW5pc2ggYnV0dG9uIG9uIHRoZSBnaXZlbiBOZXRTaW1QYW5lbCAoaW4gaXRzIGhlYWRlcikuXG4gKiBAcGFyYW0ge05ldFNpbVBhbmVsfSBvblBhbmVsXG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMubWFrZUNvbnRpbnVlQnV0dG9uID0gZnVuY3Rpb24gKG9uUGFuZWwpIHtcbiAgb25QYW5lbC5hZGRCdXR0b24oXG4gICAgICBpMThuLmNvbnRpbnVlQnV0dG9uKHsgY2FyZXQ6ICc8aSBjbGFzcz1cImZhIGZhLWNhcmV0LXJpZ2h0XCI+PC9pPicgfSksXG4gICAgICBmdW5jdGlvbiAoalF1ZXJ5RXZlbnQpIHtcbiAgICAgICAgaWYgKCEkKGpRdWVyeUV2ZW50LnRhcmdldCkuaXMoJzpkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgTmV0U2ltR2xvYmFscy5jb21wbGV0ZUxldmVsQW5kQ29udGludWUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2Vjb25kYXJ5OiBmYWxzZSxcbiAgICAgICAgY2xhc3NlczogWyAnc3VibWl0QnV0dG9uJyBdXG4gICAgICB9KTtcbn07XG4iLCIvLyBsb2NhbGUgZm9yIG5ldHNpbVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5ibG9ja2x5Lm5ldHNpbV9sb2NhbGU7XG4iLCIvKipcbiAqIEBvdmVydmlldyBVdGlsaXR5IGNsYXNzIHdyYXBwaW5nIG1vcmUgZ3JhbnVsYXIgbG9nIGJlaGF2aW9yIHRoYXQgaXNuJ3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnMuICBBbHNvIG1ha2VzIGl0IGVhc3kgdG8gdHVybiBsb2dnaW5nIG9uIGFuZCBvZmZcbiAqIGluIHRlc3RzLlxuICovXG4vKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcblxuIG1heGxlbjogOTAsXG4gbWF4cGFyYW1zOiAzLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9nZ2luZyBBUEkgdG8gY29udHJvbCBsb2cgbGV2ZWxzIGFuZCBzdXBwb3J0IGRpZmZlcmVudCBicm93c2Vyc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnNvbGV9IHdpbmRvdyBjb25zb2xlIEFQSVxuICogQHBhcmFtIHtMb2dMZXZlbH0gdmVyYm9zaXR5XG4gKi9cbnZhciBOZXRTaW1Mb2dnZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvdXRwdXRDb25zb2xlLCB2ZXJib3NpdHkgLyo9VkVSQk9TRSovKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29uc29sZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMub3V0cHV0Q29uc29sZV8gPSBvdXRwdXRDb25zb2xlO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgbWFwcGVkIHRvIGNvbnNvbGUubG9nLCBvciBuby1vcCBpZiBub3QgYXZhaWxhYmxlLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmxvZ18gPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogSWYgY29uZmlndXJlZCBmb3IgaW5mbyBsb2dnaW5nLCBnZXRzIG1hcHBlZCB0byBjb25zb2xlLmluZm8sXG4gICAqIGZhbGxzIGJhY2sgdG8gY29uc29sZS5sb2csIG9yIG5vLW9wLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLmluZm8gPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogSWYgY29uZmlndXJlZCBmb3Igd2FybmluZyBsb2dnaW5nLCBnZXRzIG1hcHBlZCB0byBjb25zb2xlLndhcm4sXG4gICAqIGZhbGxzIGJhY2sgdG8gY29uc29sZS5sb2csIG9yIG5vLW9wLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLndhcm4gPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogSWYgY29uZmlndXJlZCBmb3IgZXJyb3IgbG9nZ2luZywgZ2V0cyBtYXBwZWQgdG8gY29uc29sZS5lcnJvcixcbiAgICogZmFsbHMgYmFjayB0byBjb25zb2xlLmxvZywgb3Igbm8tb3AuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcblxuICB0aGlzLnNldFZlcmJvc2l0eSgodW5kZWZpbmVkID09PSB2ZXJib3NpdHkpID9cbiAgICAgIExvZ0xldmVsLlZFUkJPU0UgOiB2ZXJib3NpdHkpO1xufTtcblxuLyoqXG4gKiBMb2cgdmVyYm9zaXR5IGxldmVscyBlbnVtLlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgTG9nTGV2ZWwgPSB7XG4gIE5PTkU6IDAsXG4gIEVSUk9SOiAxLFxuICBXQVJOOiAyLFxuICBJTkZPOiAzLFxuICBWRVJCT1NFOiA0XG59O1xuTmV0U2ltTG9nZ2VyLkxvZ0xldmVsID0gTG9nTGV2ZWw7XG5cbi8qKlxuICogR2xvYmFsIHNpbmdsZXRvblxuICogQHR5cGUge05ldFNpbUxvZ2dlcn1cbiAqL1xudmFyIHNpbmdsZXRvbkluc3RhbmNlO1xuXG4vKipcbiAqIFN0YXRpYyBnZXR0ZXIvbGF6eS1jcmVhdG9yIGZvciB0aGUgZ2xvYmFsIHNpbmdsZXRvbiBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtOZXRTaW1Mb2dnZXJ9XG4gKi9cbk5ldFNpbUxvZ2dlci5nZXRTaW5nbGV0b24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzaW5nbGV0b25JbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2luZ2xldG9uSW5zdGFuY2UgPSBuZXcgTmV0U2ltTG9nZ2VyKGNvbnNvbGUsIExvZ0xldmVsLldBUk4pO1xuICB9XG4gIHJldHVybiBzaW5nbGV0b25JbnN0YW5jZTtcbn07XG5cbi8qKlxuICogQmluZHMgaW50ZXJuYWwgZnVuY3Rpb24gY2FsbHMgYWNjb3JkaW5nIHRvIGdpdmVuIHZlcmJvc2l0eSBsZXZlbC5cbiAqIEBwYXJhbSB2ZXJib3NpdHlcbiAqL1xuTmV0U2ltTG9nZ2VyLnByb3RvdHlwZS5zZXRWZXJib3NpdHkgPSBmdW5jdGlvbiAodmVyYm9zaXR5KSB7XG4gIC8vIE5vdGU6IFdlIGRvbid0IGNhbGwgdGhpcy5vdXRwdXRDb25zb2xlXy5sb2cuYmluZCBoZXJlLCBiZWNhdXNlIGluIElFOSB0aGVcbiAgLy8gY29uc29sZSdzIGxvZ2dpbmcgbWV0aG9kcyBkbyBub3QgaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLlxuXG4gIHRoaXMubG9nXyA9ICh0aGlzLm91dHB1dENvbnNvbGVfICYmIHRoaXMub3V0cHV0Q29uc29sZV8ubG9nKSA/XG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMub3V0cHV0Q29uc29sZV8ubG9nLCB0aGlzLm91dHB1dENvbnNvbGVfKSA6XG4gICAgICBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAodmVyYm9zaXR5ID49IExvZ0xldmVsLklORk8pIHtcbiAgICB0aGlzLmluZm8gPSAodGhpcy5vdXRwdXRDb25zb2xlXyAmJiB0aGlzLm91dHB1dENvbnNvbGVfLmluZm8pID9cbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzLm91dHB1dENvbnNvbGVfLmluZm8sIHRoaXMub3V0cHV0Q29uc29sZV8pIDpcbiAgICAgICAgdGhpcy5sb2dfO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgaWYgKHZlcmJvc2l0eSA+PSBMb2dMZXZlbC5XQVJOKSB7XG4gICAgdGhpcy53YXJuID0gKHRoaXMub3V0cHV0Q29uc29sZV8gJiYgdGhpcy5vdXRwdXRDb25zb2xlXy53YXJuKSA/XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcy5vdXRwdXRDb25zb2xlXy53YXJuLCB0aGlzLm91dHB1dENvbnNvbGVfKSA6XG4gICAgICAgIHRoaXMubG9nXztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhcm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGlmICh2ZXJib3NpdHkgPj0gTG9nTGV2ZWwuRVJST1IpIHtcbiAgICB0aGlzLmVycm9yID0gKHRoaXMub3V0cHV0Q29uc29sZV8gJiYgdGhpcy5vdXRwdXRDb25zb2xlXy5lcnJvcikgP1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMub3V0cHV0Q29uc29sZV8uZXJyb3IsIHRoaXMub3V0cHV0Q29uc29sZV8pIDpcbiAgICAgICAgdGhpcy5sb2dfO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgdG8gb3V0cHV0LCBkZXBlbmRpbmcgb24gbG9nIGxldmVsXG4gKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IGxvZ0xldmVsXG4gKi9cbk5ldFNpbUxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGxvZ0xldmVsIC8qPUlORk8qLykge1xuICBpZiAodW5kZWZpbmVkID09PSBsb2dMZXZlbCkge1xuICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcbiAgfVxuXG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICBjYXNlIExvZ0xldmVsLkVSUk9SOlxuICAgICAgdGhpcy5lcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTG9nTGV2ZWwuV0FSTjpcbiAgICAgIHRoaXMud2FybihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTG9nTGV2ZWwuSU5GTzpcbiAgICAgIHRoaXMuaW5mbyhtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmxvZ18obWVzc2FnZSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIEBvdmVydmlldyBHbG9iYWwgc2luZ2xldG9uIHVzZWQgdG8gc2ltcGxpZnkgY2VydGFpbiBjcm9zcy1jdXR0aW5nIGNvbmNlcm5zLFxuICogICAgICAgICAgIGluY2x1ZGluZzpcbiAqXG4gKiAgICAgICAgICAgQWNjZXNzIHRvIGxldmVsIGNvbmZpZ3VyYXRpb24uXG4gKiAgICAgICAgICAgQWNjZXNzIHRvIGVudmlyb25tZW50LXNwZWNpZmljIGFzc2V0IFVSTHMuXG4gKiAgICAgICAgICAgUmVwcm9kdWNpYmxlIHJhbmRvbSBudW1iZXIgZnVuY3Rpb25zIGZvciBlYXN5IHRlc3RpbmcuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHJvb3QgU3R1ZGlvQXBwIGNvbnRyb2xsZXJcbiAqIEB0eXBlIHtTdHVkaW9BcHB9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3R1ZGlvQXBwXyA9IG51bGw7XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHJvb3QgTmV0U2ltIGNvbnRyb2xsZXJcbiAqIEB0eXBlIHtOZXRTaW19XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV0c2ltXyA9IG51bGw7XG5cbi8qKlxuICogUmVwbGFjYWJsZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBsZXRzIHVzIHNldCBhIGdsb2JhbFxuICogcmFuZG9tIHNlZWQgaWYgd2Ugd2lzaC5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwc2V1ZG9SYW5kb21OdW1iZXJGdW5jdGlvbl8gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IGluY2x1c2l2ZSBsb3dlciBlbmQgb2YgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIGV4Y2x1c2l2ZSB1cHBlciBlbmQgb2YgcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnZhciByYW5kb21JbnRJblJhbmdlID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihwc2V1ZG9SYW5kb21OdW1iZXJGdW5jdGlvbl8oKSAqIChoaWdoIC0gbG93KSkgKyBsb3c7XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgc2luZ2xldG9uIGFjY2VzcyB0byBnbG9iYWwgc2ltdWxhdGlvbiBzZXR0aW5nc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogU2V0IHRoZSByb290IGNvbnRyb2xsZXJzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGdsb2JhbCBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge1N0dWRpb0FwcH0gc3R1ZGlvQXBwXG4gICAqIEBwYXJhbSB7TmV0U2ltfSBuZXRzaW1cbiAgICovXG4gIHNldFJvb3RDb250cm9sbGVyczogZnVuY3Rpb24gKHN0dWRpb0FwcCwgbmV0c2ltKSB7XG4gICAgc3R1ZGlvQXBwXyA9IHN0dWRpb0FwcDtcbiAgICBuZXRzaW1fID0gbmV0c2ltO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TmV0U2ltTGV2ZWxDb25maWd1cmF0aW9ufVxuICAgKi9cbiAgZ2V0TGV2ZWxDb25maWc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV0c2ltXy5sZXZlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybnMge1B1YlN1YkNvbmZpZ31cbiAgICovXG4gIGdldFB1YlN1YkNvbmZpZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1c2VQdXNoZXI6IG5ldHNpbV8udXNlUHVzaGVyLFxuICAgICAgcHVzaGVyQXBwbGljYXRpb25LZXk6IG5ldHNpbV8ucHVzaGVyQXBwbGljYXRpb25LZXlcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0R2xvYmFsTWF4Um91dGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXRzaW1fLmdsb2JhbE1heFJvdXRlcnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICovXG4gIGdldEFzc2V0VXJsRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3R1ZGlvQXBwXy5hc3NldFVybDtcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlciBhIGxheW91dCB1cGRhdGUgb2YgdGhlIHJpZ2h0IGNvbHVtbiwgcmVjZWl2ZWQvc2VudC9zZW5kIHBhbmVscy5cbiAgICovXG4gIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xuICAgIG5ldHNpbV8udXBkYXRlTGF5b3V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gYXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCBsZXZlbCBhbmQgY29udGludWUgdG8gdGhlIG5leHQuXG4gICAqL1xuICBjb21wbGV0ZUxldmVsQW5kQ29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICBuZXRzaW1fLmNvbXBsZXRlTGV2ZWxBbmRDb250aW51ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNlZWQgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLiAgSWYgdGhpcyBpcyBuZXZlciBjYWxsZWQsIHRoZSBkZWZhdWx0XG4gICAqIE1hdGgucmFuZG9tIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGdlbmVyYXRvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1NlZWRcbiAgICovXG4gIHNldFJhbmRvbVNlZWQ6IGZ1bmN0aW9uIChuZXdTZWVkKSB7XG4gICAgcHNldWRvUmFuZG9tTnVtYmVyRnVuY3Rpb25fID0gc2VlZHJhbmRvbShuZXdTZWVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gYSByYW5kb20gdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAqL1xuICByYW5kb206IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHNldWRvUmFuZG9tTnVtYmVyRnVuY3Rpb25fKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBpbmNsdXNpdmUgbG93ZXIgZW5kIG9mIHJhbmdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIGV4Y2x1c2l2ZSB1cHBlciBlbmQgb2YgcmFuZ2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHJhbmRvbUludEluUmFuZ2U6IHJhbmRvbUludEluUmFuZ2UsXG5cbiAgLyoqXG4gICAqIEdldCBhIHJhbmRvbSBpdGVtIG91dCBvZiBhIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gY29sbGVjdGlvblxuICAgKiBAcmV0dXJucyB7Kn0gdW5kZWZpbmVkIGlmIGNvbGxlY3Rpb24gaXMgZW1wdHlcbiAgICovXG4gIHJhbmRvbVBpY2tPbmU6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNpemUgPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbltyYW5kb21JbnRJblJhbmdlKDAsIHNpemUpXTtcbiAgfVxuXG59O1xuIiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5vZGVjcnlwdG8pIHsgcmV0dXJuIHRvc3RyaW5nKG5vZGVjcnlwdG8ucmFuZG9tQnl0ZXMod2lkdGgpKTsgfVxuICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XG4gICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICByZXR1cm4gdG9zdHJpbmcob3V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgIHJldHVybiBbK25ldyBEYXRlLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgfVxufVxuXG4vL1xuLy8gdG9zdHJpbmcoKVxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXG4vL1xuZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbn1cblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy9cbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcbi8vIGVpdGhlciBjb252ZW50aW9uLlxuLy9cbmlmICgodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWVkcmFuZG9tO1xuICAvLyBXaGVuIGluIG5vZGUuanMsIHRyeSB1c2luZyBjcnlwdG8gcGFja2FnZSBmb3IgYXV0b3NlZWRpbmcuXG4gIHRyeSB7XG4gICAgbm9kZWNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICB9IGNhdGNoIChleCkge31cbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzZWVkcmFuZG9tOyB9KTtcbn1cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMucm5nID0gZXhwb3J0cy5wc2V1ZG9SYW5kb21CeXRlcyA9IGV4cG9ydHMucHJuZyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZXhwb3J0cy5IYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxuXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoT2JqZWN0LmtleXMocmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduL2FsZ29zJykpKVxuZXhwb3J0cy5nZXRIYXNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoYXNoZXM7XG59XG5cbnZhciBwID0gcmVxdWlyZSgncGJrZGYyJylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKTtcbltcbiAgJ0NpcGhlcicsXG4gICdjcmVhdGVDaXBoZXInLFxuICAnQ2lwaGVyaXYnLFxuICAnY3JlYXRlQ2lwaGVyaXYnLFxuICAnRGVjaXBoZXInLFxuICAnY3JlYXRlRGVjaXBoZXInLFxuICAnRGVjaXBoZXJpdicsXG4gICdjcmVhdGVEZWNpcGhlcml2JyxcbiAgJ2dldENpcGhlcnMnLFxuICAnbGlzdENpcGhlcnMnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBhZXNba2V5XTtcbn0pXG5cbnZhciBkaCA9IHJlcXVpcmUoJ2RpZmZpZS1oZWxsbWFuJyk7XG5bXG4gICdEaWZmaWVIZWxsbWFuR3JvdXAnLFxuICAnY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwJyxcbiAgJ2dldERpZmZpZUhlbGxtYW4nLFxuICAnY3JlYXRlRGlmZmllSGVsbG1hbicsXG4gICdEaWZmaWVIZWxsbWFuJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgZXhwb3J0c1trZXldID0gZGhba2V5XTtcbn0pXG5cbnZhciBzaWduID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduJyk7XG5bXG4gICdjcmVhdGVTaWduJyxcbiAgJ1NpZ24nLFxuICAnY3JlYXRlVmVyaWZ5JyxcbiAgJ1ZlcmlmeSdcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IHNpZ25ba2V5XTtcbn0pXG5cbmV4cG9ydHMuY3JlYXRlRUNESCA9IHJlcXVpcmUoJ2NyZWF0ZS1lY2RoJylcblxudmFyIHB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCdwdWJsaWMtZW5jcnlwdCcpO1xuXG5bXG4gICdwdWJsaWNFbmNyeXB0JyxcbiAgJ3ByaXZhdGVFbmNyeXB0JyxcbiAgJ3B1YmxpY0RlY3J5cHQnLFxuICAncHJpdmF0ZURlY3J5cHQnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBwdWJsaWNFbmNyeXB0W2tleV07XG59KVxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbjtbXG4gICdjcmVhdGVDcmVkZW50aWFscydcbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAnc29ycnksICcgKyBuYW1lICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0JyxcbiAgICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0by1icm93c2VyaWZ5L2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpO1xuICB9XG59KVxuIiwiZXhwb3J0cy5wdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgnLi9wdWJsaWNFbmNyeXB0Jyk7XG5leHBvcnRzLnByaXZhdGVEZWNyeXB0ID0gcmVxdWlyZSgnLi9wcml2YXRlRGVjcnlwdCcpO1xuXG5leHBvcnRzLnByaXZhdGVFbmNyeXB0ID0gZnVuY3Rpb24gcHJpdmF0ZUVuY3J5cHQoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljRW5jcnlwdChrZXksIGJ1ZiwgdHJ1ZSk7XG59O1xuXG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBmdW5jdGlvbiBwdWJsaWNEZWNyeXB0KGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnByaXZhdGVEZWNyeXB0KGtleSwgYnVmLCB0cnVlKTtcbn07IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKTtcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcblxudmFyIGNvbnN0YW50cyA9IHtcbiAgUlNBX1BLQ1MxX09BRVBfUEFERElORzogNCxcbiAgUlNBX1BLQ1MxX1BBRERJTjogMSxcbiAgUlNBX05PX1BBRERJTkc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdChwdWJsaWNfa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwdWJsaWNfa2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY19rZXkpO1xuICB2YXIgcGFkZGVkTXNnO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICBwYWRkZWRNc2cgPSBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBibihtc2cpO1xuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtTGVuID4gayAtIGhMZW4yIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSBoTGVuMiAtIDIpO1xuICBwcy5maWxsKDApO1xuICB2YXIgZGJsZW4gPSBrIC0gaExlbiAtIDE7XG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbik7XG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIG5ldyBCdWZmZXIoWzFdKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSB4b3Ioc2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSk7XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMF0pLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKTtcbn1cbmZ1bmN0aW9uIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKXtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgcHM7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBuZXcgQnVmZmVyKGsgLSBtTGVuIC0gMyk7XG4gICAgcHMuZmlsbCgweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKTtcbiAgfVxuICByZXR1cm4gbmV3IGJuKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzAsIHJldmVyc2U/MToyXSksIHBzLCBuZXcgQnVmZmVyKFswXSksIG1zZ10sIGspKTtcbn1cbmZ1bmN0aW9uIG5vblplcm8obGVuLCBjcnlwdG8pIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gIHZhciBjdXIgPSAwO1xuICB2YXIgbnVtO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gICAgICBjdXIgPSAwO1xuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK107XG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNIVmliR2xqTFdWdVkzSjVjSFF2Y0hWaWJHbGpSVzVqY25sd2RDNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlIQmhjbk5sUzJWNWN5QTlJSEpsY1hWcGNtVW9KM0JoY25ObExXRnpiakVuS1R0Y2JuWmhjaUJ5WVc1a2IyMUNlWFJsY3lBOUlISmxjWFZwY21Vb0ozSmhibVJ2YldKNWRHVnpKeWs3WEc1MllYSWdZM0psWVhSbFNHRnphQ0E5SUhKbGNYVnBjbVVvSjJOeVpXRjBaUzFvWVhOb0p5azdYRzUyWVhJZ2JXZG1JRDBnY21WeGRXbHlaU2duTGk5dFoyWW5LVHRjYm5aaGNpQjRiM0lnUFNCeVpYRjFhWEpsS0NjdUwzaHZjaWNwTzF4dWRtRnlJR0p1SUQwZ2NtVnhkV2x5WlNnblltNHVhbk1uS1R0Y2JuWmhjaUIzYVhSb1VIVmliR2xqSUQwZ2NtVnhkV2x5WlNnbkxpOTNhWFJvVUhWaWJHbGpKeWs3WEc1MllYSWdZM0owSUQwZ2NtVnhkV2x5WlNnblluSnZkM05sY21sbWVTMXljMkVuS1R0Y2JseHVkbUZ5SUdOdmJuTjBZVzUwY3lBOUlIdGNiaUFnVWxOQlgxQkxRMU14WDA5QlJWQmZVRUZFUkVsT1J6b2dOQ3hjYmlBZ1VsTkJYMUJMUTFNeFgxQkJSRVJKVGpvZ01TeGNiaUFnVWxOQlgwNVBYMUJCUkVSSlRrYzZJRE5jYm4wN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdjSFZpYkdsalJXNWpjbmx3ZENod2RXSnNhV05mYTJWNUxDQnRjMmNzSUhKbGRtVnljMlVwSUh0Y2JpQWdkbUZ5SUhCaFpHUnBibWM3WEc0Z0lHbG1JQ2h3ZFdKc2FXTmZhMlY1TG5CaFpHUnBibWNwSUh0Y2JpQWdJQ0J3WVdSa2FXNW5JRDBnY0hWaWJHbGpYMnRsZVM1d1lXUmthVzVuTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSEpsZG1WeWMyVXBJSHRjYmlBZ0lDQndZV1JrYVc1bklEMGdNVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J3WVdSa2FXNW5JRDBnTkR0Y2JpQWdmVnh1SUNCMllYSWdhMlY1SUQwZ2NHRnljMlZMWlhsektIQjFZbXhwWTE5clpYa3BPMXh1SUNCMllYSWdjR0ZrWkdWa1RYTm5PMXh1SUNCcFppQW9jR0ZrWkdsdVp5QTlQVDBnTkNrZ2UxeHVJQ0FnSUhCaFpHUmxaRTF6WnlBOUlHOWhaWEFvYTJWNUxDQnRjMmNwTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSEJoWkdScGJtY2dQVDA5SURFcElIdGNiaUFnSUNCd1lXUmtaV1JOYzJjZ1BTQndhMk56TVNoclpYa3NJRzF6Wnl3Z2NtVjJaWEp6WlNrN1hHNGdJSDBnWld4elpTQnBaaUFvY0dGa1pHbHVaeUE5UFQwZ015a2dlMXh1SUNBZ0lIQmhaR1JsWkUxelp5QTlJRzVsZHlCaWJpaHRjMmNwTzF4dUlDQWdJR2xtSUNod1lXUmtaV1JOYzJjdVkyMXdLR3RsZVM1dGIyUjFiSFZ6S1NBK1BTQXdLU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMlJoZEdFZ2RHOXZJR3h2Ym1jZ1ptOXlJRzF2WkhWc2RYTW5LVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZDFibXR1YjNkdUlIQmhaR1JwYm1jbktUdGNiaUFnZlZ4dUlDQnBaaUFvY21WMlpYSnpaU2tnZTF4dUlDQWdJSEpsZEhWeWJpQmpjblFvY0dGa1pHVmtUWE5uTENCclpYa3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQjNhWFJvVUhWaWJHbGpLSEJoWkdSbFpFMXpaeXdnYTJWNUtUdGNiaUFnZlZ4dWZUdGNibHh1Wm5WdVkzUnBiMjRnYjJGbGNDaHJaWGtzSUcxelp5bDdYRzRnSUhaaGNpQnJJRDBnYTJWNUxtMXZaSFZzZFhNdVlubDBaVXhsYm1kMGFDZ3BPMXh1SUNCMllYSWdiVXhsYmlBOUlHMXpaeTVzWlc1bmRHZzdYRzRnSUhaaGNpQnBTR0Z6YUNBOUlHTnlaV0YwWlVoaGMyZ29KM05vWVRFbktTNTFjR1JoZEdVb2JtVjNJRUoxWm1abGNpZ25KeWtwTG1ScFoyVnpkQ2dwTzF4dUlDQjJZWElnYUV4bGJpQTlJR2xJWVhOb0xteGxibWQwYUR0Y2JpQWdkbUZ5SUdoTVpXNHlJRDBnTWlBcUlHaE1aVzQ3WEc0Z0lHbG1JQ2h0VEdWdUlENGdheUF0SUdoTVpXNHlJQzBnTWlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduYldWemMyRm5aU0IwYjI4Z2JHOXVaeWNwTzF4dUlDQjlYRzRnSUhaaGNpQndjeUE5SUc1bGR5QkNkV1ptWlhJb2F5QXRJRzFNWlc0Z0xTQm9UR1Z1TWlBdElESXBPMXh1SUNCd2N5NW1hV3hzS0RBcE8xeHVJQ0IyWVhJZ1pHSnNaVzRnUFNCcklDMGdhRXhsYmlBdElERTdYRzRnSUhaaGNpQnpaV1ZrSUQwZ2NtRnVaRzl0UW5sMFpYTW9hRXhsYmlrN1hHNGdJSFpoY2lCdFlYTnJaV1JFWWlBOUlIaHZjaWhDZFdabVpYSXVZMjl1WTJGMEtGdHBTR0Z6YUN3Z2NITXNJRzVsZHlCQ2RXWm1aWElvV3pGZEtTd2diWE5uWFN3Z1pHSnNaVzRwTENCdFoyWW9jMlZsWkN3Z1pHSnNaVzRwS1R0Y2JpQWdkbUZ5SUcxaGMydGxaRk5sWldRZ1BTQjRiM0lvYzJWbFpDd2diV2RtS0cxaGMydGxaRVJpTENCb1RHVnVLU2s3WEc0Z0lISmxkSFZ5YmlCdVpYY2dZbTRvUW5WbVptVnlMbU52Ym1OaGRDaGJibVYzSUVKMVptWmxjaWhiTUYwcExDQnRZWE5yWldSVFpXVmtMQ0J0WVhOclpXUkVZbDBzSUdzcEtUdGNibjFjYm1aMWJtTjBhVzl1SUhCclkzTXhLR3RsZVN3Z2JYTm5MQ0J5WlhabGNuTmxLWHRjYmlBZ2RtRnlJRzFNWlc0Z1BTQnRjMmN1YkdWdVozUm9PMXh1SUNCMllYSWdheUE5SUd0bGVTNXRiMlIxYkhWekxtSjVkR1ZNWlc1bmRHZ29LVHRjYmlBZ2FXWWdLRzFNWlc0Z1BpQnJJQzBnTVRFcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjIxbGMzTmhaMlVnZEc5dklHeHZibWNuS1R0Y2JpQWdmVnh1SUNCMllYSWdjSE03WEc0Z0lHbG1JQ2h5WlhabGNuTmxLU0I3WEc0Z0lDQWdjSE1nUFNCdVpYY2dRblZtWm1WeUtHc2dMU0J0VEdWdUlDMGdNeWs3WEc0Z0lDQWdjSE11Wm1sc2JDZ3dlR1ptS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCd2N5QTlJRzV2YmxwbGNtOG9heUF0SUcxTVpXNGdMU0F6S1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnYm1WM0lHSnVLRUoxWm1abGNpNWpiMjVqWVhRb1cyNWxkeUJDZFdabVpYSW9XekFzSUhKbGRtVnljMlUvTVRveVhTa3NJSEJ6TENCdVpYY2dRblZtWm1WeUtGc3dYU2tzSUcxeloxMHNJR3NwS1R0Y2JuMWNibVoxYm1OMGFXOXVJRzV2YmxwbGNtOG9iR1Z1TENCamNubHdkRzhwSUh0Y2JpQWdkbUZ5SUc5MWRDQTlJRzVsZHlCQ2RXWm1aWElvYkdWdUtUdGNiaUFnZG1GeUlHa2dQU0F3TzF4dUlDQjJZWElnWTJGamFHVWdQU0J5WVc1a2IyMUNlWFJsY3loc1pXNHFNaWs3WEc0Z0lIWmhjaUJqZFhJZ1BTQXdPMXh1SUNCMllYSWdiblZ0TzF4dUlDQjNhR2xzWlNBb2FTQThJR3hsYmlrZ2UxeHVJQ0FnSUdsbUlDaGpkWElnUFQwOUlHTmhZMmhsTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnWTJGamFHVWdQU0J5WVc1a2IyMUNlWFJsY3loc1pXNHFNaWs3WEc0Z0lDQWdJQ0JqZFhJZ1BTQXdPMXh1SUNBZ0lIMWNiaUFnSUNCdWRXMGdQU0JqWVdOb1pWdGpkWElySzEwN1hHNGdJQ0FnYVdZZ0tHNTFiU2tnZTF4dUlDQWdJQ0FnYjNWMFcya3JLMTBnUFNCdWRXMDdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdmRYUTdYRzU5SWwxOSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJyk7XG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKTtcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIHdpdGhQdWJsaWMgPSByZXF1aXJlKCcuL3dpdGhQdWJsaWMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJpdmF0ZURlY3J5cHQocHJpdmF0ZV9rZXksIGVuYywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZztcbiAgaWYgKHByaXZhdGVfa2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHJpdmF0ZV9rZXkucGFkZGluZztcbiAgfSBlbHNlIGlmIChyZXZlcnNlKSB7XG4gICAgcGFkZGluZyA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcGFkZGluZyA9IDQ7XG4gIH1cbiAgXG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHJpdmF0ZV9rZXkpO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgaWYgKGVuYy5sZW5ndGggPiBrIHx8IG5ldyBibihlbmMpLmNtcChrZXkubW9kdWx1cykgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHZhciBtc2c7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbXNnID0gd2l0aFB1YmxpYyhuZXcgYm4oZW5jKSwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBjcnQoZW5jLCBrZXkpO1xuICB9XG4gIHZhciB6QnVmZmVyID0gbmV3IEJ1ZmZlcihrIC0gbXNnLmxlbmd0aCk7XG4gIHpCdWZmZXIuZmlsbCgwKTtcbiAgbXNnID0gQnVmZmVyLmNvbmNhdChbekJ1ZmZlciwgbXNnXSwgayk7XG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcmV0dXJuIG9hZXAoa2V5LCBtc2cpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICByZXR1cm4gcGtjczEoa2V5LCBtc2csIHJldmVyc2UpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDMpIHtcbiAgICByZXR1cm4gbXNnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwYWRkaW5nJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9hZXAoa2V5LCBtc2cpe1xuICB2YXIgbiA9IGtleS5tb2R1bHVzO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoO1xuICB2YXIgaUhhc2ggPSBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKG5ldyBCdWZmZXIoJycpKS5kaWdlc3QoKTtcbiAgdmFyIGhMZW4gPSBpSGFzaC5sZW5ndGg7XG4gIHZhciBoTGVuMiA9IDIgKiBoTGVuO1xuICBpZiAobXNnWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgdmFyIG1hc2tlZFNlZWQgPSBtc2cuc2xpY2UoMSwgaExlbiArIDEpO1xuICB2YXIgbWFza2VkRGIgPSAgbXNnLnNsaWNlKGhMZW4gKyAxKTtcbiAgdmFyIHNlZWQgPSB4b3IobWFza2VkU2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSk7XG4gIHZhciBkYiA9IHhvcihtYXNrZWREYiwgbWdmKHNlZWQsIGsgLSBoTGVuIC0gMSkpO1xuICBpZiAoY29tcGFyZShpSGFzaCwgZGIuc2xpY2UoMCwgaExlbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgdmFyIGkgPSBoTGVuO1xuICB3aGlsZSAoZGJbaV0gPT09IDApIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGRiW2krK10gIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICByZXR1cm4gZGIuc2xpY2UoaSk7XG59XG5cbmZ1bmN0aW9uIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKXtcbiAgdmFyIHAxID0gbXNnLnNsaWNlKDAsIDIpO1xuICB2YXIgaSA9IDI7XG4gIHZhciBzdGF0dXMgPSAwO1xuICB3aGlsZSAobXNnW2krK10gIT09IDApIHtcbiAgICBpZiAoaSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgICBzdGF0dXMrKztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgcHMgPSBtc2cuc2xpY2UoMiwgaSAtIDEpO1xuICB2YXIgcDIgPSBtc2cuc2xpY2UoaSAtIDEsIGkpO1xuXG4gIGlmICgocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMicgJiYgIXJldmVyc2UpIHx8IChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAxJyAmJiByZXZlcnNlKSl7XG4gICAgc3RhdHVzKys7XG4gIH1cbiAgaWYgKHBzLmxlbmd0aCA8IDgpIHtcbiAgICBzdGF0dXMrKztcbiAgfVxuICBpZiAoc3RhdHVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgcmV0dXJuICBtc2cuc2xpY2UoaSk7XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpe1xuICBhID0gbmV3IEJ1ZmZlcihhKTtcbiAgYiA9IG5ldyBCdWZmZXIoYik7XG4gIHZhciBkaWYgPSAwO1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICBkaWYrKztcbiAgICBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICB9XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBkaWYgKz0gKGFbaV0gXiBiW2ldKTtcbiAgfVxuICByZXR1cm4gZGlmO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZjSFZpYkdsakxXVnVZM0o1Y0hRdmNISnBkbUYwWlVSbFkzSjVjSFF1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lkbUZ5SUhCaGNuTmxTMlY1Y3lBOUlISmxjWFZwY21Vb0ozQmhjbk5sTFdGemJqRW5LVHRjYm5aaGNpQnRaMllnUFNCeVpYRjFhWEpsS0NjdUwyMW5aaWNwTzF4dWRtRnlJSGh2Y2lBOUlISmxjWFZwY21Vb0p5NHZlRzl5SnlrN1hHNTJZWElnWW00Z1BTQnlaWEYxYVhKbEtDZGliaTVxY3ljcE8xeHVkbUZ5SUdOeWRDQTlJSEpsY1hWcGNtVW9KMkp5YjNkelpYSnBabmt0Y25OaEp5azdYRzUyWVhJZ1kzSmxZWFJsU0dGemFDQTlJSEpsY1hWcGNtVW9KMk55WldGMFpTMW9ZWE5vSnlrN1hHNTJZWElnZDJsMGFGQjFZbXhwWXlBOUlISmxjWFZwY21Vb0p5NHZkMmwwYUZCMVlteHBZeWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCd2NtbDJZWFJsUkdWamNubHdkQ2h3Y21sMllYUmxYMnRsZVN3Z1pXNWpMQ0J5WlhabGNuTmxLU0I3WEc0Z0lIWmhjaUJ3WVdSa2FXNW5PMXh1SUNCcFppQW9jSEpwZG1GMFpWOXJaWGt1Y0dGa1pHbHVaeWtnZTF4dUlDQWdJSEJoWkdScGJtY2dQU0J3Y21sMllYUmxYMnRsZVM1d1lXUmthVzVuTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSEpsZG1WeWMyVXBJSHRjYmlBZ0lDQndZV1JrYVc1bklEMGdNVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J3WVdSa2FXNW5JRDBnTkR0Y2JpQWdmVnh1SUNCY2JpQWdkbUZ5SUd0bGVTQTlJSEJoY25ObFMyVjVjeWh3Y21sMllYUmxYMnRsZVNrN1hHNGdJSFpoY2lCcklEMGdhMlY1TG0xdlpIVnNkWE11WW5sMFpVeGxibWQwYUNncE8xeHVJQ0JwWmlBb1pXNWpMbXhsYm1kMGFDQStJR3NnZkh3Z2JtVjNJR0p1S0dWdVl5a3VZMjF3S0d0bGVTNXRiMlIxYkhWektTQStQU0F3S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RrWldOeWVYQjBhVzl1SUdWeWNtOXlKeWs3WEc0Z0lIMWNiaUFnZG1GeUlHMXpaenRjYmlBZ2FXWWdLSEpsZG1WeWMyVXBJSHRjYmlBZ0lDQnRjMmNnUFNCM2FYUm9VSFZpYkdsaktHNWxkeUJpYmlobGJtTXBMQ0JyWlhrcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHMXpaeUE5SUdOeWRDaGxibU1zSUd0bGVTazdYRzRnSUgxY2JpQWdkbUZ5SUhwQ2RXWm1aWElnUFNCdVpYY2dRblZtWm1WeUtHc2dMU0J0YzJjdWJHVnVaM1JvS1R0Y2JpQWdla0oxWm1abGNpNW1hV3hzS0RBcE8xeHVJQ0J0YzJjZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0NlFuVm1abVZ5TENCdGMyZGRMQ0JyS1R0Y2JpQWdhV1lnS0hCaFpHUnBibWNnUFQwOUlEUXBJSHRjYmlBZ0lDQnlaWFIxY200Z2IyRmxjQ2hyWlhrc0lHMXpaeWs3WEc0Z0lIMGdaV3h6WlNCcFppQW9jR0ZrWkdsdVp5QTlQVDBnTVNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ3YTJOek1TaHJaWGtzSUcxelp5d2djbVYyWlhKelpTazdYRzRnSUgwZ1pXeHpaU0JwWmlBb2NHRmtaR2x1WnlBOVBUMGdNeWtnZTF4dUlDQWdJSEpsZEhWeWJpQnRjMmM3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QxYm10dWIzZHVJSEJoWkdScGJtY25LVHRjYmlBZ2ZWeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2IyRmxjQ2hyWlhrc0lHMXpaeWw3WEc0Z0lIWmhjaUJ1SUQwZ2EyVjVMbTF2WkhWc2RYTTdYRzRnSUhaaGNpQnJJRDBnYTJWNUxtMXZaSFZzZFhNdVlubDBaVXhsYm1kMGFDZ3BPMXh1SUNCMllYSWdiVXhsYmlBOUlHMXpaeTVzWlc1bmRHZzdYRzRnSUhaaGNpQnBTR0Z6YUNBOUlHTnlaV0YwWlVoaGMyZ29KM05vWVRFbktTNTFjR1JoZEdVb2JtVjNJRUoxWm1abGNpZ25KeWtwTG1ScFoyVnpkQ2dwTzF4dUlDQjJZWElnYUV4bGJpQTlJR2xJWVhOb0xteGxibWQwYUR0Y2JpQWdkbUZ5SUdoTVpXNHlJRDBnTWlBcUlHaE1aVzQ3WEc0Z0lHbG1JQ2h0YzJkYk1GMGdJVDA5SURBcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJSbFkzSjVjSFJwYjI0Z1pYSnliM0luS1R0Y2JpQWdmVnh1SUNCMllYSWdiV0Z6YTJWa1UyVmxaQ0E5SUcxelp5NXpiR2xqWlNneExDQm9UR1Z1SUNzZ01TazdYRzRnSUhaaGNpQnRZWE5yWldSRVlpQTlJQ0J0YzJjdWMyeHBZMlVvYUV4bGJpQXJJREVwTzF4dUlDQjJZWElnYzJWbFpDQTlJSGh2Y2lodFlYTnJaV1JUWldWa0xDQnRaMllvYldGemEyVmtSR0lzSUdoTVpXNHBLVHRjYmlBZ2RtRnlJR1JpSUQwZ2VHOXlLRzFoYzJ0bFpFUmlMQ0J0WjJZb2MyVmxaQ3dnYXlBdElHaE1aVzRnTFNBeEtTazdYRzRnSUdsbUlDaGpiMjF3WVhKbEtHbElZWE5vTENCa1lpNXpiR2xqWlNnd0xDQm9UR1Z1S1NrcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJSbFkzSjVjSFJwYjI0Z1pYSnliM0luS1R0Y2JpQWdmVnh1SUNCMllYSWdhU0E5SUdoTVpXNDdYRzRnSUhkb2FXeGxJQ2hrWWx0cFhTQTlQVDBnTUNrZ2UxeHVJQ0FnSUdrckt6dGNiaUFnZlZ4dUlDQnBaaUFvWkdKYmFTc3JYU0FoUFQwZ01Ta2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblpHVmpjbmx3ZEdsdmJpQmxjbkp2Y2ljcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCa1lpNXpiR2xqWlNocEtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2NHdGpjekVvYTJWNUxDQnRjMmNzSUhKbGRtVnljMlVwZTF4dUlDQjJZWElnY0RFZ1BTQnRjMmN1YzJ4cFkyVW9NQ3dnTWlrN1hHNGdJSFpoY2lCcElEMGdNanRjYmlBZ2RtRnlJSE4wWVhSMWN5QTlJREE3WEc0Z0lIZG9hV3hsSUNodGMyZGJhU3NyWFNBaFBUMGdNQ2tnZTF4dUlDQWdJR2xtSUNocElENDlJRzF6Wnk1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUhOMFlYUjFjeXNyTzF4dUlDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lIWmhjaUJ3Y3lBOUlHMXpaeTV6YkdsalpTZ3lMQ0JwSUMwZ01TazdYRzRnSUhaaGNpQndNaUE5SUcxelp5NXpiR2xqWlNocElDMGdNU3dnYVNrN1hHNWNiaUFnYVdZZ0tDaHdNUzUwYjFOMGNtbHVaeWduYUdWNEp5a2dJVDA5SUNjd01EQXlKeUFtSmlBaGNtVjJaWEp6WlNrZ2ZId2dLSEF4TG5SdlUzUnlhVzVuS0Nkb1pYZ25LU0FoUFQwZ0p6QXdNREVuSUNZbUlISmxkbVZ5YzJVcEtYdGNiaUFnSUNCemRHRjBkWE1yS3p0Y2JpQWdmVnh1SUNCcFppQW9jSE11YkdWdVozUm9JRHdnT0NrZ2UxeHVJQ0FnSUhOMFlYUjFjeXNyTzF4dUlDQjlYRzRnSUdsbUlDaHpkR0YwZFhNcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJSbFkzSjVjSFJwYjI0Z1pYSnliM0luS1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnSUcxelp5NXpiR2xqWlNocEtUdGNibjFjYm1aMWJtTjBhVzl1SUdOdmJYQmhjbVVvWVN3Z1lpbDdYRzRnSUdFZ1BTQnVaWGNnUW5WbVptVnlLR0VwTzF4dUlDQmlJRDBnYm1WM0lFSjFabVpsY2loaUtUdGNiaUFnZG1GeUlHUnBaaUE5SURBN1hHNGdJSFpoY2lCc1pXNGdQU0JoTG14bGJtZDBhRHRjYmlBZ2FXWWdLR0V1YkdWdVozUm9JQ0U5UFNCaUxteGxibWQwYUNrZ2UxeHVJQ0FnSUdScFppc3JPMXh1SUNBZ0lHeGxiaUE5SUUxaGRHZ3ViV2x1S0dFdWJHVnVaM1JvTENCaUxteGxibWQwYUNrN1hHNGdJSDFjYmlBZ2RtRnlJR2tnUFNBdE1UdGNiaUFnZDJocGJHVWdLQ3NyYVNBOElHeGxiaWtnZTF4dUlDQWdJR1JwWmlBclBTQW9ZVnRwWFNCZUlHSmJhVjBwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJrYVdZN1hHNTlJbDE5IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IoYSwgYikge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhW2ldIF49IGJbaV07XG4gIH1cbiAgcmV0dXJuIGFcbn07IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbmZ1bmN0aW9uIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkZGVkTXNnXG4gICAgLnRvUmVkKGJuLm1vbnQoa2V5Lm1vZHVsdXMpKVxuICAgIC5yZWRQb3cobmV3IGJuKGtleS5wdWJsaWNFeHBvbmVudCkpXG4gICAgLmZyb21SZWQoKVxuICAgIC50b0FycmF5KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNIVmliR2xqTFdWdVkzSjVjSFF2ZDJsMGFGQjFZbXhwWXk1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkluWmhjaUJpYmlBOUlISmxjWFZwY21Vb0oySnVMbXB6SnlrN1hHNW1kVzVqZEdsdmJpQjNhWFJvVUhWaWJHbGpLSEJoWkdSbFpFMXpaeXdnYTJWNUtTQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1FuVm1abVZ5S0hCaFpHUmxaRTF6WjF4dUlDQWdJQzUwYjFKbFpDaGliaTV0YjI1MEtHdGxlUzV0YjJSMWJIVnpLU2xjYmlBZ0lDQXVjbVZrVUc5M0tHNWxkeUJpYmloclpYa3VjSFZpYkdsalJYaHdiMjVsYm5RcEtWeHVJQ0FnSUM1bWNtOXRVbVZrS0NsY2JpQWdJQ0F1ZEc5QmNuSmhlU2dwS1R0Y2JuMWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0IzYVhSb1VIVmliR2xqT3lKZGZRPT0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpO1xudmFyIGFlc2lkID0gcmVxdWlyZSgnLi9hZXNpZC5qc29uJyk7XG52YXIgZml4UHJvYyA9IHJlcXVpcmUoJy4vZml4UHJvYycpO1xudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpO1xudmFyIGNvbXBhdCA9IHJlcXVpcmUoJ3Bia2RmMicpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUtleXM7XG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyhidWZmZXIpIHtcbiAgdmFyIHBhc3N3b3JkO1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZTtcbiAgICBidWZmZXIgPSBidWZmZXIua2V5O1xuICB9XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZCk7XG5cbiAgdmFyIHR5cGUgPSBzdHJpcHBlZC50YWc7XG4gIHZhciBkYXRhID0gc3RyaXBwZWQuZGF0YTtcbiAgdmFyIHN1YnR5cGUsbmRhdGE7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpO1xuICAgICAgc3dpdGNoKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJyk7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogIG5kYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyAgc3VidHlwZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArICB0eXBlKTtcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgLy9mYWxsaW5nIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpO1xuICAgICAgc3dpdGNoKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJyk7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VydmU6IG5kYXRhLmFsZ29yaXRobS5jdXJ2ZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpLnByaXZhdGVLZXlcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgIHN1YnR5cGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyAgdHlwZSk7XG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICBjYXNlICdEU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgIHBhcmFtczogYXNuMS5EU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH07XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH07XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyAgdHlwZSk7XG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZTtcbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdDtcbiAgdmFyIGl0ZXJzID0gcGFyc2VJbnQoZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLml0ZXJzLnRvU3RyaW5nKCksIDEwKTtcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV07XG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2O1xuICB2YXIgY2lwaGVyVGV4dCA9IGRhdGEuc3ViamVjdFByaXZhdGVLZXk7XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKS84O1xuICB2YXIga2V5ID0gY29tcGF0LnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJzLCBrZXlsZW4pO1xuICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KGFsZ28sIGtleSwgaXYpO1xuICB2YXIgb3V0ID0gW107XG4gIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpO1xuICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12Y0hWaWJHbGpMV1Z1WTNKNWNIUXZibTlrWlY5dGIyUjFiR1Z6TDNCaGNuTmxMV0Z6YmpFdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR0Z6YmpFZ1BTQnlaWEYxYVhKbEtDY3VMMkZ6YmpFbktUdGNiblpoY2lCaFpYTnBaQ0E5SUhKbGNYVnBjbVVvSnk0dllXVnphV1F1YW5OdmJpY3BPMXh1ZG1GeUlHWnBlRkJ5YjJNZ1BTQnlaWEYxYVhKbEtDY3VMMlpwZUZCeWIyTW5LVHRjYm5aaGNpQmphWEJvWlhKeklEMGdjbVZ4ZFdseVpTZ25Zbkp2ZDNObGNtbG1lUzFoWlhNbktUdGNiblpoY2lCamIyMXdZWFFnUFNCeVpYRjFhWEpsS0Nkd1ltdGtaakluS1R0Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2NHRnljMlZMWlhsek8xeHVYRzVtZFc1amRHbHZiaUJ3WVhKelpVdGxlWE1vWW5WbVptVnlLU0I3WEc0Z0lIWmhjaUJ3WVhOemQyOXlaRHRjYmlBZ2FXWWdLSFI1Y0dWdlppQmlkV1ptWlhJZ1BUMDlJQ2R2WW1wbFkzUW5JQ1ltSUNGQ2RXWm1aWEl1YVhOQ2RXWm1aWElvWW5WbVptVnlLU2tnZTF4dUlDQWdJSEJoYzNOM2IzSmtJRDBnWW5WbVptVnlMbkJoYzNOd2FISmhjMlU3WEc0Z0lDQWdZblZtWm1WeUlEMGdZblZtWm1WeUxtdGxlVHRjYmlBZ2ZWeHVJQ0JwWmlBb2RIbHdaVzltSUdKMVptWmxjaUE5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCaWRXWm1aWElnUFNCdVpYY2dRblZtWm1WeUtHSjFabVpsY2lrN1hHNGdJSDFjYmx4dUlDQjJZWElnYzNSeWFYQndaV1FnUFNCbWFYaFFjbTlqS0dKMVptWmxjaXdnY0dGemMzZHZjbVFwTzF4dVhHNGdJSFpoY2lCMGVYQmxJRDBnYzNSeWFYQndaV1F1ZEdGbk8xeHVJQ0IyWVhJZ1pHRjBZU0E5SUhOMGNtbHdjR1ZrTG1SaGRHRTdYRzRnSUhaaGNpQnpkV0owZVhCbExHNWtZWFJoTzF4dUlDQnpkMmwwWTJnZ0tIUjVjR1VwSUh0Y2JpQWdJQ0JqWVhObElDZFFWVUpNU1VNZ1MwVlpKenBjYmlBZ0lDQWdJRzVrWVhSaElEMGdZWE51TVM1UWRXSnNhV05MWlhrdVpHVmpiMlJsS0dSaGRHRXNJQ2RrWlhJbktUdGNiaUFnSUNBZ0lITjFZblI1Y0dVZ1BTQnVaR0YwWVM1aGJHZHZjbWwwYUcwdVlXeG5iM0pwZEdodExtcHZhVzRvSnk0bktUdGNiaUFnSUNBZ0lITjNhWFJqYUNoemRXSjBlWEJsS1NCN1hHNGdJQ0FnSUNBZ0lHTmhjMlVnSnpFdU1pNDROREF1TVRFek5UUTVMakV1TVM0eEp6cGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWE51TVM1U1UwRlFkV0pzYVdOTFpYa3VaR1ZqYjJSbEtHNWtZWFJoTG5OMVltcGxZM1JRZFdKc2FXTkxaWGt1WkdGMFlTd2dKMlJsY2ljcE8xeHVJQ0FnSUNBZ0lDQmpZWE5sSUNjeExqSXVPRFF3TGpFd01EUTFMakl1TVNjNlhHNGdJQ0FnSUNBZ0lHNWtZWFJoTG5OMVltcGxZM1JRY21sMllYUmxTMlY1SUQwZ2JtUmhkR0V1YzNWaWFtVmpkRkIxWW14cFkwdGxlVHRjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkSGx3WlRvZ0oyVmpKeXhjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0U2SUNCdVpHRjBZVnh1SUNBZ0lDQWdJQ0FnSUgwN1hHNGdJQ0FnSUNBZ0lHTmhjMlVnSnpFdU1pNDROREF1TVRBd05EQXVOQzR4SnpwY2JpQWdJQ0FnSUNBZ0lDQnVaR0YwWVM1aGJHZHZjbWwwYUcwdWNHRnlZVzF6TG5CMVlsOXJaWGtnUFNCaGMyNHhMa1JUUVhCaGNtRnRMbVJsWTI5a1pTaHVaR0YwWVM1emRXSnFaV04wVUhWaWJHbGpTMlY1TG1SaGRHRXNJQ2RrWlhJbktUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVG9nSjJSellTY3NYRzRnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhPaUJ1WkdGMFlTNWhiR2R2Y21sMGFHMHVjR0Z5WVcxelhHNGdJQ0FnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkRG9nZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QxYm10dWIzZHVJR3RsZVNCcFpDQW5JQ3NnSUhOMVluUjVjR1VwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QxYm10dWIzZHVJR3RsZVNCMGVYQmxJQ2NnS3lBZ2RIbHdaU2s3WEc0Z0lDQWdZMkZ6WlNBblJVNURVbGxRVkVWRUlGQlNTVlpCVkVVZ1MwVlpKenBjYmlBZ0lDQWdJR1JoZEdFZ1BTQmhjMjR4TGtWdVkzSjVjSFJsWkZCeWFYWmhkR1ZMWlhrdVpHVmpiMlJsS0dSaGRHRXNJQ2RrWlhJbktUdGNiaUFnSUNBZ0lHUmhkR0VnUFNCa1pXTnllWEIwS0dSaGRHRXNJSEJoYzNOM2IzSmtLVHRjYmlBZ0lDQWdJQzh2Wm1Gc2JHbHVaeUIwYUhKdmRXZG9YRzRnSUNBZ1kyRnpaU0FuVUZKSlZrRlVSU0JMUlZrbk9seHVJQ0FnSUNBZ2JtUmhkR0VnUFNCaGMyNHhMbEJ5YVhaaGRHVkxaWGt1WkdWamIyUmxLR1JoZEdFc0lDZGtaWEluS1R0Y2JpQWdJQ0FnSUhOMVluUjVjR1VnUFNCdVpHRjBZUzVoYkdkdmNtbDBhRzB1WVd4bmIzSnBkR2h0TG1wdmFXNG9KeTRuS1R0Y2JpQWdJQ0FnSUhOM2FYUmphQ2h6ZFdKMGVYQmxLU0I3WEc0Z0lDQWdJQ0FnSUdOaGMyVWdKekV1TWk0NE5EQXVNVEV6TlRRNUxqRXVNUzR4SnpwY2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYTnVNUzVTVTBGUWNtbDJZWFJsUzJWNUxtUmxZMjlrWlNodVpHRjBZUzV6ZFdKcVpXTjBVSEpwZG1GMFpVdGxlU3dnSjJSbGNpY3BPMXh1SUNBZ0lDQWdJQ0JqWVhObElDY3hMakl1T0RRd0xqRXdNRFExTGpJdU1TYzZYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTjFjblpsT2lCdVpHRjBZUzVoYkdkdmNtbDBhRzB1WTNWeWRtVXNYRzRnSUNBZ0lDQWdJQ0FnSUNCd2NtbDJZWFJsUzJWNU9pQmhjMjR4TGtWRFVISnBkbUYwWlV0bGVTNWtaV052WkdVb2JtUmhkR0V1YzNWaWFtVmpkRkJ5YVhaaGRHVkxaWGtzSUNka1pYSW5LUzV3Y21sMllYUmxTMlY1WEc0Z0lDQWdJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lDQWdZMkZ6WlNBbk1TNHlMamcwTUM0eE1EQTBNQzQwTGpFbk9seHVJQ0FnSUNBZ0lDQWdJRzVrWVhSaExtRnNaMjl5YVhSb2JTNXdZWEpoYlhNdWNISnBkbDlyWlhrZ1BTQmhjMjR4TGtSVFFYQmhjbUZ0TG1SbFkyOWtaU2h1WkdGMFlTNXpkV0pxWldOMFVISnBkbUYwWlV0bGVTd2dKMlJsY2ljcE8xeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGVYQmxPaUFuWkhOaEp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUhCaGNtRnRjem9nYm1SaGRHRXVZV3huYjNKcGRHaHRMbkJoY21GdGMxeHVJQ0FnSUNBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0FnSUdSbFptRjFiSFE2SUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1cmJtOTNiaUJyWlhrZ2FXUWdKeUFySUNCemRXSjBlWEJsS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1cmJtOTNiaUJyWlhrZ2RIbHdaU0FuSUNzZ0lIUjVjR1VwTzF4dUlDQWdJR05oYzJVZ0oxSlRRU0JRVlVKTVNVTWdTMFZaSnpwY2JpQWdJQ0FnSUhKbGRIVnliaUJoYzI0eExsSlRRVkIxWW14cFkwdGxlUzVrWldOdlpHVW9aR0YwWVN3Z0oyUmxjaWNwTzF4dUlDQWdJR05oYzJVZ0oxSlRRU0JRVWtsV1FWUkZJRXRGV1NjNlhHNGdJQ0FnSUNCeVpYUjFjbTRnWVhOdU1TNVNVMEZRY21sMllYUmxTMlY1TG1SbFkyOWtaU2hrWVhSaExDQW5aR1Z5SnlrN1hHNGdJQ0FnWTJGelpTQW5SRk5CSUZCU1NWWkJWRVVnUzBWWkp6cGNiaUFnSUNBZ0lISmxkSFZ5YmlCN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNka2MyRW5MRnh1SUNBZ0lDQWdJQ0J3WVhKaGJYTTZJR0Z6YmpFdVJGTkJVSEpwZG1GMFpVdGxlUzVrWldOdlpHVW9aR0YwWVN3Z0oyUmxjaWNwWEc0Z0lDQWdJQ0I5TzF4dUlDQWdJR05oYzJVZ0owVkRJRkJTU1ZaQlZFVWdTMFZaSnpwY2JpQWdJQ0FnSUdSaGRHRWdQU0JoYzI0eExrVkRVSEpwZG1GMFpVdGxlUzVrWldOdlpHVW9aR0YwWVN3Z0oyUmxjaWNwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnWTNWeWRtVTZJR1JoZEdFdWNHRnlZVzFsZEdWeWN5NTJZV3gxWlN4Y2JpQWdJQ0FnSUNBZ2NISnBkbUYwWlV0bGVUb2daR0YwWVM1d2NtbDJZWFJsUzJWNVhHNGdJQ0FnSUNCOU8xeHVJQ0FnSUdSbFptRjFiSFE2SUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1cmJtOTNiaUJyWlhrZ2RIbHdaU0FuSUNzZ0lIUjVjR1VwTzF4dUlDQjlYRzU5WEc1d1lYSnpaVXRsZVhNdWMybG5ibUYwZFhKbElEMGdZWE51TVM1emFXZHVZWFIxY21VN1hHNW1kVzVqZEdsdmJpQmtaV055ZVhCMEtHUmhkR0VzSUhCaGMzTjNiM0prS1NCN1hHNGdJSFpoY2lCellXeDBJRDBnWkdGMFlTNWhiR2R2Y21sMGFHMHVaR1ZqY25sd2RDNXJaR1V1YTJSbGNHRnlZVzF6TG5OaGJIUTdYRzRnSUhaaGNpQnBkR1Z5Y3lBOUlIQmhjbk5sU1c1MEtHUmhkR0V1WVd4bmIzSnBkR2h0TG1SbFkzSjVjSFF1YTJSbExtdGtaWEJoY21GdGN5NXBkR1Z5Y3k1MGIxTjBjbWx1WnlncExDQXhNQ2s3WEc0Z0lIWmhjaUJoYkdkdklEMGdZV1Z6YVdSYlpHRjBZUzVoYkdkdmNtbDBhRzB1WkdWamNubHdkQzVqYVhCb1pYSXVZV3huYnk1cWIybHVLQ2N1SnlsZE8xeHVJQ0IyWVhJZ2FYWWdQU0JrWVhSaExtRnNaMjl5YVhSb2JTNWtaV055ZVhCMExtTnBjR2hsY2k1cGRqdGNiaUFnZG1GeUlHTnBjR2hsY2xSbGVIUWdQU0JrWVhSaExuTjFZbXBsWTNSUWNtbDJZWFJsUzJWNU8xeHVJQ0IyWVhJZ2EyVjViR1Z1SUQwZ2NHRnljMlZKYm5Rb1lXeG5ieTV6Y0d4cGRDZ25MU2NwV3pGZExDQXhNQ2t2T0R0Y2JpQWdkbUZ5SUd0bGVTQTlJR052YlhCaGRDNXdZbXRrWmpKVGVXNWpLSEJoYzNOM2IzSmtMQ0J6WVd4MExDQnBkR1Z5Y3l3Z2EyVjViR1Z1S1R0Y2JpQWdkbUZ5SUdOcGNHaGxjaUE5SUdOcGNHaGxjbk11WTNKbFlYUmxSR1ZqYVhCb1pYSnBkaWhoYkdkdkxDQnJaWGtzSUdsMktUdGNiaUFnZG1GeUlHOTFkQ0E5SUZ0ZE8xeHVJQ0J2ZFhRdWNIVnphQ2hqYVhCb1pYSXVkWEJrWVhSbEtHTnBjR2hsY2xSbGVIUXBLVHRjYmlBZ2IzVjBMbkIxYzJnb1kybHdhR1Z5TG1acGJtRnNLQ2twTzF4dUlDQnlaWFIxY200Z1FuVm1abVZ5TG1OdmJtTmhkQ2h2ZFhRcE8xeHVmVnh1SWwxOSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXBhdGlsL3BlbXN0cmlwXG52YXIgZmluZFByb2MgPSAvUHJvYy1UeXBlOiA0LEVOQ1JZUFRFRFxccj9cXG5ERUstSW5mbzogQUVTLSgoPzoxMjgpfCg/OjE5Mil8KD86MjU2KSktQ0JDLChbMC05QS1IXSspXFxyP1xcblxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4vbTtcbnZhciBzdGFydFJlZ2V4ID0vXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4vbTtcbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4tLS0tLUVORCBcXDEgS0VZLS0tLS0kL207XG52YXIgZXZwID0gcmVxdWlyZSgnLi9FVlBfQnl0ZXNUb0tleScpO1xudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2tleSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleSA9IG9rZXkudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGZpbmRQcm9jKTtcbiAgdmFyIGRlY3J5cHRlZDtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHZhciBtYXRjaDIgPSBrZXkubWF0Y2goZnVsbFJlZ2V4KTtcbiAgICBkZWNyeXB0ZWQgPSBuZXcgQnVmZmVyKG1hdGNoMlsyXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV07XG4gICAgdmFyIGl2ID0gbmV3IEJ1ZmZlcihtYXRjaFsyXSwgJ2hleCcpO1xuICAgIHZhciBjaXBoZXJUZXh0ID0gbmV3IEJ1ZmZlcihtYXRjaFszXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpO1xuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsOCksIHBhcnNlSW50KG1hdGNoWzFdKSk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpO1xuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpO1xuICAgIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKTtcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dCk7XG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXSArICcgS0VZJztcbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBkYXRhOiBkZWNyeXB0ZWRcbiAgfTtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcwMzM3MDVcbmZ1bmN0aW9uIHdyYXAgKHN0cikge1xuICB2YXIgY2h1bmtzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gNjQpIHtcbiAgICBjaHVua3MucHVzaChzdHIuc2xpY2UoaSwgaSArIDY0KSlcbiAgfVxuICByZXR1cm4gY2h1bmtzLmpvaW4oXCJcXG5cIilcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZjSFZpYkdsakxXVnVZM0o1Y0hRdmJtOWtaVjl0YjJSMWJHVnpMM0JoY25ObExXRnpiakV2Wm1sNFVISnZZeTVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5OGdZV1JoY0hSbFpDQm1jbTl0SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5aGNHRjBhV3d2Y0dWdGMzUnlhWEJjYm5aaGNpQm1hVzVrVUhKdll5QTlJQzlRY205akxWUjVjR1U2SURRc1JVNURVbGxRVkVWRVhGeHlQMXhjYmtSRlN5MUpibVp2T2lCQlJWTXRLQ2cvT2pFeU9DbDhLRDg2TVRreUtYd29Qem95TlRZcEtTMURRa01zS0Zzd0xUbEJMVWhkS3lsY1hISS9YRnh1WEZ4eVAxeGNiaWhiTUMwNVFTMTZYRnh1WEZ4eVhGd3JYRnd2WEZ3OVhTc3BYRnh5UDF4Y2JpOXRPMXh1ZG1GeUlITjBZWEowVW1WblpYZ2dQUzllTFMwdExTMUNSVWRKVGlBb0xpb3BJRXRGV1MwdExTMHRYRnh5UDF4Y2JpOXRPMXh1ZG1GeUlHWjFiR3hTWldkbGVDQTlJQzllTFMwdExTMUNSVWRKVGlBb0xpb3BJRXRGV1MwdExTMHRYRnh5UDF4Y2JpaGJNQzA1UVMxNlhGeHVYRnh5WEZ3clhGd3ZYRnc5WFNzcFhGeHlQMXhjYmkwdExTMHRSVTVFSUZ4Y01TQkxSVmt0TFMwdExTUXZiVHRjYm5aaGNpQmxkbkFnUFNCeVpYRjFhWEpsS0NjdUwwVldVRjlDZVhSbGMxUnZTMlY1SnlrN1hHNTJZWElnWTJsd2FHVnljeUE5SUhKbGNYVnBjbVVvSjJKeWIzZHpaWEpwWm5rdFlXVnpKeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUNodmEyVjVMQ0J3WVhOemQyOXlaQ2tnZTF4dUlDQjJZWElnYTJWNUlEMGdiMnRsZVM1MGIxTjBjbWx1WnlncE8xeHVJQ0IyWVhJZ2JXRjBZMmdnUFNCclpYa3ViV0YwWTJnb1ptbHVaRkJ5YjJNcE8xeHVJQ0IyWVhJZ1pHVmpjbmx3ZEdWa08xeHVJQ0JwWmlBb0lXMWhkR05vS1NCN1hHNGdJQ0FnZG1GeUlHMWhkR05vTWlBOUlHdGxlUzV0WVhSamFDaG1kV3hzVW1WblpYZ3BPMXh1SUNBZ0lHUmxZM0o1Y0hSbFpDQTlJRzVsZHlCQ2RXWm1aWElvYldGMFkyZ3lXekpkTG5KbGNHeGhZMlVvTDF4Y2NqOWNYRzR2Wnl3Z0p5Y3BMQ0FuWW1GelpUWTBKeWs3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnZG1GeUlITjFhWFJsSUQwZ0oyRmxjeWNnS3lCdFlYUmphRnN4WFR0Y2JpQWdJQ0IyWVhJZ2FYWWdQU0J1WlhjZ1FuVm1abVZ5S0cxaGRHTm9XekpkTENBbmFHVjRKeWs3WEc0Z0lDQWdkbUZ5SUdOcGNHaGxjbFJsZUhRZ1BTQnVaWGNnUW5WbVptVnlLRzFoZEdOb1d6TmRMbkpsY0d4aFkyVW9MMXhjY2o5Y1hHNHZaeXdnSnljcExDQW5ZbUZ6WlRZMEp5azdYRzRnSUNBZ2RtRnlJR05wY0dobGNrdGxlU0E5SUdWMmNDaHdZWE56ZDI5eVpDd2dhWFl1YzJ4cFkyVW9NQ3c0S1N3Z2NHRnljMlZKYm5Rb2JXRjBZMmhiTVYwcEtUdGNiaUFnSUNCMllYSWdiM1YwSUQwZ1cxMDdYRzRnSUNBZ2RtRnlJR05wY0dobGNpQTlJR05wY0dobGNuTXVZM0psWVhSbFJHVmphWEJvWlhKcGRpaHpkV2wwWlN3Z1kybHdhR1Z5UzJWNUxDQnBkaWs3WEc0Z0lDQWdiM1YwTG5CMWMyZ29ZMmx3YUdWeUxuVndaR0YwWlNoamFYQm9aWEpVWlhoMEtTazdYRzRnSUNBZ2IzVjBMbkIxYzJnb1kybHdhR1Z5TG1acGJtRnNLQ2twTzF4dUlDQWdJR1JsWTNKNWNIUmxaQ0E5SUVKMVptWmxjaTVqYjI1allYUW9iM1YwS1R0Y2JpQWdmVnh1SUNCMllYSWdkR0ZuSUQwZ2EyVjVMbTFoZEdOb0tITjBZWEowVW1WblpYZ3BXekZkSUNzZ0p5QkxSVmtuTzF4dUlDQnlaWFIxY200Z2UxeHVJQ0FnSUhSaFp6b2dkR0ZuTEZ4dUlDQWdJR1JoZEdFNklHUmxZM0o1Y0hSbFpGeHVJQ0I5TzF4dWZUdGNibHh1THk4Z2FIUjBjRG92TDNOMFlXTnJiM1psY21ac2IzY3VZMjl0TDJFdk56QXpNemN3TlZ4dVpuVnVZM1JwYjI0Z2QzSmhjQ0FvYzNSeUtTQjdYRzRnSUhaaGNpQmphSFZ1YTNNZ1BTQmJYVnh1WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djM1J5TG14bGJtZDBhRHNnYVNBclBTQTJOQ2tnZTF4dUlDQWdJR05vZFc1cmN5NXdkWE5vS0hOMGNpNXpiR2xqWlNocExDQnBJQ3NnTmpRcEtWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCamFIVnVhM011YW05cGJpaGNJbHhjYmx3aUtWeHVmVnh1SWwxOSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXZwKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4pIHtcbiAga2V5TGVuID0ga2V5TGVuLzg7XG4gIHZhciBraSA9IDA7XG4gIHZhciBpaSA9IDA7XG4gIHZhciBrZXkgPSBuZXcgQnVmZmVyKGtleUxlbik7XG4gIHZhciBhZGRtZCA9IDA7XG4gIHZhciBtZCwgbWRfYnVmO1xuICB2YXIgaTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBtZCA9IGNyZWF0ZUhhc2goJ21kNScpO1xuICAgIGlmKGFkZG1kKysgPiAwKSB7XG4gICAgICAgbWQudXBkYXRlKG1kX2J1Zik7XG4gICAgfVxuICAgIG1kLnVwZGF0ZShwYXNzd29yZCk7XG4gICAgbWQudXBkYXRlKHNhbHQpO1xuICAgIG1kX2J1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIGkgPSAwO1xuICAgIGlmKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaWYoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGtleVtraSsrXSA9IG1kX2J1ZltpKytdO1xuICAgICAgICBrZXlMZW4tLTtcbiAgICAgICB9XG4gICAgfVxuICAgaWYoa2V5TGVuID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZm9yKGk9MDtpPG1kX2J1Zi5sZW5ndGg7aSsrKSB7XG4gICAgbWRfYnVmW2ldID0gMDtcbiAgfVxuICByZXR1cm4ga2V5O1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12Y0hWaWJHbGpMV1Z1WTNKNWNIUXZibTlrWlY5dGIyUjFiR1Z6TDNCaGNuTmxMV0Z6YmpFdlJWWlFYMEo1ZEdWelZHOUxaWGt1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR055WldGMFpVaGhjMmdnUFNCeVpYRjFhWEpsS0NkamNtVmhkR1V0YUdGemFDY3BPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJsZG5Bb2NHRnpjM2R2Y21Rc0lITmhiSFFzSUd0bGVVeGxiaWtnZTF4dUlDQnJaWGxNWlc0Z1BTQnJaWGxNWlc0dk9EdGNiaUFnZG1GeUlHdHBJRDBnTUR0Y2JpQWdkbUZ5SUdscElEMGdNRHRjYmlBZ2RtRnlJR3RsZVNBOUlHNWxkeUJDZFdabVpYSW9hMlY1VEdWdUtUdGNiaUFnZG1GeUlHRmtaRzFrSUQwZ01EdGNiaUFnZG1GeUlHMWtMQ0J0WkY5aWRXWTdYRzRnSUhaaGNpQnBPMXh1SUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1SUNBZ0lHMWtJRDBnWTNKbFlYUmxTR0Z6YUNnbmJXUTFKeWs3WEc0Z0lDQWdhV1lvWVdSa2JXUXJLeUErSURBcElIdGNiaUFnSUNBZ0lDQnRaQzUxY0dSaGRHVW9iV1JmWW5WbUtUdGNiaUFnSUNCOVhHNGdJQ0FnYldRdWRYQmtZWFJsS0hCaGMzTjNiM0prS1R0Y2JpQWdJQ0J0WkM1MWNHUmhkR1VvYzJGc2RDazdYRzRnSUNBZ2JXUmZZblZtSUQwZ2JXUXVaR2xuWlhOMEtDazdYRzRnSUNBZ2FTQTlJREE3WEc0Z0lDQWdhV1lvYTJWNVRHVnVJRDRnTUNrZ2UxeHVJQ0FnSUNBZ2QyaHBiR1VvZEhKMVpTa2dlMXh1SUNBZ0lDQWdJQ0JwWmloclpYbE1aVzRnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnSUNCaWNtVmhhenRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppaHBJRDA5UFNCdFpGOWlkV1l1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2EyVjVXMnRwS3l0ZElEMGdiV1JmWW5WbVcya3JLMTA3WEc0Z0lDQWdJQ0FnSUd0bGVVeGxiaTB0TzF4dUlDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lDQnBaaWhyWlhsTVpXNGdQVDA5SURBcElIdGNiaUFnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JtYjNJb2FUMHdPMms4YldSZlluVm1MbXhsYm1kMGFEdHBLeXNwSUh0Y2JpQWdJQ0J0WkY5aWRXWmJhVjBnUFNBd08xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCclpYazdYRzU5T3lKZGZRPT0iLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYXNuMS5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9wZW0uanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL3BlbS5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvcmVwb3J0ZXIuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9hcGkuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwibW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9YXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2Flc2lkLmpzb25cIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS5tb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLm1vZChwKTtcbiAgaC5pbXVsKHEpO1xuICBtMi5pYWRkKGgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihtMi5pbXVsKGJsaW5kcy51bmJsaW5kZXIpLm1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoKSk7XG4gIGlmIChvdXQubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHByZWZpeCA9IG5ldyBCdWZmZXIobGVuIC0gb3V0Lmxlbmd0aCk7XG4gICAgcHJlZml4LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbcHJlZml4LCBvdXRdLCBsZW4pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci5tb2QocHJpdi5wcmltZTEpIHx8ICFyLm1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZjSFZpYkdsakxXVnVZM0o1Y0hRdmJtOWtaVjl0YjJSMWJHVnpMMkp5YjNkelpYSnBabmt0Y25OaEwybHVaR1Y0TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR0p1SUQwZ2NtVnhkV2x5WlNnblltNHVhbk1uS1R0Y2JuWmhjaUJ5WVc1a2IyMUNlWFJsY3lBOUlISmxjWFZwY21Vb0ozSmhibVJ2YldKNWRHVnpKeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdOeWREdGNibVoxYm1OMGFXOXVJR0pzYVc1a0tIQnlhWFlwSUh0Y2JpQWdkbUZ5SUhJZ1BTQm5aWFJ5S0hCeWFYWXBPMXh1SUNCMllYSWdZbXhwYm1SbGNpQTlJSEl1ZEc5U1pXUW9ZbTR1Ylc5dWRDaHdjbWwyTG0xdlpIVnNkWE1wS1Z4dUlDQXVjbVZrVUc5M0tHNWxkeUJpYmlod2NtbDJMbkIxWW14cFkwVjRjRzl1Wlc1MEtTa3Vabkp2YlZKbFpDZ3BPMXh1SUNCeVpYUjFjbTRnZTF4dUlDQWdJR0pzYVc1a1pYSTZJR0pzYVc1a1pYSXNYRzRnSUNBZ2RXNWliR2x1WkdWeU9uSXVhVzUyYlNod2NtbDJMbTF2WkhWc2RYTXBYRzRnSUgwN1hHNTlYRzVtZFc1amRHbHZiaUJqY25Rb2JYTm5MQ0J3Y21sMktTQjdYRzRnSUhaaGNpQmliR2x1WkhNZ1BTQmliR2x1WkNod2NtbDJLVHRjYmlBZ2RtRnlJR3hsYmlBOUlIQnlhWFl1Ylc5a2RXeDFjeTVpZVhSbFRHVnVaM1JvS0NrN1hHNGdJSFpoY2lCdGIyUWdQU0JpYmk1dGIyNTBLSEJ5YVhZdWJXOWtkV3gxY3lrN1hHNGdJSFpoY2lCaWJHbHVaR1ZrSUQwZ2JtVjNJR0p1S0cxelp5a3ViWFZzS0dKc2FXNWtjeTVpYkdsdVpHVnlLUzV0YjJRb2NISnBkaTV0YjJSMWJIVnpLVHRjYmlBZ2RtRnlJR014SUQwZ1lteHBibVJsWkM1MGIxSmxaQ2hpYmk1dGIyNTBLSEJ5YVhZdWNISnBiV1V4S1NrN1hHNGdJSFpoY2lCak1pQTlJR0pzYVc1a1pXUXVkRzlTWldRb1ltNHViVzl1ZENod2NtbDJMbkJ5YVcxbE1pa3BPMXh1SUNCMllYSWdjV2x1ZGlBOUlIQnlhWFl1WTI5bFptWnBZMmxsYm5RN1hHNGdJSFpoY2lCd0lEMGdjSEpwZGk1d2NtbHRaVEU3WEc0Z0lIWmhjaUJ4SUQwZ2NISnBkaTV3Y21sdFpUSTdYRzRnSUhaaGNpQnRNU0E5SUdNeExuSmxaRkJ2ZHlod2NtbDJMbVY0Y0c5dVpXNTBNU2s3WEc0Z0lIWmhjaUJ0TWlBOUlHTXlMbkpsWkZCdmR5aHdjbWwyTG1WNGNHOXVaVzUwTWlrN1hHNGdJRzB4SUQwZ2JURXVabkp2YlZKbFpDZ3BPMXh1SUNCdE1pQTlJRzB5TG1aeWIyMVNaV1FvS1R0Y2JpQWdkbUZ5SUdnZ1BTQnRNUzVwYzNWaUtHMHlLUzVwYlhWc0tIRnBibllwTG0xdlpDaHdLVHRjYmlBZ2FDNXBiWFZzS0hFcE8xeHVJQ0J0TWk1cFlXUmtLR2dwTzF4dUlDQjJZWElnYjNWMElEMGdibVYzSUVKMVptWmxjaWh0TWk1cGJYVnNLR0pzYVc1a2N5NTFibUpzYVc1a1pYSXBMbTF2WkNod2NtbDJMbTF2WkhWc2RYTXBMblJ2UVhKeVlYa29LU2s3WEc0Z0lHbG1JQ2h2ZFhRdWJHVnVaM1JvSUR3Z2JHVnVLU0I3WEc0Z0lDQWdkbUZ5SUhCeVpXWnBlQ0E5SUc1bGR5QkNkV1ptWlhJb2JHVnVJQzBnYjNWMExteGxibWQwYUNrN1hHNGdJQ0FnY0hKbFptbDRMbVpwYkd3b01DazdYRzRnSUNBZ2IzVjBJRDBnUW5WbVptVnlMbU52Ym1OaGRDaGJjSEpsWm1sNExDQnZkWFJkTENCc1pXNHBPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnZkWFE3WEc1OVhHNWpjblF1WjJWMGNpQTlJR2RsZEhJN1hHNW1kVzVqZEdsdmJpQm5aWFJ5S0hCeWFYWXBJSHRjYmlBZ2RtRnlJR3hsYmlBOUlIQnlhWFl1Ylc5a2RXeDFjeTVpZVhSbFRHVnVaM1JvS0NrN1hHNGdJSFpoY2lCeUlEMGdibVYzSUdKdUtISmhibVJ2YlVKNWRHVnpLR3hsYmlrcE8xeHVJQ0IzYUdsc1pTQW9jaTVqYlhBb2NISnBkaTV0YjJSMWJIVnpLU0ErUFNBZ01DQjhmQ0FoY2k1dGIyUW9jSEpwZGk1d2NtbHRaVEVwSUh4OElDRnlMbTF2WkNod2NtbDJMbkJ5YVcxbE1pa3BJSHRjYmlBZ0lDQnlJRDBnYm1WM0lHSnVLSEpoYm1SdmJVSjVkR1Z6S0d4bGJpa3BPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnlPMXh1ZlNKZGZRPT0iLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IG5ldyBCdWZmZXIoJycpO1xuICB2YXIgIGkgPSAwLCBjO1xuICB3aGlsZSAodC5sZW5ndGggPCBsZW4pIHtcbiAgICBjID0gaTJvcHMoaSsrKTtcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKTtcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pO1xufTtcblxuZnVuY3Rpb24gaTJvcHMoYykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcig0KTtcbiAgb3V0LndyaXRlVUludDMyQkUoYywwKTtcbiAgcmV0dXJuIG91dDtcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12Y0hWaWJHbGpMV1Z1WTNKNWNIUXZiV2RtTG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lkbUZ5SUdOeVpXRjBaVWhoYzJnZ1BTQnlaWEYxYVhKbEtDZGpjbVZoZEdVdGFHRnphQ2NwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlBb2MyVmxaQ3dnYkdWdUtTQjdYRzRnSUhaaGNpQjBJRDBnYm1WM0lFSjFabVpsY2lnbkp5azdYRzRnSUhaaGNpQWdhU0E5SURBc0lHTTdYRzRnSUhkb2FXeGxJQ2gwTG14bGJtZDBhQ0E4SUd4bGJpa2dlMXh1SUNBZ0lHTWdQU0JwTW05d2N5aHBLeXNwTzF4dUlDQWdJSFFnUFNCQ2RXWm1aWEl1WTI5dVkyRjBLRnQwTENCamNtVmhkR1ZJWVhOb0tDZHphR0V4SnlrdWRYQmtZWFJsS0hObFpXUXBMblZ3WkdGMFpTaGpLUzVrYVdkbGMzUW9LVjBwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUIwTG5Oc2FXTmxLREFzSUd4bGJpazdYRzU5TzF4dVhHNW1kVzVqZEdsdmJpQnBNbTl3Y3loaktTQjdYRzRnSUhaaGNpQnZkWFFnUFNCdVpYY2dRblZtWm1WeUtEUXBPMXh1SUNCdmRYUXVkM0pwZEdWVlNXNTBNekpDUlNoakxEQXBPMXh1SUNCeVpYUjFjbTRnYjNWME8xeHVmU0pkZlE9PSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBnZW5lcmF0ZVByaW1lID0gcmVxdWlyZSgnLi9saWIvZ2VuZXJhdGVQcmltZScpO1xudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vbGliL3ByaW1lcycpO1xuXG52YXIgREggPSByZXF1aXJlKCcuL2xpYi9kaCcpO1xuXG5mdW5jdGlvbiBnZXREaWZmaWVIZWxsbWFuKG1vZCkge1xuICB2YXIgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLnByaW1lLCAnaGV4Jyk7XG4gIHZhciBnZW4gPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLmdlbiwgJ2hleCcpO1xuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZpZUhlbGxtYW4ocHJpbWUsIGVuYywgZ2VuZXJhdG9yLCBnZW5jKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZW5jKSB8fCAodHlwZW9mIGVuYyA9PT0gJ3N0cmluZycgJiYgWydoZXgnLCAnYmluYXJ5JywgJ2Jhc2U2NCddLmluZGV4T2YoZW5jKSA9PT0gLTEpKSB7XG4gICAgZ2VuYyA9IGdlbmVyYXRvcjtcbiAgICBnZW5lcmF0b3IgPSBlbmM7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZW5jID0gZW5jIHx8ICdiaW5hcnknO1xuICBnZW5jID0gZ2VuYyB8fCAnYmluYXJ5JztcbiAgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yIHx8IG5ldyBCdWZmZXIoWzJdKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW5lcmF0b3IpKSB7XG4gICAgZ2VuZXJhdG9yID0gbmV3IEJ1ZmZlcihnZW5lcmF0b3IsIGdlbmMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IERIKGdlbmVyYXRlUHJpbWUocHJpbWUsIGdlbmVyYXRvciksIGdlbmVyYXRvciwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpIHtcbiAgICBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWUsIGVuYyk7XG4gIH1cblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW5lcmF0b3IsIHRydWUpO1xufVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZ2V0RGlmZmllSGVsbG1hbjtcbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGNyZWF0ZURpZmZpZUhlbGxtYW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WkdsbVptbGxMV2hsYkd4dFlXNHZZbkp2ZDNObGNpNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlHZGxibVZ5WVhSbFVISnBiV1VnUFNCeVpYRjFhWEpsS0NjdUwyeHBZaTluWlc1bGNtRjBaVkJ5YVcxbEp5azdYRzUyWVhJZ2NISnBiV1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOXNhV0l2Y0hKcGJXVnpKeWs3WEc1Y2JuWmhjaUJFU0NBOUlISmxjWFZwY21Vb0p5NHZiR2xpTDJSb0p5azdYRzVjYm1aMWJtTjBhVzl1SUdkbGRFUnBabVpwWlVobGJHeHRZVzRvYlc5a0tTQjdYRzRnSUhaaGNpQndjbWx0WlNBOUlHNWxkeUJDZFdabVpYSW9jSEpwYldWelcyMXZaRjB1Y0hKcGJXVXNJQ2RvWlhnbktUdGNiaUFnZG1GeUlHZGxiaUE5SUc1bGR5QkNkV1ptWlhJb2NISnBiV1Z6VzIxdlpGMHVaMlZ1TENBbmFHVjRKeWs3WEc1Y2JpQWdjbVYwZFhKdUlHNWxkeUJFU0Nod2NtbHRaU3dnWjJWdUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1kzSmxZWFJsUkdsbVptbGxTR1ZzYkcxaGJpaHdjbWx0WlN3Z1pXNWpMQ0JuWlc1bGNtRjBiM0lzSUdkbGJtTXBJSHRjYmlBZ2FXWWdLRUoxWm1abGNpNXBjMEoxWm1abGNpaGxibU1wSUh4OElDaDBlWEJsYjJZZ1pXNWpJRDA5UFNBbmMzUnlhVzVuSnlBbUppQmJKMmhsZUNjc0lDZGlhVzVoY25rbkxDQW5ZbUZ6WlRZMEoxMHVhVzVrWlhoUFppaGxibU1wSUQwOVBTQXRNU2twSUh0Y2JpQWdJQ0JuWlc1aklEMGdaMlZ1WlhKaGRHOXlPMXh1SUNBZ0lHZGxibVZ5WVhSdmNpQTlJR1Z1WXp0Y2JpQWdJQ0JsYm1NZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUgxY2JseHVJQ0JsYm1NZ1BTQmxibU1nZkh3Z0oySnBibUZ5ZVNjN1hHNGdJR2RsYm1NZ1BTQm5aVzVqSUh4OElDZGlhVzVoY25rbk8xeHVJQ0JuWlc1bGNtRjBiM0lnUFNCblpXNWxjbUYwYjNJZ2ZId2dibVYzSUVKMVptWmxjaWhiTWwwcE8xeHVYRzRnSUdsbUlDZ2hRblZtWm1WeUxtbHpRblZtWm1WeUtHZGxibVZ5WVhSdmNpa3BJSHRjYmlBZ0lDQm5aVzVsY21GMGIzSWdQU0J1WlhjZ1FuVm1abVZ5S0dkbGJtVnlZWFJ2Y2l3Z1oyVnVZeWs3WEc0Z0lIMWNibHh1SUNCcFppQW9kSGx3Wlc5bUlIQnlhVzFsSUQwOVBTQW5iblZ0WW1WeUp5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCdVpYY2dSRWdvWjJWdVpYSmhkR1ZRY21sdFpTaHdjbWx0WlN3Z1oyVnVaWEpoZEc5eUtTd2daMlZ1WlhKaGRHOXlMQ0IwY25WbEtUdGNiaUFnZlZ4dVhHNGdJR2xtSUNnaFFuVm1abVZ5TG1selFuVm1abVZ5S0hCeWFXMWxLU2tnZTF4dUlDQWdJSEJ5YVcxbElEMGdibVYzSUVKMVptWmxjaWh3Y21sdFpTd2daVzVqS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdVpYY2dSRWdvY0hKcGJXVXNJR2RsYm1WeVlYUnZjaXdnZEhKMVpTazdYRzU5WEc1Y2JtVjRjRzl5ZEhNdVJHbG1abWxsU0dWc2JHMWhia2R5YjNWd0lEMGdaWGh3YjNKMGN5NWpjbVZoZEdWRWFXWm1hV1ZJWld4c2JXRnVSM0p2ZFhBZ1BTQmxlSEJ2Y25SekxtZGxkRVJwWm1acFpVaGxiR3h0WVc0Z1BTQm5aWFJFYVdabWFXVklaV3hzYldGdU8xeHVaWGh3YjNKMGN5NWpjbVZoZEdWRWFXWm1hV1ZJWld4c2JXRnVJRDBnWlhod2IzSjBjeTVFYVdabWFXVklaV3hzYldGdUlEMGdZM0psWVhSbFJHbG1abWxsU0dWc2JHMWhianRjYmlKZGZRPT0iLCJtb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz17XG4gICAgXCJtb2RwMVwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2M2EzNjIwZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAyXCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTY1MzgxZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHA1XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2EyMzczMjdmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE0XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFjYWE2OGZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMTVcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTNhZDJjYWZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMTZcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTIxMDgwMTFhNzIzYzEyYTc4N2U2ZDc4ODcxOWExMGJkYmE1YjI2OTljMzI3MTg2YWY0ZTIzYzFhOTQ2ODM0YjYxNTBiZGEyNTgzZTljYTJhZDQ0Y2U4ZGJiYmMyZGIwNGRlOGVmOTJlOGVmYzE0MWZiZWNhYTYyODdjNTk0NzRlNmJjMDVkOTliMjk2NGZhMDkwYzNhMjIzM2JhMTg2NTE1YmU3ZWQxZjYxMjk3MGNlZTJkN2FmYjgxYmRkNzYyMTcwNDgxY2QwMDY5MTI3ZDViMDVhYTk5M2I0ZWE5ODhkOGZkZGMxODZmZmI3ZGM5MGE2YzA4ZjRkZjQzNWM5MzQwNjMxOTlmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE3XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkyMTA4MDExYTcyM2MxMmE3ODdlNmQ3ODg3MTlhMTBiZGJhNWIyNjk5YzMyNzE4NmFmNGUyM2MxYTk0NjgzNGI2MTUwYmRhMjU4M2U5Y2EyYWQ0NGNlOGRiYmJjMmRiMDRkZThlZjkyZThlZmMxNDFmYmVjYWE2Mjg3YzU5NDc0ZTZiYzA1ZDk5YjI5NjRmYTA5MGMzYTIyMzNiYTE4NjUxNWJlN2VkMWY2MTI5NzBjZWUyZDdhZmI4MWJkZDc2MjE3MDQ4MWNkMDA2OTEyN2Q1YjA1YWE5OTNiNGVhOTg4ZDhmZGRjMTg2ZmZiN2RjOTBhNmMwOGY0ZGY0MzVjOTM0MDI4NDkyMzZjM2ZhYjRkMjdjNzAyNmMxZDRkY2IyNjAyNjQ2ZGVjOTc1MWU3NjNkYmEzN2JkZjhmZjk0MDZhZDllNTMwZWU1ZGIzODJmNDEzMDAxYWViMDZhNTNlZDkwMjdkODMxMTc5NzI3YjA4NjVhODkxOGRhM2VkYmViY2Y5YjE0ZWQ0NGNlNmNiYWNlZDRiYjFiZGI3ZjE0NDdlNmNjMjU0YjMzMjA1MTUxMmJkN2FmNDI2ZmI4ZjQwMTM3OGNkMmJmNTk4M2NhMDFjNjRiOTJlY2YwMzJlYTE1ZDE3MjFkMDNmNDgyZDdjZTZlNzRmZWY2ZDU1ZTcwMmY0Njk4MGM4MmI1YTg0MDMxOTAwYjFjOWU1OWU3Yzk3ZmJlYzdlOGYzMjNhOTdhN2UzNmNjODhiZTBmMWQ0NWI3ZmY1ODVhYzU0YmQ0MDdiMjJiNDE1NGFhY2M4ZjZkN2ViZjQ4ZTFkODE0Y2M1ZWQyMGY4MDM3ZTBhNzk3MTVlZWYyOWJlMzI4MDZhMWQ1OGJiN2M1ZGE3NmY1NTBhYTNkOGExZmJmZjBlYjE5Y2NiMWEzMTNkNTVjZGE1NmM5ZWMyZWYyOTYzMjM4N2ZlOGQ3NmUzYzA0NjgwNDNlOGY2NjNmNDg2MGVlMTJiZjJkNWIwYjc0NzRkNmU2OTRmOTFlNmRjYzQwMjRmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE4XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkyMTA4MDExYTcyM2MxMmE3ODdlNmQ3ODg3MTlhMTBiZGJhNWIyNjk5YzMyNzE4NmFmNGUyM2MxYTk0NjgzNGI2MTUwYmRhMjU4M2U5Y2EyYWQ0NGNlOGRiYmJjMmRiMDRkZThlZjkyZThlZmMxNDFmYmVjYWE2Mjg3YzU5NDc0ZTZiYzA1ZDk5YjI5NjRmYTA5MGMzYTIyMzNiYTE4NjUxNWJlN2VkMWY2MTI5NzBjZWUyZDdhZmI4MWJkZDc2MjE3MDQ4MWNkMDA2OTEyN2Q1YjA1YWE5OTNiNGVhOTg4ZDhmZGRjMTg2ZmZiN2RjOTBhNmMwOGY0ZGY0MzVjOTM0MDI4NDkyMzZjM2ZhYjRkMjdjNzAyNmMxZDRkY2IyNjAyNjQ2ZGVjOTc1MWU3NjNkYmEzN2JkZjhmZjk0MDZhZDllNTMwZWU1ZGIzODJmNDEzMDAxYWViMDZhNTNlZDkwMjdkODMxMTc5NzI3YjA4NjVhODkxOGRhM2VkYmViY2Y5YjE0ZWQ0NGNlNmNiYWNlZDRiYjFiZGI3ZjE0NDdlNmNjMjU0YjMzMjA1MTUxMmJkN2FmNDI2ZmI4ZjQwMTM3OGNkMmJmNTk4M2NhMDFjNjRiOTJlY2YwMzJlYTE1ZDE3MjFkMDNmNDgyZDdjZTZlNzRmZWY2ZDU1ZTcwMmY0Njk4MGM4MmI1YTg0MDMxOTAwYjFjOWU1OWU3Yzk3ZmJlYzdlOGYzMjNhOTdhN2UzNmNjODhiZTBmMWQ0NWI3ZmY1ODVhYzU0YmQ0MDdiMjJiNDE1NGFhY2M4ZjZkN2ViZjQ4ZTFkODE0Y2M1ZWQyMGY4MDM3ZTBhNzk3MTVlZWYyOWJlMzI4MDZhMWQ1OGJiN2M1ZGE3NmY1NTBhYTNkOGExZmJmZjBlYjE5Y2NiMWEzMTNkNTVjZGE1NmM5ZWMyZWYyOTYzMjM4N2ZlOGQ3NmUzYzA0NjgwNDNlOGY2NjNmNDg2MGVlMTJiZjJkNWIwYjc0NzRkNmU2OTRmOTFlNmRiZTExNTk3NGEzOTI2ZjEyZmVlNWU0Mzg3NzdjYjZhOTMyZGY4Y2Q4YmVjNGQwNzNiOTMxYmEzYmM4MzJiNjhkOWRkMzAwNzQxZmE3YmY4YWZjNDdlZDI1NzZmNjkzNmJhNDI0NjYzYWFiNjM5YzVhZTRmNTY4MzQyM2I0NzQyYmYxYzk3ODIzOGYxNmNiZTM5ZDY1MmRlM2ZkYjhiZWZjODQ4YWQ5MjIyMjJlMDRhNDAzN2MwNzEzZWI1N2E4MWEyM2YwYzczNDczZmM2NDZjZWEzMDZiNGJjYmM4ODYyZjgzODVkZGZhOWQ0YjdmYTJjMDg3ZTg3OTY4MzMwM2VkNWJkZDNhMDYyYjNjZjViM2EyNzhhNjZkMmExM2Y4M2Y0NGY4MmRkZjMxMGVlMDc0YWI2YTM2NDU5N2U4OTlhMDI1NWRjMTY0ZjMxY2M1MDg0Njg1MWRmOWFiNDgxOTVkZWQ3ZWExYjFkNTEwYmQ3ZWU3NGQ3M2ZhZjM2YmMzMWVjZmEyNjgzNTkwNDZmNGViODc5ZjkyNDAwOTQzOGI0ODFjNmNkNzg4OWEwMDJlZDVlZTM4MmJjOTE5MGRhNmZjMDI2ZTQ3OTU1OGU0NDc1Njc3ZTlhYTllMzA1MGUyNzY1Njk0ZGZjODFmNTZlODgwYjk2ZTcxNjBjOTgwZGQ5OGVkZDNkZmZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH1cbn0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG4gIFxuICBpZiAocHJpbWUuaXNFdmVuKCkgfHxcbiAgICAhcHJpbWVzLnNpbXBsZVNpZXZlIHx8XG4gICAgIXByaW1lcy5mZXJtYXRUZXN0KHByaW1lKSB8fFxuICAgICFtaWxsZXJSYWJpbi50ZXN0KHByaW1lKSkge1xuICAgIC8vbm90IGEgcHJpbWUgc28gKzFcbiAgICBlcnJvciArPSAxO1xuICAgIFxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfSBcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IFxuICAgICAgZXJyb3IgKz0gNDtcbiAgfVxuICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVFcnJvciAoc2VsZiwgZXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ3ZlcmlmeUVycm9yJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBlcnJvcixcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZWxmLnZlcmlmeUVycm9yID0gZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIERIKHByaW1lLCBnZW5lcmF0b3IsIG1hbGxlYWJsZSkge1xuICB0aGlzLnNldEdlbmVyYXRvcihnZW5lcmF0b3IpO1xuICB0aGlzLl9fcHJpbWUgPSBuZXcgQk4ocHJpbWUpO1xuICB0aGlzLl9wcmltZSA9IEJOLm1vbnQodGhpcy5fX3ByaW1lKTtcbiAgdGhpcy5fcHJpbWVMZW4gPSBwcmltZS5sZW5ndGg7XG4gIHRoaXMuX3B1YiA9IHZvaWQgMDtcbiAgdGhpcy5fcHJpdiA9IHZvaWQgMDtcbiAgXG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICAgIGRlZmluZUVycm9yKHRoaXMsIGNoZWNrUHJpbWUodGhpcy5fX3ByaW1lLCBnZW5lcmF0b3IpKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVFcnJvcih0aGlzLCA4KTtcbiAgfVxufVxuXG5ESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3ByaXYpIHtcbiAgICB0aGlzLl9wcml2ID0gbmV3IEJOKHJhbmRvbUJ5dGVzKHRoaXMuX3ByaW1lTGVuKSk7XG4gIH1cbiAgdGhpcy5fcHViID0gdGhpcy5fZ2VuLnRvUmVkKHRoaXMuX3ByaW1lKS5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoKTtcbn07XG5cbkRILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIG90aGVyID0gbmV3IEJOKG90aGVyKTtcbiAgb3RoZXIgPSBvdGhlci50b1JlZCh0aGlzLl9wcmltZSk7XG4gIHZhciBzZWNyZXQgPSBvdGhlci5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihzZWNyZXQudG9BcnJheSgpKTtcbiAgdmFyIHByaW1lID0gdGhpcy5nZXRQcmltZSgpO1xuICBpZiAob3V0Lmxlbmd0aCA8IHByaW1lLmxlbmd0aCkge1xuICAgIHZhciBmcm9udCA9IG5ldyBCdWZmZXIocHJpbWUubGVuZ3RoIC0gb3V0Lmxlbmd0aCk7XG4gICAgZnJvbnQuZmlsbCgwKTtcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtmcm9udCwgb3V0XSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wdWIsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIGdldFByaXZhdGVLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wcml2LCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaW1lID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fX3ByaW1lLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX2dlbiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5zZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZ2VuLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuKSkge1xuICAgIGdlbiA9IG5ldyBCdWZmZXIoZ2VuLCBlbmMpO1xuICB9XG4gIHRoaXMuX2dlbiA9IG5ldyBCTihnZW4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4udG9BcnJheSgpKTtcbiAgaWYgKCFlbmMpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcbiAgfVxufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZaR2xtWm1sbExXaGxiR3h0WVc0dmJHbGlMMlJvTG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SjJZWElnUWs0Z1BTQnlaWEYxYVhKbEtDZGliaTVxY3ljcE8xeHVkbUZ5SUUxcGJHeGxjbEpoWW1sdUlEMGdjbVZ4ZFdseVpTZ25iV2xzYkdWeUxYSmhZbWx1SnlrN1hHNTJZWElnYldsc2JHVnlVbUZpYVc0Z1BTQnVaWGNnVFdsc2JHVnlVbUZpYVc0b0tUdGNiblpoY2lCVVYwVk9WRmxHVDFWU0lEMGdibVYzSUVKT0tESTBLVHRjYm5aaGNpQkZURVZXUlU0Z1BTQnVaWGNnUWs0b01URXBPMXh1ZG1GeUlGUkZUaUE5SUc1bGR5QkNUaWd4TUNrN1hHNTJZWElnVkVoU1JVVWdQU0J1WlhjZ1FrNG9NeWs3WEc1MllYSWdVMFZXUlU0Z1BTQnVaWGNnUWs0b055azdYRzUyWVhJZ2NISnBiV1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOW5aVzVsY21GMFpWQnlhVzFsSnlrN1hHNTJZWElnY21GdVpHOXRRbmwwWlhNZ1BTQnlaWEYxYVhKbEtDZHlZVzVrYjIxaWVYUmxjeWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCRVNEdGNibHh1Wm5WdVkzUnBiMjRnYzJWMFVIVmliR2xqUzJWNUtIQjFZaXdnWlc1aktTQjdYRzRnSUdWdVl5QTlJR1Z1WXlCOGZDQW5kWFJtT0NjN1hHNGdJR2xtSUNnaFFuVm1abVZ5TG1selFuVm1abVZ5S0hCMVlpa3BJSHRjYmlBZ0lDQndkV0lnUFNCdVpYY2dRblZtWm1WeUtIQjFZaXdnWlc1aktUdGNiaUFnZlZ4dUlDQjBhR2x6TGw5d2RXSWdQU0J1WlhjZ1FrNG9jSFZpS1R0Y2JpQWdjbVYwZFhKdUlIUm9hWE03WEc1OVhHNWNibVoxYm1OMGFXOXVJSE5sZEZCeWFYWmhkR1ZMWlhrb2NISnBkaXdnWlc1aktTQjdYRzRnSUdWdVl5QTlJR1Z1WXlCOGZDQW5kWFJtT0NjN1hHNGdJR2xtSUNnaFFuVm1abVZ5TG1selFuVm1abVZ5S0hCeWFYWXBLU0I3WEc0Z0lDQWdjSEpwZGlBOUlHNWxkeUJDZFdabVpYSW9jSEpwZGl3Z1pXNWpLVHRjYmlBZ2ZWeHVJQ0IwYUdsekxsOXdjbWwySUQwZ2JtVjNJRUpPS0hCeWFYWXBPMXh1SUNCeVpYUjFjbTRnZEdocGN6dGNibjFjYmx4dWRtRnlJSEJ5YVcxbFEyRmphR1VnUFNCN2ZUdGNibVoxYm1OMGFXOXVJR05vWldOclVISnBiV1VvY0hKcGJXVXNJR2RsYm1WeVlYUnZjaWtnZTF4dUlDQjJZWElnWjJWdUlEMGdaMlZ1WlhKaGRHOXlMblJ2VTNSeWFXNW5LQ2RvWlhnbktUdGNiaUFnZG1GeUlHaGxlQ0E5SUZ0blpXNHNJSEJ5YVcxbExuUnZVM1J5YVc1bktERTJLVjB1YW05cGJpZ25YeWNwTzF4dUlDQnBaaUFvYUdWNElHbHVJSEJ5YVcxbFEyRmphR1VwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdjSEpwYldWRFlXTm9aVnRvWlhoZE8xeHVJQ0I5WEc0Z0lIWmhjaUJsY25KdmNpQTlJREE3WEc0Z0lGeHVJQ0JwWmlBb2NISnBiV1V1YVhORmRtVnVLQ2tnZkh4Y2JpQWdJQ0FoY0hKcGJXVnpMbk5wYlhCc1pWTnBaWFpsSUh4OFhHNGdJQ0FnSVhCeWFXMWxjeTVtWlhKdFlYUlVaWE4wS0hCeWFXMWxLU0I4ZkZ4dUlDQWdJQ0Z0YVd4c1pYSlNZV0pwYmk1MFpYTjBLSEJ5YVcxbEtTa2dlMXh1SUNBZ0lDOHZibTkwSUdFZ2NISnBiV1VnYzI4Z0t6RmNiaUFnSUNCbGNuSnZjaUFyUFNBeE8xeHVJQ0FnSUZ4dUlDQWdJR2xtSUNoblpXNGdQVDA5SUNjd01pY2dmSHdnWjJWdUlEMDlQU0FuTURVbktTQjdYRzRnSUNBZ0lDQXZMeUIzWlNka0lHSmxJR0ZpYkdVZ2RHOGdZMmhsWTJzZ2RHaGxJR2RsYm1WeVlYUnZjbHh1SUNBZ0lDQWdMeThnYVhRZ2QyOTFiR1FnWm1GcGJDQnpieUFyT0Z4dUlDQWdJQ0FnWlhKeWIzSWdLejBnT0R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdMeTkzWlNCM2IzVnNaRzRuZENCaVpTQmhZbXhsSUhSdklIUmxjM1FnZEdobElHZGxibVZ5WVhSdmNseHVJQ0FnSUNBZ0x5OGdjMjhnS3pSY2JpQWdJQ0FnSUdWeWNtOXlJQ3M5SURRN1hHNGdJQ0FnZlZ4dUlDQWdJSEJ5YVcxbFEyRmphR1ZiYUdWNFhTQTlJR1Z5Y205eU8xeHVJQ0FnSUhKbGRIVnliaUJsY25KdmNqdGNiaUFnZlZ4dUlDQnBaaUFvSVcxcGJHeGxjbEpoWW1sdUxuUmxjM1FvY0hKcGJXVXVjMmh5YmlneEtTa3BJSHRjYmlBZ0lDQXZMMjV2ZENCaElITmhabVVnY0hKcGJXVmNiaUFnSUNCbGNuSnZjaUFyUFNBeU8xeHVJQ0I5WEc0Z0lIWmhjaUJ5WlcwN1hHNGdJSE4zYVhSamFDQW9aMlZ1S1NCN1hHNGdJQ0FnWTJGelpTQW5NREluT2x4dUlDQWdJQ0FnYVdZZ0tIQnlhVzFsTG0xdlpDaFVWMFZPVkZsR1QxVlNLUzVqYlhBb1JVeEZWa1ZPS1NrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUIxYm5OMWFXUmhZbXhsSUdkbGJtVnlZWFJ2Y2x4dUlDQWdJQ0FnSUNCbGNuSnZjaUFyUFNBNE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdZMkZ6WlNBbk1EVW5PbHh1SUNBZ0lDQWdjbVZ0SUQwZ2NISnBiV1V1Ylc5a0tGUkZUaWs3WEc0Z0lDQWdJQ0JwWmlBb2NtVnRMbU50Y0NoVVNGSkZSU2tnSmlZZ2NtVnRMbU50Y0NoVFJWWkZUaWtwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdjSEpwYldVZ2JXOWtJREV3SUc1bFpXUnpJSFJ2SUdWeGRXRnNJRE1nYjNJZ04xeHVJQ0FnSUNBZ0lDQmxjbkp2Y2lBclBTQTRPMXh1SUNBZ0lDQWdmU0JjYmlBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUdSbFptRjFiSFE2SUZ4dUlDQWdJQ0FnWlhKeWIzSWdLejBnTkR0Y2JpQWdmVnh1SUNCd2NtbHRaVU5oWTJobFcyaGxlRjBnUFNCbGNuSnZjanRjYmlBZ2NtVjBkWEp1SUdWeWNtOXlPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmtaV1pwYm1WRmNuSnZjaUFvYzJWc1ppd2daWEp5YjNJcElIdGNiaUFnZEhKNUlIdGNiaUFnSUNCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa29jMlZzWml3Z0ozWmxjbWxtZVVWeWNtOXlKeXdnZTF4dUlDQWdJQ0FnWlc1MWJXVnlZV0pzWlRvZ2RISjFaU3hjYmlBZ0lDQWdJSFpoYkhWbE9pQmxjbkp2Y2l4Y2JpQWdJQ0FnSUhkeWFYUmhZbXhsT2lCbVlXeHpaVnh1SUNBZ0lIMHBPMXh1SUNCOUlHTmhkR05vS0dVcElIdGNiaUFnSUNCelpXeG1MblpsY21sbWVVVnljbTl5SUQwZ1pYSnliM0k3WEc0Z0lIMWNibjFjYm1aMWJtTjBhVzl1SUVSSUtIQnlhVzFsTENCblpXNWxjbUYwYjNJc0lHMWhiR3hsWVdKc1pTa2dlMXh1SUNCMGFHbHpMbk5sZEVkbGJtVnlZWFJ2Y2loblpXNWxjbUYwYjNJcE8xeHVJQ0IwYUdsekxsOWZjSEpwYldVZ1BTQnVaWGNnUWs0b2NISnBiV1VwTzF4dUlDQjBhR2x6TGw5d2NtbHRaU0E5SUVKT0xtMXZiblFvZEdocGN5NWZYM0J5YVcxbEtUdGNiaUFnZEdocGN5NWZjSEpwYldWTVpXNGdQU0J3Y21sdFpTNXNaVzVuZEdnN1hHNGdJSFJvYVhNdVgzQjFZaUE5SUhadmFXUWdNRHRjYmlBZ2RHaHBjeTVmY0hKcGRpQTlJSFp2YVdRZ01EdGNiaUFnWEc0Z0lHbG1JQ2h0WVd4c1pXRmliR1VwSUh0Y2JpQWdJQ0IwYUdsekxuTmxkRkIxWW14cFkwdGxlU0E5SUhObGRGQjFZbXhwWTB0bGVUdGNiaUFnSUNCMGFHbHpMbk5sZEZCeWFYWmhkR1ZMWlhrZ1BTQnpaWFJRY21sMllYUmxTMlY1TzF4dUlDQWdJR1JsWm1sdVpVVnljbTl5S0hSb2FYTXNJR05vWldOclVISnBiV1VvZEdocGN5NWZYM0J5YVcxbExDQm5aVzVsY21GMGIzSXBLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0JrWldacGJtVkZjbkp2Y2loMGFHbHpMQ0E0S1R0Y2JpQWdmVnh1ZlZ4dVhHNUVTQzV3Y205MGIzUjVjR1V1WjJWdVpYSmhkR1ZMWlhseklEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQnBaaUFvSVhSb2FYTXVYM0J5YVhZcElIdGNiaUFnSUNCMGFHbHpMbDl3Y21sMklEMGdibVYzSUVKT0tISmhibVJ2YlVKNWRHVnpLSFJvYVhNdVgzQnlhVzFsVEdWdUtTazdYRzRnSUgxY2JpQWdkR2hwY3k1ZmNIVmlJRDBnZEdocGN5NWZaMlZ1TG5SdlVtVmtLSFJvYVhNdVgzQnlhVzFsS1M1eVpXUlFiM2NvZEdocGN5NWZjSEpwZGlrdVpuSnZiVkpsWkNncE8xeHVJQ0J5WlhSMWNtNGdkR2hwY3k1blpYUlFkV0pzYVdOTFpYa29LVHRjYm4wN1hHNWNia1JJTG5CeWIzUnZkSGx3WlM1amIyMXdkWFJsVTJWamNtVjBJRDBnWm5WdVkzUnBiMjRnS0c5MGFHVnlLU0I3WEc0Z0lHOTBhR1Z5SUQwZ2JtVjNJRUpPS0c5MGFHVnlLVHRjYmlBZ2IzUm9aWElnUFNCdmRHaGxjaTUwYjFKbFpDaDBhR2x6TGw5d2NtbHRaU2s3WEc0Z0lIWmhjaUJ6WldOeVpYUWdQU0J2ZEdobGNpNXlaV1JRYjNjb2RHaHBjeTVmY0hKcGRpa3Vabkp2YlZKbFpDZ3BPMXh1SUNCMllYSWdiM1YwSUQwZ2JtVjNJRUoxWm1abGNpaHpaV055WlhRdWRHOUJjbkpoZVNncEtUdGNiaUFnZG1GeUlIQnlhVzFsSUQwZ2RHaHBjeTVuWlhSUWNtbHRaU2dwTzF4dUlDQnBaaUFvYjNWMExteGxibWQwYUNBOElIQnlhVzFsTG14bGJtZDBhQ2tnZTF4dUlDQWdJSFpoY2lCbWNtOXVkQ0E5SUc1bGR5QkNkV1ptWlhJb2NISnBiV1V1YkdWdVozUm9JQzBnYjNWMExteGxibWQwYUNrN1hHNGdJQ0FnWm5KdmJuUXVabWxzYkNnd0tUdGNiaUFnSUNCdmRYUWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdG1jbTl1ZEN3Z2IzVjBYU2s3WEc0Z0lIMWNiaUFnY21WMGRYSnVJRzkxZER0Y2JuMDdYRzVjYmtSSUxuQnliM1J2ZEhsd1pTNW5aWFJRZFdKc2FXTkxaWGtnUFNCbWRXNWpkR2x2YmlCblpYUlFkV0pzYVdOTFpYa29aVzVqS1NCN1hHNGdJSEpsZEhWeWJpQm1iM0p0WVhSU1pYUjFjbTVXWVd4MVpTaDBhR2x6TGw5d2RXSXNJR1Z1WXlrN1hHNTlPMXh1WEc1RVNDNXdjbTkwYjNSNWNHVXVaMlYwVUhKcGRtRjBaVXRsZVNBOUlHWjFibU4wYVc5dUlHZGxkRkJ5YVhaaGRHVkxaWGtvWlc1aktTQjdYRzRnSUhKbGRIVnliaUJtYjNKdFlYUlNaWFIxY201V1lXeDFaU2gwYUdsekxsOXdjbWwyTENCbGJtTXBPMXh1ZlR0Y2JseHVSRWd1Y0hKdmRHOTBlWEJsTG1kbGRGQnlhVzFsSUQwZ1puVnVZM1JwYjI0Z0tHVnVZeWtnZTF4dUlDQnlaWFIxY200Z1ptOXliV0YwVW1WMGRYSnVWbUZzZFdVb2RHaHBjeTVmWDNCeWFXMWxMQ0JsYm1NcE8xeHVmVHRjYmx4dVJFZ3VjSEp2ZEc5MGVYQmxMbWRsZEVkbGJtVnlZWFJ2Y2lBOUlHWjFibU4wYVc5dUlDaGxibU1wSUh0Y2JpQWdjbVYwZFhKdUlHWnZjbTFoZEZKbGRIVnlibFpoYkhWbEtIUm9hWE11WDJkbGJpd2daVzVqS1R0Y2JuMDdYRzVjYmtSSUxuQnliM1J2ZEhsd1pTNXpaWFJIWlc1bGNtRjBiM0lnUFNCbWRXNWpkR2x2YmlBb1oyVnVMQ0JsYm1NcElIdGNiaUFnWlc1aklEMGdaVzVqSUh4OElDZDFkR1k0Snp0Y2JpQWdhV1lnS0NGQ2RXWm1aWEl1YVhOQ2RXWm1aWElvWjJWdUtTa2dlMXh1SUNBZ0lHZGxiaUE5SUc1bGR5QkNkV1ptWlhJb1oyVnVMQ0JsYm1NcE8xeHVJQ0I5WEc0Z0lIUm9hWE11WDJkbGJpQTlJRzVsZHlCQ1RpaG5aVzRwTzF4dUlDQnlaWFIxY200Z2RHaHBjenRjYm4wN1hHNWNibVoxYm1OMGFXOXVJR1p2Y20xaGRGSmxkSFZ5YmxaaGJIVmxLR0p1TENCbGJtTXBJSHRjYmlBZ2RtRnlJR0oxWmlBOUlHNWxkeUJDZFdabVpYSW9ZbTR1ZEc5QmNuSmhlU2dwS1R0Y2JpQWdhV1lnS0NGbGJtTXBJSHRjYmlBZ0lDQnlaWFIxY200Z1luVm1PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQmlkV1l1ZEc5VGRISnBibWNvWlc1aktUdGNiaUFnZlZ4dWZTSmRmUT09IiwidmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZmluZFByaW1lO1xuZmluZFByaW1lLnNpbXBsZVNpZXZlID0gc2ltcGxlU2lldmU7XG5maW5kUHJpbWUuZmVybWF0VGVzdCA9IGZlcm1hdFRlc3Q7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBPTkUgPSBuZXcgQk4oMSk7XG52YXIgVFdPID0gbmV3IEJOKDIpO1xudmFyIEZJVkUgPSBuZXcgQk4oNSk7XG52YXIgU0lYVEVFTiA9IG5ldyBCTigxNik7XG52YXIgRUlHSFQgPSBuZXcgQk4oOCk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIEZPVVIgPSBuZXcgQk4oNCk7XG52YXIgVFdFTFZFID0gbmV3IEJOKDEyKTtcbnZhciBwcmltZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBfZ2V0UHJpbWVzKCkge1xuICBpZiAocHJpbWVzICE9PSBudWxsKVxuICAgIHJldHVybiBwcmltZXM7XG5cbiAgdmFyIGxpbWl0ID0gMHgxMDAwMDA7XG4gIHZhciByZXMgPSBbXTtcbiAgcmVzWzBdID0gMjtcbiAgZm9yICh2YXIgaSA9IDEsIGsgPSAzOyBrIDwgbGltaXQ7IGsgKz0gMikge1xuICAgIHZhciBzcXJ0ID0gTWF0aC5jZWlsKE1hdGguc3FydChrKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICYmIHJlc1tqXSA8PSBzcXJ0OyBqKyspXG4gICAgICBpZiAoayAlIHJlc1tqXSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG5cbiAgICBpZiAoaSAhPT0gaiAmJiByZXNbal0gPD0gc3FydClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcmVzW2krK10gPSBrO1xuICB9XG4gIHByaW1lcyA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2lldmUocCkge1xuICB2YXIgcHJpbWVzID0gX2dldFByaW1lcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWVzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChwLm1vZG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgaWYgKHAuY21wbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmVybWF0VGVzdChwKSB7XG4gIHZhciByZWQgPSBCTi5tb250KHApO1xuICByZXR1cm4gVFdPLnRvUmVkKHJlZCkucmVkUG93KHAuc3VibigxKSkuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmltZShiaXRzLCBnZW4pIHtcbiAgaWYgKGJpdHMgPCAxNikge1xuICAgIC8vIHRoaXMgaXMgd2hhdCBvcGVuc3NsIGRvZXNcbiAgICBpZiAoZ2VuID09PSAyIHx8IGdlbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHg3Yl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDI3XSk7XG4gICAgfVxuICB9XG4gIGdlbiA9IG5ldyBCTihnZW4pO1xuICB2YXIgcnVucywgY29tcDtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb20oYml0cykge1xuICAgIHJ1bnMgPSAtMTtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKHJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpKTtcbiAgICB3aGlsZSAob3V0LmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgb3V0LmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAob3V0LmlzRXZlbigpKSB7XG4gICAgICBvdXQuaWFkZChPTkUpO1xuICAgIH1cbiAgICBpZiAoIW91dC50ZXN0bigxKSkge1xuICAgICAgb3V0LmlhZGQoVFdPKTtcbiAgICB9XG4gICAgaWYgKCFnZW4uY21wKFRXTykpIHtcbiAgICAgIHdoaWxlIChvdXQubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIG91dC5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgICAgY29tcCA9IHtcbiAgICAgICAgbWFqb3I6IFtUV0VOVFlGT1VSXSxcbiAgICAgICAgbWlub3I6IFtUV0VMVkVdXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWdlbi5jbXAoRklWRSkpIHtcbiAgICAgIHJlbSA9IG91dC5tb2QoVEVOKTtcbiAgICAgIHdoaWxlIChyZW0uY21wKFRIUkVFKSkge1xuICAgICAgICBvdXQuaWFkZChGT1VSKTtcbiAgICAgICAgcmVtID0gb3V0Lm1vZChURU4pO1xuICAgICAgfVxuICAgICAgY29tcCA9IHtcbiAgICAgICAgbWFqb3I6IFtGT1VSLCBTSVhURUVOXSxcbiAgICAgICAgbWlub3I6IFtUV08sIEVJR0hUXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcCA9IHtcbiAgICAgICAgbWFqb3I6IFtGT1VSXSxcbiAgICAgICAgbWlub3I6IFtUV09dXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzKTtcblxuICB2YXIgbjIgPSBudW0uc2hybigxKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHdoaWxlIChudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzKTtcbiAgICAgIG4yID0gbnVtLnNocm4oMSk7XG4gICAgfVxuICAgIHJ1bnMrKztcbiAgICBpZiAoc2ltcGxlU2lldmUobjIpICYmICBzaW1wbGVTaWV2ZShudW0pICYmXG4gICAgICBmZXJtYXRUZXN0KG4yKSAmJiAgZmVybWF0VGVzdChudW0pICYmXG4gICAgICBtaWxsZXJSYWJpbi50ZXN0KG4yKSAmJiBtaWxsZXJSYWJpbi50ZXN0KG51bSkpIHtcbiAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIG51bS5pYWRkKGNvbXAubWFqb3JbcnVucyVjb21wLm1ham9yLmxlbmd0aF0pO1xuICAgIG4yLmlhZGQoY29tcC5taW5vcltydW5zJWNvbXAubWlub3IubGVuZ3RoXSk7XG4gIH1cblxufSIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgYnJvcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcblxuZnVuY3Rpb24gTWlsbGVyUmFiaW4ocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kIHx8IG5ldyBicm9yYW5kLlJhbmQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTWlsbGVyUmFiaW47XG5cbk1pbGxlclJhYmluLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShyYW5kKSB7XG4gIHJldHVybiBuZXcgTWlsbGVyUmFiaW4ocmFuZCk7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgYnVmID0gdGhpcy5yYW5kLmdlbmVyYXRlKE1hdGguY2VpbChsZW4gLyA4KSk7XG5cbiAgLy8gU2V0IGxvdyBiaXRzXG4gIGJ1ZlswXSB8PSAzO1xuXG4gIC8vIE1hc2sgaGlnaCBiaXRzXG4gIHZhciBtYXNrID0gbGVuICYgMHg3O1xuICBpZiAobWFzayAhPT0gMClcbiAgICBidWZbYnVmLmxlbmd0aCAtIDFdID4+PSA3IC0gbWFzaztcblxuICByZXR1cm4gbmV3IGJuKGJ1Zik7XG59XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChuLCBrLCBjYikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgdmFyIG4yID0gbjEuc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICB2YXIgcHJpbWUgPSB0cnVlO1xuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZChuMik7XG4gICAgaWYgKGNiKVxuICAgICAgY2IoYSk7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcHJpbWU7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuZ2V0RGl2aXNvciA9IGZ1bmN0aW9uIGdldERpdmlzb3Iobiwgaykge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgdmFyIG4yID0gbjEuc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZChuMik7XG5cbiAgICB2YXIgZyA9IG4uZ2NkKGEpO1xuICAgIGlmIChnLmNtcG4oMSkgIT09IDApXG4gICAgICByZXR1cm4gZztcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG4gICAgICByZXR1cm4geC5mcm9tUmVkKCkuc3VibigxKS5nY2Qobik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvYnJvcmFuZC9pbmRleC5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsInZhciBjcmVhdGVFQ0RIID0gcmVxdWlyZSgnY3J5cHRvJykuY3JlYXRlRUNESDtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFQ0RIIHx8IHJlcXVpcmUoJy4vYnJvd3NlcicpOyIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVDREgoY3VydmUpIHtcblx0cmV0dXJuIG5ldyBFQ0RIKGN1cnZlKTtcbn07XG5cbnZhciBhbGlhc2VzID0ge1xuXHRzZWNwMjU2azE6IHtcblx0XHRuYW1lOiAnc2VjcDI1NmsxJyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRzZWNwMjI0cjE6IHtcblx0XHRuYW1lOiAncDIyNCcsXG5cdFx0Ynl0ZUxlbmd0aDogMjhcblx0fSxcblx0cHJpbWUyNTZ2MToge1xuXHRcdG5hbWU6ICdwMjU2Jyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRwcmltZTE5MnYxOiB7XG5cdFx0bmFtZTogJ3AxOTInLFxuXHRcdGJ5dGVMZW5ndGg6IDI0XG5cdH0sXG5cdGVkMjU1MTk6IHtcblx0XHRuYW1lOiAnZWQyNTUxOScsXG5cdFx0Ynl0ZUxlbmd0aDogMzJcblx0fVxufTtcblxuYWxpYXNlcy5wMjI0ID0gYWxpYXNlcy5zZWNwMjI0cjE7XG5hbGlhc2VzLnAyNTYgPSBhbGlhc2VzLnNlY3AyNTZyMSA9IGFsaWFzZXMucHJpbWUyNTZ2MTtcbmFsaWFzZXMucDE5MiA9IGFsaWFzZXMuc2VjcDE5MnIxID0gYWxpYXNlcy5wcmltZTE5MnYxO1xuXG5mdW5jdGlvbiBFQ0RIKGN1cnZlKSB7XG5cdHRoaXMuY3VydmVUeXBlID0gYWxpYXNlc1tjdXJ2ZV07XG5cdGlmICghdGhpcy5jdXJ2ZVR5cGUgKSB7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSB7XG5cdFx0XHRuYW1lOiBjdXJ2ZVxuXHRcdH07XG5cdH1cblx0dGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5lYyh0aGlzLmN1cnZlVHlwZS5uYW1lKTtcblx0dGhpcy5rZXlzID0gdm9pZCAwO1xufVxuXG5FQ0RILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcblx0dGhpcy5rZXlzID0gdGhpcy5jdXJ2ZS5nZW5LZXlQYWlyKCk7XG5cdHJldHVybiB0aGlzLmdldFB1YmxpY0tleShlbmMsIGZvcm1hdCk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyLCBpbmVuYywgZW5jKSB7XG5cdGluZW5jID0gaW5lbmMgfHwgJ3V0ZjgnO1xuXHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcblx0XHRvdGhlciA9IG5ldyBCdWZmZXIob3RoZXIsIGluZW5jKTtcblx0fVxuXHR2YXIgb3RoZXJQdWIgPSB0aGlzLmN1cnZlLmtleUZyb21QdWJsaWMob3RoZXIpLmdldFB1YmxpYygpO1xuXHR2YXIgb3V0ID0gb3RoZXJQdWIubXVsKHRoaXMua2V5cy5nZXRQcml2YXRlKCkpLmdldFgoKTtcblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKG91dCwgZW5jLCB0aGlzLmN1cnZlVHlwZS5ieXRlTGVuZ3RoKTtcbn07XG5cbkVDREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuXHR2YXIga2V5ID0gdGhpcy5rZXlzLmdldFB1YmxpYyhmb3JtYXQgPT09ICdjb21wcmVzc2VkJywgdHJ1ZSk7XG5cdGlmIChmb3JtYXQgPT09ICdoeWJyaWQnKSB7XG5cdFx0aWYgKGtleVtrZXkubGVuZ3RoIC0gMV0gJSAyKSB7XG5cdFx0XHRrZXlbMF0gPSA3O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXkgWzBdID0gNjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKGtleSwgZW5jKTtcbn07XG5cbkVDREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoZW5jKSB7XG5cdHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpLCBlbmMpO1xufTtcblxuRUNESC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YiwgZW5jKSB7XG5cdGVuYyA9IGVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcblx0XHRwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcblx0fVxuXHR0aGlzLmtleXMuX2ltcG9ydFB1YmxpYyhwdWIpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkVDREgucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdiwgZW5jKSB7XG5cdGVuYyA9IGVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG5cdFx0cHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcblx0fVxuXHR2YXIgX3ByaXYgPSBuZXcgQk4ocHJpdik7XG5cdF9wcml2ID0gX3ByaXYudG9TdHJpbmcoMTYpO1xuXHR0aGlzLmtleXMuX2ltcG9ydFByaXZhdGUoX3ByaXYpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMsIGxlbikge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYm4pKSB7XG5cdFx0Ym4gPSBibi50b0FycmF5KCk7XG5cdH1cblx0dmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4pO1xuXHRpZiAobGVuICYmIGJ1Zi5sZW5ndGggPCBsZW4pIHtcblx0XHR2YXIgemVyb3MgPSBuZXcgQnVmZmVyKGxlbiAtIGJ1Zi5sZW5ndGgpO1xuXHRcdHplcm9zLmZpbGwoMCk7XG5cdFx0YnVmID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIGJ1Zl0pO1xuXHR9XG5cdGlmICghZW5jKSB7XG5cdFx0cmV0dXJuIGJ1Zjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG5cdH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZM0psWVhSbExXVmpaR2d2WW5KdmQzTmxjaTVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR1ZzYkdsd2RHbGpJRDBnY21WeGRXbHlaU2duWld4c2FYQjBhV01uS1R0Y2JuWmhjaUJDVGlBOUlISmxjWFZwY21Vb0oySnVMbXB6SnlrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdZM0psWVhSbFJVTkVTQ2hqZFhKMlpTa2dlMXh1WEhSeVpYUjFjbTRnYm1WM0lFVkRSRWdvWTNWeWRtVXBPMXh1ZlR0Y2JseHVkbUZ5SUdGc2FXRnpaWE1nUFNCN1hHNWNkSE5sWTNBeU5UWnJNVG9nZTF4dVhIUmNkRzVoYldVNklDZHpaV053TWpVMmF6RW5MRnh1WEhSY2RHSjVkR1ZNWlc1bmRHZzZJRE15WEc1Y2RIMHNYRzVjZEhObFkzQXlNalJ5TVRvZ2UxeHVYSFJjZEc1aGJXVTZJQ2R3TWpJMEp5eGNibHgwWEhSaWVYUmxUR1Z1WjNSb09pQXlPRnh1WEhSOUxGeHVYSFJ3Y21sdFpUSTFObll4T2lCN1hHNWNkRngwYm1GdFpUb2dKM0F5TlRZbkxGeHVYSFJjZEdKNWRHVk1aVzVuZEdnNklETXlYRzVjZEgwc1hHNWNkSEJ5YVcxbE1Ua3lkakU2SUh0Y2JseDBYSFJ1WVcxbE9pQW5jREU1TWljc1hHNWNkRngwWW5sMFpVeGxibWQwYURvZ01qUmNibHgwZlN4Y2JseDBaV1F5TlRVeE9Ub2dlMXh1WEhSY2RHNWhiV1U2SUNkbFpESTFOVEU1Snl4Y2JseDBYSFJpZVhSbFRHVnVaM1JvT2lBek1seHVYSFI5WEc1OU8xeHVYRzVoYkdsaGMyVnpMbkF5TWpRZ1BTQmhiR2xoYzJWekxuTmxZM0F5TWpSeU1UdGNibUZzYVdGelpYTXVjREkxTmlBOUlHRnNhV0Z6WlhNdWMyVmpjREkxTm5JeElEMGdZV3hwWVhObGN5NXdjbWx0WlRJMU5uWXhPMXh1WVd4cFlYTmxjeTV3TVRreUlEMGdZV3hwWVhObGN5NXpaV053TVRreWNqRWdQU0JoYkdsaGMyVnpMbkJ5YVcxbE1Ua3lkakU3WEc1Y2JtWjFibU4wYVc5dUlFVkRSRWdvWTNWeWRtVXBJSHRjYmx4MGRHaHBjeTVqZFhKMlpWUjVjR1VnUFNCaGJHbGhjMlZ6VzJOMWNuWmxYVHRjYmx4MGFXWWdLQ0YwYUdsekxtTjFjblpsVkhsd1pTQXBJSHRjYmx4MFhIUjBhR2x6TG1OMWNuWmxWSGx3WlNBOUlIdGNibHgwWEhSY2RHNWhiV1U2SUdOMWNuWmxYRzVjZEZ4MGZUdGNibHgwZlZ4dVhIUjBhR2x6TG1OMWNuWmxJRDBnYm1WM0lHVnNiR2x3ZEdsakxtVmpLSFJvYVhNdVkzVnlkbVZVZVhCbExtNWhiV1VwTzF4dVhIUjBhR2x6TG10bGVYTWdQU0IyYjJsa0lEQTdYRzU5WEc1Y2JrVkRSRWd1Y0hKdmRHOTBlWEJsTG1kbGJtVnlZWFJsUzJWNWN5QTlJR1oxYm1OMGFXOXVJQ2hsYm1Nc0lHWnZjbTFoZENrZ2UxeHVYSFIwYUdsekxtdGxlWE1nUFNCMGFHbHpMbU4xY25abExtZGxia3RsZVZCaGFYSW9LVHRjYmx4MGNtVjBkWEp1SUhSb2FYTXVaMlYwVUhWaWJHbGpTMlY1S0dWdVl5d2dabTl5YldGMEtUdGNibjA3WEc1Y2JrVkRSRWd1Y0hKdmRHOTBlWEJsTG1OdmJYQjFkR1ZUWldOeVpYUWdQU0JtZFc1amRHbHZiaUFvYjNSb1pYSXNJR2x1Wlc1akxDQmxibU1wSUh0Y2JseDBhVzVsYm1NZ1BTQnBibVZ1WXlCOGZDQW5kWFJtT0NjN1hHNWNkR2xtSUNnaFFuVm1abVZ5TG1selFuVm1abVZ5S0c5MGFHVnlLU2tnZTF4dVhIUmNkRzkwYUdWeUlEMGdibVYzSUVKMVptWmxjaWh2ZEdobGNpd2dhVzVsYm1NcE8xeHVYSFI5WEc1Y2RIWmhjaUJ2ZEdobGNsQjFZaUE5SUhSb2FYTXVZM1Z5ZG1VdWEyVjVSbkp2YlZCMVlteHBZeWh2ZEdobGNpa3VaMlYwVUhWaWJHbGpLQ2s3WEc1Y2RIWmhjaUJ2ZFhRZ1BTQnZkR2hsY2xCMVlpNXRkV3dvZEdocGN5NXJaWGx6TG1kbGRGQnlhWFpoZEdVb0tTa3VaMlYwV0NncE8xeHVYSFJ5WlhSMWNtNGdabTl5YldGMFVtVjBkWEp1Vm1Gc2RXVW9iM1YwTENCbGJtTXNJSFJvYVhNdVkzVnlkbVZVZVhCbExtSjVkR1ZNWlc1bmRHZ3BPMXh1ZlR0Y2JseHVSVU5FU0M1d2NtOTBiM1I1Y0dVdVoyVjBVSFZpYkdsalMyVjVJRDBnWm5WdVkzUnBiMjRnS0dWdVl5d2dabTl5YldGMEtTQjdYRzVjZEhaaGNpQnJaWGtnUFNCMGFHbHpMbXRsZVhNdVoyVjBVSFZpYkdsaktHWnZjbTFoZENBOVBUMGdKMk52YlhCeVpYTnpaV1FuTENCMGNuVmxLVHRjYmx4MGFXWWdLR1p2Y20xaGRDQTlQVDBnSjJoNVluSnBaQ2NwSUh0Y2JseDBYSFJwWmlBb2EyVjVXMnRsZVM1c1pXNW5kR2dnTFNBeFhTQWxJRElwSUh0Y2JseDBYSFJjZEd0bGVWc3dYU0E5SURjN1hHNWNkRngwZlNCbGJITmxJSHRjYmx4MFhIUmNkR3RsZVNCYk1GMGdQU0EyTzF4dVhIUmNkSDFjYmx4MGZWeHVYSFJ5WlhSMWNtNGdabTl5YldGMFVtVjBkWEp1Vm1Gc2RXVW9hMlY1TENCbGJtTXBPMXh1ZlR0Y2JseHVSVU5FU0M1d2NtOTBiM1I1Y0dVdVoyVjBVSEpwZG1GMFpVdGxlU0E5SUdaMWJtTjBhVzl1SUNobGJtTXBJSHRjYmx4MGNtVjBkWEp1SUdadmNtMWhkRkpsZEhWeWJsWmhiSFZsS0hSb2FYTXVhMlY1Y3k1blpYUlFjbWwyWVhSbEtDa3NJR1Z1WXlrN1hHNTlPMXh1WEc1RlEwUklMbkJ5YjNSdmRIbHdaUzV6WlhSUWRXSnNhV05MWlhrZ1BTQm1kVzVqZEdsdmJpQW9jSFZpTENCbGJtTXBJSHRjYmx4MFpXNWpJRDBnWlc1aklIeDhJQ2QxZEdZNEp6dGNibHgwYVdZZ0tDRkNkV1ptWlhJdWFYTkNkV1ptWlhJb2NIVmlLU2tnZTF4dVhIUmNkSEIxWWlBOUlHNWxkeUJDZFdabVpYSW9jSFZpTENCbGJtTXBPMXh1WEhSOVhHNWNkSFJvYVhNdWEyVjVjeTVmYVcxd2IzSjBVSFZpYkdsaktIQjFZaWs3WEc1Y2RISmxkSFZ5YmlCMGFHbHpPMXh1ZlR0Y2JseHVSVU5FU0M1d2NtOTBiM1I1Y0dVdWMyVjBVSEpwZG1GMFpVdGxlU0E5SUdaMWJtTjBhVzl1SUNod2NtbDJMQ0JsYm1NcElIdGNibHgwWlc1aklEMGdaVzVqSUh4OElDZDFkR1k0Snp0Y2JseDBhV1lnS0NGQ2RXWm1aWEl1YVhOQ2RXWm1aWElvY0hKcGRpa3BJSHRjYmx4MFhIUndjbWwySUQwZ2JtVjNJRUoxWm1abGNpaHdjbWwyTENCbGJtTXBPMXh1WEhSOVhHNWNkSFpoY2lCZmNISnBkaUE5SUc1bGR5QkNUaWh3Y21sMktUdGNibHgwWDNCeWFYWWdQU0JmY0hKcGRpNTBiMU4wY21sdVp5Z3hOaWs3WEc1Y2RIUm9hWE11YTJWNWN5NWZhVzF3YjNKMFVISnBkbUYwWlNoZmNISnBkaWs3WEc1Y2RISmxkSFZ5YmlCMGFHbHpPMXh1ZlR0Y2JseHVablZ1WTNScGIyNGdabTl5YldGMFVtVjBkWEp1Vm1Gc2RXVW9ZbTRzSUdWdVl5d2diR1Z1S1NCN1hHNWNkR2xtSUNnaFFYSnlZWGt1YVhOQmNuSmhlU2hpYmlrcElIdGNibHgwWEhSaWJpQTlJR0p1TG5SdlFYSnlZWGtvS1R0Y2JseDBmVnh1WEhSMllYSWdZblZtSUQwZ2JtVjNJRUoxWm1abGNpaGliaWs3WEc1Y2RHbG1JQ2hzWlc0Z0ppWWdZblZtTG14bGJtZDBhQ0E4SUd4bGJpa2dlMXh1WEhSY2RIWmhjaUI2WlhKdmN5QTlJRzVsZHlCQ2RXWm1aWElvYkdWdUlDMGdZblZtTG14bGJtZDBhQ2s3WEc1Y2RGeDBlbVZ5YjNNdVptbHNiQ2d3S1R0Y2JseDBYSFJpZFdZZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0NlpYSnZjeXdnWW5WbVhTazdYRzVjZEgxY2JseDBhV1lnS0NGbGJtTXBJSHRjYmx4MFhIUnlaWFIxY200Z1luVm1PMXh1WEhSOUlHVnNjMlVnZTF4dVhIUmNkSEpsZEhWeWJpQmlkV1l1ZEc5VGRISnBibWNvWlc1aktUdGNibHgwZlZ4dWZWeHVJbDE5IiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwibW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9YXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9wYWNrYWdlLmpzb25cIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvYnJvcmFuZC9pbmRleC5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy91dGlscy5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9obWFjLWRyYmcuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3V0aWxzLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvaG1hYy5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9wcmVjb21wdXRlZC9zZWNwMjU2azEuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvc2hvcnQuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qc1wiXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bXCIvaG9tZS90cmV2b3IvY29kZS1kb3Qtb3JnL2FwcHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdW1wiL2hvbWUvdHJldm9yL2NvZGUtZG90LW9yZy9hcHBzL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanNcIl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgX2FsZ29zID0gcmVxdWlyZSgnLi9hbGdvcycpXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBhbGdvcyA9IHt9XG5PYmplY3Qua2V5cyhfYWxnb3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvc1trZXldID0gYWxnb3Nba2V5LnRvTG93ZXJDYXNlKCldID0gX2FsZ29zW2tleV1cbn0pXG5cbmV4cG9ydHMuY3JlYXRlU2lnbiA9IGV4cG9ydHMuU2lnbiA9IGNyZWF0ZVNpZ25cblxuZnVuY3Rpb24gY3JlYXRlU2lnbiAoYWxnb3JpdGhtKSB7XG4gIHJldHVybiBuZXcgU2lnbihhbGdvcml0aG0pXG59XG5cbmV4cG9ydHMuY3JlYXRlVmVyaWZ5ID0gZXhwb3J0cy5WZXJpZnkgPSBjcmVhdGVWZXJpZnlcblxuZnVuY3Rpb24gY3JlYXRlVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBWZXJpZnkoYWxnb3JpdGhtKVxufVxuXG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cbmZ1bmN0aW9uIFNpZ24gKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuICB2YXIgZGF0YSA9IGFsZ29zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihCdWZmZXIuY29uY2F0KFt0aGlzLl90YWcsIGhhc2hdKSwga2V5LCB0aGlzLl9oYXNoVHlwZSwgdGhpcy5fc2lnblR5cGUpXG4gIGlmIChlbmMpIHtcbiAgICBzaWcgPSBzaWcudG9TdHJpbmcoZW5jKVxuICB9XG4gIHJldHVybiBzaWdcbn1cblxuaW5oZXJpdHMoVmVyaWZ5LCBzdHJlYW0uV3JpdGFibGUpXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuICB2YXIgZGF0YSA9IGFsZ29zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5cblZlcmlmeS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChkYXRhLCBfLCBkb25lKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIGRvbmUoKVxufVxuXG5WZXJpZnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblZlcmlmeS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5TWV0aG9kIChrZXksIHNpZywgZW5jKSB7XG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIGlmICh0eXBlb2Ygc2lnID09PSAnc3RyaW5nJylcbiAgICBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuXG4gIHJldHVybiB2ZXJpZnkoc2lnLCBCdWZmZXIuY29uY2F0KFt0aGlzLl90YWcsIGhhc2hdKSwga2V5LCB0aGlzLl9zaWduVHlwZSlcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzF6YVdkdUwySnliM2R6WlhJdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJbmRYTmxJSE4wY21samRDZGNiblpoY2lCemFXZHVJRDBnY21WeGRXbHlaU2duTGk5emFXZHVKeWxjYm5aaGNpQjJaWEpwWm5rZ1BTQnlaWEYxYVhKbEtDY3VMM1psY21sbWVTY3BYRzUyWVhJZ2MzUnlaV0Z0SUQwZ2NtVnhkV2x5WlNnbmMzUnlaV0Z0SnlsY2JuWmhjaUJwYm1obGNtbDBjeUE5SUhKbGNYVnBjbVVvSjJsdWFHVnlhWFJ6SnlsY2JuWmhjaUJmWVd4bmIzTWdQU0J5WlhGMWFYSmxLQ2N1TDJGc1oyOXpKeWxjYm5aaGNpQmpjbVZoZEdWSVlYTm9JRDBnY21WeGRXbHlaU2duWTNKbFlYUmxMV2hoYzJnbktWeHVkbUZ5SUdGc1oyOXpJRDBnZTMxY2JrOWlhbVZqZEM1clpYbHpLRjloYkdkdmN5a3VabTl5UldGamFDaG1kVzVqZEdsdmJpQW9hMlY1S1NCN1hHNGdJR0ZzWjI5elcydGxlVjBnUFNCaGJHZHZjMXRyWlhrdWRHOU1iM2RsY2tOaGMyVW9LVjBnUFNCZllXeG5iM05iYTJWNVhWeHVmU2xjYmx4dVpYaHdiM0owY3k1amNtVmhkR1ZUYVdkdUlEMGdaWGh3YjNKMGN5NVRhV2R1SUQwZ1kzSmxZWFJsVTJsbmJseHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVlRhV2R1SUNoaGJHZHZjbWwwYUcwcElIdGNiaUFnY21WMGRYSnVJRzVsZHlCVGFXZHVLR0ZzWjI5eWFYUm9iU2xjYm4xY2JseHVaWGh3YjNKMGN5NWpjbVZoZEdWV1pYSnBabmtnUFNCbGVIQnZjblJ6TGxabGNtbG1lU0E5SUdOeVpXRjBaVlpsY21sbWVWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVldaWEpwWm5rZ0tHRnNaMjl5YVhSb2JTa2dlMXh1SUNCeVpYUjFjbTRnYm1WM0lGWmxjbWxtZVNoaGJHZHZjbWwwYUcwcFhHNTlYRzVjYm1sdWFHVnlhWFJ6S0ZOcFoyNHNJSE4wY21WaGJTNVhjbWwwWVdKc1pTbGNibHh1Wm5WdVkzUnBiMjRnVTJsbmJpQW9ZV3huYjNKcGRHaHRLU0I3WEc0Z0lITjBjbVZoYlM1WGNtbDBZV0pzWlM1allXeHNLSFJvYVhNcFhHNGdJSFpoY2lCa1lYUmhJRDBnWVd4bmIzTmJZV3huYjNKcGRHaHRYVnh1SUNCcFppQW9JV1JoZEdFcFhHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RWYm10dWIzZHVJRzFsYzNOaFoyVWdaR2xuWlhOMEp5bGNibHh1SUNCMGFHbHpMbDlvWVhOb1ZIbHdaU0E5SUdSaGRHRXVhR0Z6YUZ4dUlDQjBhR2x6TGw5b1lYTm9JRDBnWTNKbFlYUmxTR0Z6YUNoa1lYUmhMbWhoYzJncFhHNGdJSFJvYVhNdVgzUmhaeUE5SUdSaGRHRXVhV1JjYmlBZ2RHaHBjeTVmYzJsbmJsUjVjR1VnUFNCa1lYUmhMbk5wWjI1Y2JuMWNibHh1VTJsbmJpNXdjbTkwYjNSNWNHVXVYM2R5YVhSbElEMGdablZ1WTNScGIyNGdYM2R5YVhSbElDaGtZWFJoTENCZkxDQmtiMjVsS1NCN1hHNGdJSFJvYVhNdVgyaGhjMmd1ZFhCa1lYUmxLR1JoZEdFcFhHNGdJR1J2Ym1Vb0tWeHVmVnh1WEc1VGFXZHVMbkJ5YjNSdmRIbHdaUzUxY0dSaGRHVWdQU0JtZFc1amRHbHZiaUIxY0dSaGRHVWdLR1JoZEdFc0lHVnVZeWtnZTF4dUlDQnBaaUFvZEhsd1pXOW1JR1JoZEdFZ1BUMDlJQ2R6ZEhKcGJtY25LVnh1SUNBZ0lHUmhkR0VnUFNCdVpYY2dRblZtWm1WeUtHUmhkR0VzSUdWdVl5bGNiaUFnZEdocGN5NWZhR0Z6YUM1MWNHUmhkR1VvWkdGMFlTbGNiaUFnY21WMGRYSnVJSFJvYVhOY2JuMWNibHh1VTJsbmJpNXdjbTkwYjNSNWNHVXVjMmxuYmlBOUlHWjFibU4wYVc5dUlITnBaMjVOWlhSb2IyUWdLR3RsZVN3Z1pXNWpLU0I3WEc0Z0lIUm9hWE11Wlc1a0tDbGNiaUFnZG1GeUlHaGhjMmdnUFNCMGFHbHpMbDlvWVhOb0xtUnBaMlZ6ZENncFhHNGdJSFpoY2lCemFXY2dQU0J6YVdkdUtFSjFabVpsY2k1amIyNWpZWFFvVzNSb2FYTXVYM1JoWnl3Z2FHRnphRjBwTENCclpYa3NJSFJvYVhNdVgyaGhjMmhVZVhCbExDQjBhR2x6TGw5emFXZHVWSGx3WlNsY2JpQWdhV1lnS0dWdVl5a2dlMXh1SUNBZ0lITnBaeUE5SUhOcFp5NTBiMU4wY21sdVp5aGxibU1wWEc0Z0lIMWNiaUFnY21WMGRYSnVJSE5wWjF4dWZWeHVYRzVwYm1obGNtbDBjeWhXWlhKcFpua3NJSE4wY21WaGJTNVhjbWwwWVdKc1pTbGNibVoxYm1OMGFXOXVJRlpsY21sbWVTQW9ZV3huYjNKcGRHaHRLU0I3WEc0Z0lITjBjbVZoYlM1WGNtbDBZV0pzWlM1allXeHNLSFJvYVhNcFhHNGdJSFpoY2lCa1lYUmhJRDBnWVd4bmIzTmJZV3huYjNKcGRHaHRYVnh1SUNCcFppQW9JV1JoZEdFcFhHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RWYm10dWIzZHVJRzFsYzNOaFoyVWdaR2xuWlhOMEp5bGNibHh1SUNCMGFHbHpMbDlvWVhOb0lEMGdZM0psWVhSbFNHRnphQ2hrWVhSaExtaGhjMmdwWEc0Z0lIUm9hWE11WDNSaFp5QTlJR1JoZEdFdWFXUmNiaUFnZEdocGN5NWZjMmxuYmxSNWNHVWdQU0JrWVhSaExuTnBaMjVjYm4xY2JseHVWbVZ5YVdaNUxuQnliM1J2ZEhsd1pTNWZkM0pwZEdVZ1BTQm1kVzVqZEdsdmJpQmZkM0pwZEdVZ0tHUmhkR0VzSUY4c0lHUnZibVVwSUh0Y2JpQWdkR2hwY3k1ZmFHRnphQzUxY0dSaGRHVW9aR0YwWVNsY2JpQWdaRzl1WlNncFhHNTlYRzVjYmxabGNtbG1lUzV3Y205MGIzUjVjR1V1ZFhCa1lYUmxJRDBnWm5WdVkzUnBiMjRnZFhCa1lYUmxJQ2hrWVhSaExDQmxibU1wSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJrWVhSaElEMDlQU0FuYzNSeWFXNW5KeWxjYmlBZ0lDQmtZWFJoSUQwZ2JtVjNJRUoxWm1abGNpaGtZWFJoTENCbGJtTXBYRzVjYmlBZ2RHaHBjeTVmYUdGemFDNTFjR1JoZEdVb1pHRjBZU2xjYmlBZ2NtVjBkWEp1SUhSb2FYTmNibjFjYmx4dVZtVnlhV1o1TG5CeWIzUnZkSGx3WlM1MlpYSnBabmtnUFNCbWRXNWpkR2x2YmlCMlpYSnBabmxOWlhSb2IyUWdLR3RsZVN3Z2MybG5MQ0JsYm1NcElIdGNiaUFnZEdocGN5NWxibVFvS1Z4dUlDQjJZWElnYUdGemFDQTlJSFJvYVhNdVgyaGhjMmd1WkdsblpYTjBLQ2xjYmlBZ2FXWWdLSFI1Y0dWdlppQnphV2NnUFQwOUlDZHpkSEpwYm1jbktWeHVJQ0FnSUhOcFp5QTlJRzVsZHlCQ2RXWm1aWElvYzJsbkxDQmxibU1wWEc1Y2JpQWdjbVYwZFhKdUlIWmxjbWxtZVNoemFXY3NJRUoxWm1abGNpNWpiMjVqWVhRb1czUm9hWE11WDNSaFp5d2dhR0Z6YUYwcExDQnJaWGtzSUhSb2FYTXVYM05wWjI1VWVYQmxLVnh1ZlZ4dUlsMTkiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4ndXNlIHN0cmljdCdcbi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcycpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuXG5mdW5jdGlvbiB2ZXJpZnkgKHNpZywgaGFzaCwga2V5LCBzaWduVHlwZSkge1xuICB2YXIgcHViID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHB1Yi50eXBlID09PSAnZWMnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZWNkc2EnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBlY1ZlcmlmeShzaWcsIGhhc2gsIHB1YilcbiAgfSBlbHNlIGlmIChwdWIudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBkc2FWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gcHViLm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBwYWQgPSBbIDEgXVxuICB2YXIgcGFkTnVtID0gMFxuICB3aGlsZSAoaGFzaC5sZW5ndGggKyBwYWQubGVuZ3RoICsgMiA8IGxlbikge1xuICAgIHBhZC5wdXNoKDB4ZmYpXG4gICAgcGFkTnVtKytcbiAgfVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkge1xuICAgIHBhZC5wdXNoKGhhc2hbaV0pXG4gIH1cbiAgcGFkID0gbmV3IEJ1ZmZlcihwYWQpXG4gIHZhciByZWQgPSBCTi5tb250KHB1Yi5tb2R1bHVzKVxuICBzaWcgPSBuZXcgQk4oc2lnKS50b1JlZChyZWQpXG5cbiAgc2lnID0gc2lnLnJlZFBvdyhuZXcgQk4ocHViLnB1YmxpY0V4cG9uZW50KSlcblxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gMFxuICBpZiAocGFkTnVtIDwgOCkge1xuICAgIG91dCA9IDFcbiAgfVxuICBsZW4gPSBNYXRoLm1pbihzaWcubGVuZ3RoLCBwYWQubGVuZ3RoKVxuICBpZiAoc2lnLmxlbmd0aCAhPT0gcGFkLmxlbmd0aCkge1xuICAgIG91dCA9IDFcbiAgfVxuXG4gIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0IHw9IChzaWdbaV0gXiBwYWRbaV0pXG4gIH1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuZnVuY3Rpb24gZWNWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3B1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJyldXG4gIGlmICghY3VydmVJZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IGVsbGlwdGljLmVjKGN1cnZlSWQpXG5cbiAgdmFyIHB1YmtleSA9IHB1Yi5kYXRhLnN1YmplY3RQcml2YXRlS2V5LmRhdGFcbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cbmZ1bmN0aW9uIGRzYVZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIHAgPSBwdWIuZGF0YS5wXG4gIHZhciBxID0gcHViLmRhdGEucVxuICB2YXIgZyA9IHB1Yi5kYXRhLmdcbiAgdmFyIHkgPSBwdWIuZGF0YS5wdWJfa2V5XG4gIHZhciB1bnBhY2tlZCA9IHBhcnNlS2V5cy5zaWduYXR1cmUuZGVjb2RlKHNpZywgJ2RlcicpXG4gIHZhciBzID0gdW5wYWNrZWQuc1xuICB2YXIgciA9IHVucGFja2VkLnJcbiAgY2hlY2tWYWx1ZShzLCBxKVxuICBjaGVja1ZhbHVlKHIsIHEpXG4gIHZhciBtb250cSA9IEJOLm1vbnQocSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9ICBzLmludm0ocSlcbiAgdmFyIHYgPSBnLnRvUmVkKG1vbnRwKVxuICAucmVkUG93KG5ldyBCTihoYXNoKS5tdWwodykubW9kKHEpKVxuICAuZnJvbVJlZCgpXG4gIC5tdWwoXG4gICAgeS50b1JlZChtb250cClcbiAgICAucmVkUG93KHIubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICkubW9kKHApLm1vZChxKVxuICByZXR1cm4gIXYuY21wKHIpXG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlIChiLCBxKSB7XG4gIGlmIChiLmNtcG4oMCkgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxuICB9XG4gIGlmIChiLmNtcChxKSA+PSBxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzF6YVdkdUwzWmxjbWxtZVM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpSjNWelpTQnpkSEpwWTNRblhHNHZMeUJ0ZFdOb0lHOW1JSFJvYVhNZ1ltRnpaV1FnYjI0Z2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwybHVaSFYwYm5rdmMyVnNaaTF6YVdkdVpXUXZZbXh2WWk5bmFDMXdZV2RsY3k5c2FXSXZjbk5oTG1welhHNTJZWElnY0dGeWMyVkxaWGx6SUQwZ2NtVnhkV2x5WlNnbmNHRnljMlV0WVhOdU1TY3BYRzUyWVhJZ1pXeHNhWEIwYVdNZ1BTQnlaWEYxYVhKbEtDZGxiR3hwY0hScFl5Y3BYRzUyWVhJZ1kzVnlkbVZ6SUQwZ2NtVnhkV2x5WlNnbkxpOWpkWEoyWlhNbktWeHVkbUZ5SUVKT0lEMGdjbVZ4ZFdseVpTZ25ZbTR1YW5NbktWeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjJaWEpwWm5sY2JseHVablZ1WTNScGIyNGdkbVZ5YVdaNUlDaHphV2NzSUdoaGMyZ3NJR3RsZVN3Z2MybG5ibFI1Y0dVcElIdGNiaUFnZG1GeUlIQjFZaUE5SUhCaGNuTmxTMlY1Y3loclpYa3BYRzRnSUdsbUlDaHdkV0l1ZEhsd1pTQTlQVDBnSjJWakp5a2dlMXh1SUNBZ0lHbG1JQ2h6YVdkdVZIbHdaU0FoUFQwZ0oyVmpaSE5oSnlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkM2NtOXVaeUJ3ZFdKc2FXTWdhMlY1SUhSNWNHVW5LVnh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnWldOV1pYSnBabmtvYzJsbkxDQm9ZWE5vTENCd2RXSXBYRzRnSUgwZ1pXeHpaU0JwWmlBb2NIVmlMblI1Y0dVZ1BUMDlJQ2RrYzJFbktTQjdYRzRnSUNBZ2FXWWdLSE5wWjI1VWVYQmxJQ0U5UFNBblpITmhKeWtnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QzY205dVp5QndkV0pzYVdNZ2EyVjVJSFI1Y0dVbktWeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdaSE5oVm1WeWFXWjVLSE5wWnl3Z2FHRnphQ3dnY0hWaUtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHbG1JQ2h6YVdkdVZIbHdaU0FoUFQwZ0ozSnpZU2NwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZDNKdmJtY2djSFZpYkdsaklHdGxlU0IwZVhCbEp5bGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2RtRnlJR3hsYmlBOUlIQjFZaTV0YjJSMWJIVnpMbUo1ZEdWTVpXNW5kR2dvS1Z4dUlDQjJZWElnY0dGa0lEMGdXeUF4SUYxY2JpQWdkbUZ5SUhCaFpFNTFiU0E5SURCY2JpQWdkMmhwYkdVZ0tHaGhjMmd1YkdWdVozUm9JQ3NnY0dGa0xteGxibWQwYUNBcklESWdQQ0JzWlc0cElIdGNiaUFnSUNCd1lXUXVjSFZ6YUNnd2VHWm1LVnh1SUNBZ0lIQmhaRTUxYlNzclhHNGdJSDFjYmlBZ2NHRmtMbkIxYzJnb01IZ3dNQ2xjYmlBZ2RtRnlJR2tnUFNBdE1WeHVJQ0IzYUdsc1pTQW9LeXRwSUR3Z2FHRnphQzVzWlc1bmRHZ3BJSHRjYmlBZ0lDQndZV1F1Y0hWemFDaG9ZWE5vVzJsZEtWeHVJQ0I5WEc0Z0lIQmhaQ0E5SUc1bGR5QkNkV1ptWlhJb2NHRmtLVnh1SUNCMllYSWdjbVZrSUQwZ1FrNHViVzl1ZENod2RXSXViVzlrZFd4MWN5bGNiaUFnYzJsbklEMGdibVYzSUVKT0tITnBaeWt1ZEc5U1pXUW9jbVZrS1Z4dVhHNGdJSE5wWnlBOUlITnBaeTV5WldSUWIzY29ibVYzSUVKT0tIQjFZaTV3ZFdKc2FXTkZlSEJ2Ym1WdWRDa3BYRzVjYmlBZ2MybG5JRDBnYm1WM0lFSjFabVpsY2loemFXY3Vabkp2YlZKbFpDZ3BMblJ2UVhKeVlYa29LU2xjYmlBZ2RtRnlJRzkxZENBOUlEQmNiaUFnYVdZZ0tIQmhaRTUxYlNBOElEZ3BJSHRjYmlBZ0lDQnZkWFFnUFNBeFhHNGdJSDFjYmlBZ2JHVnVJRDBnVFdGMGFDNXRhVzRvYzJsbkxteGxibWQwYUN3Z2NHRmtMbXhsYm1kMGFDbGNiaUFnYVdZZ0tITnBaeTVzWlc1bmRHZ2dJVDA5SUhCaFpDNXNaVzVuZEdncElIdGNiaUFnSUNCdmRYUWdQU0F4WEc0Z0lIMWNibHh1SUNCcElEMGdMVEZjYmlBZ2QyaHBiR1VnS0NzcmFTQThJR3hsYmlrZ2UxeHVJQ0FnSUc5MWRDQjhQU0FvYzJsblcybGRJRjRnY0dGa1cybGRLVnh1SUNCOVhHNGdJSEpsZEhWeWJpQnZkWFFnUFQwOUlEQmNibjFjYm1aMWJtTjBhVzl1SUdWalZtVnlhV1o1SUNoemFXY3NJR2hoYzJnc0lIQjFZaWtnZTF4dUlDQjJZWElnWTNWeWRtVkpaQ0E5SUdOMWNuWmxjMXR3ZFdJdVpHRjBZUzVoYkdkdmNtbDBhRzB1WTNWeWRtVXVhbTlwYmlnbkxpY3BYVnh1SUNCcFppQW9JV04xY25abFNXUXBYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkMWJtdHViM2R1SUdOMWNuWmxJQ2NnS3lCd2RXSXVaR0YwWVM1aGJHZHZjbWwwYUcwdVkzVnlkbVV1YW05cGJpZ25MaWNwS1Z4dVhHNGdJSFpoY2lCamRYSjJaU0E5SUc1bGR5QmxiR3hwY0hScFl5NWxZeWhqZFhKMlpVbGtLVnh1WEc0Z0lIWmhjaUJ3ZFdKclpYa2dQU0J3ZFdJdVpHRjBZUzV6ZFdKcVpXTjBVSEpwZG1GMFpVdGxlUzVrWVhSaFhHNGdJSEpsZEhWeWJpQmpkWEoyWlM1MlpYSnBabmtvYUdGemFDd2djMmxuTENCd2RXSnJaWGtwWEc1OVhHNW1kVzVqZEdsdmJpQmtjMkZXWlhKcFpua2dLSE5wWnl3Z2FHRnphQ3dnY0hWaUtTQjdYRzRnSUhaaGNpQndJRDBnY0hWaUxtUmhkR0V1Y0Z4dUlDQjJZWElnY1NBOUlIQjFZaTVrWVhSaExuRmNiaUFnZG1GeUlHY2dQU0J3ZFdJdVpHRjBZUzVuWEc0Z0lIWmhjaUI1SUQwZ2NIVmlMbVJoZEdFdWNIVmlYMnRsZVZ4dUlDQjJZWElnZFc1d1lXTnJaV1FnUFNCd1lYSnpaVXRsZVhNdWMybG5ibUYwZFhKbExtUmxZMjlrWlNoemFXY3NJQ2RrWlhJbktWeHVJQ0IyWVhJZ2N5QTlJSFZ1Y0dGamEyVmtMbk5jYmlBZ2RtRnlJSElnUFNCMWJuQmhZMnRsWkM1eVhHNGdJR05vWldOclZtRnNkV1VvY3l3Z2NTbGNiaUFnWTJobFkydFdZV3gxWlNoeUxDQnhLVnh1SUNCMllYSWdiVzl1ZEhFZ1BTQkNUaTV0YjI1MEtIRXBYRzRnSUhaaGNpQnRiMjUwY0NBOUlFSk9MbTF2Ym5Rb2NDbGNiaUFnZG1GeUlIY2dQU0FnY3k1cGJuWnRLSEVwWEc0Z0lIWmhjaUIySUQwZ1p5NTBiMUpsWkNodGIyNTBjQ2xjYmlBZ0xuSmxaRkJ2ZHlodVpYY2dRazRvYUdGemFDa3ViWFZzS0hjcExtMXZaQ2h4S1NsY2JpQWdMbVp5YjIxU1pXUW9LVnh1SUNBdWJYVnNLRnh1SUNBZ0lIa3VkRzlTWldRb2JXOXVkSEFwWEc0Z0lDQWdMbkpsWkZCdmR5aHlMbTExYkNoM0tTNXRiMlFvY1NrcFhHNGdJQ0FnTG1aeWIyMVNaV1FvS1Z4dUlDQXBMbTF2WkNod0tTNXRiMlFvY1NsY2JpQWdjbVYwZFhKdUlDRjJMbU50Y0NoeUtWeHVmVnh1Wm5WdVkzUnBiMjRnWTJobFkydFdZV3gxWlNBb1lpd2djU2tnZTF4dUlDQnBaaUFvWWk1amJYQnVLREFwSUR3OUlEQXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0oybHVkbUZzYVdRZ2MybG5KeWxjYmlBZ2ZWeHVJQ0JwWmlBb1lpNWpiWEFvY1NrZ1BqMGdjU2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25hVzUyWVd4cFpDQnphV2NuS1Z4dUlDQjlYRzU5WEc0aVhYMD0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpZ25cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIGtleSwgaGFzaFR5cGUsIHNpZ25UeXBlKSB7XG4gIHZhciBwcml2ID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHByaXYuY3VydmUpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBlY1NpZ24oaGFzaCwgcHJpdilcbiAgfSBlbHNlIGlmIChwcml2LnR5cGUgPT09ICdkc2EnKSB7XG4gICAgcmV0dXJuIGRzYVNpZ24oaGFzaCwgcHJpdiwgaGFzaFR5cGUpXG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMCwgMSBdXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAxIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgfVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkge1xuICAgIHBhZC5wdXNoKGhhc2hbaV0pXG4gIH1cblxuICB2YXIgb3V0ID0gY3J0KHBhZCwgcHJpdilcbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gZWNTaWduIChoYXNoLCBwcml2KSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3ByaXYuY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwcml2LmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgZWxsaXB0aWMuZWMoY3VydmVJZClcblxuICB2YXIga2V5ID0gY3VydmUuZ2VuS2V5UGFpcigpXG4gIGtleS5faW1wb3J0UHJpdmF0ZShwcml2LnByaXZhdGVLZXkpXG4gIHZhciBvdXQgPSBrZXkuc2lnbihoYXNoKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cbmZ1bmN0aW9uIGRzYVNpZ24gKGhhc2gsIHByaXYsIGFsZ28pIHtcbiAgdmFyIHggPSBwcml2LnBhcmFtcy5wcml2X2tleVxuICB2YXIgcCA9IHByaXYucGFyYW1zLnBcbiAgdmFyIHEgPSBwcml2LnBhcmFtcy5xXG4gIHZhciBtb250cSA9IEJOLm1vbnQocSlcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmICghcy5jbXBuKDApKSB7XG4gICAgICBzID0gZmFsc2VcbiAgICAgIHIgPSBuZXcgQk4oMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvREVSKHIsIHMpXG59XG5mdW5jdGlvbiB0b0RFUiAociwgcykge1xuICByID0gci50b0FycmF5KClcbiAgcyA9IHMudG9BcnJheSgpXG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKVxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWzBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgeF0pXG4gIH1cbiAgdmFyIGhsZW4gPSBoYXNoLmxlbmd0aFxuICB2YXIgaGJpdHMgPSBiaXRzMm9jdGV0cyhoYXNoLCBxKVxuICB2YXIgdiA9IG5ldyBCdWZmZXIoaGxlbilcbiAgdi5maWxsKDEpXG4gIHZhciBrID0gbmV3IEJ1ZmZlcihobGVuKVxuICBrLmZpbGwoMClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShuZXcgQnVmZmVyKFswXSkpXG4gICAgLnVwZGF0ZSh4KVxuICAgIC51cGRhdGUoaGJpdHMpXG4gICAgLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC5kaWdlc3QoKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAudXBkYXRlKG5ldyBCdWZmZXIoWzFdKSlcbiAgICAudXBkYXRlKHgpXG4gICAgLnVwZGF0ZShoYml0cylcbiAgICAuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLmRpZ2VzdCgpXG4gIHJldHVybiB7XG4gICAgazogayxcbiAgICB2OiB2XG4gIH1cbn1cbmZ1bmN0aW9uIGJpdHMyaW50IChvYml0cywgcSkge1xuICB2YXIgYml0cyA9IG5ldyBCTihvYml0cylcbiAgdmFyIHNoaWZ0ID0gKG9iaXRzLmxlbmd0aCA8PCAzKSAtIHEuYml0TGVuZ3RoKClcbiAgaWYgKHNoaWZ0ID4gMCkge1xuICAgIGJpdHMuaXNocm4oc2hpZnQpXG4gIH1cbiAgcmV0dXJuIGJpdHNcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIG91dF0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxubW9kdWxlLmV4cG9ydHMubWFrZUtleSA9IG1ha2VLZXlcbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdCA9IG5ldyBCdWZmZXIoJycpXG4gICAgd2hpbGUgKHQubGVuZ3RoICogOCA8IHEuYml0TGVuZ3RoKCkpIHtcbiAgICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspXG4gICAgICAgIC51cGRhdGUoa3YudilcbiAgICAgICAgLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwga3Yudl0pXG4gICAgfVxuICAgIGsgPSBiaXRzMmludCh0LCBxKVxuICAgIGt2LmsgPSAgY3JlYXRlSG1hYyhhbGdvLCBrdi5rKVxuICAgICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAgIC51cGRhdGUobmV3IEJ1ZmZlcihbMF0pKVxuICAgICAgICAuZGlnZXN0KClcbiAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKVxuICAgICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAgIC5kaWdlc3QoKVxuICAgIGlmIChrLmNtcChxKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBrXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYWtlUiAoZywgaywgcCwgcSkge1xuICByZXR1cm4gZy50b1JlZChCTi5tb250KHApKS5yZWRQb3coaykuZnJvbVJlZCgpLm1vZChxKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMXphV2R1TDNOcFoyNHVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZMeUJ0ZFdOb0lHOW1JSFJvYVhNZ1ltRnpaV1FnYjI0Z2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwybHVaSFYwYm5rdmMyVnNaaTF6YVdkdVpXUXZZbXh2WWk5bmFDMXdZV2RsY3k5c2FXSXZjbk5oTG1welhHNTJZWElnY0dGeWMyVkxaWGx6SUQwZ2NtVnhkV2x5WlNnbmNHRnljMlV0WVhOdU1TY3BYRzUyWVhJZ1FrNGdQU0J5WlhGMWFYSmxLQ2RpYmk1cWN5Y3BYRzUyWVhJZ1pXeHNhWEIwYVdNZ1BTQnlaWEYxYVhKbEtDZGxiR3hwY0hScFl5Y3BYRzUyWVhJZ1kzSjBJRDBnY21WeGRXbHlaU2duWW5KdmQzTmxjbWxtZVMxeWMyRW5LVnh1ZG1GeUlHTnlaV0YwWlVodFlXTWdQU0J5WlhGMWFYSmxLQ2RqY21WaGRHVXRhRzFoWXljcFhHNTJZWElnWTNWeWRtVnpJRDBnY21WeGRXbHlaU2duTGk5amRYSjJaWE1uS1Z4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlITnBaMjVjYm1aMWJtTjBhVzl1SUhOcFoyNGdLR2hoYzJnc0lHdGxlU3dnYUdGemFGUjVjR1VzSUhOcFoyNVVlWEJsS1NCN1hHNGdJSFpoY2lCd2NtbDJJRDBnY0dGeWMyVkxaWGx6S0d0bGVTbGNiaUFnYVdZZ0tIQnlhWFl1WTNWeWRtVXBJSHRjYmlBZ0lDQnBaaUFvYzJsbmJsUjVjR1VnSVQwOUlDZGxZMlJ6WVNjcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnbmQzSnZibWNnY0hKcGRtRjBaU0JyWlhrZ2RIbHdaU2NwWEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCbFkxTnBaMjRvYUdGemFDd2djSEpwZGlsY2JpQWdmU0JsYkhObElHbG1JQ2h3Y21sMkxuUjVjR1VnUFQwOUlDZGtjMkVuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1J6WVZOcFoyNG9hR0Z6YUN3Z2NISnBkaXdnYUdGemFGUjVjR1VwWEc0Z0lDQWdhV1lnS0hOcFoyNVVlWEJsSUNFOVBTQW5aSE5oSnlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkM2NtOXVaeUJ3Y21sMllYUmxJR3RsZVNCMGVYQmxKeWxjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhV1lnS0hOcFoyNVVlWEJsSUNFOVBTQW5jbk5oSnlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkM2NtOXVaeUJ3Y21sMllYUmxJR3RsZVNCMGVYQmxKeWxjYmlBZ0lDQjlYRzRnSUgxY2JpQWdkbUZ5SUd4bGJpQTlJSEJ5YVhZdWJXOWtkV3gxY3k1aWVYUmxUR1Z1WjNSb0tDbGNiaUFnZG1GeUlIQmhaQ0E5SUZzZ01Dd2dNU0JkWEc0Z0lIZG9hV3hsSUNob1lYTm9MbXhsYm1kMGFDQXJJSEJoWkM1c1pXNW5kR2dnS3lBeElEd2diR1Z1S1NCN1hHNGdJQ0FnY0dGa0xuQjFjMmdvTUhobVppbGNiaUFnZlZ4dUlDQndZV1F1Y0hWemFDZ3dlREF3S1Z4dUlDQjJZWElnYVNBOUlDMHhYRzRnSUhkb2FXeGxJQ2dySzJrZ1BDQm9ZWE5vTG14bGJtZDBhQ2tnZTF4dUlDQWdJSEJoWkM1d2RYTm9LR2hoYzJoYmFWMHBYRzRnSUgxY2JseHVJQ0IyWVhJZ2IzVjBJRDBnWTNKMEtIQmhaQ3dnY0hKcGRpbGNiaUFnY21WMGRYSnVJRzkxZEZ4dWZWeHVablZ1WTNScGIyNGdaV05UYVdkdUlDaG9ZWE5vTENCd2NtbDJLU0I3WEc0Z0lIWmhjaUJqZFhKMlpVbGtJRDBnWTNWeWRtVnpXM0J5YVhZdVkzVnlkbVV1YW05cGJpZ25MaWNwWFZ4dUlDQnBaaUFvSVdOMWNuWmxTV1FwWEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZDFibXR1YjNkdUlHTjFjblpsSUNjZ0t5QndjbWwyTG1OMWNuWmxMbXB2YVc0b0p5NG5LU2xjYmx4dUlDQjJZWElnWTNWeWRtVWdQU0J1WlhjZ1pXeHNhWEIwYVdNdVpXTW9ZM1Z5ZG1WSlpDbGNibHh1SUNCMllYSWdhMlY1SUQwZ1kzVnlkbVV1WjJWdVMyVjVVR0ZwY2lncFhHNGdJR3RsZVM1ZmFXMXdiM0owVUhKcGRtRjBaU2h3Y21sMkxuQnlhWFpoZEdWTFpYa3BYRzRnSUhaaGNpQnZkWFFnUFNCclpYa3VjMmxuYmlob1lYTm9LVnh1SUNCeVpYUjFjbTRnYm1WM0lFSjFabVpsY2lodmRYUXVkRzlFUlZJb0tTbGNibjFjYm1aMWJtTjBhVzl1SUdSellWTnBaMjRnS0doaGMyZ3NJSEJ5YVhZc0lHRnNaMjhwSUh0Y2JpQWdkbUZ5SUhnZ1BTQndjbWwyTG5CaGNtRnRjeTV3Y21sMlgydGxlVnh1SUNCMllYSWdjQ0E5SUhCeWFYWXVjR0Z5WVcxekxuQmNiaUFnZG1GeUlIRWdQU0J3Y21sMkxuQmhjbUZ0Y3k1eFhHNGdJSFpoY2lCdGIyNTBjU0E5SUVKT0xtMXZiblFvY1NsY2JpQWdkbUZ5SUdjZ1BTQndjbWwyTG5CaGNtRnRjeTVuWEc0Z0lIWmhjaUJ5SUQwZ2JtVjNJRUpPS0RBcFhHNGdJSFpoY2lCclhHNGdJSFpoY2lCSUlEMGdZbWwwY3pKcGJuUW9hR0Z6YUN3Z2NTa3ViVzlrS0hFcFhHNGdJSFpoY2lCeklEMGdabUZzYzJWY2JpQWdkbUZ5SUd0MklEMGdaMlYwUzJWNUtIZ3NJSEVzSUdoaGMyZ3NJR0ZzWjI4cFhHNGdJSGRvYVd4bElDaHpJRDA5UFNCbVlXeHpaU2tnZTF4dUlDQWdJR3NnUFNCdFlXdGxTMlY1S0hFc0lHdDJMQ0JoYkdkdktWeHVJQ0FnSUhJZ1BTQnRZV3RsVWlobkxDQnJMQ0J3TENCeEtWeHVJQ0FnSUhNZ1BTQnJMbWx1ZG0wb2NTa3VhVzExYkNoSUxtRmtaQ2g0TG0xMWJDaHlLU2twTG0xdlpDaHhLVnh1SUNBZ0lHbG1JQ2doY3k1amJYQnVLREFwS1NCN1hHNGdJQ0FnSUNCeklEMGdabUZzYzJWY2JpQWdJQ0FnSUhJZ1BTQnVaWGNnUWs0b01DbGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhSdlJFVlNLSElzSUhNcFhHNTlYRzVtZFc1amRHbHZiaUIwYjBSRlVpQW9jaXdnY3lrZ2UxeHVJQ0J5SUQwZ2NpNTBiMEZ5Y21GNUtDbGNiaUFnY3lBOUlITXVkRzlCY25KaGVTZ3BYRzVjYmlBZ0x5OGdVR0ZrSUhaaGJIVmxjMXh1SUNCcFppQW9jbHN3WFNBbUlEQjRPREFwWEc0Z0lDQWdjaUE5SUZzZ01DQmRMbU52Ym1OaGRDaHlLVnh1SUNBdkx5QlFZV1FnZG1Gc2RXVnpYRzRnSUdsbUlDaHpXekJkSUNZZ01IZzRNQ2xjYmlBZ0lDQnpJRDBnV3pCZExtTnZibU5oZENoektWeHVYRzRnSUhaaGNpQjBiM1JoYkNBOUlISXViR1Z1WjNSb0lDc2djeTVzWlc1bmRHZ2dLeUEwWEc0Z0lIWmhjaUJ5WlhNZ1BTQmJJREI0TXpBc0lIUnZkR0ZzTENBd2VEQXlMQ0J5TG14bGJtZDBhQ0JkWEc0Z0lISmxjeUE5SUhKbGN5NWpiMjVqWVhRb2Npd2dXeUF3ZURBeUxDQnpMbXhsYm1kMGFDQmRMQ0J6S1Z4dUlDQnlaWFIxY200Z2JtVjNJRUoxWm1abGNpaHlaWE1wWEc1OVhHNXRiMlIxYkdVdVpYaHdiM0owY3k1blpYUkxaWGtnUFNCblpYUkxaWGxjYm1aMWJtTjBhVzl1SUdkbGRFdGxlU0FvZUN3Z2NTd2dhR0Z6YUN3Z1lXeG5ieWtnZTF4dUlDQjRJRDBnYm1WM0lFSjFabVpsY2loNExuUnZRWEp5WVhrb0tTbGNiaUFnYVdZZ0tIZ3ViR1Z1WjNSb0lEd2djUzVpZVhSbFRHVnVaM1JvS0NrcElIdGNiaUFnSUNCMllYSWdlbVZ5YjNNZ1BTQnVaWGNnUW5WbVptVnlLSEV1WW5sMFpVeGxibWQwYUNncElDMGdlQzVzWlc1bmRHZ3BYRzRnSUNBZ2VtVnliM011Wm1sc2JDZ3dLVnh1SUNBZ0lIZ2dQU0JDZFdabVpYSXVZMjl1WTJGMEtGdDZaWEp2Y3l3Z2VGMHBYRzRnSUgxY2JpQWdkbUZ5SUdoc1pXNGdQU0JvWVhOb0xteGxibWQwYUZ4dUlDQjJZWElnYUdKcGRITWdQU0JpYVhSek1tOWpkR1YwY3lob1lYTm9MQ0J4S1Z4dUlDQjJZWElnZGlBOUlHNWxkeUJDZFdabVpYSW9hR3hsYmlsY2JpQWdkaTVtYVd4c0tERXBYRzRnSUhaaGNpQnJJRDBnYm1WM0lFSjFabVpsY2lob2JHVnVLVnh1SUNCckxtWnBiR3dvTUNsY2JpQWdheUE5SUdOeVpXRjBaVWh0WVdNb1lXeG5ieXdnYXlsY2JpQWdJQ0F1ZFhCa1lYUmxLSFlwWEc0Z0lDQWdMblZ3WkdGMFpTaHVaWGNnUW5WbVptVnlLRnN3WFNrcFhHNGdJQ0FnTG5Wd1pHRjBaU2g0S1Z4dUlDQWdJQzUxY0dSaGRHVW9hR0pwZEhNcFhHNGdJQ0FnTG1ScFoyVnpkQ2dwWEc0Z0lIWWdQU0JqY21WaGRHVkliV0ZqS0dGc1oyOHNJR3NwWEc0Z0lDQWdMblZ3WkdGMFpTaDJLVnh1SUNBZ0lDNWthV2RsYzNRb0tWeHVJQ0JySUQwZ1kzSmxZWFJsU0cxaFl5aGhiR2R2TENCcktWeHVJQ0FnSUM1MWNHUmhkR1VvZGlsY2JpQWdJQ0F1ZFhCa1lYUmxLRzVsZHlCQ2RXWm1aWElvV3pGZEtTbGNiaUFnSUNBdWRYQmtZWFJsS0hncFhHNGdJQ0FnTG5Wd1pHRjBaU2hvWW1sMGN5bGNiaUFnSUNBdVpHbG5aWE4wS0NsY2JpQWdkaUE5SUdOeVpXRjBaVWh0WVdNb1lXeG5ieXdnYXlsY2JpQWdJQ0F1ZFhCa1lYUmxLSFlwWEc0Z0lDQWdMbVJwWjJWemRDZ3BYRzRnSUhKbGRIVnliaUI3WEc0Z0lDQWdhem9nYXl4Y2JpQWdJQ0IyT2lCMlhHNGdJSDFjYm4xY2JtWjFibU4wYVc5dUlHSnBkSE15YVc1MElDaHZZbWwwY3l3Z2NTa2dlMXh1SUNCMllYSWdZbWwwY3lBOUlHNWxkeUJDVGlodlltbDBjeWxjYmlBZ2RtRnlJSE5vYVdaMElEMGdLRzlpYVhSekxteGxibWQwYUNBOFBDQXpLU0F0SUhFdVltbDBUR1Z1WjNSb0tDbGNiaUFnYVdZZ0tITm9hV1owSUQ0Z01Da2dlMXh1SUNBZ0lHSnBkSE11YVhOb2NtNG9jMmhwWm5RcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUdKcGRITmNibjFjYm1aMWJtTjBhVzl1SUdKcGRITXliMk4wWlhSeklDaGlhWFJ6TENCeEtTQjdYRzRnSUdKcGRITWdQU0JpYVhSek1tbHVkQ2hpYVhSekxDQnhLVnh1SUNCaWFYUnpJRDBnWW1sMGN5NXRiMlFvY1NsY2JpQWdkbUZ5SUc5MWRDQTlJRzVsZHlCQ2RXWm1aWElvWW1sMGN5NTBiMEZ5Y21GNUtDa3BYRzRnSUdsbUlDaHZkWFF1YkdWdVozUm9JRHdnY1M1aWVYUmxUR1Z1WjNSb0tDa3BJSHRjYmlBZ0lDQjJZWElnZW1WeWIzTWdQU0J1WlhjZ1FuVm1abVZ5S0hFdVlubDBaVXhsYm1kMGFDZ3BJQzBnYjNWMExteGxibWQwYUNsY2JpQWdJQ0I2WlhKdmN5NW1hV3hzS0RBcFhHNGdJQ0FnYjNWMElEMGdRblZtWm1WeUxtTnZibU5oZENoYmVtVnliM01zSUc5MWRGMHBYRzRnSUgxY2JpQWdjbVYwZFhKdUlHOTFkRnh1ZlZ4dWJXOWtkV3hsTG1WNGNHOXlkSE11YldGclpVdGxlU0E5SUcxaGEyVkxaWGxjYm1aMWJtTjBhVzl1SUcxaGEyVkxaWGtnS0hFc0lHdDJMQ0JoYkdkdktTQjdYRzRnSUhaaGNpQjBYRzRnSUhaaGNpQnJYRzRnSUhkb2FXeGxJQ2gwY25WbEtTQjdYRzRnSUNBZ2RDQTlJRzVsZHlCQ2RXWm1aWElvSnljcFhHNGdJQ0FnZDJocGJHVWdLSFF1YkdWdVozUm9JQ29nT0NBOElIRXVZbWwwVEdWdVozUm9LQ2twSUh0Y2JpQWdJQ0FnSUd0MkxuWWdQU0JqY21WaGRHVkliV0ZqS0dGc1oyOHNJR3QyTG1zcFhHNGdJQ0FnSUNBZ0lDNTFjR1JoZEdVb2EzWXVkaWxjYmlBZ0lDQWdJQ0FnTG1ScFoyVnpkQ2dwWEc0Z0lDQWdJQ0IwSUQwZ1FuVm1abVZ5TG1OdmJtTmhkQ2hiZEN3Z2EzWXVkbDBwWEc0Z0lDQWdmVnh1SUNBZ0lHc2dQU0JpYVhSek1tbHVkQ2gwTENCeEtWeHVJQ0FnSUd0Mkxtc2dQU0FnWTNKbFlYUmxTRzFoWXloaGJHZHZMQ0JyZGk1cktWeHVJQ0FnSUNBZ0lDQXVkWEJrWVhSbEtHdDJMbllwWEc0Z0lDQWdJQ0FnSUM1MWNHUmhkR1VvYm1WM0lFSjFabVpsY2loYk1GMHBLVnh1SUNBZ0lDQWdJQ0F1WkdsblpYTjBLQ2xjYmlBZ0lDQnJkaTUySUQwZ1kzSmxZWFJsU0cxaFl5aGhiR2R2TENCcmRpNXJLVnh1SUNBZ0lDQWdJQ0F1ZFhCa1lYUmxLR3QyTG5ZcFhHNGdJQ0FnSUNBZ0lDNWthV2RsYzNRb0tWeHVJQ0FnSUdsbUlDaHJMbU50Y0NoeEtTQTlQVDBnTFRFcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCclhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1bWRXNWpkR2x2YmlCdFlXdGxVaUFvWnl3Z2F5d2djQ3dnY1NrZ2UxeHVJQ0J5WlhSMWNtNGdaeTUwYjFKbFpDaENUaTV0YjI1MEtIQXBLUzV5WldSUWIzY29heWt1Wm5KdmJWSmxaQ2dwTG0xdlpDaHhLVnh1ZlZ4dUlsMTkiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpO1xudmFyIGFlc2lkID0gcmVxdWlyZSgnLi9hZXNpZC5qc29uJyk7XG52YXIgZml4UHJvYyA9IHJlcXVpcmUoJy4vZml4UHJvYycpO1xudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpO1xudmFyIGNvbXBhdCA9IHJlcXVpcmUoJ3Bia2RmMicpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUtleXM7XG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyhidWZmZXIpIHtcbiAgdmFyIHBhc3N3b3JkO1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZTtcbiAgICBidWZmZXIgPSBidWZmZXIua2V5O1xuICB9XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZCk7XG5cbiAgdmFyIHR5cGUgPSBzdHJpcHBlZC50YWc7XG4gIHZhciBkYXRhID0gc3RyaXBwZWQuZGF0YTtcbiAgdmFyIHN1YnR5cGUsbmRhdGE7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpO1xuICAgICAgc3dpdGNoKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJyk7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogIG5kYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyAgc3VidHlwZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArICB0eXBlKTtcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgLy9mYWxsaW5nIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpO1xuICAgICAgc3dpdGNoKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJyk7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VydmU6IG5kYXRhLmFsZ29yaXRobS5jdXJ2ZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpLnByaXZhdGVLZXlcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgIHN1YnR5cGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyAgdHlwZSk7XG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKTtcbiAgICBjYXNlICdEU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgIHBhcmFtczogYXNuMS5EU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH07XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH07XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyAgdHlwZSk7XG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZTtcbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdDtcbiAgdmFyIGl0ZXJzID0gcGFyc2VJbnQoZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLml0ZXJzLnRvU3RyaW5nKCksIDEwKTtcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV07XG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2O1xuICB2YXIgY2lwaGVyVGV4dCA9IGRhdGEuc3ViamVjdFByaXZhdGVLZXk7XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKS84O1xuICB2YXIga2V5ID0gY29tcGF0LnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJzLCBrZXlsZW4pO1xuICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KGFsZ28sIGtleSwgaXYpO1xuICB2YXIgb3V0ID0gW107XG4gIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpO1xuICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxemFXZHVMMjV2WkdWZmJXOWtkV3hsY3k5d1lYSnpaUzFoYzI0eEwybHVaR1Y0TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkluWmhjaUJoYzI0eElEMGdjbVZ4ZFdseVpTZ25MaTloYzI0eEp5azdYRzUyWVhJZ1lXVnphV1FnUFNCeVpYRjFhWEpsS0NjdUwyRmxjMmxrTG1wemIyNG5LVHRjYm5aaGNpQm1hWGhRY205aklEMGdjbVZ4ZFdseVpTZ25MaTltYVhoUWNtOWpKeWs3WEc1MllYSWdZMmx3YUdWeWN5QTlJSEpsY1hWcGNtVW9KMkp5YjNkelpYSnBabmt0WVdWekp5azdYRzUyWVhJZ1kyOXRjR0YwSUQwZ2NtVnhkV2x5WlNnbmNHSnJaR1l5SnlrN1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIQmhjbk5sUzJWNWN6dGNibHh1Wm5WdVkzUnBiMjRnY0dGeWMyVkxaWGx6S0dKMVptWmxjaWtnZTF4dUlDQjJZWElnY0dGemMzZHZjbVE3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdZblZtWm1WeUlEMDlQU0FuYjJKcVpXTjBKeUFtSmlBaFFuVm1abVZ5TG1selFuVm1abVZ5S0dKMVptWmxjaWtwSUh0Y2JpQWdJQ0J3WVhOemQyOXlaQ0E5SUdKMVptWmxjaTV3WVhOemNHaHlZWE5sTzF4dUlDQWdJR0oxWm1abGNpQTlJR0oxWm1abGNpNXJaWGs3WEc0Z0lIMWNiaUFnYVdZZ0tIUjVjR1Z2WmlCaWRXWm1aWElnUFQwOUlDZHpkSEpwYm1jbktTQjdYRzRnSUNBZ1luVm1abVZ5SUQwZ2JtVjNJRUoxWm1abGNpaGlkV1ptWlhJcE8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhOMGNtbHdjR1ZrSUQwZ1ptbDRVSEp2WXloaWRXWm1aWElzSUhCaGMzTjNiM0prS1R0Y2JseHVJQ0IyWVhJZ2RIbHdaU0E5SUhOMGNtbHdjR1ZrTG5SaFp6dGNiaUFnZG1GeUlHUmhkR0VnUFNCemRISnBjSEJsWkM1a1lYUmhPMXh1SUNCMllYSWdjM1ZpZEhsd1pTeHVaR0YwWVR0Y2JpQWdjM2RwZEdOb0lDaDBlWEJsS1NCN1hHNGdJQ0FnWTJGelpTQW5VRlZDVEVsRElFdEZXU2M2WEc0Z0lDQWdJQ0J1WkdGMFlTQTlJR0Z6YmpFdVVIVmliR2xqUzJWNUxtUmxZMjlrWlNoa1lYUmhMQ0FuWkdWeUp5azdYRzRnSUNBZ0lDQnpkV0owZVhCbElEMGdibVJoZEdFdVlXeG5iM0pwZEdodExtRnNaMjl5YVhSb2JTNXFiMmx1S0NjdUp5azdYRzRnSUNBZ0lDQnpkMmwwWTJnb2MzVmlkSGx3WlNrZ2UxeHVJQ0FnSUNBZ0lDQmpZWE5sSUNjeExqSXVPRFF3TGpFeE16VTBPUzR4TGpFdU1TYzZYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR0Z6YmpFdVVsTkJVSFZpYkdsalMyVjVMbVJsWTI5a1pTaHVaR0YwWVM1emRXSnFaV04wVUhWaWJHbGpTMlY1TG1SaGRHRXNJQ2RrWlhJbktUdGNiaUFnSUNBZ0lDQWdZMkZ6WlNBbk1TNHlMamcwTUM0eE1EQTBOUzR5TGpFbk9seHVJQ0FnSUNBZ0lDQnVaR0YwWVM1emRXSnFaV04wVUhKcGRtRjBaVXRsZVNBOUlHNWtZWFJoTG5OMVltcGxZM1JRZFdKc2FXTkxaWGs3WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFI1Y0dVNklDZGxZeWNzWEc0Z0lDQWdJQ0FnSUNBZ0lDQmtZWFJoT2lBZ2JtUmhkR0ZjYmlBZ0lDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ0lDQmpZWE5sSUNjeExqSXVPRFF3TGpFd01EUXdMalF1TVNjNlhHNGdJQ0FnSUNBZ0lDQWdibVJoZEdFdVlXeG5iM0pwZEdodExuQmhjbUZ0Y3k1d2RXSmZhMlY1SUQwZ1lYTnVNUzVFVTBGd1lYSmhiUzVrWldOdlpHVW9ibVJoZEdFdWMzVmlhbVZqZEZCMVlteHBZMHRsZVM1a1lYUmhMQ0FuWkdWeUp5azdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUjVjR1U2SUNka2MyRW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHRjBZVG9nYm1SaGRHRXVZV3huYjNKcGRHaHRMbkJoY21GdGMxeHVJQ0FnSUNBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0FnSUdSbFptRjFiSFE2SUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1cmJtOTNiaUJyWlhrZ2FXUWdKeUFySUNCemRXSjBlWEJsS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1cmJtOTNiaUJyWlhrZ2RIbHdaU0FuSUNzZ0lIUjVjR1VwTzF4dUlDQWdJR05oYzJVZ0owVk9RMUpaVUZSRlJDQlFVa2xXUVZSRklFdEZXU2M2WEc0Z0lDQWdJQ0JrWVhSaElEMGdZWE51TVM1RmJtTnllWEIwWldSUWNtbDJZWFJsUzJWNUxtUmxZMjlrWlNoa1lYUmhMQ0FuWkdWeUp5azdYRzRnSUNBZ0lDQmtZWFJoSUQwZ1pHVmpjbmx3ZENoa1lYUmhMQ0J3WVhOemQyOXlaQ2s3WEc0Z0lDQWdJQ0F2TDJaaGJHeHBibWNnZEdoeWIzVm5hRnh1SUNBZ0lHTmhjMlVnSjFCU1NWWkJWRVVnUzBWWkp6cGNiaUFnSUNBZ0lHNWtZWFJoSUQwZ1lYTnVNUzVRY21sMllYUmxTMlY1TG1SbFkyOWtaU2hrWVhSaExDQW5aR1Z5SnlrN1hHNGdJQ0FnSUNCemRXSjBlWEJsSUQwZ2JtUmhkR0V1WVd4bmIzSnBkR2h0TG1Gc1oyOXlhWFJvYlM1cWIybHVLQ2N1SnlrN1hHNGdJQ0FnSUNCemQybDBZMmdvYzNWaWRIbHdaU2tnZTF4dUlDQWdJQ0FnSUNCallYTmxJQ2N4TGpJdU9EUXdMakV4TXpVME9TNHhMakV1TVNjNlhHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHRnpiakV1VWxOQlVISnBkbUYwWlV0bGVTNWtaV052WkdVb2JtUmhkR0V1YzNWaWFtVmpkRkJ5YVhaaGRHVkxaWGtzSUNka1pYSW5LVHRjYmlBZ0lDQWdJQ0FnWTJGelpTQW5NUzR5TGpnME1DNHhNREEwTlM0eUxqRW5PbHh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUI3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpkWEoyWlRvZ2JtUmhkR0V1WVd4bmIzSnBkR2h0TG1OMWNuWmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NISnBkbUYwWlV0bGVUb2dZWE51TVM1RlExQnlhWFpoZEdWTFpYa3VaR1ZqYjJSbEtHNWtZWFJoTG5OMVltcGxZM1JRY21sMllYUmxTMlY1TENBblpHVnlKeWt1Y0hKcGRtRjBaVXRsZVZ4dUlDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJR05oYzJVZ0p6RXVNaTQ0TkRBdU1UQXdOREF1TkM0eEp6cGNiaUFnSUNBZ0lDQWdJQ0J1WkdGMFlTNWhiR2R2Y21sMGFHMHVjR0Z5WVcxekxuQnlhWFpmYTJWNUlEMGdZWE51TVM1RVUwRndZWEpoYlM1a1pXTnZaR1VvYm1SaGRHRXVjM1ZpYW1WamRGQnlhWFpoZEdWTFpYa3NJQ2RrWlhJbktUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVG9nSjJSellTY3NYRzRnSUNBZ0lDQWdJQ0FnSUNCd1lYSmhiWE02SUc1a1lYUmhMbUZzWjI5eWFYUm9iUzV3WVhKaGJYTmNiaUFnSUNBZ0lDQWdJQ0I5TzF4dUlDQWdJQ0FnSUNCa1pXWmhkV3gwT2lCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjNWdWEyNXZkMjRnYTJWNUlHbGtJQ2NnS3lBZ2MzVmlkSGx3WlNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjNWdWEyNXZkMjRnYTJWNUlIUjVjR1VnSnlBcklDQjBlWEJsS1R0Y2JpQWdJQ0JqWVhObElDZFNVMEVnVUZWQ1RFbERJRXRGV1NjNlhHNGdJQ0FnSUNCeVpYUjFjbTRnWVhOdU1TNVNVMEZRZFdKc2FXTkxaWGt1WkdWamIyUmxLR1JoZEdFc0lDZGtaWEluS1R0Y2JpQWdJQ0JqWVhObElDZFNVMEVnVUZKSlZrRlVSU0JMUlZrbk9seHVJQ0FnSUNBZ2NtVjBkWEp1SUdGemJqRXVVbE5CVUhKcGRtRjBaVXRsZVM1a1pXTnZaR1VvWkdGMFlTd2dKMlJsY2ljcE8xeHVJQ0FnSUdOaGMyVWdKMFJUUVNCUVVrbFdRVlJGSUV0RldTYzZYRzRnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lBblpITmhKeXhjYmlBZ0lDQWdJQ0FnY0dGeVlXMXpPaUJoYzI0eExrUlRRVkJ5YVhaaGRHVkxaWGt1WkdWamIyUmxLR1JoZEdFc0lDZGtaWEluS1Z4dUlDQWdJQ0FnZlR0Y2JpQWdJQ0JqWVhObElDZEZReUJRVWtsV1FWUkZJRXRGV1NjNlhHNGdJQ0FnSUNCa1lYUmhJRDBnWVhOdU1TNUZRMUJ5YVhaaGRHVkxaWGt1WkdWamIyUmxLR1JoZEdFc0lDZGtaWEluS1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUI3WEc0Z0lDQWdJQ0FnSUdOMWNuWmxPaUJrWVhSaExuQmhjbUZ0WlhSbGNuTXVkbUZzZFdVc1hHNGdJQ0FnSUNBZ0lIQnlhWFpoZEdWTFpYazZJR1JoZEdFdWNISnBkbUYwWlV0bGVWeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNCa1pXWmhkV3gwT2lCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjNWdWEyNXZkMjRnYTJWNUlIUjVjR1VnSnlBcklDQjBlWEJsS1R0Y2JpQWdmVnh1ZlZ4dWNHRnljMlZMWlhsekxuTnBaMjVoZEhWeVpTQTlJR0Z6YmpFdWMybG5ibUYwZFhKbE8xeHVablZ1WTNScGIyNGdaR1ZqY25sd2RDaGtZWFJoTENCd1lYTnpkMjl5WkNrZ2UxeHVJQ0IyWVhJZ2MyRnNkQ0E5SUdSaGRHRXVZV3huYjNKcGRHaHRMbVJsWTNKNWNIUXVhMlJsTG10a1pYQmhjbUZ0Y3k1ellXeDBPMXh1SUNCMllYSWdhWFJsY25NZ1BTQndZWEp6WlVsdWRDaGtZWFJoTG1Gc1oyOXlhWFJvYlM1a1pXTnllWEIwTG10a1pTNXJaR1Z3WVhKaGJYTXVhWFJsY25NdWRHOVRkSEpwYm1jb0tTd2dNVEFwTzF4dUlDQjJZWElnWVd4bmJ5QTlJR0ZsYzJsa1cyUmhkR0V1WVd4bmIzSnBkR2h0TG1SbFkzSjVjSFF1WTJsd2FHVnlMbUZzWjI4dWFtOXBiaWduTGljcFhUdGNiaUFnZG1GeUlHbDJJRDBnWkdGMFlTNWhiR2R2Y21sMGFHMHVaR1ZqY25sd2RDNWphWEJvWlhJdWFYWTdYRzRnSUhaaGNpQmphWEJvWlhKVVpYaDBJRDBnWkdGMFlTNXpkV0pxWldOMFVISnBkbUYwWlV0bGVUdGNiaUFnZG1GeUlHdGxlV3hsYmlBOUlIQmhjbk5sU1c1MEtHRnNaMjh1YzNCc2FYUW9KeTBuS1ZzeFhTd2dNVEFwTHpnN1hHNGdJSFpoY2lCclpYa2dQU0JqYjIxd1lYUXVjR0pyWkdZeVUzbHVZeWh3WVhOemQyOXlaQ3dnYzJGc2RDd2dhWFJsY25Nc0lHdGxlV3hsYmlrN1hHNGdJSFpoY2lCamFYQm9aWElnUFNCamFYQm9aWEp6TG1OeVpXRjBaVVJsWTJsd2FHVnlhWFlvWVd4bmJ5d2dhMlY1TENCcGRpazdYRzRnSUhaaGNpQnZkWFFnUFNCYlhUdGNiaUFnYjNWMExuQjFjMmdvWTJsd2FHVnlMblZ3WkdGMFpTaGphWEJvWlhKVVpYaDBLU2s3WEc0Z0lHOTFkQzV3ZFhOb0tHTnBjR2hsY2k1bWFXNWhiQ2dwS1R0Y2JpQWdjbVYwZFhKdUlFSjFabVpsY2k1amIyNWpZWFFvYjNWMEtUdGNibjFjYmlKZGZRPT0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciBNQVhfQUxMT0MgPSBNYXRoLnBvdygyLCAzMCkgLSAxIC8vIGRlZmF1bHQgaW4gaW9qc1xuXG5leHBvcnRzLnBia2RmMiA9IHBia2RmMlxuZnVuY3Rpb24gcGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbGxiYWNrIHByb3ZpZGVkIHRvIHBia2RmMicpXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gcGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KVxuICB9KVxufVxuXG5leHBvcnRzLnBia2RmMlN5bmMgPSBwYmtkZjJTeW5jXG5mdW5jdGlvbiBwYmtkZjJTeW5jIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpIHtcbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpdGVyYXRpb25zIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5bGVuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChrZXlsZW4gPCAwIHx8IGtleWxlbiA+IE1BWF9BTExPQykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBrZXkgbGVuZ3RoJylcbiAgfVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgJ2JpbmFyeScpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gbmV3IEJ1ZmZlcihzYWx0LCAnYmluYXJ5JylcblxuICB2YXIgaExlblxuICB2YXIgbCA9IDFcbiAgdmFyIERLID0gbmV3IEJ1ZmZlcihrZXlsZW4pXG4gIHZhciBibG9jazEgPSBuZXcgQnVmZmVyKHNhbHQubGVuZ3RoICsgNClcbiAgc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIHJcbiAgdmFyIFRcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICBibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcbiAgICB2YXIgVSA9IGNyZWF0ZUhtYWMoZGlnZXN0LCBwYXNzd29yZCkudXBkYXRlKGJsb2NrMSkuZGlnZXN0KClcblxuICAgIGlmICghaExlbikge1xuICAgICAgaExlbiA9IFUubGVuZ3RoXG4gICAgICBUID0gbmV3IEJ1ZmZlcihoTGVuKVxuICAgICAgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKVxuICAgICAgciA9IGtleWxlbiAtIChsIC0gMSkgKiBoTGVuXG4gICAgfVxuXG4gICAgVS5jb3B5KFQsIDAsIDAsIGhMZW4pXG5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgVSA9IGNyZWF0ZUhtYWMoZGlnZXN0LCBwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpXG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSB7XG4gICAgICAgIFRba10gXj0gVVtrXVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZXN0UG9zID0gKGkgLSAxKSAqIGhMZW5cbiAgICB2YXIgbGVuID0gKGkgPT09IGwgPyByIDogaExlbilcbiAgICBULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcbiAgfVxuXG4gIHJldHVybiBES1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNHSnJaR1l5TDJKeWIzZHpaWEl1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lkbUZ5SUdOeVpXRjBaVWh0WVdNZ1BTQnlaWEYxYVhKbEtDZGpjbVZoZEdVdGFHMWhZeWNwWEc1MllYSWdUVUZZWDBGTVRFOURJRDBnVFdGMGFDNXdiM2NvTWl3Z016QXBJQzBnTVNBdkx5QmtaV1poZFd4MElHbHVJR2x2YW5OY2JseHVaWGh3YjNKMGN5NXdZbXRrWmpJZ1BTQndZbXRrWmpKY2JtWjFibU4wYVc5dUlIQmlhMlJtTWlBb2NHRnpjM2R2Y21Rc0lITmhiSFFzSUdsMFpYSmhkR2x2Ym5Nc0lHdGxlV3hsYml3Z1pHbG5aWE4wTENCallXeHNZbUZqYXlrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUdScFoyVnpkQ0E5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lHTmhiR3hpWVdOcklEMGdaR2xuWlhOMFhHNGdJQ0FnWkdsblpYTjBJRDBnZFc1a1pXWnBibVZrWEc0Z0lIMWNibHh1SUNCcFppQW9kSGx3Wlc5bUlHTmhiR3hpWVdOcklDRTlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RPYnlCallXeHNZbUZqYXlCd2NtOTJhV1JsWkNCMGJ5QndZbXRrWmpJbktWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhKbGMzVnNkQ0E5SUhCaWEyUm1NbE41Ym1Nb2NHRnpjM2R2Y21Rc0lITmhiSFFzSUdsMFpYSmhkR2x2Ym5Nc0lHdGxlV3hsYml3Z1pHbG5aWE4wS1Z4dUlDQnpaWFJVYVcxbGIzVjBLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0JqWVd4c1ltRmpheWgxYm1SbFptbHVaV1FzSUhKbGMzVnNkQ2xjYmlBZ2ZTbGNibjFjYmx4dVpYaHdiM0owY3k1d1ltdGtaakpUZVc1aklEMGdjR0pyWkdZeVUzbHVZMXh1Wm5WdVkzUnBiMjRnY0dKclpHWXlVM2x1WXlBb2NHRnpjM2R2Y21Rc0lITmhiSFFzSUdsMFpYSmhkR2x2Ym5Nc0lHdGxlV3hsYml3Z1pHbG5aWE4wS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnYVhSbGNtRjBhVzl1Y3lBaFBUMGdKMjUxYldKbGNpY3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RKZEdWeVlYUnBiMjV6SUc1dmRDQmhJRzUxYldKbGNpY3BYRzRnSUgxY2JseHVJQ0JwWmlBb2FYUmxjbUYwYVc5dWN5QThJREFwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkQ1lXUWdhWFJsY21GMGFXOXVjeWNwWEc0Z0lIMWNibHh1SUNCcFppQW9kSGx3Wlc5bUlHdGxlV3hsYmlBaFBUMGdKMjUxYldKbGNpY3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RMWlhrZ2JHVnVaM1JvSUc1dmRDQmhJRzUxYldKbGNpY3BYRzRnSUgxY2JseHVJQ0JwWmlBb2EyVjViR1Z1SUR3Z01DQjhmQ0JyWlhsc1pXNGdQaUJOUVZoZlFVeE1UME1wSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkQ1lXUWdhMlY1SUd4bGJtZDBhQ2NwWEc0Z0lIMWNibHh1SUNCa2FXZGxjM1FnUFNCa2FXZGxjM1FnZkh3Z0ozTm9ZVEVuWEc1Y2JpQWdhV1lnS0NGQ2RXWm1aWEl1YVhOQ2RXWm1aWElvY0dGemMzZHZjbVFwS1NCd1lYTnpkMjl5WkNBOUlHNWxkeUJDZFdabVpYSW9jR0Z6YzNkdmNtUXNJQ2RpYVc1aGNua25LVnh1SUNCcFppQW9JVUoxWm1abGNpNXBjMEoxWm1abGNpaHpZV3gwS1NrZ2MyRnNkQ0E5SUc1bGR5QkNkV1ptWlhJb2MyRnNkQ3dnSjJKcGJtRnllU2NwWEc1Y2JpQWdkbUZ5SUdoTVpXNWNiaUFnZG1GeUlHd2dQU0F4WEc0Z0lIWmhjaUJFU3lBOUlHNWxkeUJDZFdabVpYSW9hMlY1YkdWdUtWeHVJQ0IyWVhJZ1lteHZZMnN4SUQwZ2JtVjNJRUoxWm1abGNpaHpZV3gwTG14bGJtZDBhQ0FySURRcFhHNGdJSE5oYkhRdVkyOXdlU2hpYkc5amF6RXNJREFzSURBc0lITmhiSFF1YkdWdVozUm9LVnh1WEc0Z0lIWmhjaUJ5WEc0Z0lIWmhjaUJVWEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SURFN0lHa2dQRDBnYkRzZ2FTc3JLU0I3WEc0Z0lDQWdZbXh2WTJzeExuZHlhWFJsVlVsdWRETXlRa1VvYVN3Z2MyRnNkQzVzWlc1bmRHZ3BYRzRnSUNBZ2RtRnlJRlVnUFNCamNtVmhkR1ZJYldGaktHUnBaMlZ6ZEN3Z2NHRnpjM2R2Y21RcExuVndaR0YwWlNoaWJHOWphekVwTG1ScFoyVnpkQ2dwWEc1Y2JpQWdJQ0JwWmlBb0lXaE1aVzRwSUh0Y2JpQWdJQ0FnSUdoTVpXNGdQU0JWTG14bGJtZDBhRnh1SUNBZ0lDQWdWQ0E5SUc1bGR5QkNkV1ptWlhJb2FFeGxiaWxjYmlBZ0lDQWdJR3dnUFNCTllYUm9MbU5sYVd3b2EyVjViR1Z1SUM4Z2FFeGxiaWxjYmlBZ0lDQWdJSElnUFNCclpYbHNaVzRnTFNBb2JDQXRJREVwSUNvZ2FFeGxibHh1SUNBZ0lIMWNibHh1SUNBZ0lGVXVZMjl3ZVNoVUxDQXdMQ0F3TENCb1RHVnVLVnh1WEc0Z0lDQWdabTl5SUNoMllYSWdhaUE5SURFN0lHb2dQQ0JwZEdWeVlYUnBiMjV6T3lCcUt5c3BJSHRjYmlBZ0lDQWdJRlVnUFNCamNtVmhkR1ZJYldGaktHUnBaMlZ6ZEN3Z2NHRnpjM2R2Y21RcExuVndaR0YwWlNoVktTNWthV2RsYzNRb0tWeHVYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnJJRDBnTURzZ2F5QThJR2hNWlc0N0lHc3JLeWtnZTF4dUlDQWdJQ0FnSUNCVVcydGRJRjQ5SUZWYmExMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNCMllYSWdaR1Z6ZEZCdmN5QTlJQ2hwSUMwZ01Ta2dLaUJvVEdWdVhHNGdJQ0FnZG1GeUlHeGxiaUE5SUNocElEMDlQU0JzSUQ4Z2NpQTZJR2hNWlc0cFhHNGdJQ0FnVkM1amIzQjVLRVJMTENCa1pYTjBVRzl6TENBd0xDQnNaVzRwWEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnUkV0Y2JuMWNiaUpkZlE9PSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvYnJvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG5cbnZhciBaRVJPUyA9IG5ldyBCdWZmZXIoMTI4KVxuWkVST1MuZmlsbCgwKVxuXG5mdW5jdGlvbiBIbWFjKGFsZywga2V5KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIH1cblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoa2V5KS5kaWdlc3QoKVxuXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbmluaGVyaXRzKEhtYWMsIFRyYW5zZm9ybSlcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhLCBlbmMpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSG1hYy5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuXG4gIHJldHVybiBjcmVhdGVIYXNoKHRoaXMuX2FsZykudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoZW5jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoYWxnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlkzSmxZWFJsTFdodFlXTXZZbkp2ZDNObGNpNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SW5kWE5sSUhOMGNtbGpkQ2M3WEc1MllYSWdZM0psWVhSbFNHRnphQ0E5SUhKbGNYVnBjbVVvSjJOeVpXRjBaUzFvWVhOb0wySnliM2R6WlhJbktUdGNiblpoY2lCcGJtaGxjbWwwY3lBOUlISmxjWFZwY21Vb0oybHVhR1Z5YVhSekp5bGNibHh1ZG1GeUlGUnlZVzV6Wm05eWJTQTlJSEpsY1hWcGNtVW9KM04wY21WaGJTY3BMbFJ5WVc1elptOXliVnh1WEc1MllYSWdXa1ZTVDFNZ1BTQnVaWGNnUW5WbVptVnlLREV5T0NsY2JscEZVazlUTG1acGJHd29NQ2xjYmx4dVpuVnVZM1JwYjI0Z1NHMWhZeWhoYkdjc0lHdGxlU2tnZTF4dUlDQlVjbUZ1YzJadmNtMHVZMkZzYkNoMGFHbHpLVnh1WEc0Z0lHbG1JQ2gwZVhCbGIyWWdhMlY1SUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lHdGxlU0E5SUc1bGR5QkNkV1ptWlhJb2EyVjVLVnh1SUNCOVhHNWNiaUFnZG1GeUlHSnNiMk5yYzJsNlpTQTlJQ2hoYkdjZ1BUMDlJQ2R6YUdFMU1USW5JSHg4SUdGc1p5QTlQVDBnSjNOb1lUTTROQ2NwSUQ4Z01USTRJRG9nTmpSY2JseHVJQ0IwYUdsekxsOWhiR2NnUFNCaGJHZGNiaUFnZEdocGN5NWZhMlY1SUQwZ2EyVjVYRzVjYmlBZ2FXWWdLR3RsZVM1c1pXNW5kR2dnUGlCaWJHOWphM05wZW1VcElIdGNiaUFnSUNCclpYa2dQU0JqY21WaGRHVklZWE5vS0dGc1p5a3VkWEJrWVhSbEtHdGxlU2t1WkdsblpYTjBLQ2xjYmx4dUlDQjlJR1ZzYzJVZ2FXWWdLR3RsZVM1c1pXNW5kR2dnUENCaWJHOWphM05wZW1VcElIdGNiaUFnSUNCclpYa2dQU0JDZFdabVpYSXVZMjl1WTJGMEtGdHJaWGtzSUZwRlVrOVRYU3dnWW14dlkydHphWHBsS1Z4dUlDQjlYRzVjYmlBZ2RtRnlJR2x3WVdRZ1BTQjBhR2x6TGw5cGNHRmtJRDBnYm1WM0lFSjFabVpsY2loaWJHOWphM05wZW1VcFhHNGdJSFpoY2lCdmNHRmtJRDBnZEdocGN5NWZiM0JoWkNBOUlHNWxkeUJDZFdabVpYSW9ZbXh2WTJ0emFYcGxLVnh1WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dZbXh2WTJ0emFYcGxPeUJwS3lzcElIdGNiaUFnSUNCcGNHRmtXMmxkSUQwZ2EyVjVXMmxkSUY0Z01IZ3pObHh1SUNBZ0lHOXdZV1JiYVYwZ1BTQnJaWGxiYVYwZ1hpQXdlRFZEWEc0Z0lIMWNibHh1SUNCMGFHbHpMbDlvWVhOb0lEMGdZM0psWVhSbFNHRnphQ2hoYkdjcExuVndaR0YwWlNocGNHRmtLVnh1ZlZ4dVhHNXBibWhsY21sMGN5aEliV0ZqTENCVWNtRnVjMlp2Y20wcFhHNWNia2h0WVdNdWNISnZkRzkwZVhCbExuVndaR0YwWlNBOUlHWjFibU4wYVc5dUlDaGtZWFJoTENCbGJtTXBJSHRjYmlBZ2RHaHBjeTVmYUdGemFDNTFjR1JoZEdVb1pHRjBZU3dnWlc1aktWeHVYRzRnSUhKbGRIVnliaUIwYUdselhHNTlYRzVjYmtodFlXTXVjSEp2ZEc5MGVYQmxMbDkwY21GdWMyWnZjbTBnUFNCbWRXNWpkR2x2YmlBb1pHRjBZU3dnWHl3Z2JtVjRkQ2tnZTF4dUlDQjBhR2x6TGw5b1lYTm9MblZ3WkdGMFpTaGtZWFJoS1Z4dVhHNGdJRzVsZUhRb0tWeHVmVnh1WEc1SWJXRmpMbkJ5YjNSdmRIbHdaUzVmWm14MWMyZ2dQU0JtZFc1amRHbHZiaUFvYm1WNGRDa2dlMXh1SUNCMGFHbHpMbkIxYzJnb2RHaHBjeTVrYVdkbGMzUW9LU2xjYmx4dUlDQnVaWGgwS0NsY2JuMWNibHh1U0cxaFl5NXdjbTkwYjNSNWNHVXVaR2xuWlhOMElEMGdablZ1WTNScGIyNGdLR1Z1WXlrZ2UxeHVJQ0IyWVhJZ2FDQTlJSFJvYVhNdVgyaGhjMmd1WkdsblpYTjBLQ2xjYmx4dUlDQnlaWFIxY200Z1kzSmxZWFJsU0dGemFDaDBhR2x6TGw5aGJHY3BMblZ3WkdGMFpTaDBhR2x6TGw5dmNHRmtLUzUxY0dSaGRHVW9hQ2t1WkdsblpYTjBLR1Z1WXlsY2JuMWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJqY21WaGRHVkliV0ZqS0dGc1p5d2dhMlY1S1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnU0cxaFl5aGhiR2NzSUd0bGVTbGNibjFjYmlKZGZRPT0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FwYXRpbC9wZW1zdHJpcFxudmFyIGZpbmRQcm9jID0gL1Byb2MtVHlwZTogNCxFTkNSWVBURURcXHI/XFxuREVLLUluZm86IEFFUy0oKD86MTI4KXwoPzoxOTIpfCg/OjI1NikpLUNCQywoWzAtOUEtSF0rKVxccj9cXG5cXHI/XFxuKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXHI/XFxuL207XG52YXIgc3RhcnRSZWdleCA9L14tLS0tLUJFR0lOICguKikgS0VZLS0tLS1cXHI/XFxuL207XG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICguKikgS0VZLS0tLS1cXHI/XFxuKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXHI/XFxuLS0tLS1FTkQgXFwxIEtFWS0tLS0tJC9tO1xudmFyIGV2cCA9IHJlcXVpcmUoJy4vRVZQX0J5dGVzVG9LZXknKTtcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9rZXksIHBhc3N3b3JkKSB7XG4gIHZhciBrZXkgPSBva2V5LnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYyk7XG4gIHZhciBkZWNyeXB0ZWQ7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2gyID0ga2V5Lm1hdGNoKGZ1bGxSZWdleCk7XG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3VpdGUgPSAnYWVzJyArIG1hdGNoWzFdO1xuICAgIHZhciBpdiA9IG5ldyBCdWZmZXIobWF0Y2hbMl0sICdoZXgnKTtcbiAgICB2YXIgY2lwaGVyVGV4dCA9IG5ldyBCdWZmZXIobWF0Y2hbM10ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKTtcbiAgICB2YXIgY2lwaGVyS2V5ID0gZXZwKHBhc3N3b3JkLCBpdi5zbGljZSgwLDgpLCBwYXJzZUludChtYXRjaFsxXSkpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBjaXBoZXJLZXksIGl2KTtcbiAgICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKTtcbiAgICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSk7XG4gICAgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChvdXQpO1xuICB9XG4gIHZhciB0YWcgPSBrZXkubWF0Y2goc3RhcnRSZWdleClbMV0gKyAnIEtFWSc7XG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgZGF0YTogZGVjcnlwdGVkXG4gIH07XG59O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MDMzNzA1XG5mdW5jdGlvbiB3cmFwIChzdHIpIHtcbiAgdmFyIGNodW5rcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDY0KSB7XG4gICAgY2h1bmtzLnB1c2goc3RyLnNsaWNlKGksIGkgKyA2NCkpXG4gIH1cbiAgcmV0dXJuIGNodW5rcy5qb2luKFwiXFxuXCIpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxemFXZHVMMjV2WkdWZmJXOWtkV3hsY3k5d1lYSnpaUzFoYzI0eEwyWnBlRkJ5YjJNdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaTh2SUdGa1lYQjBaV1FnWm5KdmJTQm9kSFJ3Y3pvdkwyZHBkR2gxWWk1amIyMHZZWEJoZEdsc0wzQmxiWE4wY21sd1hHNTJZWElnWm1sdVpGQnliMk1nUFNBdlVISnZZeTFVZVhCbE9pQTBMRVZPUTFKWlVGUkZSRnhjY2o5Y1hHNUVSVXN0U1c1bWJ6b2dRVVZUTFNnb1B6b3hNamdwZkNnL09qRTVNaWw4S0Q4Nk1qVTJLU2t0UTBKRExDaGJNQzA1UVMxSVhTc3BYRnh5UDF4Y2JseGNjajljWEc0b1d6QXRPVUV0ZWx4Y2JseGNjbHhjSzF4Y0wxeGNQVjByS1Z4Y2NqOWNYRzR2YlR0Y2JuWmhjaUJ6ZEdGeWRGSmxaMlY0SUQwdlhpMHRMUzB0UWtWSFNVNGdLQzRxS1NCTFJWa3RMUzB0TFZ4Y2NqOWNYRzR2YlR0Y2JuWmhjaUJtZFd4c1VtVm5aWGdnUFNBdlhpMHRMUzB0UWtWSFNVNGdLQzRxS1NCTFJWa3RMUzB0TFZ4Y2NqOWNYRzRvV3pBdE9VRXRlbHhjYmx4Y2NseGNLMXhjTDF4Y1BWMHJLVnhjY2o5Y1hHNHRMUzB0TFVWT1JDQmNYREVnUzBWWkxTMHRMUzBrTDIwN1hHNTJZWElnWlhad0lEMGdjbVZ4ZFdseVpTZ25MaTlGVmxCZlFubDBaWE5VYjB0bGVTY3BPMXh1ZG1GeUlHTnBjR2hsY25NZ1BTQnlaWEYxYVhKbEtDZGljbTkzYzJWeWFXWjVMV0ZsY3ljcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQW9iMnRsZVN3Z2NHRnpjM2R2Y21RcElIdGNiaUFnZG1GeUlHdGxlU0E5SUc5clpYa3VkRzlUZEhKcGJtY29LVHRjYmlBZ2RtRnlJRzFoZEdOb0lEMGdhMlY1TG0xaGRHTm9LR1pwYm1SUWNtOWpLVHRjYmlBZ2RtRnlJR1JsWTNKNWNIUmxaRHRjYmlBZ2FXWWdLQ0Z0WVhSamFDa2dlMXh1SUNBZ0lIWmhjaUJ0WVhSamFESWdQU0JyWlhrdWJXRjBZMmdvWm5Wc2JGSmxaMlY0S1R0Y2JpQWdJQ0JrWldOeWVYQjBaV1FnUFNCdVpYY2dRblZtWm1WeUtHMWhkR05vTWxzeVhTNXlaWEJzWVdObEtDOWNYSEkvWEZ4dUwyY3NJQ2NuS1N3Z0oySmhjMlUyTkNjcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIWmhjaUJ6ZFdsMFpTQTlJQ2RoWlhNbklDc2diV0YwWTJoYk1WMDdYRzRnSUNBZ2RtRnlJR2wySUQwZ2JtVjNJRUoxWm1abGNpaHRZWFJqYUZzeVhTd2dKMmhsZUNjcE8xeHVJQ0FnSUhaaGNpQmphWEJvWlhKVVpYaDBJRDBnYm1WM0lFSjFabVpsY2lodFlYUmphRnN6WFM1eVpYQnNZV05sS0M5Y1hISS9YRnh1TDJjc0lDY25LU3dnSjJKaGMyVTJOQ2NwTzF4dUlDQWdJSFpoY2lCamFYQm9aWEpMWlhrZ1BTQmxkbkFvY0dGemMzZHZjbVFzSUdsMkxuTnNhV05sS0RBc09Da3NJSEJoY25ObFNXNTBLRzFoZEdOb1d6RmRLU2s3WEc0Z0lDQWdkbUZ5SUc5MWRDQTlJRnRkTzF4dUlDQWdJSFpoY2lCamFYQm9aWElnUFNCamFYQm9aWEp6TG1OeVpXRjBaVVJsWTJsd2FHVnlhWFlvYzNWcGRHVXNJR05wY0dobGNrdGxlU3dnYVhZcE8xeHVJQ0FnSUc5MWRDNXdkWE5vS0dOcGNHaGxjaTUxY0dSaGRHVW9ZMmx3YUdWeVZHVjRkQ2twTzF4dUlDQWdJRzkxZEM1d2RYTm9LR05wY0dobGNpNW1hVzVoYkNncEtUdGNiaUFnSUNCa1pXTnllWEIwWldRZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0c5MWRDazdYRzRnSUgxY2JpQWdkbUZ5SUhSaFp5QTlJR3RsZVM1dFlYUmphQ2h6ZEdGeWRGSmxaMlY0S1ZzeFhTQXJJQ2NnUzBWWkp6dGNiaUFnY21WMGRYSnVJSHRjYmlBZ0lDQjBZV2M2SUhSaFp5eGNiaUFnSUNCa1lYUmhPaUJrWldOeWVYQjBaV1JjYmlBZ2ZUdGNibjA3WEc1Y2JpOHZJR2gwZEhBNkx5OXpkR0ZqYTI5MlpYSm1iRzkzTG1OdmJTOWhMemN3TXpNM01EVmNibVoxYm1OMGFXOXVJSGR5WVhBZ0tITjBjaWtnZTF4dUlDQjJZWElnWTJoMWJtdHpJRDBnVzExY2JseHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhOMGNpNXNaVzVuZEdnN0lHa2dLejBnTmpRcElIdGNiaUFnSUNCamFIVnVhM011Y0hWemFDaHpkSEl1YzJ4cFkyVW9hU3dnYVNBcklEWTBLU2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdZMmgxYm10ekxtcHZhVzRvWENKY1hHNWNJaWxjYm4xY2JpSmRmUT09IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBldnAocGFzc3dvcmQsIHNhbHQsIGtleUxlbikge1xuICBrZXlMZW4gPSBrZXlMZW4vODtcbiAgdmFyIGtpID0gMDtcbiAgdmFyIGlpID0gMDtcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKTtcbiAgdmFyIGFkZG1kID0gMDtcbiAgdmFyIG1kLCBtZF9idWY7XG4gIHZhciBpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIG1kID0gY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgaWYoYWRkbWQrKyA+IDApIHtcbiAgICAgICBtZC51cGRhdGUobWRfYnVmKTtcbiAgICB9XG4gICAgbWQudXBkYXRlKHBhc3N3b3JkKTtcbiAgICBtZC51cGRhdGUoc2FsdCk7XG4gICAgbWRfYnVmID0gbWQuZGlnZXN0KCk7XG4gICAgaSA9IDA7XG4gICAgaWYoa2V5TGVuID4gMCkge1xuICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBpZihrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2krK107XG4gICAgICAgIGtleUxlbi0tO1xuICAgICAgIH1cbiAgICB9XG4gICBpZihrZXlMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IoaT0wO2k8bWRfYnVmLmxlbmd0aDtpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzF6YVdkdUwyNXZaR1ZmYlc5a2RXeGxjeTl3WVhKelpTMWhjMjR4TDBWV1VGOUNlWFJsYzFSdlMyVjVMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW5aaGNpQmpjbVZoZEdWSVlYTm9JRDBnY21WeGRXbHlaU2duWTNKbFlYUmxMV2hoYzJnbktUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdaWFp3S0hCaGMzTjNiM0prTENCellXeDBMQ0JyWlhsTVpXNHBJSHRjYmlBZ2EyVjVUR1Z1SUQwZ2EyVjVUR1Z1THpnN1hHNGdJSFpoY2lCcmFTQTlJREE3WEc0Z0lIWmhjaUJwYVNBOUlEQTdYRzRnSUhaaGNpQnJaWGtnUFNCdVpYY2dRblZtWm1WeUtHdGxlVXhsYmlrN1hHNGdJSFpoY2lCaFpHUnRaQ0E5SURBN1hHNGdJSFpoY2lCdFpDd2diV1JmWW5WbU8xeHVJQ0IyWVhJZ2FUdGNiaUFnZDJocGJHVWdLSFJ5ZFdVcElIdGNiaUFnSUNCdFpDQTlJR055WldGMFpVaGhjMmdvSjIxa05TY3BPMXh1SUNBZ0lHbG1LR0ZrWkcxa0t5c2dQaUF3S1NCN1hHNGdJQ0FnSUNBZ2JXUXVkWEJrWVhSbEtHMWtYMkoxWmlrN1hHNGdJQ0FnZlZ4dUlDQWdJRzFrTG5Wd1pHRjBaU2h3WVhOemQyOXlaQ2s3WEc0Z0lDQWdiV1F1ZFhCa1lYUmxLSE5oYkhRcE8xeHVJQ0FnSUcxa1gySjFaaUE5SUcxa0xtUnBaMlZ6ZENncE8xeHVJQ0FnSUdrZ1BTQXdPMXh1SUNBZ0lHbG1LR3RsZVV4bGJpQStJREFwSUh0Y2JpQWdJQ0FnSUhkb2FXeGxLSFJ5ZFdVcElIdGNiaUFnSUNBZ0lDQWdhV1lvYTJWNVRHVnVJRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVdZb2FTQTlQVDBnYldSZlluVm1MbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUd0bGVWdHJhU3NyWFNBOUlHMWtYMkoxWmx0cEt5dGRPMXh1SUNBZ0lDQWdJQ0JyWlhsTVpXNHRMVHRjYmlBZ0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNBZ2FXWW9hMlY1VEdWdUlEMDlQU0F3S1NCN1hHNGdJQ0FnSUNCaWNtVmhhenRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdabTl5S0drOU1EdHBQRzFrWDJKMVppNXNaVzVuZEdnN2FTc3JLU0I3WEc0Z0lDQWdiV1JmWW5WbVcybGRJRDBnTUR0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnYTJWNU8xeHVmVHNpWFgwPSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG52YXIgcm1kMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG5cbmZ1bmN0aW9uIEhhc2hOb0NvbnN0cnVjdG9yKGhhc2gpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxuICB0aGlzLmJ1ZmZlcnMgPSBbXVxufVxuXG5pbmhlcml0cyhIYXNoTm9Db25zdHJ1Y3RvciwgVHJhbnNmb3JtKVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGRhdGEpXG5cbiAgbmV4dCgpXG59XG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcbiAgbmV4dCgpXG59XG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB0aGlzLmJ1ZmZlcnMucHVzaChkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlcnMpXG4gIHZhciByID0gdGhpcy5faGFzaChidWYpXG4gIHRoaXMuYnVmZmVycyA9IG51bGxcblxuICByZXR1cm4gZW5jID8gci50b1N0cmluZyhlbmMpIDogclxufVxuXG5mdW5jdGlvbiBIYXNoKGhhc2gpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxufVxuXG5pbmhlcml0cyhIYXNoLCBUcmFuc2Zvcm0pXG5cbkhhc2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBuZXh0KSB7XG4gIGlmIChlbmMpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuXG4gIG5leHQoKVxufVxuXG5IYXNoLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5faGFzaC5kaWdlc3QoKSlcbiAgdGhpcy5faGFzaCA9IG51bGxcblxuICBuZXh0KClcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2hhc2guZGlnZXN0KClcblxuICByZXR1cm4gZW5jID8gb3V0RGF0YS50b1N0cmluZyhlbmMpIDogb3V0RGF0YVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKGFsZykge1xuICBpZiAoJ21kNScgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihtZDUpXG4gIGlmICgncm1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKHJtZDE2MClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WTNKbFlYUmxMV2hoYzJndlluSnZkM05sY2k1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUluZFhObElITjBjbWxqZENjN1hHNTJZWElnYVc1b1pYSnBkSE1nUFNCeVpYRjFhWEpsS0NkcGJtaGxjbWwwY3ljcFhHNTJZWElnYldRMUlEMGdjbVZ4ZFdseVpTZ25MaTl0WkRVbktWeHVkbUZ5SUhKdFpERTJNQ0E5SUhKbGNYVnBjbVVvSjNKcGNHVnRaREUyTUNjcFhHNTJZWElnYzJoaElEMGdjbVZ4ZFdseVpTZ25jMmhoTG1wekp5bGNibHh1ZG1GeUlGUnlZVzV6Wm05eWJTQTlJSEpsY1hWcGNtVW9KM04wY21WaGJTY3BMbFJ5WVc1elptOXliVnh1WEc1bWRXNWpkR2x2YmlCSVlYTm9UbTlEYjI1emRISjFZM1J2Y2lob1lYTm9LU0I3WEc0Z0lGUnlZVzV6Wm05eWJTNWpZV3hzS0hSb2FYTXBYRzVjYmlBZ2RHaHBjeTVmYUdGemFDQTlJR2hoYzJoY2JpQWdkR2hwY3k1aWRXWm1aWEp6SUQwZ1cxMWNibjFjYmx4dWFXNW9aWEpwZEhNb1NHRnphRTV2UTI5dWMzUnlkV04wYjNJc0lGUnlZVzV6Wm05eWJTbGNibHh1U0dGemFFNXZRMjl1YzNSeWRXTjBiM0l1Y0hKdmRHOTBlWEJsTGw5MGNtRnVjMlp2Y20wZ1BTQm1kVzVqZEdsdmJpQW9aR0YwWVN3Z1h5d2dibVY0ZENrZ2UxeHVJQ0IwYUdsekxtSjFabVpsY25NdWNIVnphQ2hrWVhSaEtWeHVYRzRnSUc1bGVIUW9LVnh1ZlZ4dVhHNUlZWE5vVG05RGIyNXpkSEoxWTNSdmNpNXdjbTkwYjNSNWNHVXVYMlpzZFhOb0lEMGdablZ1WTNScGIyNGdLRzVsZUhRcElIdGNiaUFnZEdocGN5NXdkWE5vS0hSb2FYTXVaR2xuWlhOMEtDa3BYRzRnSUc1bGVIUW9LVnh1ZlZ4dVhHNUlZWE5vVG05RGIyNXpkSEoxWTNSdmNpNXdjbTkwYjNSNWNHVXVkWEJrWVhSbElEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHVnVZeWtnZTF4dUlDQnBaaUFvZEhsd1pXOW1JR1JoZEdFZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdaR0YwWVNBOUlHNWxkeUJDZFdabVpYSW9aR0YwWVN3Z1pXNWpLVnh1SUNCOVhHNWNiaUFnZEdocGN5NWlkV1ptWlhKekxuQjFjMmdvWkdGMFlTbGNiaUFnY21WMGRYSnVJSFJvYVhOY2JuMWNibHh1U0dGemFFNXZRMjl1YzNSeWRXTjBiM0l1Y0hKdmRHOTBlWEJsTG1ScFoyVnpkQ0E5SUdaMWJtTjBhVzl1SUNobGJtTXBJSHRjYmlBZ2RtRnlJR0oxWmlBOUlFSjFabVpsY2k1amIyNWpZWFFvZEdocGN5NWlkV1ptWlhKektWeHVJQ0IyWVhJZ2NpQTlJSFJvYVhNdVgyaGhjMmdvWW5WbUtWeHVJQ0IwYUdsekxtSjFabVpsY25NZ1BTQnVkV3hzWEc1Y2JpQWdjbVYwZFhKdUlHVnVZeUEvSUhJdWRHOVRkSEpwYm1jb1pXNWpLU0E2SUhKY2JuMWNibHh1Wm5WdVkzUnBiMjRnU0dGemFDaG9ZWE5vS1NCN1hHNGdJRlJ5WVc1elptOXliUzVqWVd4c0tIUm9hWE1wWEc1Y2JpQWdkR2hwY3k1ZmFHRnphQ0E5SUdoaGMyaGNibjFjYmx4dWFXNW9aWEpwZEhNb1NHRnphQ3dnVkhKaGJuTm1iM0p0S1Z4dVhHNUlZWE5vTG5CeWIzUnZkSGx3WlM1ZmRISmhibk5tYjNKdElEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHVnVZeXdnYm1WNGRDa2dlMXh1SUNCcFppQW9aVzVqS1NCa1lYUmhJRDBnYm1WM0lFSjFabVpsY2loa1lYUmhMQ0JsYm1NcFhHNWNiaUFnZEdocGN5NWZhR0Z6YUM1MWNHUmhkR1VvWkdGMFlTbGNibHh1SUNCdVpYaDBLQ2xjYm4xY2JseHVTR0Z6YUM1d2NtOTBiM1I1Y0dVdVgyWnNkWE5vSUQwZ1puVnVZM1JwYjI0Z0tHNWxlSFFwSUh0Y2JpQWdkR2hwY3k1d2RYTm9LSFJvYVhNdVgyaGhjMmd1WkdsblpYTjBLQ2twWEc0Z0lIUm9hWE11WDJoaGMyZ2dQU0J1ZFd4c1hHNWNiaUFnYm1WNGRDZ3BYRzU5WEc1Y2JraGhjMmd1Y0hKdmRHOTBlWEJsTG5Wd1pHRjBaU0E5SUdaMWJtTjBhVzl1SUNoa1lYUmhMQ0JsYm1NcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCa1lYUmhJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUdSaGRHRWdQU0J1WlhjZ1FuVm1abVZ5S0dSaGRHRXNJR1Z1WXlsY2JpQWdmVnh1WEc0Z0lIUm9hWE11WDJoaGMyZ3VkWEJrWVhSbEtHUmhkR0VwWEc0Z0lISmxkSFZ5YmlCMGFHbHpYRzU5WEc1Y2JraGhjMmd1Y0hKdmRHOTBlWEJsTG1ScFoyVnpkQ0E5SUdaMWJtTjBhVzl1SUNobGJtTXBJSHRjYmlBZ2RtRnlJRzkxZEVSaGRHRWdQU0IwYUdsekxsOW9ZWE5vTG1ScFoyVnpkQ2dwWEc1Y2JpQWdjbVYwZFhKdUlHVnVZeUEvSUc5MWRFUmhkR0V1ZEc5VGRISnBibWNvWlc1aktTQTZJRzkxZEVSaGRHRmNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCamNtVmhkR1ZJWVhOb0lDaGhiR2NwSUh0Y2JpQWdhV1lnS0NkdFpEVW5JRDA5UFNCaGJHY3BJSEpsZEhWeWJpQnVaWGNnU0dGemFFNXZRMjl1YzNSeWRXTjBiM0lvYldRMUtWeHVJQ0JwWmlBb0ozSnRaREUyTUNjZ1BUMDlJR0ZzWnlrZ2NtVjBkWEp1SUc1bGR5QklZWE5vVG05RGIyNXpkSEoxWTNSdmNpaHliV1F4TmpBcFhHNWNiaUFnY21WMGRYSnVJRzVsZHlCSVlYTm9LSE5vWVNoaGJHY3BLVnh1ZlZ4dUlsMTkiLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjYmJiOWQ1ZCB8IDBcbiAgdGhpcy5fYiA9IDB4NjI5YTI5MmEgfCAwXG4gIHRoaXMuX2MgPSAweDkxNTkwMTVhIHwgMFxuICB0aGlzLl9kID0gMHgxNTJmZWNkOCB8IDBcbiAgdGhpcy5fZSA9IDB4NjczMzI2NjcgfCAwXG4gIHRoaXMuX2YgPSAweDhlYjQ0YTg3IHwgMFxuICB0aGlzLl9nID0gMHhkYjBjMmUwZCB8IDBcbiAgdGhpcy5faCA9IDB4NDdiNTQ4MWQgfCAwXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4IHwgMFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDcgfCAwXG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxNyB8IDBcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5IHwgMFxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzEgfCAwXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMSB8IDBcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3IHwgMFxuICB0aGlzLl9obCA9IDB4YmVmYTRmYTQgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYSwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2MsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2QsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2UsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2YsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlkzSmxZWFJsTFdoaGMyZ3ZibTlrWlY5dGIyUjFiR1Z6TDNOb1lTNXFjeTl6YUdFek9EUXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlHbHVhR1Z5YVhSeklEMGdjbVZ4ZFdseVpTZ25hVzVvWlhKcGRITW5LVnh1ZG1GeUlGTklRVFV4TWlBOUlISmxjWFZwY21Vb0p5NHZjMmhoTlRFeUp5bGNiblpoY2lCSVlYTm9JRDBnY21WeGRXbHlaU2duTGk5b1lYTm9KeWxjYmx4dWRtRnlJRmNnUFNCdVpYY2dRWEp5WVhrb01UWXdLVnh1WEc1bWRXNWpkR2x2YmlCVGFHRXpPRFFnS0NrZ2UxeHVJQ0IwYUdsekxtbHVhWFFvS1Z4dUlDQjBhR2x6TGw5M0lEMGdWMXh1WEc0Z0lFaGhjMmd1WTJGc2JDaDBhR2x6TENBeE1qZ3NJREV4TWlsY2JuMWNibHh1YVc1b1pYSnBkSE1vVTJoaE16ZzBMQ0JUU0VFMU1USXBYRzVjYmxOb1lUTTROQzV3Y205MGIzUjVjR1V1YVc1cGRDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkR2hwY3k1ZllTQTlJREI0WTJKaVlqbGtOV1FnZkNBd1hHNGdJSFJvYVhNdVgySWdQU0F3ZURZeU9XRXlPVEpoSUh3Z01GeHVJQ0IwYUdsekxsOWpJRDBnTUhnNU1UVTVNREUxWVNCOElEQmNiaUFnZEdocGN5NWZaQ0E5SURCNE1UVXlabVZqWkRnZ2ZDQXdYRzRnSUhSb2FYTXVYMlVnUFNBd2VEWTNNek15TmpZM0lId2dNRnh1SUNCMGFHbHpMbDltSUQwZ01IZzRaV0kwTkdFNE55QjhJREJjYmlBZ2RHaHBjeTVmWnlBOUlEQjRaR0l3WXpKbE1HUWdmQ0F3WEc0Z0lIUm9hWE11WDJnZ1BTQXdlRFEzWWpVME9ERmtJSHdnTUZ4dVhHNGdJSFJvYVhNdVgyRnNJRDBnTUhoak1UQTFPV1ZrT0NCOElEQmNiaUFnZEdocGN5NWZZbXdnUFNBd2VETTJOMk5rTlRBM0lId2dNRnh1SUNCMGFHbHpMbDlqYkNBOUlEQjRNekEzTUdSa01UY2dmQ0F3WEc0Z0lIUm9hWE11WDJSc0lEMGdNSGhtTnpCbE5Ua3pPU0I4SURCY2JpQWdkR2hwY3k1ZlpXd2dQU0F3ZUdabVl6QXdZak14SUh3Z01GeHVJQ0IwYUdsekxsOW1iQ0E5SURCNE5qZzFPREUxTVRFZ2ZDQXdYRzRnSUhSb2FYTXVYMmRzSUQwZ01IZzJOR1k1T0daaE55QjhJREJjYmlBZ2RHaHBjeTVmYUd3Z1BTQXdlR0psWm1FMFptRTBJSHdnTUZ4dVhHNGdJSEpsZEhWeWJpQjBhR2x6WEc1OVhHNWNibE5vWVRNNE5DNXdjbTkwYjNSNWNHVXVYMmhoYzJnZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lIWmhjaUJJSUQwZ2JtVjNJRUoxWm1abGNpZzBPQ2xjYmx4dUlDQm1kVzVqZEdsdmJpQjNjbWwwWlVsdWREWTBRa1VnS0dnc0lHd3NJRzltWm5ObGRDa2dlMXh1SUNBZ0lFZ3VkM0pwZEdWSmJuUXpNa0pGS0dnc0lHOW1abk5sZENsY2JpQWdJQ0JJTG5keWFYUmxTVzUwTXpKQ1JTaHNMQ0J2Wm1aelpYUWdLeUEwS1Z4dUlDQjlYRzVjYmlBZ2QzSnBkR1ZKYm5RMk5FSkZLSFJvYVhNdVgyRXNJSFJvYVhNdVgyRnNMQ0F3S1Z4dUlDQjNjbWwwWlVsdWREWTBRa1VvZEdocGN5NWZZaXdnZEdocGN5NWZZbXdzSURncFhHNGdJSGR5YVhSbFNXNTBOalJDUlNoMGFHbHpMbDlqTENCMGFHbHpMbDlqYkN3Z01UWXBYRzRnSUhkeWFYUmxTVzUwTmpSQ1JTaDBhR2x6TGw5a0xDQjBhR2x6TGw5a2JDd2dNalFwWEc0Z0lIZHlhWFJsU1c1ME5qUkNSU2gwYUdsekxsOWxMQ0IwYUdsekxsOWxiQ3dnTXpJcFhHNGdJSGR5YVhSbFNXNTBOalJDUlNoMGFHbHpMbDltTENCMGFHbHpMbDltYkN3Z05EQXBYRzVjYmlBZ2NtVjBkWEp1SUVoY2JuMWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JUYUdFek9EUmNiaUpkZlE9PSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3IHwgMFxuICB0aGlzLl9iID0gMHhiYjY3YWU4NSB8IDBcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzIgfCAwXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhIHwgMFxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZiB8IDBcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGMgfCAwXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiIHwgMFxuICB0aGlzLl9oID0gMHg1YmUwY2QxOSB8IDBcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDggfCAwXG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYiB8IDBcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiIHwgMFxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjEgfCAwXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMSB8IDBcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmIHwgMFxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmIgfCAwXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OSB8IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTIChYLCBYbCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFhsIDw8ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKVxufVxuXG5mdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICB2YXIgaSA9IDAsIGogPSAwXG4gIHZhciBXaSwgV2lsXG4gIGZ1bmN0aW9uIGNhbGNXICgpIHtcbiAgICB2YXIgeCA9IFdbaiAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2ogLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBTKHgsIHhsLCAxKSBeIFMoeCwgeGwsIDgpIF4gKHggPj4+IDcpXG4gICAgdmFyIGdhbW1hMGwgPSBTKHhsLCB4LCAxKSBeIFMoeGwsIHgsIDgpIF4gUyh4bCwgeCwgNylcblxuICAgIHggPSBXW2ogLSAyICogMl1cbiAgICB4bCA9IFdbaiAtIDIgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWExID0gUyh4LCB4bCwgMTkpIF4gUyh4bCwgeCwgMjkpIF4gKHggPj4+IDYpXG4gICAgdmFyIGdhbW1hMWwgPSBTKHhsLCB4LCAxOSkgXiBTKHgsIHhsLCAyOSkgXiBTKHhsLCB4LCA2KVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpNyA9IFdbaiAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tqIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTYgPSBXW2ogLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tqIC0gMTYgKiAyICsgMV1cblxuICAgIFdpbCA9IGdhbW1hMGwgKyBXaTdsXG4gICAgV2kgPSBnYW1tYTAgKyBXaTcgKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMClcbiAgICBXaWwgPSBXaWwgKyBnYW1tYTFsXG4gICAgV2kgPSBXaSArIGdhbW1hMSArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKVxuICAgIFdpbCA9IFdpbCArIFdpMTZsXG4gICAgV2kgPSBXaSArIFdpMTYgKyAoKFdpbCA+Pj4gMCkgPCAoV2kxNmwgPj4+IDApID8gMSA6IDApXG4gIH1cblxuICBmdW5jdGlvbiBsb29wICgpIHtcbiAgICBXW2pdID0gV2lcbiAgICBXW2ogKyAxXSA9IFdpbFxuXG4gICAgdmFyIG1haiA9IE1haihhLCBiLCBjKVxuICAgIHZhciBtYWpsID0gTWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IFMoYSwgYWwsIDI4KSBeIFMoYWwsIGEsIDIpIF4gUyhhbCwgYSwgNylcbiAgICB2YXIgc2lnbWEwbCA9IFMoYWwsIGEsIDI4KSBeIFMoYSwgYWwsIDIpIF4gUyhhLCBhbCwgNylcbiAgICB2YXIgc2lnbWExaCA9IFMoZSwgZWwsIDE0KSBeIFMoZSwgZWwsIDE4KSBeIFMoZWwsIGUsIDkpXG4gICAgdmFyIHNpZ21hMWwgPSBTKGVsLCBlLCAxNCkgXiBTKGVsLCBlLCAxOCkgXiBTKGUsIGVsLCA5KVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuICAgIHZhciBLaSA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaCA9IENoKGUsIGYsIGcpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsXG4gICAgdmFyIHQxID0gaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApXG4gICAgdDFsID0gdDFsICsgY2hsXG4gICAgdDEgPSB0MSArIGNoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMClcbiAgICB0MWwgPSB0MWwgKyBLaWxcbiAgICB0MSA9IHQxICsgS2kgKyAoKHQxbCA+Pj4gMCkgPCAoS2lsID4+PiAwKSA/IDEgOiAwKVxuICAgIHQxbCA9IHQxbCArIFdpbFxuICAgIHQxID0gdDEgKyBXaSArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSBzaWdtYTBsICsgbWFqbFxuICAgIHZhciB0MiA9IHNpZ21hMGggKyBtYWogKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMClcblxuICAgIGggPSBnXG4gICAgaGwgPSBnbFxuICAgIGcgPSBmXG4gICAgZ2wgPSBmbFxuICAgIGYgPSBlXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlID0gKGQgKyB0MSArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgZCA9IGNcbiAgICBkbCA9IGNsXG4gICAgYyA9IGJcbiAgICBjbCA9IGJsXG4gICAgYiA9IGFcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhID0gKHQxICsgdDIgKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDBcblxuICAgIGkrK1xuICAgIGogKz0gMlxuICB9XG5cbiAgd2hpbGUgKGkgPCAxNikge1xuICAgIFdpID0gTS5yZWFkSW50MzJCRShqICogNClcbiAgICBXaWwgPSBNLnJlYWRJbnQzMkJFKGogKiA0ICsgNClcblxuICAgIGxvb3AoKVxuICB9XG5cbiAgd2hpbGUgKGkgPCA4MCkge1xuICAgIGNhbGNXKClcbiAgICBsb29wKClcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhICsgKCh0aGlzLl9hbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYiArICgodGhpcy5fYmwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMgKyAoKHRoaXMuX2NsID4+PiAwKSA8IChjbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkICsgKCh0aGlzLl9kbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fZSA9ICh0aGlzLl9lICsgZSArICgodGhpcy5fZWwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2YgPSAodGhpcy5fZiArIGYgKyAoKHRoaXMuX2ZsID4+PiAwKSA8IChmbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9nID0gKHRoaXMuX2cgKyBnICsgKCh0aGlzLl9nbCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5faCA9ICh0aGlzLl9oICsgaCArICgodGhpcy5faGwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2EsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYiwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9lLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9nLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZM0psWVhSbExXaGhjMmd2Ym05a1pWOXRiMlIxYkdWekwzTm9ZUzVxY3k5emFHRTFNVEl1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR2x1YUdWeWFYUnpJRDBnY21WeGRXbHlaU2duYVc1b1pYSnBkSE1uS1Z4dWRtRnlJRWhoYzJnZ1BTQnlaWEYxYVhKbEtDY3VMMmhoYzJnbktWeHVYRzUyWVhJZ1N5QTlJRnRjYmlBZ01IZzBNamhoTW1ZNU9Dd2dNSGhrTnpJNFlXVXlNaXdnTUhnM01UTTNORFE1TVN3Z01IZ3lNMlZtTmpWalpDeGNiaUFnTUhoaU5XTXdabUpqWml3Z01IaGxZelJrTTJJeVppd2dNSGhsT1dJMVpHSmhOU3dnTUhnNE1UZzVaR0ppWXl4Y2JpQWdNSGd6T1RVMll6STFZaXdnTUhobU16UTRZalV6T0N3Z01IZzFPV1l4TVRGbU1Td2dNSGhpTmpBMVpEQXhPU3hjYmlBZ01IZzVNak5tT0RKaE5Dd2dNSGhoWmpFNU5HWTVZaXdnTUhoaFlqRmpOV1ZrTlN3Z01IaGtZVFprT0RFeE9DeGNiaUFnTUhoa09EQTNZV0U1T0N3Z01IaGhNekF6TURJME1pd2dNSGd4TWpnek5XSXdNU3dnTUhnME5UY3dObVppWlN4Y2JpQWdNSGd5TkRNeE9EVmlaU3dnTUhnMFpXVTBZakk0WXl3Z01IZzFOVEJqTjJSak15d2dNSGhrTldabVlqUmxNaXhjYmlBZ01IZzNNbUpsTldRM05Dd2dNSGhtTWpkaU9EazJaaXdnTUhnNE1HUmxZakZtWlN3Z01IZ3pZakUyT1RaaU1TeGNiaUFnTUhnNVltUmpNRFpoTnl3Z01IZ3lOV00zTVRJek5Td2dNSGhqTVRsaVpqRTNOQ3dnTUhoalpqWTVNalk1TkN4Y2JpQWdNSGhsTkRsaU5qbGpNU3dnTUhnNVpXWXhOR0ZrTWl3Z01IaGxabUpsTkRjNE5pd2dNSGd6T0RSbU1qVmxNeXhjYmlBZ01IZ3dabU14T1dSak5pd2dNSGc0WWpoalpEVmlOU3dnTUhneU5EQmpZVEZqWXl3Z01IZzNOMkZqT1dNMk5TeGNiaUFnTUhneVpHVTVNbU0yWml3Z01IZzFPVEppTURJM05Td2dNSGcwWVRjME9EUmhZU3dnTUhnMlpXRTJaVFE0TXl4Y2JpQWdNSGcxWTJJd1lUbGtZeXdnTUhoaVpEUXhabUprTkN3Z01IZzNObVk1T0Roa1lTd2dNSGc0TXpFeE5UTmlOU3hjYmlBZ01IZzVPRE5sTlRFMU1pd2dNSGhsWlRZMlpHWmhZaXdnTUhoaE9ETXhZelkyWkN3Z01IZ3laR0kwTXpJeE1DeGNiaUFnTUhoaU1EQXpNamRqT0N3Z01IZzVPR1ppTWpFelppd2dNSGhpWmpVNU4yWmpOeXdnTUhoaVpXVm1NR1ZsTkN4Y2JpQWdNSGhqTm1Vd01HSm1NeXdnTUhnelpHRTRPR1pqTWl3Z01IaGtOV0UzT1RFME55d2dNSGc1TXpCaFlUY3lOU3hjYmlBZ01IZ3dObU5oTmpNMU1Td2dNSGhsTURBek9ESTJaaXdnTUhneE5ESTVNamsyTnl3Z01IZ3dZVEJsTm1VM01DeGNiaUFnTUhneU4ySTNNR0U0TlN3Z01IZzBObVF5TW1abVl5d2dNSGd5WlRGaU1qRXpPQ3dnTUhnMVl6STJZemt5Tml4Y2JpQWdNSGcwWkRKak5tUm1ZeXdnTUhnMVlXTTBNbUZsWkN3Z01IZzFNek00TUdReE15d2dNSGc1WkRrMVlqTmtaaXhjYmlBZ01IZzJOVEJoTnpNMU5Dd2dNSGc0WW1GbU5qTmtaU3dnTUhnM05qWmhNR0ZpWWl3Z01IZ3pZemMzWWpKaE9DeGNiaUFnTUhnNE1XTXlZemt5WlN3Z01IZzBOMlZrWVdWbE5pd2dNSGc1TWpjeU1tTTROU3dnTUhneE5EZ3lNelV6WWl4Y2JpQWdNSGhoTW1KbVpUaGhNU3dnTUhnMFkyWXhNRE0yTkN3Z01IaGhPREZoTmpZMFlpd2dNSGhpWXpReU16QXdNU3hjYmlBZ01IaGpNalJpT0dJM01Dd2dNSGhrTUdZNE9UYzVNU3dnTUhoak56WmpOVEZoTXl3Z01IZ3dOalUwWW1Vek1DeGNiaUFnTUhoa01Ua3laVGd4T1N3Z01IaGtObVZtTlRJeE9Dd2dNSGhrTmprNU1EWXlOQ3dnTUhnMU5UWTFZVGt4TUN4Y2JpQWdNSGhtTkRCbE16VTROU3dnTUhnMU56Y3hNakF5WVN3Z01IZ3hNRFpoWVRBM01Dd2dNSGd6TW1KaVpERmlPQ3hjYmlBZ01IZ3hPV0UwWXpFeE5pd2dNSGhpT0dReVpEQmpPQ3dnTUhneFpUTTNObU13T0N3Z01IZzFNVFF4WVdJMU15eGNiaUFnTUhneU56UTROemMwWXl3Z01IaGtaamhsWldJNU9Td2dNSGd6TkdJd1ltTmlOU3dnTUhobE1UbGlORGhoT0N4Y2JpQWdNSGd6T1RGak1HTmlNeXdnTUhoak5XTTVOV0UyTXl3Z01IZzBaV1E0WVdFMFlTd2dNSGhsTXpReE9HRmpZaXhjYmlBZ01IZzFZamxqWTJFMFppd2dNSGczTnpZelpUTTNNeXdnTUhnMk9ESmxObVptTXl3Z01IaGtObUl5WWpoaE15eGNiaUFnTUhnM05EaG1PREpsWlN3Z01IZzFaR1ZtWWpKbVl5d2dNSGczT0dFMU5qTTJaaXdnTUhnME16RTNNbVkyTUN4Y2JpQWdNSGc0TkdNNE56Z3hOQ3dnTUhoaE1XWXdZV0kzTWl3Z01IZzRZMk0zTURJd09Dd2dNSGd4WVRZME16bGxZeXhjYmlBZ01IZzVNR0psWm1abVlTd2dNSGd5TXpZek1XVXlPQ3dnTUhoaE5EVXdObU5sWWl3Z01IaGtaVGd5WW1SbE9TeGNiaUFnTUhoaVpXWTVZVE5tTnl3Z01IaGlNbU0yTnpreE5Td2dNSGhqTmpjeE56aG1NaXdnTUhobE16Y3lOVE15WWl4Y2JpQWdNSGhqWVRJM00yVmpaU3dnTUhobFlUSTJOakU1WXl3Z01IaGtNVGcyWWpoak55d2dNSGd5TVdNd1l6SXdOeXhjYmlBZ01IaGxZV1JoTjJSa05pd2dNSGhqWkdVd1pXSXhaU3dnTUhobU5UZGtOR1kzWml3Z01IaGxaVFpsWkRFM09DeGNiaUFnTUhnd05tWXdOamRoWVN3Z01IZzNNakUzTm1aaVlTd2dNSGd3WVRZek4yUmpOU3dnTUhoaE1tTTRPVGhoTml4Y2JpQWdNSGd4TVRObU9UZ3dOQ3dnTUhoaVpXWTVNR1JoWlN3Z01IZ3hZamN4TUdJek5Td2dNSGd4TXpGak5EY3hZaXhjYmlBZ01IZ3lPR1JpTnpkbU5Td2dNSGd5TXpBME4yUTROQ3dnTUhnek1tTmhZV0kzWWl3Z01IZzBNR00zTWpRNU15eGNiaUFnTUhnell6bGxZbVV3WVN3Z01IZ3hOV001WW1WaVl5d2dNSGcwTXpGa05qZGpOQ3dnTUhnNVl6RXdNR1EwWXl4Y2JpQWdNSGcwWTJNMVpEUmlaU3dnTUhoallqTmxOREppTml3Z01IZzFPVGRtTWprNVl5d2dNSGhtWXpZMU4yVXlZU3hjYmlBZ01IZzFabU5pTm1aaFlpd2dNSGd6WVdRMlptRmxZeXdnTUhnMll6UTBNVGs0WXl3Z01IZzBZVFEzTlRneE4xeHVYVnh1WEc1MllYSWdWeUE5SUc1bGR5QkJjbkpoZVNneE5qQXBYRzVjYm1aMWJtTjBhVzl1SUZOb1lUVXhNaUFvS1NCN1hHNGdJSFJvYVhNdWFXNXBkQ2dwWEc0Z0lIUm9hWE11WDNjZ1BTQlhYRzVjYmlBZ1NHRnphQzVqWVd4c0tIUm9hWE1zSURFeU9Dd2dNVEV5S1Z4dWZWeHVYRzVwYm1obGNtbDBjeWhUYUdFMU1USXNJRWhoYzJncFhHNWNibE5vWVRVeE1pNXdjbTkwYjNSNWNHVXVhVzVwZENBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RHaHBjeTVmWVNBOUlEQjRObUV3T1dVMk5qY2dmQ0F3WEc0Z0lIUm9hWE11WDJJZ1BTQXdlR0ppTmpkaFpUZzFJSHdnTUZ4dUlDQjBhR2x6TGw5aklEMGdNSGd6WXpabFpqTTNNaUI4SURCY2JpQWdkR2hwY3k1ZlpDQTlJREI0WVRVMFptWTFNMkVnZkNBd1hHNGdJSFJvYVhNdVgyVWdQU0F3ZURVeE1HVTFNamRtSUh3Z01GeHVJQ0IwYUdsekxsOW1JRDBnTUhnNVlqQTFOamc0WXlCOElEQmNiaUFnZEdocGN5NWZaeUE5SURCNE1XWTRNMlE1WVdJZ2ZDQXdYRzRnSUhSb2FYTXVYMmdnUFNBd2VEVmlaVEJqWkRFNUlId2dNRnh1WEc0Z0lIUm9hWE11WDJGc0lEMGdNSGhtTTJKall6a3dPQ0I4SURCY2JpQWdkR2hwY3k1Zlltd2dQU0F3ZURnMFkyRmhOek5pSUh3Z01GeHVJQ0IwYUdsekxsOWpiQ0E5SURCNFptVTVOR1k0TW1JZ2ZDQXdYRzRnSUhSb2FYTXVYMlJzSUQwZ01IZzFaakZrTXpabU1TQjhJREJjYmlBZ2RHaHBjeTVmWld3Z1BTQXdlR0ZrWlRZNE1tUXhJSHdnTUZ4dUlDQjBhR2x6TGw5bWJDQTlJREI0TW1JelpUWmpNV1lnZkNBd1hHNGdJSFJvYVhNdVgyZHNJRDBnTUhobVlqUXhZbVEyWWlCOElEQmNiaUFnZEdocGN5NWZhR3dnUFNBd2VERXpOMlV5TVRjNUlId2dNRnh1WEc0Z0lISmxkSFZ5YmlCMGFHbHpYRzU5WEc1Y2JtWjFibU4wYVc5dUlGTWdLRmdzSUZoc0xDQnVLU0I3WEc0Z0lISmxkSFZ5YmlBb1dDQStQajRnYmlrZ2ZDQW9XR3dnUER3Z0tETXlJQzBnYmlrcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUVOb0lDaDRMQ0I1TENCNktTQjdYRzRnSUhKbGRIVnliaUFvS0hnZ0ppQjVLU0JlSUNnb2ZuZ3BJQ1lnZWlrcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUUxaGFpQW9lQ3dnZVN3Z2Vpa2dlMXh1SUNCeVpYUjFjbTRnS0NoNElDWWdlU2tnWGlBb2VDQW1JSG9wSUY0Z0tIa2dKaUI2S1NsY2JuMWNibHh1VTJoaE5URXlMbkJ5YjNSdmRIbHdaUzVmZFhCa1lYUmxJRDBnWm5WdVkzUnBiMjRnS0UwcElIdGNiaUFnZG1GeUlGY2dQU0IwYUdsekxsOTNYRzVjYmlBZ2RtRnlJR0VnUFNCMGFHbHpMbDloSUh3Z01GeHVJQ0IyWVhJZ1lpQTlJSFJvYVhNdVgySWdmQ0F3WEc0Z0lIWmhjaUJqSUQwZ2RHaHBjeTVmWXlCOElEQmNiaUFnZG1GeUlHUWdQU0IwYUdsekxsOWtJSHdnTUZ4dUlDQjJZWElnWlNBOUlIUm9hWE11WDJVZ2ZDQXdYRzRnSUhaaGNpQm1JRDBnZEdocGN5NWZaaUI4SURCY2JpQWdkbUZ5SUdjZ1BTQjBhR2x6TGw5bklId2dNRnh1SUNCMllYSWdhQ0E5SUhSb2FYTXVYMmdnZkNBd1hHNWNiaUFnZG1GeUlHRnNJRDBnZEdocGN5NWZZV3dnZkNBd1hHNGdJSFpoY2lCaWJDQTlJSFJvYVhNdVgySnNJSHdnTUZ4dUlDQjJZWElnWTJ3Z1BTQjBhR2x6TGw5amJDQjhJREJjYmlBZ2RtRnlJR1JzSUQwZ2RHaHBjeTVmWkd3Z2ZDQXdYRzRnSUhaaGNpQmxiQ0E5SUhSb2FYTXVYMlZzSUh3Z01GeHVJQ0IyWVhJZ1ptd2dQU0IwYUdsekxsOW1iQ0I4SURCY2JpQWdkbUZ5SUdkc0lEMGdkR2hwY3k1Zloyd2dmQ0F3WEc0Z0lIWmhjaUJvYkNBOUlIUm9hWE11WDJoc0lId2dNRnh1WEc0Z0lIWmhjaUJwSUQwZ01Dd2dhaUE5SURCY2JpQWdkbUZ5SUZkcExDQlhhV3hjYmlBZ1puVnVZM1JwYjI0Z1kyRnNZMWNnS0NrZ2UxeHVJQ0FnSUhaaGNpQjRJRDBnVjF0cUlDMGdNVFVnS2lBeVhWeHVJQ0FnSUhaaGNpQjRiQ0E5SUZkYmFpQXRJREUxSUNvZ01pQXJJREZkWEc0Z0lDQWdkbUZ5SUdkaGJXMWhNQ0E5SUZNb2VDd2dlR3dzSURFcElGNGdVeWg0TENCNGJDd2dPQ2tnWGlBb2VDQStQajRnTnlsY2JpQWdJQ0IyWVhJZ1oyRnRiV0V3YkNBOUlGTW9lR3dzSUhnc0lERXBJRjRnVXloNGJDd2dlQ3dnT0NrZ1hpQlRLSGhzTENCNExDQTNLVnh1WEc0Z0lDQWdlQ0E5SUZkYmFpQXRJRElnS2lBeVhWeHVJQ0FnSUhoc0lEMGdWMXRxSUMwZ01pQXFJRElnS3lBeFhWeHVJQ0FnSUhaaGNpQm5ZVzF0WVRFZ1BTQlRLSGdzSUhoc0xDQXhPU2tnWGlCVEtIaHNMQ0I0TENBeU9Ta2dYaUFvZUNBK1BqNGdOaWxjYmlBZ0lDQjJZWElnWjJGdGJXRXhiQ0E5SUZNb2VHd3NJSGdzSURFNUtTQmVJRk1vZUN3Z2VHd3NJREk1S1NCZUlGTW9lR3dzSUhnc0lEWXBYRzVjYmlBZ0lDQXZMeUJYVzJsZElEMGdaMkZ0YldFd0lDc2dWMXRwSUMwZ04xMGdLeUJuWVcxdFlURWdLeUJYVzJrZ0xTQXhObDFjYmlBZ0lDQjJZWElnVjJrM0lEMGdWMXRxSUMwZ055QXFJREpkWEc0Z0lDQWdkbUZ5SUZkcE4yd2dQU0JYVzJvZ0xTQTNJQ29nTWlBcklERmRYRzVjYmlBZ0lDQjJZWElnVjJreE5pQTlJRmRiYWlBdElERTJJQ29nTWwxY2JpQWdJQ0IyWVhJZ1Yya3hObXdnUFNCWFcyb2dMU0F4TmlBcUlESWdLeUF4WFZ4dVhHNGdJQ0FnVjJsc0lEMGdaMkZ0YldFd2JDQXJJRmRwTjJ4Y2JpQWdJQ0JYYVNBOUlHZGhiVzFoTUNBcklGZHBOeUFySUNnb1YybHNJRDQrUGlBd0tTQThJQ2huWVcxdFlUQnNJRDQrUGlBd0tTQS9JREVnT2lBd0tWeHVJQ0FnSUZkcGJDQTlJRmRwYkNBcklHZGhiVzFoTVd4Y2JpQWdJQ0JYYVNBOUlGZHBJQ3NnWjJGdGJXRXhJQ3NnS0NoWGFXd2dQajQrSURBcElEd2dLR2RoYlcxaE1Xd2dQajQrSURBcElEOGdNU0E2SURBcFhHNGdJQ0FnVjJsc0lEMGdWMmxzSUNzZ1Yya3hObXhjYmlBZ0lDQlhhU0E5SUZkcElDc2dWMmt4TmlBcklDZ29WMmxzSUQ0K1BpQXdLU0E4SUNoWGFURTJiQ0ErUGo0Z01Da2dQeUF4SURvZ01DbGNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJR3h2YjNBZ0tDa2dlMXh1SUNBZ0lGZGJhbDBnUFNCWGFWeHVJQ0FnSUZkYmFpQXJJREZkSUQwZ1YybHNYRzVjYmlBZ0lDQjJZWElnYldGcUlEMGdUV0ZxS0dFc0lHSXNJR01wWEc0Z0lDQWdkbUZ5SUcxaGFtd2dQU0JOWVdvb1lXd3NJR0pzTENCamJDbGNibHh1SUNBZ0lIWmhjaUJ6YVdkdFlUQm9JRDBnVXloaExDQmhiQ3dnTWpncElGNGdVeWhoYkN3Z1lTd2dNaWtnWGlCVEtHRnNMQ0JoTENBM0tWeHVJQ0FnSUhaaGNpQnphV2R0WVRCc0lEMGdVeWhoYkN3Z1lTd2dNamdwSUY0Z1V5aGhMQ0JoYkN3Z01pa2dYaUJUS0dFc0lHRnNMQ0EzS1Z4dUlDQWdJSFpoY2lCemFXZHRZVEZvSUQwZ1V5aGxMQ0JsYkN3Z01UUXBJRjRnVXlobExDQmxiQ3dnTVRncElGNGdVeWhsYkN3Z1pTd2dPU2xjYmlBZ0lDQjJZWElnYzJsbmJXRXhiQ0E5SUZNb1pXd3NJR1VzSURFMEtTQmVJRk1vWld3c0lHVXNJREU0S1NCZUlGTW9aU3dnWld3c0lEa3BYRzVjYmlBZ0lDQXZMeUIwTVNBOUlHZ2dLeUJ6YVdkdFlURWdLeUJqYUNBcklFdGJhVjBnS3lCWFcybGRYRzRnSUNBZ2RtRnlJRXRwSUQwZ1MxdHFYVnh1SUNBZ0lIWmhjaUJMYVd3Z1BTQkxXMm9nS3lBeFhWeHVYRzRnSUNBZ2RtRnlJR05vSUQwZ1EyZ29aU3dnWml3Z1p5bGNiaUFnSUNCMllYSWdZMmhzSUQwZ1EyZ29aV3dzSUdac0xDQm5iQ2xjYmx4dUlDQWdJSFpoY2lCME1Xd2dQU0JvYkNBcklITnBaMjFoTVd4Y2JpQWdJQ0IyWVhJZ2RERWdQU0JvSUNzZ2MybG5iV0V4YUNBcklDZ29kREZzSUQ0K1BpQXdLU0E4SUNob2JDQStQajRnTUNrZ1B5QXhJRG9nTUNsY2JpQWdJQ0IwTVd3Z1BTQjBNV3dnS3lCamFHeGNiaUFnSUNCME1TQTlJSFF4SUNzZ1kyZ2dLeUFvS0hReGJDQStQajRnTUNrZ1BDQW9ZMmhzSUQ0K1BpQXdLU0EvSURFZ09pQXdLVnh1SUNBZ0lIUXhiQ0E5SUhReGJDQXJJRXRwYkZ4dUlDQWdJSFF4SUQwZ2RERWdLeUJMYVNBcklDZ29kREZzSUQ0K1BpQXdLU0E4SUNoTGFXd2dQajQrSURBcElEOGdNU0E2SURBcFhHNGdJQ0FnZERGc0lEMGdkREZzSUNzZ1YybHNYRzRnSUNBZ2RERWdQU0IwTVNBcklGZHBJQ3NnS0NoME1Xd2dQajQrSURBcElEd2dLRmRwYkNBK1BqNGdNQ2tnUHlBeElEb2dNQ2xjYmx4dUlDQWdJQzh2SUhReUlEMGdjMmxuYldFd0lDc2diV0ZxWEc0Z0lDQWdkbUZ5SUhReWJDQTlJSE5wWjIxaE1Hd2dLeUJ0WVdwc1hHNGdJQ0FnZG1GeUlIUXlJRDBnYzJsbmJXRXdhQ0FySUcxaGFpQXJJQ2dvZERKc0lENCtQaUF3S1NBOElDaHphV2R0WVRCc0lENCtQaUF3S1NBL0lERWdPaUF3S1Z4dVhHNGdJQ0FnYUNBOUlHZGNiaUFnSUNCb2JDQTlJR2RzWEc0Z0lDQWdaeUE5SUdaY2JpQWdJQ0JuYkNBOUlHWnNYRzRnSUNBZ1ppQTlJR1ZjYmlBZ0lDQm1iQ0E5SUdWc1hHNGdJQ0FnWld3Z1BTQW9aR3dnS3lCME1Xd3BJSHdnTUZ4dUlDQWdJR1VnUFNBb1pDQXJJSFF4SUNzZ0tDaGxiQ0ErUGo0Z01Da2dQQ0FvWkd3Z1BqNCtJREFwSUQ4Z01TQTZJREFwS1NCOElEQmNiaUFnSUNCa0lEMGdZMXh1SUNBZ0lHUnNJRDBnWTJ4Y2JpQWdJQ0JqSUQwZ1lseHVJQ0FnSUdOc0lEMGdZbXhjYmlBZ0lDQmlJRDBnWVZ4dUlDQWdJR0pzSUQwZ1lXeGNiaUFnSUNCaGJDQTlJQ2gwTVd3Z0t5QjBNbXdwSUh3Z01GeHVJQ0FnSUdFZ1BTQW9kREVnS3lCME1pQXJJQ2dvWVd3Z1BqNCtJREFwSUR3Z0tIUXhiQ0ErUGo0Z01Da2dQeUF4SURvZ01Da3BJSHdnTUZ4dVhHNGdJQ0FnYVNzclhHNGdJQ0FnYWlBclBTQXlYRzRnSUgxY2JseHVJQ0IzYUdsc1pTQW9hU0E4SURFMktTQjdYRzRnSUNBZ1Yya2dQU0JOTG5KbFlXUkpiblF6TWtKRktHb2dLaUEwS1Z4dUlDQWdJRmRwYkNBOUlFMHVjbVZoWkVsdWRETXlRa1VvYWlBcUlEUWdLeUEwS1Z4dVhHNGdJQ0FnYkc5dmNDZ3BYRzRnSUgxY2JseHVJQ0IzYUdsc1pTQW9hU0E4SURnd0tTQjdYRzRnSUNBZ1kyRnNZMWNvS1Z4dUlDQWdJR3h2YjNBb0tWeHVJQ0I5WEc1Y2JpQWdkR2hwY3k1ZllXd2dQU0FvZEdocGN5NWZZV3dnS3lCaGJDa2dmQ0F3WEc0Z0lIUm9hWE11WDJKc0lEMGdLSFJvYVhNdVgySnNJQ3NnWW13cElId2dNRnh1SUNCMGFHbHpMbDlqYkNBOUlDaDBhR2x6TGw5amJDQXJJR05zS1NCOElEQmNiaUFnZEdocGN5NWZaR3dnUFNBb2RHaHBjeTVmWkd3Z0t5QmtiQ2tnZkNBd1hHNGdJSFJvYVhNdVgyVnNJRDBnS0hSb2FYTXVYMlZzSUNzZ1pXd3BJSHdnTUZ4dUlDQjBhR2x6TGw5bWJDQTlJQ2gwYUdsekxsOW1iQ0FySUdac0tTQjhJREJjYmlBZ2RHaHBjeTVmWjJ3Z1BTQW9kR2hwY3k1Zloyd2dLeUJuYkNrZ2ZDQXdYRzRnSUhSb2FYTXVYMmhzSUQwZ0tIUm9hWE11WDJoc0lDc2dhR3dwSUh3Z01GeHVYRzRnSUhSb2FYTXVYMkVnUFNBb2RHaHBjeTVmWVNBcklHRWdLeUFvS0hSb2FYTXVYMkZzSUQ0K1BpQXdLU0E4SUNoaGJDQStQajRnTUNrZ1B5QXhJRG9nTUNrcElId2dNRnh1SUNCMGFHbHpMbDlpSUQwZ0tIUm9hWE11WDJJZ0t5QmlJQ3NnS0NoMGFHbHpMbDlpYkNBK1BqNGdNQ2tnUENBb1ltd2dQajQrSURBcElEOGdNU0E2SURBcEtTQjhJREJjYmlBZ2RHaHBjeTVmWXlBOUlDaDBhR2x6TGw5aklDc2dZeUFySUNnb2RHaHBjeTVmWTJ3Z1BqNCtJREFwSUR3Z0tHTnNJRDQrUGlBd0tTQS9JREVnT2lBd0tTa2dmQ0F3WEc0Z0lIUm9hWE11WDJRZ1BTQW9kR2hwY3k1ZlpDQXJJR1FnS3lBb0tIUm9hWE11WDJSc0lENCtQaUF3S1NBOElDaGtiQ0ErUGo0Z01Da2dQeUF4SURvZ01Da3BJSHdnTUZ4dUlDQjBhR2x6TGw5bElEMGdLSFJvYVhNdVgyVWdLeUJsSUNzZ0tDaDBhR2x6TGw5bGJDQStQajRnTUNrZ1BDQW9aV3dnUGo0K0lEQXBJRDhnTVNBNklEQXBLU0I4SURCY2JpQWdkR2hwY3k1ZlppQTlJQ2gwYUdsekxsOW1JQ3NnWmlBcklDZ29kR2hwY3k1Zlptd2dQajQrSURBcElEd2dLR1pzSUQ0K1BpQXdLU0EvSURFZ09pQXdLU2tnZkNBd1hHNGdJSFJvYVhNdVgyY2dQU0FvZEdocGN5NWZaeUFySUdjZ0t5QW9LSFJvYVhNdVgyZHNJRDQrUGlBd0tTQThJQ2huYkNBK1BqNGdNQ2tnUHlBeElEb2dNQ2twSUh3Z01GeHVJQ0IwYUdsekxsOW9JRDBnS0hSb2FYTXVYMmdnS3lCb0lDc2dLQ2gwYUdsekxsOW9iQ0ErUGo0Z01Da2dQQ0FvYUd3Z1BqNCtJREFwSUQ4Z01TQTZJREFwS1NCOElEQmNibjFjYmx4dVUyaGhOVEV5TG5CeWIzUnZkSGx3WlM1ZmFHRnphQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnZG1GeUlFZ2dQU0J1WlhjZ1FuVm1abVZ5S0RZMEtWeHVYRzRnSUdaMWJtTjBhVzl1SUhkeWFYUmxTVzUwTmpSQ1JTQW9hQ3dnYkN3Z2IyWm1jMlYwS1NCN1hHNGdJQ0FnU0M1M2NtbDBaVWx1ZERNeVFrVW9hQ3dnYjJabWMyVjBLVnh1SUNBZ0lFZ3VkM0pwZEdWSmJuUXpNa0pGS0d3c0lHOW1abk5sZENBcklEUXBYRzRnSUgxY2JseHVJQ0IzY21sMFpVbHVkRFkwUWtVb2RHaHBjeTVmWVN3Z2RHaHBjeTVmWVd3c0lEQXBYRzRnSUhkeWFYUmxTVzUwTmpSQ1JTaDBhR2x6TGw5aUxDQjBhR2x6TGw5aWJDd2dPQ2xjYmlBZ2QzSnBkR1ZKYm5RMk5FSkZLSFJvYVhNdVgyTXNJSFJvYVhNdVgyTnNMQ0F4TmlsY2JpQWdkM0pwZEdWSmJuUTJORUpGS0hSb2FYTXVYMlFzSUhSb2FYTXVYMlJzTENBeU5DbGNiaUFnZDNKcGRHVkpiblEyTkVKRktIUm9hWE11WDJVc0lIUm9hWE11WDJWc0xDQXpNaWxjYmlBZ2QzSnBkR1ZKYm5RMk5FSkZLSFJvYVhNdVgyWXNJSFJvYVhNdVgyWnNMQ0EwTUNsY2JpQWdkM0pwZEdWSmJuUTJORUpGS0hSb2FYTXVYMmNzSUhSb2FYTXVYMmRzTENBME9DbGNiaUFnZDNKcGRHVkpiblEyTkVKRktIUm9hWE11WDJnc0lIUm9hWE11WDJoc0xDQTFOaWxjYmx4dUlDQnlaWFIxY200Z1NGeHVmVnh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUZOb1lUVXhNbHh1SWwxOSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDggfCAwXG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3IHwgMFxuICB0aGlzLl9jID0gMHgzMDcwZGQxNyB8IDBcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzkgfCAwXG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxIHwgMFxuICB0aGlzLl9mID0gMHg2ODU4MTUxMSB8IDBcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTcgfCAwXG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlkzSmxZWFJsTFdoaGMyZ3ZibTlrWlY5dGIyUjFiR1Z6TDNOb1lTNXFjeTl6YUdFeU1qUXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxS2x4dUlDb2dRU0JLWVhaaFUyTnlhWEIwSUdsdGNHeGxiV1Z1ZEdGMGFXOXVJRzltSUhSb1pTQlRaV04xY21VZ1NHRnphQ0JCYkdkdmNtbDBhRzBzSUZOSVFTMHlOVFlzSUdGeklHUmxabWx1WldSY2JpQXFJR2x1SUVaSlVGTWdNVGd3TFRKY2JpQXFJRlpsY25OcGIyNGdNaTR5TFdKbGRHRWdRMjl3ZVhKcFoyaDBJRUZ1WjJWc0lFMWhjbWx1TENCUVlYVnNJRXB2YUc1emRHOXVJREl3TURBZ0xTQXlNREE1TGx4dUlDb2dUM1JvWlhJZ1kyOXVkSEpwWW5WMGIzSnpPaUJIY21WbklFaHZiSFFzSUVGdVpISmxkeUJMWlhCbGNuUXNJRmxrYm1GeUxDQk1iM04wYVc1bGRGeHVJQ3BjYmlBcUwxeHVYRzUyWVhJZ2FXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BYRzUyWVhJZ1UyaGhNalUySUQwZ2NtVnhkV2x5WlNnbkxpOXphR0V5TlRZbktWeHVkbUZ5SUVoaGMyZ2dQU0J5WlhGMWFYSmxLQ2N1TDJoaGMyZ25LVnh1WEc1MllYSWdWeUE5SUc1bGR5QkJjbkpoZVNnMk5DbGNibHh1Wm5WdVkzUnBiMjRnVTJoaE1qSTBJQ2dwSUh0Y2JpQWdkR2hwY3k1cGJtbDBLQ2xjYmx4dUlDQjBhR2x6TGw5M0lEMGdWeUF2THlCdVpYY2dRWEp5WVhrb05qUXBYRzVjYmlBZ1NHRnphQzVqWVd4c0tIUm9hWE1zSURZMExDQTFOaWxjYm4xY2JseHVhVzVvWlhKcGRITW9VMmhoTWpJMExDQlRhR0V5TlRZcFhHNWNibE5vWVRJeU5DNXdjbTkwYjNSNWNHVXVhVzVwZENBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RHaHBjeTVmWVNBOUlEQjRZekV3TlRsbFpEZ2dmQ0F3WEc0Z0lIUm9hWE11WDJJZ1BTQXdlRE0yTjJOa05UQTNJSHdnTUZ4dUlDQjBhR2x6TGw5aklEMGdNSGd6TURjd1pHUXhOeUI4SURCY2JpQWdkR2hwY3k1ZlpDQTlJREI0Wmpjd1pUVTVNemtnZkNBd1hHNGdJSFJvYVhNdVgyVWdQU0F3ZUdabVl6QXdZak14SUh3Z01GeHVJQ0IwYUdsekxsOW1JRDBnTUhnMk9EVTRNVFV4TVNCOElEQmNiaUFnZEdocGN5NWZaeUE5SURCNE5qUm1PVGhtWVRjZ2ZDQXdYRzRnSUhSb2FYTXVYMmdnUFNBd2VHSmxabUUwWm1FMElId2dNRnh1WEc0Z0lISmxkSFZ5YmlCMGFHbHpYRzU5WEc1Y2JsTm9ZVEl5TkM1d2NtOTBiM1I1Y0dVdVgyaGhjMmdnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUhaaGNpQklJRDBnYm1WM0lFSjFabVpsY2lneU9DbGNibHh1SUNCSUxuZHlhWFJsU1c1ME16SkNSU2gwYUdsekxsOWhMQ0F3S1Z4dUlDQklMbmR5YVhSbFNXNTBNekpDUlNoMGFHbHpMbDlpTENBMEtWeHVJQ0JJTG5keWFYUmxTVzUwTXpKQ1JTaDBhR2x6TGw5akxDQTRLVnh1SUNCSUxuZHlhWFJsU1c1ME16SkNSU2gwYUdsekxsOWtMQ0F4TWlsY2JpQWdTQzUzY21sMFpVbHVkRE15UWtVb2RHaHBjeTVmWlN3Z01UWXBYRzRnSUVndWQzSnBkR1ZKYm5Rek1rSkZLSFJvYVhNdVgyWXNJREl3S1Z4dUlDQklMbmR5YVhSbFNXNTBNekpDUlNoMGFHbHpMbDluTENBeU5DbGNibHh1SUNCeVpYUjFjbTRnU0Z4dWZWeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRk5vWVRJeU5GeHVJbDE5IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2NyB8IDBcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODUgfCAwXG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyIHwgMFxuICB0aGlzLl9kID0gMHhhNTRmZjUzYSB8IDBcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2YgfCAwXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjIHwgMFxuICB0aGlzLl9nID0gMHgxZjgzZDlhYiB8IDBcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTkgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gUyAoWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIFIgKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKVxufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKVxufVxuXG5mdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpXG59XG5cbmZ1bmN0aW9uIFNpZ21hMDI1NiAoeCkge1xuICByZXR1cm4gKFMoeCwgMikgXiBTKHgsIDEzKSBeIFMoeCwgMjIpKVxufVxuXG5mdW5jdGlvbiBTaWdtYTEyNTYgKHgpIHtcbiAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSlcbn1cblxuZnVuY3Rpb24gR2FtbWEwMjU2ICh4KSB7XG4gIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSlcbn1cblxuZnVuY3Rpb24gR2FtbWExMjU2ICh4KSB7XG4gIHJldHVybiAoUyh4LCAxNykgXiBTKHgsIDE5KSBeIFIoeCwgMTApKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICB2YXIgaiA9IDBcblxuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBHYW1tYTEyNTYoV1tqIC0gMl0pICsgV1tqIC0gN10gKyBHYW1tYTAyNTYoV1tqIC0gMTVdKSArIFdbaiAtIDE2XSB9XG4gIGZ1bmN0aW9uIGxvb3AgKHcpIHtcbiAgICBXW2pdID0gd1xuXG4gICAgdmFyIFQxID0gaCArIFNpZ21hMTI1NihlKSArIENoKGUsIGYsIGcpICsgS1tqXSArIHdcbiAgICB2YXIgVDIgPSBTaWdtYTAyNTYoYSkgKyBNYWooYSwgYiwgYylcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSBkICsgVDFcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gVDEgKyBUMlxuXG4gICAgaisrXG4gIH1cblxuICB3aGlsZSAoaiA8IDE2KSBsb29wKE0ucmVhZEludDMyQkUoaiAqIDQpKVxuICB3aGlsZSAoaiA8IDY0KSBsb29wKGNhbGNXKCkpXG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WTNKbFlYUmxMV2hoYzJndmJtOWtaVjl0YjJSMWJHVnpMM05vWVM1cWN5OXphR0V5TlRZdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5b3FYRzRnS2lCQklFcGhkbUZUWTNKcGNIUWdhVzF3YkdWdFpXNTBZWFJwYjI0Z2IyWWdkR2hsSUZObFkzVnlaU0JJWVhOb0lFRnNaMjl5YVhSb2JTd2dVMGhCTFRJMU5pd2dZWE1nWkdWbWFXNWxaRnh1SUNvZ2FXNGdSa2xRVXlBeE9EQXRNbHh1SUNvZ1ZtVnljMmx2YmlBeUxqSXRZbVYwWVNCRGIzQjVjbWxuYUhRZ1FXNW5aV3dnVFdGeWFXNHNJRkJoZFd3Z1NtOW9ibk4wYjI0Z01qQXdNQ0F0SURJd01Ea3VYRzRnS2lCUGRHaGxjaUJqYjI1MGNtbGlkWFJ2Y25NNklFZHlaV2NnU0c5c2RDd2dRVzVrY21WM0lFdGxjR1Z5ZEN3Z1dXUnVZWElzSUV4dmMzUnBibVYwWEc0Z0tseHVJQ292WEc1Y2JuWmhjaUJwYm1obGNtbDBjeUE5SUhKbGNYVnBjbVVvSjJsdWFHVnlhWFJ6SnlsY2JuWmhjaUJJWVhOb0lEMGdjbVZ4ZFdseVpTZ25MaTlvWVhOb0p5bGNibHh1ZG1GeUlFc2dQU0JiWEc0Z0lEQjROREk0UVRKR09UZ3NJREI0TnpFek56UTBPVEVzSURCNFFqVkRNRVpDUTBZc0lEQjRSVGxDTlVSQ1FUVXNYRzRnSURCNE16azFOa015TlVJc0lEQjROVGxHTVRFeFJqRXNJREI0T1RJelJqZ3lRVFFzSURCNFFVSXhRelZGUkRVc1hHNGdJREI0UkRnd04wRkJPVGdzSURCNE1USTRNelZDTURFc0lEQjRNalF6TVRnMVFrVXNJREI0TlRVd1F6ZEVRek1zWEc0Z0lEQjROekpDUlRWRU56UXNJREI0T0RCRVJVSXhSa1VzSURCNE9VSkVRekEyUVRjc0lEQjRRekU1UWtZeE56UXNYRzRnSURCNFJUUTVRalk1UXpFc0lEQjRSVVpDUlRRM09EWXNJREI0TUVaRE1UbEVRellzSURCNE1qUXdRMEV4UTBNc1hHNGdJREI0TWtSRk9USkROa1lzSURCNE5FRTNORGcwUVVFc0lEQjROVU5DTUVFNVJFTXNJREI0TnpaR09UZzRSRUVzWEc0Z0lEQjRPVGd6UlRVeE5USXNJREI0UVRnek1VTTJOa1FzSURCNFFqQXdNekkzUXpnc0lEQjRRa1kxT1RkR1F6Y3NYRzRnSURCNFF6WkZNREJDUmpNc0lEQjRSRFZCTnpreE5EY3NJREI0TURaRFFUWXpOVEVzSURCNE1UUXlPVEk1Tmpjc1hHNGdJREI0TWpkQ056QkJPRFVzSURCNE1rVXhRakl4TXpnc0lEQjRORVF5UXpaRVJrTXNJREI0TlRNek9EQkVNVE1zWEc0Z0lEQjROalV3UVRjek5UUXNJREI0TnpZMlFUQkJRa0lzSURCNE9ERkRNa001TWtVc0lEQjRPVEkzTWpKRE9EVXNYRzRnSURCNFFUSkNSa1U0UVRFc0lEQjRRVGd4UVRZMk5FSXNJREI0UXpJMFFqaENOekFzSURCNFF6YzJRelV4UVRNc1hHNGdJREI0UkRFNU1rVTRNVGtzSURCNFJEWTVPVEEyTWpRc0lEQjRSalF3UlRNMU9EVXNJREI0TVRBMlFVRXdOekFzWEc0Z0lEQjRNVGxCTkVNeE1UWXNJREI0TVVVek56WkRNRGdzSURCNE1qYzBPRGMzTkVNc0lEQjRNelJDTUVKRFFqVXNYRzRnSURCNE16a3hRekJEUWpNc0lEQjRORVZFT0VGQk5FRXNJREI0TlVJNVEwTkJORVlzSURCNE5qZ3lSVFpHUmpNc1hHNGdJREI0TnpRNFJqZ3lSVVVzSURCNE56aEJOVFl6TmtZc0lEQjRPRFJET0RjNE1UUXNJREI0T0VORE56QXlNRGdzWEc0Z0lEQjRPVEJDUlVaR1JrRXNJREI0UVRRMU1EWkRSVUlzSURCNFFrVkdPVUV6Umpjc0lEQjRRelkzTVRjNFJqSmNibDFjYmx4dWRtRnlJRmNnUFNCdVpYY2dRWEp5WVhrb05qUXBYRzVjYm1aMWJtTjBhVzl1SUZOb1lUSTFOaUFvS1NCN1hHNGdJSFJvYVhNdWFXNXBkQ2dwWEc1Y2JpQWdkR2hwY3k1ZmR5QTlJRmNnTHk4Z2JtVjNJRUZ5Y21GNUtEWTBLVnh1WEc0Z0lFaGhjMmd1WTJGc2JDaDBhR2x6TENBMk5Dd2dOVFlwWEc1OVhHNWNibWx1YUdWeWFYUnpLRk5vWVRJMU5pd2dTR0Z6YUNsY2JseHVVMmhoTWpVMkxuQnliM1J2ZEhsd1pTNXBibWwwSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCMGFHbHpMbDloSUQwZ01IZzJZVEE1WlRZMk55QjhJREJjYmlBZ2RHaHBjeTVmWWlBOUlEQjRZbUkyTjJGbE9EVWdmQ0F3WEc0Z0lIUm9hWE11WDJNZ1BTQXdlRE5qTm1WbU16Y3lJSHdnTUZ4dUlDQjBhR2x6TGw5a0lEMGdNSGhoTlRSbVpqVXpZU0I4SURCY2JpQWdkR2hwY3k1ZlpTQTlJREI0TlRFd1pUVXlOMllnZkNBd1hHNGdJSFJvYVhNdVgyWWdQU0F3ZURsaU1EVTJPRGhqSUh3Z01GeHVJQ0IwYUdsekxsOW5JRDBnTUhneFpqZ3paRGxoWWlCOElEQmNiaUFnZEdocGN5NWZhQ0E5SURCNE5XSmxNR05rTVRrZ2ZDQXdYRzVjYmlBZ2NtVjBkWEp1SUhSb2FYTmNibjFjYmx4dVpuVnVZM1JwYjI0Z1V5QW9XQ3dnYmlrZ2UxeHVJQ0J5WlhSMWNtNGdLRmdnUGo0K0lHNHBJSHdnS0ZnZ1BEd2dLRE15SUMwZ2Jpa3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlGSWdLRmdzSUc0cElIdGNiaUFnY21WMGRYSnVJQ2hZSUQ0K1BpQnVLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQkRhQ0FvZUN3Z2VTd2dlaWtnZTF4dUlDQnlaWFIxY200Z0tDaDRJQ1lnZVNrZ1hpQW9LSDU0S1NBbUlIb3BLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQk5ZV29nS0hnc0lIa3NJSG9wSUh0Y2JpQWdjbVYwZFhKdUlDZ29lQ0FtSUhrcElGNGdLSGdnSmlCNktTQmVJQ2g1SUNZZ2Vpa3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlGTnBaMjFoTURJMU5pQW9lQ2tnZTF4dUlDQnlaWFIxY200Z0tGTW9lQ3dnTWlrZ1hpQlRLSGdzSURFektTQmVJRk1vZUN3Z01qSXBLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQlRhV2R0WVRFeU5UWWdLSGdwSUh0Y2JpQWdjbVYwZFhKdUlDaFRLSGdzSURZcElGNGdVeWg0TENBeE1Ta2dYaUJUS0hnc0lESTFLU2xjYm4xY2JseHVablZ1WTNScGIyNGdSMkZ0YldFd01qVTJJQ2g0S1NCN1hHNGdJSEpsZEhWeWJpQW9VeWg0TENBM0tTQmVJRk1vZUN3Z01UZ3BJRjRnVWloNExDQXpLU2xjYm4xY2JseHVablZ1WTNScGIyNGdSMkZ0YldFeE1qVTJJQ2g0S1NCN1hHNGdJSEpsZEhWeWJpQW9VeWg0TENBeE55a2dYaUJUS0hnc0lERTVLU0JlSUZJb2VDd2dNVEFwS1Z4dWZWeHVYRzVUYUdFeU5UWXVjSEp2ZEc5MGVYQmxMbDkxY0dSaGRHVWdQU0JtZFc1amRHbHZiaUFvVFNrZ2UxeHVJQ0IyWVhJZ1Z5QTlJSFJvYVhNdVgzZGNibHh1SUNCMllYSWdZU0E5SUhSb2FYTXVYMkVnZkNBd1hHNGdJSFpoY2lCaUlEMGdkR2hwY3k1ZllpQjhJREJjYmlBZ2RtRnlJR01nUFNCMGFHbHpMbDlqSUh3Z01GeHVJQ0IyWVhJZ1pDQTlJSFJvYVhNdVgyUWdmQ0F3WEc0Z0lIWmhjaUJsSUQwZ2RHaHBjeTVmWlNCOElEQmNiaUFnZG1GeUlHWWdQU0IwYUdsekxsOW1JSHdnTUZ4dUlDQjJZWElnWnlBOUlIUm9hWE11WDJjZ2ZDQXdYRzRnSUhaaGNpQm9JRDBnZEdocGN5NWZhQ0I4SURCY2JseHVJQ0IyWVhJZ2FpQTlJREJjYmx4dUlDQm1kVzVqZEdsdmJpQmpZV3hqVnlBb0tTQjdJSEpsZEhWeWJpQkhZVzF0WVRFeU5UWW9WMXRxSUMwZ01sMHBJQ3NnVjF0cUlDMGdOMTBnS3lCSFlXMXRZVEF5TlRZb1YxdHFJQzBnTVRWZEtTQXJJRmRiYWlBdElERTJYU0I5WEc0Z0lHWjFibU4wYVc5dUlHeHZiM0FnS0hjcElIdGNiaUFnSUNCWFcycGRJRDBnZDF4dVhHNGdJQ0FnZG1GeUlGUXhJRDBnYUNBcklGTnBaMjFoTVRJMU5paGxLU0FySUVOb0tHVXNJR1lzSUdjcElDc2dTMXRxWFNBcklIZGNiaUFnSUNCMllYSWdWRElnUFNCVGFXZHRZVEF5TlRZb1lTa2dLeUJOWVdvb1lTd2dZaXdnWXlsY2JseHVJQ0FnSUdnZ1BTQm5YRzRnSUNBZ1p5QTlJR1pjYmlBZ0lDQm1JRDBnWlZ4dUlDQWdJR1VnUFNCa0lDc2dWREZjYmlBZ0lDQmtJRDBnWTF4dUlDQWdJR01nUFNCaVhHNGdJQ0FnWWlBOUlHRmNiaUFnSUNCaElEMGdWREVnS3lCVU1seHVYRzRnSUNBZ2Fpc3JYRzRnSUgxY2JseHVJQ0IzYUdsc1pTQW9haUE4SURFMktTQnNiMjl3S0UwdWNtVmhaRWx1ZERNeVFrVW9haUFxSURRcEtWeHVJQ0IzYUdsc1pTQW9haUE4SURZMEtTQnNiMjl3S0dOaGJHTlhLQ2twWEc1Y2JpQWdkR2hwY3k1ZllTQTlJQ2hoSUNzZ2RHaHBjeTVmWVNrZ2ZDQXdYRzRnSUhSb2FYTXVYMklnUFNBb1lpQXJJSFJvYVhNdVgySXBJSHdnTUZ4dUlDQjBhR2x6TGw5aklEMGdLR01nS3lCMGFHbHpMbDlqS1NCOElEQmNiaUFnZEdocGN5NWZaQ0E5SUNoa0lDc2dkR2hwY3k1ZlpDa2dmQ0F3WEc0Z0lIUm9hWE11WDJVZ1BTQW9aU0FySUhSb2FYTXVYMlVwSUh3Z01GeHVJQ0IwYUdsekxsOW1JRDBnS0dZZ0t5QjBhR2x6TGw5bUtTQjhJREJjYmlBZ2RHaHBjeTVmWnlBOUlDaG5JQ3NnZEdocGN5NWZaeWtnZkNBd1hHNGdJSFJvYVhNdVgyZ2dQU0FvYUNBcklIUm9hWE11WDJncElId2dNRnh1ZlZ4dVhHNVRhR0V5TlRZdWNISnZkRzkwZVhCbExsOW9ZWE5vSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCMllYSWdTQ0E5SUc1bGR5QkNkV1ptWlhJb016SXBYRzVjYmlBZ1NDNTNjbWwwWlVsdWRETXlRa1VvZEdocGN5NWZZU3dnTUNsY2JpQWdTQzUzY21sMFpVbHVkRE15UWtVb2RHaHBjeTVmWWl3Z05DbGNiaUFnU0M1M2NtbDBaVWx1ZERNeVFrVW9kR2hwY3k1Zll5d2dPQ2xjYmlBZ1NDNTNjbWwwWlVsdWRETXlRa1VvZEdocGN5NWZaQ3dnTVRJcFhHNGdJRWd1ZDNKcGRHVkpiblF6TWtKRktIUm9hWE11WDJVc0lERTJLVnh1SUNCSUxuZHlhWFJsU1c1ME16SkNSU2gwYUdsekxsOW1MQ0F5TUNsY2JpQWdTQzUzY21sMFpVbHVkRE15UWtVb2RHaHBjeTVmWnl3Z01qUXBYRzRnSUVndWQzSnBkR1ZKYm5Rek1rSkZLSFJvYVhNdVgyZ3NJREk0S1Z4dVhHNGdJSEpsZEhWeWJpQklYRzU5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1UyaGhNalUyWEc0aVhYMD0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMSB8IDBcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODkgfCAwXG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlIHwgMFxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NiB8IDBcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjAgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sIChudW0sIGNudCkge1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSlcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuICB2YXIgZSA9IHRoaXMuX2VcblxuICB2YXIgaiA9IDAsIGtcblxuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiByb2woV1tqIC0gM10gXiBXW2ogLSA4XSBeIFdbaiAtIDE0XSBeIFdbaiAtIDE2XSwgMSkgfVxuICBmdW5jdGlvbiBsb29wICh3LCBmKSB7XG4gICAgV1tqXSA9IHdcblxuICAgIHZhciB0ID0gcm9sKGEsIDUpICsgZiArIGUgKyB3ICsga1xuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb2woYiwgMzApXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICAgIGorK1xuICB9XG5cbiAgayA9IDE1MTg1MDAyNDlcbiAgd2hpbGUgKGogPCAxNikgbG9vcChNLnJlYWRJbnQzMkJFKGogKiA0KSwgKGIgJiBjKSB8ICgofmIpICYgZCkpXG4gIHdoaWxlIChqIDwgMjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8ICgofmIpICYgZCkpXG4gIGsgPSAxODU5Nzc1MzkzXG4gIHdoaWxlIChqIDwgNDApIGxvb3AoY2FsY1coKSwgYiBeIGMgXiBkKVxuICBrID0gLTE4OTQwMDc1ODhcbiAgd2hpbGUgKGogPCA2MCkgbG9vcChjYWxjVygpLCAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpXG4gIGsgPSAtODk5NDk3NTE0XG4gIHdoaWxlIChqIDwgODApIGxvb3AoY2FsY1coKSwgYiBeIGMgXiBkKVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZM0psWVhSbExXaGhjMmd2Ym05a1pWOXRiMlIxYkdWekwzTm9ZUzVxY3k5emFHRXhMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxWEc0Z0tpQkJJRXBoZG1GVFkzSnBjSFFnYVcxd2JHVnRaVzUwWVhScGIyNGdiMllnZEdobElGTmxZM1Z5WlNCSVlYTm9JRUZzWjI5eWFYUm9iU3dnVTBoQkxURXNJR0Z6SUdSbFptbHVaV1JjYmlBcUlHbHVJRVpKVUZNZ1VGVkNJREU0TUMweFhHNGdLaUJXWlhKemFXOXVJREl1TVdFZ1EyOXdlWEpwWjJoMElGQmhkV3dnU205b2JuTjBiMjRnTWpBd01DQXRJREl3TURJdVhHNGdLaUJQZEdobGNpQmpiMjUwY21saWRYUnZjbk02SUVkeVpXY2dTRzlzZEN3Z1FXNWtjbVYzSUV0bGNHVnlkQ3dnV1dSdVlYSXNJRXh2YzNScGJtVjBYRzRnS2lCRWFYTjBjbWxpZFhSbFpDQjFibVJsY2lCMGFHVWdRbE5FSUV4cFkyVnVjMlZjYmlBcUlGTmxaU0JvZEhSd09pOHZjR0ZxYUc5dFpTNXZjbWN1ZFdzdlkzSjVjSFF2YldRMUlHWnZjaUJrWlhSaGFXeHpMbHh1SUNvdlhHNWNiblpoY2lCcGJtaGxjbWwwY3lBOUlISmxjWFZwY21Vb0oybHVhR1Z5YVhSekp5bGNiblpoY2lCSVlYTm9JRDBnY21WeGRXbHlaU2duTGk5b1lYTm9KeWxjYmx4dWRtRnlJRmNnUFNCdVpYY2dRWEp5WVhrb09EQXBYRzVjYm1aMWJtTjBhVzl1SUZOb1lURWdLQ2tnZTF4dUlDQjBhR2x6TG1sdWFYUW9LVnh1SUNCMGFHbHpMbDkzSUQwZ1YxeHVYRzRnSUVoaGMyZ3VZMkZzYkNoMGFHbHpMQ0EyTkN3Z05UWXBYRzU5WEc1Y2JtbHVhR1Z5YVhSektGTm9ZVEVzSUVoaGMyZ3BYRzVjYmxOb1lURXVjSEp2ZEc5MGVYQmxMbWx1YVhRZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lIUm9hWE11WDJFZ1BTQXdlRFkzTkRVeU16QXhJSHdnTUZ4dUlDQjBhR2x6TGw5aUlEMGdNSGhsWm1Oa1lXSTRPU0I4SURCY2JpQWdkR2hwY3k1Zll5QTlJREI0T1RoaVlXUmpabVVnZkNBd1hHNGdJSFJvYVhNdVgyUWdQU0F3ZURFd016STFORGMySUh3Z01GeHVJQ0IwYUdsekxsOWxJRDBnTUhoak0yUXlaVEZtTUNCOElEQmNibHh1SUNCeVpYUjFjbTRnZEdocGMxeHVmVnh1WEc0dktseHVJQ29nUW1sMGQybHpaU0J5YjNSaGRHVWdZU0F6TWkxaWFYUWdiblZ0WW1WeUlIUnZJSFJvWlNCc1pXWjBMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQnliMndnS0c1MWJTd2dZMjUwS1NCN1hHNGdJSEpsZEhWeWJpQW9iblZ0SUR3OElHTnVkQ2tnZkNBb2JuVnRJRDQrUGlBb016SWdMU0JqYm5RcEtWeHVmVnh1WEc1VGFHRXhMbkJ5YjNSdmRIbHdaUzVmZFhCa1lYUmxJRDBnWm5WdVkzUnBiMjRnS0UwcElIdGNiaUFnZG1GeUlGY2dQU0IwYUdsekxsOTNYRzVjYmlBZ2RtRnlJR0VnUFNCMGFHbHpMbDloWEc0Z0lIWmhjaUJpSUQwZ2RHaHBjeTVmWWx4dUlDQjJZWElnWXlBOUlIUm9hWE11WDJOY2JpQWdkbUZ5SUdRZ1BTQjBhR2x6TGw5a1hHNGdJSFpoY2lCbElEMGdkR2hwY3k1ZlpWeHVYRzRnSUhaaGNpQnFJRDBnTUN3Z2ExeHVYRzRnSUdaMWJtTjBhVzl1SUdOaGJHTlhJQ2dwSUhzZ2NtVjBkWEp1SUhKdmJDaFhXMm9nTFNBelhTQmVJRmRiYWlBdElEaGRJRjRnVjF0cUlDMGdNVFJkSUY0Z1YxdHFJQzBnTVRaZExDQXhLU0I5WEc0Z0lHWjFibU4wYVc5dUlHeHZiM0FnS0hjc0lHWXBJSHRjYmlBZ0lDQlhXMnBkSUQwZ2QxeHVYRzRnSUNBZ2RtRnlJSFFnUFNCeWIyd29ZU3dnTlNrZ0t5Qm1JQ3NnWlNBcklIY2dLeUJyWEc1Y2JpQWdJQ0JsSUQwZ1pGeHVJQ0FnSUdRZ1BTQmpYRzRnSUNBZ1l5QTlJSEp2YkNoaUxDQXpNQ2xjYmlBZ0lDQmlJRDBnWVZ4dUlDQWdJR0VnUFNCMFhHNGdJQ0FnYWlzclhHNGdJSDFjYmx4dUlDQnJJRDBnTVRVeE9EVXdNREkwT1Z4dUlDQjNhR2xzWlNBb2FpQThJREUyS1NCc2IyOXdLRTB1Y21WaFpFbHVkRE15UWtVb2FpQXFJRFFwTENBb1lpQW1JR01wSUh3Z0tDaCtZaWtnSmlCa0tTbGNiaUFnZDJocGJHVWdLR29nUENBeU1Da2diRzl2Y0NoallXeGpWeWdwTENBb1lpQW1JR01wSUh3Z0tDaCtZaWtnSmlCa0tTbGNiaUFnYXlBOUlERTROVGszTnpVek9UTmNiaUFnZDJocGJHVWdLR29nUENBME1Da2diRzl2Y0NoallXeGpWeWdwTENCaUlGNGdZeUJlSUdRcFhHNGdJR3NnUFNBdE1UZzVOREF3TnpVNE9GeHVJQ0IzYUdsc1pTQW9haUE4SURZd0tTQnNiMjl3S0dOaGJHTlhLQ2tzSUNoaUlDWWdZeWtnZkNBb1lpQW1JR1FwSUh3Z0tHTWdKaUJrS1NsY2JpQWdheUE5SUMwNE9UazBPVGMxTVRSY2JpQWdkMmhwYkdVZ0tHb2dQQ0E0TUNrZ2JHOXZjQ2hqWVd4alZ5Z3BMQ0JpSUY0Z1l5QmVJR1FwWEc1Y2JpQWdkR2hwY3k1ZllTQTlJQ2hoSUNzZ2RHaHBjeTVmWVNrZ2ZDQXdYRzRnSUhSb2FYTXVYMklnUFNBb1lpQXJJSFJvYVhNdVgySXBJSHdnTUZ4dUlDQjBhR2x6TGw5aklEMGdLR01nS3lCMGFHbHpMbDlqS1NCOElEQmNiaUFnZEdocGN5NWZaQ0E5SUNoa0lDc2dkR2hwY3k1ZlpDa2dmQ0F3WEc0Z0lIUm9hWE11WDJVZ1BTQW9aU0FySUhSb2FYTXVYMlVwSUh3Z01GeHVmVnh1WEc1VGFHRXhMbkJ5YjNSdmRIbHdaUzVmYUdGemFDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkbUZ5SUVnZ1BTQnVaWGNnUW5WbVptVnlLREl3S1Z4dVhHNGdJRWd1ZDNKcGRHVkpiblF6TWtKRktIUm9hWE11WDJFZ2ZDQXdMQ0F3S1Z4dUlDQklMbmR5YVhSbFNXNTBNekpDUlNoMGFHbHpMbDlpSUh3Z01Dd2dOQ2xjYmlBZ1NDNTNjbWwwWlVsdWRETXlRa1VvZEdocGN5NWZZeUI4SURBc0lEZ3BYRzRnSUVndWQzSnBkR1ZKYm5Rek1rSkZLSFJvYVhNdVgyUWdmQ0F3TENBeE1pbGNiaUFnU0M1M2NtbDBaVWx1ZERNeVFrVW9kR2hwY3k1ZlpTQjhJREFzSURFMktWeHVYRzRnSUhKbGRIVnliaUJJWEc1OVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdVMmhoTVZ4dUlsMTkiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDEgfCAwXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5IHwgMFxuICB0aGlzLl9jID0gMHg5OGJhZGNmZSB8IDBcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzYgfCAwXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwIHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbCAobnVtLCBjbnQpIHtcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuICB2YXIgZSA9IHRoaXMuX2VcblxuICB2YXIgaiA9IDAsIGtcblxuICAvKlxuICAgKiBTSEEtMSBoYXMgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0IG9wZXJhdGlvbi4gQnV0LCBTSEEgaXMgbm90XG4gICAqIGZ1bmN0aW9uIGNhbGNXKCkgeyByZXR1cm4gcm9sKFdbaiAtIDNdIF4gV1tqIC0gIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdLCAxKSB9XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBXW2ogLSAzXSBeIFdbaiAtIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdIH1cbiAgZnVuY3Rpb24gbG9vcCAodywgZikge1xuICAgIFdbal0gPSB3XG5cbiAgICB2YXIgdCA9IHJvbChhLCA1KSArIGYgKyBlICsgdyArIGtcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm9sKGIsIDMwKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgICBqKytcbiAgfVxuXG4gIGsgPSAxNTE4NTAwMjQ5XG4gIHdoaWxlIChqIDwgMTYpIGxvb3AoTS5yZWFkSW50MzJCRShqICogNCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICB3aGlsZSAoaiA8IDIwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICBrID0gMTg1OTc3NTM5M1xuICB3aGlsZSAoaiA8IDQwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcbiAgayA9IC0xODk0MDA3NTg4XG4gIHdoaWxlIChqIDwgNjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKVxuICBrID0gLTg5OTQ5NzUxNFxuICB3aGlsZSAoaiA8IDgwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WTNKbFlYUmxMV2hoYzJndmJtOWtaVjl0YjJSMWJHVnpMM05vWVM1cWN5OXphR0V1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdktseHVJQ29nUVNCS1lYWmhVMk55YVhCMElHbHRjR3hsYldWdWRHRjBhVzl1SUc5bUlIUm9aU0JUWldOMWNtVWdTR0Z6YUNCQmJHZHZjbWwwYUcwc0lGTklRUzB3TENCaGN5QmtaV1pwYm1Wa1hHNGdLaUJwYmlCR1NWQlRJRkJWUWlBeE9EQXRNVnh1SUNvZ1ZHaHBjeUJ6YjNWeVkyVWdZMjlrWlNCcGN5QmtaWEpwZG1Wa0lHWnliMjBnYzJoaE1TNXFjeUJ2WmlCMGFHVWdjMkZ0WlNCeVpYQnZjMmwwYjNKNUxseHVJQ29nVkdobElHUnBabVpsY21WdVkyVWdZbVYwZDJWbGJpQlRTRUV0TUNCaGJtUWdVMGhCTFRFZ2FYTWdhblZ6ZENCaElHSnBkSGRwYzJVZ2NtOTBZWFJsSUd4bFpuUmNiaUFxSUc5d1pYSmhkR2x2YmlCM1lYTWdZV1JrWldRdVhHNGdLaTljYmx4dWRtRnlJR2x1YUdWeWFYUnpJRDBnY21WeGRXbHlaU2duYVc1b1pYSnBkSE1uS1Z4dWRtRnlJRWhoYzJnZ1BTQnlaWEYxYVhKbEtDY3VMMmhoYzJnbktWeHVYRzUyWVhJZ1Z5QTlJRzVsZHlCQmNuSmhlU2c0TUNsY2JseHVablZ1WTNScGIyNGdVMmhoSUNncElIdGNiaUFnZEdocGN5NXBibWwwS0NsY2JpQWdkR2hwY3k1ZmR5QTlJRmRjYmx4dUlDQklZWE5vTG1OaGJHd29kR2hwY3l3Z05qUXNJRFUyS1Z4dWZWeHVYRzVwYm1obGNtbDBjeWhUYUdFc0lFaGhjMmdwWEc1Y2JsTm9ZUzV3Y205MGIzUjVjR1V1YVc1cGRDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkR2hwY3k1ZllTQTlJREI0TmpjME5USXpNREVnZkNBd1hHNGdJSFJvYVhNdVgySWdQU0F3ZUdWbVkyUmhZamc1SUh3Z01GeHVJQ0IwYUdsekxsOWpJRDBnTUhnNU9HSmhaR05tWlNCOElEQmNiaUFnZEdocGN5NWZaQ0E5SURCNE1UQXpNalUwTnpZZ2ZDQXdYRzRnSUhSb2FYTXVYMlVnUFNBd2VHTXpaREpsTVdZd0lId2dNRnh1WEc0Z0lISmxkSFZ5YmlCMGFHbHpYRzU5WEc1Y2JpOHFYRzRnS2lCQ2FYUjNhWE5sSUhKdmRHRjBaU0JoSURNeUxXSnBkQ0J1ZFcxaVpYSWdkRzhnZEdobElHeGxablF1WEc0Z0tpOWNibVoxYm1OMGFXOXVJSEp2YkNBb2JuVnRMQ0JqYm5RcElIdGNiaUFnY21WMGRYSnVJQ2h1ZFcwZ1BEd2dZMjUwS1NCOElDaHVkVzBnUGo0K0lDZ3pNaUF0SUdOdWRDa3BYRzU5WEc1Y2JsTm9ZUzV3Y205MGIzUjVjR1V1WDNWd1pHRjBaU0E5SUdaMWJtTjBhVzl1SUNoTktTQjdYRzRnSUhaaGNpQlhJRDBnZEdocGN5NWZkMXh1WEc0Z0lIWmhjaUJoSUQwZ2RHaHBjeTVmWVZ4dUlDQjJZWElnWWlBOUlIUm9hWE11WDJKY2JpQWdkbUZ5SUdNZ1BTQjBhR2x6TGw5alhHNGdJSFpoY2lCa0lEMGdkR2hwY3k1ZlpGeHVJQ0IyWVhJZ1pTQTlJSFJvYVhNdVgyVmNibHh1SUNCMllYSWdhaUE5SURBc0lHdGNibHh1SUNBdktseHVJQ0FnS2lCVFNFRXRNU0JvWVhNZ1lTQmlhWFIzYVhObElISnZkR0YwWlNCc1pXWjBJRzl3WlhKaGRHbHZiaTRnUW5WMExDQlRTRUVnYVhNZ2JtOTBYRzRnSUNBcUlHWjFibU4wYVc5dUlHTmhiR05YS0NrZ2V5QnlaWFIxY200Z2NtOXNLRmRiYWlBdElETmRJRjRnVjF0cUlDMGdJRGhkSUY0Z1YxdHFJQzBnTVRSZElGNGdWMXRxSUMwZ01UWmRMQ0F4S1NCOVhHNGdJQ0FxTDF4dUlDQm1kVzVqZEdsdmJpQmpZV3hqVnlBb0tTQjdJSEpsZEhWeWJpQlhXMm9nTFNBelhTQmVJRmRiYWlBdElEaGRJRjRnVjF0cUlDMGdNVFJkSUY0Z1YxdHFJQzBnTVRaZElIMWNiaUFnWm5WdVkzUnBiMjRnYkc5dmNDQW9keXdnWmlrZ2UxeHVJQ0FnSUZkYmFsMGdQU0IzWEc1Y2JpQWdJQ0IyWVhJZ2RDQTlJSEp2YkNoaExDQTFLU0FySUdZZ0t5QmxJQ3NnZHlBcklHdGNibHh1SUNBZ0lHVWdQU0JrWEc0Z0lDQWdaQ0E5SUdOY2JpQWdJQ0JqSUQwZ2NtOXNLR0lzSURNd0tWeHVJQ0FnSUdJZ1BTQmhYRzRnSUNBZ1lTQTlJSFJjYmlBZ0lDQnFLeXRjYmlBZ2ZWeHVYRzRnSUdzZ1BTQXhOVEU0TlRBd01qUTVYRzRnSUhkb2FXeGxJQ2hxSUR3Z01UWXBJR3h2YjNBb1RTNXlaV0ZrU1c1ME16SkNSU2hxSUNvZ05Da3NJQ2hpSUNZZ1l5a2dmQ0FvS0g1aUtTQW1JR1FwS1Z4dUlDQjNhR2xzWlNBb2FpQThJREl3S1NCc2IyOXdLR05oYkdOWEtDa3NJQ2hpSUNZZ1l5a2dmQ0FvS0g1aUtTQW1JR1FwS1Z4dUlDQnJJRDBnTVRnMU9UYzNOVE01TTF4dUlDQjNhR2xzWlNBb2FpQThJRFF3S1NCc2IyOXdLR05oYkdOWEtDa3NJR0lnWGlCaklGNGdaQ2xjYmlBZ2F5QTlJQzB4T0RrME1EQTNOVGc0WEc0Z0lIZG9hV3hsSUNocUlEd2dOakFwSUd4dmIzQW9ZMkZzWTFjb0tTd2dLR0lnSmlCaktTQjhJQ2hpSUNZZ1pDa2dmQ0FvWXlBbUlHUXBLVnh1SUNCcklEMGdMVGc1T1RRNU56VXhORnh1SUNCM2FHbHNaU0FvYWlBOElEZ3dLU0JzYjI5d0tHTmhiR05YS0Nrc0lHSWdYaUJqSUY0Z1pDbGNibHh1SUNCMGFHbHpMbDloSUQwZ0tHRWdLeUIwYUdsekxsOWhLU0I4SURCY2JpQWdkR2hwY3k1ZllpQTlJQ2hpSUNzZ2RHaHBjeTVmWWlrZ2ZDQXdYRzRnSUhSb2FYTXVYMk1nUFNBb1l5QXJJSFJvYVhNdVgyTXBJSHdnTUZ4dUlDQjBhR2x6TGw5a0lEMGdLR1FnS3lCMGFHbHpMbDlrS1NCOElEQmNiaUFnZEdocGN5NWZaU0E5SUNobElDc2dkR2hwY3k1ZlpTa2dmQ0F3WEc1OVhHNWNibE5vWVM1d2NtOTBiM1I1Y0dVdVgyaGhjMmdnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUhaaGNpQklJRDBnYm1WM0lFSjFabVpsY2lneU1DbGNibHh1SUNCSUxuZHlhWFJsU1c1ME16SkNSU2gwYUdsekxsOWhJSHdnTUN3Z01DbGNiaUFnU0M1M2NtbDBaVWx1ZERNeVFrVW9kR2hwY3k1ZllpQjhJREFzSURRcFhHNGdJRWd1ZDNKcGRHVkpiblF6TWtKRktIUm9hWE11WDJNZ2ZDQXdMQ0E0S1Z4dUlDQklMbmR5YVhSbFNXNTBNekpDUlNoMGFHbHpMbDlrSUh3Z01Dd2dNVElwWEc0Z0lFZ3VkM0pwZEdWSmJuUXpNa0pGS0hSb2FYTXVYMlVnZkNBd0xDQXhOaWxjYmx4dUlDQnlaWFIxY200Z1NGeHVmVnh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUZOb1lWeHVYRzRpWFgwPSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxuICB0aGlzLl9zID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGwgPSB0aGlzLl9sZW4gKz0gZGF0YS5sZW5ndGhcbiAgdmFyIHMgPSB0aGlzLl9zIHx8IDBcbiAgdmFyIGYgPSAwXG4gIHZhciBidWZmZXIgPSB0aGlzLl9ibG9ja1xuXG4gIHdoaWxlIChzIDwgbCkge1xuICAgIHZhciB0ID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIGYgKyB0aGlzLl9ibG9ja1NpemUgLSAocyAlIHRoaXMuX2Jsb2NrU2l6ZSkpXG4gICAgdmFyIGNoID0gKHQgLSBmKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaDsgaSsrKSB7XG4gICAgICBidWZmZXJbKHMgJSB0aGlzLl9ibG9ja1NpemUpICsgaV0gPSBkYXRhW2kgKyBmXVxuICAgIH1cblxuICAgIHMgKz0gY2hcbiAgICBmICs9IGNoXG5cbiAgICBpZiAoKHMgJSB0aGlzLl9ibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYnVmZmVyKVxuICAgIH1cbiAgfVxuICB0aGlzLl9zID0gc1xuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgLy8gU3VwcG9zZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIE0sIGluIGJpdHMsIGlzIGxcbiAgdmFyIGwgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gQXBwZW5kIHRoZSBiaXQgMSB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZV0gPSAweDgwXG5cbiAgLy8gYW5kIHRoZW4gayB6ZXJvIGJpdHMsIHdoZXJlIGsgaXMgdGhlIHNtYWxsZXN0IG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGwgKyAxICsgaykgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplICsgMSlcblxuICBpZiAobCAlICh0aGlzLl9ibG9ja1NpemUgKiA4KSA+PSB0aGlzLl9maW5hbFNpemUgKiA4KSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIC8vIHRvIHRoaXMgYXBwZW5kIHRoZSBibG9jayB3aGljaCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIGwgd3JpdHRlbiBpbiBiaW5hcnlcbiAgLy8gVE9ETzogaGFuZGxlIGNhc2Ugd2hlcmUgbCBpcyA+IE1hdGgucG93KDIsIDI5KVxuICB0aGlzLl9ibG9jay53cml0ZUludDMyQkUobCwgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICB2YXIgaGFzaCA9IHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaykgfHwgdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZM0psWVhSbExXaGhjMmd2Ym05a1pWOXRiMlIxYkdWekwzTm9ZUzVxY3k5b1lYTm9MbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5OGdjSEp2ZEc5MGVYQmxJR05zWVhOeklHWnZjaUJvWVhOb0lHWjFibU4wYVc5dWMxeHVablZ1WTNScGIyNGdTR0Z6YUNBb1lteHZZMnRUYVhwbExDQm1hVzVoYkZOcGVtVXBJSHRjYmlBZ2RHaHBjeTVmWW14dlkyc2dQU0J1WlhjZ1FuVm1abVZ5S0dKc2IyTnJVMmw2WlNsY2JpQWdkR2hwY3k1ZlptbHVZV3hUYVhwbElEMGdabWx1WVd4VGFYcGxYRzRnSUhSb2FYTXVYMkpzYjJOclUybDZaU0E5SUdKc2IyTnJVMmw2WlZ4dUlDQjBhR2x6TGw5c1pXNGdQU0F3WEc0Z0lIUm9hWE11WDNNZ1BTQXdYRzU5WEc1Y2JraGhjMmd1Y0hKdmRHOTBlWEJsTG5Wd1pHRjBaU0E5SUdaMWJtTjBhVzl1SUNoa1lYUmhMQ0JsYm1NcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCa1lYUmhJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUdWdVl5QTlJR1Z1WXlCOGZDQW5kWFJtT0NkY2JpQWdJQ0JrWVhSaElEMGdibVYzSUVKMVptWmxjaWhrWVhSaExDQmxibU1wWEc0Z0lIMWNibHh1SUNCMllYSWdiQ0E5SUhSb2FYTXVYMnhsYmlBclBTQmtZWFJoTG14bGJtZDBhRnh1SUNCMllYSWdjeUE5SUhSb2FYTXVYM01nZkh3Z01GeHVJQ0IyWVhJZ1ppQTlJREJjYmlBZ2RtRnlJR0oxWm1abGNpQTlJSFJvYVhNdVgySnNiMk5yWEc1Y2JpQWdkMmhwYkdVZ0tITWdQQ0JzS1NCN1hHNGdJQ0FnZG1GeUlIUWdQU0JOWVhSb0xtMXBiaWhrWVhSaExteGxibWQwYUN3Z1ppQXJJSFJvYVhNdVgySnNiMk5yVTJsNlpTQXRJQ2h6SUNVZ2RHaHBjeTVmWW14dlkydFRhWHBsS1NsY2JpQWdJQ0IyWVhJZ1kyZ2dQU0FvZENBdElHWXBYRzVjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05vT3lCcEt5c3BJSHRjYmlBZ0lDQWdJR0oxWm1abGNsc29jeUFsSUhSb2FYTXVYMkpzYjJOclUybDZaU2tnS3lCcFhTQTlJR1JoZEdGYmFTQXJJR1pkWEc0Z0lDQWdmVnh1WEc0Z0lDQWdjeUFyUFNCamFGeHVJQ0FnSUdZZ0t6MGdZMmhjYmx4dUlDQWdJR2xtSUNnb2N5QWxJSFJvYVhNdVgySnNiMk5yVTJsNlpTa2dQVDA5SURBcElIdGNiaUFnSUNBZ0lIUm9hWE11WDNWd1pHRjBaU2hpZFdabVpYSXBYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lIUm9hWE11WDNNZ1BTQnpYRzVjYmlBZ2NtVjBkWEp1SUhSb2FYTmNibjFjYmx4dVNHRnphQzV3Y205MGIzUjVjR1V1WkdsblpYTjBJRDBnWm5WdVkzUnBiMjRnS0dWdVl5a2dlMXh1SUNBdkx5QlRkWEJ3YjNObElIUm9aU0JzWlc1bmRHZ2diMllnZEdobElHMWxjM05oWjJVZ1RTd2dhVzRnWW1sMGN5d2dhWE1nYkZ4dUlDQjJZWElnYkNBOUlIUm9hWE11WDJ4bGJpQXFJRGhjYmx4dUlDQXZMeUJCY0hCbGJtUWdkR2hsSUdKcGRDQXhJSFJ2SUhSb1pTQmxibVFnYjJZZ2RHaGxJRzFsYzNOaFoyVmNiaUFnZEdocGN5NWZZbXh2WTJ0YmRHaHBjeTVmYkdWdUlDVWdkR2hwY3k1ZllteHZZMnRUYVhwbFhTQTlJREI0T0RCY2JseHVJQ0F2THlCaGJtUWdkR2hsYmlCcklIcGxjbThnWW1sMGN5d2dkMmhsY21VZ2F5QnBjeUIwYUdVZ2MyMWhiR3hsYzNRZ2JtOXVMVzVsWjJGMGFYWmxJSE52YkhWMGFXOXVJSFJ2SUhSb1pTQmxjWFZoZEdsdmJpQW9iQ0FySURFZ0t5QnJLU0E5UFQwZ1ptbHVZV3hUYVhwbElHMXZaQ0JpYkc5amExTnBlbVZjYmlBZ2RHaHBjeTVmWW14dlkyc3VabWxzYkNnd0xDQjBhR2x6TGw5c1pXNGdKU0IwYUdsekxsOWliRzlqYTFOcGVtVWdLeUF4S1Z4dVhHNGdJR2xtSUNoc0lDVWdLSFJvYVhNdVgySnNiMk5yVTJsNlpTQXFJRGdwSUQ0OUlIUm9hWE11WDJacGJtRnNVMmw2WlNBcUlEZ3BJSHRjYmlBZ0lDQjBhR2x6TGw5MWNHUmhkR1VvZEdocGN5NWZZbXh2WTJzcFhHNGdJQ0FnZEdocGN5NWZZbXh2WTJzdVptbHNiQ2d3S1Z4dUlDQjlYRzVjYmlBZ0x5OGdkRzhnZEdocGN5QmhjSEJsYm1RZ2RHaGxJR0pzYjJOcklIZG9hV05vSUdseklHVnhkV0ZzSUhSdklIUm9aU0J1ZFcxaVpYSWdiQ0IzY21sMGRHVnVJR2x1SUdKcGJtRnllVnh1SUNBdkx5QlVUMFJQT2lCb1lXNWtiR1VnWTJGelpTQjNhR1Z5WlNCc0lHbHpJRDRnVFdGMGFDNXdiM2NvTWl3Z01qa3BYRzRnSUhSb2FYTXVYMkpzYjJOckxuZHlhWFJsU1c1ME16SkNSU2hzTENCMGFHbHpMbDlpYkc5amExTnBlbVVnTFNBMEtWeHVYRzRnSUhaaGNpQm9ZWE5vSUQwZ2RHaHBjeTVmZFhCa1lYUmxLSFJvYVhNdVgySnNiMk5yS1NCOGZDQjBhR2x6TGw5b1lYTm9LQ2xjYmx4dUlDQnlaWFIxY200Z1pXNWpJRDhnYUdGemFDNTBiMU4wY21sdVp5aGxibU1wSURvZ2FHRnphRnh1ZlZ4dVhHNUlZWE5vTG5CeWIzUnZkSGx3WlM1ZmRYQmtZWFJsSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjE5MWNHUmhkR1VnYlhWemRDQmlaU0JwYlhCc1pXMWxiblJsWkNCaWVTQnpkV0pqYkdGemN5Y3BYRzU5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1NHRnphRnh1SWwxOSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqIEBwcmVzZXJ2ZVxuKGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vLyBjb25zdGFudHMgdGFibGVcbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXVxudmFyIGhyID0gWzB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyAoYnl0ZXMpIHtcbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMilcbiAgfVxuICByZXR1cm4gd29yZHNcbn1cblxuZnVuY3Rpb24gd29yZHNUb0J5dGVzICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXVxuICBmb3IgKHZhciBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpIHtcbiAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2sgKEgsIE0sIG9mZnNldCkge1xuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpXG4gICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXVxuXG4gICAgLy8gU3dhcFxuICAgIE1bb2Zmc2V0X2ldID0gKFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApXG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsXG4gIHZhciBhciwgYnIsIGNyLCBkciwgZXJcblxuICBhciA9IGFsID0gSFswXVxuICBiciA9IGJsID0gSFsxXVxuICBjciA9IGNsID0gSFsyXVxuICBkciA9IGRsID0gSFszXVxuICBlciA9IGVsID0gSFs0XVxuXG4gIC8vIGNvbXB1dGF0aW9uXG4gIHZhciB0XG4gIGZvciAoaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdCA9IChhbCArIE1bb2Zmc2V0ICsgemxbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmMihibCwgY2wsIGRsKSArIGhsWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYmwsIGNsLCBkbCkgKyBobFsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF1cbiAgICB9XG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc2xbaV0pXG4gICAgdCA9ICh0ICsgZWwpIHwgMFxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0XG5cbiAgICB0ID0gKGFyICsgTVtvZmZzZXQgKyB6cltpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjUoYnIsIGNyLCBkcikgKyBoclswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGY0KGJyLCBjciwgZHIpICsgaHJbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjIoYnIsIGNyLCBkcikgKyBoclszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjEoYnIsIGNyLCBkcikgKyBocls0XVxuICAgIH1cblxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNyW2ldKVxuICAgIHQgPSAodCArIGVyKSB8IDBcbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdFxuICB9XG5cbiAgLy8gaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgdCA9IChIWzFdICsgY2wgKyBkcikgfCAwXG4gIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpIHwgMFxuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKSB8IDBcbiAgSFszXSA9IChIWzRdICsgYWwgKyBicikgfCAwXG4gIEhbNF0gPSAoSFswXSArIGJsICsgY3IpIHwgMFxuICBIWzBdID0gdFxufVxuXG5mdW5jdGlvbiBmMSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjIgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHkpKSB8ICgofngpICYgKHopKSlcbn1cblxuZnVuY3Rpb24gZjMgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjQgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpKVxufVxuXG5mdW5jdGlvbiBmNSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICgoeSkgfCAofih6KSkpKVxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwIChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdXG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICd1dGY4JylcbiAgfVxuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpXG5cbiAgdmFyIG5CaXRzTGVmdCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuICB2YXIgbkJpdHNUb3RhbCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKVxuICBtWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKEgsIG0sIGkpXG4gIH1cblxuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgLy8gc2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXVxuXG4gICAgLy8gU3dhcFxuICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIH1cblxuICB2YXIgZGlnZXN0Ynl0ZXMgPSB3b3Jkc1RvQnl0ZXMoSClcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmlwZW1kMTYwXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WTNKbFlYUmxMV2hoYzJndmJtOWtaVjl0YjJSMWJHVnpMM0pwY0dWdFpERTJNQzlzYVdJdmNtbHdaVzFrTVRZd0xtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5cGNia055ZVhCMGIwcFRJSFl6TGpFdU1seHVZMjlrWlM1bmIyOW5iR1V1WTI5dEwzQXZZM0o1Y0hSdkxXcHpYRzRvWXlrZ01qQXdPUzB5TURFeklHSjVJRXBsWm1ZZ1RXOTBkQzRnUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM1Y2JtTnZaR1V1WjI5dloyeGxMbU52YlM5d0wyTnllWEIwYnkxcWN5OTNhV3RwTDB4cFkyVnVjMlZjYmlvdlhHNHZLaW9nUUhCeVpYTmxjblpsWEc0b1l5a2dNakF4TWlCaWVTQkR3NmxrY21saklFMWxjMjVwYkM0Z1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNWNibHh1VW1Wa2FYTjBjbWxpZFhScGIyNGdZVzVrSUhWelpTQnBiaUJ6YjNWeVkyVWdZVzVrSUdKcGJtRnllU0JtYjNKdGN5d2dkMmwwYUNCdmNpQjNhWFJvYjNWMElHMXZaR2xtYVdOaGRHbHZiaXdnWVhKbElIQmxjbTFwZEhSbFpDQndjbTkyYVdSbFpDQjBhR0YwSUhSb1pTQm1iMnhzYjNkcGJtY2dZMjl1WkdsMGFXOXVjeUJoY21VZ2JXVjBPbHh1WEc0Z0lDQWdMU0JTWldScGMzUnlhV0oxZEdsdmJuTWdiMllnYzI5MWNtTmxJR052WkdVZ2JYVnpkQ0J5WlhSaGFXNGdkR2hsSUdGaWIzWmxJR052Y0hseWFXZG9kQ0J1YjNScFkyVXNJSFJvYVhNZ2JHbHpkQ0J2WmlCamIyNWthWFJwYjI1eklHRnVaQ0IwYUdVZ1ptOXNiRzkzYVc1bklHUnBjMk5zWVdsdFpYSXVYRzRnSUNBZ0xTQlNaV1JwYzNSeWFXSjFkR2x2Ym5NZ2FXNGdZbWx1WVhKNUlHWnZjbTBnYlhWemRDQnlaWEJ5YjJSMVkyVWdkR2hsSUdGaWIzWmxJR052Y0hseWFXZG9kQ0J1YjNScFkyVXNJSFJvYVhNZ2JHbHpkQ0J2WmlCamIyNWthWFJwYjI1eklHRnVaQ0IwYUdVZ1ptOXNiRzkzYVc1bklHUnBjMk5zWVdsdFpYSWdhVzRnZEdobElHUnZZM1Z0Wlc1MFlYUnBiMjRnWVc1a0wyOXlJRzkwYUdWeUlHMWhkR1Z5YVdGc2N5QndjbTkyYVdSbFpDQjNhWFJvSUhSb1pTQmthWE4wY21saWRYUnBiMjR1WEc1Y2JsUklTVk1nVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1Fsa2dWRWhGSUVOUFVGbFNTVWRJVkNCSVQweEVSVkpUSUVGT1JDQkRUMDVVVWtsQ1ZWUlBVbE1nWENKQlV5QkpVMXdpSUVGT1JDQkJUbGtnUlZoUVVrVlRVeUJQVWlCSlRWQk1TVVZFSUZkQlVsSkJUbFJKUlZNc0lFbE9RMHhWUkVsT1J5d2dRbFZVSUU1UFZDQk1TVTFKVkVWRUlGUlBMQ0JVU0VVZ1NVMVFURWxGUkNCWFFWSlNRVTVVU1VWVElFOUdJRTFGVWtOSVFVNVVRVUpKVEVsVVdTQkJUa1FnUmtsVVRrVlRVeUJHVDFJZ1FTQlFRVkpVU1VOVlRFRlNJRkJWVWxCUFUwVWdRVkpGSUVSSlUwTk1RVWxOUlVRdUlFbE9JRTVQSUVWV1JVNVVJRk5JUVV4TUlGUklSU0JEVDFCWlVrbEhTRlFnU0U5TVJFVlNJRTlTSUVOUFRsUlNTVUpWVkU5U1V5QkNSU0JNU1VGQ1RFVWdSazlTSUVGT1dTQkVTVkpGUTFRc0lFbE9SRWxTUlVOVUxDQkpUa05KUkVWT1ZFRk1MQ0JUVUVWRFNVRk1MQ0JGV0VWTlVFeEJVbGtzSUU5U0lFTlBUbE5GVVZWRlRsUkpRVXdnUkVGTlFVZEZVeUFvU1U1RFRGVkVTVTVITENCQ1ZWUWdUazlVSUV4SlRVbFVSVVFnVkU4c0lGQlNUME5WVWtWTlJVNVVJRTlHSUZOVlFsTlVTVlJWVkVVZ1IwOVBSRk1nVDFJZ1UwVlNWa2xEUlZNN0lFeFBVMU1nVDBZZ1ZWTkZMQ0JFUVZSQkxDQlBVaUJRVWs5R1NWUlRPeUJQVWlCQ1ZWTkpUa1ZUVXlCSlRsUkZVbEpWVUZSSlQwNHBJRWhQVjBWV1JWSWdRMEZWVTBWRUlFRk9SQ0JQVGlCQlRsa2dWRWhGVDFKWklFOUdJRXhKUVVKSlRFbFVXU3dnVjBoRlZFaEZVaUJKVGlCRFQwNVVVa0ZEVkN3Z1UxUlNTVU5VSUV4SlFVSkpURWxVV1N3Z1QxSWdWRTlTVkNBb1NVNURURlZFU1U1SElFNUZSMHhKUjBWT1EwVWdUMUlnVDFSSVJWSlhTVk5GS1NCQlVrbFRTVTVISUVsT0lFRk9XU0JYUVZrZ1QxVlVJRTlHSUZSSVJTQlZVMFVnVDBZZ1ZFaEpVeUJUVDBaVVYwRlNSU3dnUlZaRlRpQkpSaUJCUkZaSlUwVkVJRTlHSUZSSVJTQlFUMU5UU1VKSlRFbFVXU0JQUmlCVFZVTklJRVJCVFVGSFJTNWNiaW92WEc1Y2JpOHZJR052Ym5OMFlXNTBjeUIwWVdKc1pWeHVkbUZ5SUhwc0lEMGdXMXh1SUNBd0xDQXhMQ0F5TENBekxDQTBMQ0ExTENBMkxDQTNMQ0E0TENBNUxDQXhNQ3dnTVRFc0lERXlMQ0F4TXl3Z01UUXNJREUxTEZ4dUlDQTNMQ0EwTENBeE15d2dNU3dnTVRBc0lEWXNJREUxTENBekxDQXhNaXdnTUN3Z09Td2dOU3dnTWl3Z01UUXNJREV4TENBNExGeHVJQ0F6TENBeE1Dd2dNVFFzSURRc0lEa3NJREUxTENBNExDQXhMQ0F5TENBM0xDQXdMQ0EyTENBeE15d2dNVEVzSURVc0lERXlMRnh1SUNBeExDQTVMQ0F4TVN3Z01UQXNJREFzSURnc0lERXlMQ0EwTENBeE15d2dNeXdnTnl3Z01UVXNJREUwTENBMUxDQTJMQ0F5TEZ4dUlDQTBMQ0F3TENBMUxDQTVMQ0EzTENBeE1pd2dNaXdnTVRBc0lERTBMQ0F4TENBekxDQTRMQ0F4TVN3Z05pd2dNVFVzSURFelhHNWRYRzVjYm5aaGNpQjZjaUE5SUZ0Y2JpQWdOU3dnTVRRc0lEY3NJREFzSURrc0lESXNJREV4TENBMExDQXhNeXdnTml3Z01UVXNJRGdzSURFc0lERXdMQ0F6TENBeE1peGNiaUFnTml3Z01URXNJRE1zSURjc0lEQXNJREV6TENBMUxDQXhNQ3dnTVRRc0lERTFMQ0E0TENBeE1pd2dOQ3dnT1N3Z01Td2dNaXhjYmlBZ01UVXNJRFVzSURFc0lETXNJRGNzSURFMExDQTJMQ0E1TENBeE1Td2dPQ3dnTVRJc0lESXNJREV3TENBd0xDQTBMQ0F4TXl4Y2JpQWdPQ3dnTml3Z05Dd2dNU3dnTXl3Z01URXNJREUxTENBd0xDQTFMQ0F4TWl3Z01pd2dNVE1zSURrc0lEY3NJREV3TENBeE5DeGNiaUFnTVRJc0lERTFMQ0F4TUN3Z05Dd2dNU3dnTlN3Z09Dd2dOeXdnTml3Z01pd2dNVE1zSURFMExDQXdMQ0F6TENBNUxDQXhNVnh1WFZ4dVhHNTJZWElnYzJ3Z1BTQmJYRzRnSURFeExDQXhOQ3dnTVRVc0lERXlMQ0ExTENBNExDQTNMQ0E1TENBeE1Td2dNVE1zSURFMExDQXhOU3dnTml3Z055d2dPU3dnT0N4Y2JpQWdOeXdnTml3Z09Dd2dNVE1zSURFeExDQTVMQ0EzTENBeE5Td2dOeXdnTVRJc0lERTFMQ0E1TENBeE1Td2dOeXdnTVRNc0lERXlMRnh1SUNBeE1Td2dNVE1zSURZc0lEY3NJREUwTENBNUxDQXhNeXdnTVRVc0lERTBMQ0E0TENBeE15d2dOaXdnTlN3Z01USXNJRGNzSURVc1hHNGdJREV4TENBeE1pd2dNVFFzSURFMUxDQXhOQ3dnTVRVc0lEa3NJRGdzSURrc0lERTBMQ0ExTENBMkxDQTRMQ0EyTENBMUxDQXhNaXhjYmlBZ09Td2dNVFVzSURVc0lERXhMQ0EyTENBNExDQXhNeXdnTVRJc0lEVXNJREV5TENBeE15d2dNVFFzSURFeExDQTRMQ0ExTENBMlhHNWRYRzVjYm5aaGNpQnpjaUE5SUZ0Y2JpQWdPQ3dnT1N3Z09Td2dNVEVzSURFekxDQXhOU3dnTVRVc0lEVXNJRGNzSURjc0lEZ3NJREV4TENBeE5Dd2dNVFFzSURFeUxDQTJMRnh1SUNBNUxDQXhNeXdnTVRVc0lEY3NJREV5TENBNExDQTVMQ0F4TVN3Z055d2dOeXdnTVRJc0lEY3NJRFlzSURFMUxDQXhNeXdnTVRFc1hHNGdJRGtzSURjc0lERTFMQ0F4TVN3Z09Dd2dOaXdnTml3Z01UUXNJREV5TENBeE15d2dOU3dnTVRRc0lERXpMQ0F4TXl3Z055d2dOU3hjYmlBZ01UVXNJRFVzSURnc0lERXhMQ0F4TkN3Z01UUXNJRFlzSURFMExDQTJMQ0E1TENBeE1pd2dPU3dnTVRJc0lEVXNJREUxTENBNExGeHVJQ0E0TENBMUxDQXhNaXdnT1N3Z01USXNJRFVzSURFMExDQTJMQ0E0TENBeE15d2dOaXdnTlN3Z01UVXNJREV6TENBeE1Td2dNVEZjYmwxY2JseHVkbUZ5SUdoc0lEMGdXekI0TURBd01EQXdNREFzSURCNE5VRTRNamM1T1Rrc0lEQjROa1ZFT1VWQ1FURXNJREI0T0VZeFFrSkRSRU1zSURCNFFUazFNMFpFTkVWZFhHNTJZWElnYUhJZ1BTQmJNSGcxTUVFeU9FSkZOaXdnTUhnMVF6UkVSREV5TkN3Z01IZzJSRGN3TTBWR015d2dNSGczUVRaRU56WkZPU3dnTUhnd01EQXdNREF3TUYxY2JseHVablZ1WTNScGIyNGdZbmwwWlhOVWIxZHZjbVJ6SUNoaWVYUmxjeWtnZTF4dUlDQjJZWElnZDI5eVpITWdQU0JiWFZ4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z1lpQTlJREE3SUdrZ1BDQmllWFJsY3k1c1pXNW5kR2c3SUdrckt5d2dZaUFyUFNBNEtTQjdYRzRnSUNBZ2QyOXlaSE5iWWlBK1BqNGdOVjBnZkQwZ1lubDBaWE5iYVYwZ1BEd2dLREkwSUMwZ1lpQWxJRE15S1Z4dUlDQjlYRzRnSUhKbGRIVnliaUIzYjNKa2MxeHVmVnh1WEc1bWRXNWpkR2x2YmlCM2IzSmtjMVJ2UW5sMFpYTWdLSGR2Y21SektTQjdYRzRnSUhaaGNpQmllWFJsY3lBOUlGdGRYRzRnSUdadmNpQW9kbUZ5SUdJZ1BTQXdPeUJpSUR3Z2QyOXlaSE11YkdWdVozUm9JQ29nTXpJN0lHSWdLejBnT0NrZ2UxeHVJQ0FnSUdKNWRHVnpMbkIxYzJnb0tIZHZjbVJ6VzJJZ1BqNCtJRFZkSUQ0K1BpQW9NalFnTFNCaUlDVWdNeklwS1NBbUlEQjRSa1lwWEc0Z0lIMWNiaUFnY21WMGRYSnVJR0o1ZEdWelhHNTlYRzVjYm1aMWJtTjBhVzl1SUhCeWIyTmxjM05DYkc5amF5QW9TQ3dnVFN3Z2IyWm1jMlYwS1NCN1hHNGdJQzh2SUhOM1lYQWdaVzVrYVdGdVhHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnTVRZN0lHa3JLeWtnZTF4dUlDQWdJSFpoY2lCdlptWnpaWFJmYVNBOUlHOW1abk5sZENBcklHbGNiaUFnSUNCMllYSWdUVjl2Wm1aelpYUmZhU0E5SUUxYmIyWm1jMlYwWDJsZFhHNWNiaUFnSUNBdkx5QlRkMkZ3WEc0Z0lDQWdUVnR2Wm1aelpYUmZhVjBnUFNBb1hHNGdJQ0FnSUNBb0tDaE5YMjltWm5ObGRGOXBJRHc4SURncElId2dLRTFmYjJabWMyVjBYMmtnUGo0K0lESTBLU2tnSmlBd2VEQXdabVl3TUdabUtTQjhYRzRnSUNBZ0lDQW9LQ2hOWDI5bVpuTmxkRjlwSUR3OElESTBLU0I4SUNoTlgyOW1abk5sZEY5cElENCtQaUE0S1NrZ0ppQXdlR1ptTURCbVpqQXdLVnh1SUNBZ0lDbGNiaUFnZlZ4dVhHNGdJQzh2SUZkdmNtdHBibWNnZG1GeWFXRmliR1Z6WEc0Z0lIWmhjaUJoYkN3Z1ltd3NJR05zTENCa2JDd2daV3hjYmlBZ2RtRnlJR0Z5TENCaWNpd2dZM0lzSUdSeUxDQmxjbHh1WEc0Z0lHRnlJRDBnWVd3Z1BTQklXekJkWEc0Z0lHSnlJRDBnWW13Z1BTQklXekZkWEc0Z0lHTnlJRDBnWTJ3Z1BTQklXekpkWEc0Z0lHUnlJRDBnWkd3Z1BTQklXek5kWEc0Z0lHVnlJRDBnWld3Z1BTQklXelJkWEc1Y2JpQWdMeThnWTI5dGNIVjBZWFJwYjI1Y2JpQWdkbUZ5SUhSY2JpQWdabTl5SUNocElEMGdNRHNnYVNBOElEZ3dPeUJwSUNzOUlERXBJSHRjYmlBZ0lDQjBJRDBnS0dGc0lDc2dUVnR2Wm1aelpYUWdLeUI2YkZ0cFhWMHBJSHdnTUZ4dUlDQWdJR2xtSUNocElEd2dNVFlwSUh0Y2JpQWdJQ0FnSUhRZ0t6MGdaakVvWW13c0lHTnNMQ0JrYkNrZ0t5Qm9iRnN3WFZ4dUlDQWdJSDBnWld4elpTQnBaaUFvYVNBOElETXlLU0I3WEc0Z0lDQWdJQ0IwSUNzOUlHWXlLR0pzTENCamJDd2daR3dwSUNzZ2FHeGJNVjFjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2tnUENBME9Da2dlMXh1SUNBZ0lDQWdkQ0FyUFNCbU15aGliQ3dnWTJ3c0lHUnNLU0FySUdoc1d6SmRYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHBJRHdnTmpRcElIdGNiaUFnSUNBZ0lIUWdLejBnWmpRb1ltd3NJR05zTENCa2JDa2dLeUJvYkZzelhWeHVJQ0FnSUgwZ1pXeHpaU0I3THk4Z2FXWWdLR2s4T0RBcElIdGNiaUFnSUNBZ0lIUWdLejBnWmpVb1ltd3NJR05zTENCa2JDa2dLeUJvYkZzMFhWeHVJQ0FnSUgxY2JpQWdJQ0IwSUQwZ2RDQjhJREJjYmlBZ0lDQjBJRDBnY205MGJDaDBMQ0J6YkZ0cFhTbGNiaUFnSUNCMElEMGdLSFFnS3lCbGJDa2dmQ0F3WEc0Z0lDQWdZV3dnUFNCbGJGeHVJQ0FnSUdWc0lEMGdaR3hjYmlBZ0lDQmtiQ0E5SUhKdmRHd29ZMndzSURFd0tWeHVJQ0FnSUdOc0lEMGdZbXhjYmlBZ0lDQmliQ0E5SUhSY2JseHVJQ0FnSUhRZ1BTQW9ZWElnS3lCTlcyOW1abk5sZENBcklIcHlXMmxkWFNrZ2ZDQXdYRzRnSUNBZ2FXWWdLR2tnUENBeE5pa2dlMXh1SUNBZ0lDQWdkQ0FyUFNCbU5TaGljaXdnWTNJc0lHUnlLU0FySUdoeVd6QmRYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHBJRHdnTXpJcElIdGNiaUFnSUNBZ0lIUWdLejBnWmpRb1luSXNJR055TENCa2Npa2dLeUJvY2xzeFhWeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FTQThJRFE0S1NCN1hHNGdJQ0FnSUNCMElDczlJR1l6S0dKeUxDQmpjaXdnWkhJcElDc2dhSEpiTWwxY2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0drZ1BDQTJOQ2tnZTF4dUlDQWdJQ0FnZENBclBTQm1NaWhpY2l3Z1kzSXNJR1J5S1NBcklHaHlXek5kWEc0Z0lDQWdmU0JsYkhObElIc3ZMeUJwWmlBb2FUdzRNQ2tnZTF4dUlDQWdJQ0FnZENBclBTQm1NU2hpY2l3Z1kzSXNJR1J5S1NBcklHaHlXelJkWEc0Z0lDQWdmVnh1WEc0Z0lDQWdkQ0E5SUhRZ2ZDQXdYRzRnSUNBZ2RDQTlJSEp2ZEd3b2RDd2djM0piYVYwcFhHNGdJQ0FnZENBOUlDaDBJQ3NnWlhJcElId2dNRnh1SUNBZ0lHRnlJRDBnWlhKY2JpQWdJQ0JsY2lBOUlHUnlYRzRnSUNBZ1pISWdQU0J5YjNSc0tHTnlMQ0F4TUNsY2JpQWdJQ0JqY2lBOUlHSnlYRzRnSUNBZ1luSWdQU0IwWEc0Z0lIMWNibHh1SUNBdkx5QnBiblJsY20xbFpHbGhkR1VnYUdGemFDQjJZV3gxWlZ4dUlDQjBJRDBnS0VoYk1WMGdLeUJqYkNBcklHUnlLU0I4SURCY2JpQWdTRnN4WFNBOUlDaElXekpkSUNzZ1pHd2dLeUJsY2lrZ2ZDQXdYRzRnSUVoYk1sMGdQU0FvU0ZzelhTQXJJR1ZzSUNzZ1lYSXBJSHdnTUZ4dUlDQklXek5kSUQwZ0tFaGJORjBnS3lCaGJDQXJJR0p5S1NCOElEQmNiaUFnU0ZzMFhTQTlJQ2hJV3pCZElDc2dZbXdnS3lCamNpa2dmQ0F3WEc0Z0lFaGJNRjBnUFNCMFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdZeElDaDRMQ0I1TENCNktTQjdYRzRnSUhKbGRIVnliaUFvS0hncElGNGdLSGtwSUY0Z0tIb3BLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm1NaUFvZUN3Z2VTd2dlaWtnZTF4dUlDQnlaWFIxY200Z0tDZ29lQ2tnSmlBb2VTa3BJSHdnS0NoK2VDa2dKaUFvZWlrcEtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCbU15QW9lQ3dnZVN3Z2Vpa2dlMXh1SUNCeVpYUjFjbTRnS0Nnb2VDa2dmQ0FvZmloNUtTa3BJRjRnS0hvcEtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCbU5DQW9lQ3dnZVN3Z2Vpa2dlMXh1SUNCeVpYUjFjbTRnS0Nnb2VDa2dKaUFvZWlrcElId2dLQ2g1S1NBbUlDaCtLSG9wS1NrcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUdZMUlDaDRMQ0I1TENCNktTQjdYRzRnSUhKbGRIVnliaUFvS0hncElGNGdLQ2g1S1NCOElDaCtLSG9wS1NrcFhHNTlYRzVjYm1aMWJtTjBhVzl1SUhKdmRHd2dLSGdzSUc0cElIdGNiaUFnY21WMGRYSnVJQ2g0SUR3OElHNHBJSHdnS0hnZ1BqNCtJQ2d6TWlBdElHNHBLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnlhWEJsYldReE5qQWdLRzFsYzNOaFoyVXBJSHRjYmlBZ2RtRnlJRWdnUFNCYk1IZzJOelExTWpNd01Td2dNSGhGUmtORVFVSTRPU3dnTUhnNU9FSkJSRU5HUlN3Z01IZ3hNRE15TlRRM05pd2dNSGhETTBReVJURkdNRjFjYmx4dUlDQnBaaUFvZEhsd1pXOW1JRzFsYzNOaFoyVWdQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnYldWemMyRm5aU0E5SUc1bGR5QkNkV1ptWlhJb2JXVnpjMkZuWlN3Z0ozVjBaamduS1Z4dUlDQjlYRzVjYmlBZ2RtRnlJRzBnUFNCaWVYUmxjMVJ2VjI5eVpITW9iV1Z6YzJGblpTbGNibHh1SUNCMllYSWdia0pwZEhOTVpXWjBJRDBnYldWemMyRm5aUzVzWlc1bmRHZ2dLaUE0WEc0Z0lIWmhjaUJ1UW1sMGMxUnZkR0ZzSUQwZ2JXVnpjMkZuWlM1c1pXNW5kR2dnS2lBNFhHNWNiaUFnTHk4Z1FXUmtJSEJoWkdScGJtZGNiaUFnYlZ0dVFtbDBjMHhsWm5RZ1BqNCtJRFZkSUh3OUlEQjRPREFnUER3Z0tESTBJQzBnYmtKcGRITk1aV1owSUNVZ016SXBYRzRnSUcxYktDZ29ia0pwZEhOTVpXWjBJQ3NnTmpRcElENCtQaUE1S1NBOFBDQTBLU0FySURFMFhTQTlJQ2hjYmlBZ0lDQW9LQ2h1UW1sMGMxUnZkR0ZzSUR3OElEZ3BJSHdnS0c1Q2FYUnpWRzkwWVd3Z1BqNCtJREkwS1NrZ0ppQXdlREF3Wm1Zd01HWm1LU0I4WEc0Z0lDQWdLQ2dvYmtKcGRITlViM1JoYkNBOFBDQXlOQ2tnZkNBb2JrSnBkSE5VYjNSaGJDQStQajRnT0NrcElDWWdNSGhtWmpBd1ptWXdNQ2xjYmlBZ0tWeHVYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JTNXNaVzVuZEdnN0lHa2dLejBnTVRZcElIdGNiaUFnSUNCd2NtOWpaWE56UW14dlkyc29TQ3dnYlN3Z2FTbGNiaUFnZlZ4dVhHNGdJQzh2SUhOM1lYQWdaVzVrYVdGdVhHNGdJR1p2Y2lBb2FTQTlJREE3SUdrZ1BDQTFPeUJwS3lzcElIdGNiaUFnSUNBdkx5QnphRzl5ZEdOMWRGeHVJQ0FnSUhaaGNpQklYMmtnUFNCSVcybGRYRzVjYmlBZ0lDQXZMeUJUZDJGd1hHNGdJQ0FnU0Z0cFhTQTlJQ2dvS0VoZmFTQThQQ0E0S1NCOElDaElYMmtnUGo0K0lESTBLU2tnSmlBd2VEQXdabVl3TUdabUtTQjhYRzRnSUNBZ0lDQW9LQ2hJWDJrZ1BEd2dNalFwSUh3Z0tFaGZhU0ErUGo0Z09Da3BJQ1lnTUhobVpqQXdabVl3TUNsY2JpQWdmVnh1WEc0Z0lIWmhjaUJrYVdkbGMzUmllWFJsY3lBOUlIZHZjbVJ6Vkc5Q2VYUmxjeWhJS1Z4dUlDQnlaWFIxY200Z2JtVjNJRUoxWm1abGNpaGthV2RsYzNSaWVYUmxjeWxjYm4xY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQnlhWEJsYldReE5qQmNiaUpkZlE9PSIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvYXNuMS5qc1xuLy8gRmVkb3IsIHlvdSBhcmUgYW1hemluZy5cblxudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJyk7XG5cbnZhciBSU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVByaXZhdGVLZXknLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMicpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2NvZWZmaWNpZW50JykuaW50KClcbiAgKTtcbn0pO1xuZXhwb3J0cy5SU0FQcml2YXRlS2V5ID0gUlNBUHJpdmF0ZUtleTtcblxudmFyIFJTQVB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdSU0FQdWJsaWNLZXknLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKVxuICApO1xufSk7XG5leHBvcnRzLlJTQVB1YmxpY0tleSA9IFJTQVB1YmxpY0tleTtcblxudmFyIFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5JykuYml0c3RyKClcbiAgKTtcbn0pO1xuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG5cbnZhciBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuMS5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ25vbmUnKS5udWxsXygpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2N1cnZlJykub2JqaWQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgICAgIHRoaXMua2V5KCdnJykuaW50KClcbiAgICAgICkub3B0aW9uYWwoKVxuICApO1xufSk7XG5cbnZhciBQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKTtcbn0pO1xuZXhwb3J0cy5Qcml2YXRlS2V5ID0gUHJpdmF0ZUtleUluZm87XG52YXIgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICB0aGlzLmtleSgnZGVjcnlwdCcpLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2tkZScpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdrZGVwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgICAgICB0aGlzLmtleSgnc2FsdCcpLm9jdHN0cigpLFxuICAgICAgICAgICAgdGhpcy5rZXkoJ2l0ZXJzJykuaW50KClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRoaXMua2V5KCdjaXBoZXInKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2FsZ28nKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdpdicpLm9jdHN0cigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gICk7XG59KTtcblxuZXhwb3J0cy5FbmNyeXB0ZWRQcml2YXRlS2V5ID0gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm87XG5cbnZhciBEU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0RTQVByaXZhdGVLZXknLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2cnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHViX2tleScpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2X2tleScpLmludCgpXG4gICk7XG59KTtcbmV4cG9ydHMuRFNBUHJpdmF0ZUtleSA9IERTQVByaXZhdGVLZXk7XG5cbmV4cG9ydHMuRFNBcGFyYW0gPSBhc24xLmRlZmluZSgnRFNBcGFyYW0nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW50KCk7XG59KTtcbnZhciBFQ1ByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnRUNQcml2YXRlS2V5JywgZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCkuZXhwbGljaXQoMCkudXNlKEVDUGFyYW1ldGVycyksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLm9wdGlvbmFsKCkuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgKTtcbn0pO1xuZXhwb3J0cy5FQ1ByaXZhdGVLZXkgPSBFQ1ByaXZhdGVLZXk7XG52YXIgRUNQYXJhbWV0ZXJzID0gYXNuMS5kZWZpbmUoJ0VDUGFyYW1ldGVycycsIGZ1bmN0aW9uKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgbmFtZWRDdXJ2ZTogdGhpcy5vYmppZCgpXG4gIH0pO1xufSk7XG5cbmV4cG9ydHMuc2lnbmF0dXJlID0gYXNuMS5kZWZpbmUoJ3NpZ25hdHVyZScsIGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgncicpLmludCgpLFxuICAgIHRoaXMua2V5KCdzJykuaW50KClcbiAgKTtcbn0pO1xuIiwidmFyIGFzbjEgPSBleHBvcnRzO1xuXG5hc24xLmJpZ251bSA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbmFzbjEuZGVmaW5lID0gcmVxdWlyZSgnLi9hc24xL2FwaScpLmRlZmluZTtcbmFzbjEuYmFzZSA9IHJlcXVpcmUoJy4vYXNuMS9iYXNlJyk7XG5hc24xLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vYXNuMS9jb25zdGFudHMnKTtcbmFzbjEuZGVjb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZGVjb2RlcnMnKTtcbmFzbjEuZW5jb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZW5jb2RlcnMnKTtcbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJFbmNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRW5jb2RlcjtcblxuREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLnRyZWUuX2VuY29kZShkYXRhLCByZXBvcnRlcikuam9pbigpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uIGVuY29kZUNvbXBvc2l0ZSh0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50KSB7XG4gIHZhciBlbmNvZGVkVGFnID0gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHRoaXMucmVwb3J0ZXIpO1xuXG4gIC8vIFNob3J0IGZvcm1cbiAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgMHg4MCkge1xuICAgIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDIpO1xuICAgIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gICAgaGVhZGVyWzFdID0gY29udGVudC5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBoZWFkZXIsIGNvbnRlbnQgXSk7XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgLy8gQ291bnQgb2N0ZXRzIHJlcXVpcmVkIHRvIHN0b3JlIGxlbmd0aFxuICB2YXIgbGVuT2N0ZXRzID0gMTtcbiAgZm9yICh2YXIgaSA9IGNvbnRlbnQubGVuZ3RoOyBpID49IDB4MTAwOyBpID4+PSA4KVxuICAgIGxlbk9jdGV0cysrO1xuXG4gIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDEgKyAxICsgbGVuT2N0ZXRzKTtcbiAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgaGVhZGVyWzFdID0gMHg4MCB8IGxlbk9jdGV0cztcblxuICBmb3IgKHZhciBpID0gMSArIGxlbk9jdGV0cywgaiA9IGNvbnRlbnQubGVuZ3RoOyBqID4gMDsgaS0tLCBqID4+PSA4KVxuICAgIGhlYWRlcltpXSA9IGogJiAweGZmO1xuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZVN0ciA9IGZ1bmN0aW9uIGVuY29kZVN0cihzdHIsIHRhZykge1xuICBpZiAodGFnID09PSAnb2N0c3RyJylcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICBlbHNlIGlmICh0YWcgPT09ICdiaXRzdHInKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgc3RyLnVudXNlZCB8IDAsIHN0ci5kYXRhIF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdW5zdXBwb3J0ZWQnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKG51bS5zaWduID09PSBmYWxzZSAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBkZWNvZGVycyA9IGV4cG9ydHM7XG5cbmRlY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5kZWNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJEZWNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJhc2UuRGVjb2RlckJ1ZmZlcikpXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMudHJlZS5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgJ0ZhaWxlZCB0byBwZWVrIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG5cbiAgcmV0dXJuIGRlY29kZWRUYWcudGFnID09PSB0YWcgfHwgZGVjb2RlZFRhZy50YWdTdHIgPT09IHRhZyB8fCBhbnk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGFnID0gZnVuY3Rpb24gZGVjb2RlVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY29kZSB0YWcgb2YgXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkVGFnLnByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBsZW5ndGggb2YgXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gRmFpbHVyZVxuICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIGlmICghYW55ICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZyAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicgIT09IHRhZykge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICB9XG5cbiAgaWYgKGRlY29kZWRUYWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoLi4uIGZpbmQgRU5EIHRhZ1xuICB2YXIgc3RhdGUgPSBidWZmZXIuc3RhcnQoKTtcbiAgdmFyIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICAgIGJ1ZmZlcixcbiAgICAgICdGYWlsZWQgdG8gc2tpcCBpbmRlZmluaXRlIGxlbmd0aCBib2R5OiBcIicgKyB0aGlzLnRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIHJldHVybiBidWZmZXIuY3V0KHN0YXRlKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwVW50aWxFbmQgPSBmdW5jdGlvbiBza2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgICByZXR1cm4gbGVuO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2Rlcikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBwb3NzaWJsZUVuZCA9IHRoaXMuX3BlZWtUYWcoYnVmZmVyLCAnZW5kJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHBvc3NpYmxlRW5kKSlcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcblxuICAgIHZhciByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ29jdHN0cicpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICB2YXIgdW51c2VkID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxuICAgICAgcmV0dXJuIHVudXNlZDtcblxuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArICcgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU9iamlkID0gZnVuY3Rpb24gZGVjb2RlT2JqaWQoYnVmZmVyLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICB2YXIgaWRlbnQgPSAwO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgc3ViaWRlbnQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWRlbnQgPDw9IDc7XG4gICAgaWRlbnQgfD0gc3ViaWRlbnQgJiAweDdmO1xuICAgIGlmICgoc3ViaWRlbnQgJiAweDgwKSA9PT0gMCkge1xuICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG4gICAgICBpZGVudCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChzdWJpZGVudCAmIDB4ODApXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG5cbiAgdmFyIGZpcnN0ID0gKGlkZW50aWZpZXJzWzBdIC8gNDApIHwgMDtcbiAgdmFyIHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XG5cbiAgaWYgKHJlbGF0aXZlKVxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xuICBlbHNlXG4gICAgcmVzdWx0ID0gW2ZpcnN0LCBzZWNvbmRdLmNvbmNhdChpZGVudGlmaWVycy5zbGljZSgxKSk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXN1bHQgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJyAnKV07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0RlY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVOdWxsID0gZnVuY3Rpb24gZGVjb2RlTnVsbChidWZmZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlQm9vbCA9IGZ1bmN0aW9uIGRlY29kZUJvb2woYnVmZmVyKSB7XG4gIHZhciByZXMgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzICE9PSAwO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChidWZmZXIsIHZhbHVlcykge1xuICAvLyBCaWdpbnQsIHJldHVybiBhcyBpdCBpcyAoYXNzdW1lIGJpZyBlbmRpYW4pXG4gIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gIHZhciByZXMgPSBuZXcgYmlnbnVtKHJhdyk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXMgPSB2YWx1ZXNbcmVzLnRvU3RyaW5nKDEwKV0gfHwgcmVzO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXREZWNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGRlckRlY29kZVRhZyhidWYsIGZhaWwpIHtcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcih0YWcpKVxuICAgIHJldHVybiB0YWc7XG5cbiAgdmFyIGNscyA9IGRlci50YWdDbGFzc1t0YWcgPj4gNl07XG4gIHZhciBwcmltaXRpdmUgPSAodGFnICYgMHgyMCkgPT09IDA7XG5cbiAgLy8gTXVsdGktb2N0ZXQgdGFnIC0gbG9hZFxuICBpZiAoKHRhZyAmIDB4MWYpID09PSAweDFmKSB7XG4gICAgdmFyIG9jdCA9IHRhZztcbiAgICB0YWcgPSAwO1xuICAgIHdoaWxlICgob2N0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIG9jdCA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgICBpZiAoYnVmLmlzRXJyb3Iob2N0KSlcbiAgICAgICAgcmV0dXJuIG9jdDtcblxuICAgICAgdGFnIDw8PSA3O1xuICAgICAgdGFnIHw9IG9jdCAmIDB4N2Y7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhZyAmPSAweDFmO1xuICB9XG4gIHZhciB0YWdTdHIgPSBkZXIudGFnW3RhZ107XG5cbiAgcmV0dXJuIHtcbiAgICBjbHM6IGNscyxcbiAgICBwcmltaXRpdmU6IHByaW1pdGl2ZSxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWdTdHI6IHRhZ1N0clxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXJEZWNvZGVMZW4oYnVmLCBwcmltaXRpdmUsIGZhaWwpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgLy8gSW5kZWZpbml0ZSBmb3JtXG4gIGlmICghcHJpbWl0aXZlICYmIGxlbiA9PT0gMHg4MClcbiAgICByZXR1cm4gbnVsbDtcblxuICAvLyBEZWZpbml0ZSBmb3JtXG4gIGlmICgobGVuICYgMHg4MCkgPT09IDApIHtcbiAgICAvLyBTaG9ydCBmb3JtXG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICB2YXIgbnVtID0gbGVuICYgMHg3ZjtcbiAgaWYgKG51bSA+PSA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG4iLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XG5cbmV4cG9ydHMudGFnID0ge1xuICAweDAwOiAnZW5kJyxcbiAgMHgwMTogJ2Jvb2wnLFxuICAweDAyOiAnaW50JyxcbiAgMHgwMzogJ2JpdHN0cicsXG4gIDB4MDQ6ICdvY3RzdHInLFxuICAweDA1OiAnbnVsbF8nLFxuICAweDA2OiAnb2JqaWQnLFxuICAweDA3OiAnb2JqRGVzYycsXG4gIDB4MDg6ICdleHRlcm5hbCcsXG4gIDB4MDk6ICdyZWFsJyxcbiAgMHgwYTogJ2VudW0nLFxuICAweDBiOiAnZW1iZWQnLFxuICAweDBjOiAndXRmOHN0cicsXG4gIDB4MGQ6ICdyZWxhdGl2ZU9pZCcsXG4gIDB4MTA6ICdzZXEnLFxuICAweDExOiAnc2V0JyxcbiAgMHgxMjogJ251bXN0cicsXG4gIDB4MTM6ICdwcmludHN0cicsXG4gIDB4MTQ6ICd0NjFzdHInLFxuICAweDE1OiAndmlkZW9zdHInLFxuICAweDE2OiAnaWE1c3RyJyxcbiAgMHgxNzogJ3V0Y3RpbWUnLFxuICAweDE4OiAnZ2VudGltZScsXG4gIDB4MTk6ICdncmFwaHN0cicsXG4gIDB4MWE6ICdpc282NDZzdHInLFxuICAweDFiOiAnZ2Vuc3RyJyxcbiAgMHgxYzogJ3VuaXN0cicsXG4gIDB4MWQ6ICdjaGFyc3RyJyxcbiAgMHgxZTogJ2JtcHN0cidcbn07XG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XG4iLCJ2YXIgYmFzZSA9IGV4cG9ydHM7XG5cbmJhc2UuUmVwb3J0ZXIgPSByZXF1aXJlKCcuL3JlcG9ydGVyJykuUmVwb3J0ZXI7XG5iYXNlLkRlY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkRlY29kZXJCdWZmZXI7XG5iYXNlLkVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkVuY29kZXJCdWZmZXI7XG5iYXNlLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIFJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5fcmVwb3J0ZXJTdGF0ZSA9IHtcbiAgICBvYmo6IG51bGwsXG4gICAgcGF0aDogW10sXG4gICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcbiAgICBlcnJvcnM6IFtdXG4gIH07XG59XG5leHBvcnRzLlJlcG9ydGVyID0gUmVwb3J0ZXI7XG5cblJlcG9ydGVyLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmV0dXJuIHsgb2JqOiBzdGF0ZS5vYmosIHBhdGhMZW46IHN0YXRlLnBhdGgubGVuZ3RoIH07XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZGF0YSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLm9iaiA9IGRhdGEub2JqO1xuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBkYXRhLnBhdGhMZW4pO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyS2V5ID0gZnVuY3Rpb24gZW50ZXJLZXkoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGgucHVzaChrZXkpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlS2V5ID0gZnVuY3Rpb24gbGVhdmVLZXkoaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBpbmRleCAtIDEpO1xuICBpZiAoc3RhdGUub2JqICE9PSBudWxsKVxuICAgIHN0YXRlLm9ialtrZXldID0gdmFsdWU7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJPYmplY3QgPSBmdW5jdGlvbiBlbnRlck9iamVjdCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgcHJldiA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0ge307XG4gIHJldHVybiBwcmV2O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlT2JqZWN0ID0gZnVuY3Rpb24gbGVhdmVPYmplY3QocHJldikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBub3cgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHByZXY7XG4gIHJldHVybiBub3c7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgdmFyIGVycjtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgaW5oZXJpdGVkID0gbXNnIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbiAgaWYgKGluaGVyaXRlZCkge1xuICAgIGVyciA9IG1zZztcbiAgfSBlbHNlIHtcbiAgICBlcnIgPSBuZXcgUmVwb3J0ZXJFcnJvcihzdGF0ZS5wYXRoLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gJ1snICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyAnXSc7XG4gICAgfSkuam9pbignJyksIG1zZy5tZXNzYWdlIHx8IG1zZywgbXNnLnN0YWNrKTtcbiAgfVxuXG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHRocm93IGVycjtcblxuICBpZiAoIWluaGVyaXRlZClcbiAgICBzdGF0ZS5lcnJvcnMucHVzaChlcnIpO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUud3JhcFJlc3VsdCA9IGZ1bmN0aW9uIHdyYXBSZXN1bHQocmVzdWx0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN1bHQ6IHRoaXMuaXNFcnJvcihyZXN1bHQpID8gbnVsbCA6IHJlc3VsdCxcbiAgICBlcnJvcnM6IHN0YXRlLmVycm9yc1xuICB9O1xufTtcblxuZnVuY3Rpb24gUmVwb3J0ZXJFcnJvcihwYXRoLCBtc2cpIHtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5yZXRocm93KG1zZyk7XG59O1xuaW5oZXJpdHMoUmVwb3J0ZXJFcnJvciwgRXJyb3IpO1xuXG5SZXBvcnRlckVycm9yLnByb3RvdHlwZS5yZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdyhtc2cpIHtcbiAgdGhpcy5tZXNzYWdlID0gbXNnICsgJyBhdDogJyArICh0aGlzLnBhdGggfHwgJyhzaGFsbG93KScpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXBvcnRlckVycm9yKTtcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5FbmNvZGVyQnVmZmVyO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuLy8gU3VwcG9ydGVkIHRhZ3NcbnZhciB0YWdzID0gW1xuICAnc2VxJywgJ3NlcW9mJywgJ3NldCcsICdzZXRvZicsICdvY3RzdHInLCAnYml0c3RyJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ2lhNXN0cicsICd1dGY4c3RyJ1xuXTtcblxuLy8gUHVibGljIG1ldGhvZHMgbGlzdFxudmFyIG1ldGhvZHMgPSBbXG4gICdrZXknLCAnb2JqJywgJ3VzZScsICdvcHRpb25hbCcsICdleHBsaWNpdCcsICdpbXBsaWNpdCcsICdkZWYnLCAnY2hvaWNlJyxcbiAgJ2FueSdcbl0uY29uY2F0KHRhZ3MpO1xuXG4vLyBPdmVycmlkZWQgbWV0aG9kcyBsaXN0XG52YXIgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB0aGlzLl9iYXNlU3RhdGUgPSBzdGF0ZTtcblxuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG5cbiAgLy8gU2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb24gZWFjaCBtZXRob2RcbiAgaWYgKCFzdGF0ZS5wYXJlbnQpIHtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuX3dyYXAoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgc3RhdGVQcm9wcyA9IFtcbiAgJ2VuYycsICdwYXJlbnQnLCAnY2hpbGRyZW4nLCAndGFnJywgJ2FyZ3MnLCAncmV2ZXJzZUFyZ3MnLCAnY2hvaWNlJyxcbiAgJ29wdGlvbmFsJywgJ2FueScsICdvYmonLCAndXNlJywgJ2FsdGVyZWRVc2UnLCAna2V5JywgJ2RlZmF1bHQnLCAnZXhwbGljaXQnLFxuICAnaW1wbGljaXQnXG5dO1xuXG5Ob2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBjc3RhdGUgPSB7fTtcbiAgc3RhdGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBjc3RhdGVbcHJvcF0gPSBzdGF0ZVtwcm9wXTtcbiAgfSk7XG4gIHZhciByZXMgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihjc3RhdGUucGFyZW50KTtcbiAgcmVzLl9iYXNlU3RhdGUgPSBjc3RhdGU7XG4gIHJldHVybiByZXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fd3JhcCA9IGZ1bmN0aW9uIHdyYXAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uIF93cmFwcGVkTWV0aG9kKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNsb25lKTtcbiAgICAgIHJldHVybiBjbG9uZVttZXRob2RdLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIHRoaXMpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGJvZHkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBib2R5LmNhbGwodGhpcyk7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuXG4gIHN0YXRlLmNoaWxkcmVuID0gc3RhdGUuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID09PSB0aGlzO1xuICB9LCB0aGlzKTtcbiAgYXNzZXJ0LmVxdWFsKHN0YXRlLmNoaWxkcmVuLmxlbmd0aCwgMSwgJ1Jvb3Qgbm9kZSBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZCcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3VzZUFyZ3MgPSBmdW5jdGlvbiB1c2VBcmdzKGFyZ3MpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlbiBhbmQgYXJnc1xuICB2YXIgY2hpbGRyZW4gPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfSwgdGhpcyk7XG4gIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gIShhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5jaGlsZHJlbiA9PT0gbnVsbCk7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgIC8vIFJlcGxhY2UgcGFyZW50IHRvIG1haW50YWluIGJhY2t3YXJkIGxpbmtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9IHRoaXM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmFyZ3MgPT09IG51bGwpO1xuICAgIHN0YXRlLmFyZ3MgPSBhcmdzO1xuICAgIHN0YXRlLnJldmVyc2VBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpXG4gICAgICAgIHJldHVybiBhcmc7XG5cbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSAoa2V5IHwgMCkpXG4gICAgICAgICAga2V5IHw9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ1trZXldO1xuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuLy8gT3ZlcnJpZGVkIG1ldGhvZHNcbi8vXG5cbm92ZXJyaWRlZC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkIGZvciBlbmNvZGluZzogJyArIHN0YXRlLmVuYyk7XG4gIH07XG59KTtcblxuLy9cbi8vIFB1YmxpYyBtZXRob2RzXG4vL1xuXG50YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gIE5vZGUucHJvdG90eXBlW3RhZ10gPSBmdW5jdGlvbiBfdGFnTWV0aG9kKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhc3NlcnQoc3RhdGUudGFnID09PSBudWxsKTtcbiAgICBzdGF0ZS50YWcgPSB0YWc7XG5cbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuTm9kZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGl0ZW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS51c2UgPT09IG51bGwpO1xuICBzdGF0ZS51c2UgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmRlZiA9IGZ1bmN0aW9uIGRlZih2YWwpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZVsnZGVmYXVsdCddID09PSBudWxsKTtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IHZhbDtcbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZXhwbGljaXQgPSBmdW5jdGlvbiBleHBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuaW1wbGljaXQgPSBmdW5jdGlvbiBpbXBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub2JqID0gZnVuY3Rpb24gb2JqKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBzdGF0ZS5vYmogPSB0cnVlO1xuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMClcbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24ga2V5KG5ld0tleSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmtleSA9PT0gbnVsbCk7XG4gIHN0YXRlLmtleSA9IG5ld0tleTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLmFueSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5jaG9pY2UgPSBmdW5jdGlvbiBjaG9pY2Uob2JqKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuY2hvaWNlID09PSBudWxsKTtcbiAgc3RhdGUuY2hvaWNlID0gb2JqO1xuICB0aGlzLl91c2VBcmdzKE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIERlY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIGlucHV0LndyYXBSZXN1bHQoc3RhdGUuY2hpbGRyZW5bMF0uX2RlY29kZShpbnB1dCkpO1xuXG4gIHZhciByZXN1bHQgPSBzdGF0ZVsnZGVmYXVsdCddO1xuICB2YXIgcHJlc2VudCA9IHRydWU7XG5cbiAgdmFyIHByZXZLZXk7XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwpXG4gICAgcHJldktleSA9IGlucHV0LmVudGVyS2V5KHN0YXRlLmtleSk7XG5cbiAgLy8gQ2hlY2sgaWYgdGFnIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCkge1xuICAgIHZhciB0YWcgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmV4cGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuaW1wbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCAmJiAhc3RhdGUuYW55KSB7XG4gICAgICAvLyBUcmlhbCBhbmQgRXJyb3JcbiAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0KTtcbiAgICAgICAgcHJlc2VudCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXNlbnQgPSB0aGlzLl9wZWVrVGFnKGlucHV0LCB0YWcsIHN0YXRlLmFueSk7XG5cbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKHByZXNlbnQpKVxuICAgICAgICByZXR1cm4gcHJlc2VudDtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIG9iamVjdCBvbiBzdGFja1xuICB2YXIgcHJldk9iajtcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHByZXZPYmogPSBpbnB1dC5lbnRlck9iamVjdCgpO1xuXG4gIGlmIChwcmVzZW50KSB7XG4gICAgLy8gVW53cmFwIGV4cGxpY2l0IHZhbHVlc1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGV4cGxpY2l0ID0gdGhpcy5fZGVjb2RlVGFnKGlucHV0LCBzdGF0ZS5leHBsaWNpdCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihleHBsaWNpdCkpXG4gICAgICAgIHJldHVybiBleHBsaWNpdDtcbiAgICAgIGlucHV0ID0gZXhwbGljaXQ7XG4gICAgfVxuXG4gICAgLy8gVW53cmFwIGltcGxpY2l0IGFuZCBub3JtYWwgdmFsdWVzXG4gICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kZWNvZGVUYWcoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnLFxuICAgICAgICBzdGF0ZS5hbnlcbiAgICAgICk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihib2R5KSlcbiAgICAgICAgcmV0dXJuIGJvZHk7XG5cbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHJlc3VsdCA9IGlucHV0LnJhdyhzYXZlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgaW5wdXQgPSBib2R5O1xuICAgIH1cblxuICAgIC8vIFNlbGVjdCBwcm9wZXIgbWV0aG9kIGZvciB0YWdcbiAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgcmVzdWx0ID0gcmVzdWx0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCk7XG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0KTtcblxuICAgIGlmIChpbnB1dC5pc0Vycm9yKHJlc3VsdCkpXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgLy8gRGVjb2RlIGNoaWxkcmVuXG4gICAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsICYmIHN0YXRlLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmFpbCA9IHN0YXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gZGVjb2RlQ2hpbGRyZW4oY2hpbGQpIHtcbiAgICAgICAgLy8gTk9URTogV2UgYXJlIGlnbm9yaW5nIGVycm9ycyBoZXJlLCB0byBsZXQgcGFyc2VyIGNvbnRpbnVlIHdpdGggb3RoZXJcbiAgICAgICAgLy8gcGFydHMgb2YgZW5jb2RlZCBkYXRhXG4gICAgICAgIGNoaWxkLl9kZWNvZGUoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmFpbClcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH1cblxuICAvLyBQb3Agb2JqZWN0XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICByZXN1bHQgPSBpbnB1dC5sZWF2ZU9iamVjdChwcmV2T2JqKTtcblxuICAvLyBTZXQga2V5XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCBwcmVzZW50ID09PSB0cnVlKSlcbiAgICBpbnB1dC5sZWF2ZUtleShwcmV2S2V5LCBzdGF0ZS5rZXksIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVHZW5lcmljID0gZnVuY3Rpb24gZGVjb2RlR2VuZXJpYyh0YWcsIGlucHV0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAodGFnID09PSAnc2VxJyB8fCB0YWcgPT09ICdzZXQnKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodGFnID09PSAnc2Vxb2YnIHx8IHRhZyA9PT0gJ3NldG9mJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTGlzdChpbnB1dCwgdGFnLCBzdGF0ZS5hcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2N0c3RyJyB8fCB0YWcgPT09ICdiaXRzdHInKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2lhNXN0cicgfHwgdGFnID09PSAndXRmOHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBzdGF0ZS5hcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVUaW1lKGlucHV0LCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU51bGwoaW5wdXQpO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlQm9vbChpbnB1dCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUludChpbnB1dCwgc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzWzBdKTtcbiAgZWxzZSBpZiAoc3RhdGUudXNlICE9PSBudWxsKVxuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopLl9kZWNvZGUoaW5wdXQpO1xuICBlbHNlXG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCd1bmtub3duIHRhZzogJyArIHRhZyk7XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZ2V0VXNlID0gZnVuY3Rpb24gX2dldFVzZShlbnRpdHksIG9iaikge1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgLy8gQ3JlYXRlIGFsdGVyZWQgdXNlIGRlY29kZXIgaWYgaW1wbGljaXQgaXMgc2V0XG4gIHN0YXRlLnVzZURlY29kZXIgPSB0aGlzLl91c2UoZW50aXR5LCBvYmopO1xuICBhc3NlcnQoc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuY2hpbGRyZW5bMF07XG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XG4gICAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuY2xvbmUoKTtcbiAgICBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlRGVjb2Rlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVDaG9pY2UgPSBmdW5jdGlvbiBkZWNvZGVDaG9pY2UoaW5wdXQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2tleV07XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcbiAgICByZXR1cm47XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICh0aGlzLl9za2lwRGVmYXVsdChyZXN1bHQsIHJlcG9ydGVyLCBwYXJlbnQpKVxuICAgIHJldHVybjtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICAvLyBTZXQgcmVwb3J0ZXIgdG8gc2hhcmUgaXQgd2l0aCBhIGNoaWxkIGNsYXNzXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcblxuICAvLyBDaGVjayBpZiBkYXRhIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbClcbiAgICAgIGRhdGEgPSBzdGF0ZVsnZGVmYXVsdCddXG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yIGVycm9yIHJlcG9ydGluZ1xuICB2YXIgcHJldktleTtcblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG5cbiAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnc2Vxb2YnIHx8IHN0YXRlLnRhZyA9PT0gJ3NldG9mJykge1xuICAgICAgLy8gVE9ETyhpbmR1dG55KTogdGhpcyBzaG91bGQgYmUgdGhyb3duIG9uIERTTCBsZXZlbFxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVG9vIG1hbnkgYXJncyBmb3IgOiAnICsgc3RhdGUudGFnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ3NlcW9mL3NldG9mLCBidXQgZGF0YSBpcyBub3QgQXJyYXknKTtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XG4gICAgdmFyIGNscyA9IHN0YXRlLmltcGxpY2l0ID09PSBudWxsID8gJ3VuaXZlcnNhbCcgOiAnY29udGV4dCc7XG5cbiAgICBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXBvcnRlci5lcnJvcignVGFnIGNvdWxkIGJlIG9tbWl0ZWQgb25seSBmb3IgLnVzZSgpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZSh0YWcsIHByaW1pdGl2ZSwgY2xzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwIGluIGV4cGxpY2l0XG4gIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUoc3RhdGUuZXhwbGljaXQsIGZhbHNlLCAnY29udGV4dCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVDaG9pY2UgPSBmdW5jdGlvbiBlbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2RhdGEudHlwZV07XG4gIGlmICghbm9kZSkge1xuICAgIGFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGRhdGEudHlwZSArICcgbm90IGZvdW5kIGluICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xuICB9XG4gIHJldHVybiBub2RlLl9lbmNvZGUoZGF0YS52YWx1ZSwgcmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZSh0YWcsIGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdvY3RzdHInIHx8IHRhZyA9PT0gJ2JpdHN0cicgfHwgdGFnID09PSAnaWE1c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ3V0ZjhzdHInKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIHN0YXRlLnJldmVyc2VBcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVRpbWUoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVOdWxsKCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUJvb2woZGF0YSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhZzogJyArIHRhZyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gRGVjb2RlckJ1ZmZlcihiYXNlLCBvcHRpb25zKSB7XG4gIFJlcG9ydGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJhc2UpKSB7XG4gICAgdGhpcy5lcnJvcignSW5wdXQgbm90IEJ1ZmZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYmFzZSA9IGJhc2U7XG4gIHRoaXMub2Zmc2V0ID0gMDtcbiAgdGhpcy5sZW5ndGggPSBiYXNlLmxlbmd0aDtcbn1cbmluaGVyaXRzKERlY29kZXJCdWZmZXIsIFJlcG9ydGVyKTtcbmV4cG9ydHMuRGVjb2RlckJ1ZmZlciA9IERlY29kZXJCdWZmZXI7XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICByZXR1cm4geyBvZmZzZXQ6IHRoaXMub2Zmc2V0LCByZXBvcnRlcjogUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzKSB9O1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoc2F2ZSkge1xuICAvLyBSZXR1cm4gc2tpcHBlZCBkYXRhXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xuICByZXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldDtcblxuICB0aGlzLm9mZnNldCA9IHNhdmUub2Zmc2V0O1xuICBSZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZS5jYWxsKHRoaXMsIHNhdmUucmVwb3J0ZXIpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0ID09PSB0aGlzLmxlbmd0aDtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChmYWlsKSB7XG4gIGlmICh0aGlzLm9mZnNldCArIDEgPD0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5yZWFkVUludDgodGhpcy5vZmZzZXQrKywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoYnl0ZXMsIGZhaWwpIHtcbiAgaWYgKCEodGhpcy5vZmZzZXQgKyBieXRlcyA8PSB0aGlzLmxlbmd0aCkpXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG5cbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG5cbiAgLy8gU2hhcmUgcmVwb3J0ZXIgc3RhdGVcbiAgcmVzLl9yZXBvcnRlclN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldCArIGJ5dGVzO1xuICB0aGlzLm9mZnNldCArPSBieXRlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gcmF3KHNhdmUpIHtcbiAgcmV0dXJuIHRoaXMuYmFzZS5zbGljZShzYXZlID8gc2F2ZS5vZmZzZXQgOiB0aGlzLm9mZnNldCwgdGhpcy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBFbmNvZGVyQnVmZmVyKHZhbHVlLCByZXBvcnRlcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRW5jb2RlckJ1ZmZlcikpXG4gICAgICAgIGl0ZW0gPSBuZXcgRW5jb2RlckJ1ZmZlcihpdGVtLCByZXBvcnRlcik7XG4gICAgICB0aGlzLmxlbmd0aCArPSBpdGVtLmxlbmd0aDtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoISgwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDB4ZmYpKVxuICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdub24tYnl0ZSBFbmNvZGVyQnVmZmVyIHZhbHVlJyk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgdHlwZW9mIHZhbHVlKTtcbiAgfVxufVxuZXhwb3J0cy5FbmNvZGVyQnVmZmVyID0gRW5jb2RlckJ1ZmZlcjtcblxuRW5jb2RlckJ1ZmZlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ob3V0LCBvZmZzZXQpIHtcbiAgaWYgKCFvdXQpXG4gICAgb3V0ID0gbmV3IEJ1ZmZlcih0aGlzLmxlbmd0aCk7XG4gIGlmICghb2Zmc2V0KVxuICAgIG9mZnNldCA9IDA7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBvdXQ7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaXRlbS5qb2luKG91dCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBpdGVtLmxlbmd0aDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgb3V0W29mZnNldF0gPSB0aGlzLnZhbHVlO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgIG91dC53cml0ZSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnZhbHVlKSlcbiAgICAgIHRoaXMudmFsdWUuY29weShvdXQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgLy8gTGF6aWx5IGNyZWF0ZSBkZWNvZGVyXG4gIGlmICghdGhpcy5kZWNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZGVjb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZGVjb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmRlY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldERlY29kZXIoZW5jKS5kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXRFbmNvZGVyID0gZnVuY3Rpb24gX2dldEVuY29kZXIoZW5jKSB7XG4gIC8vIExhemlseSBjcmVhdGUgZW5jb2RlclxuICBpZiAoIXRoaXMuZW5jb2RlcnMuaGFzT3duUHJvcGVydHkoZW5jKSlcbiAgICB0aGlzLmVuY29kZXJzW2VuY10gPSB0aGlzLl9jcmVhdGVOYW1lZChhc24xLmVuY29kZXJzW2VuY10pO1xuICByZXR1cm4gdGhpcy5lbmNvZGVyc1tlbmNdO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgZW5jLCAvKiBpbnRlcm5hbCAqLyByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy5fZ2V0RW5jb2RlcihlbmMpLmVuY29kZShkYXRhLCByZXBvcnRlcik7XG59O1xuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG5cbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi5ldmFsKCkgbWFnaWNhbGx5IGFwcGVhcnMgd2hlbiB0aGlzIGlzIGNhbGxlZCBpbiBJRTpcbiAgICAgICAgd0V4ZWNTY3JpcHQuY2FsbCh3aW4sICdudWxsJyk7XG4gICAgICAgIHdFdmFsID0gd2luLmV2YWw7XG4gICAgfVxuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgfSk7XG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChjb250ZXh0W2tleV0pIHtcbiAgICAgICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHdpbktleXMgPSBPYmplY3Rfa2V5cyh3aW4pO1xuXG4gICAgdmFyIHJlcyA9IHdFdmFsLmNhbGwod2luLCB0aGlzLmNvZGUpO1xuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMod2luKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGNpcmN1bGFyIG9iamVjdHMgbGlrZSBgdG9wYCBhbmQgYHdpbmRvd2AgYnkgb25seVxuICAgICAgICAvLyB1cGRhdGluZyBleGlzdGluZyBjb250ZXh0IHByb3BlcnRpZXMgb3IgbmV3IHByb3BlcnRpZXMgaW4gdGhlIGB3aW5gXG4gICAgICAgIC8vIHRoYXQgd2FzIG9ubHkgaW50cm9kdWNlZCBhZnRlciB0aGUgZXZhbC5cbiAgICAgICAgaWYgKGtleSBpbiBjb250ZXh0IHx8IGluZGV4T2Yod2luS2V5cywga2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHdpbltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wKGNvbnRleHQsIGtleSwgd2luW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHJldHVybiByZXM7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluVGhpc0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2YWwodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIm1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPXtcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjFcIjogXCJhZXMtMTI4LWVjYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yXCI6IFwiYWVzLTEyOC1jYmNcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuM1wiOiBcImFlcy0xMjgtb2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjRcIjogXCJhZXMtMTI4LWNmYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yMVwiOiBcImFlcy0xOTItZWNiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIyXCI6IFwiYWVzLTE5Mi1jYmNcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjNcIjogXCJhZXMtMTkyLW9mYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yNFwiOiBcImFlcy0xOTItY2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQxXCI6IFwiYWVzLTI1Ni1lY2JcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDJcIjogXCJhZXMtMjU2LWNiY1wiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40M1wiOiBcImFlcy0yNTYtb2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQ0XCI6IFwiYWVzLTI1Ni1jZmJcIlxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5lbGxpcHRpYy51dGlscyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvdXRpbHMnKTtcbmVsbGlwdGljLnJhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG5lbGxpcHRpYy5obWFjRFJCRyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvaG1hYy1kcmJnJyk7XG5lbGxpcHRpYy5jdXJ2ZSA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmUnKTtcbmVsbGlwdGljLmN1cnZlcyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmVzJyk7XG5cbi8vIFByb3RvY29sc1xuZWxsaXB0aWMuZWMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VjJyk7XG4iLCJtb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuMS4wXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQyBjcnlwdG9ncmFwaHlcIixcbiAgXCJtYWluXCI6IFwibGliL2VsbGlwdGljLmpzXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwibWFrZSBsaW50ICYmIG1vY2hhIC0tcmVwb3J0ZXI9c3BlYyB0ZXN0LyotdGVzdC5qc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy5naXRcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIkVDXCIsXG4gICAgXCJFbGxpcHRpY1wiLFxuICAgIFwiY3VydmVcIixcbiAgICBcIkNyeXB0b2dyYXBoeVwiXG4gIF0sXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGZWRvciBJbmR1dG55XCIsXG4gICAgXCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcbiAgfSxcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4zLjQ0LjJcIixcbiAgICBcImpzY3NcIjogXCJeMS4xMS4zXCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi42LjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJeMi40LjEzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYm4uanNcIjogXCJeMi4wLjNcIixcbiAgICBcImJyb3JhbmRcIjogXCJeMS4wLjFcIixcbiAgICBcImhhc2guanNcIjogXCJeMS4wLjBcIixcbiAgICBcImluaGVyaXRzXCI6IFwiXjIuMC4xXCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiZDg2Y2QyYTgxNzhmN2U3Y2VjYmQ2ZGQ5MmVlYTA4NGUyYWI0NGMxM1wiLFxuICBcIl9pZFwiOiBcImVsbGlwdGljQDMuMS4wXCIsXG4gIFwiX3NoYXN1bVwiOiBcImMyMTY4MmVmNzYyNzY5YjU2YTc0MjAxNjA5MTA1ZGExMWQ1ZjYwY2NcIixcbiAgXCJfZnJvbVwiOiBcImVsbGlwdGljQD49My4wLjAgPDQuMC4wXCIsXG4gIFwiX25wbVZlcnNpb25cIjogXCIyLjExLjBcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCIyLjIuMVwiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJpbmR1dG55XCIsXG4gICAgXCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcbiAgfSxcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiaW5kdXRueVwiLFxuICAgICAgXCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCJjMjE2ODJlZjc2Mjc2OWI1NmE3NDIwMTYwOTEwNWRhMTFkNWY2MGNjXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTMuMS4wLnRnelwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge30sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZWxsaXB0aWMvLS9lbGxpcHRpYy0zLjEuMC50Z3pcIixcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCJcbn1cbiIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBJRVxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlclxuICB0cnkge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnknICsgJ3B0bycpO1xuXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbnV0aWxzLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59O1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCFlbmMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3KSB7XG4gIHZhciBuYWYgPSBbXTtcbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuICB3aGlsZSAoay5jbXBuKDEpID49IDApIHtcbiAgICB2YXIgejtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG4gICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBtb2Q7XG4gICAgICBrLmlzdWJuKHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gMDtcbiAgICB9XG4gICAgbmFmLnB1c2goeik7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24sIHNoaWZ0IGJ5IHdvcmQgaWYgcG9zc2libGVcbiAgICB2YXIgc2hpZnQgPSAoay5jbXBuKDApICE9PSAwICYmIGsuYW5kbG4od3MgLSAxKSA9PT0gMCkgPyAodyArIDEpIDogMTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoaWZ0OyBpKyspXG4gICAgICBuYWYucHVzaCgwKTtcbiAgICBrLmlzaHJuKHNoaWZ0KTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pc2hybigxKTtcbiAgICBrMi5pc2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBqc2Y7XG59XG51dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMpO1xuICB2YXIgbm9uY2UgPSB1dGlscy50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMpO1xuICB2YXIgcGVycyA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMpO1xuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMucmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9CdWZmZXIoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzLnRvQnVmZmVyKGFkZCwgYWRkRW5jKTtcblxuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5yZXNlZWQgPSAxO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG4gIGlmICh0aGlzLnJlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMucmVzZWVkKys7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoZWxsaXB0aWMuY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gZWxsaXB0aWMuY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBlbGxpcHRpYy5jdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEtleVBhaXIodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGVsbGlwdGljLmhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBlbGxpcHRpYy5yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBibigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBibihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cuc2hybihkZWx0YSk7XG4gIGlmICghdHJ1bmNPbmx5ICYmIG1zZy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG4gIGVsc2VcbiAgICByZXR1cm4gbXNnO1xufTtcblxuRUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csIDE2KSk7XG5cbiAgLy8gWmVyby1leHRlbmQga2V5IHRvIHByb3ZpZGUgZW5vdWdoIGVudHJvcHlcbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IGJrZXkubGVuZ3RoOyBpIDwgMjE7IGkrKylcbiAgICBia2V5LnVuc2hpZnQoMCk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgpO1xuICBmb3IgKHZhciBpID0gbm9uY2UubGVuZ3RoOyBpIDwgYnl0ZXM7IGkrKylcbiAgICBub25jZS51bnNoaWZ0KDApO1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBlbGxpcHRpYy5obWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IGJrZXksXG4gICAgbm9uY2U6IG5vbmNlXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgYm4oMSkpO1xuICBkbyB7XG4gICAgdmFyIGsgPSBuZXcgYm4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC5tb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpLm1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMClcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH0gd2hpbGUgKHRydWUpO1xufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IGJuKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLm1vZCh0aGlzLm4pO1xuICB2YXIgdTIgPSBzaW52Lm11bChyKS5tb2QodGhpcy5uKTtcblxuICB2YXIgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBwLmdldFgoKS5tb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBibihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC5tb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG4gIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG4gIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoaXNZT2RkLCByKTtcbiAgdmFyIGVOZWcgPSBlLm5lZygpLm1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgcmV0dXJuIHIubXVsKHMpLmFkZCh0aGlzLmcubXVsKGVOZWcpKS5tdWwockludik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSwgUSwgZW5jKSB7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgcmV0dXJuIHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IGJuKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgYm4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICBpZiAoZGF0YS5sZW5ndGggPCA2IHx8IGRhdGFbMF0gIT09IDB4MzAgfHwgZGF0YVsyXSAhPT0gMHgwMilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciB0b3RhbCA9IGRhdGFbMV07XG4gIGlmICgxICsgdG90YWwgPiBkYXRhLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBybGVuID0gZGF0YVszXTtcbiAgLy8gU2hvcnQgbGVuZ3RoIG5vdGF0aW9uXG4gIGlmIChybGVuID49IDB4ODApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoNCArIHJsZW4gKyAyID49IGRhdGEubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGRhdGFbNCArIHJsZW5dICE9PSAweDAyKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIHNsZW4gPSBkYXRhWzUgKyBybGVuXTtcbiAgLy8gU2hvcnQgbGVuZ3RoIG5vdGF0aW9uXG4gIGlmIChzbGVuID49IDB4ODApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoNCArIHJsZW4gKyAyICsgc2xlbiA+IGRhdGEubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB0aGlzLnIgPSBuZXcgYm4oZGF0YS5zbGljZSg0LCA0ICsgcmxlbikpO1xuICB0aGlzLnMgPSBuZXcgYm4oZGF0YS5zbGljZSg0ICsgcmxlbiArIDIsIDQgKyBybGVuICsgMiArIHNsZW4pKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICB2YXIgdG90YWwgPSByLmxlbmd0aCArIHMubGVuZ3RoICsgNDtcbiAgdmFyIHJlcyA9IFsgMHgzMCwgdG90YWwsIDB4MDIsIHIubGVuZ3RoIF07XG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG5cbmZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5lYyA9IGVjO1xuICB0aGlzLnByaXYgPSBudWxsO1xuICB0aGlzLnB1YiA9IG51bGw7XG5cbiAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG4gIGlmIChvcHRpb25zLnByaXYpXG4gICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG4gIGlmIChvcHRpb25zLnB1YilcbiAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHJpdjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwcml2OiBwcml2LFxuICAgIHByaXZFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHZhciBwdWIgPSB0aGlzLmdldFB1YmxpYygpO1xuXG4gIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgaWYgKCFwdWIudmFsaWRhdGUoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcblxuICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsIGVuYykge1xuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIWVuYylcbiAgICByZXR1cm4gdGhpcy5wdWI7XG5cbiAgdmFyIGxlbiA9IHRoaXMuZWMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG4gIHZhciB4ID0gdGhpcy5wdWIuZ2V0WCgpLnRvQXJyYXkoKTtcblxuICBmb3IgKHZhciBpID0geC5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICB4LnVuc2hpZnQoMCk7XG5cbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSAhPT0gJ21vbnQnKSB7XG4gICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgIHJlcyA9IFsgdGhpcy5wdWIuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5ID0gdGhpcy5wdWIuZ2V0WSgpLnRvQXJyYXkoKTtcbiAgICAgIGZvciAodmFyIGkgPSB5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB5LnVuc2hpZnQoMCk7XG4gICAgICB2YXIgcmVzID0gWyAweDA0IF0uY29uY2F0KHgsIHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMgPSB4O1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgYm4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2Lm1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAga2V5ID0gdXRpbHMudG9BcnJheShrZXksIGVuYyk7XG4gIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgIT09ICdtb250JylcbiAgICByZXR1cm4gdGhpcy5faW1wb3J0UHVibGljU2hvcnQoa2V5KTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9pbXBvcnRQdWJsaWNNb250KGtleSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljU2hvcnQgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljU2hvcnQoa2V5KSB7XG4gIHZhciBsZW4gPSB0aGlzLmVjLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICBpZiAoa2V5WzBdID09PSAweDA0ICYmIGtleS5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KFxuICAgICAga2V5LnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAga2V5LnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG4gIH0gZWxzZSBpZiAoKGtleVswXSA9PT0gMHgwMiB8fCBrZXlbMF0gPT09IDB4MDMpICYmIGtleS5sZW5ndGggLSAxID09PSBsZW4pIHtcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnRGcm9tWChrZXlbMF0gPT09IDB4MDMsIGtleS5zbGljZSgxLCAxICsgbGVuKSk7XG4gIH1cbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWNNb250ID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpY01vbnQoa2V5KSB7XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXksIDEpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2cpIHtcbiAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMCcsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCdcbiAgXVxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSByZXF1aXJlKCcuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMScpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnXG4gICAgfVxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmVcbiAgXVxufSk7XG4iLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iLCJ2YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgICBpZiAoaGkpXG4gICAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG51dGlscy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG51dGlscy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG51dGlscy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxudXRpbHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cbnV0aWxzLmFzc2VydCA9IGFzc2VydDtcblxudXRpbHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn07XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn07XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgcm90cjMyID0gdXRpbHMucm90cjMyO1xudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIHJvdHI2NF9oaSA9IHV0aWxzLnJvdHI2NF9oaTtcbnZhciByb3RyNjRfbG8gPSB1dGlscy5yb3RyNjRfbG87XG52YXIgc2hyNjRfaGkgPSB1dGlscy5zaHI2NF9oaTtcbnZhciBzaHI2NF9sbyA9IHV0aWxzLnNocjY0X2xvO1xudmFyIHN1bTY0ID0gdXRpbHMuc3VtNjQ7XG52YXIgc3VtNjRfaGkgPSB1dGlscy5zdW02NF9oaTtcbnZhciBzdW02NF9sbyA9IHV0aWxzLnN1bTY0X2xvO1xudmFyIHN1bTY0XzRfaGkgPSB1dGlscy5zdW02NF80X2hpO1xudmFyIHN1bTY0XzRfbG8gPSB1dGlscy5zdW02NF80X2xvO1xudmFyIHN1bTY0XzVfaGkgPSB1dGlscy5zdW02NF81X2hpO1xudmFyIHN1bTY0XzVfbG8gPSB1dGlscy5zdW02NF81X2xvO1xudmFyIEJsb2NrSGFzaCA9IGhhc2guY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTI1Nl9LID0gW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dO1xuXG52YXIgc2hhNTEyX0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbnZhciBzaGExX0sgPSBbXG4gIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsXG4gIDB4OEYxQkJDREMsIDB4Q0E2MkMxRDZcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTkgXTtcbiAgdGhpcy5rID0gc2hhMjU2X0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG59XG51dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTI1NiA9IFNIQTI1NjtcblxuU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTI1Ni5vdXRTaXplID0gMjU2O1xuU0hBMjU2LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gc3VtMzJfNChnMV8yNTYoV1tpIC0gMl0pLCBXW2kgLSA3XSwgZzBfMjU2KFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgdmFyIGcgPSB0aGlzLmhbNl07XG4gIHZhciBoID0gdGhpcy5oWzddO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBUMSA9IHN1bTMyXzUoaCwgczFfMjU2KGUpLCBjaDMyKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgIGggPSBnO1xuICAgIGcgPSBmO1xuICAgIGYgPSBlO1xuICAgIGUgPSBzdW0zMihkLCBUMSk7XG4gICAgZCA9IGM7XG4gICAgYyA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHN1bTMyKFQxLCBUMik7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xuICB0aGlzLmhbNV0gPSBzdW0zMih0aGlzLmhbNV0sIGYpO1xuICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICB0aGlzLmhbN10gPSBzdW0zMih0aGlzLmhbN10sIGgpO1xufTtcblxuU0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMjI0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcbiAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuXG4gIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgICAgICAgICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xuZXhwb3J0cy5zaGEyMjQgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTUxMigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG4gICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuICAgICAgICAgICAgIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsXG4gICAgICAgICAgICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcbiAgICAgICAgICAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsXG4gICAgICAgICAgICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcbiAgICAgICAgICAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuICAgICAgICAgICAgIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkgXTtcbiAgdGhpcy5rID0gc2hhNTEyX0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGE1MTIgPSBTSEE1MTI7XG5cblNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuU0hBNTEyLm91dFNpemUgPSA1MTI7XG5TSEE1MTIuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuU0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIC8vIDMyIHggMzJiaXQgd29yZHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuICAgIHZhciBjMF9sbyA9IGcxXzUxMl9sbyhXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG4gICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuICAgIHZhciBjMl9oaSA9IGcwXzUxMl9oaShXW2kgLSAzMF0sIFdbaSAtIDI5XSk7ICAvLyBpIC0gMTVcbiAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcblxuICAgIFdbaV0gPSBzdW02NF80X2hpKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gIH1cbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB0aGlzLl9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCk7XG5cbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgdmFyIGFoID0gdGhpcy5oWzBdO1xuICB2YXIgYWwgPSB0aGlzLmhbMV07XG4gIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgdmFyIGJsID0gdGhpcy5oWzNdO1xuICB2YXIgY2ggPSB0aGlzLmhbNF07XG4gIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgdmFyIGRoID0gdGhpcy5oWzZdO1xuICB2YXIgZGwgPSB0aGlzLmhbN107XG4gIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgdmFyIGVsID0gdGhpcy5oWzldO1xuICB2YXIgZmggPSB0aGlzLmhbMTBdO1xuICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuICB2YXIgZ2wgPSB0aGlzLmhbMTNdO1xuICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGhoO1xuICAgIHZhciBjMF9sbyA9IGhsO1xuICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgIHZhciBjMl9oaSA9IGNoNjRfaGkoZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG4gICAgdmFyIGMzX2xvID0gdGhpcy5rW2kgKyAxXTtcbiAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG4gICAgdmFyIFQxX2hpID0gc3VtNjRfNV9oaShjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjNF9oaSwgYzRfbG8pO1xuICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIHZhciBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuICAgIHZhciBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuICAgIHZhciBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIHZhciBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG4gICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblxuICAgIGhoID0gZ2g7XG4gICAgaGwgPSBnbDtcblxuICAgIGdoID0gZmg7XG4gICAgZ2wgPSBmbDtcblxuICAgIGZoID0gZWg7XG4gICAgZmwgPSBlbDtcblxuICAgIGVoID0gc3VtNjRfaGkoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuICAgIGVsID0gc3VtNjRfbG8oZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG4gICAgZGggPSBjaDtcbiAgICBkbCA9IGNsO1xuXG4gICAgY2ggPSBiaDtcbiAgICBjbCA9IGJsO1xuXG4gICAgYmggPSBhaDtcbiAgICBibCA9IGFsO1xuXG4gICAgYWggPSBzdW02NF9oaShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gIH1cblxuICBzdW02NCh0aGlzLmgsIDAsIGFoLCBhbCk7XG4gIHN1bTY0KHRoaXMuaCwgMiwgYmgsIGJsKTtcbiAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICBzdW02NCh0aGlzLmgsIDYsIGRoLCBkbCk7XG4gIHN1bTY0KHRoaXMuaCwgOCwgZWgsIGVsKTtcbiAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgc3VtNjQodGhpcy5oLCAxMiwgZ2gsIGdsKTtcbiAgc3VtNjQodGhpcy5oLCAxNCwgaGgsIGhsKTtcbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG4gICAgcmV0dXJuIG5ldyBTSEEzODQoKTtcblxuICBTSEE1MTIuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgICAgICAgICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgICAgICAgICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAgICAgICAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgICAgICAgICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgICAgICAgICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAgICAgICAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgICAgICAgICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbmV4cG9ydHMuc2hhMzg0ID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsXG4gICAgICAgICAgICAgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xufVxuXG51dGlscy5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGExID0gU0hBMTtcblxuU0hBMS5ibG9ja1NpemUgPSA1MTI7XG5TSEExLm91dFNpemUgPSAxNjA7XG5TSEExLmhtYWNTdHJlbmd0aCA9IDgwO1xuU0hBMS5wYWRMZW5ndGggPSA2NDtcblxuU0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG4gIGZvcig7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSByb3RsMzIoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cblxuZnVuY3Rpb24gczFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA2KSBeIHJvdHIzMih4LCAxMSkgXiByb3RyMzIoeCwgMjUpO1xufVxuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDgpO1xuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDgpO1xuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBoYXNoLmNvbW1vbi5CbG9ja0hhc2g7XG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcblxuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcbn1cbnV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoKTtcbmV4cG9ydHMucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5SSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuUklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5SSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgQSA9IHRoaXMuaFswXTtcbiAgdmFyIEIgPSB0aGlzLmhbMV07XG4gIHZhciBDID0gdGhpcy5oWzJdO1xuICB2YXIgRCA9IHRoaXMuaFszXTtcbiAgdmFyIEUgPSB0aGlzLmhbNF07XG4gIHZhciBBaCA9IEE7XG4gIHZhciBCaCA9IEI7XG4gIHZhciBDaCA9IEM7XG4gIHZhciBEaCA9IEQ7XG4gIHZhciBFaCA9IEU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgIHZhciBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuICAgICAgICBzW2pdKSxcbiAgICAgIEUpO1xuICAgIEEgPSBFO1xuICAgIEUgPSBEO1xuICAgIEQgPSByb3RsMzIoQywgMTApO1xuICAgIEMgPSBCO1xuICAgIEIgPSBUO1xuICAgIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgc2hbal0pLFxuICAgICAgRWgpO1xuICAgIEFoID0gRWg7XG4gICAgRWggPSBEaDtcbiAgICBEaCA9IHJvdGwzMihDaCwgMTApO1xuICAgIENoID0gQmg7XG4gICAgQmggPSBUO1xuICB9XG4gIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICB0aGlzLmhbMV0gPSBzdW0zMl8zKHRoaXMuaFsyXSwgRCwgRWgpO1xuICB0aGlzLmhbMl0gPSBzdW0zMl8zKHRoaXMuaFszXSwgRSwgQWgpO1xuICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICB0aGlzLmhbNF0gPSBzdW0zMl8zKHRoaXMuaFswXSwgQiwgQ2gpO1xuICB0aGlzLmhbMF0gPSBUO1xufTtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xufTtcblxuZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiB4IF4geSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gIGVsc2VcbiAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG59XG5cbmZ1bmN0aW9uIEsoaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YTgyNzk5OTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg4ZjFiYmNkYztcbiAgZWxzZVxuICAgIHJldHVybiAweGE5NTNmZDRlO1xufVxuXG5mdW5jdGlvbiBLaChqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDUwYTI4YmU2O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVjNGRkMTI0O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZkNzAzZWYzO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDdhNmQ3NmU5O1xuICBlbHNlXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG59XG5cbnZhciByID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dO1xuXG52YXIgcmggPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl07XG5cbnZhciBzID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXTtcblxudmFyIHNoID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXTtcbiIsInZhciBobWFjID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHgzNjtcbiAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuICAvLyAweDM2IF4gMHg1YyA9IDB4NmFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcbiIsInZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nVG90YWwgPSAwO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG4gIHRoaXMuaG1hY1N0cmVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7XG4gIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuICB0aGlzLmVuZGlhbiA9ICdiaWcnO1xuXG4gIHRoaXMuX2RlbHRhOCA9IHRoaXMuYmxvY2tTaXplIC8gODtcbiAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG59XG5leHBvcnRzLkJsb2NrSGFzaCA9IEJsb2NrSGFzaDtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG4gIG1zZyA9IHV0aWxzLnRvQXJyYXkobXNnLCBlbmMpO1xuICBpZiAoIXRoaXMucGVuZGluZylcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG4gIGVsc2VcbiAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuY29uY2F0KG1zZyk7XG4gIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cbiAgLy8gRW5vdWdoIGRhdGEsIHRyeSB1cGRhdGluZ1xuICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcbiAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cbiAgICAvLyBQcm9jZXNzIHBlbmRpbmcgZGF0YSBpbiBibG9ja3NcbiAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cbiAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgdGhpcy5fdXBkYXRlKG1zZywgaSwgaSArIHRoaXMuX2RlbHRhMzIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpO1xuICBhc3NlcnQodGhpcy5wZW5kaW5nID09PSBudWxsKTtcblxuICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcbiAgdmFyIGJ5dGVzID0gdGhpcy5fZGVsdGE4O1xuICB2YXIgayA9IGJ5dGVzIC0gKChsZW4gKyB0aGlzLnBhZExlbmd0aCkgJSBieXRlcyk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcbiAgcmVzWzBdID0gMHg4MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG4gICAgcmVzW2ldID0gMDtcblxuICAvLyBBcHBlbmQgbGVuZ3RoXG4gIGxlbiA8PD0gMztcbiAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcblxuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG5cbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkb3VibGVzOiB7XG4gICAgc3RlcDogNCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2U2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGEnLFxuICAgICAgICAnZjdlMzUwNzM5OWU1OTU5MjlkYjk5ZjM0ZjU3OTM3MTAxMjk2ODkxZTQ0ZDIzZjBiZTFmMzJjY2U2OTYxNjgyMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4JyxcbiAgICAgICAgJzExZjhhODA5ODU1N2RmZTQ1ZTgyNTZlODMwYjYwYWNlNjJkNjEzYWMyZjdiMTdiZWQzMWI2ZWFmZjZlMjZjYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc1ZTE1OWY3MjhiODY1YTcyZjk5Y2M2YzZmYzg0NmRlMGI5MzgzM2ZkMjIyMmVkNzNmY2U1YjU1MWU1YjczOScsXG4gICAgICAgICdkMzUwNmUwZDllM2M3OWViYTRlZjk3YTUxZmY3MWY1ZWFjYjU5NTVhZGQyNDM0NWM2ZWZhNmZmZWU5ZmVkNjk1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDAnLFxuICAgICAgICAnNGUyNzNhZGZjNzMyMjIxOTUzYjQ0NTM5N2YzMzYzMTQ1YjlhODkwMDgxOTllY2I2MjAwM2M3ZjNiZWU5ZGU5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGMnLFxuICAgICAgICAnNGFhZDBhNmY2OGQzMDhiNGIzZmJkNzgxM2FiMGRhMDRmOWUzMzY1NDYxNjJlZTU2YjNlZmYwYzY1ZmQ0ZmQzNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MjNjYmFhNmU1ZGI5OTZkNmJmNzcxYzAwYmQ1NDhjN2I3MDBkYmZmYTZjMGU3N2JjYjYxMTU5MjUyMzJmY2RhJyxcbiAgICAgICAgJzk2ZTg2N2I1NTk1Y2M0OThhOTIxMTM3NDg4ODI0ZDZlMjY2MGEwNjUzNzc5NDk0ODAxZGMwNjlkOWViMzlmNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYScsXG4gICAgICAgICc1ZDlhOGNhMzk3MGVmMGYyNjllZTdlZGFmMTc4MDg5ZDlhZTRjZGMzYTcxMWY3MTJkZGZkNGZkYWUxZGU4OTk5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjAnLFxuICAgICAgICAnY2RkOWUxMzE5MmEwMGI3NzJlYzhmMzMwMGMwOTA2NjZiN2ZmNGExOGZmNTE5NWFjMGZiZDVjZDYyYmM2NWEwOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMTAzMWJlMjYyYzdlZDFiMWRjOTIyN2E0YTA0YzAxN2E3N2Y4ZDQ0NjRmM2IzODUyYzhhY2RlNmU1MzRmZDJkJyxcbiAgICAgICAgJzlkNzA2MTkyODk0MDQwNWU2YmI2YTQxNzY1OTc1MzVhZjI5MmRkNDE5ZTFjZWQ3OWE0NGYxOGYyOTQ1NmEwMGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZCcsXG4gICAgICAgICdlNTdjNmI2Yzk3ZGNlMWJhYjA2ZTRlMTJiZjNlY2Q1Yzk4MWM4OTU3Y2M0MTQ0MmQzMTU1ZGViZjE4MDkwMDg4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjEnLFxuICAgICAgICAnOWJhY2FhMzU0ODE2NDJiYzQxZjQ2M2Y3ZWM5NzgwZTVkZWM3YWRjNTA4Zjc0MGExN2U5ZWE4ZTI3YTY4YmUxZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MzkwNGZhYTBiMzM0Y2RkYTZlMDAwOTM1ZWYyMjE1MWVjMDhkMGY3YmIxMTA2OWY1NzU0NWNjYzFhMzdiN2MwJyxcbiAgICAgICAgJzViYzA4N2QwYmM4MDEwNmQ4OGM5ZWNjYWMyMGQzYzFjMTM5OTk5ODFlMTQ0MzQ2OTlkY2IwOTZiMDIyNzcxYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0NycsXG4gICAgICAgICcxMGI3NzcwYjJhM2RhNGIzOTQwMzEwNDIwY2E5NTE0NTc5ZTg4ZTJlNDdmZDY4YjNlYTEwMDQ3ZTg0NjAzNzJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjInLFxuICAgICAgICAnMjgzYmViYzNlOGVhMjNmNTY3MDFkZTE5ZTllYmY0NTc2YjMwNGVlYzIwODZkYzhjYzA0NThmZTU1NDJlNTQ1MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZjlkOWI4MDNlY2YxOTE2MzdjNzNhNDQxM2RmYTE4MGZkZGY4NGE1OTQ3ZmJjOWM2MDZlZDg2YzNmYWMzYTcnLFxuICAgICAgICAnN2M4MGM2OGU2MDMwNTliYTY5YjhlMmEzMGU0NWM0ZDQ3ZWE0ZGQyZjVjMjgxMDAyZDg2ODkwNjAzYTg0MjE2MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkJyxcbiAgICAgICAgJzU2ZTcwNzk3ZTk2NjRlZjViZmIwMTliYzRkZGFmOWI3MjgwNWY2M2VhMjg3M2FmNjI0ZjNhMmU5NmMyOGIyYTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4MycsXG4gICAgICAgICc3YzQ4MWI5YjViNDNiMmViNjM3NDA0OWJmYTYyYzJlNWU3N2YxN2ZjYzUyOThmNDRjOGUzMDk0Zjc5MDMxM2E2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGJmODA5YjE5ODhhNDZiMDZjOWYxOTE5NDEzYjEwZjkyMjZjNjBmNjY4ODMyZmZkOTU5YWY2MGM4MmEwYScsXG4gICAgICAgICc1M2E1NjI4NTZkY2I2NjQ2ZGM2Yjc0YzVkMWMzNDE4YzZkNGRmZjA4Yzk3Y2QyYmVkNGNiN2Y4OGQ4YzhlNTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZTgnLFxuICAgICAgICAnYmMyZGE4MmI2ZmE1YjU3MWE3ZjA5MDQ5Nzc2YTFlZjdlY2QyOTIyMzgwNTFjMTk4YzFhODRlOTViMmI0YWUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkJyxcbiAgICAgICAgJzQ1NzE1MzRiYWE5NGQzYjVmOWY5OGQwOWZiOTkwYmRkYmQ1ZjViMDNlYzQ4MWYxMGUwZTVkYzg0MWQ3NTViZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTA2MzcyYjBmNGEyMDdhZGY1ZWE5MDVlOGYxNzcxYjRlN2U4ZGJkMWM2YTZjNWI3MjU4NjZhMGFlNGZjZTcyNScsXG4gICAgICAgICc3YTkwODk3NGJjZTE4Y2ZlMTJhMjdiYjJhZDVhNDg4Y2Q3NDg0YTc3ODcxMDQ4NzBiMjcwMzRmOTRlZWUzMWRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTQnLFxuICAgICAgICAnNGI2ZGFkMGI1YWU0NjI1MDcwMTNhZDA2MjQ1YmExOTBiYjQ4NTBmNWYzNmE3ZWVkZGZmMmMyNzUzNGI0NThmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjJyxcbiAgICAgICAgJzE3NzQ5Yzc2NmM5ZDBiMThlMTZmZDA5ZjZkZWY2ODFiNTMwYjk2MTRiZmY3ZGQzM2UwYjM5NDE4MTdkY2FhZTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVhNzRlM2RiZTc3OGIxYjEwZjIzOGFkNjE2ODZhYTVjNzZlM2RiMmJlNDMwNTc2MzI0MjdlMjg0MGZiMjdiNicsXG4gICAgICAgICc2ZTA1NjhkYjliMGIxMzI5N2NmNjc0ZGVjY2I2YWY5MzEyNmI1OTZiOTczZjdiNzc3MDFkM2RiN2YyM2NiOTZmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzknLFxuICAgICAgICAnYzkwZGRmOGRlZTRlOTVjZjU3NzA2NmQ3MDY4MWYwZDM1ZTJhMzNkMmI1NmQyMDMyYjRiMTc1MmQxOTAxYWMwMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxJyxcbiAgICAgICAgJzg5M2ZiNTc4OTUxYWQyNTM3ZjcxOGYyZWFjYmZiYmJiODIzMTRlZWY3ODgwY2ZlOTE3ZTczNWQ5Njk5YTg0YzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDg5NTYyNjU0OGI2NWI4MWUyNjRjNzYzN2M5NzI4NzdkMWQ3MmU1ZjNhOTI1MDE0MzcyZTlmNjU4OGY2YzE0YicsXG4gICAgICAgICdmZWJmYWEzOGYyYmM3ZWFlNzI4ZWM2MDgxOGMzNDBlYjAzNDI4ZDYzMmJiMDY3ZTE3OTM2M2VkNzVkN2Q5OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDMnLFxuICAgICAgICAnMjgwNGRmYTQ0ODA1YTFlNGQ3Yzk5Y2M5NzYyODA4YjA5MmNjNTg0ZDk1ZmYzYjUxMTQ4OGU0ZTc0ZWZkZjZlNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkJyxcbiAgICAgICAgJ2VlZDFkZTdmNjM4ZTAwNzcxZTg5NzY4Y2EzY2E5NDQ3MmQxNTVlODBhZjMyMmVhOWZjYjQyOTFiNmFjOWVjNzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTMwMTY5N2JkZmNkNzA0MzEzYmE0OGU1MWQ1Njc1NDNmMmExODIwMzFlZmQ2OTE1ZGRjMDdiYmNjNGUxNjA3MCcsXG4gICAgICAgICc3MzcwZjkxY2ZiNjdlNGY1MDgxODA5ZmEyNWQ0MGY5YjE3MzVkYmY3YzBhMTFhMTMwYzBkMWEwNDFlMTc3ZWExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDQnLFxuICAgICAgICAnZTUwN2EzNjIwYTM4MjYxYWZmZGNiZDk0MjcyMjJiODM5YWVmYWJlMTU4Mjg5NGQ5OTFkNGQ0OGNiNmVmMTUwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGEnLFxuICAgICAgICAnNjYyYTlmMmRiYTA2Mzk4NmRlMWQ5MGMyYjZiZTIxNWRiYmVhMmNmZTk1NTEwYmZkZjIzY2JmNzk1MDFmZmY4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGYzZmIwMTc2YWY4NWQ2NWZmOTlmZjkxOThjMzYwOTFmNDhlODY1MDM2ODFlM2U2Njg2ZmQ1MDUzMjMxZTExJyxcbiAgICAgICAgJzFlNjM2MzNhZDBlZjRmMWMxNjYxYTZkMGVhMDJiNzI4NmNjN2U3NGVjOTUxZDFjOTgyMmMzODU3NmZlYjczYmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZScsXG4gICAgICAgICdlZmE0NzI2N2ZlYTUyMWExYTlkYzM0M2EzNzM2Yzk3NGMyZmFkYWZhODFlMzZjNTRlN2QyYTRjNjY3MDI0MTRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDEnLFxuICAgICAgICAnMmE3NThlMzAwZmE3OTg0YjQ3MWIwMDZhMWFhZmJiMThkMGE2YjJjMDQyMGU4M2UyMGU4YTk0MjFjZjJjZmQ1MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNjQ1OWUwZWUzNjYyZWM4ZDIzNTQwYzIyM2JjYmRjNTcxY2JjYjk2N2Q3OTQyNGYzY2YyOWViM2RlNmI4MGVmJyxcbiAgICAgICAgJzY3Yzg3NmQwNmYzZTA2ZGUxZGFkZjE2ZTU2NjFkYjNjNGIzYWU2ZDQ4ZTM1YjJmZjMwYmYwYjYxYTcxYmE0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4JyxcbiAgICAgICAgJ2RiOGJhOWZmZjRiNTg2ZDAwYzRiMWY5MTc3YjBlMjhiNWIwZTdiOGY3ODQ1Mjk1YTI5NGM4NDI2NmIxMzMxMjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZCcsXG4gICAgICAgICc2NDhhMzY1Nzc0YjYxZjJmZjEzMGMwYzM1YWVjMWY0ZjE5MjEzYjBjN2UzMzI4NDM5NjcyMjRhZjk2YWI3Yzg0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRkZjljMTQ5MTljZGU2MWY2ZDUxZGZkYmU1ZmVlNWRjZWVjNDE0M2JhOGQxY2E4ODhlOGJkMzczZmQwNTRjOTYnLFxuICAgICAgICAnMzVlYzUxMDkyZDg3MjgwNTA5NzRjMjNhMWQ4NWQ0YjVkNTA2Y2RjMjg4NDkwMTkyZWJhYzA2Y2FkMTBkNWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZCcsXG4gICAgICAgICdkZGI4NGYwZjRhNGRkZDU3NTg0ZjA0NGJmMjYwZTY0MTkwNTMyNmY3NmM2NGM4ZTZiZTdlNWUwM2Q0ZmM1OTlkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTUnLFxuICAgICAgICAnOWExYWYwYjI2YTZhNDgwN2FkZDlhMmRhZjcxZGYyNjI0NjUxNTJiYzNlZTI0YzY1ZTg5OWJlOTMyMzg1YTJhOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTc2ZGY4ZTIzYTA4NDExNDIxNDM5YTQ1MThkYTMxODgwY2VmMGZiYTdkNGRmMTJiMWE2OTczZWVjYjk0MjY2JyxcbiAgICAgICAgJzQwYTZiZjIwZTc2NjQwYjJjOTJiOTdhZmU1OGNkODJjNDMyZTEwYTdmNTE0ZDlmM2VlOGJlMTFhZTFiMjhlYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MScsXG4gICAgICAgICczNDYyNmQ5YWI1YTViMjJmZjcwOThlMTJmMmZmNTgwMDg3YjM4NDExZmYyNGFjNTYzYjUxM2ZjMWZkOWY0M2FjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhYycsXG4gICAgICAgICdjMjU2MjEwMDNkM2Y0MmE4MjdiNzhhMTMwOTNhOTVlZWFjM2QyNmVmYThhOGQ4M2ZjNTE4MGU5MzViY2QwOTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1ZDBmZWYzZWM2ZGIxMDkzOTkwNjRmM2EwZTNiMjg1NTY0NWI0YTkwN2FkMzU0NTI3YWFlNzUxNjNkODI3NTEnLFxuICAgICAgICAnMWYwMzY0ODQxM2EzOGMwYmUyOWQ0OTZlNTgyY2Y1NjYzZTg3NTFlOTY4NzczMzE1ODJjMjM3YTI0ZWIxZjk2MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlJyxcbiAgICAgICAgJzQ5M2QxM2ZlZjUyNGJhMTg4YWY0YzRkYzU0ZDA3OTM2YzdiN2VkNmZiOTBlMmNlYjJjOTUxZTAxZjBjMjk5MDcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MScsXG4gICAgICAgICdjNjBmOWM5MjNjNzI3YjBiNzFiZWYyYzY3ZDFkMTI2ODdmZjdhNjMxODY5MDMxNjZkNjA1YjY4YmFlYzI5M2VjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTY0OWYyMWY1MWJkYmFlN2JlNGFlMzRjZTZlNTIxN2E1OGZkY2U3ZjQ3ZjlhYTdmM2I1OGZhMjEyMGUyYjMnLFxuICAgICAgICAnYmUzMjc5ZWQ1YmJiYjAzYWM2OWE4MGY4OTg3OWFhNWEwMWE2Yjk2NWYxM2Y3ZTU5ZDQ3YTUzMDViYTVhZDkzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmJyxcbiAgICAgICAgJzRkOWY5MmU3MTZkMWM3MzUyNmZjOTljY2ZiOGFkMzRjZTg4NmVlZGZhOGQ4ZTRmMTNhN2Y3MTMxZGViYTk0MTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOScsXG4gICAgICAgICdhZWVmZTkzNzU2YjUzNDBkMmYzYTQ5NThhN2FiYmY1ZTAxNDZlNzdmNjI5NWEwN2I2NzFjZGMxY2MxMDdjZWZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE0NmE3NzhjMDQ2NzBjMmY5MWIwMGFmNDY4MGRmYThiY2UzNDkwNzE3ZDU4YmE4ODlkZGI1OTI4MzY2NjQyYmUnLFxuICAgICAgICAnYjMxOGUwZWMzMzU0MDI4YWRkNjY5ODI3ZjlkNGIyODcwYWFhOTcxZDJmN2U1ZWQxZDBiMjk3NDgzZDgzZWZkMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5JyxcbiAgICAgICAgJzZiODRjNjkyMjM5N2ViYTliNzJjZDI4NzIyODFhNjhhNWU2ODMyOTNhNTdhMjEzYjM4Y2Q4ZDdkM2Y0ZjI4MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMicsXG4gICAgICAgICc4MTU3ZjU1YTdjOTkzMDZjNzljMDc2NjE2MWM5MWUyOTY2YTczODk5ZDI3OWI0OGE2NTVmYmEwZjFhZDgzNmYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E4ZTI4MmZmMGM5NzA2OTA3MjE1ZmY5OGU4ZmQ0MTY2MTUzMTFkZTA0NDZmMWUwNjJhNzNiMDYxMGQwNjRlMTMnLFxuICAgICAgICAnN2Y5NzM1NWI4ZGI4MWMwOWFiZmI3ZjNjNWIyNTE1ODg4YjY3OWEzZTUwZGQ2YmQ2Y2VmN2M3MzExMWY0Y2MwYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjJyxcbiAgICAgICAgJ2NjYzlkYzM3YWJmYzljMTY1N2I0MTU1ZjJjNDdmOWU2NjQ2YjNhMWQ4Y2I5ODU0MzgzZGExM2FjMDc5YWZhNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYScsXG4gICAgICAgICcyZTdlNTUyODg4YzMzMWRkOGJhMDM4NmE0YjljZDY4NDljNjUzZjY0Yzg3MDkzODVlOWI4YWJmODc1MjRmMmZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyYTYzYTUwYWU0MDFlNTZkNjQ1YTExNTNiMTA5YThmY2NhMGE0M2Q1NjFmYmEyZGJiNTEzNDBjOWQ4MmIxNTEnLFxuICAgICAgICAnZTgyZDg2ZmI2NDQzZmNiNzU2NWFlZTU4YjI5NDgyMjBhNzBmNzUwYWY0ODRjYTUyZDQxNDIxNzRkY2Y4OTQwNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczJyxcbiAgICAgICAgJ2Q5OWZjZGQ1YmY2OTAyZTJhZTk2ZGQ2NDQ3YzI5OWExODViOTBhMzkxMzNhZWFiMzU4Mjk5ZTVlOWZhZjY1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OCcsXG4gICAgICAgICczOGVlN2I4Y2JhNTQwNGRkODRhMjViZjM5Y2VjYjJjYTkwMGE3OWM0MmIyNjJlNTU2ZDY0YjFiNTk3NzkwNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzNDY0YTU3YTc4MTAyYWE2MmI2OTc5YWU4MTdmNDYzN2ZmY2ZlZDNjNGIxY2UzMGJjZDYzMDNmNmNhZjY2NmInLFxuICAgICAgICAnNjliZTE1OTAwNDYxNDU4MGVmN2U0MzM0NTNjY2IwY2E0OGYzMDBhODFkMDk0MmUxM2Y0OTVhOTA3ZjZlY2MyNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2JyxcbiAgICAgICAgJ2QzYTgxY2E2ZTc4NWMwNjM4MzkzN2FkZjRiNzk4Y2FhNmU4YTlmYmZhNTQ3YjE2ZDc1OGQ2NjY1ODFmMzNjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhJyxcbiAgICAgICAgJzQwYTMwNDYzYTMzMDUxOTMzNzhmZWRmMzFmN2NjMGViN2FlNzg0ZjA0NTFjYjk0NTllNzFkYzczY2JlZjk0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGVhOTY2NjEzOTUyN2E4YzFkZDk0Y2U0ZjA3MWZkMjNjOGIzNTBjNWE0YmIzMzc0OGM0YmExMTFmYWNjYWUwJyxcbiAgICAgICAgJzYyMGVmYWJiYzhlZTI3ODJlMjRlN2MwY2ZiOTVjNWQ3MzViNzgzYmU5Y2YwZjhlOTU1YWYzNGEzMGU2MmI5NDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4NycsXG4gICAgICAgICc3YTE4OGZhMzUyMGUzMGQ0NjFkYTI1MDEwNDU3MzFjYTk0MTQ2MTk4Mjg4MzM5NTkzN2Y2OGQwMGM2NDRhNTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Y3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWUnLFxuICAgICAgICAnZWE5OGU2NzIzMmQzYjMyOTVkM2I1MzU1MzIxMTVjY2FjODYxMmM3MjE4NTE2MTc1MjZhZTQ3YTljNzdiZmM4MidcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIG5hZjoge1xuICAgIHduZDogNyxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknLFxuICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZjhiZGU0ZDFhMDcyMDkzNTViNGE3MjUwYTVjNTEyOGU4OGI4NGJkZGM2MTlhYjdjYmE4ZDU2OWIyNDBlZmU0JyxcbiAgICAgICAgJ2Q4YWMyMjI2MzZlNWUzZDZkNGRiYTlkZGE2YzljNDI2Zjc4ODI3MWJhYjBkNjg0MGRjYTg3ZDNhYTZhYzYyZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWNiZGYwNjQ2ZTVkYjRlYWEzOThmMzY1ZjJlYTdhMGUzZDQxOWI3ZTAzMzBlMzljZTkyYmRkZWRjYWM0ZjliYycsXG4gICAgICAgICc2YWViY2E0MGJhMjU1OTYwYTMxNzhkNmQ4NjFhNTRkYmE4MTNkMGI4MTNmZGU3YjVhNTA4MjYyODA4NzI2NGRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FjZDQ4NGUyZjBjN2Y2NTMwOWFkMTc4YTlmNTU5YWJkZTA5Nzk2OTc0YzU3ZTcxNGMzNWYxMTBkZmMyN2NjYmUnLFxuICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzRhZTdmODU4YTk0MTFlNWVmNDI0NmI3MGM2NWFhYzU2NDk5ODBiZTVjMTc4OTFiYmVjMTc4OTVkYTAwOGNiJyxcbiAgICAgICAgJ2Q5ODRhMDMyZWI2YjVlMTkwMjQzZGQ1NmQ3YjdiMzY1MzcyZGIxZTJkZmY5ZDZhODMwMWQ3NGM5Yzk1M2M2MWInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjI4NzczYzJkOTc1Mjg4YmM3ZDFkMjA1YzM3NDg2NTFiMDc1ZmJjNjYxMGU1OGNkZGVlZGRmOGYxOTQwNWFhOCcsXG4gICAgICAgICdhYjA5MDJlOGQ4ODBhODk3NTgyMTJlYjY1Y2RhZjQ3M2ExYTA2ZGE1MjFmYTkxZjI5YjVjYjUyZGIwM2VkODEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDc5MjRkNGY3ZDQzZWE5NjVhNDY1YWUzMDk1ZmY0MTEzMWU1OTQ2ZjNjODVmNzllNDRhZGJjZjhlMjdlMDgwZScsXG4gICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RlZmRlYTRjZGI2Nzc3NTBhNDIwZmVlODA3ZWFjZjIxZWI5ODk4YWU3OWI5NzY4NzY2ZTRmYWEwNGEyZDRhMzQnLFxuICAgICAgICAnNDIxMWFiMDY5NDYzNTE2OGU5OTdiMGVhZDJhOTNkYWVjZWQxZjRhMDRhOTVjMGY2Y2ZiMTk5ZjY5ZTU2ZWI3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyYjRlYTBhNzk3YTQ0M2QyOTNlZjVjZmY0NDRmNDk3OWYwNmFjZmViZDdlODZkMjc3NDc1NjU2MTM4Mzg1YjZjJyxcbiAgICAgICAgJzg1ZTg5YmMwMzc5NDVkOTNiMzQzMDgzYjVhMWM4NjEzMWEwMWY2MGM1MDI2OTc2M2I1NzBjODU0ZTVjMDliN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUyYmJmNGE0Y2RkMTI1NjRmOTNmYTMzMmNlMzMzMzAxZDlhZDQwMjcxZjgxMDcxODEzNDBhZWYyNWJlNTlkNScsXG4gICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmYTIxMDRkNmIzOGQxMWIwMjMwMDEwNTU5ODc5MTI0ZTQyYWI4ZGZlZmY1ZmYyOWRjOWNkYWRkNGVjYWNjM2YnLFxuICAgICAgICAnMmRlMTA2ODI5NWRkODY1YjY0NTY5MzM1YmQ1ZGQ4MDE4MWQ3MGVjZmM4ODI2NDg0MjNiYTc2YjUzMmI3ZDY3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyNDgyNzliMDliNGQ2OGRhYjIxYTliMDY2ZWRkYTgzMjYzYzNkODRlMDk1NzJlMjY5Y2EwY2Q3ZjU0NTM3MTQnLFxuICAgICAgICAnNzMwMTZmN2JmMjM0YWFkZTVkMWFhNzFiZGVhMmIxZmYzZmMwZGUyYTg4NzkxMmZmZTU0YTMyY2U5N2NiMzQwMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYWVkNGYyYmUzYThiZjI3OGU3MDEzMmZiMGJlYjc1MjJmNTcwZTE0NGJmNjE1YzA3ZTk5NmQ0NDNkZWU4NzI5JyxcbiAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQ0ZDEyYzcwNjVkODEyZThhY2YyOGQ3Y2JiMTlmOTAxMWVjZDllOWZkZjI4MWIwZTZhM2I1ZTg3ZDIyZTdkYicsXG4gICAgICAgICcyMTE5YTQ2MGNlMzI2Y2RjNzZjNDU5MjZjOTgyZmRhYzBlMTA2ZTg2MWVkZjYxYzVhMDM5MDYzZjBlMGU2NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZhMjQ1YmY2ZGM2OTg1MDRjODlhMjBjZmRlZDYwODUzMTUyYjY5NTMzNmMyODA2M2I2MWM2NWNiZDI2OWU2YjQnLFxuICAgICAgICAnZTAyMmNmNDJjMmJkNGE3MDhiM2Y1MTI2ZjE2YTI0YWQ4YjMzYmE0OGQwNDIzYjZlZmQ1ZTYzNDgxMDBkOGE4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjk3ZmZhNmZkOWRlNjI3YzA3N2UzZDJmZTU0MTA4NGNlMTMzMDBiMGJlYzExNDZmOTVhZTU3ZjBkMGJkNmE1JyxcbiAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1YmRiMDE5OTgxNzE4Yjk4NmQwZjA3ZTgzNGNiMGQ5ZGViODM2MGZmYjdmNjFkZjk4MjM0NWVmMjdhNzQ3OScsXG4gICAgICAgICcyOTcyZDJkZTRmOGQyMDY4MWE3OGQ5M2VjOTZmZTIzYzI2YmZhZTg0ZmIxNGRiNDNiMDFlMWU5MDU2YjhjNDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjJkMTRkYWI0MTUwYmY0OTc0MDJmZGM0NWEyMTVlMTBkY2IwMWMzNTQ5NTliMTBjZmUzMWM3ZTlkODdmZjMzZCcsXG4gICAgICAgICc4MGZjMDZiZDhjYzViMDEwOTgwODhhMTk1MGVlZDBkYjAxYWExMzI5NjdhYjQ3MjIzNWY1NjQyNDgzYjI1ZWFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwYzYwYWQwMDQwZjI3ZGFkZTViNGIwNmM0MDhlNTZiMmM1MGU5ZjU2YjliOGI0MjVlNTU1YzJmODYzMDhiNmYnLFxuICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3YTkzNzVhZDYxNjdhZDU0YWE3NGM2MzQ4Y2M1NGQzNDRjYzVkYzk0ODdkODQ3MDQ5ZDVlYWJiMGZhMDNjOGZiJyxcbiAgICAgICAgJ2QwZTNmYTllY2E4NzI2OTA5NTU5ZTBkNzkyNjkwNDZiZGM1OWVhMTBjNzBjZTJiMDJkNDk5ZWMyMjRkYzdmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNTI4ZWNkOWI2OTZiNTRjOTA3YTllZDA0NTQ0N2E3OWJiNDA4ZWMzOWI2OGRmNTA0YmI1MWY0NTliYzNmZmM5JyxcbiAgICAgICAgJ2VlY2Y0MTI1MzEzNmU1Zjk5OTY2ZjIxODgxZmQ2NTZlYmM0MzQ1NDA1YzUyMGRiYzA2MzQ2NWI1MjE0MDk5MzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDkzNzBhNGI1ZjQzNDEyZWEyNWY1MTRlOGVjZGFkMDUyNjYxMTVlNGE3ZWNiMTM4NzIzMTgwOGY4YjQ1OTYzJyxcbiAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzdmMjMwOTM2ZWU4OGNiYmQ3M2RmOTMwZDY0NzAyZWY4ODFkODExZTBlMTQ5OGUyZjFjMTNlYjFmYzM0NWQ3NCcsXG4gICAgICAgICc5NThlZjQyYTc4ODZiNjQwMGEwODI2NmU5YmExYjM3ODk2Yzk1MzMwZDk3MDc3Y2JiZThlYjNjNzY3MWM2MGQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyZGFjOTkxY2M0Y2U0YjllYTQ0ODg3ZTVjN2MwYmNlNThjODAwNzRhYjlkNGRiYWViMjg1MzFiNzczOWY1MzAnLFxuICAgICAgICAnZTBkZWRjOWIzYjJmOGRhZDRkYTFmMzJkZWMyNTMxZGY5ZWI1ZmJlYjA1OThlNGZkMWExMTdkYmE3MDNhM2MzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNiM2Q5ZjY2MjYyMWZiMWI0YmU4ZmJiZTI1MjAxMjVhMjE2Y2RmYzlkYWUzZGViY2JhNDg1MGM2OTBkNDViJyxcbiAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjE2ZjgwNDI0NGU0NmUyYTA5MjMyZDRhZmYzYjU5OTc2Yjk4ZmFjMTQzMjhhMmQxYTMyNDk2YjQ5OTk4ZjI0NycsXG4gICAgICAgICdjZWRhYmQ5YjgyMjAzZjdlMTNkMjA2ZmNkZjRlMzNkOTJhNmM1M2MyNmU1Y2NlMjZkNjU3OTk2MmM0ZTMxZGY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NhZjc1NDI3MmRjODQ1NjNiMDM1MmI3YTE0MzExYWY1NWQyNDUzMTVhY2UyN2M2NTM2OWUxNWY3MTUxZDQxZDEnLFxuICAgICAgICAnY2I0NzQ2NjBlZjM1ZjVmMmE0MWI2NDNmYTVlNDYwNTc1ZjRmYTliNzk2MjIzMmE1YzMyZjkwODMxOGEwNDQ3NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyNjAwY2E0YjI4MmNiOTg2Zjg1ZDBmMTcwOTk3OWQ4YjQ0YTA5YzA3Y2I4NmQ3YzEyNDQ5N2JjODZmMDgyMTIwJyxcbiAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzYzNWNhNzJkN2U4NDMyYzMzOGVjNTNjZDEyMjIwYmMwMWM0ODY4NWUyNGY3ZGM4YzYwMmE3NzQ2OTk4ZTQzNScsXG4gICAgICAgICc5MWI2NDk2MDk0ODlkNjEzZDFkNWU1OTBmNzhlNmQ3NGVjZmMwNjFkNTcwNDhiYWQ5ZTc2ZjMwMmM1YjljNjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzU0ZTMyMzlmMzI1NTcwY2RiYmY0YTg3ZGVlZThhNjZiN2YyYjMzNDc5ZDQ2OGZiYzFhNTA3NDNiZjU2Y2MxOCcsXG4gICAgICAgICc2NzNmYjg2ZTViZGEzMGZiM2NkMGVkMzA0ZWE0OWEwMjNlZTMzZDAxOTdhNjk1ZDBjNWQ5ODA5M2M1MzY2ODMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNlNmJkMTA3MWExZTk2YWZmNTc4NTljODJkNTcwZjAzMzA4MDA2NjFkMWM5NTJmOWZlMjY5NDY5MWQ5YjllOCcsXG4gICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE4NmI0ODNkMDU2YTAzMzgyNmFlNzNkODhmNzMyOTg1YzRjY2IxZjMyYmEzNWY0YjRjYzQ3ZmRjZjA0YWE2ZWInLFxuICAgICAgICAnM2I5NTJkMzJjNjdjZjc3ZTJlMTc0NDZlMjA0MTgwYWIyMWZiODA5MDg5NTEzOGI0YTRhNzk3Zjg2ZTgwODg4YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZjlkNzBhNmI5ODc2Y2U1NDRjOTg1NjFmNGJlNGY3MjU0NDJlNmQyYjczN2Q5YzkxYTgzMjE3MjRjZTA5NjNmJyxcbiAgICAgICAgJzU1ZWIyZGFmZDg0ZDZjY2Q1Zjg2MmI3ODVkYzM5ZDRhYjE1NzIyMjcyMGVmOWRhMjE3YjhjNDVjZjJiYTI0MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWVkZDVjYzIzYzUxZTg3YTQ5N2NhODE1ZDVkY2UwZjhhYjUyNTU0Zjg0OWVkODk5NWRlNjRjNWYzNGNlNzE0MycsXG4gICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5MDc5OGMyYjY0NzY4MzBkYTEyZmUwMjI4N2U5ZTc3N2FhM2ZiYTFjMzU1YjE3YTcyMmQzNjJmODQ2MTRmYmEnLFxuICAgICAgICAnZTM4ZGE3NmRjZDQ0MDYyMTk4OGQwMGJjZjc5YWYyNWQ1YjI5YzA5NGRiMmEyMzE0NmQwMDNhZmQ0MTk0M2U3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjNjNDIzYTk1ZDlmNWIzMDU0NzU0ZWZhMTUwYWMzOWNkMjk1NTJmZTM2MDI1NzM2MmRmZGVjZWY0MDUzYjQ1JyxcbiAgICAgICAgJ2Y5OGEzZmQ4MzFlYjJiNzQ5YTkzYjBlNmYzNWNmYjQwYzhjZDVhYTY2N2ExNTU4MWJjMmZlZGVkNDk4ZmQ5YzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzY2ZGJiMjRkMTM0ZTc0NWNjY2FhMjhjOTliZjI3NDkwNmJiNjZiMjZkY2Y5OGRmOGQyZmVkNTBkODg0MjQ5YScsXG4gICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5ZGJmNDZmOGM5NDc1OWJhMjEyNzdjMzM3ODRmNDE2NDVmN2I0NGY2YzU5NmE1OGNlOTJlNjY2MTkxYWJlM2UnLFxuICAgICAgICAnYzUzNGFkNDQxNzVmYmMzMDBmNGVhNmNlNjQ4MzA5YTA0MmNlNzM5YTc5MTk3OThjZDg1ZTIxNmM0YTMwN2Y2ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTNhZGE5NTEwM2M0NTM3MzA1ZTY5MWU3NGU5YTRhOGRkNjQ3ZTcxMWE5NWU3M2NiNjJkYzYwMThjZmQ4N2I4JyxcbiAgICAgICAgJ2UxMzgxN2I0NGVlMTRkZTY2M2JmNGJjODA4MzQxZjMyNjk0OWUyMWE2YTc1YzI1NzA3Nzg0MTliZGFmNTczM2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc1NGI0ZmEwZThhY2VkMDZkNDE2N2EyYzU5Y2NhNGNkYTE4NjljMDZlYmFkZmI2NDg4NTUwMDE1YTg4NTIyYycsXG4gICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGRjYWRmNTk5MGUwNDhhYTM4NzRkNDZhYmVmOWQ3MDE4NThmOTVkZTgwNDFkMmE2ODI4Yzk5ZTIyNjI1MTknLFxuICAgICAgICAnZTQ5MWE0MjUzN2Y2ZTU5N2Q1ZDI4YTMyMjRiMWJjMjVkZjkxNTRlZmJkMmVmMWQyY2JiYTJjYWU1MzQ3ZDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTYyNDE0NDUwYzc2YzE2ODljN2I0OGY4MjAyZWMzN2ZiMjI0Y2Y1YWMwYmZhMTU3MDMyOGE4YTNkN2M3N2FiJyxcbiAgICAgICAgJzEwMGI2MTBlYzRmZmI0NzYwZDVjMWZjMTMzZWY2ZjZiMTI1MDdhMDUxZjA0YWM1NzYwYWZhNWIyOWRiODM0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUxNDA4NzgzNDk2NGI1NGIxNWIxNjA2NDRkOTE1NDg1YTE2OTc3MjI1Yjg4NDdiYjBkZDA4NTEzN2VjNDdjYScsXG4gICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzY2MzMGFkNmI0ODNlNGJjNzljZTJjOWRkOGJjNTQ5OTNlOTQ3ZWI4ZGY3ODdiNDQyOTQzZDNmN2I1MjdlYWYnLFxuICAgICAgICAnOGIzNzhhMjJkODI3Mjc4ZDg5YzVlOWJlOGY5NTA4YWUzYzJhZDQ2MjkwMzU4NjMwYWZiMzRkYjA0ZWVkZTBhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjI0ZDg0NzgwNzMyODYwY2UxYzc4ZmNiZmVmZTA4YjJiMjk4MjNkYjkxM2Y2NDkzOTc1YmEwZmY0ODQ3NjEwJyxcbiAgICAgICAgJzY4NjUxY2Y5YjZkYTkwM2UwOTE0NDQ4YzZjZDlkNGNhODk2ODc4ZjUyODJiZTRjOGNjMDZlMmE0MDQwNzg1NzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzMzY2U4MGRhOTU1YThhMjY5MDJjOTU2MzNlNjJhOTg1MTkyNDc0YjVhZjIwN2RhNmRmN2I0ZmQ1ZmM2MWNkNCcsXG4gICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE1ZDk0NDEyNTQ5NDUwNjRjZjFhMWMzM2JiZDNiNDlmODk2NmM1MDkyMTcxZTY5OWVmMjU4ZGZhYjgxYzA0NWMnLFxuICAgICAgICAnZDU2ZWIzMGI2OTQ2M2U3MjM0ZjUxMzdiNzNiODQxNzc0MzQ4MDBiYWNlYmZjNjg1ZmMzN2JiZTllZmU0MDcwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMWQwZmNmMmVjOWRlNjc1YjYxMjEzNmU1Y2U3MGQyNzFjMjE0MTdjOWQyYjhhYWFhYzEzODU5OWQwNzE3OTQwJyxcbiAgICAgICAgJ2VkZDc3ZjUwYmNiNWEzY2FiMmU5MDczNzMwOTY2N2YyNjQxNDYyYTU0MDcwZjNkNTE5MjEyZDM5YzE5N2E2MjknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTIyZmJlMTVjMGFmOGNjYzU3ODBjMDczNWY4NGRiZTlhNzkwYmFkZWU4MjQ1YzA2YzdjYTM3MzMxY2IzNjk4MCcsXG4gICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzExMDkxZGQ5ODYwZThlMjBlZTEzNDczYzExNTVmNWY2OTYzNWUzOTQ3MDRlYWE3NDAwOTQ1MjI0NmNmYTliMycsXG4gICAgICAgICc2NmRiNjU2Zjg3ZDFmMDRmZmZkMWYwNDc4OGMwNjgzMDg3MWVjNWE2NGZlZWU2ODViZDgwZjBiMTI4NmQ4Mzc0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0YzFmZDA0ZDMwMWJlODliMzFjMDQ0MmQzZTZhYzI0ODgzOTI4YjQ1YTkzNDA3ODE4NjdkNDIzMmVjMmRiZGYnLFxuICAgICAgICAnOTQxNDY4NWU5N2IxYjU5NTRiZDQ2ZjczMDE3NDEzNmQ1N2YxY2VlYjQ4NzQ0M2RjNTMyMTg1N2JhNzNhYmVlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyMTllYTVkNmI1NDcwMWMxYzE0ZGU1YjU1N2ViNDJhOGQxM2YzYWJiY2QwOGFmZmNjMmE1ZTZiMDQ5YjhkNjMnLFxuICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkN2I4NzQwZjc0YThmYmFhYjFmNjgzZGI4ZjQ1ZGUyNjU0M2E1NDkwYmNhNjI3MDg3MjM2OTEyNDY5YTBiNDQ4JyxcbiAgICAgICAgJ2ZhNzc5NjgxMjhkOWM5MmVlMTAxMGYzMzdhZDQ3MTdlZmYxNWRiNWVkM2MwNDliMzQxMWUwMzE1ZWFhNDU5M2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJkMzFjMjIyZjhmNmYwZWY4NmY3Yzk4ZDNhMzMzNWVhZDViY2QzMmFiZGQ5NDI4OWZlNGQzMDkxYWE4MjRiZicsXG4gICAgICAgICc1ZjMwMzJmNTg5MjE1NmUzOWNjZDNkNzkxNWI5ZTFkYTJlNmRhYzllNmYyNmU5NjExMThkMTRiODQ2MmUxNjYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0NjFmMzcxOTE0YWIzMjY3MTA0NWExNTVkOTgzMWVhODc5M2Q3N2NkNTk1OTJjNDM0MGY4NmNiYzE4MzQ3YjUnLFxuICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTA3OWFkYjFkZjE4NjAwNzQzNTZhMjVhYTM4MjA2YTZkNzE2YjJjM2U2NzQ1M2QyODc2OThiYWQ3YjJiMmQ2JyxcbiAgICAgICAgJzhkYzI0MTJhYWZlM2JlNWM0YzVmMzdlMGVjYzVmOWY2YTQ0Njk4OWFmMDRjNGUyNWViYWFjNDc5ZWMxYzhjMWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTZlYzkzZTQ0N2VjODNmMDQ2N2IxODMwMmVlNjIwZjdlNjVkZTMzMTg3NGM5ZGM3MmJmZDg2MTZiYTlkYTZiNScsXG4gICAgICAgICc1ZTQ2MzExNTBlNjJmYjQwZDBlOGMyYTdjYTU4MDRhMzlkNTgxODZhNTBlNDk3MTM5NjI2Nzc4ZTI1YjA2NzRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTVmOTgwYzI0NWY2ZjAzODk3ODI5MGFmYTcwYjZiZDg4NTU4OTdmOThiNmFhNDg1Yjk2MDY1ZDUzN2JkOTknLFxuICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OGM5NDA3NTQ0YWMxMzI2OTJlZTE5MTBhMDI0Mzk5NThhZTA0ODc3MTUxMzQyZWE5NmM0YjZiMzVhNDlmNTEnLFxuICAgICAgICAnZjNlMDMxOTE2OWViOWI4NWQ1NDA0Nzk1NTM5YTVlNjhmYTFmYmQ1ODNjMDY0ZDI0NjJiNjc1ZjE5NGEzZGRiNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTRmNGJlMjE5YTFhNzcwMTZkY2Q4Mzg0MzFhZWEwMDAxY2RjOGFlN2E2ZmM2ODg3MjY1NzhkOTcwMjg1N2E1JyxcbiAgICAgICAgJzQyMjQyYTk2OTI4M2E1ZjMzOWJhN2YwNzVlMzZiYTJhZjkyNWNlMzBkNzY3ZWQ2ZTU1ZjRiMDMxODgwZDU2MmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU5OGE4MDMwZGE2ZDg2YzZiYzdmMmY1MTQ0ZWE1NDlkMjgyMTFlYTU4ZmFhNzBlYmY0YzFlNjY1YzFmZTliNScsXG4gICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MTkxNjM2NWFiYjJiNWQwOTE5MmY1ZjJkYmVhZmVjMjA4ZjAyMGYxMjU3MGExODRkYmFkYzNlNTg1OTU5OTcnLFxuICAgICAgICAnNGYxNDM1MWQwMDg3ZWZhNDlkMjQ1YjMyODk4NDk4OWQ1Y2FmOTQ1MGYzNGJmYzBlZDE2ZTk2YjU4ZmE5OTEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0MWQ2MDYzYTU4NmZhNDc1YTcyNDYwNGRhMDNiYzViOTJhMmUwZDJlMGEzNmFjZmU0YzczYTU1MTQ3NDI4ODEnLFxuICAgICAgICAnNzM4NjdmNTljMDY1OWU4MTkwNGY5YTFjNzU0MzY5OGU2MjU2MmQ2NzQ0YzE2OWNlN2EzNmRlMDFhOGQ2MTU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlOTViYjM5OWE2OTcxZDM3NjAyNjk0N2Y4OWJkZTJmMjgyYjMzODEwOTI4YmU0ZGVkMTEyYWM0ZDcwZTIwZDUnLFxuICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNmU0NjQxYTUzOTQ4ZmQ0NzZjMzlmOGE5OWZkOTc0ZTVlYzA3NTY0YjUzMTVkOGJmOTk0NzFiY2EwZWYyZjY2JyxcbiAgICAgICAgJ2QyNDI0YjFiMWFiZTRlYjgxNjQyMjdiMDg1YzlhYTk0NTZlYTEzNDkzZmQ1NjNlMDZmZDUxY2Y1Njk0Yzc4ZmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzM2NTgxZWE3YmZiYmIyOTBjMTkxYTJmNTA3YTQxY2Y1NjQzODQyMTcwZTkxNGZhZWFiMjdjMmM1NzlmNzI2JyxcbiAgICAgICAgJ2VhZDEyMTY4NTk1ZmUxYmU5OTI1MjEyOWI2ZTU2YjMzOTFmN2FiMTQxMGNkMWUwZWYzZGNkY2FiZDJmZGEyMjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGFiODk4MTZkYWRmZDZiNmExZjI2MzRmY2YwMGVjODQwMzc4MTAyNWVkNjg5MGM0ODQ5NzQyNzA2YmQ0M2VkZScsXG4gICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlMzNmMWE3NDZjOWM1Nzc4MTMzMzQ0ZDkyOTlmY2FhMjBiMDkzOGU4YWNmZjI1NDRiYjQwMjg0YjhjNWZiOTQnLFxuICAgICAgICAnNjA2NjAyNTdkZDExYjNhYTljOGVkNjE4ZDI0ZWRmZjIzMDZkMzIwZjFkMDMwMTBlMzNhN2QyMDU3ZjNiM2I2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1YjdjMWRjYjNjZWMxYjdlZTdmMzBkZWQ3OWRkMjBhMGVkMWY0Y2MxOGNiY2ZjZmE0MTAzNjFmZDhmMDhmMzEnLFxuICAgICAgICAnM2Q5OGE5Y2RkMDI2ZGQ0M2YzOTA0OGYyNWE4ODQ3ZjRmY2FmYWQxODk1ZDdhNjMzYzZmZWQzYzM1ZTk5OTUxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOWRmOWZiZDhkOWU0NjUwOTI3NWY0YjEyNWQ2ZDQ1ZDdmYmU5YTNiODc4YTdhZjg3MmEyODAwNjYxYWM1ZjUxJyxcbiAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMGIxY2FlMDZiMGE4NDdhM2ZlYTZlNjcxYWFmOGFkZmRmZTU4Y2EyZjc2ODEwNWM4MDgyYjJlNDQ5ZmNlMjUyJyxcbiAgICAgICAgJ2FlNDM0MTAyZWRkZTA5NThlYzRiMTlkOTE3YTZhMjhlNmI3MmRhMTgzNGFmZjBlNjUwZjA0OTUwM2EyOTZjZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU4Y2VhZmI5YjNlOWExMzZkYzdmZjY3ZTg0MDI5NWI0OTlkZmIzYjIxMzNlNGJhMTEzZjJlNGMwZTEyMWU1JyxcbiAgICAgICAgJ2NmMjE3NDExOGM4YjZkN2E0YjQ4ZjZkNTM0Y2U1Yzc5NDIyYzA4NmE2MzQ2MDUwMmI4MjdjZTYyYTMyNjY4M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDI0YTQ0ZTA0N2UxOWI2ZjVhZmI4MWM3Y2EyZjY5MDgwYTUwNzY2ODlhMDEwOTE5ZjQyNzI1YzJiNzg5YTMzYicsXG4gICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhMDE2MDZhN2E2YzljZGQyNDlmZGZjZmFjYjk5NTg0MDAxZWRkMjhhYmJhYjc3YjUxMDRlOThlOGUzYjM1ZDQnLFxuICAgICAgICAnMzIyYWY0OTA4YzczMTJiMGNmYmZlMzY5ZjdhN2IzY2RiN2Q0NDk0YmMyODIzNzAwY2ZkNjUyMTg4YTNlYTk4ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjhhZGRiZjJiNjYxYzhhNmM2MzI4NjU1ZWI5NjY1MTI1MjAwN2Q4YzVlYTMxYmU0YWQxOTZkZThjZTIxMzFmJyxcbiAgICAgICAgJzY3NDllNjdjMDI5Yjg1ZjUyYTAzNGVhZmQwOTY4MzZiMjUyMDgxODY4MGUyNmFjOGYzZGZiY2RiNzE3NDk3MDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNhZTE5NzQ1NjZjYTA2Y2M1MTZkNDdlMGZiMTY1YTY3NGEzZGFiY2ZjYTE1ZTcyMmYwZTM0NTBmNDU4ODknLFxuICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OTFlZTM1NTMxM2Q5OTcyMWNmNjk5M2ZmZWQxZTNlMzAxOTkzZmYzZWQyNTg4MDIwNzVlYThjZWQzOTdlMjQ2JyxcbiAgICAgICAgJ2IwZWE1NThhMTEzYzMwYmVhNjBmYzQ3NzU0NjBjNzkwMWZmMGIwNTNkMjVjYTJiZGVlZTk4ZjFhNGJlNWQxOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTEzOTZkNTVmZGE1NGM0OWYxOWFhOTczMThkOGRhNjFmYTg1ODRlNDdiMDg0OTQ1MDc3Y2YwMzI1NWI1Mjk4NCcsXG4gICAgICAgICc5OThjNzRhOGNkNDVhYzAxMjg5ZDU4MzNhN2JlYjQ3NDRmZjUzNmIwMWIyNTdiZTRjNTc2N2JlYTkzZWE1N2E0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNjNWQyYTFiYTM5YzVhMTc5MDAwMDczOGM5ZTBjNDBiOGRjZGZkNTQ2ODc1NGI2NDA1NTQwMTU3ZTAxN2FhN2EnLFxuICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYzg3MDRiOGE2MGEwZGVmYTNhOTlhNzI5OWYyZTljM2ZiYzM5NWFmYjA0YWMwNzg0MjVlZjhhMTc5M2NjMDMwJyxcbiAgICAgICAgJ2JkZDQ2MDM5ZmVlZDE3ODgxZDFlMDg2MmRiMzQ3ZjhjZjM5NWI3NGZjNGJjZGM0ZTk0MGI3NGUzYWMxZjFiMTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzUzM2U0ZjdlYTg1NTVhYWNkOTc3N2FjNWNhZDI5Yjk3ZGQ0ZGVmY2NjNTNlZTdlYTIwNDExOWIyODg5YjE5NycsXG4gICAgICAgICc2ZjBhMjU2YmM1ZWZkZjQyOWEyZmI2MjQyZjFhNDNhMmQ5YjkyNWJiNGE0YjNhMjZiYjhlMGY0NWViNTk2MDk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2MxNGY4ZjJjY2IyN2Q2ZjEwOWY2ZDA4ZDAzY2M5NmE2OWJhOGMzNGVlYzA3YmJjZjU2NmQ0OGUzM2RhNjU5MycsXG4gICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E2Y2JjMzA0NmJjNmE0NTBiYWMyNDc4OWZhMTcxMTVhNGM5NzM5ZWQ3NWY4ZjIxY2U0NDFmNzJlMGI5MGU2ZWYnLFxuICAgICAgICAnMjFhZTdmNDY4MGU4ODliYjEzMDYxOWUyYzBmOTVhMzYwY2ViNTczYzcwNjAzMTM5ODYyYWZkNjE3ZmE5YjlmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0N2Q2ZDlhMDJjNDg5MjdlYmZiODZjMTM1OWIxY2FmMTMwYTNjMDI2N2QxMWNlNjM0NGIzOWY5OWQ0M2NjMzgnLFxuICAgICAgICAnNjBlYTdmNjFhMzUzNTI0ZDFjOTg3ZjZlY2VjOTJmMDg2ZDU2NWFiNjg3ODcwY2IxMjY4OWZmMWUzMWM3NDQ0OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY1NDVkMjE4MWRiOGQ5ODNmN2RjYjM3NWVmNTg2NmQ0N2M2N2IxYmYzMWM4Y2Y4NTVlZjc0MzdiNzI2NTZhJyxcbiAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQwNzQ3Y2M5ZDAxMmNiMWExM2I4MTQ4MzA5YzZkZTdlYzI1ZDY5NDVkNjU3MTQ2YjlkNTk5NGI4ZmViMTExMScsXG4gICAgICAgICc1Y2E1NjA3NTNiZTJhMTJmYzZkZTZjYWYyY2I0ODk1NjVkYjkzNjE1NmI5NTE0ZTFiYjVlODMwMzdlMGZhMmQ0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlNDJjOGVjODJjOTk3OThjY2YzYTYxMGJlODcwZTc4MzM4YzdmNzEzMzQ4YmQzNGM4MjAzZWY0MDM3ZjM1MDInLFxuICAgICAgICAnNzU3MWQ3NGVlNWUwZmI5MmE3YThiMzNhMDc3ODMzNDFhNTQ5MjE0NGNjNTRiY2M0MGE5NDQ3MzY5MzYwNjQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNzc1YWI3MDg5YmM2YWY4MjNhYmEyZTFhZjcwYjIzNmQyNTFjYWRiMGM4Njc0MzI4NzUyMmExYjNiMGRlZGVhJyxcbiAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2VlMzFjYmY3ZTM0ZWMzNzlkOTRmYjgxNGQzZDc3NWFkOTU0NTk1ZDEzMTRiYTg4NDY5NTllM2U4MmY3NGUyNicsXG4gICAgICAgICc4ZmQ2NGExNGMwNmI1ODljMjZiOTQ3YWUyYmNmNmJmYTAxNDllZjBiZTE0ZWQ0ZDgwZjQ0OGEwMWM0M2IxYzZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I0ZjllYWVhMDliNjkxNzYxOWY2ZWE2YTRlYjU0NjRlZmRkYjU4ZmQ0NWIxZWJlZmNkYzFhMDFkMDhiNDc5ODYnLFxuICAgICAgICAnMzllNWM5OTI1YjVhNTRiMDc0MzNhNGYxOGM2MTcyNmY4YmIxMzFjMDEyY2E1NDJlYjI0YThhYzA3MjAwNjgyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNDI2M2RmYzNkMmRmOTIzYTAxNzlhNDg5NjZkMzBjZTg0ZTI1MTVhZmMzZGNjYzFiNzc5MDc3OTJlYmNjNjBlJyxcbiAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDg0NTc1MjQ4MjBmYTY1YTRmOGQzNWViNjkzMDg1N2MwMDMyYWNjMGE0YTJkZTQyMjIzM2VlZGE4OTc2MTJjNCcsXG4gICAgICAgICcyNWE3NDhhYjM2Nzk3OWQ5ODczM2MzOGExZmExYzJlN2RjNmNjMDdkYjJkNjBhOWFlN2E3NmFhYTQ5YmQwZjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmZWVlZjE4ODExMDFmMmNiMTE2NDRmM2EyYWZkZmMyMDQ1ZTE5OTE5MTUyOTIzZjM2N2ExNzY3YzExY2NlZGEnLFxuICAgICAgICAnZWNmYjcwNTZjZjFkZTA0MmY5NDIwYmFiMzk2NzkzYzBjMzkwYmRlNzRiNGJiZGZmMTZhODNhZTA5YTlhNzUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZDdlZjZiMTc1NDNmODM3M2M1NzNmNDRlMWYzODk4MzVkODliY2JjNjA2MmNlZDM2YzgyZGY4M2I4ZmFlODU5JyxcbiAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTc1NjA1ZDU5MTAyYTVhMjY4NDUwMGQzYjk5MWYyZTNmM2M4OGI5MzIyNTU0NzAzNWFmMjVhZjY2ZTA0NTQxZicsXG4gICAgICAgICdmNWM1NDc1NGE4ZjcxZWU1NDBiOWI0ODcyODQ3M2UzMTRmNzI5YWM1MzA4YjA2OTM4MzYwOTkwZTJiZmFkMTI1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ViOTg2NjBmNGM0ZGZhYTA2YTJiZTQ1M2Q1MDIwYmM5OWEwYzJlNjBhYmUzODg0NTdkZDQzZmVmYjFlZDYyMGMnLFxuICAgICAgICAnNmNiOWE4ODc2ZDljYjg1MjA2MDlhZjNhZGQyNmNkMjBhMGE3Y2Q4YTk0MTExMzFjZTg1ZjQ0MTAwMDk5MjIzZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxM2U4N2IwMjdkODUxNGQzNTkzOWYyZTY4OTJiMTk5MjIxNTQ1OTY5NDE4ODgzMzZkYzM1NjNlM2I4ZGJhOTQyJyxcbiAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUxNjMwMjZlOWZkNmZlMDE3YzM4ZjA2YTViZTZmYzEyNTQyNGIzNzFjZTI3MDhlN2JmNDQ5MTY5MWU1NzY0YScsXG4gICAgICAgICcxYWNiMjUwZjI1NWRkNjFjNDNkOTRjY2M2NzBkMGY1OGY0OWFlM2ZhMTViOTY2MjNlNTQzMGRhMGFkNmM2MmIyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IyNjhmNWVmOWFkNTFlNGQ3OGRlM2E3NTBjMmRjODliMWU2MjZkNDM1MDU4Njc5OTk5MzJlNWRiMzNhZjNkODAnLFxuICAgICAgICAnNWYzMTBkNGIzYzk5YjllYmIxOWY3N2Q0MWMxZGVlMDE4Y2YwZDM0ZmQ0MTkxNjE0MDAzZTk0NWExMjE2ZTQyMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjA3ZjMxMThhOWRmMDM1ZTlmYWQ4NWViNmM3YmZlNDJiMDJmMDFjYTk5Y2VlYTNiZjdmZmRiYTkzYzQ3NTBkJyxcbiAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGQ4Yjk4NTVjN2MwNTJhMzQxNDZmZDIwZmZiNjU4YmVhNGI5ZjY5ZTBkODI1ZWJlYzE2ZThjM2NlMmI1MjZhMScsXG4gICAgICAgICdjZGI1NTllZWRjMmQ3OWY5MjZiYWY0NGZiODRlYTRkNDRiY2Y1MGZlZTUxZDdjZWIzMGUyZTdmNDYzMDM2NzU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUyZGIwYjUzODRkZmJmMDViZmE5ZDQ3MmQ3YWUyNmRmZTRiODUxY2VjYTkxYjFlYmE1NDI2MzE4MGRhMzJiNjMnLFxuICAgICAgICAnYzNiOTk3ZDA1MGVlNWQ0MjNlYmFmNjZhNmRiOWY1N2IzMTgwYzkwMjg3NTY3OWRlOTI0YjY5ZDg0YTdiMzc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U2MmY5NDkwZDNkNTFkYTYzOTVlZmQyNGU4MDkxOWNjN2QwZjI5YzNmM2ZhNDhjNmZmZjU0M2JlY2JkNDMzNTInLFxuICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3ZjMwZWEyNDc2YjM5OWI0OTU3NTA5Yzg4Zjc3ZDAxOTFhZmEyZmY1Y2I3YjE0ZmQ2ZDhlN2Q2NWFhYWIxMTkzJyxcbiAgICAgICAgJ2NhNWVmN2Q0YjIzMWM5NGMzYjE1Mzg5YTVmNjMxMWU5ZGFmZjdiYjY3YjEwM2U5ODgwZWY0YmZmNjM3YWNhZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTA5OGZmMWUxZDlmMTRmYjQ2YTIxMGZhZGE2YzkwM2ZlZjBmYjdiNGExZGQxZDlhYzYwYTAzNjE4MDBiN2EwMCcsXG4gICAgICAgICc5NzMxMTQxZDgxZmM4ZjgwODRkMzdjNmU3NTQyMDA2YjNlZTFiNDBkNjBkZmU1MzYyYTViMTMyZmQxN2RkYzAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJiNzhjN2RlOWVlNTEyYTcyODk1YmU2YjljYmVmYTZlMmYzYzRjY2NlNDQ1Yzk2YjlmMmM4MWUyNzc4YWQ1OCcsXG4gICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyY2I3NGZkZGM4ZTlmYmNkMDc2ZWVmMmE3YzcyYjBjZTM3ZDUwZjA4MjY5ZGZjMDc0YjU4MTU1MDU0N2E0ZjcnLFxuICAgICAgICAnZDNhYTJlZDcxYzlkZDIyNDdhNjJkZjA2MjczNmViMGJhZGRlYTllMzYxMjJkMmJlODY0MWFiY2IwMDVjYzRhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDM4NDQ3NTY2ZDRkN2JlZGFkYzI5OTQ5NmFiMzU3NDI2MDA5YTM1ZjIzNWNiMTQxYmUwZDk5Y2QxMGFlM2E4JyxcbiAgICAgICAgJ2M0ZTEwMjA5MTY5ODBhNGRhNWQwMWFjNWU2YWQzMzA3MzRlZjBkNzkwNjYzMWM0ZjIzOTA0MjZiMmVkZDc5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDE2MmQ0ODhiODk0MDIwMzliNTg0YzZmYzZjMzA4ODcwNTg3ZDljNDZmNjYwYjg3OGFiNjVjODJjNzExZDY3ZScsXG4gICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNmYWQzZmE4NGNhZjBmMzRmMGY4OWJmZDJkY2Y1NGZjMTc1ZDc2N2FlYzNlNTA2ODRmM2JhNGE0YmY1ZjY4M2QnLFxuICAgICAgICAnY2QxYmM3Y2I2Y2M0MDdiYjJmMGNhNjQ3YzcxOGE3MzBjZjcxODcyZTdkMGQyYTUzZmEyMGVmY2RmZTYxODI2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY3NGYyNjAwYTMwMDdhMDA1NjhjMWE3Y2UwNWQwODE2YzFmYjg0YmYxMzcwNzk4ZjFjNjk1MzJmYWViMWE4NmInLFxuICAgICAgICAnMjk5ZDIxZjk0MTNmMzNiM2VkZjQzYjI1NzAwNDU4MGI3MGRiNTdkYTBiMTgyMjU5ZTA5ZWVjYzY5ZTBkMzhhNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMzJmNGRhNTRhZGU3NGFiYjgxYjgxNWFkMWZiM2IyNjNkODJkNmM2OTI3MTRiY2ZmODdkMjliZDVlZTlmMDhmJyxcbiAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzBlNGU2NzA0MzUzODU1NTZlNTkzNjU3MTM1ODQ1ZDM2ZmJiNjkzMWY3MmIwOGNiMWVkOTU0ZjFlM2NlM2ZmNicsXG4gICAgICAgICc0NjJmOWJjZTYxOTg5ODYzODQ5OTM1MDExM2JiYzliMTBhODc4ZDM1ZGE3MDc0MGRjNjk1YTU1OWViODhkYjdiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JlMjA2MjAwM2M1MWNjMzAwNDY4MjkwNDMzMGU0ZGVlN2YzZGNkMTBiMDFlNTgwYmYxOTcxYjA0ZDRjYWQyOTcnLFxuICAgICAgICAnNjIxODhiYzQ5ZDYxZTU0Mjg1NzNkNDhhNzRlMWM2NTViMWM2MTA5MDkwNTY4MmEwZDU1NThlZDcyZGNjYjliYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MzE0NDQyM2FjZTM0NTFlZDI5ZTBmYjlhYzJhZjIxMWNiNmU4NGE2MDFkZjU5OTNjNDE5ODU5ZmZmNWRmMDRhJyxcbiAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjAxNWY4MDQ0ZjVmY2JkY2YyMWNhMjZkNmMzNGZiODE5NzgyOTIwNWM3YjdkMmE3Y2I2NjQxOGMxNTdiMTEyYycsXG4gICAgICAgICdhYjhjMWUwODZkMDRlODEzNzQ0YTY1NWIyZGY4ZDVmODNiM2NkYzZmYWEzMDg4YzFkM2FlYTE0NTRlM2ExZDVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1ZTllMWRhNjQ5ZDk3ZDg5ZTQ4NjgxMTdhNDY1YTNhNGY4YTE4ZGU1N2ExNDBkMzZiM2YyYWYzNDFhMjFiNTInLFxuICAgICAgICAnNGNiMDQ0MzdmMzkxZWQ3MzExMWExM2NjMWQ0ZGQwZGIxNjkzNDY1YzIyNDA0ODBkODk1NWU4NTkyZjI3NDQ3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2FlNDEwNDdkZDdjYTA2NWRiZjhlZDc3Yjk5MjQzOTk4MzAwNWNkNzJlMTZkNmY5OTZhNTMxNmQzNjk2NmJiJyxcbiAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzZTI3NjNkODg1Zjk1OGZjNjZjZGQyMjgwMGYwYTQ4NzE5N2QwYTgyZTM3N2I0OWY4MGFmODdjODk3YjA2NScsXG4gICAgICAgICdiZmVmYWNkYjBlNWQwZmQ3ZGYzYTMxMWE5NGRlMDYyYjI2YjgwYzYxZmJjOTc1MDhiNzk5OTI2NzFlZjdjYTdmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5ODVmZGZkMTI3YzA1NjdjNmY1M2VjMWJiNjNlYzMxNThlNTk3YzQwYmZlNzQ3YzgzY2RkZmM5MTA2NDE5MTcnLFxuICAgICAgICAnNjAzYzEyZGFmM2Q5ODYyZWYyYjI1ZmUxZGUyODlhZWQyNGVkMjkxZTBlYzY3MDg3MDNhNWJkNTY3ZjMyZWQwMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NGExYWQ2YjVmNzZlMzlkYjJkZDI0OTQxMGVhYzdmOTllNzRjNTljYjgzZDJkMGVkNWZmMTU0M2RhNzcwM2U5JyxcbiAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzA2ODJhNTA3MDMzNzVmNjAyZDQxNjY2NGJhMTliN2ZjOWJhYjQyYzcyNzQ3NDYzYTcxZDA4OTZiMjJmNmRhMycsXG4gICAgICAgICc1NTNlMDRmNmIwMThiNGZhNmM4ZjM5ZTdmMzExZDMxNzYyOTBkMGUwZjE5Y2E3M2YxNzcxNGQ5OTc3YTIyZmY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzllMjE1OGYwZDdjMGQ1ZjI2YzM3OTFlZmVmYTc5NTk3NjU0ZTdhMmIyNDY0ZjUyYjFlZTZjMTM0Nzc2OWVmNTcnLFxuICAgICAgICAnNzEyZmNkZDFiOTA1M2YwOTAwM2EzNDgxZmE3NzYyZTlmZmQ3YzhlZjM1YTM4NTA5ZTJmYmYyNjI5MDA4MzczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NmUyNjk4OWE0M2M5Y2ZlYmE0MDI5YzIwMjUzOGMyODE3MmU1NjZlM2M0ZmNlNzMyMjg1N2YzYmUzMjdkNjYnLFxuICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NWQ0NmVmZWEzNzcxZTZlNjhhYmI4OWExM2FkNzQ3ZWNmMTg5MjM5M2RmYzRmMWI3MDA0Nzg4YzUwMzc0ZGE4JyxcbiAgICAgICAgJzk4NTIzOTBhOTk1MDc2NzlmZDBiODZmZDJiMzlhODY4ZDdlZmMyMjE1MTM0NmUxYTNjYTQ3MjY1ODZhNmJlZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODA5YTIwYzY3ZDY0OTAwZmZiNjk4YzRjODI1ZjZkNWYyMzEwZmIwNDUxYzg2OTM0NWI3MzE5ZjY0NTYwNTcyMScsXG4gICAgICAgICc5ZTk5NDk4MGQ5OTE3ZTIyYjc2YjA2MTkyN2ZhMDQxNDNkMDk2Y2NjNTQ5NjNlNmE1ZWJmYTVmM2Y4ZTI4NmMxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFiMzg5MDNhNDNmN2YxMTRlZDQ1MDBiNGVhYzcwODNmZGVmZWNlMWNmMjljNjM1MjhkNTYzNDQ2Zjk3MmMxODAnLFxuICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOSdcbiAgICAgIF1cbiAgICBdXG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBibihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBibihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzKFNob3J0Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgYm4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBibihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCh0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cbiAgdmFyIGJhc2lzO1xuICBpZiAoY29uZi5iYXNpcykge1xuICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgYm4odmVjLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IGJuKHZlYy5iLCAxNilcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXNcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IGJuLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgYm4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgYm4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4uc2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgYm4oMSk7XG4gIHZhciB5MSA9IG5ldyBibigwKTtcbiAgdmFyIHgyID0gbmV3IGJuKDApO1xuICB2YXIgeTIgPSBuZXcgYm4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5zaWduKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5zaWduKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH1cbiAgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcbiAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgdmFyIHYyID0gYmFzaXNbMV07XG5cbiAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcbiAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG4gIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cbiAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcbiAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKG9kZCwgeCkge1xuICB4ID0gbmV3IGJuKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuXG4gIC8vIFhYWCBJcyB0aGVyZSBhbnkgd2F5IHRvIHRlbGwgaWYgdGhlIG51bWJlciBpcyBvZGQgd2l0aG91dCBjb252ZXJ0aW5nIGl0XG4gIC8vIHRvIG5vbi1yZWQgZm9ybT9cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmluZilcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IHBvaW50Lng7XG4gIHZhciB5ID0gcG9pbnQueTtcblxuICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG4gICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLnNpZ24pIHtcbiAgICAgIHNwbGl0LmsxLnNpZ24gPSAhc3BsaXQuazEuc2lnbjtcbiAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNwbGl0LmsyLnNpZ24pIHtcbiAgICAgIHNwbGl0LmsyLnNpZ24gPSAhc3BsaXQuazIuc2lnbjtcbiAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICB9XG5cbiAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICB9XG4gIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyKTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgYm4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBibih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IGJuKGssIDE2KTtcblxuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgYm4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgYm4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBibih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgYm4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBKUG9pbnQgeDogJyArIHRoaXMueC50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgYm4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgYm4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IGJuKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IGJuKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgYm4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHopIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB6KTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAvLyBOby1vcFxufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXNocm4oMSkpXG4gICAgYml0cy5wdXNoKHQuYW5kbG4oMSkpO1xuXG4gIGZvciAodmFyIGkgPSBiaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGJpdHNbaV0gPT09IDApIHtcbiAgICAgIC8vIE4gKiBRICsgUSA9ICgoTiAvIDIpICogUSArIFEpKSArIChOIC8gMikgKiBRXG4gICAgICBhID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgPSAyICogKChOIC8gMikgKiBRICsgUSkpXG4gICAgICBiID0gYi5kYmwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTiAqIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSArICgoTiAvIDIpICogUSlcbiAgICAgIGIgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSArIFEgPSAyICogKChOIC8gMikgKiBRICsgUSlcbiAgICAgIGEgPSBhLmRibCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gRWR3YXJkc0N1cnZlKGNvbmYpIHtcbiAgLy8gTk9URTogSW1wb3J0YW50IGFzIHdlIGFyZSBjcmVhdGluZyBwb2ludCBpbiBCYXNlLmNhbGwoKVxuICB0aGlzLnR3aXN0ZWQgPSAoY29uZi5hIHwgMCkgIT09IDE7XG4gIHRoaXMubU9uZUEgPSB0aGlzLnR3aXN0ZWQgJiYgKGNvbmYuYSB8IDApID09PSAtMTtcbiAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG5cbiAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IGJuKGNvbmYuYSwgMTYpLm1vZCh0aGlzLnJlZC5tKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYyA9IG5ldyBibihjb25mLmMsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gIHRoaXMuZCA9IG5ldyBibihjb25mLmQsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuZGQgPSB0aGlzLmQucmVkQWRkKHRoaXMuZCk7XG5cbiAgYXNzZXJ0KCF0aGlzLnR3aXN0ZWQgfHwgdGhpcy5jLmZyb21SZWQoKS5jbXBuKDEpID09PSAwKTtcbiAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxBID0gZnVuY3Rpb24gX211bEEobnVtKSB7XG4gIGlmICh0aGlzLm1PbmVBKVxuICAgIHJldHVybiBudW0ucmVkTmVnKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5hLnJlZE11bChudW0pO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQyA9IGZ1bmN0aW9uIF9tdWxDKG51bSkge1xuICBpZiAodGhpcy5vbmVDKVxuICAgIHJldHVybiBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jLnJlZE11bChudW0pO1xufTtcblxuLy8gSnVzdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNob3J0IGN1cnZlXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWChvZGQsIHgpIHtcbiAgeCA9IG5ldyBibih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKHgyKSk7XG4gIHZhciBsaHMgPSB0aGlzLm9uZS5yZWRTdWIodGhpcy5jMi5yZWRNdWwodGhpcy5kKS5yZWRNdWwoeDIpKTtcblxuICB2YXIgeSA9IHJocy5yZWRNdWwobGhzLnJlZEludm0oKSkucmVkU3FydCgpO1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIGN1cnZlLm9uZSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgYm4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgYm4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgYm4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgICAgICB0aGlzLnkuY21wKHRoaXMueikgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICB2YXIgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgLy8gRiA9IEUgKyBEXG4gICAgdmFyIGYgPSBlLnJlZEFkZChkKTtcbiAgICBpZiAodGhpcy56T25lKSB7XG4gICAgICAvLyBYMyA9IChCIC0gQyAtIEQpICogKEYgLSAyKVxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRTdWIoZCkucmVkTXVsKGYucmVkU3ViKHRoaXMuY3VydmUudHdvKSk7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRl4yIC0gMiAqIEZcbiAgICAgIG56ID0gZi5yZWRTcXIoKS5yZWRTdWIoZikucmVkU3ViKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIID0gWjFeMlxuICAgICAgdmFyIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAvLyBKID0gRiAtIDIgKiBIXG4gICAgICB2YXIgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgdmFyIGUgPSBjLnJlZEFkZChkKTtcbiAgICAvLyBIID0gKGMgKiBaMSleMlxuICAgIHZhciBoID0gdGhpcy5jdXJ2ZS5fbXVsQyh0aGlzLmMucmVkTXVsKHRoaXMueikpLnJlZFNxcigpO1xuICAgIC8vIEogPSBFIC0gMiAqIEhcbiAgICB2YXIgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEJhc2VDdXJ2ZVxuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcblxudmFyIGdldE5BRiA9IGVsbGlwdGljLnV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSBlbGxpcHRpYy51dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgYm4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBibi5yZWQoY29uZi5wcmltZSkgOiBibi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgYm4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBibigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IGJuKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IGJuKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydChwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIHZhciBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3KTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4pIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0pO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMyAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG4gIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBjcnQ7XG5mdW5jdGlvbiBibGluZChwcml2KSB7XG4gIHZhciByID0gZ2V0cihwcml2KTtcbiAgdmFyIGJsaW5kZXIgPSByLnRvUmVkKGJuLm1vbnQocHJpdi5tb2R1bHVzKSlcbiAgLnJlZFBvdyhuZXcgYm4ocHJpdi5wdWJsaWNFeHBvbmVudCkpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHtcbiAgICBibGluZGVyOiBibGluZGVyLFxuICAgIHVuYmxpbmRlcjpyLmludm0ocHJpdi5tb2R1bHVzKVxuICB9O1xufVxuZnVuY3Rpb24gY3J0KG1zZywgcHJpdikge1xuICB2YXIgYmxpbmRzID0gYmxpbmQocHJpdik7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbW9kID0gYm4ubW9udChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYmxpbmRlZCA9IG5ldyBibihtc2cpLm11bChibGluZHMuYmxpbmRlcikubW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS5tb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS5tb2QocHJpdi5tb2R1bHVzKS50b0FycmF5KCkpO1xuICBpZiAob3V0Lmxlbmd0aCA8IGxlbikge1xuICAgIHZhciBwcmVmaXggPSBuZXcgQnVmZmVyKGxlbiAtIG91dC5sZW5ndGgpO1xuICAgIHByZWZpeC5maWxsKDApO1xuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgb3V0XSwgbGVuKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIubW9kKHByaXYucHJpbWUxKSB8fCAhci5tb2QocHJpdi5wcmltZTIpKSB7XG4gICAgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxemFXZHVMMjV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUxYSnpZUzlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJblpoY2lCaWJpQTlJSEpsY1hWcGNtVW9KMkp1TG1wekp5azdYRzUyWVhJZ2NtRnVaRzl0UW5sMFpYTWdQU0J5WlhGMWFYSmxLQ2R5WVc1a2IyMWllWFJsY3ljcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQmpjblE3WEc1bWRXNWpkR2x2YmlCaWJHbHVaQ2h3Y21sMktTQjdYRzRnSUhaaGNpQnlJRDBnWjJWMGNpaHdjbWwyS1R0Y2JpQWdkbUZ5SUdKc2FXNWtaWElnUFNCeUxuUnZVbVZrS0dKdUxtMXZiblFvY0hKcGRpNXRiMlIxYkhWektTbGNiaUFnTG5KbFpGQnZkeWh1WlhjZ1ltNG9jSEpwZGk1d2RXSnNhV05GZUhCdmJtVnVkQ2twTG1aeWIyMVNaV1FvS1R0Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNCaWJHbHVaR1Z5T2lCaWJHbHVaR1Z5TEZ4dUlDQWdJSFZ1WW14cGJtUmxjanB5TG1sdWRtMG9jSEpwZGk1dGIyUjFiSFZ6S1Z4dUlDQjlPMXh1ZlZ4dVpuVnVZM1JwYjI0Z1kzSjBLRzF6Wnl3Z2NISnBkaWtnZTF4dUlDQjJZWElnWW14cGJtUnpJRDBnWW14cGJtUW9jSEpwZGlrN1hHNGdJSFpoY2lCc1pXNGdQU0J3Y21sMkxtMXZaSFZzZFhNdVlubDBaVXhsYm1kMGFDZ3BPMXh1SUNCMllYSWdiVzlrSUQwZ1ltNHViVzl1ZENod2NtbDJMbTF2WkhWc2RYTXBPMXh1SUNCMllYSWdZbXhwYm1SbFpDQTlJRzVsZHlCaWJpaHRjMmNwTG0xMWJDaGliR2x1WkhNdVlteHBibVJsY2lrdWJXOWtLSEJ5YVhZdWJXOWtkV3gxY3lrN1hHNGdJSFpoY2lCak1TQTlJR0pzYVc1a1pXUXVkRzlTWldRb1ltNHViVzl1ZENod2NtbDJMbkJ5YVcxbE1Ta3BPMXh1SUNCMllYSWdZeklnUFNCaWJHbHVaR1ZrTG5SdlVtVmtLR0p1TG0xdmJuUW9jSEpwZGk1d2NtbHRaVElwS1R0Y2JpQWdkbUZ5SUhGcGJuWWdQU0J3Y21sMkxtTnZaV1ptYVdOcFpXNTBPMXh1SUNCMllYSWdjQ0E5SUhCeWFYWXVjSEpwYldVeE8xeHVJQ0IyWVhJZ2NTQTlJSEJ5YVhZdWNISnBiV1V5TzF4dUlDQjJZWElnYlRFZ1BTQmpNUzV5WldSUWIzY29jSEpwZGk1bGVIQnZibVZ1ZERFcE8xeHVJQ0IyWVhJZ2JUSWdQU0JqTWk1eVpXUlFiM2NvY0hKcGRpNWxlSEJ2Ym1WdWRESXBPMXh1SUNCdE1TQTlJRzB4TG1aeWIyMVNaV1FvS1R0Y2JpQWdiVElnUFNCdE1pNW1jbTl0VW1Wa0tDazdYRzRnSUhaaGNpQm9JRDBnYlRFdWFYTjFZaWh0TWlrdWFXMTFiQ2h4YVc1MktTNXRiMlFvY0NrN1hHNGdJR2d1YVcxMWJDaHhLVHRjYmlBZ2JUSXVhV0ZrWkNob0tUdGNiaUFnZG1GeUlHOTFkQ0E5SUc1bGR5QkNkV1ptWlhJb2JUSXVhVzExYkNoaWJHbHVaSE11ZFc1aWJHbHVaR1Z5S1M1dGIyUW9jSEpwZGk1dGIyUjFiSFZ6S1M1MGIwRnljbUY1S0NrcE8xeHVJQ0JwWmlBb2IzVjBMbXhsYm1kMGFDQThJR3hsYmlrZ2UxeHVJQ0FnSUhaaGNpQndjbVZtYVhnZ1BTQnVaWGNnUW5WbVptVnlLR3hsYmlBdElHOTFkQzVzWlc1bmRHZ3BPMXh1SUNBZ0lIQnlaV1pwZUM1bWFXeHNLREFwTzF4dUlDQWdJRzkxZENBOUlFSjFabVpsY2k1amIyNWpZWFFvVzNCeVpXWnBlQ3dnYjNWMFhTd2diR1Z1S1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnYjNWME8xeHVmVnh1WTNKMExtZGxkSElnUFNCblpYUnlPMXh1Wm5WdVkzUnBiMjRnWjJWMGNpaHdjbWwyS1NCN1hHNGdJSFpoY2lCc1pXNGdQU0J3Y21sMkxtMXZaSFZzZFhNdVlubDBaVXhsYm1kMGFDZ3BPMXh1SUNCMllYSWdjaUE5SUc1bGR5QmliaWh5WVc1a2IyMUNlWFJsY3loc1pXNHBLVHRjYmlBZ2QyaHBiR1VnS0hJdVkyMXdLSEJ5YVhZdWJXOWtkV3gxY3lrZ1BqMGdJREFnZkh3Z0lYSXViVzlrS0hCeWFYWXVjSEpwYldVeEtTQjhmQ0FoY2k1dGIyUW9jSEpwZGk1d2NtbHRaVElwS1NCN1hHNGdJQ0FnY2lBOUlHNWxkeUJpYmloeVlXNWtiMjFDZVhSbGN5aHNaVzRwS1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnY2p0Y2JuMGlYWDA9IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cbmlmKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXM7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXI7XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcyhzaXplLCBjYikge1xuICB2YXIgYnl0ZXMgPSBuZXcgQnVmZmVyKHNpemUpOyAvL2luIGJyb3dzZXJpZnksIHRoaXMgaXMgYW4gZXh0ZW5kZWQgVWludDhBcnJheVxuICAgIC8qIFRoaXMgd2lsbCBub3Qgd29yayBpbiBvbGRlciBicm93c2Vycy5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICovXG5cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gb2xkQnJvd3NlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG4nK1xuICAgICAgJ3VzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnXG4gICAgKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZjbUZ1Wkc5dFlubDBaWE12WW5KdmQzTmxjaTVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWTNKNWNIUnZJRDBnWjJ4dlltRnNMbU55ZVhCMGJ5QjhmQ0JuYkc5aVlXd3ViWE5EY25sd2RHOWNibWxtS0dOeWVYQjBieUFtSmlCamNubHdkRzh1WjJWMFVtRnVaRzl0Vm1Gc2RXVnpLU0I3WEc0Z0lHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2NtRnVaRzl0UW5sMFpYTTdYRzU5SUdWc2MyVWdlMXh1SUNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUc5c1pFSnliM2R6WlhJN1hHNTlYRzVtZFc1amRHbHZiaUJ5WVc1a2IyMUNlWFJsY3loemFYcGxMQ0JqWWlrZ2UxeHVJQ0IyWVhJZ1lubDBaWE1nUFNCdVpYY2dRblZtWm1WeUtITnBlbVVwT3lBdkwybHVJR0p5YjNkelpYSnBabmtzSUhSb2FYTWdhWE1nWVc0Z1pYaDBaVzVrWldRZ1ZXbHVkRGhCY25KaGVWeHVJQ0FnSUM4cUlGUm9hWE1nZDJsc2JDQnViM1FnZDI5eWF5QnBiaUJ2YkdSbGNpQmljbTkzYzJWeWN5NWNiaUFnSUNBZ0tpQlRaV1VnYUhSMGNITTZMeTlrWlhabGJHOXdaWEl1Ylc5NmFXeHNZUzV2Y21jdlpXNHRWVk12Wkc5amN5OVhaV0l2UVZCSkwzZHBibVJ2ZHk1amNubHdkRzh1WjJWMFVtRnVaRzl0Vm1Gc2RXVnpYRzRnSUNBZ0lDb3ZYRzVjYmlBZ1kzSjVjSFJ2TG1kbGRGSmhibVJ2YlZaaGJIVmxjeWhpZVhSbGN5azdYRzRnSUdsbUlDaDBlWEJsYjJZZ1kySWdQVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNCeVpYUjFjbTRnY0hKdlkyVnpjeTV1WlhoMFZHbGpheWhtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNCallpaHVkV3hzTENCaWVYUmxjeWs3WEc0Z0lDQWdmU2s3WEc0Z0lIMWNiaUFnY21WMGRYSnVJR0o1ZEdWek8xeHVmVnh1Wm5WdVkzUnBiMjRnYjJ4a1FuSnZkM05sY2lncElIdGNiaUFnZEdoeWIzY2dibVYzSUVWeWNtOXlLRnh1SUNBZ0lDQWdKM05sWTNWeVpTQnlZVzVrYjIwZ2JuVnRZbVZ5SUdkbGJtVnlZWFJwYjI0Z2JtOTBJSE4xY0hCdmNuUmxaQ0JpZVNCMGFHbHpJR0p5YjNkelpYSmNYRzRuSzF4dUlDQWdJQ0FnSjNWelpTQmphSEp2YldVc0lFWnBjbVZHYjNnZ2IzSWdTVzUwWlhKdVpYUWdSWGh3Ykc5eVpYSWdNVEVuWEc0Z0lDQWdLVnh1ZlZ4dUlsMTkiLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbi8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4vLyBhcmNoaXRlY3R1cmUgeWV0LlxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufVxuXG4vLyBCTlxuXG5mdW5jdGlvbiBCTihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAvLyBNYXkgYmUgYG5ldyBCTihibilgID9cbiAgaWYgKG51bWJlciAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobnVtYmVyLndvcmRzKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgdGhpcy53b3JkcyA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgYmFzZSA9IDEwO1xuICB9XG5cbiAgaWYgKG51bWJlciAhPT0gbnVsbClcbiAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG59XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gQk47XG5lbHNlXG4gIGV4cG9ydHMuQk4gPSBCTjtcblxuQk4uQk4gPSBCTjtcbkJOLndvcmRTaXplID0gMjY7XG5cbkJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gIH1cbiAgaWYgKGJhc2UgPT09ICdoZXgnKVxuICAgIGJhc2UgPSAxNjtcbiAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICB2YXIgc3RhcnQgPSAwO1xuICBpZiAobnVtYmVyWzBdID09PSAnLScpXG4gICAgc3RhcnQrKztcblxuICBpZiAoYmFzZSA9PT0gMTYpXG4gICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gIGVsc2VcbiAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG5cbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxuICAgIHRoaXMuc2lnbiA9IHRydWU7XG5cbiAgdGhpcy5zdHJpcCgpO1xuXG4gIGlmIChlbmRpYW4gIT09ICdsZScpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIGlmIChudW1iZXIgPCAwKSB7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICBudW1iZXIgPSAtbnVtYmVyO1xuICB9XG4gIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgIHRoaXMud29yZHMgPSBbXG4gICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAyO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgdGhpcy53b3JkcyA9IFtcbiAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgMVxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAzO1xuICB9XG5cbiAgaWYgKGVuZGlhbiAhPT0gJ2xlJylcbiAgICByZXR1cm47XG5cbiAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcblxuICB2YXIgb2ZmID0gMDtcbiAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgIGZvciAodmFyIGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUhleChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHIgPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICByIDw8PSA0O1xuXG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NClcbiAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKVxuICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAvLyAnMCcgLSAnOSdcbiAgICBlbHNlXG4gICAgICByIHw9IGMgJiAweGY7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbkJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXgobnVtYmVyLCBzdGFydCkge1xuICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICB2YXIgb2ZmID0gMDtcbiAgZm9yICh2YXIgaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgdmFyIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIG9mZiArPSAyNDtcbiAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICBvZmYgLT0gMjY7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICB2YXIgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICB9XG4gIHRoaXMuc3RyaXAoKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQmFzZShzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICB2YXIgciA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgIHIgKj0gbXVsO1xuXG4gICAgLy8gJ2EnXG4gICAgaWYgKGMgPj0gNDkpXG4gICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgIC8vICdBJ1xuICAgIGVsc2UgaWYgKGMgPj0gMTcpXG4gICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgIC8vICcwJyAtICc5J1xuICAgIGVsc2VcbiAgICAgIHIgKz0gYztcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpXG4gICAgbGltYkxlbisrO1xuICBsaW1iTGVuLS07XG4gIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgdmFyIHdvcmQgPSAwO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcbiAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgfVxuXG4gIGlmIChtb2QgIT09IDApIHtcbiAgICB2YXIgcG93ID0gMTtcbiAgICB2YXIgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2Q7IGkrKylcbiAgICAgIHBvdyAqPSBiYXNlO1xuICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApXG4gICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gIH1cbn07XG5cbkJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShkZXN0KSB7XG4gIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGRlc3Quc2lnbiA9IHRoaXMuc2lnbjtcbiAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbn07XG5cbkJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgdGhpcy5jb3B5KHIpO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAoKSB7XG4gIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKVxuICAgIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xufTtcblxuQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbigpIHtcbiAgLy8gLTAgPSAwXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKVxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG59O1xuXG4vKlxuXG52YXIgemVyb3MgPSBbXTtcbnZhciBncm91cFNpemVzID0gW107XG52YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG52YXIgcyA9ICcnO1xudmFyIGkgPSAtMTtcbndoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICB6ZXJvc1tpXSA9IHM7XG4gIHMgKz0gJzAnO1xufVxuZ3JvdXBTaXplc1swXSA9IDA7XG5ncm91cFNpemVzWzFdID0gMDtcbmdyb3VwQmFzZXNbMF0gPSAwO1xuZ3JvdXBCYXNlc1sxXSA9IDA7XG52YXIgYmFzZSA9IDIgLSAxO1xud2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgZ3JvdXBTaXplICs9IDE7XG4gIH1cbiAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbn1cblxuKi9cblxudmFyIHplcm9zID0gW1xuICAnJyxcbiAgJzAnLFxuICAnMDAnLFxuICAnMDAwJyxcbiAgJzAwMDAnLFxuICAnMDAwMDAnLFxuICAnMDAwMDAwJyxcbiAgJzAwMDAwMDAnLFxuICAnMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5dO1xuXG52YXIgZ3JvdXBTaXplcyA9IFtcbiAgMCwgMCxcbiAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICA1LCA1LCA1LCA1LCA1LCA1LCA1XG5dO1xuXG52YXIgZ3JvdXBCYXNlcyA9IFtcbiAgMCwgMCxcbiAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG5dO1xuXG5CTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhiYXNlLCBwYWRkaW5nKSB7XG4gIGJhc2UgPSBiYXNlIHx8IDEwO1xuICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICBlbHNlXG4gICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICBvZmYgKz0gMjtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMClcbiAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgaWYgKHRoaXMuc2lnbilcbiAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICByZXR1cm4gb3V0O1xuICB9IGVsc2UgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgIHZhciBvdXQgPSAnJztcbiAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICBjLnNpZ24gPSBmYWxzZTtcbiAgICB3aGlsZSAoYy5jbXBuKDApICE9PSAwKSB7XG4gICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICBpZiAodGhpcy5zaWduKVxuICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9XG59O1xuXG5CTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG59O1xuXG5CTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoZW5kaWFuKSB7XG4gIHRoaXMuc3RyaXAoKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh0aGlzLmJ5dGVMZW5ndGgoKSk7XG4gIHJlc1swXSA9IDA7XG5cbiAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gIGlmIChlbmRpYW4gIT09ICdsZScpIHtcbiAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBxLmNtcG4oMCkgIT09IDA7IGkrKykge1xuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgcS5pc2hybig4KTtcblxuICAgICAgcmVzW3Jlcy5sZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3N1bWUgbGl0dGxlLWVuZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBxLmNtcG4oMCkgIT09IDA7IGkrKykge1xuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgcS5pc2hybig4KTtcblxuICAgICAgcmVzW2ldID0gYjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKE1hdGguY2x6MzIpIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICB9O1xufSBlbHNlIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICByZXR1cm4gciArIHQ7XG4gIH07XG59XG5cbkJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHModykge1xuICAvLyBTaG9ydC1jdXRcbiAgaWYgKHcgPT09IDApXG4gICAgcmV0dXJuIDI2O1xuXG4gIHZhciB0ID0gdztcbiAgdmFyIHIgPSAwO1xuICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgciArPSAxMztcbiAgICB0ID4+Pj0gMTM7XG4gIH1cbiAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICByICs9IDc7XG4gICAgdCA+Pj49IDc7XG4gIH1cbiAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgIHIgKz0gNDtcbiAgICB0ID4+Pj0gNDtcbiAgfVxuICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgciArPSAyO1xuICAgIHQgPj4+PSAyO1xuICB9XG4gIGlmICgodCAmIDB4MSkgPT09IDApXG4gICAgcisrO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbkJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGgoKSB7XG4gIHZhciBoaSA9IDA7XG4gIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG59O1xuXG4vLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG5CTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cygpIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgciA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgciArPSBiO1xuICAgIGlmIChiICE9PSAyNilcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbn07XG5cbi8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbkJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblxuICB2YXIgciA9IHRoaXMuY2xvbmUoKTtcbiAgci5zaWduID0gIXRoaXMuc2lnbjtcbiAgcmV0dXJuIHI7XG59O1xuXG5cbi8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gfHwgbnVtLnNpZ247XG5cbiAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aClcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuXG4vLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IobnVtKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG59O1xuXG5cbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gJiYgbnVtLnNpZ247XG5cbiAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICBiID0gbnVtO1xuICBlbHNlXG4gICAgYiA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG59O1xuXG5cbi8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gfHwgbnVtLnNpZ247XG5cbiAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICB2YXIgYTtcbiAgdmFyIGI7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXG4gIGlmICh0aGlzICE9PSBhKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG59O1xuXG5cbi8vIFNldCBgYml0YCBvZiBgdGhpc2BcbkJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0bihiaXQsIHZhbCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICB3aGlsZSAodGhpcy5sZW5ndGggPD0gb2ZmKVxuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXG4gIGlmICh2YWwpXG4gICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gIGVsc2VcbiAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKG51bSkge1xuICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gIGlmICh0aGlzLnNpZ24gJiYgIW51bS5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdmFyIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICB0aGlzLnNpZ24gPSAhdGhpcy5zaWduO1xuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgfSBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgciA9IHRoaXMuaXN1YihudW0pO1xuICAgIG51bS5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgfVxuXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgdmFyIGE7XG4gIHZhciBiO1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSBhLndvcmRzW2ldICsgYi53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gIH1cbiAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSBhLndvcmRzW2ldICsgY2Fycnk7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSByID4+PiAyNjtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbkJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobnVtKSB7XG4gIGlmIChudW0uc2lnbiAmJiAhdGhpcy5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICBudW0uc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghbnVtLnNpZ24gJiYgdGhpcy5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xufTtcblxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihudW0pIHtcbiAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgaWYgKG51bS5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgIG51bS5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgfSBlbHNlIGlmICh0aGlzLnNpZ24pIHtcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmlhZGQobnVtKTtcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGEgPiBiXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKGNtcCA+IDApIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IGEud29yZHNbaV0gLSBiLndvcmRzW2ldICsgY2Fycnk7XG4gICAgY2FycnkgPSByID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICB9XG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gYS53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICBpZiAoYSAhPT0gdGhpcylcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG59O1xuXG4vKlxuLy8gTk9URTogVGhpcyBjb3VsZCBiZSBwb3RlbnRpb25hbGx5IHVzZWQgdG8gZ2VuZXJhdGUgbG9vcC1sZXNzIG11bHRpcGxpY2F0aW9uc1xuZnVuY3Rpb24gX2dlbkNvbWJNdWxUbyhhbGVuLCBibGVuKSB7XG4gIHZhciBsZW4gPSBhbGVuICsgYmxlbiAtIDE7XG4gIHZhciBzcmMgPSBbXG4gICAgJ3ZhciBhID0gdGhpcy53b3JkcywgYiA9IG51bS53b3JkcywgbyA9IG91dC53b3JkcywgYyA9IDAsIHcsICcgK1xuICAgICAgICAnbWFzayA9IDB4M2ZmZmZmZiwgc2hpZnQgPSAweDQwMDAwMDA7JyxcbiAgICAnb3V0Lmxlbmd0aCA9ICcgKyBsZW4gKyAnOydcbiAgXTtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgIHZhciBtaW5KID0gTWF0aC5tYXgoMCwgayAtIGFsZW4gKyAxKTtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIGJsZW4gLSAxKTtcblxuICAgIGZvciAodmFyIGogPSBtaW5KOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgIHZhciBtdWwgPSAnYVsnICsgaSArICddICogYlsnICsgaiArICddJztcblxuICAgICAgaWYgKGogPT09IG1pbkopIHtcbiAgICAgICAgc3JjLnB1c2goJ3cgPSAnICsgbXVsICsgJyArIGM7Jyk7XG4gICAgICAgIHNyYy5wdXNoKCdjID0gKHcgLyBzaGlmdCkgfCAwOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goJ3cgKz0gJyArIG11bCArICc7Jyk7XG4gICAgICAgIHNyYy5wdXNoKCdjICs9ICh3IC8gc2hpZnQpIHwgMDsnKTtcbiAgICAgIH1cbiAgICAgIHNyYy5wdXNoKCd3ICY9IG1hc2s7Jyk7XG4gICAgfVxuICAgIHNyYy5wdXNoKCdvWycgKyBrICsgJ10gPSB3OycpO1xuICB9XG4gIHNyYy5wdXNoKCdpZiAoYyAhPT0gMCkgeycsXG4gICAgICAgICAgICcgIG9bJyArIGsgKyAnXSA9IGM7JyxcbiAgICAgICAgICAgJyAgb3V0Lmxlbmd0aCsrOycsXG4gICAgICAgICAgICd9JyxcbiAgICAgICAgICAgJ3JldHVybiBvdXQ7Jyk7XG5cbiAgcmV0dXJuIHNyYy5qb2luKCdcXG4nKTtcbn1cbiovXG5cbkJOLnByb3RvdHlwZS5fc21hbGxNdWxUbyA9IGZ1bmN0aW9uIF9zbWFsbE11bFRvKG51bSwgb3V0KSB7XG4gIG91dC5zaWduID0gbnVtLnNpZ24gIT09IHRoaXMuc2lnbjtcbiAgb3V0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gdGhpcy5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcbiAgICB9XG4gICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgY2FycnkgPSBuY2Fycnk7XG4gIH1cbiAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gIH0gZWxzZSB7XG4gICAgb3V0Lmxlbmd0aC0tO1xuICB9XG5cbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLl9iaWdNdWxUbyA9IGZ1bmN0aW9uIF9iaWdNdWxUbyhudW0sIG91dCkge1xuICBvdXQuc2lnbiA9IG51bS5zaWduICE9PSB0aGlzLnNpZ247XG4gIG91dC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGhuY2FycnkgPSAwO1xuICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICBobmNhcnJ5ID0gMDtcbiAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHRoaXMubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgfVxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gIH1cbiAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gIH0gZWxzZSB7XG4gICAgb3V0Lmxlbmd0aC0tO1xuICB9XG5cbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8obnVtLCBvdXQpIHtcbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCA8IDYzKVxuICAgIHJlcyA9IHRoaXMuX3NtYWxsTXVsVG8obnVtLCBvdXQpO1xuICBlbHNlXG4gICAgcmVzID0gdGhpcy5fYmlnTXVsVG8obnVtLCBvdXQpO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG5CTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKG51bSkge1xuICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xufTtcblxuLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbkJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChudW0pIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMCB8fCBudW0uY21wbigwKSA9PT0gMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciB0bGVuID0gdGhpcy5sZW5ndGg7XG4gIHZhciBubGVuID0gbnVtLmxlbmd0aDtcblxuICB0aGlzLnNpZ24gPSBudW0uc2lnbiAhPT0gdGhpcy5zaWduO1xuICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID0gMDtcblxuICBmb3IgKHZhciBrID0gdGhpcy5sZW5ndGggLSAyOyBrID49IDA7IGstLSkge1xuICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgY2FycnlgLFxuICAgIC8vIG5vdGUgdGhhdCBjYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciByd29yZCA9IDA7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBubGVuIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSB0bGVuICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal07XG4gICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIGxvICs9IHJ3b3JkO1xuICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICB9XG4gICAgdGhpcy53b3Jkc1trXSA9IHJ3b3JkO1xuICAgIHRoaXMud29yZHNbayArIDFdICs9IGNhcnJ5O1xuICAgIGNhcnJ5ID0gMDtcbiAgfVxuXG4gIC8vIFByb3BhZ2F0ZSBvdmVyZmxvd3NcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldICsgY2Fycnk7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbihudW0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblxuICAvLyBDYXJyeVxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKiBudW07XG4gICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICBjYXJyeSA+Pj0gMjY7XG4gICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbn07XG5cbi8vIGB0aGlzYCAqIGB0aGlzYFxuQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxcigpIHtcbiAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xufTtcblxuLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoKSB7XG4gIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbn07XG5cbi8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuKGJpdHMpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgIHZhciBjID0gKHRoaXMud29yZHNbaV0gLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5KSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzICE9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB0aGlzLmxlbmd0aCArPSBzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbi8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4vLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbi8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbkJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgdmFyIGg7XG4gIGlmIChoaW50KVxuICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICBlbHNlXG4gICAgaCA9IDA7XG5cbiAgdmFyIHIgPSBiaXRzICUgMjY7XG4gIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICBoIC09IHM7XG4gIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gIGlmIChtYXNrZWRXb3Jkcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gIH1cblxuICBpZiAocyA9PT0gMCkge1xuICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV07XG4gICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgfVxuXG4gIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApXG4gICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgdGhpcy5zdHJpcCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU2hpZnQtbGVmdFxuQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbn07XG5cbi8vIFNoaWZ0LXJpZ2h0XG5CTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4oYml0cykge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xufTtcblxuLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbkJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuKGJpdCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICB2YXIgciA9IGJpdCAlIDI2O1xuICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICB2YXIgcSA9IDEgPDwgcjtcblxuICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICByZXR1cm4gISEodyAmIHEpO1xufTtcblxuLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbkJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24oYml0cykge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICBhc3NlcnQoIXRoaXMuc2lnbiwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gIGlmIChyICE9PSAwKVxuICAgIHMrKztcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbkJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG59O1xuXG4vLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW0gPCAwKVxuICAgIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gIGlmICh0aGlzLnNpZ24pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IG51bSkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtIHRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbihudW0pIHtcbiAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgLy8gQ2FycnlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICBlbHNlXG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW0gPCAwKVxuICAgIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gIGlmICh0aGlzLnNpZ24pIHtcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gIC8vIENhcnJ5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicygpIHtcbiAgdGhpcy5zaWduID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzKCkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwobnVtLCBtdWwsIHNoaWZ0KSB7XG4gIC8vIEJpZ2dlciBzdG9yYWdlIGlzIG5lZWRlZFxuICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICB2YXIgaTtcbiAgaWYgKHRoaXMud29yZHMubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0W2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB0aGlzLndvcmRzID0gdDtcbiAgfSBlbHNlIHtcbiAgICBpID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICAvLyBaZXJvaWZ5IHJlc3RcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgbGVuKTtcbiAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2kgKyBzaGlmdF0gKyBjYXJyeTtcbiAgICB2YXIgcmlnaHQgPSBudW0ud29yZHNbaV0gKiBtdWw7XG4gICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgfVxuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpICsgc2hpZnRdICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gIH1cblxuICBpZiAoY2FycnkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IC10aGlzLndvcmRzW2ldICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICB9XG4gIHRoaXMuc2lnbiA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2KG51bSwgbW9kZSkge1xuICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBiID0gbnVtO1xuXG4gIC8vIE5vcm1hbGl6ZVxuICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdO1xuICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgYiA9IGIuc2hsbihzaGlmdCk7XG4gICAgYS5pc2hsbihzaGlmdCk7XG4gICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIHZhciBxO1xuXG4gIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspXG4gICAgICBxLndvcmRzW2ldID0gMDtcbiAgfVxuXG4gIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgaWYgKCFkaWZmLnNpZ24pIHtcbiAgICBhID0gZGlmZjtcbiAgICBpZiAocSlcbiAgICAgIHEud29yZHNbbV0gPSAxO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgIHZhciBxaiA9IGEud29yZHNbYi5sZW5ndGggKyBqXSAqIDB4NDAwMDAwMCArIGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV07XG5cbiAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgIC8vICgweDdmZmZmZmYpXG4gICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICB3aGlsZSAoYS5zaWduKSB7XG4gICAgICBxai0tO1xuICAgICAgYS5zaWduID0gZmFsc2U7XG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgIGlmIChhLmNtcG4oMCkgIT09IDApXG4gICAgICAgIGEuc2lnbiA9ICFhLnNpZ247XG4gICAgfVxuICAgIGlmIChxKVxuICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICB9XG4gIGlmIChxKVxuICAgIHEuc3RyaXAoKTtcbiAgYS5zdHJpcCgpO1xuXG4gIC8vIERlbm9ybWFsaXplXG4gIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMClcbiAgICBhLmlzaHJuKHNoaWZ0KTtcbiAgcmV0dXJuIHsgZGl2OiBxID8gcSA6IG51bGwsIG1vZDogYSB9O1xufTtcblxuQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZChudW0sIG1vZGUpIHtcbiAgYXNzZXJ0KG51bS5jbXBuKDApICE9PSAwKTtcblxuICBpZiAodGhpcy5zaWduICYmICFudW0uc2lnbikge1xuICAgIHZhciByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuICAgIHZhciBkaXY7XG4gICAgdmFyIG1vZDtcbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgIGlmIChtb2RlICE9PSAnZGl2JylcbiAgICAgIG1vZCA9IHJlcy5tb2QuY21wbigwKSA9PT0gMCA/IHJlcy5tb2QgOiBudW0uc3ViKHJlcy5tb2QpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXY6IGRpdixcbiAgICAgIG1vZDogbW9kXG4gICAgfTtcbiAgfSBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG4gICAgdmFyIGRpdjtcbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgIHJldHVybiB7IGRpdjogZGl2LCBtb2Q6IHJlcy5tb2QgfTtcbiAgfSBlbHNlIGlmICh0aGlzLnNpZ24gJiYgbnVtLnNpZ24pIHtcbiAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcbiAgfVxuXG4gIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKVxuICAgIHJldHVybiB7IGRpdjogbmV3IEJOKDApLCBtb2Q6IHRoaXMgfTtcblxuICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChtb2RlID09PSAnZGl2JylcbiAgICAgIHJldHVybiB7IGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksIG1vZDogbnVsbCB9O1xuICAgIGVsc2UgaWYgKG1vZGUgPT09ICdtb2QnKVxuICAgICAgcmV0dXJuIHsgZGl2OiBudWxsLCBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xufTtcblxuLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdihudW0pIHtcbiAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicpLmRpdjtcbn07XG5cbi8vIEZpbmQgYHRoaXNgICUgYG51bWBcbkJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QobnVtKSB7XG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnKS5tb2Q7XG59O1xuXG4vLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQobnVtKSB7XG4gIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgaWYgKGRtLm1vZC5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBkbS5kaXY7XG5cbiAgdmFyIG1vZCA9IGRtLmRpdi5zaWduID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICB2YXIgaGFsZiA9IG51bS5zaHJuKDEpO1xuICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gIC8vIFJvdW5kIGRvd25cbiAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKVxuICAgIHJldHVybiBkbS5kaXY7XG5cbiAgLy8gUm91bmQgdXBcbiAgcmV0dXJuIGRtLmRpdi5zaWduID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xufTtcblxuQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gIHZhciBhY2MgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBhY2MgPSAocCAqIGFjYyArIHRoaXMud29yZHNbaV0pICUgbnVtO1xuXG4gIHJldHVybiBhY2M7XG59O1xuXG4vLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbkJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICBjYXJyeSA9IHcgJSBudW07XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QocCkge1xuICBhc3NlcnQoIXAuc2lnbik7XG4gIGFzc2VydChwLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciB4ID0gdGhpcztcbiAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgaWYgKHguc2lnbilcbiAgICB4ID0geC5tb2QocCk7XG4gIGVsc2VcbiAgICB4ID0geC5jbG9uZSgpO1xuXG4gIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gIHZhciBBID0gbmV3IEJOKDEpO1xuICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAvLyBDICogeCArIEQgKiB5ID0geVxuICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgdmFyIGcgPSAwO1xuXG4gIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICB4LmlzaHJuKDEpO1xuICAgIHkuaXNocm4oMSk7XG4gICAgKytnO1xuICB9XG5cbiAgdmFyIHlwID0geS5jbG9uZSgpO1xuICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgd2hpbGUgKHguY21wbigwKSAhPT0gMCkge1xuICAgIHdoaWxlICh4LmlzRXZlbigpKSB7XG4gICAgICB4LmlzaHJuKDEpO1xuICAgICAgaWYgKEEuaXNFdmVuKCkgJiYgQi5pc0V2ZW4oKSkge1xuICAgICAgICBBLmlzaHJuKDEpO1xuICAgICAgICBCLmlzaHJuKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQS5pYWRkKHlwKS5pc2hybigxKTtcbiAgICAgICAgQi5pc3ViKHhwKS5pc2hybigxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoeS5pc0V2ZW4oKSkge1xuICAgICAgeS5pc2hybigxKTtcbiAgICAgIGlmIChDLmlzRXZlbigpICYmIEQuaXNFdmVuKCkpIHtcbiAgICAgICAgQy5pc2hybigxKTtcbiAgICAgICAgRC5pc2hybigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEMuaWFkZCh5cCkuaXNocm4oMSk7XG4gICAgICAgIEQuaXN1Yih4cCkuaXNocm4oMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgIHguaXN1Yih5KTtcbiAgICAgIEEuaXN1YihDKTtcbiAgICAgIEIuaXN1YihEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeS5pc3ViKHgpO1xuICAgICAgQy5pc3ViKEEpO1xuICAgICAgRC5pc3ViKEIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYTogQyxcbiAgICBiOiBELFxuICAgIGdjZDogeS5pc2hsbihnKVxuICB9O1xufTtcblxuLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4vLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbi8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG5CTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wKHApIHtcbiAgYXNzZXJ0KCFwLnNpZ24pO1xuICBhc3NlcnQocC5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgYSA9IHRoaXM7XG4gIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gIGlmIChhLnNpZ24pXG4gICAgYSA9IGEubW9kKHApO1xuICBlbHNlXG4gICAgYSA9IGEuY2xvbmUoKTtcblxuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICBhLmlzaHJuKDEpO1xuICAgICAgaWYgKHgxLmlzRXZlbigpKVxuICAgICAgICB4MS5pc2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDEuaWFkZChkZWx0YSkuaXNocm4oMSk7XG4gICAgfVxuICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICBiLmlzaHJuKDEpO1xuICAgICAgaWYgKHgyLmlzRXZlbigpKVxuICAgICAgICB4Mi5pc2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDIuaWFkZChkZWx0YSkuaXNocm4oMSk7XG4gICAgfVxuICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICBhLmlzdWIoYik7XG4gICAgICB4MS5pc3ViKHgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYi5pc3ViKGEpO1xuICAgICAgeDIuaXN1Yih4MSk7XG4gICAgfVxuICB9XG4gIGlmIChhLmNtcG4oMSkgPT09IDApXG4gICAgcmV0dXJuIHgxO1xuICBlbHNlXG4gICAgcmV0dXJuIHgyO1xufTtcblxuQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZChudW0pIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gbnVtLmNsb25lKCk7XG4gIGlmIChudW0uY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXG4gIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICBhLnNpZ24gPSBmYWxzZTtcbiAgYi5zaWduID0gZmFsc2U7XG5cbiAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgYS5pc2hybigxKTtcbiAgICBiLmlzaHJuKDEpO1xuICB9XG5cbiAgZG8ge1xuICAgIHdoaWxlIChhLmlzRXZlbigpKVxuICAgICAgYS5pc2hybigxKTtcbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSlcbiAgICAgIGIuaXNocm4oMSk7XG5cbiAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgIGlmIChyIDwgMCkge1xuICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICB2YXIgdCA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0O1xuICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGEuaXN1YihiKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGIuaXNobG4oc2hpZnQpO1xufTtcblxuLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG5CTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0obnVtKSB7XG4gIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLm1vZChudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG59O1xuXG5CTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG59O1xuXG4vLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG5CTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbihudW0pIHtcbiAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG59O1xuXG4vLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG5CTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbihiaXQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGg7IGkgPCBzICsgMTsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgIHRoaXMubGVuZ3RoID0gcyArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICB2YXIgY2FycnkgPSBxO1xuICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgdyArPSBjYXJyeTtcbiAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuKG51bSkge1xuICB2YXIgc2lnbiA9IG51bSA8IDA7XG4gIGlmIChzaWduKVxuICAgIG51bSA9IC1udW07XG5cbiAgaWYgKHRoaXMuc2lnbiAmJiAhc2lnbilcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnNpZ24gJiYgc2lnbilcbiAgICByZXR1cm4gMTtcblxuICBudW0gJj0gMHgzZmZmZmZmO1xuICB0aGlzLnN0cmlwKCk7XG5cbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgIHJlcyA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdO1xuICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICB9XG4gIGlmICh0aGlzLnNpZ24pXG4gICAgcmVzID0gLXJlcztcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbi8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcChudW0pIHtcbiAgaWYgKHRoaXMuc2lnbiAmJiAhbnVtLnNpZ24pXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKVxuICAgIHJldHVybiAxO1xuXG4gIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgaWYgKHRoaXMuc2lnbilcbiAgICByZXR1cm4gLXJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBVbnNpZ25lZCBjb21wYXJpc29uXG5CTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAobnVtKSB7XG4gIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuXG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXTtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1tpXTtcblxuICAgIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGEgPCBiKVxuICAgICAgcmVzID0gLTE7XG4gICAgZWxzZSBpZiAoYSA+IGIpXG4gICAgICByZXMgPSAxO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vL1xuLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbi8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuLy9cbkJOLnJlZCA9IGZ1bmN0aW9uIHJlZChudW0pIHtcbiAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICBhc3NlcnQoIXRoaXMuc2lnbiwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xufTtcblxuQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQoY3R4KSB7XG4gIHRoaXMucmVkID0gY3R4O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YihudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG59O1xuXG4vLyBTcXVhcmUgcm9vdCBvdmVyIHBcbkJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG59O1xuXG4vLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG5CTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyhudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbn07XG5cbi8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG52YXIgcHJpbWVzID0ge1xuICBrMjU2OiBudWxsLFxuICBwMjI0OiBudWxsLFxuICBwMTkyOiBudWxsLFxuICBwMjU1MTk6IG51bGxcbn07XG5cbi8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuZnVuY3Rpb24gTVByaW1lKG5hbWUsIHApIHtcbiAgLy8gUCA9IDIgXiBOIC0gS1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gIHRoaXMuayA9IG5ldyBCTigxKS5pc2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xufVxuXG5NUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wKCkge1xuICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gIHJldHVybiB0bXA7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlKG51bSkge1xuICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgdmFyIHIgPSBudW07XG4gIHZhciBybGVuO1xuXG4gIGRvIHtcbiAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgci53b3Jkc1swXSA9IDA7XG4gICAgci5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICByLmlzdWIodGhpcy5wKTtcbiAgfSBlbHNlIHtcbiAgICByLnN0cmlwKCk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChpbnB1dCwgb3V0KSB7XG4gIGlucHV0LmlzaHJuKHRoaXMubiwgMCwgb3V0KTtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG59O1xuXG5mdW5jdGlvbiBLMjU2KCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdrMjU2JyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbn1cbmluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbksyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dHB1dCkge1xuICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICBmb3IgKHZhciBpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV07XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICBwcmV2ID0gbmV4dDtcbiAgfVxuICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldiA+Pj4gMjI7XG4gIGlucHV0Lmxlbmd0aCAtPSA5O1xufTtcblxuSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgdmFyIGhpO1xuICB2YXIgbG8gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbnVtLndvcmRzW2ldO1xuICAgIGhpID0gdyAqIDB4NDA7XG4gICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgIGhpICs9IChsbyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIGxvICY9IDB4M2ZmZmZmZjtcblxuICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuXG4gICAgbG8gPSBoaTtcbiAgfVxuXG4gIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgIG51bS5sZW5ndGgtLTtcbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMClcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgfVxuICByZXR1cm4gbnVtO1xufTtcblxuZnVuY3Rpb24gUDIyNCgpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAncDIyNCcsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG59XG5pbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG5mdW5jdGlvbiBQMTkyKCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdwMTkyJyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbn1cbmluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbmZ1bmN0aW9uIFAyNTUxOSgpIHtcbiAgLy8gMiBeIDI1NSAtIDE5XG4gIE1QcmltZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgJzI1NTE5JyxcbiAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xufVxuaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG5QMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIC8vIEsgPSAweDEzXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhpID0gbnVtLndvcmRzW2ldICogMHgxMyArIGNhcnJ5O1xuICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgIGhpID4+Pj0gMjY7XG5cbiAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICBjYXJyeSA9IGhpO1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMClcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICByZXR1cm4gbnVtO1xufTtcblxuLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG5CTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZShuYW1lKSB7XG4gIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gIGlmIChwcmltZXNbbmFtZV0pXG4gICAgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICB2YXIgcHJpbWU7XG4gIGlmIChuYW1lID09PSAnazI1NicpXG4gICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpXG4gICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDE5MicpXG4gICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5JylcbiAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbi8vXG4vLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbi8vXG5mdW5jdGlvbiBSZWQobSkge1xuICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wcmltZSA9IG51bGw7XG4gIH1cbn1cblxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxKGEpIHtcbiAgYXNzZXJ0KCFhLnNpZ24sICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIoYSwgYikge1xuICBhc3NlcnQoIWEuc2lnbiAmJiAhYi5zaWduLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kKGEpIHtcbiAgaWYgKHRoaXMucHJpbWUpXG4gICAgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gIHJldHVybiBhLm1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cblJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKGEpIHtcbiAgdmFyIHIgPSBhLmNsb25lKCk7XG4gIHIuc2lnbiA9ICFyLnNpZ247XG4gIHJldHVybiByLmlhZGQodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5zdWIoYik7XG4gIGlmIChyZXMuY21wbigwKSA8IDApXG4gICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobChhLCBudW0pIHtcbiAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLnNobG4obnVtKSk7XG59O1xuXG5SZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xufTtcblxuUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoYSwgYikge1xuICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbn07XG5cblJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoYSkge1xuICByZXR1cm4gdGhpcy5pbXVsKGEsIGEpO1xufTtcblxuUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoYSkge1xuICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG59O1xuXG5SZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0KGEpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gYS5jbG9uZSgpO1xuXG4gIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gIC8vIEZhc3QgY2FzZVxuICBpZiAobW9kMyA9PT0gMykge1xuICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXNocm4oMik7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAvL1xuICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICB2YXIgcyA9IDA7XG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDAgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgIHMrKztcbiAgICBxLmlzaHJuKDEpO1xuICB9XG4gIGFzc2VydChxLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLmlzaHJuKDEpO1xuICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKVxuICAgIHoucmVkSUFkZChuT25lKTtcblxuICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pc2hybigxKSk7XG4gIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gIHZhciBtID0gcztcbiAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICB2YXIgdG1wID0gdDtcbiAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspXG4gICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgYXNzZXJ0KGkgPCBtKTtcbiAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pc2hsbihtIC0gaSAtIDEpKTtcblxuICAgIHIgPSByLnJlZE11bChiKTtcbiAgICBjID0gYi5yZWRTcXIoKTtcbiAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgbSA9IGk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cblJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgaWYgKGludi5zaWduKSB7XG4gICAgaW52LnNpZ24gPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICB9XG59O1xuXG5SZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyhhLCBudW0pIHtcbiAgdmFyIHcgPSBbXTtcblxuICBpZiAobnVtLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigxKTtcblxuICB2YXIgcSA9IG51bS5jbG9uZSgpO1xuXG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDApIHtcbiAgICB3LnB1c2gocS5hbmRsbigxKSk7XG4gICAgcS5pc2hybigxKTtcbiAgfVxuXG4gIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHJlcyA9IGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gdGhpcy5zcXIocmVzKSlcbiAgICBpZiAod1tpXSAhPT0gMClcbiAgICAgIGJyZWFrO1xuXG4gIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgIGZvciAodmFyIHEgPSB0aGlzLnNxcihyZXMpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHRoaXMuc3FyKHEpKSB7XG4gICAgICBpZiAod1tpXSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXMgPSB0aGlzLm11bChyZXMsIHEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyhudW0pIHtcbiAgdmFyIHIgPSBudW0ubW9kKHRoaXMubSk7XG4gIGlmIChyID09PSBudW0pXG4gICAgcmV0dXJuIHIuY2xvbmUoKTtcbiAgZWxzZVxuICAgIHJldHVybiByO1xufTtcblxuUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xuICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gIHJlcy5yZWQgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy9cbi8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuLy9cblxuQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQobnVtKSB7XG4gIHJldHVybiBuZXcgTW9udChudW0pO1xufTtcblxuZnVuY3Rpb24gTW9udChtKSB7XG4gIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApXG4gICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICB0aGlzLnIgPSBuZXcgQk4oMSkuaXNobG4odGhpcy5zaGlmdCk7XG4gIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgdGhpcy5taW52LnNpZ24gPSB0cnVlO1xuICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYubW9kKHRoaXMucik7XG59XG5pbmhlcml0cyhNb250LCBSZWQpO1xuXG5Nb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8obnVtKSB7XG4gIHJldHVybiB0aGlzLmltb2QobnVtLnNobG4odGhpcy5zaGlmdCkpO1xufTtcblxuTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pIHtcbiAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgci5yZWQgPSBudWxsO1xuICByZXR1cm4gcjtcbn07XG5cbk1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApIHtcbiAgICBhLndvcmRzWzBdID0gMDtcbiAgICBhLmxlbmd0aCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgdCA9IGEuaW11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXNocm4odGhpcy5zaGlmdCk7XG4gIHZhciByZXMgPSB1O1xuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgdmFyIHQgPSBhLm11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXNocm4odGhpcy5zaGlmdCk7XG4gIHZhciByZXMgPSB1O1xuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCIndXNlIHN0cmljdCdcbmV4cG9ydHNbJzEuMy4xMzIuMC4xMCddID0gJ3NlY3AyNTZrMSdcblxuZXhwb3J0c1snMS4zLjEzMi4wLjMzJ10gPSAncDIyNCdcblxuZXhwb3J0c1snMS4yLjg0MC4xMDA0NS4zLjEuMSddID0gJ3AxOTInXG5cbmV4cG9ydHNbJzEuMi44NDAuMTAwNDUuMy4xLjcnXSA9ICdwMjU2J1xuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG5leHBvcnRzWydSU0EtU0hBMjI0J10gPSBleHBvcnRzLnNoYTIyNFdpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTIyNCcsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDJkMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDQwNTAwMDQxYycsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVNIQTI1NiddID0gZXhwb3J0cy5zaGEyNTZXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGEyNTYnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjAnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEEzODQnXSA9IGV4cG9ydHMuc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhMzg0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwJywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtU0hBNTEyJ10gPSBleHBvcnRzLnNoYTUxMldpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTUxMicsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDUxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDMwNTAwMDQ0MCcsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVNIQTEnXSA9IHtcblx0c2lnbjogJ3JzYScsXG5cdGhhc2g6ICdzaGExJyxcblx0aWQ6IG5ldyBCdWZmZXIoJzMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNCcsICdoZXgnKVxufVxuZXhwb3J0c1snZWNkc2Etd2l0aC1TSEExJ10gPSB7XG5cdHNpZ246ICdlY2RzYScsXG5cdGhhc2g6ICdzaGExJyxcblx0aWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0cy5EU0EgPSBleHBvcnRzWydEU0EtU0hBMSddID0gZXhwb3J0c1snRFNBLVNIQSddID0ge1xuICBzaWduOiAnZHNhJyxcbiAgaGFzaDogJ3NoYTEnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMjI0J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEyMjQnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEyMjQnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMjU2J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEyNTYnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEyNTYnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMzg0J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEzODQnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEzODQnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBNTEyJ10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEE1MTInXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGE1MTInLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtUklQRU1EMTYwJ10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAncm1kMTYwJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVJJUEVNRDE2MCddID0gZXhwb3J0cy5yaXBlbWQxNjBXaXRoUlNBID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3JtZDE2MCcsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDIxMzAwOTA2MDUyYjI0MDMwMjAxMDUwMDA0MTQnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1NRDUnXSA9IGV4cG9ydHMubWQ1V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnbWQ1JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMCcsICdoZXgnKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMXphV2R1TDJGc1oyOXpMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpZDFjMlVnYzNSeWFXTjBKMXh1Wlhod2IzSjBjMXNuVWxOQkxWTklRVEl5TkNkZElEMGdaWGh3YjNKMGN5NXphR0V5TWpSWGFYUm9VbE5CUlc1amNubHdkR2x2YmlBOUlIdGNiaUFnYzJsbmJqb2dKM0p6WVNjc1hHNGdJR2hoYzJnNklDZHphR0V5TWpRbkxGeHVJQ0JwWkRvZ2JtVjNJRUoxWm1abGNpZ25NekF5WkRNd01HUXdOakE1TmpBNE5qUTRNREUyTlRBek1EUXdNakEwTURVd01EQTBNV01uTENBbmFHVjRKeWxjYm4xY2JtVjRjRzl5ZEhOYkoxSlRRUzFUU0VFeU5UWW5YU0E5SUdWNGNHOXlkSE11YzJoaE1qVTJWMmwwYUZKVFFVVnVZM0o1Y0hScGIyNGdQU0I3WEc0Z0lITnBaMjQ2SUNkeWMyRW5MRnh1SUNCb1lYTm9PaUFuYzJoaE1qVTJKeXhjYmlBZ2FXUTZJRzVsZHlCQ2RXWm1aWElvSnpNd016RXpNREJrTURZd09UWXdPRFkwT0RBeE5qVXdNekEwTURJd01UQTFNREF3TkRJd0p5d2dKMmhsZUNjcFhHNTlYRzVsZUhCdmNuUnpXeWRTVTBFdFUwaEJNemcwSjEwZ1BTQmxlSEJ2Y25SekxuTm9ZVE00TkZkcGRHaFNVMEZGYm1OeWVYQjBhVzl1SUQwZ2UxeHVJQ0J6YVdkdU9pQW5jbk5oSnl4Y2JpQWdhR0Z6YURvZ0ozTm9ZVE00TkNjc1hHNGdJR2xrT2lCdVpYY2dRblZtWm1WeUtDY3pNRFF4TXpBd1pEQTJNRGsyTURnMk5EZ3dNVFkxTURNd05EQXlNREl3TlRBd01EUXpNQ2NzSUNkb1pYZ25LVnh1ZlZ4dVpYaHdiM0owYzFzblVsTkJMVk5JUVRVeE1pZGRJRDBnWlhod2IzSjBjeTV6YUdFMU1USlhhWFJvVWxOQlJXNWpjbmx3ZEdsdmJpQTlJSHRjYmlBZ2MybG5iam9nSjNKellTY3NYRzRnSUdoaGMyZzZJQ2R6YUdFMU1USW5MRnh1SUNCcFpEb2dibVYzSUVKMVptWmxjaWduTXpBMU1UTXdNR1F3TmpBNU5qQTROalE0TURFMk5UQXpNRFF3TWpBek1EVXdNREEwTkRBbkxDQW5hR1Y0SnlsY2JuMWNibVY0Y0c5eWRITmJKMUpUUVMxVFNFRXhKMTBnUFNCN1hHNWNkSE5wWjI0NklDZHljMkVuTEZ4dVhIUm9ZWE5vT2lBbmMyaGhNU2NzWEc1Y2RHbGtPaUJ1WlhjZ1FuVm1abVZ5S0Njek1ESXhNekF3T1RBMk1EVXlZakJsTURNd01qRmhNRFV3TURBME1UUW5MQ0FuYUdWNEp5bGNibjFjYm1WNGNHOXlkSE5iSjJWalpITmhMWGRwZEdndFUwaEJNU2RkSUQwZ2UxeHVYSFJ6YVdkdU9pQW5aV05rYzJFbkxGeHVYSFJvWVhOb09pQW5jMmhoTVNjc1hHNWNkR2xrT2lCdVpYY2dRblZtWm1WeUtDY25MQ0FuYUdWNEp5bGNibjFjYm1WNGNHOXlkSE11UkZOQklEMGdaWGh3YjNKMGMxc25SRk5CTFZOSVFURW5YU0E5SUdWNGNHOXlkSE5iSjBSVFFTMVRTRUVuWFNBOUlIdGNiaUFnYzJsbmJqb2dKMlJ6WVNjc1hHNGdJR2hoYzJnNklDZHphR0V4Snl4Y2JpQWdhV1E2SUc1bGR5QkNkV1ptWlhJb0p5Y3NJQ2RvWlhnbktWeHVmVnh1Wlhod2IzSjBjMXNuUkZOQkxWTklRVEl5TkNkZElEMGdaWGh3YjNKMGMxc25SRk5CTFZkSlZFZ3RVMGhCTWpJMEoxMGdQU0I3WEc0Z0lITnBaMjQ2SUNka2MyRW5MRnh1SUNCb1lYTm9PaUFuYzJoaE1qSTBKeXhjYmlBZ2FXUTZJRzVsZHlCQ2RXWm1aWElvSnljc0lDZG9aWGduS1Z4dWZWeHVaWGh3YjNKMGMxc25SRk5CTFZOSVFUSTFOaWRkSUQwZ1pYaHdiM0owYzFzblJGTkJMVmRKVkVndFUwaEJNalUySjEwZ1BTQjdYRzRnSUhOcFoyNDZJQ2RrYzJFbkxGeHVJQ0JvWVhOb09pQW5jMmhoTWpVMkp5eGNiaUFnYVdRNklHNWxkeUJDZFdabVpYSW9KeWNzSUNkb1pYZ25LVnh1ZlZ4dVpYaHdiM0owYzFzblJGTkJMVk5JUVRNNE5DZGRJRDBnWlhod2IzSjBjMXNuUkZOQkxWZEpWRWd0VTBoQk16ZzBKMTBnUFNCN1hHNGdJSE5wWjI0NklDZGtjMkVuTEZ4dUlDQm9ZWE5vT2lBbmMyaGhNemcwSnl4Y2JpQWdhV1E2SUc1bGR5QkNkV1ptWlhJb0p5Y3NJQ2RvWlhnbktWeHVmVnh1Wlhod2IzSjBjMXNuUkZOQkxWTklRVFV4TWlkZElEMGdaWGh3YjNKMGMxc25SRk5CTFZkSlZFZ3RVMGhCTlRFeUoxMGdQU0I3WEc0Z0lITnBaMjQ2SUNka2MyRW5MRnh1SUNCb1lYTm9PaUFuYzJoaE5URXlKeXhjYmlBZ2FXUTZJRzVsZHlCQ2RXWm1aWElvSnljc0lDZG9aWGduS1Z4dWZWeHVaWGh3YjNKMGMxc25SRk5CTFZKSlVFVk5SREUyTUNkZElEMGdlMXh1SUNCemFXZHVPaUFuWkhOaEp5eGNiaUFnYUdGemFEb2dKM0p0WkRFMk1DY3NYRzRnSUdsa09pQnVaWGNnUW5WbVptVnlLQ2NuTENBbmFHVjRKeWxjYm4xY2JtVjRjRzl5ZEhOYkoxSlRRUzFTU1ZCRlRVUXhOakFuWFNBOUlHVjRjRzl5ZEhNdWNtbHdaVzFrTVRZd1YybDBhRkpUUVNBOUlIdGNiaUFnYzJsbmJqb2dKM0p6WVNjc1hHNGdJR2hoYzJnNklDZHliV1F4TmpBbkxGeHVJQ0JwWkRvZ2JtVjNJRUoxWm1abGNpZ25NekF5TVRNd01Ea3dOakExTW1JeU5EQXpNREl3TVRBMU1EQXdOREUwSnl3Z0oyaGxlQ2NwWEc1OVhHNWxlSEJ2Y25Seld5ZFNVMEV0VFVRMUoxMGdQU0JsZUhCdmNuUnpMbTFrTlZkcGRHaFNVMEZGYm1OeWVYQjBhVzl1SUQwZ2UxeHVJQ0J6YVdkdU9pQW5jbk5oSnl4Y2JpQWdhR0Z6YURvZ0oyMWtOU2NzWEc0Z0lHbGtPaUJ1WlhjZ1FuVm1abVZ5S0Njek1ESXdNekF3WXpBMk1EZ3lZVGcyTkRnNE5tWTNNR1F3TWpBMU1EVXdNREEwTVRBbkxDQW5hR1Y0SnlsY2JuMWNiaUpkZlE9PSIsInZhciBjaXBoZXJzID0gcmVxdWlyZSgnLi9lbmNyeXB0ZXInKVxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyaXZcbnZhciBkZWNpcGhlcnMgPSByZXF1aXJlKCcuL2RlY3J5cHRlcicpXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXZcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtb2Rlcylcbn1cbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vY2lwaGVyQmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnLi9FVlBfQnl0ZXNUb0tleScpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IENpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH0gZWxzZSBpZiAoY2h1bmsudG9TdHJpbmcoJ2hleCcpICE9PSAnMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAnKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBuZXcgQnVmZmVyKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG4gIHZhciBvdXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbiAgcmV0dXJuIG91dFxufVxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH1cbiAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZaVzVqY25sd2RHVnlMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKMllYSWdZV1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOWhaWE1uS1Z4dWRtRnlJRlJ5WVc1elptOXliU0E5SUhKbGNYVnBjbVVvSnk0dlkybHdhR1Z5UW1GelpTY3BYRzUyWVhJZ2FXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BYRzUyWVhJZ2JXOWtaWE1nUFNCeVpYRjFhWEpsS0NjdUwyMXZaR1Z6SnlsY2JuWmhjaUJsWW5ScklEMGdjbVZ4ZFdseVpTZ25MaTlGVmxCZlFubDBaWE5VYjB0bGVTY3BYRzUyWVhJZ1UzUnlaV0Z0UTJsd2FHVnlJRDBnY21WeGRXbHlaU2duTGk5emRISmxZVzFEYVhCb1pYSW5LVnh1ZG1GeUlFRjFkR2hEYVhCb1pYSWdQU0J5WlhGMWFYSmxLQ2N1TDJGMWRHaERhWEJvWlhJbktWeHVhVzVvWlhKcGRITW9RMmx3YUdWeUxDQlVjbUZ1YzJadmNtMHBYRzVtZFc1amRHbHZiaUJEYVhCb1pYSWdLRzF2WkdVc0lHdGxlU3dnYVhZcElIdGNiaUFnYVdZZ0tDRW9kR2hwY3lCcGJuTjBZVzVqWlc5bUlFTnBjR2hsY2lrcElIdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lFTnBjR2hsY2lodGIyUmxMQ0JyWlhrc0lHbDJLVnh1SUNCOVhHNGdJRlJ5WVc1elptOXliUzVqWVd4c0tIUm9hWE1wWEc0Z0lIUm9hWE11WDJOaFkyaGxJRDBnYm1WM0lGTndiR2wwZEdWeUtDbGNiaUFnZEdocGN5NWZZMmx3YUdWeUlEMGdibVYzSUdGbGN5NUJSVk1vYTJWNUtWeHVJQ0IwYUdsekxsOXdjbVYySUQwZ2JtVjNJRUoxWm1abGNpaHBkaTVzWlc1bmRHZ3BYRzRnSUdsMkxtTnZjSGtvZEdocGN5NWZjSEpsZGlsY2JpQWdkR2hwY3k1ZmJXOWtaU0E5SUcxdlpHVmNiaUFnZEdocGN5NWZZWFYwYjNCaFpHUnBibWNnUFNCMGNuVmxYRzU5WEc1RGFYQm9aWEl1Y0hKdmRHOTBlWEJsTGw5MWNHUmhkR1VnUFNCbWRXNWpkR2x2YmlBb1pHRjBZU2tnZTF4dUlDQjBhR2x6TGw5allXTm9aUzVoWkdRb1pHRjBZU2xjYmlBZ2RtRnlJR05vZFc1clhHNGdJSFpoY2lCMGFHbHVaMXh1SUNCMllYSWdiM1YwSUQwZ1cxMWNiaUFnZDJocGJHVWdLQ2hqYUhWdWF5QTlJSFJvYVhNdVgyTmhZMmhsTG1kbGRDZ3BLU2tnZTF4dUlDQWdJSFJvYVc1bklEMGdkR2hwY3k1ZmJXOWtaUzVsYm1OeWVYQjBLSFJvYVhNc0lHTm9kVzVyS1Z4dUlDQWdJRzkxZEM1d2RYTm9LSFJvYVc1bktWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCQ2RXWm1aWEl1WTI5dVkyRjBLRzkxZENsY2JuMWNia05wY0dobGNpNXdjbTkwYjNSNWNHVXVYMlpwYm1Gc0lEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnWTJoMWJtc2dQU0IwYUdsekxsOWpZV05vWlM1bWJIVnphQ2dwWEc0Z0lHbG1JQ2gwYUdsekxsOWhkWFJ2Y0dGa1pHbHVaeWtnZTF4dUlDQWdJR05vZFc1cklEMGdkR2hwY3k1ZmJXOWtaUzVsYm1OeWVYQjBLSFJvYVhNc0lHTm9kVzVyS1Z4dUlDQWdJSFJvYVhNdVgyTnBjR2hsY2k1elkzSjFZaWdwWEc0Z0lDQWdjbVYwZFhKdUlHTm9kVzVyWEc0Z0lIMGdaV3h6WlNCcFppQW9ZMmgxYm1zdWRHOVRkSEpwYm1jb0oyaGxlQ2NwSUNFOVBTQW5NVEF4TURFd01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TVRBbktTQjdYRzRnSUNBZ2RHaHBjeTVmWTJsd2FHVnlMbk5qY25WaUtDbGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJSaGRHRWdibTkwSUcxMWJIUnBjR3hsSUc5bUlHSnNiMk5ySUd4bGJtZDBhQ2NwWEc0Z0lIMWNibjFjYmtOcGNHaGxjaTV3Y205MGIzUjVjR1V1YzJWMFFYVjBiMUJoWkdScGJtY2dQU0JtZFc1amRHbHZiaUFvYzJWMFZHOHBJSHRjYmlBZ2RHaHBjeTVmWVhWMGIzQmhaR1JwYm1jZ1BTQWhJWE5sZEZSdlhHNTlYRzVjYm1aMWJtTjBhVzl1SUZOd2JHbDBkR1Z5SUNncElIdGNiaUFnYVdZZ0tDRW9kR2hwY3lCcGJuTjBZVzVqWlc5bUlGTndiR2wwZEdWeUtTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCdVpYY2dVM0JzYVhSMFpYSW9LVnh1SUNCOVhHNGdJSFJvYVhNdVkyRmphR1VnUFNCdVpYY2dRblZtWm1WeUtDY25LVnh1ZlZ4dVUzQnNhWFIwWlhJdWNISnZkRzkwZVhCbExtRmtaQ0E5SUdaMWJtTjBhVzl1SUNoa1lYUmhLU0I3WEc0Z0lIUm9hWE11WTJGamFHVWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdDBhR2x6TG1OaFkyaGxMQ0JrWVhSaFhTbGNibjFjYmx4dVUzQnNhWFIwWlhJdWNISnZkRzkwZVhCbExtZGxkQ0E5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnYVdZZ0tIUm9hWE11WTJGamFHVXViR1Z1WjNSb0lENGdNVFVwSUh0Y2JpQWdJQ0IyWVhJZ2IzVjBJRDBnZEdocGN5NWpZV05vWlM1emJHbGpaU2d3TENBeE5pbGNiaUFnSUNCMGFHbHpMbU5oWTJobElEMGdkR2hwY3k1allXTm9aUzV6YkdsalpTZ3hOaWxjYmlBZ0lDQnlaWFIxY200Z2IzVjBYRzRnSUgxY2JpQWdjbVYwZFhKdUlHNTFiR3hjYm4xY2JsTndiR2wwZEdWeUxuQnliM1J2ZEhsd1pTNW1iSFZ6YUNBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RtRnlJR3hsYmlBOUlERTJJQzBnZEdocGN5NWpZV05vWlM1c1pXNW5kR2hjYmlBZ2RtRnlJSEJoWkVKMVptWWdQU0J1WlhjZ1FuVm1abVZ5S0d4bGJpbGNibHh1SUNCMllYSWdhU0E5SUMweFhHNGdJSGRvYVd4bElDZ3JLMmtnUENCc1pXNHBJSHRjYmlBZ0lDQndZV1JDZFdabUxuZHlhWFJsVlVsdWREZ29iR1Z1TENCcEtWeHVJQ0I5WEc0Z0lIWmhjaUJ2ZFhRZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0MGFHbHpMbU5oWTJobExDQndZV1JDZFdabVhTbGNiaUFnY21WMGRYSnVJRzkxZEZ4dWZWeHVkbUZ5SUcxdlpHVnNhWE4wSUQwZ2UxeHVJQ0JGUTBJNklISmxjWFZwY21Vb0p5NHZiVzlrWlhNdlpXTmlKeWtzWEc0Z0lFTkNRem9nY21WeGRXbHlaU2duTGk5dGIyUmxjeTlqWW1NbktTeGNiaUFnUTBaQ09pQnlaWEYxYVhKbEtDY3VMMjF2WkdWekwyTm1ZaWNwTEZ4dUlDQkRSa0k0T2lCeVpYRjFhWEpsS0NjdUwyMXZaR1Z6TDJObVlqZ25LU3hjYmlBZ1EwWkNNVG9nY21WeGRXbHlaU2duTGk5dGIyUmxjeTlqWm1JeEp5a3NYRzRnSUU5R1Fqb2djbVZ4ZFdseVpTZ25MaTl0YjJSbGN5OXZabUluS1N4Y2JpQWdRMVJTT2lCeVpYRjFhWEpsS0NjdUwyMXZaR1Z6TDJOMGNpY3BMRnh1SUNCSFEwMDZJSEpsY1hWcGNtVW9KeTR2Ylc5a1pYTXZZM1J5SnlsY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTNKbFlYUmxRMmx3YUdWeWFYWWdLSE4xYVhSbExDQndZWE56ZDI5eVpDd2dhWFlwSUh0Y2JpQWdkbUZ5SUdOdmJtWnBaeUE5SUcxdlpHVnpXM04xYVhSbExuUnZURzkzWlhKRFlYTmxLQ2xkWEc0Z0lHbG1JQ2doWTI5dVptbG5LU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduYVc1MllXeHBaQ0J6ZFdsMFpTQjBlWEJsSnlsY2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlHbDJJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUdsMklEMGdibVYzSUVKMVptWmxjaWhwZGlsY2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlIQmhjM04zYjNKa0lEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJSEJoYzNOM2IzSmtJRDBnYm1WM0lFSjFabVpsY2lod1lYTnpkMjl5WkNsY2JpQWdmVnh1SUNCcFppQW9jR0Z6YzNkdmNtUXViR1Z1WjNSb0lDRTlQU0JqYjI1bWFXY3VhMlY1SUM4Z09Da2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMmx1ZG1Gc2FXUWdhMlY1SUd4bGJtZDBhQ0FuSUNzZ2NHRnpjM2R2Y21RdWJHVnVaM1JvS1Z4dUlDQjlYRzRnSUdsbUlDaHBkaTVzWlc1bmRHZ2dJVDA5SUdOdmJtWnBaeTVwZGlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oybHVkbUZzYVdRZ2FYWWdiR1Z1WjNSb0lDY2dLeUJwZGk1c1pXNW5kR2dwWEc0Z0lIMWNiaUFnYVdZZ0tHTnZibVpwWnk1MGVYQmxJRDA5UFNBbmMzUnlaV0Z0SnlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1UzUnlaV0Z0UTJsd2FHVnlLRzF2WkdWc2FYTjBXMk52Ym1acFp5NXRiMlJsWFN3Z2NHRnpjM2R2Y21Rc0lHbDJLVnh1SUNCOUlHVnNjMlVnYVdZZ0tHTnZibVpwWnk1MGVYQmxJRDA5UFNBbllYVjBhQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUVGMWRHaERhWEJvWlhJb2JXOWtaV3hwYzNSYlkyOXVabWxuTG0xdlpHVmRMQ0J3WVhOemQyOXlaQ3dnYVhZcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUc1bGR5QkRhWEJvWlhJb2JXOWtaV3hwYzNSYlkyOXVabWxuTG0xdlpHVmRMQ0J3WVhOemQyOXlaQ3dnYVhZcFhHNTlYRzVtZFc1amRHbHZiaUJqY21WaGRHVkRhWEJvWlhJZ0tITjFhWFJsTENCd1lYTnpkMjl5WkNrZ2UxeHVJQ0IyWVhJZ1kyOXVabWxuSUQwZ2JXOWtaWE5iYzNWcGRHVXVkRzlNYjNkbGNrTmhjMlVvS1YxY2JpQWdhV1lnS0NGamIyNW1hV2NwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkcGJuWmhiR2xrSUhOMWFYUmxJSFI1Y0dVbktWeHVJQ0I5WEc0Z0lIWmhjaUJyWlhseklEMGdaV0owYXlod1lYTnpkMjl5WkN3Z1kyOXVabWxuTG10bGVTd2dZMjl1Wm1sbkxtbDJLVnh1SUNCeVpYUjFjbTRnWTNKbFlYUmxRMmx3YUdWeWFYWW9jM1ZwZEdVc0lHdGxlWE11YTJWNUxDQnJaWGx6TG1sMktWeHVmVnh1WEc1bGVIQnZjblJ6TG1OeVpXRjBaVU5wY0dobGNtbDJJRDBnWTNKbFlYUmxRMmx3YUdWeWFYWmNibVY0Y0c5eWRITXVZM0psWVhSbFEybHdhR1Z5SUQwZ1kzSmxZWFJsUTJsd2FHVnlYRzRpWFgwPSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9jaXBoZXJCYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBlYnRrID0gcmVxdWlyZSgnLi9FVlBfQnl0ZXNUb0tleScpXG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbn1cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVxuICB9XG59XG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMWhaWE12WkdWamNubHdkR1Z5TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUoyWVhJZ1lXVnpJRDBnY21WeGRXbHlaU2duTGk5aFpYTW5LVnh1ZG1GeUlGUnlZVzV6Wm05eWJTQTlJSEpsY1hWcGNtVW9KeTR2WTJsd2FHVnlRbUZ6WlNjcFhHNTJZWElnYVc1b1pYSnBkSE1nUFNCeVpYRjFhWEpsS0NkcGJtaGxjbWwwY3ljcFhHNTJZWElnYlc5a1pYTWdQU0J5WlhGMWFYSmxLQ2N1TDIxdlpHVnpKeWxjYm5aaGNpQlRkSEpsWVcxRGFYQm9aWElnUFNCeVpYRjFhWEpsS0NjdUwzTjBjbVZoYlVOcGNHaGxjaWNwWEc1MllYSWdRWFYwYUVOcGNHaGxjaUE5SUhKbGNYVnBjbVVvSnk0dllYVjBhRU5wY0dobGNpY3BYRzUyWVhJZ1pXSjBheUE5SUhKbGNYVnBjbVVvSnk0dlJWWlFYMEo1ZEdWelZHOUxaWGtuS1Z4dVhHNXBibWhsY21sMGN5aEVaV05wY0dobGNpd2dWSEpoYm5ObWIzSnRLVnh1Wm5WdVkzUnBiMjRnUkdWamFYQm9aWElnS0cxdlpHVXNJR3RsZVN3Z2FYWXBJSHRjYmlBZ2FXWWdLQ0VvZEdocGN5QnBibk4wWVc1alpXOW1JRVJsWTJsd2FHVnlLU2tnZTF4dUlDQWdJSEpsZEhWeWJpQnVaWGNnUkdWamFYQm9aWElvYlc5a1pTd2dhMlY1TENCcGRpbGNiaUFnZlZ4dUlDQlVjbUZ1YzJadmNtMHVZMkZzYkNoMGFHbHpLVnh1SUNCMGFHbHpMbDlqWVdOb1pTQTlJRzVsZHlCVGNHeHBkSFJsY2lncFhHNGdJSFJvYVhNdVgyeGhjM1FnUFNCMmIybGtJREJjYmlBZ2RHaHBjeTVmWTJsd2FHVnlJRDBnYm1WM0lHRmxjeTVCUlZNb2EyVjVLVnh1SUNCMGFHbHpMbDl3Y21WMklEMGdibVYzSUVKMVptWmxjaWhwZGk1c1pXNW5kR2dwWEc0Z0lHbDJMbU52Y0hrb2RHaHBjeTVmY0hKbGRpbGNiaUFnZEdocGN5NWZiVzlrWlNBOUlHMXZaR1ZjYmlBZ2RHaHBjeTVmWVhWMGIzQmhaR1JwYm1jZ1BTQjBjblZsWEc1OVhHNUVaV05wY0dobGNpNXdjbTkwYjNSNWNHVXVYM1Z3WkdGMFpTQTlJR1oxYm1OMGFXOXVJQ2hrWVhSaEtTQjdYRzRnSUhSb2FYTXVYMk5oWTJobExtRmtaQ2hrWVhSaEtWeHVJQ0IyWVhJZ1kyaDFibXRjYmlBZ2RtRnlJSFJvYVc1blhHNGdJSFpoY2lCdmRYUWdQU0JiWFZ4dUlDQjNhR2xzWlNBb0tHTm9kVzVySUQwZ2RHaHBjeTVmWTJGamFHVXVaMlYwS0hSb2FYTXVYMkYxZEc5d1lXUmthVzVuS1NrcElIdGNiaUFnSUNCMGFHbHVaeUE5SUhSb2FYTXVYMjF2WkdVdVpHVmpjbmx3ZENoMGFHbHpMQ0JqYUhWdWF5bGNiaUFnSUNCdmRYUXVjSFZ6YUNoMGFHbHVaeWxjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdRblZtWm1WeUxtTnZibU5oZENodmRYUXBYRzU5WEc1RVpXTnBjR2hsY2k1d2NtOTBiM1I1Y0dVdVgyWnBibUZzSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCMllYSWdZMmgxYm1zZ1BTQjBhR2x6TGw5allXTm9aUzVtYkhWemFDZ3BYRzRnSUdsbUlDaDBhR2x6TGw5aGRYUnZjR0ZrWkdsdVp5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCMWJuQmhaQ2gwYUdsekxsOXRiMlJsTG1SbFkzSjVjSFFvZEdocGN5d2dZMmgxYm1zcEtWeHVJQ0I5SUdWc2MyVWdhV1lnS0dOb2RXNXJLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZGtZWFJoSUc1dmRDQnRkV3gwYVhCc1pTQnZaaUJpYkc5amF5QnNaVzVuZEdnbktWeHVJQ0I5WEc1OVhHNUVaV05wY0dobGNpNXdjbTkwYjNSNWNHVXVjMlYwUVhWMGIxQmhaR1JwYm1jZ1BTQm1kVzVqZEdsdmJpQW9jMlYwVkc4cElIdGNiaUFnZEdocGN5NWZZWFYwYjNCaFpHUnBibWNnUFNBaElYTmxkRlJ2WEc1OVhHNW1kVzVqZEdsdmJpQlRjR3hwZEhSbGNpQW9LU0I3WEc0Z0lHbG1JQ2doS0hSb2FYTWdhVzV6ZEdGdVkyVnZaaUJUY0d4cGRIUmxjaWtwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUZOd2JHbDBkR1Z5S0NsY2JpQWdmVnh1SUNCMGFHbHpMbU5oWTJobElEMGdibVYzSUVKMVptWmxjaWduSnlsY2JuMWNibE53YkdsMGRHVnlMbkJ5YjNSdmRIbHdaUzVoWkdRZ1BTQm1kVzVqZEdsdmJpQW9aR0YwWVNrZ2UxeHVJQ0IwYUdsekxtTmhZMmhsSUQwZ1FuVm1abVZ5TG1OdmJtTmhkQ2hiZEdocGN5NWpZV05vWlN3Z1pHRjBZVjBwWEc1OVhHNWNibE53YkdsMGRHVnlMbkJ5YjNSdmRIbHdaUzVuWlhRZ1BTQm1kVzVqZEdsdmJpQW9ZWFYwYjFCaFpHUnBibWNwSUh0Y2JpQWdkbUZ5SUc5MWRGeHVJQ0JwWmlBb1lYVjBiMUJoWkdScGJtY3BJSHRjYmlBZ0lDQnBaaUFvZEdocGN5NWpZV05vWlM1c1pXNW5kR2dnUGlBeE5pa2dlMXh1SUNBZ0lDQWdiM1YwSUQwZ2RHaHBjeTVqWVdOb1pTNXpiR2xqWlNnd0xDQXhOaWxjYmlBZ0lDQWdJSFJvYVhNdVkyRmphR1VnUFNCMGFHbHpMbU5oWTJobExuTnNhV05sS0RFMktWeHVJQ0FnSUNBZ2NtVjBkWEp1SUc5MWRGeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCcFppQW9kR2hwY3k1allXTm9aUzVzWlc1bmRHZ2dQajBnTVRZcElIdGNiaUFnSUNBZ0lHOTFkQ0E5SUhSb2FYTXVZMkZqYUdVdWMyeHBZMlVvTUN3Z01UWXBYRzRnSUNBZ0lDQjBhR2x6TG1OaFkyaGxJRDBnZEdocGN5NWpZV05vWlM1emJHbGpaU2d4TmlsY2JpQWdJQ0FnSUhKbGRIVnliaUJ2ZFhSY2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJRzUxYkd4Y2JuMWNibE53YkdsMGRHVnlMbkJ5YjNSdmRIbHdaUzVtYkhWemFDQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdhV1lnS0hSb2FYTXVZMkZqYUdVdWJHVnVaM1JvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVkyRmphR1ZjYmlBZ2ZWeHVmVnh1Wm5WdVkzUnBiMjRnZFc1d1lXUWdLR3hoYzNRcElIdGNiaUFnZG1GeUlIQmhaR1JsWkNBOUlHeGhjM1JiTVRWZFhHNGdJSFpoY2lCcElEMGdMVEZjYmlBZ2QyaHBiR1VnS0NzcmFTQThJSEJoWkdSbFpDa2dlMXh1SUNBZ0lHbG1JQ2hzWVhOMFd5aHBJQ3NnS0RFMklDMGdjR0ZrWkdWa0tTbGRJQ0U5UFNCd1lXUmtaV1FwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduZFc1aFlteGxJSFJ2SUdSbFkzSjVjSFFnWkdGMFlTY3BYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lHbG1JQ2h3WVdSa1pXUWdQVDA5SURFMktTQjdYRzRnSUNBZ2NtVjBkWEp1WEc0Z0lIMWNiaUFnY21WMGRYSnVJR3hoYzNRdWMyeHBZMlVvTUN3Z01UWWdMU0J3WVdSa1pXUXBYRzU5WEc1Y2JuWmhjaUJ0YjJSbGJHbHpkQ0E5SUh0Y2JpQWdSVU5DT2lCeVpYRjFhWEpsS0NjdUwyMXZaR1Z6TDJWallpY3BMRnh1SUNCRFFrTTZJSEpsY1hWcGNtVW9KeTR2Ylc5a1pYTXZZMkpqSnlrc1hHNGdJRU5HUWpvZ2NtVnhkV2x5WlNnbkxpOXRiMlJsY3k5alptSW5LU3hjYmlBZ1EwWkNPRG9nY21WeGRXbHlaU2duTGk5dGIyUmxjeTlqWm1JNEp5a3NYRzRnSUVOR1FqRTZJSEpsY1hWcGNtVW9KeTR2Ylc5a1pYTXZZMlppTVNjcExGeHVJQ0JQUmtJNklISmxjWFZwY21Vb0p5NHZiVzlrWlhNdmIyWmlKeWtzWEc0Z0lFTlVVam9nY21WeGRXbHlaU2duTGk5dGIyUmxjeTlqZEhJbktTeGNiaUFnUjBOTk9pQnlaWEYxYVhKbEtDY3VMMjF2WkdWekwyTjBjaWNwWEc1OVhHNWNibVoxYm1OMGFXOXVJR055WldGMFpVUmxZMmx3YUdWeWFYWWdLSE4xYVhSbExDQndZWE56ZDI5eVpDd2dhWFlwSUh0Y2JpQWdkbUZ5SUdOdmJtWnBaeUE5SUcxdlpHVnpXM04xYVhSbExuUnZURzkzWlhKRFlYTmxLQ2xkWEc0Z0lHbG1JQ2doWTI5dVptbG5LU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWduYVc1MllXeHBaQ0J6ZFdsMFpTQjBlWEJsSnlsY2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlHbDJJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUdsMklEMGdibVYzSUVKMVptWmxjaWhwZGlsY2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlIQmhjM04zYjNKa0lEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJSEJoYzNOM2IzSmtJRDBnYm1WM0lFSjFabVpsY2lod1lYTnpkMjl5WkNsY2JpQWdmVnh1SUNCcFppQW9jR0Z6YzNkdmNtUXViR1Z1WjNSb0lDRTlQU0JqYjI1bWFXY3VhMlY1SUM4Z09Da2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMmx1ZG1Gc2FXUWdhMlY1SUd4bGJtZDBhQ0FuSUNzZ2NHRnpjM2R2Y21RdWJHVnVaM1JvS1Z4dUlDQjlYRzRnSUdsbUlDaHBkaTVzWlc1bmRHZ2dJVDA5SUdOdmJtWnBaeTVwZGlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oybHVkbUZzYVdRZ2FYWWdiR1Z1WjNSb0lDY2dLeUJwZGk1c1pXNW5kR2dwWEc0Z0lIMWNiaUFnYVdZZ0tHTnZibVpwWnk1MGVYQmxJRDA5UFNBbmMzUnlaV0Z0SnlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1UzUnlaV0Z0UTJsd2FHVnlLRzF2WkdWc2FYTjBXMk52Ym1acFp5NXRiMlJsWFN3Z2NHRnpjM2R2Y21Rc0lHbDJMQ0IwY25WbEtWeHVJQ0I5SUdWc2MyVWdhV1lnS0dOdmJtWnBaeTUwZVhCbElEMDlQU0FuWVhWMGFDY3BJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjNJRUYxZEdoRGFYQm9aWElvYlc5a1pXeHBjM1JiWTI5dVptbG5MbTF2WkdWZExDQndZWE56ZDI5eVpDd2dhWFlzSUhSeWRXVXBYRzRnSUgxY2JpQWdjbVYwZFhKdUlHNWxkeUJFWldOcGNHaGxjaWh0YjJSbGJHbHpkRnRqYjI1bWFXY3ViVzlrWlYwc0lIQmhjM04zYjNKa0xDQnBkaWxjYm4xY2JseHVablZ1WTNScGIyNGdZM0psWVhSbFJHVmphWEJvWlhJZ0tITjFhWFJsTENCd1lYTnpkMjl5WkNrZ2UxeHVJQ0IyWVhJZ1kyOXVabWxuSUQwZ2JXOWtaWE5iYzNWcGRHVXVkRzlNYjNkbGNrTmhjMlVvS1YxY2JpQWdhV1lnS0NGamIyNW1hV2NwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkcGJuWmhiR2xrSUhOMWFYUmxJSFI1Y0dVbktWeHVJQ0I5WEc0Z0lIWmhjaUJyWlhseklEMGdaV0owYXlod1lYTnpkMjl5WkN3Z1kyOXVabWxuTG10bGVTd2dZMjl1Wm1sbkxtbDJLVnh1SUNCeVpYUjFjbTRnWTNKbFlYUmxSR1ZqYVhCb1pYSnBkaWh6ZFdsMFpTd2dhMlY1Y3k1clpYa3NJR3RsZVhNdWFYWXBYRzU5WEc1bGVIQnZjblJ6TG1OeVpXRjBaVVJsWTJsd2FHVnlJRDBnWTNKbFlYUmxSR1ZqYVhCb1pYSmNibVY0Y0c5eWRITXVZM0psWVhSbFJHVmphWEJvWlhKcGRpQTlJR055WldGMFpVUmxZMmx3YUdWeWFYWmNiaUpkZlE9PSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9jaXBoZXJCYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZjM1J5WldGdFEybHdhR1Z5TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKMllYSWdZV1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOWhaWE1uS1Z4dWRtRnlJRlJ5WVc1elptOXliU0E5SUhKbGNYVnBjbVVvSnk0dlkybHdhR1Z5UW1GelpTY3BYRzUyWVhJZ2FXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BYRzVjYm1sdWFHVnlhWFJ6S0ZOMGNtVmhiVU5wY0dobGNpd2dWSEpoYm5ObWIzSnRLVnh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JUZEhKbFlXMURhWEJvWlhKY2JtWjFibU4wYVc5dUlGTjBjbVZoYlVOcGNHaGxjaUFvYlc5a1pTd2dhMlY1TENCcGRpd2daR1ZqY25sd2RDa2dlMXh1SUNCcFppQW9JU2gwYUdseklHbHVjM1JoYm1ObGIyWWdVM1J5WldGdFEybHdhR1Z5S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1UzUnlaV0Z0UTJsd2FHVnlLRzF2WkdVc0lHdGxlU3dnYVhZcFhHNGdJSDFjYmlBZ1ZISmhibk5tYjNKdExtTmhiR3dvZEdocGN5bGNiaUFnZEdocGN5NWZZMmx3YUdWeUlEMGdibVYzSUdGbGN5NUJSVk1vYTJWNUtWeHVJQ0IwYUdsekxsOXdjbVYySUQwZ2JtVjNJRUoxWm1abGNpaHBkaTVzWlc1bmRHZ3BYRzRnSUhSb2FYTXVYMk5oWTJobElEMGdibVYzSUVKMVptWmxjaWduSnlsY2JpQWdkR2hwY3k1ZmMyVmpRMkZqYUdVZ1BTQnVaWGNnUW5WbVptVnlLQ2NuS1Z4dUlDQjBhR2x6TGw5a1pXTnllWEIwSUQwZ1pHVmpjbmx3ZEZ4dUlDQnBkaTVqYjNCNUtIUm9hWE11WDNCeVpYWXBYRzRnSUhSb2FYTXVYMjF2WkdVZ1BTQnRiMlJsWEc1OVhHNVRkSEpsWVcxRGFYQm9aWEl1Y0hKdmRHOTBlWEJsTGw5MWNHUmhkR1VnUFNCbWRXNWpkR2x2YmlBb1kyaDFibXNwSUh0Y2JpQWdjbVYwZFhKdUlIUm9hWE11WDIxdlpHVXVaVzVqY25sd2RDaDBhR2x6TENCamFIVnVheXdnZEdocGN5NWZaR1ZqY25sd2RDbGNibjFjYmxOMGNtVmhiVU5wY0dobGNpNXdjbTkwYjNSNWNHVXVYMlpwYm1Gc0lEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjBhR2x6TGw5amFYQm9aWEl1YzJOeWRXSW9LVnh1ZlZ4dUlsMTkiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzFoWlhNdmJXOWtaWE12YjJaaUxtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SjJZWElnZUc5eUlEMGdjbVZ4ZFdseVpTZ25ZblZtWm1WeUxYaHZjaWNwWEc1Y2JtWjFibU4wYVc5dUlHZGxkRUpzYjJOcklDaHpaV3htS1NCN1hHNGdJSE5sYkdZdVgzQnlaWFlnUFNCelpXeG1MbDlqYVhCb1pYSXVaVzVqY25sd2RFSnNiMk5yS0hObGJHWXVYM0J5WlhZcFhHNGdJSEpsZEhWeWJpQnpaV3htTGw5d2NtVjJYRzU5WEc1Y2JtVjRjRzl5ZEhNdVpXNWpjbmx3ZENBOUlHWjFibU4wYVc5dUlDaHpaV3htTENCamFIVnVheWtnZTF4dUlDQjNhR2xzWlNBb2MyVnNaaTVmWTJGamFHVXViR1Z1WjNSb0lEd2dZMmgxYm1zdWJHVnVaM1JvS1NCN1hHNGdJQ0FnYzJWc1ppNWZZMkZqYUdVZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0elpXeG1MbDlqWVdOb1pTd2daMlYwUW14dlkyc29jMlZzWmlsZEtWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhCaFpDQTlJSE5sYkdZdVgyTmhZMmhsTG5Oc2FXTmxLREFzSUdOb2RXNXJMbXhsYm1kMGFDbGNiaUFnYzJWc1ppNWZZMkZqYUdVZ1BTQnpaV3htTGw5allXTm9aUzV6YkdsalpTaGphSFZ1YXk1c1pXNW5kR2dwWEc0Z0lISmxkSFZ5YmlCNGIzSW9ZMmgxYm1zc0lIQmhaQ2xjYm4xY2JpSmRmUT09IiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBpbmNyMzIgKGl2KSB7XG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaXRlbSA9IGl2LnJlYWRVSW50OChsZW4pXG4gICAgaWYgKGl0ZW0gPT09IDI1NSkge1xuICAgICAgaXYud3JpdGVVSW50OCgwLCBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0rK1xuICAgICAgaXYud3JpdGVVSW50OChpdGVtLCBsZW4pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICBpbmNyMzIoc2VsZi5fcHJldilcbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMWhaWE12Ylc5a1pYTXZZM1J5TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SjJZWElnZUc5eUlEMGdjbVZ4ZFdseVpTZ25ZblZtWm1WeUxYaHZjaWNwWEc1Y2JtWjFibU4wYVc5dUlHbHVZM0l6TWlBb2FYWXBJSHRjYmlBZ2RtRnlJR3hsYmlBOUlHbDJMbXhsYm1kMGFGeHVJQ0IyWVhJZ2FYUmxiVnh1SUNCM2FHbHNaU0FvYkdWdUxTMHBJSHRjYmlBZ0lDQnBkR1Z0SUQwZ2FYWXVjbVZoWkZWSmJuUTRLR3hsYmlsY2JpQWdJQ0JwWmlBb2FYUmxiU0E5UFQwZ01qVTFLU0I3WEc0Z0lDQWdJQ0JwZGk1M2NtbDBaVlZKYm5RNEtEQXNJR3hsYmlsY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdhWFJsYlNzclhHNGdJQ0FnSUNCcGRpNTNjbWwwWlZWSmJuUTRLR2wwWlcwc0lHeGxiaWxjYmlBZ0lDQWdJR0p5WldGclhHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlHZGxkRUpzYjJOcklDaHpaV3htS1NCN1hHNGdJSFpoY2lCdmRYUWdQU0J6Wld4bUxsOWphWEJvWlhJdVpXNWpjbmx3ZEVKc2IyTnJLSE5sYkdZdVgzQnlaWFlwWEc0Z0lHbHVZM0l6TWloelpXeG1MbDl3Y21WMktWeHVJQ0J5WlhSMWNtNGdiM1YwWEc1OVhHNWNibVY0Y0c5eWRITXVaVzVqY25sd2RDQTlJR1oxYm1OMGFXOXVJQ2h6Wld4bUxDQmphSFZ1YXlrZ2UxeHVJQ0IzYUdsc1pTQW9jMlZzWmk1ZlkyRmphR1V1YkdWdVozUm9JRHdnWTJoMWJtc3ViR1Z1WjNSb0tTQjdYRzRnSUNBZ2MyVnNaaTVmWTJGamFHVWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdHpaV3htTGw5allXTm9aU3dnWjJWMFFteHZZMnNvYzJWc1ppbGRLVnh1SUNCOVhHNGdJSFpoY2lCd1lXUWdQU0J6Wld4bUxsOWpZV05vWlM1emJHbGpaU2d3TENCamFIVnVheTVzWlc1bmRHZ3BYRzRnSUhObGJHWXVYMk5oWTJobElEMGdjMlZzWmk1ZlkyRmphR1V1YzJ4cFkyVW9ZMmgxYm1zdWJHVnVaM1JvS1Z4dUlDQnlaWFIxY200Z2VHOXlLR05vZFc1ckxDQndZV1FwWEc1OVhHNGlYWDA9IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICB2YXIgb3V0ID0gcGFkWzBdIF4gYnl0ZVBhcmFtXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LnNsaWNlKDEpLCBuZXcgQnVmZmVyKFtkZWNyeXB0ID8gYnl0ZVBhcmFtIDogb3V0XSldKVxuICByZXR1cm4gb3V0XG59XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzFoWlhNdmJXOWtaWE12WTJaaU9DNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1aMWJtTjBhVzl1SUdWdVkzSjVjSFJDZVhSbElDaHpaV3htTENCaWVYUmxVR0Z5WVcwc0lHUmxZM0o1Y0hRcElIdGNiaUFnZG1GeUlIQmhaQ0E5SUhObGJHWXVYMk5wY0dobGNpNWxibU55ZVhCMFFteHZZMnNvYzJWc1ppNWZjSEpsZGlsY2JpQWdkbUZ5SUc5MWRDQTlJSEJoWkZzd1hTQmVJR0o1ZEdWUVlYSmhiVnh1SUNCelpXeG1MbDl3Y21WMklEMGdRblZtWm1WeUxtTnZibU5oZENoYmMyVnNaaTVmY0hKbGRpNXpiR2xqWlNneEtTd2dibVYzSUVKMVptWmxjaWhiWkdWamNubHdkQ0EvSUdKNWRHVlFZWEpoYlNBNklHOTFkRjBwWFNsY2JpQWdjbVYwZFhKdUlHOTFkRnh1ZlZ4dVpYaHdiM0owY3k1bGJtTnllWEIwSUQwZ1puVnVZM1JwYjI0Z0tITmxiR1lzSUdOb2RXNXJMQ0JrWldOeWVYQjBLU0I3WEc0Z0lIWmhjaUJzWlc0Z1BTQmphSFZ1YXk1c1pXNW5kR2hjYmlBZ2RtRnlJRzkxZENBOUlHNWxkeUJDZFdabVpYSW9iR1Z1S1Z4dUlDQjJZWElnYVNBOUlDMHhYRzRnSUhkb2FXeGxJQ2dySzJrZ1BDQnNaVzRwSUh0Y2JpQWdJQ0J2ZFhSYmFWMGdQU0JsYm1OeWVYQjBRbmwwWlNoelpXeG1MQ0JqYUhWdWExdHBYU3dnWkdWamNubHdkQ2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiM1YwWEc1OVhHNGlYWDA9IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBuZXcgQnVmZmVyKFt2YWx1ZV0pXSlcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZiVzlrWlhNdlkyWmlNUzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWm5WdVkzUnBiMjRnWlc1amNubHdkRUo1ZEdVZ0tITmxiR1lzSUdKNWRHVlFZWEpoYlN3Z1pHVmpjbmx3ZENrZ2UxeHVJQ0IyWVhJZ2NHRmtYRzRnSUhaaGNpQnBJRDBnTFRGY2JpQWdkbUZ5SUd4bGJpQTlJRGhjYmlBZ2RtRnlJRzkxZENBOUlEQmNiaUFnZG1GeUlHSnBkQ3dnZG1Gc2RXVmNiaUFnZDJocGJHVWdLQ3NyYVNBOElHeGxiaWtnZTF4dUlDQWdJSEJoWkNBOUlITmxiR1l1WDJOcGNHaGxjaTVsYm1OeWVYQjBRbXh2WTJzb2MyVnNaaTVmY0hKbGRpbGNiaUFnSUNCaWFYUWdQU0FvWW5sMFpWQmhjbUZ0SUNZZ0tERWdQRHdnS0RjZ0xTQnBLU2twSUQ4Z01IZzRNQ0E2SURCY2JpQWdJQ0IyWVd4MVpTQTlJSEJoWkZzd1hTQmVJR0pwZEZ4dUlDQWdJRzkxZENBclBTQW9LSFpoYkhWbElDWWdNSGc0TUNrZ1BqNGdLR2tnSlNBNEtTbGNiaUFnSUNCelpXeG1MbDl3Y21WMklEMGdjMmhwWm5SSmJpaHpaV3htTGw5d2NtVjJMQ0JrWldOeWVYQjBJRDhnWW1sMElEb2dkbUZzZFdVcFhHNGdJSDFjYmlBZ2NtVjBkWEp1SUc5MWRGeHVmVnh1Wlhod2IzSjBjeTVsYm1OeWVYQjBJRDBnWm5WdVkzUnBiMjRnS0hObGJHWXNJR05vZFc1ckxDQmtaV055ZVhCMEtTQjdYRzRnSUhaaGNpQnNaVzRnUFNCamFIVnVheTVzWlc1bmRHaGNiaUFnZG1GeUlHOTFkQ0E5SUc1bGR5QkNkV1ptWlhJb2JHVnVLVnh1SUNCMllYSWdhU0E5SUMweFhHNGdJSGRvYVd4bElDZ3JLMmtnUENCc1pXNHBJSHRjYmlBZ0lDQnZkWFJiYVYwZ1BTQmxibU55ZVhCMFFubDBaU2h6Wld4bUxDQmphSFZ1YTF0cFhTd2daR1ZqY25sd2RDbGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IzVjBYRzU5WEc1bWRXNWpkR2x2YmlCemFHbG1kRWx1SUNoaWRXWm1aWElzSUhaaGJIVmxLU0I3WEc0Z0lIWmhjaUJzWlc0Z1BTQmlkV1ptWlhJdWJHVnVaM1JvWEc0Z0lIWmhjaUJwSUQwZ0xURmNiaUFnZG1GeUlHOTFkQ0E5SUc1bGR5QkNkV1ptWlhJb1luVm1abVZ5TG14bGJtZDBhQ2xjYmlBZ1luVm1abVZ5SUQwZ1FuVm1abVZ5TG1OdmJtTmhkQ2hiWW5WbVptVnlMQ0J1WlhjZ1FuVm1abVZ5S0Z0MllXeDFaVjBwWFNsY2JpQWdkMmhwYkdVZ0tDc3JhU0E4SUd4bGJpa2dlMXh1SUNBZ0lHOTFkRnRwWFNBOUlHSjFabVpsY2x0cFhTQThQQ0F4SUh3Z1luVm1abVZ5VzJrZ0t5QXhYU0ErUGlBb055bGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IzVjBYRzU5WEc0aVhYMD0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKCcnKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gbmV3IEJ1ZmZlcignJylcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzFoWlhNdmJXOWtaWE12WTJaaUxtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUoyWVhJZ2VHOXlJRDBnY21WeGRXbHlaU2duWW5WbVptVnlMWGh2Y2ljcFhHNWNibVY0Y0c5eWRITXVaVzVqY25sd2RDQTlJR1oxYm1OMGFXOXVJQ2h6Wld4bUxDQmtZWFJoTENCa1pXTnllWEIwS1NCN1hHNGdJSFpoY2lCdmRYUWdQU0J1WlhjZ1FuVm1abVZ5S0NjbktWeHVJQ0IyWVhJZ2JHVnVYRzVjYmlBZ2QyaHBiR1VnS0dSaGRHRXViR1Z1WjNSb0tTQjdYRzRnSUNBZ2FXWWdLSE5sYkdZdVgyTmhZMmhsTG14bGJtZDBhQ0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdjMlZzWmk1ZlkyRmphR1VnUFNCelpXeG1MbDlqYVhCb1pYSXVaVzVqY25sd2RFSnNiMk5yS0hObGJHWXVYM0J5WlhZcFhHNGdJQ0FnSUNCelpXeG1MbDl3Y21WMklEMGdibVYzSUVKMVptWmxjaWduSnlsY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlBb2MyVnNaaTVmWTJGamFHVXViR1Z1WjNSb0lEdzlJR1JoZEdFdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNCc1pXNGdQU0J6Wld4bUxsOWpZV05vWlM1c1pXNW5kR2hjYmlBZ0lDQWdJRzkxZENBOUlFSjFabVpsY2k1amIyNWpZWFFvVzI5MWRDd2daVzVqY25sd2RGTjBZWEowS0hObGJHWXNJR1JoZEdFdWMyeHBZMlVvTUN3Z2JHVnVLU3dnWkdWamNubHdkQ2xkS1Z4dUlDQWdJQ0FnWkdGMFlTQTlJR1JoZEdFdWMyeHBZMlVvYkdWdUtWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J2ZFhRZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0dmRYUXNJR1Z1WTNKNWNIUlRkR0Z5ZENoelpXeG1MQ0JrWVhSaExDQmtaV055ZVhCMEtWMHBYRzRnSUNBZ0lDQmljbVZoYTF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ2ZFhSY2JuMWNibVoxYm1OMGFXOXVJR1Z1WTNKNWNIUlRkR0Z5ZENBb2MyVnNaaXdnWkdGMFlTd2daR1ZqY25sd2RDa2dlMXh1SUNCMllYSWdiR1Z1SUQwZ1pHRjBZUzVzWlc1bmRHaGNiaUFnZG1GeUlHOTFkQ0E5SUhodmNpaGtZWFJoTENCelpXeG1MbDlqWVdOb1pTbGNiaUFnYzJWc1ppNWZZMkZqYUdVZ1BTQnpaV3htTGw5allXTm9aUzV6YkdsalpTaHNaVzRwWEc0Z0lITmxiR1l1WDNCeVpYWWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdHpaV3htTGw5d2NtVjJMQ0JrWldOeWVYQjBJRDhnWkdGMFlTQTZJRzkxZEYwcFhHNGdJSEpsZEhWeWJpQnZkWFJjYm4xY2JpSmRmUT09IiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIGRhdGEgPSB4b3IoYmxvY2ssIHNlbGYuX3ByZXYpXG5cbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soZGF0YSlcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBwYWQgPSBzZWxmLl9wcmV2XG5cbiAgc2VsZi5fcHJldiA9IGJsb2NrXG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxuXG4gIHJldHVybiB4b3Iob3V0LCBwYWQpXG59XG4iLCJleHBvcnRzWydhZXMtMTI4LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTkyLWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMjU2LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTI4LWNiYyddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0JDJyxcbiAgdHlwZTogJ2Jsb2NrJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jYmMnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NCQycsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2JjJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDQkMnLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMxMjgnXSA9IGV4cG9ydHNbJ2Flcy0xMjgtY2JjJ11cbmV4cG9ydHNbJ2FlczE5MiddID0gZXhwb3J0c1snYWVzLTE5Mi1jYmMnXVxuZXhwb3J0c1snYWVzMjU2J10gPSBleHBvcnRzWydhZXMtMjU2LWNiYyddXG5leHBvcnRzWydhZXMtMTI4LWNmYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjgnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjgnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmI4J10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkI4JyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiOCddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCOCcsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjEnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjEnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmIxJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkIxJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiMSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCMScsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LW9mYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnT0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItb2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdPRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1vZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ09GQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWN0ciddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ1RSJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY3RyJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDVFInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jdHInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NUUicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMTkyLWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMjU2LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vY2lwaGVyQmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgR0hBU0ggPSByZXF1aXJlKCcuL2doYXNoJylcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcblxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9maW5JRCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBuZXcgQnVmZmVyKFswLCAwLCAwLCAxXSldKVxuICBpdiA9IEJ1ZmZlci5jb25jYXQoW2l2LCBuZXcgQnVmZmVyKFswLCAwLCAwLCAyXSldKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX2FsZW4gPSAwXG4gIHRoaXMuX2xlbiA9IDBcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB2YXIgaCA9IG5ldyBCdWZmZXIoNClcbiAgaC5maWxsKDApXG4gIHRoaXMuX2doYXNoID0gbmV3IEdIQVNIKHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2soaCkpXG4gIHRoaXMuX2F1dGhUYWcgPSBudWxsXG4gIHRoaXMuX2NhbGxlZCA9IGZhbHNlXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQgJiYgdGhpcy5fYWxlbikge1xuICAgIHZhciBydW1wID0gMTYgLSAodGhpcy5fYWxlbiAlIDE2KVxuICAgIGlmIChydW1wIDwgMTYpIHtcbiAgICAgIHJ1bXAgPSBuZXcgQnVmZmVyKHJ1bXApXG4gICAgICBydW1wLmZpbGwoMClcbiAgICAgIHRoaXMuX2doYXNoLnVwZGF0ZShydW1wKVxuICAgIH1cbiAgfVxuICB0aGlzLl9jYWxsZWQgPSB0cnVlXG4gIHZhciBvdXQgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGNodW5rKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShvdXQpXG4gIH1cbiAgdGhpcy5fbGVuICs9IGNodW5rLmxlbmd0aFxuICByZXR1cm4gb3V0XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgIXRoaXMuX2F1dGhUYWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gIH1cbiAgdmFyIHRhZyA9IHhvcih0aGlzLl9naGFzaC5maW5hbCh0aGlzLl9hbGVuICogOCwgdGhpcy5fbGVuICogOCksIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fZmluSUQpKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIGlmICh4b3JUZXN0KHRhZywgdGhpcy5fYXV0aFRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiBnZXRBdXRoVGFnICgpIHtcbiAgaWYgKCF0aGlzLl9kZWNyeXB0ICYmIEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9hdXRoVGFnKSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRoVGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uIHNldEF1dGhUYWcgKHRhZykge1xuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiBzZXRBQUQgKGJ1Zikge1xuICBpZiAoIXRoaXMuX2NhbGxlZCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShidWYpXG4gICAgdGhpcy5fYWxlbiArPSBidWYubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBBQUQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5mdW5jdGlvbiB4b3JUZXN0IChhLCBiKSB7XG4gIHZhciBvdXQgPSAwXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICBvdXQrK1xuICB9XG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dCArPSAoYVtpXSBeIGJbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMWhaWE12WVhWMGFFTnBjR2hsY2k1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWRtRnlJR0ZsY3lBOUlISmxjWFZwY21Vb0p5NHZZV1Z6SnlsY2JuWmhjaUJVY21GdWMyWnZjbTBnUFNCeVpYRjFhWEpsS0NjdUwyTnBjR2hsY2tKaGMyVW5LVnh1ZG1GeUlHbHVhR1Z5YVhSeklEMGdjbVZ4ZFdseVpTZ25hVzVvWlhKcGRITW5LVnh1ZG1GeUlFZElRVk5JSUQwZ2NtVnhkV2x5WlNnbkxpOW5hR0Z6YUNjcFhHNTJZWElnZUc5eUlEMGdjbVZ4ZFdseVpTZ25ZblZtWm1WeUxYaHZjaWNwWEc1cGJtaGxjbWwwY3loVGRISmxZVzFEYVhCb1pYSXNJRlJ5WVc1elptOXliU2xjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVTNSeVpXRnRRMmx3YUdWeVhHNWNibVoxYm1OMGFXOXVJRk4wY21WaGJVTnBjR2hsY2lBb2JXOWtaU3dnYTJWNUxDQnBkaXdnWkdWamNubHdkQ2tnZTF4dUlDQnBaaUFvSVNoMGFHbHpJR2x1YzNSaGJtTmxiMllnVTNSeVpXRnRRMmx3YUdWeUtTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCdVpYY2dVM1J5WldGdFEybHdhR1Z5S0cxdlpHVXNJR3RsZVN3Z2FYWXBYRzRnSUgxY2JpQWdWSEpoYm5ObWIzSnRMbU5oYkd3b2RHaHBjeWxjYmlBZ2RHaHBjeTVmWm1sdVNVUWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdHBkaXdnYm1WM0lFSjFabVpsY2loYk1Dd2dNQ3dnTUN3Z01WMHBYU2xjYmlBZ2FYWWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdHBkaXdnYm1WM0lFSjFabVpsY2loYk1Dd2dNQ3dnTUN3Z01sMHBYU2xjYmlBZ2RHaHBjeTVmWTJsd2FHVnlJRDBnYm1WM0lHRmxjeTVCUlZNb2EyVjVLVnh1SUNCMGFHbHpMbDl3Y21WMklEMGdibVYzSUVKMVptWmxjaWhwZGk1c1pXNW5kR2dwWEc0Z0lIUm9hWE11WDJOaFkyaGxJRDBnYm1WM0lFSjFabVpsY2lnbkp5bGNiaUFnZEdocGN5NWZjMlZqUTJGamFHVWdQU0J1WlhjZ1FuVm1abVZ5S0NjbktWeHVJQ0IwYUdsekxsOWtaV055ZVhCMElEMGdaR1ZqY25sd2RGeHVJQ0IwYUdsekxsOWhiR1Z1SUQwZ01GeHVJQ0IwYUdsekxsOXNaVzRnUFNBd1hHNGdJR2wyTG1OdmNIa29kR2hwY3k1ZmNISmxkaWxjYmlBZ2RHaHBjeTVmYlc5a1pTQTlJRzF2WkdWY2JpQWdkbUZ5SUdnZ1BTQnVaWGNnUW5WbVptVnlLRFFwWEc0Z0lHZ3VabWxzYkNnd0tWeHVJQ0IwYUdsekxsOW5hR0Z6YUNBOUlHNWxkeUJIU0VGVFNDaDBhR2x6TGw5amFYQm9aWEl1Wlc1amNubHdkRUpzYjJOcktHZ3BLVnh1SUNCMGFHbHpMbDloZFhSb1ZHRm5JRDBnYm5Wc2JGeHVJQ0IwYUdsekxsOWpZV3hzWldRZ1BTQm1ZV3h6WlZ4dWZWeHVVM1J5WldGdFEybHdhR1Z5TG5CeWIzUnZkSGx3WlM1ZmRYQmtZWFJsSUQwZ1puVnVZM1JwYjI0Z0tHTm9kVzVyS1NCN1hHNGdJR2xtSUNnaGRHaHBjeTVmWTJGc2JHVmtJQ1ltSUhSb2FYTXVYMkZzWlc0cElIdGNiaUFnSUNCMllYSWdjblZ0Y0NBOUlERTJJQzBnS0hSb2FYTXVYMkZzWlc0Z0pTQXhOaWxjYmlBZ0lDQnBaaUFvY25WdGNDQThJREUyS1NCN1hHNGdJQ0FnSUNCeWRXMXdJRDBnYm1WM0lFSjFabVpsY2loeWRXMXdLVnh1SUNBZ0lDQWdjblZ0Y0M1bWFXeHNLREFwWEc0Z0lDQWdJQ0IwYUdsekxsOW5hR0Z6YUM1MWNHUmhkR1VvY25WdGNDbGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2RHaHBjeTVmWTJGc2JHVmtJRDBnZEhKMVpWeHVJQ0IyWVhJZ2IzVjBJRDBnZEdocGN5NWZiVzlrWlM1bGJtTnllWEIwS0hSb2FYTXNJR05vZFc1cktWeHVJQ0JwWmlBb2RHaHBjeTVmWkdWamNubHdkQ2tnZTF4dUlDQWdJSFJvYVhNdVgyZG9ZWE5vTG5Wd1pHRjBaU2hqYUhWdWF5bGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQjBhR2x6TGw5bmFHRnphQzUxY0dSaGRHVW9iM1YwS1Z4dUlDQjlYRzRnSUhSb2FYTXVYMnhsYmlBclBTQmphSFZ1YXk1c1pXNW5kR2hjYmlBZ2NtVjBkWEp1SUc5MWRGeHVmVnh1VTNSeVpXRnRRMmx3YUdWeUxuQnliM1J2ZEhsd1pTNWZabWx1WVd3Z1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lHbG1JQ2gwYUdsekxsOWtaV055ZVhCMElDWW1JQ0YwYUdsekxsOWhkWFJvVkdGbktTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkVmJuTjFjSEJ2Y25SbFpDQnpkR0YwWlNCdmNpQjFibUZpYkdVZ2RHOGdZWFYwYUdWdWRHbGpZWFJsSUdSaGRHRW5LVnh1SUNCOVhHNGdJSFpoY2lCMFlXY2dQU0I0YjNJb2RHaHBjeTVmWjJoaGMyZ3VabWx1WVd3b2RHaHBjeTVmWVd4bGJpQXFJRGdzSUhSb2FYTXVYMnhsYmlBcUlEZ3BMQ0IwYUdsekxsOWphWEJvWlhJdVpXNWpjbmx3ZEVKc2IyTnJLSFJvYVhNdVgyWnBia2xFS1NsY2JpQWdhV1lnS0hSb2FYTXVYMlJsWTNKNWNIUXBJSHRjYmlBZ0lDQnBaaUFvZUc5eVZHVnpkQ2gwWVdjc0lIUm9hWE11WDJGMWRHaFVZV2NwS1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjFWdWMzVndjRzl5ZEdWa0lITjBZWFJsSUc5eUlIVnVZV0pzWlNCMGJ5QmhkWFJvWlc1MGFXTmhkR1VnWkdGMFlTY3BYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIUm9hWE11WDJGMWRHaFVZV2NnUFNCMFlXZGNiaUFnZlZ4dUlDQjBhR2x6TGw5amFYQm9aWEl1YzJOeWRXSW9LVnh1ZlZ4dVUzUnlaV0Z0UTJsd2FHVnlMbkJ5YjNSdmRIbHdaUzVuWlhSQmRYUm9WR0ZuSUQwZ1puVnVZM1JwYjI0Z1oyVjBRWFYwYUZSaFp5QW9LU0I3WEc0Z0lHbG1JQ2doZEdocGN5NWZaR1ZqY25sd2RDQW1KaUJDZFdabVpYSXVhWE5DZFdabVpYSW9kR2hwY3k1ZllYVjBhRlJoWnlrcElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NWZZWFYwYUZSaFoxeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblFYUjBaVzF3ZEdsdVp5QjBieUJuWlhRZ1lYVjBhQ0IwWVdjZ2FXNGdkVzV6ZFhCd2IzSjBaV1FnYzNSaGRHVW5LVnh1SUNCOVhHNTlYRzVUZEhKbFlXMURhWEJvWlhJdWNISnZkRzkwZVhCbExuTmxkRUYxZEdoVVlXY2dQU0JtZFc1amRHbHZiaUJ6WlhSQmRYUm9WR0ZuSUNoMFlXY3BJSHRjYmlBZ2FXWWdLSFJvYVhNdVgyUmxZM0o1Y0hRcElIdGNiaUFnSUNCMGFHbHpMbDloZFhSb1ZHRm5JRDBnZEdGblhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkQmRIUmxiWEIwYVc1bklIUnZJSE5sZENCaGRYUm9JSFJoWnlCcGJpQjFibk4xY0hCdmNuUmxaQ0J6ZEdGMFpTY3BYRzRnSUgxY2JuMWNibE4wY21WaGJVTnBjR2hsY2k1d2NtOTBiM1I1Y0dVdWMyVjBRVUZFSUQwZ1puVnVZM1JwYjI0Z2MyVjBRVUZFSUNoaWRXWXBJSHRjYmlBZ2FXWWdLQ0YwYUdsekxsOWpZV3hzWldRcElIdGNiaUFnSUNCMGFHbHpMbDluYUdGemFDNTFjR1JoZEdVb1luVm1LVnh1SUNBZ0lIUm9hWE11WDJGc1pXNGdLejBnWW5WbUxteGxibWQwYUZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduUVhSMFpXMXdkR2x1WnlCMGJ5QnpaWFFnUVVGRUlHbHVJSFZ1YzNWd2NHOXlkR1ZrSUhOMFlYUmxKeWxjYmlBZ2ZWeHVmVnh1Wm5WdVkzUnBiMjRnZUc5eVZHVnpkQ0FvWVN3Z1lpa2dlMXh1SUNCMllYSWdiM1YwSUQwZ01GeHVJQ0JwWmlBb1lTNXNaVzVuZEdnZ0lUMDlJR0l1YkdWdVozUm9LU0I3WEc0Z0lDQWdiM1YwS3l0Y2JpQWdmVnh1SUNCMllYSWdiR1Z1SUQwZ1RXRjBhQzV0YVc0b1lTNXNaVzVuZEdnc0lHSXViR1Z1WjNSb0tWeHVJQ0IyWVhJZ2FTQTlJQzB4WEc0Z0lIZG9hV3hsSUNncksya2dQQ0JzWlc0cElIdGNiaUFnSUNCdmRYUWdLejBnS0dGYmFWMGdYaUJpVzJsZEtWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdmRYUmNibjFjYmlKZGZRPT0iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGFbaV0gXiBiW2ldXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZibTlrWlY5dGIyUjFiR1Z6TDJKMVptWmxjaTE0YjNJdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdlRzl5SUNoaExDQmlLU0I3WEc0Z0lIWmhjaUJzWlc1bmRHZ2dQU0JOWVhSb0xtMXBiaWhoTG14bGJtZDBhQ3dnWWk1c1pXNW5kR2dwWEc0Z0lIWmhjaUJpZFdabVpYSWdQU0J1WlhjZ1FuVm1abVZ5S0d4bGJtZDBhQ2xjYmx4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnWW5WbVptVnlXMmxkSUQwZ1lWdHBYU0JlSUdKYmFWMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQmlkV1ptWlhKY2JuMWNiaUpkZlE9PSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciB6ZXJvcyA9IG5ldyBCdWZmZXIoMTYpXG56ZXJvcy5maWxsKDApXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gbmV3IEJ1ZmZlcigxNilcbiAgdGhpcy5zdGF0ZS5maWxsKDApXG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JfVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSBpICUgOCkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppID0geG9yKFppLCBWaSlcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JfVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiX1ZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHplcm9zXSwgMTYpKVxuICB9XG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFtcbiAgICAwLCBhYmwsXG4gICAgMCwgYmxcbiAgXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIG91dCA9IG91dC5tYXAoZml4dXBfdWludDMyKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBhWzBdIF4gYlswXSxcbiAgICBhWzFdIF4gYlsxXSxcbiAgICBhWzJdIF4gYlsyXSxcbiAgICBhWzNdIF4gYlszXVxuICBdXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZaMmhoYzJndWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlIcGxjbTl6SUQwZ2JtVjNJRUoxWm1abGNpZ3hOaWxjYm5wbGNtOXpMbVpwYkd3b01DbGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdSMGhCVTBoY2JtWjFibU4wYVc5dUlFZElRVk5JSUNoclpYa3BJSHRjYmlBZ2RHaHBjeTVvSUQwZ2EyVjVYRzRnSUhSb2FYTXVjM1JoZEdVZ1BTQnVaWGNnUW5WbVptVnlLREUyS1Z4dUlDQjBhR2x6TG5OMFlYUmxMbVpwYkd3b01DbGNiaUFnZEdocGN5NWpZV05vWlNBOUlHNWxkeUJDZFdabVpYSW9KeWNwWEc1OVhHNHZMeUJtY205dElHaDBkSEE2THk5aWFYUjNhWE5sYzJocFpuUnNaV1owTG1kcGRHaDFZaTVwYnk5emFtTnNMMlJ2WXk5emVXMWliMnh6TDNOeVl5OWpiM0psWDJkamJTNXFjeTVvZEcxc1hHNHZMeUJpZVNCS2RXaHZJRmJEcEdqRHBDMUlaWEowZEhWaFhHNUhTRUZUU0M1d2NtOTBiM1I1Y0dVdVoyaGhjMmdnUFNCbWRXNWpkR2x2YmlBb1lteHZZMnNwSUh0Y2JpQWdkbUZ5SUdrZ1BTQXRNVnh1SUNCM2FHbHNaU0FvS3l0cElEd2dZbXh2WTJzdWJHVnVaM1JvS1NCN1hHNGdJQ0FnZEdocGN5NXpkR0YwWlZ0cFhTQmVQU0JpYkc5amExdHBYVnh1SUNCOVhHNGdJSFJvYVhNdVgyMTFiSFJwY0d4NUtDbGNibjFjYmx4dVIwaEJVMGd1Y0hKdmRHOTBlWEJsTGw5dGRXeDBhWEJzZVNBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RtRnlJRlpwSUQwZ2RHOUJjbkpoZVNoMGFHbHpMbWdwWEc0Z0lIWmhjaUJhYVNBOUlGc3dMQ0F3TENBd0xDQXdYVnh1SUNCMllYSWdhaXdnZUdrc0lHeHpZbDlXYVZ4dUlDQjJZWElnYVNBOUlDMHhYRzRnSUhkb2FXeGxJQ2dySzJrZ1BDQXhNamdwSUh0Y2JpQWdJQ0I0YVNBOUlDaDBhR2x6TG5OMFlYUmxXMzUrS0drZ0x5QTRLVjBnSmlBb01TQThQQ0FvTnlBdElHa2dKU0E0S1NrcElDRTlQU0F3WEc0Z0lDQWdhV1lnS0hocEtTQjdYRzRnSUNBZ0lDQXZMeUJhWDJrck1TQTlJRnBmYVNCZUlGWmZhVnh1SUNBZ0lDQWdXbWtnUFNCNGIzSW9XbWtzSUZacEtWeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklGTjBiM0psSUhSb1pTQjJZV3gxWlNCdlppQk1VMElvVmw5cEtWeHVJQ0FnSUd4ellsOVdhU0E5SUNoV2FWc3pYU0FtSURFcElDRTlQU0F3WEc1Y2JpQWdJQ0F2THlCV1gya3JNU0E5SUZaZmFTQStQaUF4WEc0Z0lDQWdabTl5SUNocUlEMGdNenNnYWlBK0lEQTdJR290TFNrZ2UxeHVJQ0FnSUNBZ1ZtbGJhbDBnUFNBb1ZtbGJhbDBnUGo0K0lERXBJSHdnS0NoV2FWdHFJQzBnTVYwZ0ppQXhLU0E4UENBek1TbGNiaUFnSUNCOVhHNGdJQ0FnVm1sYk1GMGdQU0JXYVZzd1hTQStQajRnTVZ4dVhHNGdJQ0FnTHk4Z1NXWWdURk5DS0ZaZmFTa2dhWE1nTVN3Z1ZsOXBLekVnUFNBb1ZsOXBJRDQrSURFcElGNGdVbHh1SUNBZ0lHbG1JQ2hzYzJKZlZta3BJSHRjYmlBZ0lDQWdJRlpwV3pCZElEMGdWbWxiTUYwZ1hpQW9NSGhsTVNBOFBDQXlOQ2xjYmlBZ0lDQjlYRzRnSUgxY2JpQWdkR2hwY3k1emRHRjBaU0E5SUdaeWIyMUJjbkpoZVNoYWFTbGNibjFjYmtkSVFWTklMbkJ5YjNSdmRIbHdaUzUxY0dSaGRHVWdQU0JtZFc1amRHbHZiaUFvWW5WbUtTQjdYRzRnSUhSb2FYTXVZMkZqYUdVZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0MGFHbHpMbU5oWTJobExDQmlkV1pkS1Z4dUlDQjJZWElnWTJoMWJtdGNiaUFnZDJocGJHVWdLSFJvYVhNdVkyRmphR1V1YkdWdVozUm9JRDQ5SURFMktTQjdYRzRnSUNBZ1kyaDFibXNnUFNCMGFHbHpMbU5oWTJobExuTnNhV05sS0RBc0lERTJLVnh1SUNBZ0lIUm9hWE11WTJGamFHVWdQU0IwYUdsekxtTmhZMmhsTG5Oc2FXTmxLREUyS1Z4dUlDQWdJSFJvYVhNdVoyaGhjMmdvWTJoMWJtc3BYRzRnSUgxY2JuMWNia2RJUVZOSUxuQnliM1J2ZEhsd1pTNW1hVzVoYkNBOUlHWjFibU4wYVc5dUlDaGhZbXdzSUdKc0tTQjdYRzRnSUdsbUlDaDBhR2x6TG1OaFkyaGxMbXhsYm1kMGFDa2dlMXh1SUNBZ0lIUm9hWE11WjJoaGMyZ29RblZtWm1WeUxtTnZibU5oZENoYmRHaHBjeTVqWVdOb1pTd2dlbVZ5YjNOZExDQXhOaWtwWEc0Z0lIMWNiaUFnZEdocGN5NW5hR0Z6YUNobWNtOXRRWEp5WVhrb1cxeHVJQ0FnSURBc0lHRmliQ3hjYmlBZ0lDQXdMQ0JpYkZ4dUlDQmRLU2xjYmlBZ2NtVjBkWEp1SUhSb2FYTXVjM1JoZEdWY2JuMWNibHh1Wm5WdVkzUnBiMjRnZEc5QmNuSmhlU0FvWW5WbUtTQjdYRzRnSUhKbGRIVnliaUJiWEc0Z0lDQWdZblZtTG5KbFlXUlZTVzUwTXpKQ1JTZ3dLU3hjYmlBZ0lDQmlkV1l1Y21WaFpGVkpiblF6TWtKRktEUXBMRnh1SUNBZ0lHSjFaaTV5WldGa1ZVbHVkRE15UWtVb09Da3NYRzRnSUNBZ1luVm1MbkpsWVdSVlNXNTBNekpDUlNneE1pbGNiaUFnWFZ4dWZWeHVablZ1WTNScGIyNGdabkp2YlVGeWNtRjVJQ2h2ZFhRcElIdGNiaUFnYjNWMElEMGdiM1YwTG0xaGNDaG1hWGgxY0Y5MWFXNTBNeklwWEc0Z0lIWmhjaUJpZFdZZ1BTQnVaWGNnUW5WbVptVnlLREUyS1Z4dUlDQmlkV1l1ZDNKcGRHVlZTVzUwTXpKQ1JTaHZkWFJiTUYwc0lEQXBYRzRnSUdKMVppNTNjbWwwWlZWSmJuUXpNa0pGS0c5MWRGc3hYU3dnTkNsY2JpQWdZblZtTG5keWFYUmxWVWx1ZERNeVFrVW9iM1YwV3pKZExDQTRLVnh1SUNCaWRXWXVkM0pwZEdWVlNXNTBNekpDUlNodmRYUmJNMTBzSURFeUtWeHVJQ0J5WlhSMWNtNGdZblZtWEc1OVhHNTJZWElnZFdsdWRGOXRZWGdnUFNCTllYUm9MbkJ2ZHlneUxDQXpNaWxjYm1aMWJtTjBhVzl1SUdacGVIVndYM1ZwYm5Rek1pQW9lQ2tnZTF4dUlDQjJZWElnY21WMExDQjRYM0J2YzF4dUlDQnlaWFFnUFNCNElENGdkV2x1ZEY5dFlYZ2dmSHdnZUNBOElEQWdQeUFvZUY5d2IzTWdQU0JOWVhSb0xtRmljeWg0S1NBbElIVnBiblJmYldGNExDQjRJRHdnTUNBL0lIVnBiblJmYldGNElDMGdlRjl3YjNNZ09pQjRYM0J2Y3lrZ09pQjRYRzRnSUhKbGRIVnliaUJ5WlhSY2JuMWNibVoxYm1OMGFXOXVJSGh2Y2lBb1lTd2dZaWtnZTF4dUlDQnlaWFIxY200Z1cxeHVJQ0FnSUdGYk1GMGdYaUJpV3pCZExGeHVJQ0FnSUdGYk1WMGdYaUJpV3pGZExGeHVJQ0FnSUdGYk1sMGdYaUJpV3pKZExGeHVJQ0FnSUdGYk0xMGdYaUJpV3pOZFhHNGdJRjFjYm4xY2JpSmRmUT09IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9iYXNlNjRDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICBuZXh0KClcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBuZXh0KGUpXG4gIH1cbiAgbmV4dCgpXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW5hbCkge1xuICBpZiAoZW5jICE9PSAnYmFzZTY0Jykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhlbmMpXG4gIH1cbiAgdGhpcy5fYmFzZTY0Q2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9iYXNlNjRDYWNoZSwgdmFsdWVdKVxuICB2YXIgb3V0XG4gIGlmIChmaW5hbCkge1xuICAgIG91dCA9IHRoaXMuX2Jhc2U2NENhY2hlXG4gICAgdGhpcy5fYmFzZTY0Q2FjaGUgPSBudWxsXG4gICAgcmV0dXJuIG91dC50b1N0cmluZygnYmFzZTY0JylcbiAgfVxuICB2YXIgbGVuID0gdGhpcy5fYmFzZTY0Q2FjaGUubGVuZ3RoXG4gIHZhciBvdmVyaGFuZyA9IGxlbiAlIDNcbiAgaWYgKCFvdmVyaGFuZykge1xuICAgIG91dCA9IHRoaXMuX2Jhc2U2NENhY2hlXG4gICAgdGhpcy5fYmFzZTY0Q2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICAgIHJldHVybiBvdXQudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIH1cbiAgdmFyIG5ld0xlbiA9IGxlbiAtIG92ZXJoYW5nXG4gIGlmICghbmV3TGVuKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBvdXQgPSB0aGlzLl9iYXNlNjRDYWNoZS5zbGljZSgwLCBuZXdMZW4pXG4gIHRoaXMuX2Jhc2U2NENhY2hlID0gdGhpcy5fYmFzZTY0Q2FjaGUuc2xpY2UoLW92ZXJoYW5nKVxuICByZXR1cm4gb3V0LnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlluSnZkM05sY21sbWVTMWhaWE12WTJsd2FHVnlRbUZ6WlM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW5aaGNpQlVjbUZ1YzJadmNtMGdQU0J5WlhGMWFYSmxLQ2R6ZEhKbFlXMG5LUzVVY21GdWMyWnZjbTFjYm5aaGNpQnBibWhsY21sMGN5QTlJSEpsY1hWcGNtVW9KMmx1YUdWeWFYUnpKeWxjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCRGFYQm9aWEpDWVhObFhHNXBibWhsY21sMGN5aERhWEJvWlhKQ1lYTmxMQ0JVY21GdWMyWnZjbTBwWEc1bWRXNWpkR2x2YmlCRGFYQm9aWEpDWVhObElDZ3BJSHRjYmlBZ1ZISmhibk5tYjNKdExtTmhiR3dvZEdocGN5bGNiaUFnZEdocGN5NWZZbUZ6WlRZMFEyRmphR1VnUFNCdVpYY2dRblZtWm1WeUtDY25LVnh1ZlZ4dVEybHdhR1Z5UW1GelpTNXdjbTkwYjNSNWNHVXVkWEJrWVhSbElEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHbHVjSFYwUlc1akxDQnZkWFJ3ZFhSRmJtTXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQmtZWFJoSUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lHUmhkR0VnUFNCdVpYY2dRblZtWm1WeUtHUmhkR0VzSUdsdWNIVjBSVzVqS1Z4dUlDQjlYRzRnSUhaaGNpQnZkWFJFWVhSaElEMGdkR2hwY3k1ZmRYQmtZWFJsS0dSaGRHRXBYRzRnSUdsbUlDaHZkWFJ3ZFhSRmJtTXBJSHRjYmlBZ0lDQnZkWFJFWVhSaElEMGdkR2hwY3k1ZmRHOVRkSEpwYm1jb2IzVjBSR0YwWVN3Z2IzVjBjSFYwUlc1aktWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdmRYUkVZWFJoWEc1OVhHNURhWEJvWlhKQ1lYTmxMbkJ5YjNSdmRIbHdaUzVmZEhKaGJuTm1iM0p0SUQwZ1puVnVZM1JwYjI0Z0tHUmhkR0VzSUY4c0lHNWxlSFFwSUh0Y2JpQWdkR2hwY3k1d2RYTm9LSFJvYVhNdVgzVndaR0YwWlNoa1lYUmhLU2xjYmlBZ2JtVjRkQ2dwWEc1OVhHNURhWEJvWlhKQ1lYTmxMbkJ5YjNSdmRIbHdaUzVmWm14MWMyZ2dQU0JtZFc1amRHbHZiaUFvYm1WNGRDa2dlMXh1SUNCMGNua2dlMXh1SUNBZ0lIUm9hWE11Y0hWemFDaDBhR2x6TGw5bWFXNWhiQ2dwS1Z4dUlDQjlJR05oZEdOb0tHVXBJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjRkQ2hsS1Z4dUlDQjlYRzRnSUc1bGVIUW9LVnh1ZlZ4dVEybHdhR1Z5UW1GelpTNXdjbTkwYjNSNWNHVXVabWx1WVd3Z1BTQm1kVzVqZEdsdmJpQW9iM1YwY0hWMFJXNWpLU0I3WEc0Z0lIWmhjaUJ2ZFhSRVlYUmhJRDBnZEdocGN5NWZabWx1WVd3b0tTQjhmQ0J1WlhjZ1FuVm1abVZ5S0NjbktWeHVJQ0JwWmlBb2IzVjBjSFYwUlc1aktTQjdYRzRnSUNBZ2IzVjBSR0YwWVNBOUlIUm9hWE11WDNSdlUzUnlhVzVuS0c5MWRFUmhkR0VzSUc5MWRIQjFkRVZ1WXl3Z2RISjFaU2xjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdiM1YwUkdGMFlWeHVmVnh1WEc1RGFYQm9aWEpDWVhObExuQnliM1J2ZEhsd1pTNWZkRzlUZEhKcGJtY2dQU0JtZFc1amRHbHZiaUFvZG1Gc2RXVXNJR1Z1WXl3Z1ptbHVZV3dwSUh0Y2JpQWdhV1lnS0dWdVl5QWhQVDBnSjJKaGMyVTJOQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkbUZzZFdVdWRHOVRkSEpwYm1jb1pXNWpLVnh1SUNCOVhHNGdJSFJvYVhNdVgySmhjMlUyTkVOaFkyaGxJRDBnUW5WbVptVnlMbU52Ym1OaGRDaGJkR2hwY3k1ZlltRnpaVFkwUTJGamFHVXNJSFpoYkhWbFhTbGNiaUFnZG1GeUlHOTFkRnh1SUNCcFppQW9abWx1WVd3cElIdGNiaUFnSUNCdmRYUWdQU0IwYUdsekxsOWlZWE5sTmpSRFlXTm9aVnh1SUNBZ0lIUm9hWE11WDJKaGMyVTJORU5oWTJobElEMGdiblZzYkZ4dUlDQWdJSEpsZEhWeWJpQnZkWFF1ZEc5VGRISnBibWNvSjJKaGMyVTJOQ2NwWEc0Z0lIMWNiaUFnZG1GeUlHeGxiaUE5SUhSb2FYTXVYMkpoYzJVMk5FTmhZMmhsTG14bGJtZDBhRnh1SUNCMllYSWdiM1psY21oaGJtY2dQU0JzWlc0Z0pTQXpYRzRnSUdsbUlDZ2hiM1psY21oaGJtY3BJSHRjYmlBZ0lDQnZkWFFnUFNCMGFHbHpMbDlpWVhObE5qUkRZV05vWlZ4dUlDQWdJSFJvYVhNdVgySmhjMlUyTkVOaFkyaGxJRDBnYm1WM0lFSjFabVpsY2lnbkp5bGNiaUFnSUNCeVpYUjFjbTRnYjNWMExuUnZVM1J5YVc1bktDZGlZWE5sTmpRbktWeHVJQ0I5WEc0Z0lIWmhjaUJ1WlhkTVpXNGdQU0JzWlc0Z0xTQnZkbVZ5YUdGdVoxeHVJQ0JwWmlBb0lXNWxkMHhsYmlrZ2UxeHVJQ0FnSUhKbGRIVnliaUFuSjF4dUlDQjlYRzVjYmlBZ2IzVjBJRDBnZEdocGN5NWZZbUZ6WlRZMFEyRmphR1V1YzJ4cFkyVW9NQ3dnYm1WM1RHVnVLVnh1SUNCMGFHbHpMbDlpWVhObE5qUkRZV05vWlNBOUlIUm9hWE11WDJKaGMyVTJORU5oWTJobExuTnNhV05sS0MxdmRtVnlhR0Z1WnlsY2JpQWdjbVYwZFhKdUlHOTFkQzUwYjFOMGNtbHVaeWduWW1GelpUWTBKeWxjYm4xY2JpSmRmUT09IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9mbHVzaCkpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHRzLndyaXRlY2h1bmspICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTl5WldGa1lXSnNaUzF6ZEhKbFlXMHZiR2xpTDE5emRISmxZVzFmWkhWd2JHVjRMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHZJRU52Y0hseWFXZG9kQ0JLYjNsbGJuUXNJRWx1WXk0Z1lXNWtJRzkwYUdWeUlFNXZaR1VnWTI5dWRISnBZblYwYjNKekxseHVMeTljYmk4dklGQmxjbTFwYzNOcGIyNGdhWE1nYUdWeVpXSjVJR2R5WVc1MFpXUXNJR1p5WldVZ2IyWWdZMmhoY21kbExDQjBieUJoYm5rZ2NHVnljMjl1SUc5aWRHRnBibWx1WnlCaFhHNHZMeUJqYjNCNUlHOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxYRzR2THlCY0lsTnZablIzWVhKbFhDSXBMQ0IwYnlCa1pXRnNJR2x1SUhSb1pTQlRiMlowZDJGeVpTQjNhWFJvYjNWMElISmxjM1J5YVdOMGFXOXVMQ0JwYm1Oc2RXUnBibWRjYmk4dklIZHBkR2h2ZFhRZ2JHbHRhWFJoZEdsdmJpQjBhR1VnY21sbmFIUnpJSFJ2SUhWelpTd2dZMjl3ZVN3Z2JXOWthV1o1TENCdFpYSm5aU3dnY0hWaWJHbHphQ3hjYmk4dklHUnBjM1J5YVdKMWRHVXNJSE4xWW14cFkyVnVjMlVzSUdGdVpDOXZjaUJ6Wld4c0lHTnZjR2xsY3lCdlppQjBhR1VnVTI5bWRIZGhjbVVzSUdGdVpDQjBieUJ3WlhKdGFYUmNiaTh2SUhCbGNuTnZibk1nZEc4Z2QyaHZiU0IwYUdVZ1UyOW1kSGRoY21VZ2FYTWdablZ5Ym1semFHVmtJSFJ2SUdSdklITnZMQ0J6ZFdKcVpXTjBJSFJ2SUhSb1pWeHVMeThnWm05c2JHOTNhVzVuSUdOdmJtUnBkR2x2Ym5NNlhHNHZMMXh1THk4Z1ZHaGxJR0ZpYjNabElHTnZjSGx5YVdkb2RDQnViM1JwWTJVZ1lXNWtJSFJvYVhNZ2NHVnliV2x6YzJsdmJpQnViM1JwWTJVZ2MyaGhiR3dnWW1VZ2FXNWpiSFZrWldSY2JpOHZJR2x1SUdGc2JDQmpiM0JwWlhNZ2IzSWdjM1ZpYzNSaGJuUnBZV3dnY0c5eWRHbHZibk1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMbHh1THk5Y2JpOHZJRlJJUlNCVFQwWlVWMEZTUlNCSlV5QlFVazlXU1VSRlJDQmNJa0ZUSUVsVFhDSXNJRmRKVkVoUFZWUWdWMEZTVWtGT1ZGa2dUMFlnUVU1WklFdEpUa1FzSUVWWVVGSkZVMU5jYmk4dklFOVNJRWxOVUV4SlJVUXNJRWxPUTB4VlJFbE9SeUJDVlZRZ1RrOVVJRXhKVFVsVVJVUWdWRThnVkVoRklGZEJVbEpCVGxSSlJWTWdUMFpjYmk4dklFMUZVa05JUVU1VVFVSkpURWxVV1N3Z1JrbFVUa1ZUVXlCR1QxSWdRU0JRUVZKVVNVTlZURUZTSUZCVlVsQlBVMFVnUVU1RUlFNVBUa2xPUmxKSlRrZEZUVVZPVkM0Z1NVNWNiaTh2SUU1UElFVldSVTVVSUZOSVFVeE1JRlJJUlNCQlZWUklUMUpUSUU5U0lFTlBVRmxTU1VkSVZDQklUMHhFUlZKVElFSkZJRXhKUVVKTVJTQkdUMUlnUVU1WklFTk1RVWxOTEZ4dUx5OGdSRUZOUVVkRlV5QlBVaUJQVkVoRlVpQk1TVUZDU1V4SlZGa3NJRmRJUlZSSVJWSWdTVTRnUVU0Z1FVTlVTVTlPSUU5R0lFTlBUbFJTUVVOVUxDQlVUMUpVSUU5U1hHNHZMeUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2NnUmxKUFRTd2dUMVZVSUU5R0lFOVNJRWxPSUVOUFRrNUZRMVJKVDA0Z1YwbFVTQ0JVU0VVZ1UwOUdWRmRCVWtVZ1QxSWdWRWhGWEc0dkx5QlZVMFVnVDFJZ1QxUklSVklnUkVWQlRFbE9SMU1nU1U0Z1ZFaEZJRk5QUmxSWFFWSkZMbHh1WEc0dkx5QmhJR1IxY0d4bGVDQnpkSEpsWVcwZ2FYTWdhblZ6ZENCaElITjBjbVZoYlNCMGFHRjBJR2x6SUdKdmRHZ2djbVZoWkdGaWJHVWdZVzVrSUhkeWFYUmhZbXhsTGx4dUx5OGdVMmx1WTJVZ1NsTWdaRzlsYzI0bmRDQm9ZWFpsSUcxMWJIUnBjR3hsSUhCeWIzUnZkSGx3WVd3Z2FXNW9aWEpwZEdGdVkyVXNJSFJvYVhNZ1kyeGhjM05jYmk4dklIQnliM1J2ZEhsd1lXeHNlU0JwYm1obGNtbDBjeUJtY205dElGSmxZV1JoWW14bExDQmhibVFnZEdobGJpQndZWEpoYzJsMGFXTmhiR3g1SUdaeWIyMWNiaTh2SUZkeWFYUmhZbXhsTGx4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFUjFjR3hsZUR0Y2JseHVMeW84Y21Wd2JHRmpaVzFsYm5RK0tpOWNiblpoY2lCdlltcGxZM1JMWlhseklEMGdUMkpxWldOMExtdGxlWE1nZkh3Z1puVnVZM1JwYjI0Z0tHOWlhaWtnZTF4dUlDQjJZWElnYTJWNWN5QTlJRnRkTzF4dUlDQm1iM0lnS0haaGNpQnJaWGtnYVc0Z2IySnFLU0JyWlhsekxuQjFjMmdvYTJWNUtUdGNiaUFnY21WMGRYSnVJR3RsZVhNN1hHNTlYRzR2S2p3dmNtVndiR0ZqWlcxbGJuUStLaTljYmx4dVhHNHZLanh5WlhCc1lXTmxiV1Z1ZEQ0cUwxeHVkbUZ5SUhWMGFXd2dQU0J5WlhGMWFYSmxLQ2RqYjNKbExYVjBhV3d0YVhNbktUdGNiblYwYVd3dWFXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BPMXh1THlvOEwzSmxjR3hoWTJWdFpXNTBQaW92WEc1Y2JuWmhjaUJTWldGa1lXSnNaU0E5SUhKbGNYVnBjbVVvSnk0dlgzTjBjbVZoYlY5eVpXRmtZV0pzWlNjcE8xeHVkbUZ5SUZkeWFYUmhZbXhsSUQwZ2NtVnhkV2x5WlNnbkxpOWZjM1J5WldGdFgzZHlhWFJoWW14bEp5azdYRzVjYm5WMGFXd3VhVzVvWlhKcGRITW9SSFZ3YkdWNExDQlNaV0ZrWVdKc1pTazdYRzVjYm1admNrVmhZMmdvYjJKcVpXTjBTMlY1Y3loWGNtbDBZV0pzWlM1d2NtOTBiM1I1Y0dVcExDQm1kVzVqZEdsdmJpaHRaWFJvYjJRcElIdGNiaUFnYVdZZ0tDRkVkWEJzWlhndWNISnZkRzkwZVhCbFcyMWxkR2h2WkYwcFhHNGdJQ0FnUkhWd2JHVjRMbkJ5YjNSdmRIbHdaVnR0WlhSb2IyUmRJRDBnVjNKcGRHRmliR1V1Y0hKdmRHOTBlWEJsVzIxbGRHaHZaRjA3WEc1OUtUdGNibHh1Wm5WdVkzUnBiMjRnUkhWd2JHVjRLRzl3ZEdsdmJuTXBJSHRjYmlBZ2FXWWdLQ0VvZEdocGN5QnBibk4wWVc1alpXOW1JRVIxY0d4bGVDa3BYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QkVkWEJzWlhnb2IzQjBhVzl1Y3lrN1hHNWNiaUFnVW1WaFpHRmliR1V1WTJGc2JDaDBhR2x6TENCdmNIUnBiMjV6S1R0Y2JpQWdWM0pwZEdGaWJHVXVZMkZzYkNoMGFHbHpMQ0J2Y0hScGIyNXpLVHRjYmx4dUlDQnBaaUFvYjNCMGFXOXVjeUFtSmlCdmNIUnBiMjV6TG5KbFlXUmhZbXhsSUQwOVBTQm1ZV3h6WlNsY2JpQWdJQ0IwYUdsekxuSmxZV1JoWW14bElEMGdabUZzYzJVN1hHNWNiaUFnYVdZZ0tHOXdkR2x2Ym5NZ0ppWWdiM0IwYVc5dWN5NTNjbWwwWVdKc1pTQTlQVDBnWm1Gc2MyVXBYRzRnSUNBZ2RHaHBjeTUzY21sMFlXSnNaU0E5SUdaaGJITmxPMXh1WEc0Z0lIUm9hWE11WVd4c2IzZElZV3htVDNCbGJpQTlJSFJ5ZFdVN1hHNGdJR2xtSUNodmNIUnBiMjV6SUNZbUlHOXdkR2x2Ym5NdVlXeHNiM2RJWVd4bVQzQmxiaUE5UFQwZ1ptRnNjMlVwWEc0Z0lDQWdkR2hwY3k1aGJHeHZkMGhoYkdaUGNHVnVJRDBnWm1Gc2MyVTdYRzVjYmlBZ2RHaHBjeTV2Ym1ObEtDZGxibVFuTENCdmJtVnVaQ2s3WEc1OVhHNWNiaTh2SUhSb1pTQnVieTFvWVd4bUxXOXdaVzRnWlc1bWIzSmpaWEpjYm1aMWJtTjBhVzl1SUc5dVpXNWtLQ2tnZTF4dUlDQXZMeUJwWmlCM1pTQmhiR3h2ZHlCb1lXeG1MVzl3Wlc0Z2MzUmhkR1VzSUc5eUlHbG1JSFJvWlNCM2NtbDBZV0pzWlNCemFXUmxJR1Z1WkdWa0xGeHVJQ0F2THlCMGFHVnVJSGRsSjNKbElHOXJMbHh1SUNCcFppQW9kR2hwY3k1aGJHeHZkMGhoYkdaUGNHVnVJSHg4SUhSb2FYTXVYM2R5YVhSaFlteGxVM1JoZEdVdVpXNWtaV1FwWEc0Z0lDQWdjbVYwZFhKdU8xeHVYRzRnSUM4dklHNXZJRzF2Y21VZ1pHRjBZU0JqWVc0Z1ltVWdkM0pwZEhSbGJpNWNiaUFnTHk4Z1FuVjBJR0ZzYkc5M0lHMXZjbVVnZDNKcGRHVnpJSFJ2SUdoaGNIQmxiaUJwYmlCMGFHbHpJSFJwWTJzdVhHNGdJSEJ5YjJObGMzTXVibVY0ZEZScFkyc29kR2hwY3k1bGJtUXVZbWx1WkNoMGFHbHpLU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR1p2Y2tWaFkyZ2dLSGh6TENCbUtTQjdYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzSUQwZ2VITXViR1Z1WjNSb095QnBJRHdnYkRzZ2FTc3JLU0I3WEc0Z0lDQWdaaWg0YzF0cFhTd2dhU2s3WEc0Z0lIMWNibjFjYmlKZGZRPT0iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTl5WldGa1lXSnNaUzF6ZEhKbFlXMHZiR2xpTDE5emRISmxZVzFmZDNKcGRHRmliR1V1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdkx5QkRiM0I1Y21sbmFIUWdTbTk1Wlc1MExDQkpibU11SUdGdVpDQnZkR2hsY2lCT2IyUmxJR052Ym5SeWFXSjFkRzl5Y3k1Y2JpOHZYRzR2THlCUVpYSnRhWE56YVc5dUlHbHpJR2hsY21WaWVTQm5jbUZ1ZEdWa0xDQm1jbVZsSUc5bUlHTm9ZWEpuWlN3Z2RHOGdZVzU1SUhCbGNuTnZiaUJ2WW5SaGFXNXBibWNnWVZ4dUx5OGdZMjl3ZVNCdlppQjBhR2x6SUhOdlpuUjNZWEpsSUdGdVpDQmhjM052WTJsaGRHVmtJR1J2WTNWdFpXNTBZWFJwYjI0Z1ptbHNaWE1nS0hSb1pWeHVMeThnWENKVGIyWjBkMkZ5WlZ3aUtTd2dkRzhnWkdWaGJDQnBiaUIwYUdVZ1UyOW1kSGRoY21VZ2QybDBhRzkxZENCeVpYTjBjbWxqZEdsdmJpd2dhVzVqYkhWa2FXNW5YRzR2THlCM2FYUm9iM1YwSUd4cGJXbDBZWFJwYjI0Z2RHaGxJSEpwWjJoMGN5QjBieUIxYzJVc0lHTnZjSGtzSUcxdlpHbG1lU3dnYldWeVoyVXNJSEIxWW14cGMyZ3NYRzR2THlCa2FYTjBjbWxpZFhSbExDQnpkV0pzYVdObGJuTmxMQ0JoYm1RdmIzSWdjMlZzYkNCamIzQnBaWE1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMQ0JoYm1RZ2RHOGdjR1Z5YldsMFhHNHZMeUJ3WlhKemIyNXpJSFJ2SUhkb2IyMGdkR2hsSUZOdlpuUjNZWEpsSUdseklHWjFjbTVwYzJobFpDQjBieUJrYnlCemJ5d2djM1ZpYW1WamRDQjBieUIwYUdWY2JpOHZJR1p2Ykd4dmQybHVaeUJqYjI1a2FYUnBiMjV6T2x4dUx5OWNiaTh2SUZSb1pTQmhZbTkyWlNCamIzQjVjbWxuYUhRZ2JtOTBhV05sSUdGdVpDQjBhR2x6SUhCbGNtMXBjM05wYjI0Z2JtOTBhV05sSUhOb1lXeHNJR0psSUdsdVkyeDFaR1ZrWEc0dkx5QnBiaUJoYkd3Z1kyOXdhV1Z6SUc5eUlITjFZbk4wWVc1MGFXRnNJSEJ2Y25ScGIyNXpJRzltSUhSb1pTQlRiMlowZDJGeVpTNWNiaTh2WEc0dkx5QlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRYRzR2THlCUFVpQkpUVkJNU1VWRUxDQkpUa05NVlVSSlRrY2dRbFZVSUU1UFZDQk1TVTFKVkVWRUlGUlBJRlJJUlNCWFFWSlNRVTVVU1VWVElFOUdYRzR2THlCTlJWSkRTRUZPVkVGQ1NVeEpWRmtzSUVaSlZFNUZVMU1nUms5U0lFRWdVRUZTVkVsRFZVeEJVaUJRVlZKUVQxTkZJRUZPUkNCT1QwNUpUa1pTU1U1SFJVMUZUbFF1SUVsT1hHNHZMeUJPVHlCRlZrVk9WQ0JUU0VGTVRDQlVTRVVnUVZWVVNFOVNVeUJQVWlCRFQxQlpVa2xIU0ZRZ1NFOU1SRVZTVXlCQ1JTQk1TVUZDVEVVZ1JrOVNJRUZPV1NCRFRFRkpUU3hjYmk4dklFUkJUVUZIUlZNZ1QxSWdUMVJJUlZJZ1RFbEJRa2xNU1ZSWkxDQlhTRVZVU0VWU0lFbE9JRUZPSUVGRFZFbFBUaUJQUmlCRFQwNVVVa0ZEVkN3Z1ZFOVNWQ0JQVWx4dUx5OGdUMVJJUlZKWFNWTkZMQ0JCVWtsVFNVNUhJRVpTVDAwc0lFOVZWQ0JQUmlCUFVpQkpUaUJEVDA1T1JVTlVTVTlPSUZkSlZFZ2dWRWhGSUZOUFJsUlhRVkpGSUU5U0lGUklSVnh1THk4Z1ZWTkZJRTlTSUU5VVNFVlNJRVJGUVV4SlRrZFRJRWxPSUZSSVJTQlRUMFpVVjBGU1JTNWNibHh1THk4Z1FTQmlhWFFnYzJsdGNHeGxjaUIwYUdGdUlISmxZV1JoWW14bElITjBjbVZoYlhNdVhHNHZMeUJKYlhCc1pXMWxiblFnWVc0Z1lYTjVibU1nTGw5M2NtbDBaU2hqYUhWdWF5d2dZMklwTENCaGJtUWdhWFFuYkd3Z2FHRnVaR3hsSUdGc2JGeHVMeThnZEdobElHUnlZV2x1SUdWMlpXNTBJR1Z0YVhOemFXOXVJR0Z1WkNCaWRXWm1aWEpwYm1jdVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdWM0pwZEdGaWJHVTdYRzVjYmk4cVBISmxjR3hoWTJWdFpXNTBQaW92WEc1MllYSWdRblZtWm1WeUlEMGdjbVZ4ZFdseVpTZ25ZblZtWm1WeUp5a3VRblZtWm1WeU8xeHVMeW84TDNKbGNHeGhZMlZ0Wlc1MFBpb3ZYRzVjYmxkeWFYUmhZbXhsTGxkeWFYUmhZbXhsVTNSaGRHVWdQU0JYY21sMFlXSnNaVk4wWVhSbE8xeHVYRzVjYmk4cVBISmxjR3hoWTJWdFpXNTBQaW92WEc1MllYSWdkWFJwYkNBOUlISmxjWFZwY21Vb0oyTnZjbVV0ZFhScGJDMXBjeWNwTzF4dWRYUnBiQzVwYm1obGNtbDBjeUE5SUhKbGNYVnBjbVVvSjJsdWFHVnlhWFJ6SnlrN1hHNHZLand2Y21Wd2JHRmpaVzFsYm5RK0tpOWNibHh1ZG1GeUlGTjBjbVZoYlNBOUlISmxjWFZwY21Vb0ozTjBjbVZoYlNjcE8xeHVYRzUxZEdsc0xtbHVhR1Z5YVhSektGZHlhWFJoWW14bExDQlRkSEpsWVcwcE8xeHVYRzVtZFc1amRHbHZiaUJYY21sMFpWSmxjU2hqYUhWdWF5d2daVzVqYjJScGJtY3NJR05pS1NCN1hHNGdJSFJvYVhNdVkyaDFibXNnUFNCamFIVnVhenRjYmlBZ2RHaHBjeTVsYm1OdlpHbHVaeUE5SUdWdVkyOWthVzVuTzF4dUlDQjBhR2x6TG1OaGJHeGlZV05ySUQwZ1kySTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlGZHlhWFJoWW14bFUzUmhkR1VvYjNCMGFXOXVjeXdnYzNSeVpXRnRLU0I3WEc0Z0lIWmhjaUJFZFhCc1pYZ2dQU0J5WlhGMWFYSmxLQ2N1TDE5emRISmxZVzFmWkhWd2JHVjRKeWs3WEc1Y2JpQWdiM0IwYVc5dWN5QTlJRzl3ZEdsdmJuTWdmSHdnZTMwN1hHNWNiaUFnTHk4Z2RHaGxJSEJ2YVc1MElHRjBJSGRvYVdOb0lIZHlhWFJsS0NrZ2MzUmhjblJ6SUhKbGRIVnlibWx1WnlCbVlXeHpaVnh1SUNBdkx5Qk9iM1JsT2lBd0lHbHpJR0VnZG1Gc2FXUWdkbUZzZFdVc0lHMWxZVzV6SUhSb1lYUWdkMlVnWVd4M1lYbHpJSEpsZEhWeWJpQm1ZV3h6WlNCcFpseHVJQ0F2THlCMGFHVWdaVzUwYVhKbElHSjFabVpsY2lCcGN5QnViM1FnWm14MWMyaGxaQ0JwYlcxbFpHbGhkR1ZzZVNCdmJpQjNjbWwwWlNncFhHNGdJSFpoY2lCb2QyMGdQU0J2Y0hScGIyNXpMbWhwWjJoWFlYUmxjazFoY21zN1hHNGdJSFpoY2lCa1pXWmhkV3gwU0hkdElEMGdiM0IwYVc5dWN5NXZZbXBsWTNSTmIyUmxJRDhnTVRZZ09pQXhOaUFxSURFd01qUTdYRzRnSUhSb2FYTXVhR2xuYUZkaGRHVnlUV0Z5YXlBOUlDaG9kMjBnZkh3Z2FIZHRJRDA5UFNBd0tTQS9JR2gzYlNBNklHUmxabUYxYkhSSWQyMDdYRzVjYmlBZ0x5OGdiMkpxWldOMElITjBjbVZoYlNCbWJHRm5JSFJ2SUdsdVpHbGpZWFJsSUhkb1pYUm9aWElnYjNJZ2JtOTBJSFJvYVhNZ2MzUnlaV0Z0WEc0Z0lDOHZJR052Ym5SaGFXNXpJR0oxWm1abGNuTWdiM0lnYjJKcVpXTjBjeTVjYmlBZ2RHaHBjeTV2WW1wbFkzUk5iMlJsSUQwZ0lTRnZjSFJwYjI1ekxtOWlhbVZqZEUxdlpHVTdYRzVjYmlBZ2FXWWdLSE4wY21WaGJTQnBibk4wWVc1alpXOW1JRVIxY0d4bGVDbGNiaUFnSUNCMGFHbHpMbTlpYW1WamRFMXZaR1VnUFNCMGFHbHpMbTlpYW1WamRFMXZaR1VnZkh3Z0lTRnZjSFJwYjI1ekxuZHlhWFJoWW14bFQySnFaV04wVFc5a1pUdGNibHh1SUNBdkx5QmpZWE4wSUhSdklHbHVkSE11WEc0Z0lIUm9hWE11YUdsbmFGZGhkR1Z5VFdGeWF5QTlJSDUrZEdocGN5NW9hV2RvVjJGMFpYSk5ZWEpyTzF4dVhHNGdJSFJvYVhNdWJtVmxaRVJ5WVdsdUlEMGdabUZzYzJVN1hHNGdJQzh2SUdGMElIUm9aU0J6ZEdGeWRDQnZaaUJqWVd4c2FXNW5JR1Z1WkNncFhHNGdJSFJvYVhNdVpXNWthVzVuSUQwZ1ptRnNjMlU3WEc0Z0lDOHZJSGRvWlc0Z1pXNWtLQ2tnYUdGeklHSmxaVzRnWTJGc2JHVmtMQ0JoYm1RZ2NtVjBkWEp1WldSY2JpQWdkR2hwY3k1bGJtUmxaQ0E5SUdaaGJITmxPMXh1SUNBdkx5QjNhR1Z1SUNkbWFXNXBjMmduSUdseklHVnRhWFIwWldSY2JpQWdkR2hwY3k1bWFXNXBjMmhsWkNBOUlHWmhiSE5sTzF4dVhHNGdJQzh2SUhOb2IzVnNaQ0IzWlNCa1pXTnZaR1VnYzNSeWFXNW5jeUJwYm5SdklHSjFabVpsY25NZ1ltVm1iM0psSUhCaGMzTnBibWNnZEc4Z1gzZHlhWFJsUDF4dUlDQXZMeUIwYUdseklHbHpJR2hsY21VZ2MyOGdkR2hoZENCemIyMWxJRzV2WkdVdFkyOXlaU0J6ZEhKbFlXMXpJR05oYmlCdmNIUnBiV2w2WlNCemRISnBibWRjYmlBZ0x5OGdhR0Z1Wkd4cGJtY2dZWFFnWVNCc2IzZGxjaUJzWlhabGJDNWNiaUFnZG1GeUlHNXZSR1ZqYjJSbElEMGdiM0IwYVc5dWN5NWtaV052WkdWVGRISnBibWR6SUQwOVBTQm1ZV3h6WlR0Y2JpQWdkR2hwY3k1a1pXTnZaR1ZUZEhKcGJtZHpJRDBnSVc1dlJHVmpiMlJsTzF4dVhHNGdJQzh2SUVOeWVYQjBieUJwY3lCcmFXNWtJRzltSUc5c1pDQmhibVFnWTNKMWMzUjVMaUFnU0dsemRHOXlhV05oYkd4NUxDQnBkSE1nWkdWbVlYVnNkQ0J6ZEhKcGJtZGNiaUFnTHk4Z1pXNWpiMlJwYm1jZ2FYTWdKMkpwYm1GeWVTY2djMjhnZDJVZ2FHRjJaU0IwYnlCdFlXdGxJSFJvYVhNZ1kyOXVabWxuZFhKaFlteGxMbHh1SUNBdkx5QkZkbVZ5ZVhSb2FXNW5JR1ZzYzJVZ2FXNGdkR2hsSUhWdWFYWmxjbk5sSUhWelpYTWdKM1YwWmpnbkxDQjBhRzkxWjJndVhHNGdJSFJvYVhNdVpHVm1ZWFZzZEVWdVkyOWthVzVuSUQwZ2IzQjBhVzl1Y3k1a1pXWmhkV3gwUlc1amIyUnBibWNnZkh3Z0ozVjBaamduTzF4dVhHNGdJQzh2SUc1dmRDQmhiaUJoWTNSMVlXd2dZblZtWm1WeUlIZGxJR3RsWlhBZ2RISmhZMnNnYjJZc0lHSjFkQ0JoSUcxbFlYTjFjbVZ0Wlc1MFhHNGdJQzh2SUc5bUlHaHZkeUJ0ZFdOb0lIZGxKM0psSUhkaGFYUnBibWNnZEc4Z1oyVjBJSEIxYzJobFpDQjBieUJ6YjIxbElIVnVaR1Z5YkhscGJtZGNiaUFnTHk4Z2MyOWphMlYwSUc5eUlHWnBiR1V1WEc0Z0lIUm9hWE11YkdWdVozUm9JRDBnTUR0Y2JseHVJQ0F2THlCaElHWnNZV2NnZEc4Z2MyVmxJSGRvWlc0Z2QyVW5jbVVnYVc0Z2RHaGxJRzFwWkdSc1pTQnZaaUJoSUhkeWFYUmxMbHh1SUNCMGFHbHpMbmR5YVhScGJtY2dQU0JtWVd4elpUdGNibHh1SUNBdkx5QjNhR1Z1SUhSeWRXVWdZV3hzSUhkeWFYUmxjeUIzYVd4c0lHSmxJR0oxWm1abGNtVmtJSFZ1ZEdsc0lDNTFibU52Y21zb0tTQmpZV3hzWEc0Z0lIUm9hWE11WTI5eWEyVmtJRDBnTUR0Y2JseHVJQ0F2THlCaElHWnNZV2NnZEc4Z1ltVWdZV0pzWlNCMGJ5QjBaV3hzSUdsbUlIUm9aU0J2Ym5keWFYUmxJR05pSUdseklHTmhiR3hsWkNCcGJXMWxaR2xoZEdWc2VTeGNiaUFnTHk4Z2IzSWdiMjRnWVNCc1lYUmxjaUIwYVdOckxpQWdWMlVnYzJWMElIUm9hWE1nZEc4Z2RISjFaU0JoZENCbWFYSnpkQ3dnWW1WallYVnpaU0JoYm5sY2JpQWdMeThnWVdOMGFXOXVjeUIwYUdGMElITm9iM1ZzWkc0bmRDQm9ZWEJ3Wlc0Z2RXNTBhV3dnWENKc1lYUmxjbHdpSUhOb2IzVnNaQ0JuWlc1bGNtRnNiSGtnWVd4emIxeHVJQ0F2THlCdWIzUWdhR0Z3Y0dWdUlHSmxabTl5WlNCMGFHVWdabWx5YzNRZ2QzSnBkR1VnWTJGc2JDNWNiaUFnZEdocGN5NXplVzVqSUQwZ2RISjFaVHRjYmx4dUlDQXZMeUJoSUdac1lXY2dkRzhnYTI1dmR5QnBaaUIzWlNkeVpTQndjbTlqWlhOemFXNW5JSEJ5WlhacGIzVnpiSGtnWW5WbVptVnlaV1FnYVhSbGJYTXNJSGRvYVdOb1hHNGdJQzh2SUcxaGVTQmpZV3hzSUhSb1pTQmZkM0pwZEdVb0tTQmpZV3hzWW1GamF5QnBiaUIwYUdVZ2MyRnRaU0IwYVdOckxDQnpieUIwYUdGMElIZGxJR1J2YmlkMFhHNGdJQzh2SUdWdVpDQjFjQ0JwYmlCaGJpQnZkbVZ5YkdGd2NHVmtJRzl1ZDNKcGRHVWdjMmwwZFdGMGFXOXVMbHh1SUNCMGFHbHpMbUoxWm1abGNsQnliMk5sYzNOcGJtY2dQU0JtWVd4elpUdGNibHh1SUNBdkx5QjBhR1VnWTJGc2JHSmhZMnNnZEdoaGRDZHpJSEJoYzNObFpDQjBieUJmZDNKcGRHVW9ZMmgxYm1zc1kySXBYRzRnSUhSb2FYTXViMjUzY21sMFpTQTlJR1oxYm1OMGFXOXVLR1Z5S1NCN1hHNGdJQ0FnYjI1M2NtbDBaU2h6ZEhKbFlXMHNJR1Z5S1R0Y2JpQWdmVHRjYmx4dUlDQXZMeUIwYUdVZ1kyRnNiR0poWTJzZ2RHaGhkQ0IwYUdVZ2RYTmxjaUJ6ZFhCd2JHbGxjeUIwYnlCM2NtbDBaU2hqYUhWdWF5eGxibU52WkdsdVp5eGpZaWxjYmlBZ2RHaHBjeTUzY21sMFpXTmlJRDBnYm5Wc2JEdGNibHh1SUNBdkx5QjBhR1VnWVcxdmRXNTBJSFJvWVhRZ2FYTWdZbVZwYm1jZ2QzSnBkSFJsYmlCM2FHVnVJRjkzY21sMFpTQnBjeUJqWVd4c1pXUXVYRzRnSUhSb2FYTXVkM0pwZEdWc1pXNGdQU0F3TzF4dVhHNGdJSFJvYVhNdVluVm1abVZ5SUQwZ1cxMDdYRzVjYmlBZ0x5OGdiblZ0WW1WeUlHOW1JSEJsYm1ScGJtY2dkWE5sY2kxemRYQndiR2xsWkNCM2NtbDBaU0JqWVd4c1ltRmphM05jYmlBZ0x5OGdkR2hwY3lCdGRYTjBJR0psSURBZ1ltVm1iM0psSUNkbWFXNXBjMmduSUdOaGJpQmlaU0JsYldsMGRHVmtYRzRnSUhSb2FYTXVjR1Z1WkdsdVoyTmlJRDBnTUR0Y2JseHVJQ0F2THlCbGJXbDBJSEJ5WldacGJtbHphQ0JwWmlCMGFHVWdiMjVzZVNCMGFHbHVaeUIzWlNkeVpTQjNZV2wwYVc1bklHWnZjaUJwY3lCZmQzSnBkR1VnWTJKelhHNGdJQzh2SUZSb2FYTWdhWE1nY21Wc1pYWmhiblFnWm05eUlITjVibU5vY205dWIzVnpJRlJ5WVc1elptOXliU0J6ZEhKbFlXMXpYRzRnSUhSb2FYTXVjSEpsWm1sdWFYTm9aV1FnUFNCbVlXeHpaVHRjYmx4dUlDQXZMeUJVY25WbElHbG1JSFJvWlNCbGNuSnZjaUIzWVhNZ1lXeHlaV0ZrZVNCbGJXbDBkR1ZrSUdGdVpDQnphRzkxYkdRZ2JtOTBJR0psSUhSb2NtOTNiaUJoWjJGcGJseHVJQ0IwYUdsekxtVnljbTl5UlcxcGRIUmxaQ0E5SUdaaGJITmxPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQlhjbWwwWVdKc1pTaHZjSFJwYjI1ektTQjdYRzRnSUhaaGNpQkVkWEJzWlhnZ1BTQnlaWEYxYVhKbEtDY3VMMTl6ZEhKbFlXMWZaSFZ3YkdWNEp5azdYRzVjYmlBZ0x5OGdWM0pwZEdGaWJHVWdZM1J2Y2lCcGN5QmhjSEJzYVdWa0lIUnZJRVIxY0d4bGVHVnpMQ0IwYUc5MVoyZ2dkR2hsZVNkeVpTQnViM1JjYmlBZ0x5OGdhVzV6ZEdGdVkyVnZaaUJYY21sMFlXSnNaU3dnZEdobGVTZHlaU0JwYm5OMFlXNWpaVzltSUZKbFlXUmhZbXhsTGx4dUlDQnBaaUFvSVNoMGFHbHpJR2x1YzNSaGJtTmxiMllnVjNKcGRHRmliR1VwSUNZbUlDRW9kR2hwY3lCcGJuTjBZVzVqWlc5bUlFUjFjR3hsZUNrcFhHNGdJQ0FnY21WMGRYSnVJRzVsZHlCWGNtbDBZV0pzWlNodmNIUnBiMjV6S1R0Y2JseHVJQ0IwYUdsekxsOTNjbWwwWVdKc1pWTjBZWFJsSUQwZ2JtVjNJRmR5YVhSaFlteGxVM1JoZEdVb2IzQjBhVzl1Y3l3Z2RHaHBjeWs3WEc1Y2JpQWdMeThnYkdWbllXTjVMbHh1SUNCMGFHbHpMbmR5YVhSaFlteGxJRDBnZEhKMVpUdGNibHh1SUNCVGRISmxZVzB1WTJGc2JDaDBhR2x6S1R0Y2JuMWNibHh1THk4Z1QzUm9aWEozYVhObElIQmxiM0JzWlNCallXNGdjR2x3WlNCWGNtbDBZV0pzWlNCemRISmxZVzF6TENCM2FHbGphQ0JwY3lCcWRYTjBJSGR5YjI1bkxseHVWM0pwZEdGaWJHVXVjSEp2ZEc5MGVYQmxMbkJwY0dVZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ2RHaHBjeTVsYldsMEtDZGxjbkp2Y2ljc0lHNWxkeUJGY25KdmNpZ25RMkZ1Ym05MElIQnBjR1V1SUU1dmRDQnlaV0ZrWVdKc1pTNG5LU2s3WEc1OU8xeHVYRzVjYm1aMWJtTjBhVzl1SUhkeWFYUmxRV1owWlhKRmJtUW9jM1J5WldGdExDQnpkR0YwWlN3Z1kySXBJSHRjYmlBZ2RtRnlJR1Z5SUQwZ2JtVjNJRVZ5Y205eUtDZDNjbWwwWlNCaFpuUmxjaUJsYm1RbktUdGNiaUFnTHk4Z1ZFOUVUem9nWkdWbVpYSWdaWEp5YjNJZ1pYWmxiblJ6SUdOdmJuTnBjM1JsYm5Sc2VTQmxkbVZ5ZVhkb1pYSmxMQ0J1YjNRZ2FuVnpkQ0IwYUdVZ1kySmNiaUFnYzNSeVpXRnRMbVZ0YVhRb0oyVnljbTl5Snl3Z1pYSXBPMXh1SUNCd2NtOWpaWE56TG01bGVIUlVhV05yS0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUdOaUtHVnlLVHRjYmlBZ2ZTazdYRzU5WEc1Y2JpOHZJRWxtSUhkbElHZGxkQ0J6YjIxbGRHaHBibWNnZEdoaGRDQnBjeUJ1YjNRZ1lTQmlkV1ptWlhJc0lITjBjbWx1Wnl3Z2JuVnNiQ3dnYjNJZ2RXNWtaV1pwYm1Wa0xGeHVMeThnWVc1a0lIZGxKM0psSUc1dmRDQnBiaUJ2WW1wbFkzUk5iMlJsTENCMGFHVnVJSFJvWVhRbmN5QmhiaUJsY25KdmNpNWNiaTh2SUU5MGFHVnlkMmx6WlNCemRISmxZVzBnWTJoMWJtdHpJR0Z5WlNCaGJHd2dZMjl1YzJsa1pYSmxaQ0IwYnlCaVpTQnZaaUJzWlc1bmRHZzlNU3dnWVc1a0lIUm9aVnh1THk4Z2QyRjBaWEp0WVhKcmN5QmtaWFJsY20xcGJtVWdhRzkzSUcxaGJua2diMkpxWldOMGN5QjBieUJyWldWd0lHbHVJSFJvWlNCaWRXWm1aWElzSUhKaGRHaGxjaUIwYUdGdVhHNHZMeUJvYjNjZ2JXRnVlU0JpZVhSbGN5QnZjaUJqYUdGeVlXTjBaWEp6TGx4dVpuVnVZM1JwYjI0Z2RtRnNhV1JEYUhWdWF5aHpkSEpsWVcwc0lITjBZWFJsTENCamFIVnVheXdnWTJJcElIdGNiaUFnZG1GeUlIWmhiR2xrSUQwZ2RISjFaVHRjYmlBZ2FXWWdLQ0YxZEdsc0xtbHpRblZtWm1WeUtHTm9kVzVyS1NBbUpseHVJQ0FnSUNBZ0lYVjBhV3d1YVhOVGRISnBibWNvWTJoMWJtc3BJQ1ltWEc0Z0lDQWdJQ0FoZFhScGJDNXBjMDUxYkd4UGNsVnVaR1ZtYVc1bFpDaGphSFZ1YXlrZ0ppWmNiaUFnSUNBZ0lDRnpkR0YwWlM1dlltcGxZM1JOYjJSbEtTQjdYRzRnSUNBZ2RtRnlJR1Z5SUQwZ2JtVjNJRlI1Y0dWRmNuSnZjaWduU1c1MllXeHBaQ0J1YjI0dGMzUnlhVzVuTDJKMVptWmxjaUJqYUhWdWF5Y3BPMXh1SUNBZ0lITjBjbVZoYlM1bGJXbDBLQ2RsY25KdmNpY3NJR1Z5S1R0Y2JpQWdJQ0J3Y205alpYTnpMbTVsZUhSVWFXTnJLR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnWTJJb1pYSXBPMXh1SUNBZ0lIMHBPMXh1SUNBZ0lIWmhiR2xrSUQwZ1ptRnNjMlU3WEc0Z0lIMWNiaUFnY21WMGRYSnVJSFpoYkdsa08xeHVmVnh1WEc1WGNtbDBZV0pzWlM1d2NtOTBiM1I1Y0dVdWQzSnBkR1VnUFNCbWRXNWpkR2x2YmloamFIVnVheXdnWlc1amIyUnBibWNzSUdOaUtTQjdYRzRnSUhaaGNpQnpkR0YwWlNBOUlIUm9hWE11WDNkeWFYUmhZbXhsVTNSaGRHVTdYRzRnSUhaaGNpQnlaWFFnUFNCbVlXeHpaVHRjYmx4dUlDQnBaaUFvZFhScGJDNXBjMFoxYm1OMGFXOXVLR1Z1WTI5a2FXNW5LU2tnZTF4dUlDQWdJR05pSUQwZ1pXNWpiMlJwYm1jN1hHNGdJQ0FnWlc1amIyUnBibWNnUFNCdWRXeHNPMXh1SUNCOVhHNWNiaUFnYVdZZ0tIVjBhV3d1YVhOQ2RXWm1aWElvWTJoMWJtc3BLVnh1SUNBZ0lHVnVZMjlrYVc1bklEMGdKMkoxWm1abGNpYzdYRzRnSUdWc2MyVWdhV1lnS0NGbGJtTnZaR2x1WnlsY2JpQWdJQ0JsYm1OdlpHbHVaeUE5SUhOMFlYUmxMbVJsWm1GMWJIUkZibU52WkdsdVp6dGNibHh1SUNCcFppQW9JWFYwYVd3dWFYTkdkVzVqZEdsdmJpaGpZaWtwWEc0Z0lDQWdZMklnUFNCbWRXNWpkR2x2YmlncElIdDlPMXh1WEc0Z0lHbG1JQ2h6ZEdGMFpTNWxibVJsWkNsY2JpQWdJQ0IzY21sMFpVRm1kR1Z5Ulc1a0tIUm9hWE1zSUhOMFlYUmxMQ0JqWWlrN1hHNGdJR1ZzYzJVZ2FXWWdLSFpoYkdsa1EyaDFibXNvZEdocGN5d2djM1JoZEdVc0lHTm9kVzVyTENCallpa3BJSHRjYmlBZ0lDQnpkR0YwWlM1d1pXNWthVzVuWTJJckt6dGNiaUFnSUNCeVpYUWdQU0IzY21sMFpVOXlRblZtWm1WeUtIUm9hWE1zSUhOMFlYUmxMQ0JqYUhWdWF5d2daVzVqYjJScGJtY3NJR05pS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5TzF4dVhHNVhjbWwwWVdKc1pTNXdjbTkwYjNSNWNHVXVZMjl5YXlBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNCMllYSWdjM1JoZEdVZ1BTQjBhR2x6TGw5M2NtbDBZV0pzWlZOMFlYUmxPMXh1WEc0Z0lITjBZWFJsTG1OdmNtdGxaQ3NyTzF4dWZUdGNibHh1VjNKcGRHRmliR1V1Y0hKdmRHOTBlWEJsTG5WdVkyOXlheUE5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDkzY21sMFlXSnNaVk4wWVhSbE8xeHVYRzRnSUdsbUlDaHpkR0YwWlM1amIzSnJaV1FwSUh0Y2JpQWdJQ0J6ZEdGMFpTNWpiM0pyWldRdExUdGNibHh1SUNBZ0lHbG1JQ2doYzNSaGRHVXVkM0pwZEdsdVp5QW1KbHh1SUNBZ0lDQWdJQ0FoYzNSaGRHVXVZMjl5YTJWa0lDWW1YRzRnSUNBZ0lDQWdJQ0Z6ZEdGMFpTNW1hVzVwYzJobFpDQW1KbHh1SUNBZ0lDQWdJQ0FoYzNSaGRHVXVZblZtWm1WeVVISnZZMlZ6YzJsdVp5QW1KbHh1SUNBZ0lDQWdJQ0J6ZEdGMFpTNWlkV1ptWlhJdWJHVnVaM1JvS1Z4dUlDQWdJQ0FnWTJ4bFlYSkNkV1ptWlhJb2RHaHBjeXdnYzNSaGRHVXBPMXh1SUNCOVhHNTlPMXh1WEc1bWRXNWpkR2x2YmlCa1pXTnZaR1ZEYUhWdWF5aHpkR0YwWlN3Z1kyaDFibXNzSUdWdVkyOWthVzVuS1NCN1hHNGdJR2xtSUNnaGMzUmhkR1V1YjJKcVpXTjBUVzlrWlNBbUpseHVJQ0FnSUNBZ2MzUmhkR1V1WkdWamIyUmxVM1J5YVc1bmN5QWhQVDBnWm1Gc2MyVWdKaVpjYmlBZ0lDQWdJSFYwYVd3dWFYTlRkSEpwYm1jb1kyaDFibXNwS1NCN1hHNGdJQ0FnWTJoMWJtc2dQU0J1WlhjZ1FuVm1abVZ5S0dOb2RXNXJMQ0JsYm1OdlpHbHVaeWs3WEc0Z0lIMWNiaUFnY21WMGRYSnVJR05vZFc1ck8xeHVmVnh1WEc0dkx5QnBaaUIzWlNkeVpTQmhiSEpsWVdSNUlIZHlhWFJwYm1jZ2MyOXRaWFJvYVc1bkxDQjBhR1Z1SUdwMWMzUWdjSFYwSUhSb2FYTmNiaTh2SUdsdUlIUm9aU0J4ZFdWMVpTd2dZVzVrSUhkaGFYUWdiM1Z5SUhSMWNtNHVJQ0JQZEdobGNuZHBjMlVzSUdOaGJHd2dYM2R5YVhSbFhHNHZMeUJKWmlCM1pTQnlaWFIxY200Z1ptRnNjMlVzSUhSb1pXNGdkMlVnYm1WbFpDQmhJR1J5WVdsdUlHVjJaVzUwTENCemJ5QnpaWFFnZEdoaGRDQm1iR0ZuTGx4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZQY2tKMVptWmxjaWh6ZEhKbFlXMHNJSE4wWVhSbExDQmphSFZ1YXl3Z1pXNWpiMlJwYm1jc0lHTmlLU0I3WEc0Z0lHTm9kVzVySUQwZ1pHVmpiMlJsUTJoMWJtc29jM1JoZEdVc0lHTm9kVzVyTENCbGJtTnZaR2x1WnlrN1hHNGdJR2xtSUNoMWRHbHNMbWx6UW5WbVptVnlLR05vZFc1cktTbGNiaUFnSUNCbGJtTnZaR2x1WnlBOUlDZGlkV1ptWlhJbk8xeHVJQ0IyWVhJZ2JHVnVJRDBnYzNSaGRHVXViMkpxWldOMFRXOWtaU0EvSURFZ09pQmphSFZ1YXk1c1pXNW5kR2c3WEc1Y2JpQWdjM1JoZEdVdWJHVnVaM1JvSUNzOUlHeGxianRjYmx4dUlDQjJZWElnY21WMElEMGdjM1JoZEdVdWJHVnVaM1JvSUR3Z2MzUmhkR1V1YUdsbmFGZGhkR1Z5VFdGeWF6dGNiaUFnTHk4Z2QyVWdiWFZ6ZENCbGJuTjFjbVVnZEdoaGRDQndjbVYyYVc5MWN5QnVaV1ZrUkhKaGFXNGdkMmxzYkNCdWIzUWdZbVVnY21WelpYUWdkRzhnWm1Gc2MyVXVYRzRnSUdsbUlDZ2hjbVYwS1Z4dUlDQWdJSE4wWVhSbExtNWxaV1JFY21GcGJpQTlJSFJ5ZFdVN1hHNWNiaUFnYVdZZ0tITjBZWFJsTG5keWFYUnBibWNnZkh3Z2MzUmhkR1V1WTI5eWEyVmtLVnh1SUNBZ0lITjBZWFJsTG1KMVptWmxjaTV3ZFhOb0tHNWxkeUJYY21sMFpWSmxjU2hqYUhWdWF5d2daVzVqYjJScGJtY3NJR05pS1NrN1hHNGdJR1ZzYzJWY2JpQWdJQ0JrYjFkeWFYUmxLSE4wY21WaGJTd2djM1JoZEdVc0lHWmhiSE5sTENCc1pXNHNJR05vZFc1ckxDQmxibU52WkdsdVp5d2dZMklwTzF4dVhHNGdJSEpsZEhWeWJpQnlaWFE3WEc1OVhHNWNibVoxYm1OMGFXOXVJR1J2VjNKcGRHVW9jM1J5WldGdExDQnpkR0YwWlN3Z2QzSnBkR1YyTENCc1pXNHNJR05vZFc1ckxDQmxibU52WkdsdVp5d2dZMklwSUh0Y2JpQWdjM1JoZEdVdWQzSnBkR1ZzWlc0Z1BTQnNaVzQ3WEc0Z0lITjBZWFJsTG5keWFYUmxZMklnUFNCallqdGNiaUFnYzNSaGRHVXVkM0pwZEdsdVp5QTlJSFJ5ZFdVN1hHNGdJSE4wWVhSbExuTjVibU1nUFNCMGNuVmxPMXh1SUNCcFppQW9kM0pwZEdWMktWeHVJQ0FnSUhOMGNtVmhiUzVmZDNKcGRHVjJLR05vZFc1ckxDQnpkR0YwWlM1dmJuZHlhWFJsS1R0Y2JpQWdaV3h6WlZ4dUlDQWdJSE4wY21WaGJTNWZkM0pwZEdVb1kyaDFibXNzSUdWdVkyOWthVzVuTENCemRHRjBaUzV2Ym5keWFYUmxLVHRjYmlBZ2MzUmhkR1V1YzNsdVl5QTlJR1poYkhObE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCdmJuZHlhWFJsUlhKeWIzSW9jM1J5WldGdExDQnpkR0YwWlN3Z2MzbHVZeXdnWlhJc0lHTmlLU0I3WEc0Z0lHbG1JQ2h6ZVc1aktWeHVJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzV3Wlc1a2FXNW5ZMkl0TFR0Y2JpQWdJQ0FnSUdOaUtHVnlLVHRjYmlBZ0lDQjlLVHRjYmlBZ1pXeHpaU0I3WEc0Z0lDQWdjM1JoZEdVdWNHVnVaR2x1WjJOaUxTMDdYRzRnSUNBZ1kySW9aWElwTzF4dUlDQjlYRzVjYmlBZ2MzUnlaV0Z0TGw5M2NtbDBZV0pzWlZOMFlYUmxMbVZ5Y205eVJXMXBkSFJsWkNBOUlIUnlkV1U3WEc0Z0lITjBjbVZoYlM1bGJXbDBLQ2RsY25KdmNpY3NJR1Z5S1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYjI1M2NtbDBaVk4wWVhSbFZYQmtZWFJsS0hOMFlYUmxLU0I3WEc0Z0lITjBZWFJsTG5keWFYUnBibWNnUFNCbVlXeHpaVHRjYmlBZ2MzUmhkR1V1ZDNKcGRHVmpZaUE5SUc1MWJHdzdYRzRnSUhOMFlYUmxMbXhsYm1kMGFDQXRQU0J6ZEdGMFpTNTNjbWwwWld4bGJqdGNiaUFnYzNSaGRHVXVkM0pwZEdWc1pXNGdQU0F3TzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ2Ym5keWFYUmxLSE4wY21WaGJTd2daWElwSUh0Y2JpQWdkbUZ5SUhOMFlYUmxJRDBnYzNSeVpXRnRMbDkzY21sMFlXSnNaVk4wWVhSbE8xeHVJQ0IyWVhJZ2MzbHVZeUE5SUhOMFlYUmxMbk41Ym1NN1hHNGdJSFpoY2lCallpQTlJSE4wWVhSbExuZHlhWFJsWTJJN1hHNWNiaUFnYjI1M2NtbDBaVk4wWVhSbFZYQmtZWFJsS0hOMFlYUmxLVHRjYmx4dUlDQnBaaUFvWlhJcFhHNGdJQ0FnYjI1M2NtbDBaVVZ5Y205eUtITjBjbVZoYlN3Z2MzUmhkR1VzSUhONWJtTXNJR1Z5TENCallpazdYRzRnSUdWc2MyVWdlMXh1SUNBZ0lDOHZJRU5vWldOcklHbG1JSGRsSjNKbElHRmpkSFZoYkd4NUlISmxZV1I1SUhSdklHWnBibWx6YUN3Z1luVjBJR1J2YmlkMElHVnRhWFFnZVdWMFhHNGdJQ0FnZG1GeUlHWnBibWx6YUdWa0lEMGdibVZsWkVacGJtbHphQ2h6ZEhKbFlXMHNJSE4wWVhSbEtUdGNibHh1SUNBZ0lHbG1JQ2doWm1sdWFYTm9aV1FnSmlaY2JpQWdJQ0FnSUNBZ0lYTjBZWFJsTG1OdmNtdGxaQ0FtSmx4dUlDQWdJQ0FnSUNBaGMzUmhkR1V1WW5WbVptVnlVSEp2WTJWemMybHVaeUFtSmx4dUlDQWdJQ0FnSUNCemRHRjBaUzVpZFdabVpYSXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQmpiR1ZoY2tKMVptWmxjaWh6ZEhKbFlXMHNJSE4wWVhSbEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9jM2x1WXlrZ2UxeHVJQ0FnSUNBZ2NISnZZMlZ6Y3k1dVpYaDBWR2xqYXlobWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdZV1owWlhKWGNtbDBaU2h6ZEhKbFlXMHNJSE4wWVhSbExDQm1hVzVwYzJobFpDd2dZMklwTzF4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR0ZtZEdWeVYzSnBkR1VvYzNSeVpXRnRMQ0J6ZEdGMFpTd2dabWx1YVhOb1pXUXNJR05pS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1lXWjBaWEpYY21sMFpTaHpkSEpsWVcwc0lITjBZWFJsTENCbWFXNXBjMmhsWkN3Z1kySXBJSHRjYmlBZ2FXWWdLQ0ZtYVc1cGMyaGxaQ2xjYmlBZ0lDQnZibmR5YVhSbFJISmhhVzRvYzNSeVpXRnRMQ0J6ZEdGMFpTazdYRzRnSUhOMFlYUmxMbkJsYm1ScGJtZGpZaTB0TzF4dUlDQmpZaWdwTzF4dUlDQm1hVzVwYzJoTllYbGlaU2h6ZEhKbFlXMHNJSE4wWVhSbEtUdGNibjFjYmx4dUx5OGdUWFZ6ZENCbWIzSmpaU0JqWVd4c1ltRmpheUIwYnlCaVpTQmpZV3hzWldRZ2IyNGdibVY0ZEZScFkyc3NJSE52SUhSb1lYUWdkMlVnWkc5dUozUmNiaTh2SUdWdGFYUWdKMlJ5WVdsdUp5QmlaV1p2Y21VZ2RHaGxJSGR5YVhSbEtDa2dZMjl1YzNWdFpYSWdaMlYwY3lCMGFHVWdKMlpoYkhObEp5QnlaWFIxY201Y2JpOHZJSFpoYkhWbExDQmhibVFnYUdGeklHRWdZMmhoYm1ObElIUnZJR0YwZEdGamFDQmhJQ2RrY21GcGJpY2diR2x6ZEdWdVpYSXVYRzVtZFc1amRHbHZiaUJ2Ym5keWFYUmxSSEpoYVc0b2MzUnlaV0Z0TENCemRHRjBaU2tnZTF4dUlDQnBaaUFvYzNSaGRHVXViR1Z1WjNSb0lEMDlQU0F3SUNZbUlITjBZWFJsTG01bFpXUkVjbUZwYmlrZ2UxeHVJQ0FnSUhOMFlYUmxMbTVsWldSRWNtRnBiaUE5SUdaaGJITmxPMXh1SUNBZ0lITjBjbVZoYlM1bGJXbDBLQ2RrY21GcGJpY3BPMXh1SUNCOVhHNTlYRzVjYmx4dUx5OGdhV1lnZEdobGNtVW5jeUJ6YjIxbGRHaHBibWNnYVc0Z2RHaGxJR0oxWm1abGNpQjNZV2wwYVc1bkxDQjBhR1Z1SUhCeWIyTmxjM01nYVhSY2JtWjFibU4wYVc5dUlHTnNaV0Z5UW5WbVptVnlLSE4wY21WaGJTd2djM1JoZEdVcElIdGNiaUFnYzNSaGRHVXVZblZtWm1WeVVISnZZMlZ6YzJsdVp5QTlJSFJ5ZFdVN1hHNWNiaUFnYVdZZ0tITjBjbVZoYlM1ZmQzSnBkR1YySUNZbUlITjBZWFJsTG1KMVptWmxjaTVzWlc1bmRHZ2dQaUF4S1NCN1hHNGdJQ0FnTHk4Z1JtRnpkQ0JqWVhObExDQjNjbWwwWlNCbGRtVnllWFJvYVc1bklIVnphVzVuSUY5M2NtbDBaWFlvS1Z4dUlDQWdJSFpoY2lCalluTWdQU0JiWFR0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJqSUQwZ01Ec2dZeUE4SUhOMFlYUmxMbUoxWm1abGNpNXNaVzVuZEdnN0lHTXJLeWxjYmlBZ0lDQWdJR05pY3k1d2RYTm9LSE4wWVhSbExtSjFabVpsY2x0alhTNWpZV3hzWW1GamF5azdYRzVjYmlBZ0lDQXZMeUJqYjNWdWRDQjBhR1VnYjI1bElIZGxJR0Z5WlNCaFpHUnBibWNzSUdGeklIZGxiR3d1WEc0Z0lDQWdMeThnVkU5RVR5aHBjMkZoWTNNcElHTnNaV0Z1SUhSb2FYTWdkWEJjYmlBZ0lDQnpkR0YwWlM1d1pXNWthVzVuWTJJckt6dGNiaUFnSUNCa2IxZHlhWFJsS0hOMGNtVmhiU3dnYzNSaGRHVXNJSFJ5ZFdVc0lITjBZWFJsTG14bGJtZDBhQ3dnYzNSaGRHVXVZblZtWm1WeUxDQW5KeXdnWm5WdVkzUnBiMjRvWlhKeUtTQjdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05pY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0J6ZEdGMFpTNXdaVzVrYVc1blkySXRMVHRjYmlBZ0lDQWdJQ0FnWTJKelcybGRLR1Z5Y2lrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNrN1hHNWNiaUFnSUNBdkx5QkRiR1ZoY2lCaWRXWm1aWEpjYmlBZ0lDQnpkR0YwWlM1aWRXWm1aWElnUFNCYlhUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQXZMeUJUYkc5M0lHTmhjMlVzSUhkeWFYUmxJR05vZFc1cmN5QnZibVV0WW5rdGIyNWxYRzRnSUNBZ1ptOXlJQ2gyWVhJZ1l5QTlJREE3SUdNZ1BDQnpkR0YwWlM1aWRXWm1aWEl1YkdWdVozUm9PeUJqS3lzcElIdGNiaUFnSUNBZ0lIWmhjaUJsYm5SeWVTQTlJSE4wWVhSbExtSjFabVpsY2x0alhUdGNiaUFnSUNBZ0lIWmhjaUJqYUhWdWF5QTlJR1Z1ZEhKNUxtTm9kVzVyTzF4dUlDQWdJQ0FnZG1GeUlHVnVZMjlrYVc1bklEMGdaVzUwY25rdVpXNWpiMlJwYm1jN1hHNGdJQ0FnSUNCMllYSWdZMklnUFNCbGJuUnllUzVqWVd4c1ltRmphenRjYmlBZ0lDQWdJSFpoY2lCc1pXNGdQU0J6ZEdGMFpTNXZZbXBsWTNSTmIyUmxJRDhnTVNBNklHTm9kVzVyTG14bGJtZDBhRHRjYmx4dUlDQWdJQ0FnWkc5WGNtbDBaU2h6ZEhKbFlXMHNJSE4wWVhSbExDQm1ZV3h6WlN3Z2JHVnVMQ0JqYUhWdWF5d2daVzVqYjJScGJtY3NJR05pS1R0Y2JseHVJQ0FnSUNBZ0x5OGdhV1lnZDJVZ1pHbGtiaWQwSUdOaGJHd2dkR2hsSUc5dWQzSnBkR1VnYVcxdFpXUnBZWFJsYkhrc0lIUm9aVzVjYmlBZ0lDQWdJQzh2SUdsMElHMWxZVzV6SUhSb1lYUWdkMlVnYm1WbFpDQjBieUIzWVdsMElIVnVkR2xzSUdsMElHUnZaWE11WEc0Z0lDQWdJQ0F2THlCaGJITnZMQ0IwYUdGMElHMWxZVzV6SUhSb1lYUWdkR2hsSUdOb2RXNXJJR0Z1WkNCallpQmhjbVVnWTNWeWNtVnVkR3g1WEc0Z0lDQWdJQ0F2THlCaVpXbHVaeUJ3Y205alpYTnpaV1FzSUhOdklHMXZkbVVnZEdobElHSjFabVpsY2lCamIzVnVkR1Z5SUhCaGMzUWdkR2hsYlM1Y2JpQWdJQ0FnSUdsbUlDaHpkR0YwWlM1M2NtbDBhVzVuS1NCN1hHNGdJQ0FnSUNBZ0lHTXJLenRjYmlBZ0lDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLR01nUENCemRHRjBaUzVpZFdabVpYSXViR1Z1WjNSb0tWeHVJQ0FnSUNBZ2MzUmhkR1V1WW5WbVptVnlJRDBnYzNSaGRHVXVZblZtWm1WeUxuTnNhV05sS0dNcE8xeHVJQ0FnSUdWc2MyVmNiaUFnSUNBZ0lITjBZWFJsTG1KMVptWmxjaTVzWlc1bmRHZ2dQU0F3TzF4dUlDQjlYRzVjYmlBZ2MzUmhkR1V1WW5WbVptVnlVSEp2WTJWemMybHVaeUE5SUdaaGJITmxPMXh1ZlZ4dVhHNVhjbWwwWVdKc1pTNXdjbTkwYjNSNWNHVXVYM2R5YVhSbElEMGdablZ1WTNScGIyNG9ZMmgxYm1zc0lHVnVZMjlrYVc1bkxDQmpZaWtnZTF4dUlDQmpZaWh1WlhjZ1JYSnliM0lvSjI1dmRDQnBiWEJzWlcxbGJuUmxaQ2NwS1R0Y2JseHVmVHRjYmx4dVYzSnBkR0ZpYkdVdWNISnZkRzkwZVhCbExsOTNjbWwwWlhZZ1BTQnVkV3hzTzF4dVhHNVhjbWwwWVdKc1pTNXdjbTkwYjNSNWNHVXVaVzVrSUQwZ1puVnVZM1JwYjI0b1kyaDFibXNzSUdWdVkyOWthVzVuTENCallpa2dlMXh1SUNCMllYSWdjM1JoZEdVZ1BTQjBhR2x6TGw5M2NtbDBZV0pzWlZOMFlYUmxPMXh1WEc0Z0lHbG1JQ2gxZEdsc0xtbHpSblZ1WTNScGIyNG9ZMmgxYm1zcEtTQjdYRzRnSUNBZ1kySWdQU0JqYUhWdWF6dGNiaUFnSUNCamFIVnVheUE5SUc1MWJHdzdYRzRnSUNBZ1pXNWpiMlJwYm1jZ1BTQnVkV3hzTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSFYwYVd3dWFYTkdkVzVqZEdsdmJpaGxibU52WkdsdVp5a3BJSHRjYmlBZ0lDQmpZaUE5SUdWdVkyOWthVzVuTzF4dUlDQWdJR1Z1WTI5a2FXNW5JRDBnYm5Wc2JEdGNiaUFnZlZ4dVhHNGdJR2xtSUNnaGRYUnBiQzVwYzA1MWJHeFBjbFZ1WkdWbWFXNWxaQ2hqYUhWdWF5a3BYRzRnSUNBZ2RHaHBjeTUzY21sMFpTaGphSFZ1YXl3Z1pXNWpiMlJwYm1jcE8xeHVYRzRnSUM4dklDNWxibVFvS1NCbWRXeHNlU0IxYm1OdmNtdHpYRzRnSUdsbUlDaHpkR0YwWlM1amIzSnJaV1FwSUh0Y2JpQWdJQ0J6ZEdGMFpTNWpiM0pyWldRZ1BTQXhPMXh1SUNBZ0lIUm9hWE11ZFc1amIzSnJLQ2s3WEc0Z0lIMWNibHh1SUNBdkx5QnBaMjV2Y21VZ2RXNXVaV05sYzNOaGNua2daVzVrS0NrZ1kyRnNiSE11WEc0Z0lHbG1JQ2doYzNSaGRHVXVaVzVrYVc1bklDWW1JQ0Z6ZEdGMFpTNW1hVzVwYzJobFpDbGNiaUFnSUNCbGJtUlhjbWwwWVdKc1pTaDBhR2x6TENCemRHRjBaU3dnWTJJcE8xeHVmVHRjYmx4dVhHNW1kVzVqZEdsdmJpQnVaV1ZrUm1sdWFYTm9LSE4wY21WaGJTd2djM1JoZEdVcElIdGNiaUFnY21WMGRYSnVJQ2h6ZEdGMFpTNWxibVJwYm1jZ0ppWmNiaUFnSUNBZ0lDQWdJQ0J6ZEdGMFpTNXNaVzVuZEdnZ1BUMDlJREFnSmlaY2JpQWdJQ0FnSUNBZ0lDQWhjM1JoZEdVdVptbHVhWE5vWldRZ0ppWmNiaUFnSUNBZ0lDQWdJQ0FoYzNSaGRHVXVkM0pwZEdsdVp5azdYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQnlaV1pwYm1semFDaHpkSEpsWVcwc0lITjBZWFJsS1NCN1hHNGdJR2xtSUNnaGMzUmhkR1V1Y0hKbFptbHVhWE5vWldRcElIdGNiaUFnSUNCemRHRjBaUzV3Y21WbWFXNXBjMmhsWkNBOUlIUnlkV1U3WEc0Z0lDQWdjM1J5WldGdExtVnRhWFFvSjNCeVpXWnBibWx6YUNjcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1pwYm1semFFMWhlV0psS0hOMGNtVmhiU3dnYzNSaGRHVXBJSHRjYmlBZ2RtRnlJRzVsWldRZ1BTQnVaV1ZrUm1sdWFYTm9LSE4wY21WaGJTd2djM1JoZEdVcE8xeHVJQ0JwWmlBb2JtVmxaQ2tnZTF4dUlDQWdJR2xtSUNoemRHRjBaUzV3Wlc1a2FXNW5ZMklnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJSEJ5WldacGJtbHphQ2h6ZEhKbFlXMHNJSE4wWVhSbEtUdGNiaUFnSUNBZ0lITjBZWFJsTG1acGJtbHphR1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSE4wY21WaGJTNWxiV2wwS0NkbWFXNXBjMmduS1R0Y2JpQWdJQ0I5SUdWc2MyVmNiaUFnSUNBZ0lIQnlaV1pwYm1semFDaHpkSEpsWVcwc0lITjBZWFJsS1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnYm1WbFpEdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1pXNWtWM0pwZEdGaWJHVW9jM1J5WldGdExDQnpkR0YwWlN3Z1kySXBJSHRjYmlBZ2MzUmhkR1V1Wlc1a2FXNW5JRDBnZEhKMVpUdGNiaUFnWm1sdWFYTm9UV0Y1WW1Vb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc0Z0lHbG1JQ2hqWWlrZ2UxeHVJQ0FnSUdsbUlDaHpkR0YwWlM1bWFXNXBjMmhsWkNsY2JpQWdJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWTJJcE8xeHVJQ0FnSUdWc2MyVmNiaUFnSUNBZ0lITjBjbVZoYlM1dmJtTmxLQ2RtYVc1cGMyZ25MQ0JqWWlrN1hHNGdJSDFjYmlBZ2MzUmhkR1V1Wlc1a1pXUWdQU0IwY25WbE8xeHVmVnh1SWwxOSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OXlaV0ZrWVdKc1pTMXpkSEpsWVcwdmJHbGlMMTl6ZEhKbFlXMWZjbVZoWkdGaWJHVXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdkx5QkRiM0I1Y21sbmFIUWdTbTk1Wlc1MExDQkpibU11SUdGdVpDQnZkR2hsY2lCT2IyUmxJR052Ym5SeWFXSjFkRzl5Y3k1Y2JpOHZYRzR2THlCUVpYSnRhWE56YVc5dUlHbHpJR2hsY21WaWVTQm5jbUZ1ZEdWa0xDQm1jbVZsSUc5bUlHTm9ZWEpuWlN3Z2RHOGdZVzU1SUhCbGNuTnZiaUJ2WW5SaGFXNXBibWNnWVZ4dUx5OGdZMjl3ZVNCdlppQjBhR2x6SUhOdlpuUjNZWEpsSUdGdVpDQmhjM052WTJsaGRHVmtJR1J2WTNWdFpXNTBZWFJwYjI0Z1ptbHNaWE1nS0hSb1pWeHVMeThnWENKVGIyWjBkMkZ5WlZ3aUtTd2dkRzhnWkdWaGJDQnBiaUIwYUdVZ1UyOW1kSGRoY21VZ2QybDBhRzkxZENCeVpYTjBjbWxqZEdsdmJpd2dhVzVqYkhWa2FXNW5YRzR2THlCM2FYUm9iM1YwSUd4cGJXbDBZWFJwYjI0Z2RHaGxJSEpwWjJoMGN5QjBieUIxYzJVc0lHTnZjSGtzSUcxdlpHbG1lU3dnYldWeVoyVXNJSEIxWW14cGMyZ3NYRzR2THlCa2FYTjBjbWxpZFhSbExDQnpkV0pzYVdObGJuTmxMQ0JoYm1RdmIzSWdjMlZzYkNCamIzQnBaWE1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMQ0JoYm1RZ2RHOGdjR1Z5YldsMFhHNHZMeUJ3WlhKemIyNXpJSFJ2SUhkb2IyMGdkR2hsSUZOdlpuUjNZWEpsSUdseklHWjFjbTVwYzJobFpDQjBieUJrYnlCemJ5d2djM1ZpYW1WamRDQjBieUIwYUdWY2JpOHZJR1p2Ykd4dmQybHVaeUJqYjI1a2FYUnBiMjV6T2x4dUx5OWNiaTh2SUZSb1pTQmhZbTkyWlNCamIzQjVjbWxuYUhRZ2JtOTBhV05sSUdGdVpDQjBhR2x6SUhCbGNtMXBjM05wYjI0Z2JtOTBhV05sSUhOb1lXeHNJR0psSUdsdVkyeDFaR1ZrWEc0dkx5QnBiaUJoYkd3Z1kyOXdhV1Z6SUc5eUlITjFZbk4wWVc1MGFXRnNJSEJ2Y25ScGIyNXpJRzltSUhSb1pTQlRiMlowZDJGeVpTNWNiaTh2WEc0dkx5QlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRYRzR2THlCUFVpQkpUVkJNU1VWRUxDQkpUa05NVlVSSlRrY2dRbFZVSUU1UFZDQk1TVTFKVkVWRUlGUlBJRlJJUlNCWFFWSlNRVTVVU1VWVElFOUdYRzR2THlCTlJWSkRTRUZPVkVGQ1NVeEpWRmtzSUVaSlZFNUZVMU1nUms5U0lFRWdVRUZTVkVsRFZVeEJVaUJRVlZKUVQxTkZJRUZPUkNCT1QwNUpUa1pTU1U1SFJVMUZUbFF1SUVsT1hHNHZMeUJPVHlCRlZrVk9WQ0JUU0VGTVRDQlVTRVVnUVZWVVNFOVNVeUJQVWlCRFQxQlpVa2xIU0ZRZ1NFOU1SRVZTVXlCQ1JTQk1TVUZDVEVVZ1JrOVNJRUZPV1NCRFRFRkpUU3hjYmk4dklFUkJUVUZIUlZNZ1QxSWdUMVJJUlZJZ1RFbEJRa2xNU1ZSWkxDQlhTRVZVU0VWU0lFbE9JRUZPSUVGRFZFbFBUaUJQUmlCRFQwNVVVa0ZEVkN3Z1ZFOVNWQ0JQVWx4dUx5OGdUMVJJUlZKWFNWTkZMQ0JCVWtsVFNVNUhJRVpTVDAwc0lFOVZWQ0JQUmlCUFVpQkpUaUJEVDA1T1JVTlVTVTlPSUZkSlZFZ2dWRWhGSUZOUFJsUlhRVkpGSUU5U0lGUklSVnh1THk4Z1ZWTkZJRTlTSUU5VVNFVlNJRVJGUVV4SlRrZFRJRWxPSUZSSVJTQlRUMFpVVjBGU1JTNWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JTWldGa1lXSnNaVHRjYmx4dUx5bzhjbVZ3YkdGalpXMWxiblErS2k5Y2JuWmhjaUJwYzBGeWNtRjVJRDBnY21WeGRXbHlaU2duYVhOaGNuSmhlU2NwTzF4dUx5bzhMM0psY0d4aFkyVnRaVzUwUGlvdlhHNWNibHh1THlvOGNtVndiR0ZqWlcxbGJuUStLaTljYm5aaGNpQkNkV1ptWlhJZ1BTQnlaWEYxYVhKbEtDZGlkV1ptWlhJbktTNUNkV1ptWlhJN1hHNHZLand2Y21Wd2JHRmpaVzFsYm5RK0tpOWNibHh1VW1WaFpHRmliR1V1VW1WaFpHRmliR1ZUZEdGMFpTQTlJRkpsWVdSaFlteGxVM1JoZEdVN1hHNWNiblpoY2lCRlJTQTlJSEpsY1hWcGNtVW9KMlYyWlc1MGN5Y3BMa1YyWlc1MFJXMXBkSFJsY2p0Y2JseHVMeW84Y21Wd2JHRmpaVzFsYm5RK0tpOWNibWxtSUNnaFJVVXViR2x6ZEdWdVpYSkRiM1Z1ZENrZ1JVVXViR2x6ZEdWdVpYSkRiM1Z1ZENBOUlHWjFibU4wYVc5dUtHVnRhWFIwWlhJc0lIUjVjR1VwSUh0Y2JpQWdjbVYwZFhKdUlHVnRhWFIwWlhJdWJHbHpkR1Z1WlhKektIUjVjR1VwTG14bGJtZDBhRHRjYm4wN1hHNHZLand2Y21Wd2JHRmpaVzFsYm5RK0tpOWNibHh1ZG1GeUlGTjBjbVZoYlNBOUlISmxjWFZwY21Vb0ozTjBjbVZoYlNjcE8xeHVYRzR2S2p4eVpYQnNZV05sYldWdWRENHFMMXh1ZG1GeUlIVjBhV3dnUFNCeVpYRjFhWEpsS0NkamIzSmxMWFYwYVd3dGFYTW5LVHRjYm5WMGFXd3VhVzVvWlhKcGRITWdQU0J5WlhGMWFYSmxLQ2RwYm1obGNtbDBjeWNwTzF4dUx5bzhMM0psY0d4aFkyVnRaVzUwUGlvdlhHNWNiblpoY2lCVGRISnBibWRFWldOdlpHVnlPMXh1WEc1Y2JpOHFQSEpsY0d4aFkyVnRaVzUwUGlvdlhHNTJZWElnWkdWaWRXY2dQU0J5WlhGMWFYSmxLQ2QxZEdsc0p5azdYRzVwWmlBb1pHVmlkV2NnSmlZZ1pHVmlkV2N1WkdWaWRXZHNiMmNwSUh0Y2JpQWdaR1ZpZFdjZ1BTQmtaV0oxWnk1a1pXSjFaMnh2WnlnbmMzUnlaV0Z0SnlrN1hHNTlJR1ZzYzJVZ2UxeHVJQ0JrWldKMVp5QTlJR1oxYm1OMGFXOXVJQ2dwSUh0OU8xeHVmVnh1THlvOEwzSmxjR3hoWTJWdFpXNTBQaW92WEc1Y2JseHVkWFJwYkM1cGJtaGxjbWwwY3loU1pXRmtZV0pzWlN3Z1UzUnlaV0Z0S1R0Y2JseHVablZ1WTNScGIyNGdVbVZoWkdGaWJHVlRkR0YwWlNodmNIUnBiMjV6TENCemRISmxZVzBwSUh0Y2JpQWdkbUZ5SUVSMWNHeGxlQ0E5SUhKbGNYVnBjbVVvSnk0dlgzTjBjbVZoYlY5a2RYQnNaWGduS1R0Y2JseHVJQ0J2Y0hScGIyNXpJRDBnYjNCMGFXOXVjeUI4ZkNCN2ZUdGNibHh1SUNBdkx5QjBhR1VnY0c5cGJuUWdZWFFnZDJocFkyZ2dhWFFnYzNSdmNITWdZMkZzYkdsdVp5QmZjbVZoWkNncElIUnZJR1pwYkd3Z2RHaGxJR0oxWm1abGNseHVJQ0F2THlCT2IzUmxPaUF3SUdseklHRWdkbUZzYVdRZ2RtRnNkV1VzSUcxbFlXNXpJRndpWkc5dUozUWdZMkZzYkNCZmNtVmhaQ0J3Y21WbGJYQjBhWFpsYkhrZ1pYWmxjbHdpWEc0Z0lIWmhjaUJvZDIwZ1BTQnZjSFJwYjI1ekxtaHBaMmhYWVhSbGNrMWhjbXM3WEc0Z0lIWmhjaUJrWldaaGRXeDBTSGR0SUQwZ2IzQjBhVzl1Y3k1dlltcGxZM1JOYjJSbElEOGdNVFlnT2lBeE5pQXFJREV3TWpRN1hHNGdJSFJvYVhNdWFHbG5hRmRoZEdWeVRXRnlheUE5SUNob2QyMGdmSHdnYUhkdElEMDlQU0F3S1NBL0lHaDNiU0E2SUdSbFptRjFiSFJJZDIwN1hHNWNiaUFnTHk4Z1kyRnpkQ0IwYnlCcGJuUnpMbHh1SUNCMGFHbHpMbWhwWjJoWFlYUmxjazFoY21zZ1BTQitmblJvYVhNdWFHbG5hRmRoZEdWeVRXRnlhenRjYmx4dUlDQjBhR2x6TG1KMVptWmxjaUE5SUZ0ZE8xeHVJQ0IwYUdsekxteGxibWQwYUNBOUlEQTdYRzRnSUhSb2FYTXVjR2x3WlhNZ1BTQnVkV3hzTzF4dUlDQjBhR2x6TG5CcGNHVnpRMjkxYm5RZ1BTQXdPMXh1SUNCMGFHbHpMbVpzYjNkcGJtY2dQU0J1ZFd4c08xeHVJQ0IwYUdsekxtVnVaR1ZrSUQwZ1ptRnNjMlU3WEc0Z0lIUm9hWE11Wlc1a1JXMXBkSFJsWkNBOUlHWmhiSE5sTzF4dUlDQjBhR2x6TG5KbFlXUnBibWNnUFNCbVlXeHpaVHRjYmx4dUlDQXZMeUJoSUdac1lXY2dkRzhnWW1VZ1lXSnNaU0IwYnlCMFpXeHNJR2xtSUhSb1pTQnZibmR5YVhSbElHTmlJR2x6SUdOaGJHeGxaQ0JwYlcxbFpHbGhkR1ZzZVN4Y2JpQWdMeThnYjNJZ2IyNGdZU0JzWVhSbGNpQjBhV05yTGlBZ1YyVWdjMlYwSUhSb2FYTWdkRzhnZEhKMVpTQmhkQ0JtYVhKemRDd2dZbVZqWVhWelpTQmhibmxjYmlBZ0x5OGdZV04wYVc5dWN5QjBhR0YwSUhOb2IzVnNaRzRuZENCb1lYQndaVzRnZFc1MGFXd2dYQ0pzWVhSbGNsd2lJSE5vYjNWc1pDQm5aVzVsY21Gc2JIa2dZV3h6YjF4dUlDQXZMeUJ1YjNRZ2FHRndjR1Z1SUdKbFptOXlaU0IwYUdVZ1ptbHljM1FnZDNKcGRHVWdZMkZzYkM1Y2JpQWdkR2hwY3k1emVXNWpJRDBnZEhKMVpUdGNibHh1SUNBdkx5QjNhR1Z1WlhabGNpQjNaU0J5WlhSMWNtNGdiblZzYkN3Z2RHaGxiaUIzWlNCelpYUWdZU0JtYkdGbklIUnZJSE5oZVZ4dUlDQXZMeUIwYUdGMElIZGxKM0psSUdGM1lXbDBhVzVuSUdFZ0ozSmxZV1JoWW14bEp5QmxkbVZ1ZENCbGJXbHpjMmx2Ymk1Y2JpQWdkR2hwY3k1dVpXVmtVbVZoWkdGaWJHVWdQU0JtWVd4elpUdGNiaUFnZEdocGN5NWxiV2wwZEdWa1VtVmhaR0ZpYkdVZ1BTQm1ZV3h6WlR0Y2JpQWdkR2hwY3k1eVpXRmtZV0pzWlV4cGMzUmxibWx1WnlBOUlHWmhiSE5sTzF4dVhHNWNiaUFnTHk4Z2IySnFaV04wSUhOMGNtVmhiU0JtYkdGbkxpQlZjMlZrSUhSdklHMWhhMlVnY21WaFpDaHVLU0JwWjI1dmNtVWdiaUJoYm1RZ2RHOWNiaUFnTHk4Z2JXRnJaU0JoYkd3Z2RHaGxJR0oxWm1abGNpQnRaWEpuYVc1bklHRnVaQ0JzWlc1bmRHZ2dZMmhsWTJ0eklHZHZJR0YzWVhsY2JpQWdkR2hwY3k1dlltcGxZM1JOYjJSbElEMGdJU0Z2Y0hScGIyNXpMbTlpYW1WamRFMXZaR1U3WEc1Y2JpQWdhV1lnS0hOMGNtVmhiU0JwYm5OMFlXNWpaVzltSUVSMWNHeGxlQ2xjYmlBZ0lDQjBhR2x6TG05aWFtVmpkRTF2WkdVZ1BTQjBhR2x6TG05aWFtVmpkRTF2WkdVZ2ZId2dJU0Z2Y0hScGIyNXpMbkpsWVdSaFlteGxUMkpxWldOMFRXOWtaVHRjYmx4dUlDQXZMeUJEY25sd2RHOGdhWE1nYTJsdVpDQnZaaUJ2YkdRZ1lXNWtJR055ZFhOMGVTNGdJRWhwYzNSdmNtbGpZV3hzZVN3Z2FYUnpJR1JsWm1GMWJIUWdjM1J5YVc1blhHNGdJQzh2SUdWdVkyOWthVzVuSUdseklDZGlhVzVoY25rbklITnZJSGRsSUdoaGRtVWdkRzhnYldGclpTQjBhR2x6SUdOdmJtWnBaM1Z5WVdKc1pTNWNiaUFnTHk4Z1JYWmxjbmwwYUdsdVp5QmxiSE5sSUdsdUlIUm9aU0IxYm1sMlpYSnpaU0IxYzJWeklDZDFkR1k0Snl3Z2RHaHZkV2RvTGx4dUlDQjBhR2x6TG1SbFptRjFiSFJGYm1OdlpHbHVaeUE5SUc5d2RHbHZibk11WkdWbVlYVnNkRVZ1WTI5a2FXNW5JSHg4SUNkMWRHWTRKenRjYmx4dUlDQXZMeUIzYUdWdUlIQnBjR2x1Wnl3Z2QyVWdiMjVzZVNCallYSmxJR0ZpYjNWMElDZHlaV0ZrWVdKc1pTY2daWFpsYm5SeklIUm9ZWFFnYUdGd2NHVnVYRzRnSUM4dklHRm1kR1Z5SUhKbFlXUW9LV2x1WnlCaGJHd2dkR2hsSUdKNWRHVnpJR0Z1WkNCdWIzUWdaMlYwZEdsdVp5QmhibmtnY0hWemFHSmhZMnN1WEc0Z0lIUm9hWE11Y21GdVQzVjBJRDBnWm1Gc2MyVTdYRzVjYmlBZ0x5OGdkR2hsSUc1MWJXSmxjaUJ2WmlCM2NtbDBaWEp6SUhSb1lYUWdZWEpsSUdGM1lXbDBhVzVuSUdFZ1pISmhhVzRnWlhabGJuUWdhVzRnTG5CcGNHVW9LWE5jYmlBZ2RHaHBjeTVoZDJGcGRFUnlZV2x1SUQwZ01EdGNibHh1SUNBdkx5QnBaaUIwY25WbExDQmhJRzFoZVdKbFVtVmhaRTF2Y21VZ2FHRnpJR0psWlc0Z2MyTm9aV1IxYkdWa1hHNGdJSFJvYVhNdWNtVmhaR2x1WjAxdmNtVWdQU0JtWVd4elpUdGNibHh1SUNCMGFHbHpMbVJsWTI5a1pYSWdQU0J1ZFd4c08xeHVJQ0IwYUdsekxtVnVZMjlrYVc1bklEMGdiblZzYkR0Y2JpQWdhV1lnS0c5d2RHbHZibk11Wlc1amIyUnBibWNwSUh0Y2JpQWdJQ0JwWmlBb0lWTjBjbWx1WjBSbFkyOWtaWElwWEc0Z0lDQWdJQ0JUZEhKcGJtZEVaV052WkdWeUlEMGdjbVZ4ZFdseVpTZ25jM1J5YVc1blgyUmxZMjlrWlhJdkp5a3VVM1J5YVc1blJHVmpiMlJsY2p0Y2JpQWdJQ0IwYUdsekxtUmxZMjlrWlhJZ1BTQnVaWGNnVTNSeWFXNW5SR1ZqYjJSbGNpaHZjSFJwYjI1ekxtVnVZMjlrYVc1bktUdGNiaUFnSUNCMGFHbHpMbVZ1WTI5a2FXNW5JRDBnYjNCMGFXOXVjeTVsYm1OdlpHbHVaenRjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCU1pXRmtZV0pzWlNodmNIUnBiMjV6S1NCN1hHNGdJSFpoY2lCRWRYQnNaWGdnUFNCeVpYRjFhWEpsS0NjdUwxOXpkSEpsWVcxZlpIVndiR1Y0SnlrN1hHNWNiaUFnYVdZZ0tDRW9kR2hwY3lCcGJuTjBZVzVqWlc5bUlGSmxZV1JoWW14bEtTbGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGSmxZV1JoWW14bEtHOXdkR2x2Ym5NcE8xeHVYRzRnSUhSb2FYTXVYM0psWVdSaFlteGxVM1JoZEdVZ1BTQnVaWGNnVW1WaFpHRmliR1ZUZEdGMFpTaHZjSFJwYjI1ekxDQjBhR2x6S1R0Y2JseHVJQ0F2THlCc1pXZGhZM2xjYmlBZ2RHaHBjeTV5WldGa1lXSnNaU0E5SUhSeWRXVTdYRzVjYmlBZ1UzUnlaV0Z0TG1OaGJHd29kR2hwY3lrN1hHNTlYRzVjYmk4dklFMWhiblZoYkd4NUlITm9iM1psSUhOdmJXVjBhR2x1WnlCcGJuUnZJSFJvWlNCeVpXRmtLQ2tnWW5WbVptVnlMbHh1THk4Z1ZHaHBjeUJ5WlhSMWNtNXpJSFJ5ZFdVZ2FXWWdkR2hsSUdocFoyaFhZWFJsY2sxaGNtc2dhR0Z6SUc1dmRDQmlaV1Z1SUdocGRDQjVaWFFzWEc0dkx5QnphVzFwYkdGeUlIUnZJR2h2ZHlCWGNtbDBZV0pzWlM1M2NtbDBaU2dwSUhKbGRIVnlibk1nZEhKMVpTQnBaaUI1YjNVZ2MyaHZkV3hrWEc0dkx5QjNjbWwwWlNncElITnZiV1VnYlc5eVpTNWNibEpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV3ZFhOb0lEMGdablZ1WTNScGIyNG9ZMmgxYm1zc0lHVnVZMjlrYVc1bktTQjdYRzRnSUhaaGNpQnpkR0YwWlNBOUlIUm9hWE11WDNKbFlXUmhZbXhsVTNSaGRHVTdYRzVjYmlBZ2FXWWdLSFYwYVd3dWFYTlRkSEpwYm1jb1kyaDFibXNwSUNZbUlDRnpkR0YwWlM1dlltcGxZM1JOYjJSbEtTQjdYRzRnSUNBZ1pXNWpiMlJwYm1jZ1BTQmxibU52WkdsdVp5QjhmQ0J6ZEdGMFpTNWtaV1poZFd4MFJXNWpiMlJwYm1jN1hHNGdJQ0FnYVdZZ0tHVnVZMjlrYVc1bklDRTlQU0J6ZEdGMFpTNWxibU52WkdsdVp5a2dlMXh1SUNBZ0lDQWdZMmgxYm1zZ1BTQnVaWGNnUW5WbVptVnlLR05vZFc1ckxDQmxibU52WkdsdVp5azdYRzRnSUNBZ0lDQmxibU52WkdsdVp5QTlJQ2NuTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ5WldGa1lXSnNaVUZrWkVOb2RXNXJLSFJvYVhNc0lITjBZWFJsTENCamFIVnVheXdnWlc1amIyUnBibWNzSUdaaGJITmxLVHRjYm4wN1hHNWNiaTh2SUZWdWMyaHBablFnYzJodmRXeGtJQ3BoYkhkaGVYTXFJR0psSUhOdmJXVjBhR2x1WnlCa2FYSmxZM1JzZVNCdmRYUWdiMllnY21WaFpDZ3BYRzVTWldGa1lXSnNaUzV3Y205MGIzUjVjR1V1ZFc1emFHbG1kQ0E5SUdaMWJtTjBhVzl1S0dOb2RXNXJLU0I3WEc0Z0lIWmhjaUJ6ZEdGMFpTQTlJSFJvYVhNdVgzSmxZV1JoWW14bFUzUmhkR1U3WEc0Z0lISmxkSFZ5YmlCeVpXRmtZV0pzWlVGa1pFTm9kVzVyS0hSb2FYTXNJSE4wWVhSbExDQmphSFZ1YXl3Z0p5Y3NJSFJ5ZFdVcE8xeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2NtVmhaR0ZpYkdWQlpHUkRhSFZ1YXloemRISmxZVzBzSUhOMFlYUmxMQ0JqYUhWdWF5d2daVzVqYjJScGJtY3NJR0ZrWkZSdlJuSnZiblFwSUh0Y2JpQWdkbUZ5SUdWeUlEMGdZMmgxYm10SmJuWmhiR2xrS0hOMFlYUmxMQ0JqYUhWdWF5azdYRzRnSUdsbUlDaGxjaWtnZTF4dUlDQWdJSE4wY21WaGJTNWxiV2wwS0NkbGNuSnZjaWNzSUdWeUtUdGNiaUFnZlNCbGJITmxJR2xtSUNoMWRHbHNMbWx6VG5Wc2JFOXlWVzVrWldacGJtVmtLR05vZFc1cktTa2dlMXh1SUNBZ0lITjBZWFJsTG5KbFlXUnBibWNnUFNCbVlXeHpaVHRjYmlBZ0lDQnBaaUFvSVhOMFlYUmxMbVZ1WkdWa0tWeHVJQ0FnSUNBZ2IyNUZiMlpEYUhWdWF5aHpkSEpsWVcwc0lITjBZWFJsS1R0Y2JpQWdmU0JsYkhObElHbG1JQ2h6ZEdGMFpTNXZZbXBsWTNSTmIyUmxJSHg4SUdOb2RXNXJJQ1ltSUdOb2RXNXJMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0JwWmlBb2MzUmhkR1V1Wlc1a1pXUWdKaVlnSVdGa1pGUnZSbkp2Ym5RcElIdGNiaUFnSUNBZ0lIWmhjaUJsSUQwZ2JtVjNJRVZ5Y205eUtDZHpkSEpsWVcwdWNIVnphQ2dwSUdGbWRHVnlJRVZQUmljcE8xeHVJQ0FnSUNBZ2MzUnlaV0Z0TG1WdGFYUW9KMlZ5Y205eUp5d2daU2s3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h6ZEdGMFpTNWxibVJGYldsMGRHVmtJQ1ltSUdGa1pGUnZSbkp2Ym5RcElIdGNiaUFnSUNBZ0lIWmhjaUJsSUQwZ2JtVjNJRVZ5Y205eUtDZHpkSEpsWVcwdWRXNXphR2xtZENncElHRm1kR1Z5SUdWdVpDQmxkbVZ1ZENjcE8xeHVJQ0FnSUNBZ2MzUnlaV0Z0TG1WdGFYUW9KMlZ5Y205eUp5d2daU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbG1JQ2h6ZEdGMFpTNWtaV052WkdWeUlDWW1JQ0ZoWkdSVWIwWnliMjUwSUNZbUlDRmxibU52WkdsdVp5bGNiaUFnSUNBZ0lDQWdZMmgxYm1zZ1BTQnpkR0YwWlM1a1pXTnZaR1Z5TG5keWFYUmxLR05vZFc1cktUdGNibHh1SUNBZ0lDQWdhV1lnS0NGaFpHUlViMFp5YjI1MEtWeHVJQ0FnSUNBZ0lDQnpkR0YwWlM1eVpXRmthVzVuSUQwZ1ptRnNjMlU3WEc1Y2JpQWdJQ0FnSUM4dklHbG1JSGRsSUhkaGJuUWdkR2hsSUdSaGRHRWdibTkzTENCcWRYTjBJR1Z0YVhRZ2FYUXVYRzRnSUNBZ0lDQnBaaUFvYzNSaGRHVXVabXh2ZDJsdVp5QW1KaUJ6ZEdGMFpTNXNaVzVuZEdnZ1BUMDlJREFnSmlZZ0lYTjBZWFJsTG5ONWJtTXBJSHRjYmlBZ0lDQWdJQ0FnYzNSeVpXRnRMbVZ0YVhRb0oyUmhkR0VuTENCamFIVnVheWs3WEc0Z0lDQWdJQ0FnSUhOMGNtVmhiUzV5WldGa0tEQXBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdMeThnZFhCa1lYUmxJSFJvWlNCaWRXWm1aWElnYVc1bWJ5NWNiaUFnSUNBZ0lDQWdjM1JoZEdVdWJHVnVaM1JvSUNzOUlITjBZWFJsTG05aWFtVmpkRTF2WkdVZ1B5QXhJRG9nWTJoMWJtc3ViR1Z1WjNSb08xeHVJQ0FnSUNBZ0lDQnBaaUFvWVdSa1ZHOUdjbTl1ZENsY2JpQWdJQ0FnSUNBZ0lDQnpkR0YwWlM1aWRXWm1aWEl1ZFc1emFHbG1kQ2hqYUhWdWF5azdYRzRnSUNBZ0lDQWdJR1ZzYzJWY2JpQWdJQ0FnSUNBZ0lDQnpkR0YwWlM1aWRXWm1aWEl1Y0hWemFDaGphSFZ1YXlrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0hOMFlYUmxMbTVsWldSU1pXRmtZV0pzWlNsY2JpQWdJQ0FnSUNBZ0lDQmxiV2wwVW1WaFpHRmliR1VvYzNSeVpXRnRLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYldGNVltVlNaV0ZrVFc5eVpTaHpkSEpsWVcwc0lITjBZWFJsS1R0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9JV0ZrWkZSdlJuSnZiblFwSUh0Y2JpQWdJQ0J6ZEdGMFpTNXlaV0ZrYVc1bklEMGdabUZzYzJVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2JtVmxaRTF2Y21WRVlYUmhLSE4wWVhSbEtUdGNibjFjYmx4dVhHNWNiaTh2SUdsbUlHbDBKM01nY0dGemRDQjBhR1VnYUdsbmFDQjNZWFJsY2lCdFlYSnJMQ0IzWlNCallXNGdjSFZ6YUNCcGJpQnpiMjFsSUcxdmNtVXVYRzR2THlCQmJITnZMQ0JwWmlCM1pTQm9ZWFpsSUc1dklHUmhkR0VnZVdWMExDQjNaU0JqWVc0Z2MzUmhibVFnYzI5dFpWeHVMeThnYlc5eVpTQmllWFJsY3k0Z0lGUm9hWE1nYVhNZ2RHOGdkMjl5YXlCaGNtOTFibVFnWTJGelpYTWdkMmhsY21VZ2FIZHRQVEFzWEc0dkx5QnpkV05vSUdGeklIUm9aU0J5WlhCc0xpQWdRV3h6Ynl3Z2FXWWdkR2hsSUhCMWMyZ29LU0IwY21sbloyVnlaV1FnWVZ4dUx5OGdjbVZoWkdGaWJHVWdaWFpsYm5Rc0lHRnVaQ0IwYUdVZ2RYTmxjaUJqWVd4c1pXUWdjbVZoWkNoc1lYSm5aVTUxYldKbGNpa2djM1ZqYUNCMGFHRjBYRzR2THlCdVpXVmtVbVZoWkdGaWJHVWdkMkZ6SUhObGRDd2dkR2hsYmlCM1pTQnZkV2RvZENCMGJ5QndkWE5vSUcxdmNtVXNJSE52SUhSb1lYUWdZVzV2ZEdobGNseHVMeThnSjNKbFlXUmhZbXhsSnlCbGRtVnVkQ0IzYVd4c0lHSmxJSFJ5YVdkblpYSmxaQzVjYm1aMWJtTjBhVzl1SUc1bFpXUk5iM0psUkdGMFlTaHpkR0YwWlNrZ2UxeHVJQ0J5WlhSMWNtNGdJWE4wWVhSbExtVnVaR1ZrSUNZbVhHNGdJQ0FnSUNBZ0lDQW9jM1JoZEdVdWJtVmxaRkpsWVdSaFlteGxJSHg4WEc0Z0lDQWdJQ0FnSUNBZ2MzUmhkR1V1YkdWdVozUm9JRHdnYzNSaGRHVXVhR2xuYUZkaGRHVnlUV0Z5YXlCOGZGeHVJQ0FnSUNBZ0lDQWdJSE4wWVhSbExteGxibWQwYUNBOVBUMGdNQ2s3WEc1OVhHNWNiaTh2SUdKaFkydDNZWEprY3lCamIyMXdZWFJwWW1sc2FYUjVMbHh1VW1WaFpHRmliR1V1Y0hKdmRHOTBlWEJsTG5ObGRFVnVZMjlrYVc1bklEMGdablZ1WTNScGIyNG9aVzVqS1NCN1hHNGdJR2xtSUNnaFUzUnlhVzVuUkdWamIyUmxjaWxjYmlBZ0lDQlRkSEpwYm1kRVpXTnZaR1Z5SUQwZ2NtVnhkV2x5WlNnbmMzUnlhVzVuWDJSbFkyOWtaWEl2SnlrdVUzUnlhVzVuUkdWamIyUmxjanRjYmlBZ2RHaHBjeTVmY21WaFpHRmliR1ZUZEdGMFpTNWtaV052WkdWeUlEMGdibVYzSUZOMGNtbHVaMFJsWTI5a1pYSW9aVzVqS1R0Y2JpQWdkR2hwY3k1ZmNtVmhaR0ZpYkdWVGRHRjBaUzVsYm1OdlpHbHVaeUE5SUdWdVl6dGNiaUFnY21WMGRYSnVJSFJvYVhNN1hHNTlPMXh1WEc0dkx5QkViMjRuZENCeVlXbHpaU0IwYUdVZ2FIZHRJRDRnTVRJNFRVSmNiblpoY2lCTlFWaGZTRmROSUQwZ01IZzRNREF3TURBN1hHNW1kVzVqZEdsdmJpQnliM1Z1WkZWd1ZHOU9aWGgwVUc5M1pYSlBaaklvYmlrZ2UxeHVJQ0JwWmlBb2JpQStQU0JOUVZoZlNGZE5LU0I3WEc0Z0lDQWdiaUE5SUUxQldGOUlWMDA3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnTHk4Z1IyVjBJSFJvWlNCdVpYaDBJR2hwWjJobGMzUWdjRzkzWlhJZ2IyWWdNbHh1SUNBZ0lHNHRMVHRjYmlBZ0lDQm1iM0lnS0haaGNpQndJRDBnTVRzZ2NDQThJRE15T3lCd0lEdzhQU0F4S1NCdUlIdzlJRzRnUGo0Z2NEdGNiaUFnSUNCdUt5czdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHNDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHaHZkMDExWTJoVWIxSmxZV1FvYml3Z2MzUmhkR1VwSUh0Y2JpQWdhV1lnS0hOMFlYUmxMbXhsYm1kMGFDQTlQVDBnTUNBbUppQnpkR0YwWlM1bGJtUmxaQ2xjYmlBZ0lDQnlaWFIxY200Z01EdGNibHh1SUNCcFppQW9jM1JoZEdVdWIySnFaV04wVFc5a1pTbGNiaUFnSUNCeVpYUjFjbTRnYmlBOVBUMGdNQ0EvSURBZ09pQXhPMXh1WEc0Z0lHbG1JQ2hwYzA1aFRpaHVLU0I4ZkNCMWRHbHNMbWx6VG5Wc2JDaHVLU2tnZTF4dUlDQWdJQzh2SUc5dWJIa2dabXh2ZHlCdmJtVWdZblZtWm1WeUlHRjBJR0VnZEdsdFpWeHVJQ0FnSUdsbUlDaHpkR0YwWlM1bWJHOTNhVzVuSUNZbUlITjBZWFJsTG1KMVptWmxjaTVzWlc1bmRHZ3BYRzRnSUNBZ0lDQnlaWFIxY200Z2MzUmhkR1V1WW5WbVptVnlXekJkTG14bGJtZDBhRHRjYmlBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0J5WlhSMWNtNGdjM1JoZEdVdWJHVnVaM1JvTzF4dUlDQjlYRzVjYmlBZ2FXWWdLRzRnUEQwZ01DbGNiaUFnSUNCeVpYUjFjbTRnTUR0Y2JseHVJQ0F2THlCSlppQjNaU2R5WlNCaGMydHBibWNnWm05eUlHMXZjbVVnZEdoaGJpQjBhR1VnZEdGeVoyVjBJR0oxWm1abGNpQnNaWFpsYkN4Y2JpQWdMeThnZEdobGJpQnlZV2x6WlNCMGFHVWdkMkYwWlhJZ2JXRnlheTRnSUVKMWJYQWdkWEFnZEc4Z2RHaGxJRzVsZUhRZ2FHbG5hR1Z6ZEZ4dUlDQXZMeUJ3YjNkbGNpQnZaaUF5TENCMGJ5QndjbVYyWlc1MElHbHVZM0psWVhOcGJtY2dhWFFnWlhoalpYTnphWFpsYkhrZ2FXNGdkR2x1ZVZ4dUlDQXZMeUJoYlc5MWJuUnpMbHh1SUNCcFppQW9iaUErSUhOMFlYUmxMbWhwWjJoWFlYUmxjazFoY21zcFhHNGdJQ0FnYzNSaGRHVXVhR2xuYUZkaGRHVnlUV0Z5YXlBOUlISnZkVzVrVlhCVWIwNWxlSFJRYjNkbGNrOW1NaWh1S1R0Y2JseHVJQ0F2THlCa2IyNG5kQ0JvWVhabElIUm9ZWFFnYlhWamFDNGdJSEpsZEhWeWJpQnVkV3hzTENCMWJteGxjM01nZDJVbmRtVWdaVzVrWldRdVhHNGdJR2xtSUNodUlENGdjM1JoZEdVdWJHVnVaM1JvS1NCN1hHNGdJQ0FnYVdZZ0tDRnpkR0YwWlM1bGJtUmxaQ2tnZTF4dUlDQWdJQ0FnYzNSaGRHVXVibVZsWkZKbFlXUmhZbXhsSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQXdPMXh1SUNBZ0lIMGdaV3h6WlZ4dUlDQWdJQ0FnY21WMGRYSnVJSE4wWVhSbExteGxibWQwYUR0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdU8xeHVmVnh1WEc0dkx5QjViM1VnWTJGdUlHOTJaWEp5YVdSbElHVnBkR2hsY2lCMGFHbHpJRzFsZEdodlpDd2diM0lnZEdobElHRnplVzVqSUY5eVpXRmtLRzRwSUdKbGJHOTNMbHh1VW1WaFpHRmliR1V1Y0hKdmRHOTBlWEJsTG5KbFlXUWdQU0JtZFc1amRHbHZiaWh1S1NCN1hHNGdJR1JsWW5WbktDZHlaV0ZrSnl3Z2JpazdYRzRnSUhaaGNpQnpkR0YwWlNBOUlIUm9hWE11WDNKbFlXUmhZbXhsVTNSaGRHVTdYRzRnSUhaaGNpQnVUM0pwWnlBOUlHNDdYRzVjYmlBZ2FXWWdLQ0YxZEdsc0xtbHpUblZ0WW1WeUtHNHBJSHg4SUc0Z1BpQXdLVnh1SUNBZ0lITjBZWFJsTG1WdGFYUjBaV1JTWldGa1lXSnNaU0E5SUdaaGJITmxPMXh1WEc0Z0lDOHZJR2xtSUhkbEozSmxJR1J2YVc1bklISmxZV1FvTUNrZ2RHOGdkSEpwWjJkbGNpQmhJSEpsWVdSaFlteGxJR1YyWlc1MExDQmlkWFFnZDJWY2JpQWdMeThnWVd4eVpXRmtlU0JvWVhabElHRWdZblZ1WTJnZ2IyWWdaR0YwWVNCcGJpQjBhR1VnWW5WbVptVnlMQ0IwYUdWdUlHcDFjM1FnZEhKcFoyZGxjbHh1SUNBdkx5QjBhR1VnSjNKbFlXUmhZbXhsSnlCbGRtVnVkQ0JoYm1RZ2JXOTJaU0J2Ymk1Y2JpQWdhV1lnS0c0Z1BUMDlJREFnSmlaY2JpQWdJQ0FnSUhOMFlYUmxMbTVsWldSU1pXRmtZV0pzWlNBbUpseHVJQ0FnSUNBZ0tITjBZWFJsTG14bGJtZDBhQ0ErUFNCemRHRjBaUzVvYVdkb1YyRjBaWEpOWVhKcklIeDhJSE4wWVhSbExtVnVaR1ZrS1NrZ2UxeHVJQ0FnSUdSbFluVm5LQ2R5WldGa09pQmxiV2wwVW1WaFpHRmliR1VuTENCemRHRjBaUzVzWlc1bmRHZ3NJSE4wWVhSbExtVnVaR1ZrS1R0Y2JpQWdJQ0JwWmlBb2MzUmhkR1V1YkdWdVozUm9JRDA5UFNBd0lDWW1JSE4wWVhSbExtVnVaR1ZrS1Z4dUlDQWdJQ0FnWlc1a1VtVmhaR0ZpYkdVb2RHaHBjeWs3WEc0Z0lDQWdaV3h6WlZ4dUlDQWdJQ0FnWlcxcGRGSmxZV1JoWW14bEtIUm9hWE1wTzF4dUlDQWdJSEpsZEhWeWJpQnVkV3hzTzF4dUlDQjlYRzVjYmlBZ2JpQTlJR2h2ZDAxMVkyaFViMUpsWVdRb2Jpd2djM1JoZEdVcE8xeHVYRzRnSUM4dklHbG1JSGRsSjNabElHVnVaR1ZrTENCaGJtUWdkMlVuY21VZ2JtOTNJR05zWldGeUxDQjBhR1Z1SUdacGJtbHphQ0JwZENCMWNDNWNiaUFnYVdZZ0tHNGdQVDA5SURBZ0ppWWdjM1JoZEdVdVpXNWtaV1FwSUh0Y2JpQWdJQ0JwWmlBb2MzUmhkR1V1YkdWdVozUm9JRDA5UFNBd0tWeHVJQ0FnSUNBZ1pXNWtVbVZoWkdGaWJHVW9kR2hwY3lrN1hHNGdJQ0FnY21WMGRYSnVJRzUxYkd3N1hHNGdJSDFjYmx4dUlDQXZMeUJCYkd3Z2RHaGxJR0ZqZEhWaGJDQmphSFZ1YXlCblpXNWxjbUYwYVc5dUlHeHZaMmxqSUc1bFpXUnpJSFJ2SUdKbFhHNGdJQzh2SUNwaVpXeHZkeW9nZEdobElHTmhiR3dnZEc4Z1gzSmxZV1F1SUNCVWFHVWdjbVZoYzI5dUlHbHpJSFJvWVhRZ2FXNGdZMlZ5ZEdGcGJseHVJQ0F2THlCemVXNTBhR1YwYVdNZ2MzUnlaV0Z0SUdOaGMyVnpMQ0J6ZFdOb0lHRnpJSEJoYzNOMGFISnZkV2RvSUhOMGNtVmhiWE1zSUY5eVpXRmtYRzRnSUM4dklHMWhlU0JpWlNCaElHTnZiWEJzWlhSbGJIa2djM2x1WTJoeWIyNXZkWE1nYjNCbGNtRjBhVzl1SUhkb2FXTm9JRzFoZVNCamFHRnVaMlZjYmlBZ0x5OGdkR2hsSUhOMFlYUmxJRzltSUhSb1pTQnlaV0ZrSUdKMVptWmxjaXdnY0hKdmRtbGthVzVuSUdWdWIzVm5hQ0JrWVhSaElIZG9aVzVjYmlBZ0x5OGdZbVZtYjNKbElIUm9aWEpsSUhkaGN5QXFibTkwS2lCbGJtOTFaMmd1WEc0Z0lDOHZYRzRnSUM4dklGTnZMQ0IwYUdVZ2MzUmxjSE1nWVhKbE9seHVJQ0F2THlBeExpQkdhV2QxY21VZ2IzVjBJSGRvWVhRZ2RHaGxJSE4wWVhSbElHOW1JSFJvYVc1bmN5QjNhV3hzSUdKbElHRm1kR1Z5SUhkbElHUnZYRzRnSUM4dklHRWdjbVZoWkNCbWNtOXRJSFJvWlNCaWRXWm1aWEl1WEc0Z0lDOHZYRzRnSUM4dklESXVJRWxtSUhSb1lYUWdjbVZ6ZFd4MGFXNW5JSE4wWVhSbElIZHBiR3dnZEhKcFoyZGxjaUJoSUY5eVpXRmtMQ0IwYUdWdUlHTmhiR3dnWDNKbFlXUXVYRzRnSUM4dklFNXZkR1VnZEdoaGRDQjBhR2x6SUcxaGVTQmlaU0JoYzNsdVkyaHliMjV2ZFhNc0lHOXlJSE41Ym1Ob2NtOXViM1Z6TGlBZ1dXVnpMQ0JwZENCcGMxeHVJQ0F2THlCa1pXVndiSGtnZFdkc2VTQjBieUIzY21sMFpTQkJVRWx6SUhSb2FYTWdkMkY1TENCaWRYUWdkR2hoZENCemRHbHNiQ0JrYjJWemJpZDBJRzFsWVc1Y2JpQWdMeThnZEdoaGRDQjBhR1VnVW1WaFpHRmliR1VnWTJ4aGMzTWdjMmh2ZFd4a0lHSmxhR0YyWlNCcGJYQnliM0JsY214NUxDQmhjeUJ6ZEhKbFlXMXpJR0Z5WlZ4dUlDQXZMeUJrWlhOcFoyNWxaQ0IwYnlCaVpTQnplVzVqTDJGemVXNWpJR0ZuYm05emRHbGpMbHh1SUNBdkx5QlVZV3RsSUc1dmRHVWdhV1lnZEdobElGOXlaV0ZrSUdOaGJHd2dhWE1nYzNsdVl5QnZjaUJoYzNsdVl5QW9hV1VzSUdsbUlIUm9aU0J5WldGa0lHTmhiR3hjYmlBZ0x5OGdhR0Z6SUhKbGRIVnlibVZrSUhsbGRDa3NJSE52SUhSb1lYUWdkMlVnYTI1dmR5QjNhR1YwYUdWeUlHOXlJRzV2ZENCcGRDZHpJSE5oWm1VZ2RHOGdaVzFwZEZ4dUlDQXZMeUFuY21WaFpHRmliR1VuSUdWMFl5NWNiaUFnTHk5Y2JpQWdMeThnTXk0Z1FXTjBkV0ZzYkhrZ2NIVnNiQ0IwYUdVZ2NtVnhkV1Z6ZEdWa0lHTm9kVzVyY3lCdmRYUWdiMllnZEdobElHSjFabVpsY2lCaGJtUWdjbVYwZFhKdUxseHVYRzRnSUM4dklHbG1JSGRsSUc1bFpXUWdZU0J5WldGa1lXSnNaU0JsZG1WdWRDd2dkR2hsYmlCM1pTQnVaV1ZrSUhSdklHUnZJSE52YldVZ2NtVmhaR2x1Wnk1Y2JpQWdkbUZ5SUdSdlVtVmhaQ0E5SUhOMFlYUmxMbTVsWldSU1pXRmtZV0pzWlR0Y2JpQWdaR1ZpZFdjb0oyNWxaV1FnY21WaFpHRmliR1VuTENCa2IxSmxZV1FwTzF4dVhHNGdJQzh2SUdsbUlIZGxJR04xY25KbGJuUnNlU0JvWVhabElHeGxjM01nZEdoaGJpQjBhR1VnYUdsbmFGZGhkR1Z5VFdGeWF5d2dkR2hsYmlCaGJITnZJSEpsWVdRZ2MyOXRaVnh1SUNCcFppQW9jM1JoZEdVdWJHVnVaM1JvSUQwOVBTQXdJSHg4SUhOMFlYUmxMbXhsYm1kMGFDQXRJRzRnUENCemRHRjBaUzVvYVdkb1YyRjBaWEpOWVhKcktTQjdYRzRnSUNBZ1pHOVNaV0ZrSUQwZ2RISjFaVHRjYmlBZ0lDQmtaV0oxWnlnbmJHVnVaM1JvSUd4bGMzTWdkR2hoYmlCM1lYUmxjbTFoY21zbkxDQmtiMUpsWVdRcE8xeHVJQ0I5WEc1Y2JpQWdMeThnYUc5M1pYWmxjaXdnYVdZZ2QyVW5kbVVnWlc1a1pXUXNJSFJvWlc0Z2RHaGxjbVVuY3lCdWJ5QndiMmx1ZEN3Z1lXNWtJR2xtSUhkbEozSmxJR0ZzY21WaFpIbGNiaUFnTHk4Z2NtVmhaR2x1Wnl3Z2RHaGxiaUJwZENkeklIVnVibVZqWlhOellYSjVMbHh1SUNCcFppQW9jM1JoZEdVdVpXNWtaV1FnZkh3Z2MzUmhkR1V1Y21WaFpHbHVaeWtnZTF4dUlDQWdJR1J2VW1WaFpDQTlJR1poYkhObE8xeHVJQ0FnSUdSbFluVm5LQ2R5WldGa2FXNW5JRzl5SUdWdVpHVmtKeXdnWkc5U1pXRmtLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaGtiMUpsWVdRcElIdGNiaUFnSUNCa1pXSjFaeWduWkc4Z2NtVmhaQ2NwTzF4dUlDQWdJSE4wWVhSbExuSmxZV1JwYm1jZ1BTQjBjblZsTzF4dUlDQWdJSE4wWVhSbExuTjVibU1nUFNCMGNuVmxPMXh1SUNBZ0lDOHZJR2xtSUhSb1pTQnNaVzVuZEdnZ2FYTWdZM1Z5Y21WdWRHeDVJSHBsY204c0lIUm9aVzRnZDJVZ0ttNWxaV1FxSUdFZ2NtVmhaR0ZpYkdVZ1pYWmxiblF1WEc0Z0lDQWdhV1lnS0hOMFlYUmxMbXhsYm1kMGFDQTlQVDBnTUNsY2JpQWdJQ0FnSUhOMFlYUmxMbTVsWldSU1pXRmtZV0pzWlNBOUlIUnlkV1U3WEc0Z0lDQWdMeThnWTJGc2JDQnBiblJsY201aGJDQnlaV0ZrSUcxbGRHaHZaRnh1SUNBZ0lIUm9hWE11WDNKbFlXUW9jM1JoZEdVdWFHbG5hRmRoZEdWeVRXRnlheWs3WEc0Z0lDQWdjM1JoZEdVdWMzbHVZeUE5SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnTHk4Z1NXWWdYM0psWVdRZ2NIVnphR1ZrSUdSaGRHRWdjM2x1WTJoeWIyNXZkWE5zZVN3Z2RHaGxiaUJnY21WaFpHbHVaMkFnZDJsc2JDQmlaU0JtWVd4elpTeGNiaUFnTHk4Z1lXNWtJSGRsSUc1bFpXUWdkRzhnY21VdFpYWmhiSFZoZEdVZ2FHOTNJRzExWTJnZ1pHRjBZU0IzWlNCallXNGdjbVYwZFhKdUlIUnZJSFJvWlNCMWMyVnlMbHh1SUNCcFppQW9aRzlTWldGa0lDWW1JQ0Z6ZEdGMFpTNXlaV0ZrYVc1bktWeHVJQ0FnSUc0Z1BTQm9iM2ROZFdOb1ZHOVNaV0ZrS0c1UGNtbG5MQ0J6ZEdGMFpTazdYRzVjYmlBZ2RtRnlJSEpsZER0Y2JpQWdhV1lnS0c0Z1BpQXdLVnh1SUNBZ0lISmxkQ0E5SUdaeWIyMU1hWE4wS0c0c0lITjBZWFJsS1R0Y2JpQWdaV3h6WlZ4dUlDQWdJSEpsZENBOUlHNTFiR3c3WEc1Y2JpQWdhV1lnS0hWMGFXd3VhWE5PZFd4c0tISmxkQ2twSUh0Y2JpQWdJQ0J6ZEdGMFpTNXVaV1ZrVW1WaFpHRmliR1VnUFNCMGNuVmxPMXh1SUNBZ0lHNGdQU0F3TzF4dUlDQjlYRzVjYmlBZ2MzUmhkR1V1YkdWdVozUm9JQzA5SUc0N1hHNWNiaUFnTHk4Z1NXWWdkMlVnYUdGMlpTQnViM1JvYVc1bklHbHVJSFJvWlNCaWRXWm1aWElzSUhSb1pXNGdkMlVnZDJGdWRDQjBieUJyYm05M1hHNGdJQzh2SUdGeklITnZiMjRnWVhNZ2QyVWdLbVJ2S2lCblpYUWdjMjl0WlhSb2FXNW5JR2x1ZEc4Z2RHaGxJR0oxWm1abGNpNWNiaUFnYVdZZ0tITjBZWFJsTG14bGJtZDBhQ0E5UFQwZ01DQW1KaUFoYzNSaGRHVXVaVzVrWldRcFhHNGdJQ0FnYzNSaGRHVXVibVZsWkZKbFlXUmhZbXhsSUQwZ2RISjFaVHRjYmx4dUlDQXZMeUJKWmlCM1pTQjBjbWxsWkNCMGJ5QnlaV0ZrS0NrZ2NHRnpkQ0IwYUdVZ1JVOUdMQ0IwYUdWdUlHVnRhWFFnWlc1a0lHOXVJSFJvWlNCdVpYaDBJSFJwWTJzdVhHNGdJR2xtSUNodVQzSnBaeUFoUFQwZ2JpQW1KaUJ6ZEdGMFpTNWxibVJsWkNBbUppQnpkR0YwWlM1c1pXNW5kR2dnUFQwOUlEQXBYRzRnSUNBZ1pXNWtVbVZoWkdGaWJHVW9kR2hwY3lrN1hHNWNiaUFnYVdZZ0tDRjFkR2xzTG1selRuVnNiQ2h5WlhRcEtWeHVJQ0FnSUhSb2FYTXVaVzFwZENnblpHRjBZU2NzSUhKbGRDazdYRzVjYmlBZ2NtVjBkWEp1SUhKbGREdGNibjA3WEc1Y2JtWjFibU4wYVc5dUlHTm9kVzVyU1c1MllXeHBaQ2h6ZEdGMFpTd2dZMmgxYm1zcElIdGNiaUFnZG1GeUlHVnlJRDBnYm5Wc2JEdGNiaUFnYVdZZ0tDRjFkR2xzTG1selFuVm1abVZ5S0dOb2RXNXJLU0FtSmx4dUlDQWdJQ0FnSVhWMGFXd3VhWE5UZEhKcGJtY29ZMmgxYm1zcElDWW1YRzRnSUNBZ0lDQWhkWFJwYkM1cGMwNTFiR3hQY2xWdVpHVm1hVzVsWkNoamFIVnVheWtnSmlaY2JpQWdJQ0FnSUNGemRHRjBaUzV2WW1wbFkzUk5iMlJsS1NCN1hHNGdJQ0FnWlhJZ1BTQnVaWGNnVkhsd1pVVnljbTl5S0NkSmJuWmhiR2xrSUc1dmJpMXpkSEpwYm1jdlluVm1abVZ5SUdOb2RXNXJKeWs3WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1Z5TzF4dWZWeHVYRzVjYm1aMWJtTjBhVzl1SUc5dVJXOW1RMmgxYm1zb2MzUnlaV0Z0TENCemRHRjBaU2tnZTF4dUlDQnBaaUFvYzNSaGRHVXVaR1ZqYjJSbGNpQW1KaUFoYzNSaGRHVXVaVzVrWldRcElIdGNiaUFnSUNCMllYSWdZMmgxYm1zZ1BTQnpkR0YwWlM1a1pXTnZaR1Z5TG1WdVpDZ3BPMXh1SUNBZ0lHbG1JQ2hqYUhWdWF5QW1KaUJqYUhWdWF5NXNaVzVuZEdncElIdGNiaUFnSUNBZ0lITjBZWFJsTG1KMVptWmxjaTV3ZFhOb0tHTm9kVzVyS1R0Y2JpQWdJQ0FnSUhOMFlYUmxMbXhsYm1kMGFDQXJQU0J6ZEdGMFpTNXZZbXBsWTNSTmIyUmxJRDhnTVNBNklHTm9kVzVyTG14bGJtZDBhRHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjM1JoZEdVdVpXNWtaV1FnUFNCMGNuVmxPMXh1WEc0Z0lDOHZJR1Z0YVhRZ0ozSmxZV1JoWW14bEp5QnViM2NnZEc4Z2JXRnJaU0J6ZFhKbElHbDBJR2RsZEhNZ2NHbGphMlZrSUhWd0xseHVJQ0JsYldsMFVtVmhaR0ZpYkdVb2MzUnlaV0Z0S1R0Y2JuMWNibHh1THk4Z1JHOXVKM1FnWlcxcGRDQnlaV0ZrWVdKc1pTQnlhV2RvZENCaGQyRjVJR2x1SUhONWJtTWdiVzlrWlN3Z1ltVmpZWFZ6WlNCMGFHbHpJR05oYmlCMGNtbG5aMlZ5WEc0dkx5QmhibTkwYUdWeUlISmxZV1FvS1NCallXeHNJRDArSUhOMFlXTnJJRzkyWlhKbWJHOTNMaUFnVkdocGN5QjNZWGtzSUdsMElHMXBaMmgwSUhSeWFXZG5aWEpjYmk4dklHRWdibVY0ZEZScFkyc2djbVZqZFhKemFXOXVJSGRoY201cGJtY3NJR0oxZENCMGFHRjBKM01nYm05MElITnZJR0poWkM1Y2JtWjFibU4wYVc5dUlHVnRhWFJTWldGa1lXSnNaU2h6ZEhKbFlXMHBJSHRjYmlBZ2RtRnlJSE4wWVhSbElEMGdjM1J5WldGdExsOXlaV0ZrWVdKc1pWTjBZWFJsTzF4dUlDQnpkR0YwWlM1dVpXVmtVbVZoWkdGaWJHVWdQU0JtWVd4elpUdGNiaUFnYVdZZ0tDRnpkR0YwWlM1bGJXbDBkR1ZrVW1WaFpHRmliR1VwSUh0Y2JpQWdJQ0JrWldKMVp5Z25aVzFwZEZKbFlXUmhZbXhsSnl3Z2MzUmhkR1V1Wm14dmQybHVaeWs3WEc0Z0lDQWdjM1JoZEdVdVpXMXBkSFJsWkZKbFlXUmhZbXhsSUQwZ2RISjFaVHRjYmlBZ0lDQnBaaUFvYzNSaGRHVXVjM2x1WXlsY2JpQWdJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lHVnRhWFJTWldGa1lXSnNaVjhvYzNSeVpXRnRLVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJR1ZzYzJWY2JpQWdJQ0FnSUdWdGFYUlNaV0ZrWVdKc1pWOG9jM1J5WldGdEtUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJsYldsMFVtVmhaR0ZpYkdWZktITjBjbVZoYlNrZ2UxeHVJQ0JrWldKMVp5Z25aVzFwZENCeVpXRmtZV0pzWlNjcE8xeHVJQ0J6ZEhKbFlXMHVaVzFwZENnbmNtVmhaR0ZpYkdVbktUdGNiaUFnWm14dmR5aHpkSEpsWVcwcE8xeHVmVnh1WEc1Y2JpOHZJR0YwSUhSb2FYTWdjRzlwYm5Rc0lIUm9aU0IxYzJWeUlHaGhjeUJ3Y21WemRXMWhZbXg1SUhObFpXNGdkR2hsSUNkeVpXRmtZV0pzWlNjZ1pYWmxiblFzWEc0dkx5QmhibVFnWTJGc2JHVmtJSEpsWVdRb0tTQjBieUJqYjI1emRXMWxJSE52YldVZ1pHRjBZUzRnSUhSb1lYUWdiV0Y1SUdoaGRtVWdkSEpwWjJkbGNtVmtYRzR2THlCcGJpQjBkWEp1SUdGdWIzUm9aWElnWDNKbFlXUW9iaWtnWTJGc2JDd2dhVzRnZDJocFkyZ2dZMkZ6WlNCeVpXRmthVzVuSUQwZ2RISjFaU0JwWmx4dUx5OGdhWFFuY3lCcGJpQndjbTluY21WemN5NWNiaTh2SUVodmQyVjJaWElzSUdsbUlIZGxKM0psSUc1dmRDQmxibVJsWkN3Z2IzSWdjbVZoWkdsdVp5d2dZVzVrSUhSb1pTQnNaVzVuZEdnZ1BDQm9kMjBzWEc0dkx5QjBhR1Z1SUdkdklHRm9aV0ZrSUdGdVpDQjBjbmtnZEc4Z2NtVmhaQ0J6YjIxbElHMXZjbVVnY0hKbFpXMXdkR2wyWld4NUxseHVablZ1WTNScGIyNGdiV0Y1WW1WU1pXRmtUVzl5WlNoemRISmxZVzBzSUhOMFlYUmxLU0I3WEc0Z0lHbG1JQ2doYzNSaGRHVXVjbVZoWkdsdVowMXZjbVVwSUh0Y2JpQWdJQ0J6ZEdGMFpTNXlaV0ZrYVc1blRXOXlaU0E5SUhSeWRXVTdYRzRnSUNBZ2NISnZZMlZ6Y3k1dVpYaDBWR2xqYXlobWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lHMWhlV0psVW1WaFpFMXZjbVZmS0hOMGNtVmhiU3dnYzNSaGRHVXBPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUcxaGVXSmxVbVZoWkUxdmNtVmZLSE4wY21WaGJTd2djM1JoZEdVcElIdGNiaUFnZG1GeUlHeGxiaUE5SUhOMFlYUmxMbXhsYm1kMGFEdGNiaUFnZDJocGJHVWdLQ0Z6ZEdGMFpTNXlaV0ZrYVc1bklDWW1JQ0Z6ZEdGMFpTNW1iRzkzYVc1bklDWW1JQ0Z6ZEdGMFpTNWxibVJsWkNBbUpseHVJQ0FnSUNBZ0lDQWdjM1JoZEdVdWJHVnVaM1JvSUR3Z2MzUmhkR1V1YUdsbmFGZGhkR1Z5VFdGeWF5a2dlMXh1SUNBZ0lHUmxZblZuS0NkdFlYbGlaVkpsWVdSTmIzSmxJSEpsWVdRZ01DY3BPMXh1SUNBZ0lITjBjbVZoYlM1eVpXRmtLREFwTzF4dUlDQWdJR2xtSUNoc1pXNGdQVDA5SUhOMFlYUmxMbXhsYm1kMGFDbGNiaUFnSUNBZ0lDOHZJR1JwWkc0bmRDQm5aWFFnWVc1NUlHUmhkR0VzSUhOMGIzQWdjM0JwYm01cGJtY3VYRzRnSUNBZ0lDQmljbVZoYXp0Y2JpQWdJQ0JsYkhObFhHNGdJQ0FnSUNCc1pXNGdQU0J6ZEdGMFpTNXNaVzVuZEdnN1hHNGdJSDFjYmlBZ2MzUmhkR1V1Y21WaFpHbHVaMDF2Y21VZ1BTQm1ZV3h6WlR0Y2JuMWNibHh1THk4Z1lXSnpkSEpoWTNRZ2JXVjBhRzlrTGlBZ2RHOGdZbVVnYjNabGNuSnBaR1JsYmlCcGJpQnpjR1ZqYVdacFl5QnBiWEJzWlcxbGJuUmhkR2x2YmlCamJHRnpjMlZ6TGx4dUx5OGdZMkZzYkNCallpaGxjaXdnWkdGMFlTa2dkMmhsY21VZ1pHRjBZU0JwY3lBOFBTQnVJR2x1SUd4bGJtZDBhQzVjYmk4dklHWnZjaUIyYVhKMGRXRnNJQ2h1YjI0dGMzUnlhVzVuTENCdWIyNHRZblZtWm1WeUtTQnpkSEpsWVcxekxDQmNJbXhsYm1kMGFGd2lJR2x6SUhOdmJXVjNhR0YwWEc0dkx5QmhjbUpwZEhKaGNua3NJR0Z1WkNCd1pYSm9ZWEJ6SUc1dmRDQjJaWEo1SUcxbFlXNXBibWRtZFd3dVhHNVNaV0ZrWVdKc1pTNXdjbTkwYjNSNWNHVXVYM0psWVdRZ1BTQm1kVzVqZEdsdmJpaHVLU0I3WEc0Z0lIUm9hWE11WlcxcGRDZ25aWEp5YjNJbkxDQnVaWGNnUlhKeWIzSW9KMjV2ZENCcGJYQnNaVzFsYm5SbFpDY3BLVHRjYm4wN1hHNWNibEpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV3YVhCbElEMGdablZ1WTNScGIyNG9aR1Z6ZEN3Z2NHbHdaVTl3ZEhNcElIdGNiaUFnZG1GeUlITnlZeUE5SUhSb2FYTTdYRzRnSUhaaGNpQnpkR0YwWlNBOUlIUm9hWE11WDNKbFlXUmhZbXhsVTNSaGRHVTdYRzVjYmlBZ2MzZHBkR05vSUNoemRHRjBaUzV3YVhCbGMwTnZkVzUwS1NCN1hHNGdJQ0FnWTJGelpTQXdPbHh1SUNBZ0lDQWdjM1JoZEdVdWNHbHdaWE1nUFNCa1pYTjBPMXh1SUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnWTJGelpTQXhPbHh1SUNBZ0lDQWdjM1JoZEdVdWNHbHdaWE1nUFNCYmMzUmhkR1V1Y0dsd1pYTXNJR1JsYzNSZE8xeHVJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdaR1ZtWVhWc2REcGNiaUFnSUNBZ0lITjBZWFJsTG5CcGNHVnpMbkIxYzJnb1pHVnpkQ2s3WEc0Z0lDQWdJQ0JpY21WaGF6dGNiaUFnZlZ4dUlDQnpkR0YwWlM1d2FYQmxjME52ZFc1MElDczlJREU3WEc0Z0lHUmxZblZuS0Nkd2FYQmxJR052ZFc1MFBTVmtJRzl3ZEhNOUpXb25MQ0J6ZEdGMFpTNXdhWEJsYzBOdmRXNTBMQ0J3YVhCbFQzQjBjeWs3WEc1Y2JpQWdkbUZ5SUdSdlJXNWtJRDBnS0NGd2FYQmxUM0IwY3lCOGZDQndhWEJsVDNCMGN5NWxibVFnSVQwOUlHWmhiSE5sS1NBbUpseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1pYTjBJQ0U5UFNCd2NtOWpaWE56TG5OMFpHOTFkQ0FtSmx4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JrWlhOMElDRTlQU0J3Y205alpYTnpMbk4wWkdWeWNqdGNibHh1SUNCMllYSWdaVzVrUm00Z1BTQmtiMFZ1WkNBL0lHOXVaVzVrSURvZ1kyeGxZVzUxY0R0Y2JpQWdhV1lnS0hOMFlYUmxMbVZ1WkVWdGFYUjBaV1FwWEc0Z0lDQWdjSEp2WTJWemN5NXVaWGgwVkdsamF5aGxibVJHYmlrN1hHNGdJR1ZzYzJWY2JpQWdJQ0J6Y21NdWIyNWpaU2duWlc1a0p5d2daVzVrUm00cE8xeHVYRzRnSUdSbGMzUXViMjRvSjNWdWNHbHdaU2NzSUc5dWRXNXdhWEJsS1R0Y2JpQWdablZ1WTNScGIyNGdiMjUxYm5CcGNHVW9jbVZoWkdGaWJHVXBJSHRjYmlBZ0lDQmtaV0oxWnlnbmIyNTFibkJwY0dVbktUdGNiaUFnSUNCcFppQW9jbVZoWkdGaWJHVWdQVDA5SUhOeVl5a2dlMXh1SUNBZ0lDQWdZMnhsWVc1MWNDZ3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJRzl1Wlc1a0tDa2dlMXh1SUNBZ0lHUmxZblZuS0NkdmJtVnVaQ2NwTzF4dUlDQWdJR1JsYzNRdVpXNWtLQ2s3WEc0Z0lIMWNibHh1SUNBdkx5QjNhR1Z1SUhSb1pTQmtaWE4wSUdSeVlXbHVjeXdnYVhRZ2NtVmtkV05sY3lCMGFHVWdZWGRoYVhSRWNtRnBiaUJqYjNWdWRHVnlYRzRnSUM4dklHOXVJSFJvWlNCemIzVnlZMlV1SUNCVWFHbHpJSGR2ZFd4a0lHSmxJRzF2Y21VZ1pXeGxaMkZ1ZENCM2FYUm9JR0VnTG05dVkyVW9LVnh1SUNBdkx5Qm9ZVzVrYkdWeUlHbHVJR1pzYjNjb0tTd2dZblYwSUdGa1pHbHVaeUJoYm1RZ2NtVnRiM1pwYm1jZ2NtVndaV0YwWldSc2VTQnBjMXh1SUNBdkx5QjBiMjhnYzJ4dmR5NWNiaUFnZG1GeUlHOXVaSEpoYVc0Z1BTQndhWEJsVDI1RWNtRnBiaWh6Y21NcE8xeHVJQ0JrWlhOMExtOXVLQ2RrY21GcGJpY3NJRzl1WkhKaGFXNHBPMXh1WEc0Z0lHWjFibU4wYVc5dUlHTnNaV0Z1ZFhBb0tTQjdYRzRnSUNBZ1pHVmlkV2NvSjJOc1pXRnVkWEFuS1R0Y2JpQWdJQ0F2THlCamJHVmhiblZ3SUdWMlpXNTBJR2hoYm1Sc1pYSnpJRzl1WTJVZ2RHaGxJSEJwY0dVZ2FYTWdZbkp2YTJWdVhHNGdJQ0FnWkdWemRDNXlaVzF2ZG1WTWFYTjBaVzVsY2lnblkyeHZjMlVuTENCdmJtTnNiM05sS1R0Y2JpQWdJQ0JrWlhOMExuSmxiVzkyWlV4cGMzUmxibVZ5S0NkbWFXNXBjMmduTENCdmJtWnBibWx6YUNrN1hHNGdJQ0FnWkdWemRDNXlaVzF2ZG1WTWFYTjBaVzVsY2lnblpISmhhVzRuTENCdmJtUnlZV2x1S1R0Y2JpQWdJQ0JrWlhOMExuSmxiVzkyWlV4cGMzUmxibVZ5S0NkbGNuSnZjaWNzSUc5dVpYSnliM0lwTzF4dUlDQWdJR1JsYzNRdWNtVnRiM1psVEdsemRHVnVaWElvSjNWdWNHbHdaU2NzSUc5dWRXNXdhWEJsS1R0Y2JpQWdJQ0J6Y21NdWNtVnRiM1psVEdsemRHVnVaWElvSjJWdVpDY3NJRzl1Wlc1a0tUdGNiaUFnSUNCemNtTXVjbVZ0YjNabFRHbHpkR1Z1WlhJb0oyVnVaQ2NzSUdOc1pXRnVkWEFwTzF4dUlDQWdJSE55WXk1eVpXMXZkbVZNYVhOMFpXNWxjaWduWkdGMFlTY3NJRzl1WkdGMFlTazdYRzVjYmlBZ0lDQXZMeUJwWmlCMGFHVWdjbVZoWkdWeUlHbHpJSGRoYVhScGJtY2dabTl5SUdFZ1pISmhhVzRnWlhabGJuUWdabkp2YlNCMGFHbHpYRzRnSUNBZ0x5OGdjM0JsWTJsbWFXTWdkM0pwZEdWeUxDQjBhR1Z1SUdsMElIZHZkV3hrSUdOaGRYTmxJR2wwSUhSdklHNWxkbVZ5SUhOMFlYSjBYRzRnSUNBZ0x5OGdabXh2ZDJsdVp5QmhaMkZwYmk1Y2JpQWdJQ0F2THlCVGJ5d2dhV1lnZEdocGN5QnBjeUJoZDJGcGRHbHVaeUJoSUdSeVlXbHVMQ0IwYUdWdUlIZGxJR3AxYzNRZ1kyRnNiQ0JwZENCdWIzY3VYRzRnSUNBZ0x5OGdTV1lnZDJVZ1pHOXVKM1FnYTI1dmR5d2dkR2hsYmlCaGMzTjFiV1VnZEdoaGRDQjNaU0JoY21VZ2QyRnBkR2x1WnlCbWIzSWdiMjVsTGx4dUlDQWdJR2xtSUNoemRHRjBaUzVoZDJGcGRFUnlZV2x1SUNZbVhHNGdJQ0FnSUNBZ0lDZ2haR1Z6ZEM1ZmQzSnBkR0ZpYkdWVGRHRjBaU0I4ZkNCa1pYTjBMbDkzY21sMFlXSnNaVk4wWVhSbExtNWxaV1JFY21GcGJpa3BYRzRnSUNBZ0lDQnZibVJ5WVdsdUtDazdYRzRnSUgxY2JseHVJQ0J6Y21NdWIyNG9KMlJoZEdFbkxDQnZibVJoZEdFcE8xeHVJQ0JtZFc1amRHbHZiaUJ2Ym1SaGRHRW9ZMmgxYm1zcElIdGNiaUFnSUNCa1pXSjFaeWduYjI1a1lYUmhKeWs3WEc0Z0lDQWdkbUZ5SUhKbGRDQTlJR1JsYzNRdWQzSnBkR1VvWTJoMWJtc3BPMXh1SUNBZ0lHbG1JQ2htWVd4elpTQTlQVDBnY21WMEtTQjdYRzRnSUNBZ0lDQmtaV0oxWnlnblptRnNjMlVnZDNKcGRHVWdjbVZ6Y0c5dWMyVXNJSEJoZFhObEp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUhOeVl5NWZjbVZoWkdGaWJHVlRkR0YwWlM1aGQyRnBkRVJ5WVdsdUtUdGNiaUFnSUNBZ0lITnlZeTVmY21WaFpHRmliR1ZUZEdGMFpTNWhkMkZwZEVSeVlXbHVLeXM3WEc0Z0lDQWdJQ0J6Y21NdWNHRjFjMlVvS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNBdkx5QnBaaUIwYUdVZ1pHVnpkQ0JvWVhNZ1lXNGdaWEp5YjNJc0lIUm9aVzRnYzNSdmNDQndhWEJwYm1jZ2FXNTBieUJwZEM1Y2JpQWdMeThnYUc5M1pYWmxjaXdnWkc5dUozUWdjM1Z3Y0hKbGMzTWdkR2hsSUhSb2NtOTNhVzVuSUdKbGFHRjJhVzl5SUdadmNpQjBhR2x6TGx4dUlDQm1kVzVqZEdsdmJpQnZibVZ5Y205eUtHVnlLU0I3WEc0Z0lDQWdaR1ZpZFdjb0oyOXVaWEp5YjNJbkxDQmxjaWs3WEc0Z0lDQWdkVzV3YVhCbEtDazdYRzRnSUNBZ1pHVnpkQzV5WlcxdmRtVk1hWE4wWlc1bGNpZ25aWEp5YjNJbkxDQnZibVZ5Y205eUtUdGNiaUFnSUNCcFppQW9SVVV1YkdsemRHVnVaWEpEYjNWdWRDaGtaWE4wTENBblpYSnliM0luS1NBOVBUMGdNQ2xjYmlBZ0lDQWdJR1JsYzNRdVpXMXBkQ2duWlhKeWIzSW5MQ0JsY2lrN1hHNGdJSDFjYmlBZ0x5OGdWR2hwY3lCcGN5QmhJR0p5ZFhSaGJHeDVJSFZuYkhrZ2FHRmpheUIwYnlCdFlXdGxJSE4xY21VZ2RHaGhkQ0J2ZFhJZ1pYSnliM0lnYUdGdVpHeGxjbHh1SUNBdkx5QnBjeUJoZEhSaFkyaGxaQ0JpWldadmNtVWdZVzU1SUhWelpYSnNZVzVrSUc5dVpYTXVJQ0JPUlZaRlVpQkVUeUJVU0VsVExseHVJQ0JwWmlBb0lXUmxjM1F1WDJWMlpXNTBjeUI4ZkNBaFpHVnpkQzVmWlhabGJuUnpMbVZ5Y205eUtWeHVJQ0FnSUdSbGMzUXViMjRvSjJWeWNtOXlKeXdnYjI1bGNuSnZjaWs3WEc0Z0lHVnNjMlVnYVdZZ0tHbHpRWEp5WVhrb1pHVnpkQzVmWlhabGJuUnpMbVZ5Y205eUtTbGNiaUFnSUNCa1pYTjBMbDlsZG1WdWRITXVaWEp5YjNJdWRXNXphR2xtZENodmJtVnljbTl5S1R0Y2JpQWdaV3h6WlZ4dUlDQWdJR1JsYzNRdVgyVjJaVzUwY3k1bGNuSnZjaUE5SUZ0dmJtVnljbTl5TENCa1pYTjBMbDlsZG1WdWRITXVaWEp5YjNKZE8xeHVYRzVjYmx4dUlDQXZMeUJDYjNSb0lHTnNiM05sSUdGdVpDQm1hVzVwYzJnZ2MyaHZkV3hrSUhSeWFXZG5aWElnZFc1d2FYQmxMQ0JpZFhRZ2IyNXNlU0J2Ym1ObExseHVJQ0JtZFc1amRHbHZiaUJ2Ym1Oc2IzTmxLQ2tnZTF4dUlDQWdJR1JsYzNRdWNtVnRiM1psVEdsemRHVnVaWElvSjJacGJtbHphQ2NzSUc5dVptbHVhWE5vS1R0Y2JpQWdJQ0IxYm5CcGNHVW9LVHRjYmlBZ2ZWeHVJQ0JrWlhOMExtOXVZMlVvSjJOc2IzTmxKeXdnYjI1amJHOXpaU2s3WEc0Z0lHWjFibU4wYVc5dUlHOXVabWx1YVhOb0tDa2dlMXh1SUNBZ0lHUmxZblZuS0NkdmJtWnBibWx6YUNjcE8xeHVJQ0FnSUdSbGMzUXVjbVZ0YjNabFRHbHpkR1Z1WlhJb0oyTnNiM05sSnl3Z2IyNWpiRzl6WlNrN1hHNGdJQ0FnZFc1d2FYQmxLQ2s3WEc0Z0lIMWNiaUFnWkdWemRDNXZibU5sS0NkbWFXNXBjMmduTENCdmJtWnBibWx6YUNrN1hHNWNiaUFnWm5WdVkzUnBiMjRnZFc1d2FYQmxLQ2tnZTF4dUlDQWdJR1JsWW5WbktDZDFibkJwY0dVbktUdGNiaUFnSUNCemNtTXVkVzV3YVhCbEtHUmxjM1FwTzF4dUlDQjlYRzVjYmlBZ0x5OGdkR1ZzYkNCMGFHVWdaR1Z6ZENCMGFHRjBJR2wwSjNNZ1ltVnBibWNnY0dsd1pXUWdkRzljYmlBZ1pHVnpkQzVsYldsMEtDZHdhWEJsSnl3Z2MzSmpLVHRjYmx4dUlDQXZMeUJ6ZEdGeWRDQjBhR1VnWm14dmR5QnBaaUJwZENCb1lYTnVKM1FnWW1WbGJpQnpkR0Z5ZEdWa0lHRnNjbVZoWkhrdVhHNGdJR2xtSUNnaGMzUmhkR1V1Wm14dmQybHVaeWtnZTF4dUlDQWdJR1JsWW5WbktDZHdhWEJsSUhKbGMzVnRaU2NwTzF4dUlDQWdJSE55WXk1eVpYTjFiV1VvS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCa1pYTjBPMXh1ZlR0Y2JseHVablZ1WTNScGIyNGdjR2x3WlU5dVJISmhhVzRvYzNKaktTQjdYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0IyWVhJZ2MzUmhkR1VnUFNCemNtTXVYM0psWVdSaFlteGxVM1JoZEdVN1hHNGdJQ0FnWkdWaWRXY29KM0JwY0dWUGJrUnlZV2x1Snl3Z2MzUmhkR1V1WVhkaGFYUkVjbUZwYmlrN1hHNGdJQ0FnYVdZZ0tITjBZWFJsTG1GM1lXbDBSSEpoYVc0cFhHNGdJQ0FnSUNCemRHRjBaUzVoZDJGcGRFUnlZV2x1TFMwN1hHNGdJQ0FnYVdZZ0tITjBZWFJsTG1GM1lXbDBSSEpoYVc0Z1BUMDlJREFnSmlZZ1JVVXViR2x6ZEdWdVpYSkRiM1Z1ZENoemNtTXNJQ2RrWVhSaEp5a3BJSHRjYmlBZ0lDQWdJSE4wWVhSbExtWnNiM2RwYm1jZ1BTQjBjblZsTzF4dUlDQWdJQ0FnWm14dmR5aHpjbU1wTzF4dUlDQWdJSDFjYmlBZ2ZUdGNibjFjYmx4dVhHNVNaV0ZrWVdKc1pTNXdjbTkwYjNSNWNHVXVkVzV3YVhCbElEMGdablZ1WTNScGIyNG9aR1Z6ZENrZ2UxeHVJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbE8xeHVYRzRnSUM4dklHbG1JSGRsSjNKbElHNXZkQ0J3YVhCcGJtY2dZVzU1ZDJobGNtVXNJSFJvWlc0Z1pHOGdibTkwYUdsdVp5NWNiaUFnYVdZZ0tITjBZWFJsTG5CcGNHVnpRMjkxYm5RZ1BUMDlJREFwWEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE03WEc1Y2JpQWdMeThnYW5WemRDQnZibVVnWkdWemRHbHVZWFJwYjI0dUlDQnRiM04wSUdOdmJXMXZiaUJqWVhObExseHVJQ0JwWmlBb2MzUmhkR1V1Y0dsd1pYTkRiM1Z1ZENBOVBUMGdNU2tnZTF4dUlDQWdJQzh2SUhCaGMzTmxaQ0JwYmlCdmJtVXNJR0oxZENCcGRDZHpJRzV2ZENCMGFHVWdjbWxuYUhRZ2IyNWxMbHh1SUNBZ0lHbG1JQ2hrWlhOMElDWW1JR1JsYzNRZ0lUMDlJSE4wWVhSbExuQnBjR1Z6S1Z4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNWNiaUFnSUNCcFppQW9JV1JsYzNRcFhHNGdJQ0FnSUNCa1pYTjBJRDBnYzNSaGRHVXVjR2x3WlhNN1hHNWNiaUFnSUNBdkx5Qm5iM1FnWVNCdFlYUmphQzVjYmlBZ0lDQnpkR0YwWlM1d2FYQmxjeUE5SUc1MWJHdzdYRzRnSUNBZ2MzUmhkR1V1Y0dsd1pYTkRiM1Z1ZENBOUlEQTdYRzRnSUNBZ2MzUmhkR1V1Wm14dmQybHVaeUE5SUdaaGJITmxPMXh1SUNBZ0lHbG1JQ2hrWlhOMEtWeHVJQ0FnSUNBZ1pHVnpkQzVsYldsMEtDZDFibkJwY0dVbkxDQjBhR2x6S1R0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmVnh1WEc0Z0lDOHZJSE5zYjNjZ1kyRnpaUzRnYlhWc2RHbHdiR1VnY0dsd1pTQmtaWE4wYVc1aGRHbHZibk11WEc1Y2JpQWdhV1lnS0NGa1pYTjBLU0I3WEc0Z0lDQWdMeThnY21WdGIzWmxJR0ZzYkM1Y2JpQWdJQ0IyWVhJZ1pHVnpkSE1nUFNCemRHRjBaUzV3YVhCbGN6dGNiaUFnSUNCMllYSWdiR1Z1SUQwZ2MzUmhkR1V1Y0dsd1pYTkRiM1Z1ZER0Y2JpQWdJQ0J6ZEdGMFpTNXdhWEJsY3lBOUlHNTFiR3c3WEc0Z0lDQWdjM1JoZEdVdWNHbHdaWE5EYjNWdWRDQTlJREE3WEc0Z0lDQWdjM1JoZEdVdVpteHZkMmx1WnlBOUlHWmhiSE5sTzF4dVhHNGdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc1pXNDdJR2tyS3lsY2JpQWdJQ0FnSUdSbGMzUnpXMmxkTG1WdGFYUW9KM1Z1Y0dsd1pTY3NJSFJvYVhNcE8xeHVJQ0FnSUhKbGRIVnliaUIwYUdsek8xeHVJQ0I5WEc1Y2JpQWdMeThnZEhKNUlIUnZJR1pwYm1RZ2RHaGxJSEpwWjJoMElHOXVaUzVjYmlBZ2RtRnlJR2tnUFNCcGJtUmxlRTltS0hOMFlYUmxMbkJwY0dWekxDQmtaWE4wS1R0Y2JpQWdhV1lnS0drZ1BUMDlJQzB4S1Z4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dVhHNGdJSE4wWVhSbExuQnBjR1Z6TG5Od2JHbGpaU2hwTENBeEtUdGNiaUFnYzNSaGRHVXVjR2x3WlhORGIzVnVkQ0F0UFNBeE8xeHVJQ0JwWmlBb2MzUmhkR1V1Y0dsd1pYTkRiM1Z1ZENBOVBUMGdNU2xjYmlBZ0lDQnpkR0YwWlM1d2FYQmxjeUE5SUhOMFlYUmxMbkJwY0dWeld6QmRPMXh1WEc0Z0lHUmxjM1F1WlcxcGRDZ25kVzV3YVhCbEp5d2dkR2hwY3lrN1hHNWNiaUFnY21WMGRYSnVJSFJvYVhNN1hHNTlPMXh1WEc0dkx5QnpaWFFnZFhBZ1pHRjBZU0JsZG1WdWRITWdhV1lnZEdobGVTQmhjbVVnWVhOclpXUWdabTl5WEc0dkx5QkZibk4xY21VZ2NtVmhaR0ZpYkdVZ2JHbHpkR1Z1WlhKeklHVjJaVzUwZFdGc2JIa2daMlYwSUhOdmJXVjBhR2x1WjF4dVVtVmhaR0ZpYkdVdWNISnZkRzkwZVhCbExtOXVJRDBnWm5WdVkzUnBiMjRvWlhZc0lHWnVLU0I3WEc0Z0lIWmhjaUJ5WlhNZ1BTQlRkSEpsWVcwdWNISnZkRzkwZVhCbExtOXVMbU5oYkd3b2RHaHBjeXdnWlhZc0lHWnVLVHRjYmx4dUlDQXZMeUJKWmlCc2FYTjBaVzVwYm1jZ2RHOGdaR0YwWVN3Z1lXNWtJR2wwSUdoaGN5QnViM1FnWlhod2JHbGphWFJzZVNCaVpXVnVJSEJoZFhObFpDeGNiaUFnTHk4Z2RHaGxiaUJqWVd4c0lISmxjM1Z0WlNCMGJ5QnpkR0Z5ZENCMGFHVWdabXh2ZHlCdlppQmtZWFJoSUc5dUlIUm9aU0J1WlhoMElIUnBZMnN1WEc0Z0lHbG1JQ2hsZGlBOVBUMGdKMlJoZEdFbklDWW1JR1poYkhObElDRTlQU0IwYUdsekxsOXlaV0ZrWVdKc1pWTjBZWFJsTG1ac2IzZHBibWNwSUh0Y2JpQWdJQ0IwYUdsekxuSmxjM1Z0WlNncE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dWMklEMDlQU0FuY21WaFpHRmliR1VuSUNZbUlIUm9hWE11Y21WaFpHRmliR1VwSUh0Y2JpQWdJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbE8xeHVJQ0FnSUdsbUlDZ2hjM1JoZEdVdWNtVmhaR0ZpYkdWTWFYTjBaVzVwYm1jcElIdGNiaUFnSUNBZ0lITjBZWFJsTG5KbFlXUmhZbXhsVEdsemRHVnVhVzVuSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSE4wWVhSbExtVnRhWFIwWldSU1pXRmtZV0pzWlNBOUlHWmhiSE5sTzF4dUlDQWdJQ0FnYzNSaGRHVXVibVZsWkZKbFlXUmhZbXhsSUQwZ2RISjFaVHRjYmlBZ0lDQWdJR2xtSUNnaGMzUmhkR1V1Y21WaFpHbHVaeWtnZTF4dUlDQWdJQ0FnSUNCMllYSWdjMlZzWmlBOUlIUm9hWE03WEc0Z0lDQWdJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdaR1ZpZFdjb0ozSmxZV1JoWW14bElHNWxlSFIwYVdOcklISmxZV1FnTUNjcE8xeHVJQ0FnSUNBZ0lDQWdJSE5sYkdZdWNtVmhaQ2d3S1R0Y2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSE4wWVhSbExteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0lDQmxiV2wwVW1WaFpHRmliR1VvZEdocGN5d2djM1JoZEdVcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCeVpYTTdYRzU5TzF4dVVtVmhaR0ZpYkdVdWNISnZkRzkwZVhCbExtRmtaRXhwYzNSbGJtVnlJRDBnVW1WaFpHRmliR1V1Y0hKdmRHOTBlWEJsTG05dU8xeHVYRzR2THlCd1lYVnpaU2dwSUdGdVpDQnlaWE4xYldVb0tTQmhjbVVnY21WdGJtRnVkSE1nYjJZZ2RHaGxJR3hsWjJGamVTQnlaV0ZrWVdKc1pTQnpkSEpsWVcwZ1FWQkpYRzR2THlCSlppQjBhR1VnZFhObGNpQjFjMlZ6SUhSb1pXMHNJSFJvWlc0Z2MzZHBkR05vSUdsdWRHOGdiMnhrSUcxdlpHVXVYRzVTWldGa1lXSnNaUzV3Y205MGIzUjVjR1V1Y21WemRXMWxJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSFpoY2lCemRHRjBaU0E5SUhSb2FYTXVYM0psWVdSaFlteGxVM1JoZEdVN1hHNGdJR2xtSUNnaGMzUmhkR1V1Wm14dmQybHVaeWtnZTF4dUlDQWdJR1JsWW5WbktDZHlaWE4xYldVbktUdGNiaUFnSUNCemRHRjBaUzVtYkc5M2FXNW5JRDBnZEhKMVpUdGNiaUFnSUNCcFppQW9JWE4wWVhSbExuSmxZV1JwYm1jcElIdGNiaUFnSUNBZ0lHUmxZblZuS0NkeVpYTjFiV1VnY21WaFpDQXdKeWs3WEc0Z0lDQWdJQ0IwYUdsekxuSmxZV1FvTUNrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsYzNWdFpTaDBhR2x6TENCemRHRjBaU2s3WEc0Z0lIMWNiaUFnY21WMGRYSnVJSFJvYVhNN1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCeVpYTjFiV1VvYzNSeVpXRnRMQ0J6ZEdGMFpTa2dlMXh1SUNCcFppQW9JWE4wWVhSbExuSmxjM1Z0WlZOamFHVmtkV3hsWkNrZ2UxeHVJQ0FnSUhOMFlYUmxMbkpsYzNWdFpWTmphR1ZrZFd4bFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnY0hKdlkyVnpjeTV1WlhoMFZHbGpheWhtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGMzVnRaVjhvYzNSeVpXRnRMQ0J6ZEdGMFpTazdYRzRnSUNBZ2ZTazdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnY21WemRXMWxYeWh6ZEhKbFlXMHNJSE4wWVhSbEtTQjdYRzRnSUhOMFlYUmxMbkpsYzNWdFpWTmphR1ZrZFd4bFpDQTlJR1poYkhObE8xeHVJQ0J6ZEhKbFlXMHVaVzFwZENnbmNtVnpkVzFsSnlrN1hHNGdJR1pzYjNjb2MzUnlaV0Z0S1R0Y2JpQWdhV1lnS0hOMFlYUmxMbVpzYjNkcGJtY2dKaVlnSVhOMFlYUmxMbkpsWVdScGJtY3BYRzRnSUNBZ2MzUnlaV0Z0TG5KbFlXUW9NQ2s3WEc1OVhHNWNibEpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV3WVhWelpTQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQmtaV0oxWnlnblkyRnNiQ0J3WVhWelpTQm1iRzkzYVc1blBTVnFKeXdnZEdocGN5NWZjbVZoWkdGaWJHVlRkR0YwWlM1bWJHOTNhVzVuS1R0Y2JpQWdhV1lnS0daaGJITmxJQ0U5UFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbExtWnNiM2RwYm1jcElIdGNiaUFnSUNCa1pXSjFaeWduY0dGMWMyVW5LVHRjYmlBZ0lDQjBhR2x6TGw5eVpXRmtZV0pzWlZOMFlYUmxMbVpzYjNkcGJtY2dQU0JtWVd4elpUdGNiaUFnSUNCMGFHbHpMbVZ0YVhRb0ozQmhkWE5sSnlrN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUhSb2FYTTdYRzU5TzF4dVhHNW1kVzVqZEdsdmJpQm1iRzkzS0hOMGNtVmhiU2tnZTF4dUlDQjJZWElnYzNSaGRHVWdQU0J6ZEhKbFlXMHVYM0psWVdSaFlteGxVM1JoZEdVN1hHNGdJR1JsWW5WbktDZG1iRzkzSnl3Z2MzUmhkR1V1Wm14dmQybHVaeWs3WEc0Z0lHbG1JQ2h6ZEdGMFpTNW1iRzkzYVc1bktTQjdYRzRnSUNBZ1pHOGdlMXh1SUNBZ0lDQWdkbUZ5SUdOb2RXNXJJRDBnYzNSeVpXRnRMbkpsWVdRb0tUdGNiaUFnSUNCOUlIZG9hV3hsSUNodWRXeHNJQ0U5UFNCamFIVnVheUFtSmlCemRHRjBaUzVtYkc5M2FXNW5LVHRjYmlBZ2ZWeHVmVnh1WEc0dkx5QjNjbUZ3SUdGdUlHOXNaQzF6ZEhsc1pTQnpkSEpsWVcwZ1lYTWdkR2hsSUdGemVXNWpJR1JoZEdFZ2MyOTFjbU5sTGx4dUx5OGdWR2hwY3lCcGN5QXFibTkwS2lCd1lYSjBJRzltSUhSb1pTQnlaV0ZrWVdKc1pTQnpkSEpsWVcwZ2FXNTBaWEptWVdObExseHVMeThnU1hRZ2FYTWdZVzRnZFdkc2VTQjFibVp2Y25SMWJtRjBaU0J0WlhOeklHOW1JR2hwYzNSdmNua3VYRzVTWldGa1lXSnNaUzV3Y205MGIzUjVjR1V1ZDNKaGNDQTlJR1oxYm1OMGFXOXVLSE4wY21WaGJTa2dlMXh1SUNCMllYSWdjM1JoZEdVZ1BTQjBhR2x6TGw5eVpXRmtZV0pzWlZOMFlYUmxPMXh1SUNCMllYSWdjR0YxYzJWa0lEMGdabUZzYzJVN1hHNWNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpPMXh1SUNCemRISmxZVzB1YjI0b0oyVnVaQ2NzSUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUdSbFluVm5LQ2QzY21Gd2NHVmtJR1Z1WkNjcE8xeHVJQ0FnSUdsbUlDaHpkR0YwWlM1a1pXTnZaR1Z5SUNZbUlDRnpkR0YwWlM1bGJtUmxaQ2tnZTF4dUlDQWdJQ0FnZG1GeUlHTm9kVzVySUQwZ2MzUmhkR1V1WkdWamIyUmxjaTVsYm1Rb0tUdGNiaUFnSUNBZ0lHbG1JQ2hqYUhWdWF5QW1KaUJqYUhWdWF5NXNaVzVuZEdncFhHNGdJQ0FnSUNBZ0lITmxiR1l1Y0hWemFDaGphSFZ1YXlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYzJWc1ppNXdkWE5vS0c1MWJHd3BPMXh1SUNCOUtUdGNibHh1SUNCemRISmxZVzB1YjI0b0oyUmhkR0VuTENCbWRXNWpkR2x2YmloamFIVnVheWtnZTF4dUlDQWdJR1JsWW5WbktDZDNjbUZ3Y0dWa0lHUmhkR0VuS1R0Y2JpQWdJQ0JwWmlBb2MzUmhkR1V1WkdWamIyUmxjaWxjYmlBZ0lDQWdJR05vZFc1cklEMGdjM1JoZEdVdVpHVmpiMlJsY2k1M2NtbDBaU2hqYUhWdWF5azdYRzRnSUNBZ2FXWWdLQ0ZqYUhWdWF5QjhmQ0FoYzNSaGRHVXViMkpxWldOMFRXOWtaU0FtSmlBaFkyaDFibXN1YkdWdVozUm9LVnh1SUNBZ0lDQWdjbVYwZFhKdU8xeHVYRzRnSUNBZ2RtRnlJSEpsZENBOUlITmxiR1l1Y0hWemFDaGphSFZ1YXlrN1hHNGdJQ0FnYVdZZ0tDRnlaWFFwSUh0Y2JpQWdJQ0FnSUhCaGRYTmxaQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQnpkSEpsWVcwdWNHRjFjMlVvS1R0Y2JpQWdJQ0I5WEc0Z0lIMHBPMXh1WEc0Z0lDOHZJSEJ5YjNoNUlHRnNiQ0IwYUdVZ2IzUm9aWElnYldWMGFHOWtjeTVjYmlBZ0x5OGdhVzF3YjNKMFlXNTBJSGRvWlc0Z2QzSmhjSEJwYm1jZ1ptbHNkR1Z5Y3lCaGJtUWdaSFZ3YkdWNFpYTXVYRzRnSUdadmNpQW9kbUZ5SUdrZ2FXNGdjM1J5WldGdEtTQjdYRzRnSUNBZ2FXWWdLSFYwYVd3dWFYTkdkVzVqZEdsdmJpaHpkSEpsWVcxYmFWMHBJQ1ltSUhWMGFXd3VhWE5WYm1SbFptbHVaV1FvZEdocGMxdHBYU2twSUh0Y2JpQWdJQ0FnSUhSb2FYTmJhVjBnUFNCbWRXNWpkR2x2YmlodFpYUm9iMlFwSUhzZ2NtVjBkWEp1SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2MzUnlaV0Z0VzIxbGRHaHZaRjB1WVhCd2JIa29jM1J5WldGdExDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lDQWdmWDBvYVNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ0x5OGdjSEp2ZUhrZ1kyVnlkR0ZwYmlCcGJYQnZjblJoYm5RZ1pYWmxiblJ6TGx4dUlDQjJZWElnWlhabGJuUnpJRDBnV3lkbGNuSnZjaWNzSUNkamJHOXpaU2NzSUNka1pYTjBjbTk1Snl3Z0ozQmhkWE5sSnl3Z0ozSmxjM1Z0WlNkZE8xeHVJQ0JtYjNKRllXTm9LR1YyWlc1MGN5d2dablZ1WTNScGIyNG9aWFlwSUh0Y2JpQWdJQ0J6ZEhKbFlXMHViMjRvWlhZc0lITmxiR1l1WlcxcGRDNWlhVzVrS0hObGJHWXNJR1YyS1NrN1hHNGdJSDBwTzF4dVhHNGdJQzh2SUhkb1pXNGdkMlVnZEhKNUlIUnZJR052Ym5OMWJXVWdjMjl0WlNCdGIzSmxJR0o1ZEdWekxDQnphVzF3YkhrZ2RXNXdZWFZ6WlNCMGFHVmNiaUFnTHk4Z2RXNWtaWEpzZVdsdVp5QnpkSEpsWVcwdVhHNGdJSE5sYkdZdVgzSmxZV1FnUFNCbWRXNWpkR2x2YmlodUtTQjdYRzRnSUNBZ1pHVmlkV2NvSjNkeVlYQndaV1FnWDNKbFlXUW5MQ0J1S1R0Y2JpQWdJQ0JwWmlBb2NHRjFjMlZrS1NCN1hHNGdJQ0FnSUNCd1lYVnpaV1FnUFNCbVlXeHpaVHRjYmlBZ0lDQWdJSE4wY21WaGJTNXlaWE4xYldVb0tUdGNiaUFnSUNCOVhHNGdJSDA3WEc1Y2JpQWdjbVYwZFhKdUlITmxiR1k3WEc1OU8xeHVYRzVjYmx4dUx5OGdaWGh3YjNObFpDQm1iM0lnZEdWemRHbHVaeUJ3ZFhKd2IzTmxjeUJ2Ym14NUxseHVVbVZoWkdGaWJHVXVYMlp5YjIxTWFYTjBJRDBnWm5KdmJVeHBjM1E3WEc1Y2JpOHZJRkJzZFdOcklHOW1aaUJ1SUdKNWRHVnpJR1p5YjIwZ1lXNGdZWEp5WVhrZ2IyWWdZblZtWm1WeWN5NWNiaTh2SUV4bGJtZDBhQ0JwY3lCMGFHVWdZMjl0WW1sdVpXUWdiR1Z1WjNSb2N5QnZaaUJoYkd3Z2RHaGxJR0oxWm1abGNuTWdhVzRnZEdobElHeHBjM1F1WEc1bWRXNWpkR2x2YmlCbWNtOXRUR2x6ZENodUxDQnpkR0YwWlNrZ2UxeHVJQ0IyWVhJZ2JHbHpkQ0E5SUhOMFlYUmxMbUoxWm1abGNqdGNiaUFnZG1GeUlHeGxibWQwYUNBOUlITjBZWFJsTG14bGJtZDBhRHRjYmlBZ2RtRnlJSE4wY21sdVowMXZaR1VnUFNBaElYTjBZWFJsTG1SbFkyOWtaWEk3WEc0Z0lIWmhjaUJ2WW1wbFkzUk5iMlJsSUQwZ0lTRnpkR0YwWlM1dlltcGxZM1JOYjJSbE8xeHVJQ0IyWVhJZ2NtVjBPMXh1WEc0Z0lDOHZJRzV2ZEdocGJtY2dhVzRnZEdobElHeHBjM1FzSUdSbFptbHVhWFJsYkhrZ1pXMXdkSGt1WEc0Z0lHbG1JQ2hzYVhOMExteGxibWQwYUNBOVBUMGdNQ2xjYmlBZ0lDQnlaWFIxY200Z2JuVnNiRHRjYmx4dUlDQnBaaUFvYkdWdVozUm9JRDA5UFNBd0tWeHVJQ0FnSUhKbGRDQTlJRzUxYkd3N1hHNGdJR1ZzYzJVZ2FXWWdLRzlpYW1WamRFMXZaR1VwWEc0Z0lDQWdjbVYwSUQwZ2JHbHpkQzV6YUdsbWRDZ3BPMXh1SUNCbGJITmxJR2xtSUNnaGJpQjhmQ0J1SUQ0OUlHeGxibWQwYUNrZ2UxeHVJQ0FnSUM4dklISmxZV1FnYVhRZ1lXeHNMQ0IwY25WdVkyRjBaU0IwYUdVZ1lYSnlZWGt1WEc0Z0lDQWdhV1lnS0hOMGNtbHVaMDF2WkdVcFhHNGdJQ0FnSUNCeVpYUWdQU0JzYVhOMExtcHZhVzRvSnljcE8xeHVJQ0FnSUdWc2MyVmNiaUFnSUNBZ0lISmxkQ0E5SUVKMVptWmxjaTVqYjI1allYUW9iR2x6ZEN3Z2JHVnVaM1JvS1R0Y2JpQWdJQ0JzYVhOMExteGxibWQwYUNBOUlEQTdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdMeThnY21WaFpDQnFkWE4wSUhOdmJXVWdiMllnYVhRdVhHNGdJQ0FnYVdZZ0tHNGdQQ0JzYVhOMFd6QmRMbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdMeThnYW5WemRDQjBZV3RsSUdFZ2NHRnlkQ0J2WmlCMGFHVWdabWx5YzNRZ2JHbHpkQ0JwZEdWdExseHVJQ0FnSUNBZ0x5OGdjMnhwWTJVZ2FYTWdkR2hsSUhOaGJXVWdabTl5SUdKMVptWmxjbk1nWVc1a0lITjBjbWx1WjNNdVhHNGdJQ0FnSUNCMllYSWdZblZtSUQwZ2JHbHpkRnN3WFR0Y2JpQWdJQ0FnSUhKbGRDQTlJR0oxWmk1emJHbGpaU2d3TENCdUtUdGNiaUFnSUNBZ0lHeHBjM1JiTUYwZ1BTQmlkV1l1YzJ4cFkyVW9iaWs3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h1SUQwOVBTQnNhWE4wV3pCZExteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0x5OGdabWx5YzNRZ2JHbHpkQ0JwY3lCaElIQmxjbVpsWTNRZ2JXRjBZMmhjYmlBZ0lDQWdJSEpsZENBOUlHeHBjM1F1YzJocFpuUW9LVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0x5OGdZMjl0Y0d4bGVDQmpZWE5sTGx4dUlDQWdJQ0FnTHk4Z2QyVWdhR0YyWlNCbGJtOTFaMmdnZEc4Z1kyOTJaWElnYVhRc0lHSjFkQ0JwZENCemNHRnVjeUJ3WVhOMElIUm9aU0JtYVhKemRDQmlkV1ptWlhJdVhHNGdJQ0FnSUNCcFppQW9jM1J5YVc1blRXOWtaU2xjYmlBZ0lDQWdJQ0FnY21WMElEMGdKeWM3WEc0Z0lDQWdJQ0JsYkhObFhHNGdJQ0FnSUNBZ0lISmxkQ0E5SUc1bGR5QkNkV1ptWlhJb2JpazdYRzVjYmlBZ0lDQWdJSFpoY2lCaklEMGdNRHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd0xDQnNJRDBnYkdsemRDNXNaVzVuZEdnN0lHa2dQQ0JzSUNZbUlHTWdQQ0J1T3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHSjFaaUE5SUd4cGMzUmJNRjA3WEc0Z0lDQWdJQ0FnSUhaaGNpQmpjSGtnUFNCTllYUm9MbTFwYmlodUlDMGdZeXdnWW5WbUxteGxibWQwYUNrN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0hOMGNtbHVaMDF2WkdVcFhHNGdJQ0FnSUNBZ0lDQWdjbVYwSUNzOUlHSjFaaTV6YkdsalpTZ3dMQ0JqY0hrcE8xeHVJQ0FnSUNBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0FnSUNBZ1luVm1MbU52Y0hrb2NtVjBMQ0JqTENBd0xDQmpjSGtwTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hqY0hrZ1BDQmlkV1l1YkdWdVozUm9LVnh1SUNBZ0lDQWdJQ0FnSUd4cGMzUmJNRjBnUFNCaWRXWXVjMnhwWTJVb1kzQjVLVHRjYmlBZ0lDQWdJQ0FnWld4elpWeHVJQ0FnSUNBZ0lDQWdJR3hwYzNRdWMyaHBablFvS1R0Y2JseHVJQ0FnSUNBZ0lDQmpJQ3M5SUdOd2VUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2NtVjBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxibVJTWldGa1lXSnNaU2h6ZEhKbFlXMHBJSHRjYmlBZ2RtRnlJSE4wWVhSbElEMGdjM1J5WldGdExsOXlaV0ZrWVdKc1pWTjBZWFJsTzF4dVhHNGdJQzh2SUVsbUlIZGxJR2RsZENCb1pYSmxJR0psWm05eVpTQmpiMjV6ZFcxcGJtY2dZV3hzSUhSb1pTQmllWFJsY3l3Z2RHaGxiaUIwYUdGMElHbHpJR0ZjYmlBZ0x5OGdZblZuSUdsdUlHNXZaR1V1SUNCVGFHOTFiR1FnYm1WMlpYSWdhR0Z3Y0dWdUxseHVJQ0JwWmlBb2MzUmhkR1V1YkdWdVozUm9JRDRnTUNsY2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMlZ1WkZKbFlXUmhZbXhsSUdOaGJHeGxaQ0J2YmlCdWIyNHRaVzF3ZEhrZ2MzUnlaV0Z0SnlrN1hHNWNiaUFnYVdZZ0tDRnpkR0YwWlM1bGJtUkZiV2wwZEdWa0tTQjdYRzRnSUNBZ2MzUmhkR1V1Wlc1a1pXUWdQU0IwY25WbE8xeHVJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBdkx5QkRhR1ZqYXlCMGFHRjBJSGRsSUdScFpHNG5kQ0JuWlhRZ2IyNWxJR3hoYzNRZ2RXNXphR2xtZEM1Y2JpQWdJQ0FnSUdsbUlDZ2hjM1JoZEdVdVpXNWtSVzFwZEhSbFpDQW1KaUJ6ZEdGMFpTNXNaVzVuZEdnZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ2MzUmhkR1V1Wlc1a1JXMXBkSFJsWkNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUhOMGNtVmhiUzV5WldGa1lXSnNaU0E5SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0J6ZEhKbFlXMHVaVzFwZENnblpXNWtKeWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1ptOXlSV0ZqYUNBb2VITXNJR1lwSUh0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBc0lHd2dQU0I0Y3k1c1pXNW5kR2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNiaUFnSUNCbUtIaHpXMmxkTENCcEtUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJwYm1SbGVFOW1JQ2g0Y3l3Z2VDa2dlMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkNBOUlIaHpMbXhsYm1kMGFEc2dhU0E4SUd3N0lHa3JLeWtnZTF4dUlDQWdJR2xtSUNoNGMxdHBYU0E5UFQwZ2VDa2djbVYwZFhKdUlHazdYRzRnSUgxY2JpQWdjbVYwZFhKdUlDMHhPMXh1ZlZ4dUlsMTkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5eVpXRmtZV0pzWlMxemRISmxZVzB2Ym05a1pWOXRiMlIxYkdWekwyTnZjbVV0ZFhScGJDMXBjeTlzYVdJdmRYUnBiQzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHk4Z1EyOXdlWEpwWjJoMElFcHZlV1Z1ZEN3Z1NXNWpMaUJoYm1RZ2IzUm9aWElnVG05a1pTQmpiMjUwY21saWRYUnZjbk11WEc0dkwxeHVMeThnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0ZjYmk4dklHTnZjSGtnYjJZZ2RHaHBjeUJ6YjJaMGQyRnlaU0JoYm1RZ1lYTnpiMk5wWVhSbFpDQmtiMk4xYldWdWRHRjBhVzl1SUdacGJHVnpJQ2gwYUdWY2JpOHZJRndpVTI5bWRIZGhjbVZjSWlrc0lIUnZJR1JsWVd3Z2FXNGdkR2hsSUZOdlpuUjNZWEpsSUhkcGRHaHZkWFFnY21WemRISnBZM1JwYjI0c0lHbHVZMngxWkdsdVoxeHVMeThnZDJsMGFHOTFkQ0JzYVcxcGRHRjBhVzl1SUhSb1pTQnlhV2RvZEhNZ2RHOGdkWE5sTENCamIzQjVMQ0J0YjJScFpua3NJRzFsY21kbExDQndkV0pzYVhOb0xGeHVMeThnWkdsemRISnBZblYwWlN3Z2MzVmliR2xqWlc1elpTd2dZVzVrTDI5eUlITmxiR3dnWTI5d2FXVnpJRzltSUhSb1pTQlRiMlowZDJGeVpTd2dZVzVrSUhSdklIQmxjbTFwZEZ4dUx5OGdjR1Z5YzI5dWN5QjBieUIzYUc5dElIUm9aU0JUYjJaMGQyRnlaU0JwY3lCbWRYSnVhWE5vWldRZ2RHOGdaRzhnYzI4c0lITjFZbXBsWTNRZ2RHOGdkR2hsWEc0dkx5Qm1iMnhzYjNkcGJtY2dZMjl1WkdsMGFXOXVjenBjYmk4dlhHNHZMeUJVYUdVZ1lXSnZkbVVnWTI5d2VYSnBaMmgwSUc1dmRHbGpaU0JoYm1RZ2RHaHBjeUJ3WlhKdGFYTnphVzl1SUc1dmRHbGpaU0J6YUdGc2JDQmlaU0JwYm1Oc2RXUmxaRnh1THk4Z2FXNGdZV3hzSUdOdmNHbGxjeUJ2Y2lCemRXSnpkR0Z1ZEdsaGJDQndiM0owYVc5dWN5QnZaaUIwYUdVZ1UyOW1kSGRoY21VdVhHNHZMMXh1THk4Z1ZFaEZJRk5QUmxSWFFWSkZJRWxUSUZCU1QxWkpSRVZFSUZ3aVFWTWdTVk5jSWl3Z1YwbFVTRTlWVkNCWFFWSlNRVTVVV1NCUFJpQkJUbGtnUzBsT1JDd2dSVmhRVWtWVFUxeHVMeThnVDFJZ1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJseHVMeThnVFVWU1EwaEJUbFJCUWtsTVNWUlpMQ0JHU1ZST1JWTlRJRVpQVWlCQklGQkJVbFJKUTFWTVFWSWdVRlZTVUU5VFJTQkJUa1FnVGs5T1NVNUdVa2xPUjBWTlJVNVVMaUJKVGx4dUx5OGdUazhnUlZaRlRsUWdVMGhCVEV3Z1ZFaEZJRUZWVkVoUFVsTWdUMUlnUTA5UVdWSkpSMGhVSUVoUFRFUkZVbE1nUWtVZ1RFbEJRa3hGSUVaUFVpQkJUbGtnUTB4QlNVMHNYRzR2THlCRVFVMUJSMFZUSUU5U0lFOVVTRVZTSUV4SlFVSkpURWxVV1N3Z1YwaEZWRWhGVWlCSlRpQkJUaUJCUTFSSlQwNGdUMFlnUTA5T1ZGSkJRMVFzSUZSUFVsUWdUMUpjYmk4dklFOVVTRVZTVjBsVFJTd2dRVkpKVTBsT1J5QkdVazlOTENCUFZWUWdUMFlnVDFJZ1NVNGdRMDlPVGtWRFZFbFBUaUJYU1ZSSUlGUklSU0JUVDBaVVYwRlNSU0JQVWlCVVNFVmNiaTh2SUZWVFJTQlBVaUJQVkVoRlVpQkVSVUZNU1U1SFV5QkpUaUJVU0VVZ1UwOUdWRmRCVWtVdVhHNWNiaTh2SUU1UFZFVTZJRlJvWlhObElIUjVjR1VnWTJobFkydHBibWNnWm5WdVkzUnBiMjV6SUdsdWRHVnVkR2x2Ym1Gc2JIa2daRzl1SjNRZ2RYTmxJR0JwYm5OMFlXNWpaVzltWUZ4dUx5OGdZbVZqWVhWelpTQnBkQ0JwY3lCbWNtRm5hV3hsSUdGdVpDQmpZVzRnWW1VZ1pXRnphV3g1SUdaaGEyVmtJSGRwZEdnZ1lFOWlhbVZqZEM1amNtVmhkR1VvS1dBdVhHNW1kVzVqZEdsdmJpQnBjMEZ5Y21GNUtHRnlLU0I3WEc0Z0lISmxkSFZ5YmlCQmNuSmhlUzVwYzBGeWNtRjVLR0Z5S1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5CY25KaGVTQTlJR2x6UVhKeVlYazdYRzVjYm1aMWJtTjBhVzl1SUdselFtOXZiR1ZoYmloaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2RpYjI5c1pXRnVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkNiMjlzWldGdUlEMGdhWE5DYjI5c1pXRnVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwNTFiR3dvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ1BUMDlJRzUxYkd3N1hHNTlYRzVsZUhCdmNuUnpMbWx6VG5Wc2JDQTlJR2x6VG5Wc2JEdGNibHh1Wm5WdVkzUnBiMjRnYVhOT2RXeHNUM0pWYm1SbFptbHVaV1FvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ1BUMGdiblZzYkR0Y2JuMWNibVY0Y0c5eWRITXVhWE5PZFd4c1QzSlZibVJsWm1sdVpXUWdQU0JwYzA1MWJHeFBjbFZ1WkdWbWFXNWxaRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTk9kVzFpWlhJb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnWVhKbklEMDlQU0FuYm5WdFltVnlKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTk9kVzFpWlhJZ1BTQnBjMDUxYldKbGNqdGNibHh1Wm5WdVkzUnBiMjRnYVhOVGRISnBibWNvWVhKbktTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdZWEpuSUQwOVBTQW5jM1J5YVc1bkp6dGNibjFjYm1WNGNHOXlkSE11YVhOVGRISnBibWNnUFNCcGMxTjBjbWx1Wnp0Y2JseHVablZ1WTNScGIyNGdhWE5UZVcxaWIyd29ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmMzbHRZbTlzSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5UZVcxaWIyd2dQU0JwYzFONWJXSnZiRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlZibVJsWm1sdVpXUW9ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQmhjbWNnUFQwOUlIWnZhV1FnTUR0Y2JuMWNibVY0Y0c5eWRITXVhWE5WYm1SbFptbHVaV1FnUFNCcGMxVnVaR1ZtYVc1bFpEdGNibHh1Wm5WdVkzUnBiMjRnYVhOU1pXZEZlSEFvY21VcElIdGNiaUFnY21WMGRYSnVJR2x6VDJKcVpXTjBLSEpsS1NBbUppQnZZbXBsWTNSVWIxTjBjbWx1WnloeVpTa2dQVDA5SUNkYmIySnFaV04wSUZKbFowVjRjRjBuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMUpsWjBWNGNDQTlJR2x6VW1WblJYaHdPMXh1WEc1bWRXNWpkR2x2YmlCcGMwOWlhbVZqZENoaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2R2WW1wbFkzUW5JQ1ltSUdGeVp5QWhQVDBnYm5Wc2JEdGNibjFjYm1WNGNHOXlkSE11YVhOUFltcGxZM1FnUFNCcGMwOWlhbVZqZER0Y2JseHVablZ1WTNScGIyNGdhWE5FWVhSbEtHUXBJSHRjYmlBZ2NtVjBkWEp1SUdselQySnFaV04wS0dRcElDWW1JRzlpYW1WamRGUnZVM1J5YVc1bktHUXBJRDA5UFNBblcyOWlhbVZqZENCRVlYUmxYU2M3WEc1OVhHNWxlSEJ2Y25SekxtbHpSR0YwWlNBOUlHbHpSR0YwWlR0Y2JseHVablZ1WTNScGIyNGdhWE5GY25KdmNpaGxLU0I3WEc0Z0lISmxkSFZ5YmlCcGMwOWlhbVZqZENobEtTQW1KbHh1SUNBZ0lDQWdLRzlpYW1WamRGUnZVM1J5YVc1bktHVXBJRDA5UFNBblcyOWlhbVZqZENCRmNuSnZjbDBuSUh4OElHVWdhVzV6ZEdGdVkyVnZaaUJGY25KdmNpazdYRzU5WEc1bGVIQnZjblJ6TG1selJYSnliM0lnUFNCcGMwVnljbTl5TzF4dVhHNW1kVzVqZEdsdmJpQnBjMFoxYm1OMGFXOXVLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0oyWjFibU4wYVc5dUp6dGNibjFjYm1WNGNHOXlkSE11YVhOR2RXNWpkR2x2YmlBOUlHbHpSblZ1WTNScGIyNDdYRzVjYm1aMWJtTjBhVzl1SUdselVISnBiV2wwYVhabEtHRnlaeWtnZTF4dUlDQnlaWFIxY200Z1lYSm5JRDA5UFNCdWRXeHNJSHg4WEc0Z0lDQWdJQ0FnSUNCMGVYQmxiMllnWVhKbklEMDlQU0FuWW05dmJHVmhiaWNnZkh4Y2JpQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkdWRXMWlaWEluSUh4OFhHNGdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmMzUnlhVzVuSnlCOGZGeHVJQ0FnSUNBZ0lDQWdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0ozTjViV0p2YkNjZ2ZId2dJQzh2SUVWVE5pQnplVzFpYjJ4Y2JpQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkMWJtUmxabWx1WldRbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzFCeWFXMXBkR2wyWlNBOUlHbHpVSEpwYldsMGFYWmxPMXh1WEc1bWRXNWpkR2x2YmlCcGMwSjFabVpsY2loaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUVKMVptWmxjaTVwYzBKMVptWmxjaWhoY21jcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzBKMVptWmxjaUE5SUdselFuVm1abVZ5TzF4dVhHNW1kVzVqZEdsdmJpQnZZbXBsWTNSVWIxTjBjbWx1WnlodktTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2J5azdYRzU5SWwxOSIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsImFyZ3VtZW50c1s0XVtcIi9ob21lL3RyZXZvci9jb2RlLWRvdC1vcmcvYXBwcy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzXCJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcblxuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBzY3J1Yl92ZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gR2xvYmFsICgpIHtcbiAgdGhpcy5TQk9YID0gW11cbiAgdGhpcy5JTlZfU0JPWCA9IFtdXG4gIHRoaXMuU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5JTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5SQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG59XG5cbkdsb2JhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGQsIGksIHN4LCB0LCB4LCB4MiwgeDQsIHg4LCB4aSwgX2lcbiAgZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pLCBfcmVzdWx0c1xuICAgIF9yZXN1bHRzID0gW11cbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpIDw8IDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChpIDw8IDEpIF4gMHgxMWIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0c1xuICB9KSgpXG4gIHggPSAwXG4gIHhpID0gMFxuICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICB0aGlzLlNCT1hbeF0gPSBzeFxuICAgIHRoaXMuSU5WX1NCT1hbc3hdID0geFxuICAgIHgyID0gZFt4XVxuICAgIHg0ID0gZFt4Ml1cbiAgICB4OCA9IGRbeDRdXG4gICAgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLlNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLlNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5TVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5TVUJfTUlYWzNdW3hdID0gdFxuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5JTlZfU1VCX01JWFszXVtzeF0gPSB0XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIEcgPSBuZXcgR2xvYmFsKClcblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5cbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuXG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcblxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheSAoYnVmKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC8gNFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBidWZmZXJUb0FycmF5KGtleSlcbiAgdGhpcy5fZG9SZXNldCgpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnZLc1Jvdywga2V5U2l6ZSwga2V5V29yZHMsIGtzUm93LCBrc1Jvd3MsIHRcbiAga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcbiAga3NSb3dzID0gKHRoaXMuX25Sb3VuZHMgKyAxKSAqIDRcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICB0aGlzLl9rZXlTY2hlZHVsZVtrc1Jvd10gPSBrc1JvdyA8IGtleVNpemUgPyBrZXlXb3Jkc1trc1Jvd10gOiAodCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gMV0sIChrc1JvdyAlIGtleVNpemUpID09PSAwID8gKHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCksIHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSwgdCBePSBHLlJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNCkgOiBrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQgPyB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0gOiB2b2lkIDAsIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KVxuICB9XG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gW11cbiAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1Jvd1xuICAgIHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIChpbnZLc1JvdyAlIDQgPyAwIDogNCldXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQgPyB0IDogRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdCA+Pj4gMjRdXSBeIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0ICYgMHhmZl1dXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgdGVtcCA9IFtNWzNdLCBNWzFdXVxuICBNWzFdID0gdGVtcFswXVxuICBNWzNdID0gdGVtcFsxXVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1Yl92ZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2tleSlcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9DcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YKSB7XG4gIHZhciBrc1JvdywgczAsIHMxLCBzMiwgczMsIHQwLCB0MSwgdDIsIHQzXG5cbiAgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAga3NSb3cgPSA0XG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCB0aGlzLl9uUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYWzBdW3MwID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYWzBdW3MxID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYWzBdW3MyID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYWzBdW3MzID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgcmV0dXJuIFtcbiAgICBmaXh1cF91aW50MzIodDApLFxuICAgIGZpeHVwX3VpbnQzMih0MSksXG4gICAgZml4dXBfdWludDMyKHQyKSxcbiAgICBmaXh1cF91aW50MzIodDMpXG4gIF1cbn1cblxuZXhwb3J0cy5BRVMgPSBBRVNcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5amNubHdkRzh0WW5KdmQzTmxjbWxtZVM5dWIyUmxYMjF2WkhWc1pYTXZZbkp2ZDNObGNtbG1lUzFoWlhNdllXVnpMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5OGdZbUZ6WldRZ2IyNGdkR2hsSUdGbGN5QnBiWEJzYVcxbGJuUmhkR2x2YmlCcGJpQjBjbWx3YkdVZ2MyVmpYRzR2THlCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdmEyVjVZbUZ6WlM5MGNtbHdiR1Z6WldOY2JseHVMeThnZDJocFkyZ2dhWE1nYVc0Z2RIVnliaUJpWVhObFpDQnZiaUIwYUdVZ2IyNWxJR1p5YjIwZ1kzSjVjSFJ2TFdwelhHNHZMeUJvZEhSd2N6b3ZMMk52WkdVdVoyOXZaMnhsTG1OdmJTOXdMMk55ZVhCMGJ5MXFjeTljYmx4dWRtRnlJSFZwYm5SZmJXRjRJRDBnVFdGMGFDNXdiM2NvTWl3Z016SXBYRzVtZFc1amRHbHZiaUJtYVhoMWNGOTFhVzUwTXpJZ0tIZ3BJSHRjYmlBZ2RtRnlJSEpsZEN3Z2VGOXdiM05jYmlBZ2NtVjBJRDBnZUNBK0lIVnBiblJmYldGNElIeDhJSGdnUENBd0lEOGdLSGhmY0c5eklEMGdUV0YwYUM1aFluTW9lQ2tnSlNCMWFXNTBYMjFoZUN3Z2VDQThJREFnUHlCMWFXNTBYMjFoZUNBdElIaGZjRzl6SURvZ2VGOXdiM01wSURvZ2VGeHVJQ0J5WlhSMWNtNGdjbVYwWEc1OVhHNW1kVzVqZEdsdmJpQnpZM0oxWWw5MlpXTWdLSFlwSUh0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0IyTG14bGJtZDBhRHNnZGlzcktTQjdYRzRnSUNBZ2RsdHBYU0E5SURCY2JpQWdmVnh1SUNCeVpYUjFjbTRnWm1Gc2MyVmNibjFjYmx4dVpuVnVZM1JwYjI0Z1IyeHZZbUZzSUNncElIdGNiaUFnZEdocGN5NVRRazlZSUQwZ1cxMWNiaUFnZEdocGN5NUpUbFpmVTBKUFdDQTlJRnRkWEc0Z0lIUm9hWE11VTFWQ1gwMUpXQ0E5SUZ0YlhTd2dXMTBzSUZ0ZExDQmJYVjFjYmlBZ2RHaHBjeTVKVGxaZlUxVkNYMDFKV0NBOUlGdGJYU3dnVzEwc0lGdGRMQ0JiWFYxY2JpQWdkR2hwY3k1cGJtbDBLQ2xjYmlBZ2RHaHBjeTVTUTA5T0lEMGdXekI0TURBc0lEQjRNREVzSURCNE1ESXNJREI0TURRc0lEQjRNRGdzSURCNE1UQXNJREI0TWpBc0lEQjROREFzSURCNE9EQXNJREI0TVdJc0lEQjRNelpkWEc1OVhHNWNia2RzYjJKaGJDNXdjbTkwYjNSNWNHVXVhVzVwZENBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RtRnlJR1FzSUdrc0lITjRMQ0IwTENCNExDQjRNaXdnZURRc0lIZzRMQ0I0YVN3Z1gybGNiaUFnWkNBOUlDaG1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdkbUZ5SUY5cExDQmZjbVZ6ZFd4MGMxeHVJQ0FnSUY5eVpYTjFiSFJ6SUQwZ1cxMWNiaUFnSUNCbWIzSWdLR2tnUFNCZmFTQTlJREE3SUY5cElEd2dNalUyT3lCcElEMGdLeXRmYVNrZ2UxeHVJQ0FnSUNBZ2FXWWdLR2tnUENBeE1qZ3BJSHRjYmlBZ0lDQWdJQ0FnWDNKbGMzVnNkSE11Y0hWemFDaHBJRHc4SURFcFhHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCZmNtVnpkV3gwY3k1d2RYTm9LQ2hwSUR3OElERXBJRjRnTUhneE1XSXBYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJmY21WemRXeDBjMXh1SUNCOUtTZ3BYRzRnSUhnZ1BTQXdYRzRnSUhocElEMGdNRnh1SUNCbWIzSWdLR2tnUFNCZmFTQTlJREE3SUY5cElEd2dNalUyT3lCcElEMGdLeXRmYVNrZ2UxeHVJQ0FnSUhONElEMGdlR2tnWGlBb2VHa2dQRHdnTVNrZ1hpQW9lR2tnUER3Z01pa2dYaUFvZUdrZ1BEd2dNeWtnWGlBb2VHa2dQRHdnTkNsY2JpQWdJQ0J6ZUNBOUlDaHplQ0ErUGo0Z09Da2dYaUFvYzNnZ0ppQXdlR1ptS1NCZUlEQjROak5jYmlBZ0lDQjBhR2x6TGxOQ1QxaGJlRjBnUFNCemVGeHVJQ0FnSUhSb2FYTXVTVTVXWDFOQ1QxaGJjM2hkSUQwZ2VGeHVJQ0FnSUhneUlEMGdaRnQ0WFZ4dUlDQWdJSGcwSUQwZ1pGdDRNbDFjYmlBZ0lDQjRPQ0E5SUdSYmVEUmRYRzRnSUNBZ2RDQTlJQ2hrVzNONFhTQXFJREI0TVRBeEtTQmVJQ2h6ZUNBcUlEQjRNVEF4TURFd01DbGNiaUFnSUNCMGFHbHpMbE5WUWw5TlNWaGJNRjFiZUYwZ1BTQW9kQ0E4UENBeU5Da2dmQ0FvZENBK1BqNGdPQ2xjYmlBZ0lDQjBhR2x6TGxOVlFsOU5TVmhiTVYxYmVGMGdQU0FvZENBOFBDQXhOaWtnZkNBb2RDQStQajRnTVRZcFhHNGdJQ0FnZEdocGN5NVRWVUpmVFVsWVd6SmRXM2hkSUQwZ0tIUWdQRHdnT0NrZ2ZDQW9kQ0ErUGo0Z01qUXBYRzRnSUNBZ2RHaHBjeTVUVlVKZlRVbFlXek5kVzNoZElEMGdkRnh1SUNBZ0lIUWdQU0FvZURnZ0tpQXdlREV3TVRBeE1ERXBJRjRnS0hnMElDb2dNSGd4TURBd01Ta2dYaUFvZURJZ0tpQXdlREV3TVNrZ1hpQW9lQ0FxSURCNE1UQXhNREV3TUNsY2JpQWdJQ0IwYUdsekxrbE9WbDlUVlVKZlRVbFlXekJkVzNONFhTQTlJQ2gwSUR3OElESTBLU0I4SUNoMElENCtQaUE0S1Z4dUlDQWdJSFJvYVhNdVNVNVdYMU5WUWw5TlNWaGJNVjFiYzNoZElEMGdLSFFnUER3Z01UWXBJSHdnS0hRZ1BqNCtJREUyS1Z4dUlDQWdJSFJvYVhNdVNVNVdYMU5WUWw5TlNWaGJNbDFiYzNoZElEMGdLSFFnUER3Z09Da2dmQ0FvZENBK1BqNGdNalFwWEc0Z0lDQWdkR2hwY3k1SlRsWmZVMVZDWDAxSldGc3pYVnR6ZUYwZ1BTQjBYRzRnSUNBZ2FXWWdLSGdnUFQwOUlEQXBJSHRjYmlBZ0lDQWdJSGdnUFNCNGFTQTlJREZjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2VDQTlJSGd5SUY0Z1pGdGtXMlJiZURnZ1hpQjRNbDFkWFZ4dUlDQWdJQ0FnZUdrZ1hqMGdaRnRrVzNocFhWMWNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhSeWRXVmNibjFjYmx4dWRtRnlJRWNnUFNCdVpYY2dSMnh2WW1Gc0tDbGNibHh1UVVWVExtSnNiMk5yVTJsNlpTQTlJRFFnS2lBMFhHNWNia0ZGVXk1d2NtOTBiM1I1Y0dVdVlteHZZMnRUYVhwbElEMGdRVVZUTG1Kc2IyTnJVMmw2WlZ4dVhHNUJSVk11YTJWNVUybDZaU0E5SURJMU5pQXZJRGhjYmx4dVFVVlRMbkJ5YjNSdmRIbHdaUzVyWlhsVGFYcGxJRDBnUVVWVExtdGxlVk5wZW1WY2JseHVablZ1WTNScGIyNGdZblZtWm1WeVZHOUJjbkpoZVNBb1luVm1LU0I3WEc0Z0lIWmhjaUJzWlc0Z1BTQmlkV1l1YkdWdVozUm9JQzhnTkZ4dUlDQjJZWElnYjNWMElEMGdibVYzSUVGeWNtRjVLR3hsYmlsY2JpQWdkbUZ5SUdrZ1BTQXRNVnh1SUNCM2FHbHNaU0FvS3l0cElEd2diR1Z1S1NCN1hHNGdJQ0FnYjNWMFcybGRJRDBnWW5WbUxuSmxZV1JWU1c1ME16SkNSU2hwSUNvZ05DbGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IzVjBYRzU5WEc1bWRXNWpkR2x2YmlCQlJWTWdLR3RsZVNrZ2UxeHVJQ0IwYUdsekxsOXJaWGtnUFNCaWRXWm1aWEpVYjBGeWNtRjVLR3RsZVNsY2JpQWdkR2hwY3k1ZlpHOVNaWE5sZENncFhHNTlYRzVjYmtGRlV5NXdjbTkwYjNSNWNHVXVYMlJ2VW1WelpYUWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJSFpoY2lCcGJuWkxjMUp2ZHl3Z2EyVjVVMmw2WlN3Z2EyVjVWMjl5WkhNc0lHdHpVbTkzTENCcmMxSnZkM01zSUhSY2JpQWdhMlY1VjI5eVpITWdQU0IwYUdsekxsOXJaWGxjYmlBZ2EyVjVVMmw2WlNBOUlHdGxlVmR2Y21SekxteGxibWQwYUZ4dUlDQjBhR2x6TGw5dVVtOTFibVJ6SUQwZ2EyVjVVMmw2WlNBcklEWmNiaUFnYTNOU2IzZHpJRDBnS0hSb2FYTXVYMjVTYjNWdVpITWdLeUF4S1NBcUlEUmNiaUFnZEdocGN5NWZhMlY1VTJOb1pXUjFiR1VnUFNCYlhWeHVJQ0JtYjNJZ0tHdHpVbTkzSUQwZ01Ec2dhM05TYjNjZ1BDQnJjMUp2ZDNNN0lHdHpVbTkzS3lzcElIdGNiaUFnSUNCMGFHbHpMbDlyWlhsVFkyaGxaSFZzWlZ0cmMxSnZkMTBnUFNCcmMxSnZkeUE4SUd0bGVWTnBlbVVnUHlCclpYbFhiM0prYzF0cmMxSnZkMTBnT2lBb2RDQTlJSFJvYVhNdVgydGxlVk5qYUdWa2RXeGxXMnR6VW05M0lDMGdNVjBzSUNocmMxSnZkeUFsSUd0bGVWTnBlbVVwSUQwOVBTQXdJRDhnS0hRZ1BTQW9kQ0E4UENBNEtTQjhJQ2gwSUQ0K1BpQXlOQ2tzSUhRZ1BTQW9SeTVUUWs5WVczUWdQajQrSURJMFhTQThQQ0F5TkNrZ2ZDQW9SeTVUUWs5WVd5aDBJRDQrUGlBeE5pa2dKaUF3ZUdabVhTQThQQ0F4TmlrZ2ZDQW9SeTVUUWs5WVd5aDBJRDQrUGlBNEtTQW1JREI0Wm1aZElEdzhJRGdwSUh3Z1J5NVRRazlZVzNRZ0ppQXdlR1ptWFN3Z2RDQmVQU0JITGxKRFQwNWJLR3R6VW05M0lDOGdhMlY1VTJsNlpTa2dmQ0F3WFNBOFBDQXlOQ2tnT2lCclpYbFRhWHBsSUQ0Z05pQW1KaUJyYzFKdmR5QWxJR3RsZVZOcGVtVWdQVDA5SURRZ1B5QjBJRDBnS0VjdVUwSlBXRnQwSUQ0K1BpQXlORjBnUER3Z01qUXBJSHdnS0VjdVUwSlBXRnNvZENBK1BqNGdNVFlwSUNZZ01IaG1abDBnUER3Z01UWXBJSHdnS0VjdVUwSlBXRnNvZENBK1BqNGdPQ2tnSmlBd2VHWm1YU0E4UENBNEtTQjhJRWN1VTBKUFdGdDBJQ1lnTUhobVpsMGdPaUIyYjJsa0lEQXNJSFJvYVhNdVgydGxlVk5qYUdWa2RXeGxXMnR6VW05M0lDMGdhMlY1VTJsNlpWMGdYaUIwS1Z4dUlDQjlYRzRnSUhSb2FYTXVYMmx1ZGt0bGVWTmphR1ZrZFd4bElEMGdXMTFjYmlBZ1ptOXlJQ2hwYm5aTGMxSnZkeUE5SURBN0lHbHVka3R6VW05M0lEd2dhM05TYjNkek95QnBiblpMYzFKdmR5c3JLU0I3WEc0Z0lDQWdhM05TYjNjZ1BTQnJjMUp2ZDNNZ0xTQnBiblpMYzFKdmQxeHVJQ0FnSUhRZ1BTQjBhR2x6TGw5clpYbFRZMmhsWkhWc1pWdHJjMUp2ZHlBdElDaHBiblpMYzFKdmR5QWxJRFFnUHlBd0lEb2dOQ2xkWEc0Z0lDQWdkR2hwY3k1ZmFXNTJTMlY1VTJOb1pXUjFiR1ZiYVc1MlMzTlNiM2RkSUQwZ2FXNTJTM05TYjNjZ1BDQTBJSHg4SUd0elVtOTNJRHc5SURRZ1B5QjBJRG9nUnk1SlRsWmZVMVZDWDAxSldGc3dYVnRITGxOQ1QxaGJkQ0ErUGo0Z01qUmRYU0JlSUVjdVNVNVdYMU5WUWw5TlNWaGJNVjFiUnk1VFFrOVlXeWgwSUQ0K1BpQXhOaWtnSmlBd2VHWm1YVjBnWGlCSExrbE9WbDlUVlVKZlRVbFlXekpkVzBjdVUwSlBXRnNvZENBK1BqNGdPQ2tnSmlBd2VHWm1YVjBnWGlCSExrbE9WbDlUVlVKZlRVbFlXek5kVzBjdVUwSlBXRnQwSUNZZ01IaG1abDFkWEc0Z0lIMWNiaUFnY21WMGRYSnVJSFJ5ZFdWY2JuMWNibHh1UVVWVExuQnliM1J2ZEhsd1pTNWxibU55ZVhCMFFteHZZMnNnUFNCbWRXNWpkR2x2YmlBb1RTa2dlMXh1SUNCTklEMGdZblZtWm1WeVZHOUJjbkpoZVNodVpYY2dRblZtWm1WeUtFMHBLVnh1SUNCMllYSWdiM1YwSUQwZ2RHaHBjeTVmWkc5RGNubHdkRUpzYjJOcktFMHNJSFJvYVhNdVgydGxlVk5qYUdWa2RXeGxMQ0JITGxOVlFsOU5TVmdzSUVjdVUwSlBXQ2xjYmlBZ2RtRnlJR0oxWmlBOUlHNWxkeUJDZFdabVpYSW9NVFlwWEc0Z0lHSjFaaTUzY21sMFpWVkpiblF6TWtKRktHOTFkRnN3WFN3Z01DbGNiaUFnWW5WbUxuZHlhWFJsVlVsdWRETXlRa1VvYjNWMFd6RmRMQ0EwS1Z4dUlDQmlkV1l1ZDNKcGRHVlZTVzUwTXpKQ1JTaHZkWFJiTWwwc0lEZ3BYRzRnSUdKMVppNTNjbWwwWlZWSmJuUXpNa0pGS0c5MWRGc3pYU3dnTVRJcFhHNGdJSEpsZEhWeWJpQmlkV1pjYm4xY2JseHVRVVZUTG5CeWIzUnZkSGx3WlM1a1pXTnllWEIwUW14dlkyc2dQU0JtZFc1amRHbHZiaUFvVFNrZ2UxeHVJQ0JOSUQwZ1luVm1abVZ5Vkc5QmNuSmhlU2h1WlhjZ1FuVm1abVZ5S0UwcEtWeHVJQ0IyWVhJZ2RHVnRjQ0E5SUZ0Tld6TmRMQ0JOV3pGZFhWeHVJQ0JOV3pGZElEMGdkR1Z0Y0Zzd1hWeHVJQ0JOV3pOZElEMGdkR1Z0Y0ZzeFhWeHVJQ0IyWVhJZ2IzVjBJRDBnZEdocGN5NWZaRzlEY25sd2RFSnNiMk5yS0Uwc0lIUm9hWE11WDJsdWRrdGxlVk5qYUdWa2RXeGxMQ0JITGtsT1ZsOVRWVUpmVFVsWUxDQkhMa2xPVmw5VFFrOVlLVnh1SUNCMllYSWdZblZtSUQwZ2JtVjNJRUoxWm1abGNpZ3hOaWxjYmlBZ1luVm1MbmR5YVhSbFZVbHVkRE15UWtVb2IzVjBXekJkTENBd0tWeHVJQ0JpZFdZdWQzSnBkR1ZWU1c1ME16SkNSU2h2ZFhSYk0xMHNJRFFwWEc0Z0lHSjFaaTUzY21sMFpWVkpiblF6TWtKRktHOTFkRnN5WFN3Z09DbGNiaUFnWW5WbUxuZHlhWFJsVlVsdWRETXlRa1VvYjNWMFd6RmRMQ0F4TWlsY2JpQWdjbVYwZFhKdUlHSjFabHh1ZlZ4dVhHNUJSVk11Y0hKdmRHOTBlWEJsTG5OamNuVmlJRDBnWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0J6WTNKMVlsOTJaV01vZEdocGN5NWZhMlY1VTJOb1pXUjFiR1VwWEc0Z0lITmpjblZpWDNabFl5aDBhR2x6TGw5cGJuWkxaWGxUWTJobFpIVnNaU2xjYmlBZ2MyTnlkV0pmZG1WaktIUm9hWE11WDJ0bGVTbGNibjFjYmx4dVFVVlRMbkJ5YjNSdmRIbHdaUzVmWkc5RGNubHdkRUpzYjJOcklEMGdablZ1WTNScGIyNGdLRTBzSUd0bGVWTmphR1ZrZFd4bExDQlRWVUpmVFVsWUxDQlRRazlZS1NCN1hHNGdJSFpoY2lCcmMxSnZkeXdnY3pBc0lITXhMQ0J6TWl3Z2N6TXNJSFF3TENCME1Td2dkRElzSUhRelhHNWNiaUFnY3pBZ1BTQk5XekJkSUY0Z2EyVjVVMk5vWldSMWJHVmJNRjFjYmlBZ2N6RWdQU0JOV3pGZElGNGdhMlY1VTJOb1pXUjFiR1ZiTVYxY2JpQWdjeklnUFNCTld6SmRJRjRnYTJWNVUyTm9aV1IxYkdWYk1sMWNiaUFnY3pNZ1BTQk5Xek5kSUY0Z2EyVjVVMk5vWldSMWJHVmJNMTFjYmlBZ2EzTlNiM2NnUFNBMFhHNGdJR1p2Y2lBb2RtRnlJSEp2ZFc1a0lEMGdNVHNnY205MWJtUWdQQ0IwYUdsekxsOXVVbTkxYm1Sek95QnliM1Z1WkNzcktTQjdYRzRnSUNBZ2REQWdQU0JUVlVKZlRVbFlXekJkVzNNd0lENCtQaUF5TkYwZ1hpQlRWVUpmVFVsWVd6RmRXeWh6TVNBK1BqNGdNVFlwSUNZZ01IaG1abDBnWGlCVFZVSmZUVWxZV3pKZFd5aHpNaUErUGo0Z09Da2dKaUF3ZUdabVhTQmVJRk5WUWw5TlNWaGJNMTFiY3pNZ0ppQXdlR1ptWFNCZUlHdGxlVk5qYUdWa2RXeGxXMnR6VW05M0t5dGRYRzRnSUNBZ2RERWdQU0JUVlVKZlRVbFlXekJkVzNNeElENCtQaUF5TkYwZ1hpQlRWVUpmVFVsWVd6RmRXeWh6TWlBK1BqNGdNVFlwSUNZZ01IaG1abDBnWGlCVFZVSmZUVWxZV3pKZFd5aHpNeUErUGo0Z09Da2dKaUF3ZUdabVhTQmVJRk5WUWw5TlNWaGJNMTFiY3pBZ0ppQXdlR1ptWFNCZUlHdGxlVk5qYUdWa2RXeGxXMnR6VW05M0t5dGRYRzRnSUNBZ2RESWdQU0JUVlVKZlRVbFlXekJkVzNNeUlENCtQaUF5TkYwZ1hpQlRWVUpmVFVsWVd6RmRXeWh6TXlBK1BqNGdNVFlwSUNZZ01IaG1abDBnWGlCVFZVSmZUVWxZV3pKZFd5aHpNQ0ErUGo0Z09Da2dKaUF3ZUdabVhTQmVJRk5WUWw5TlNWaGJNMTFiY3pFZ0ppQXdlR1ptWFNCZUlHdGxlVk5qYUdWa2RXeGxXMnR6VW05M0t5dGRYRzRnSUNBZ2RETWdQU0JUVlVKZlRVbFlXekJkVzNNeklENCtQaUF5TkYwZ1hpQlRWVUpmVFVsWVd6RmRXeWh6TUNBK1BqNGdNVFlwSUNZZ01IaG1abDBnWGlCVFZVSmZUVWxZV3pKZFd5aHpNU0ErUGo0Z09Da2dKaUF3ZUdabVhTQmVJRk5WUWw5TlNWaGJNMTFiY3pJZ0ppQXdlR1ptWFNCZUlHdGxlVk5qYUdWa2RXeGxXMnR6VW05M0t5dGRYRzRnSUNBZ2N6QWdQU0IwTUZ4dUlDQWdJSE14SUQwZ2RERmNiaUFnSUNCek1pQTlJSFF5WEc0Z0lDQWdjek1nUFNCME0xeHVJQ0I5WEc0Z0lIUXdJRDBnS0NoVFFrOVlXM013SUQ0K1BpQXlORjBnUER3Z01qUXBJSHdnS0ZOQ1QxaGJLSE14SUQ0K1BpQXhOaWtnSmlBd2VHWm1YU0E4UENBeE5pa2dmQ0FvVTBKUFdGc29jeklnUGo0K0lEZ3BJQ1lnTUhobVpsMGdQRHdnT0NrZ2ZDQlRRazlZVzNNeklDWWdNSGhtWmwwcElGNGdhMlY1VTJOb1pXUjFiR1ZiYTNOU2IzY3JLMTFjYmlBZ2RERWdQU0FvS0ZOQ1QxaGJjekVnUGo0K0lESTBYU0E4UENBeU5Da2dmQ0FvVTBKUFdGc29jeklnUGo0K0lERTJLU0FtSURCNFptWmRJRHc4SURFMktTQjhJQ2hUUWs5WVd5aHpNeUErUGo0Z09Da2dKaUF3ZUdabVhTQThQQ0E0S1NCOElGTkNUMWhiY3pBZ0ppQXdlR1ptWFNrZ1hpQnJaWGxUWTJobFpIVnNaVnRyYzFKdmR5c3JYVnh1SUNCME1pQTlJQ2dvVTBKUFdGdHpNaUErUGo0Z01qUmRJRHc4SURJMEtTQjhJQ2hUUWs5WVd5aHpNeUErUGo0Z01UWXBJQ1lnTUhobVpsMGdQRHdnTVRZcElId2dLRk5DVDFoYktITXdJRDQrUGlBNEtTQW1JREI0Wm1aZElEdzhJRGdwSUh3Z1UwSlBXRnR6TVNBbUlEQjRabVpkS1NCZUlHdGxlVk5qYUdWa2RXeGxXMnR6VW05M0t5dGRYRzRnSUhReklEMGdLQ2hUUWs5WVczTXpJRDQrUGlBeU5GMGdQRHdnTWpRcElId2dLRk5DVDFoYktITXdJRDQrUGlBeE5pa2dKaUF3ZUdabVhTQThQQ0F4TmlrZ2ZDQW9VMEpQV0Zzb2N6RWdQajQrSURncElDWWdNSGhtWmwwZ1BEd2dPQ2tnZkNCVFFrOVlXM015SUNZZ01IaG1abDBwSUY0Z2EyVjVVMk5vWldSMWJHVmJhM05TYjNjcksxMWNiaUFnY21WMGRYSnVJRnRjYmlBZ0lDQm1hWGgxY0Y5MWFXNTBNeklvZERBcExGeHVJQ0FnSUdacGVIVndYM1ZwYm5Rek1paDBNU2tzWEc0Z0lDQWdabWw0ZFhCZmRXbHVkRE15S0hReUtTeGNiaUFnSUNCbWFYaDFjRjkxYVc1ME16SW9kRE1wWEc0Z0lGMWNibjFjYmx4dVpYaHdiM0owY3k1QlJWTWdQU0JCUlZOY2JpSmRmUT09IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIGtleUxlbiwgaXZMZW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgfVxuICBrZXlMZW4gPSBrZXlMZW4gLyA4XG4gIGl2TGVuID0gaXZMZW4gfHwgMFxuICB2YXIga2kgPSAwXG4gIHZhciBpaSA9IDBcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKVxuICB2YXIgaXYgPSBuZXcgQnVmZmVyKGl2TGVuKVxuICB2YXIgYWRkbWQgPSAwXG4gIHZhciBtZF9idWZcbiAgdmFyIGlcbiAgdmFyIGJ1ZnMgPSBbXVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChhZGRtZCsrID4gMCkge1xuICAgICAgYnVmcy5wdXNoKG1kX2J1ZilcbiAgICB9XG4gICAgYnVmcy5wdXNoKHBhc3N3b3JkKVxuICAgIG1kX2J1ZiA9IG1kNShCdWZmZXIuY29uY2F0KGJ1ZnMpKVxuICAgIGJ1ZnMgPSBbXVxuICAgIGkgPSAwXG4gICAgaWYgKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBrZXlba2krK10gPSBtZF9idWZbaV1cbiAgICAgICAga2V5TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdkxlbiA+IDAgJiYgaSAhPT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGl2TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaXZbaWkrK10gPSBtZF9idWZbaV1cbiAgICAgICAgaXZMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleUxlbiA9PT0gMCAmJiBpdkxlbiA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG1kX2J1Zi5sZW5ndGg7IGkrKykge1xuICAgIG1kX2J1ZltpXSA9IDBcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdlxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpY205M2MyVnlhV1o1TDI1dlpHVmZiVzlrZFd4bGN5OWpjbmx3ZEc4dFluSnZkM05sY21sbWVTOXViMlJsWDIxdlpIVnNaWE12WW5KdmQzTmxjbWxtZVMxaFpYTXZSVlpRWDBKNWRHVnpWRzlMWlhrdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlHMWtOU0E5SUhKbGNYVnBjbVVvSjJOeVpXRjBaUzFvWVhOb0wyMWtOU2NwWEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUVWV1VGOUNlWFJsYzFSdlMyVjVYRzVtZFc1amRHbHZiaUJGVmxCZlFubDBaWE5VYjB0bGVTQW9jR0Z6YzNkdmNtUXNJR3RsZVV4bGJpd2dhWFpNWlc0cElIdGNiaUFnYVdZZ0tDRkNkV1ptWlhJdWFYTkNkV1ptWlhJb2NHRnpjM2R2Y21RcEtTQjdYRzRnSUNBZ2NHRnpjM2R2Y21RZ1BTQnVaWGNnUW5WbVptVnlLSEJoYzNOM2IzSmtMQ0FuWW1sdVlYSjVKeWxjYmlBZ2ZWeHVJQ0JyWlhsTVpXNGdQU0JyWlhsTVpXNGdMeUE0WEc0Z0lHbDJUR1Z1SUQwZ2FYWk1aVzRnZkh3Z01GeHVJQ0IyWVhJZ2Eya2dQU0F3WEc0Z0lIWmhjaUJwYVNBOUlEQmNiaUFnZG1GeUlHdGxlU0E5SUc1bGR5QkNkV1ptWlhJb2EyVjVUR1Z1S1Z4dUlDQjJZWElnYVhZZ1BTQnVaWGNnUW5WbVptVnlLR2wyVEdWdUtWeHVJQ0IyWVhJZ1lXUmtiV1FnUFNBd1hHNGdJSFpoY2lCdFpGOWlkV1pjYmlBZ2RtRnlJR2xjYmlBZ2RtRnlJR0oxWm5NZ1BTQmJYVnh1SUNCM2FHbHNaU0FvZEhKMVpTa2dlMXh1SUNBZ0lHbG1JQ2hoWkdSdFpDc3JJRDRnTUNrZ2UxeHVJQ0FnSUNBZ1luVm1jeTV3ZFhOb0tHMWtYMkoxWmlsY2JpQWdJQ0I5WEc0Z0lDQWdZblZtY3k1d2RYTm9LSEJoYzNOM2IzSmtLVnh1SUNBZ0lHMWtYMkoxWmlBOUlHMWtOU2hDZFdabVpYSXVZMjl1WTJGMEtHSjFabk1wS1Z4dUlDQWdJR0oxWm5NZ1BTQmJYVnh1SUNBZ0lHa2dQU0F3WEc0Z0lDQWdhV1lnS0d0bGVVeGxiaUErSURBcElIdGNiaUFnSUNBZ0lIZG9hV3hsSUNoMGNuVmxLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaHJaWGxNWlc0Z1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQmljbVZoYTF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHbG1JQ2hwSUQwOVBTQnRaRjlpZFdZdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZbkpsWVd0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnJaWGxiYTJrcksxMGdQU0J0WkY5aWRXWmJhVjFjYmlBZ0lDQWdJQ0FnYTJWNVRHVnVMUzFjYmlBZ0lDQWdJQ0FnYVNzclhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNocGRreGxiaUErSURBZ0ppWWdhU0FoUFQwZ2JXUmZZblZtTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnZDJocGJHVWdLSFJ5ZFdVcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0dsMlRHVnVJRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWW5KbFlXdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JwWmlBb2FTQTlQVDBnYldSZlluVm1MbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdKeVpXRnJYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnYVhaYmFXa3JLMTBnUFNCdFpGOWlkV1piYVYxY2JpQWdJQ0FnSUNBZ2FYWk1aVzR0TFZ4dUlDQWdJQ0FnSUNCcEt5dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHdGxlVXhsYmlBOVBUMGdNQ0FtSmlCcGRreGxiaUE5UFQwZ01Da2dlMXh1SUNBZ0lDQWdZbkpsWVd0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnWm05eUlDaHBJRDBnTURzZ2FTQThJRzFrWDJKMVppNXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJRzFrWDJKMVpsdHBYU0E5SURCY2JpQWdmVnh1SUNCeVpYUjFjbTRnZTF4dUlDQWdJR3RsZVRvZ2EyVjVMRnh1SUNBZ0lHbDJPaUJwZGx4dUlDQjlYRzU5WEc0aVhYMD0iLCIndXNlIHN0cmljdCc7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xuXG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9tZDUsIDE2KTtcbn07IiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5YVdaNUwyNXZaR1ZmYlc5a2RXeGxjeTlqY25sd2RHOHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdlkzSmxZWFJsTFdoaGMyZ3ZhR1ZzY0dWeWN5NXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWlkMWMyVWdjM1J5YVdOMEp6dGNiblpoY2lCcGJuUlRhWHBsSUQwZ05EdGNiblpoY2lCNlpYSnZRblZtWm1WeUlEMGdibVYzSUVKMVptWmxjaWhwYm5SVGFYcGxLVHNnZW1WeWIwSjFabVpsY2k1bWFXeHNLREFwTzF4dWRtRnlJR05vY25ONklEMGdPRHRjYmx4dVpuVnVZM1JwYjI0Z2RHOUJjbkpoZVNoaWRXWXNJR0pwWjBWdVpHbGhiaWtnZTF4dUlDQnBaaUFvS0dKMVppNXNaVzVuZEdnZ0pTQnBiblJUYVhwbEtTQWhQVDBnTUNrZ2UxeHVJQ0FnSUhaaGNpQnNaVzRnUFNCaWRXWXViR1Z1WjNSb0lDc2dLR2x1ZEZOcGVtVWdMU0FvWW5WbUxteGxibWQwYUNBbElHbHVkRk5wZW1VcEtUdGNiaUFnSUNCaWRXWWdQU0JDZFdabVpYSXVZMjl1WTJGMEtGdGlkV1lzSUhwbGNtOUNkV1ptWlhKZExDQnNaVzRwTzF4dUlDQjlYRzVjYmlBZ2RtRnlJR0Z5Y2lBOUlGdGRPMXh1SUNCMllYSWdabTRnUFNCaWFXZEZibVJwWVc0Z1B5QmlkV1l1Y21WaFpFbHVkRE15UWtVZ09pQmlkV1l1Y21WaFpFbHVkRE15VEVVN1hHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWW5WbUxteGxibWQwYURzZ2FTQXJQU0JwYm5SVGFYcGxLU0I3WEc0Z0lDQWdZWEp5TG5CMWMyZ29abTR1WTJGc2JDaGlkV1lzSUdrcEtUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z1lYSnlPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjBiMEoxWm1abGNpaGhjbklzSUhOcGVtVXNJR0pwWjBWdVpHbGhiaWtnZTF4dUlDQjJZWElnWW5WbUlEMGdibVYzSUVKMVptWmxjaWh6YVhwbEtUdGNiaUFnZG1GeUlHWnVJRDBnWW1sblJXNWthV0Z1SUQ4Z1luVm1MbmR5YVhSbFNXNTBNekpDUlNBNklHSjFaaTUzY21sMFpVbHVkRE15VEVVN1hHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWVhKeUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdabTR1WTJGc2JDaGlkV1lzSUdGeWNsdHBYU3dnYVNBcUlEUXNJSFJ5ZFdVcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCaWRXWTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHaGhjMmdvWW5WbUxDQm1iaXdnYUdGemFGTnBlbVVzSUdKcFowVnVaR2xoYmlrZ2UxeHVJQ0JwWmlBb0lVSjFabVpsY2k1cGMwSjFabVpsY2loaWRXWXBLU0JpZFdZZ1BTQnVaWGNnUW5WbVptVnlLR0oxWmlrN1hHNGdJSFpoY2lCaGNuSWdQU0JtYmloMGIwRnljbUY1S0dKMVppd2dZbWxuUlc1a2FXRnVLU3dnWW5WbUxteGxibWQwYUNBcUlHTm9jbk42S1R0Y2JpQWdjbVYwZFhKdUlIUnZRblZtWm1WeUtHRnljaXdnYUdGemFGTnBlbVVzSUdKcFowVnVaR2xoYmlrN1hHNTlYRzVsZUhCdmNuUnpMbWhoYzJnZ1BTQm9ZWE5vT3lKZGZRPT0iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiBSaWNoYXJkIEJyZW50J3MgWG9yZ2VucyB4b3I0MDk2IGFsZ29yaXRobS5cbi8vXG4vLyBUaGlzIGZhc3Qgbm9uLWNyeXB0b2dyYXBoaWMgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaXMgZGVzaWduZWQgZm9yXG4vLyB1c2UgaW4gTW9udGUtQ2FybG8gYWxnb3JpdGhtcy4gSXQgY29tYmluZXMgYSBsb25nLXBlcmlvZCB4b3JzaGlmdFxuLy8gZ2VuZXJhdG9yIHdpdGggYSBXZXlsIGdlbmVyYXRvciwgYW5kIGl0IHBhc3NlcyBhbGwgY29tbW9uIGJhdHRlcmllc1xuLy8gb2Ygc3Rhc3RpY2lhbCB0ZXN0cyBmb3IgcmFuZG9tbmVzcyB3aGlsZSBjb25zdW1pbmcgb25seSBhIGZldyBuYW5vc2Vjb25kc1xuLy8gZm9yIGVhY2ggcHJuZyBnZW5lcmF0ZWQuICBGb3IgYmFja2dyb3VuZCBvbiB0aGUgZ2VuZXJhdG9yLCBzZWUgQnJlbnQnc1xuLy8gcGFwZXI6IFwiU29tZSBsb25nLXBlcmlvZCByYW5kb20gbnVtYmVyIGdlbmVyYXRvcnMgdXNpbmcgc2hpZnRzIGFuZCB4b3JzLlwiXG4vLyBodHRwOi8vYXJ4aXYub3JnL3BkZi8xMTA0LjMxMTUucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcjEyOFwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBtZS54IF4gKG1lLnggPDwgMTEpO1xuICAgIG1lLnggPSBtZS55O1xuICAgIG1lLnkgPSBtZS56O1xuICAgIG1lLnogPSBtZS53O1xuICAgIHJldHVybiBtZS53IF49IChtZS53ID4+PiAxOSkgXiB0IF4gKHQgPj4+IDgpO1xuICB9O1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yMTI4ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJUeWNoZS1pXCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqby5cbi8vIFNlZSBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kLCBhID0gbWUuYTtcbiAgICBiID0gKGIgPDwgMjUpIF4gKGIgPj4+IDcpIF4gYztcbiAgICBjID0gKGMgLSBkKSB8IDA7XG4gICAgZCA9IChkIDw8IDI0KSBeIChkID4+PiA4KSBeIGE7XG4gICAgYSA9IChhIC0gYikgfCAwO1xuICAgIG1lLmIgPSBiID0gKGIgPDwgMjApIF4gKGIgPj4+IDEyKSBeIGM7XG4gICAgbWUuYyA9IGMgPSAoYyAtIGQpIHwgMDtcbiAgICBtZS5kID0gKGQgPDwgMTYpIF4gKGMgPj4+IDE2KSBeIGE7XG4gICAgcmV0dXJuIG1lLmEgPSAoYSAtIGIpIHwgMDtcbiAgfTtcblxuICAvKiBUaGUgZm9sbG93aW5nIGlzIG5vbi1pbnZlcnRlZCB0eWNoZSwgd2hpY2ggaGFzIGJldHRlciBpbnRlcm5hbFxuICAgKiBiaXQgZGlmZnVzaW9uLCBidXQgd2hpY2ggaXMgYWJvdXQgMjUlIHNsb3dlciB0aGFuIHR5Y2hlLWkgaW4gSlMuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG1lLmEsIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQ7XG4gICAgYSA9IChtZS5hICsgbWUuYiB8IDApID4+PiAwO1xuICAgIGQgPSBtZS5kIF4gYTsgZCA9IGQgPDwgMTYgXiBkID4+PiAxNjtcbiAgICBjID0gbWUuYyArIGQgfCAwO1xuICAgIGIgPSBtZS5iIF4gYzsgYiA9IGIgPDwgMTIgXiBkID4+PiAyMDtcbiAgICBtZS5hID0gYSA9IGEgKyBiIHwgMDtcbiAgICBkID0gZCBeIGE7IG1lLmQgPSBkID0gZCA8PCA4IF4gZCA+Pj4gMjQ7XG4gICAgbWUuYyA9IGMgPSBjICsgZCB8IDA7XG4gICAgYiA9IGIgXiBjO1xuICAgIHJldHVybiBtZS5iID0gKGIgPDwgNyBeIGIgPj4+IDI1KTtcbiAgfVxuICAqL1xuXG4gIG1lLmEgPSAwO1xuICBtZS5iID0gMDtcbiAgbWUuYyA9IDI2NTQ0MzU3NjkgfCAwO1xuICBtZS5kID0gMTM2NzEzMDU1MTtcblxuICBpZiAoc2VlZCA9PT0gTWF0aC5mbG9vcihzZWVkKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS5hID0gKHNlZWQgLyAweDEwMDAwMDAwMCkgfCAwO1xuICAgIG1lLmIgPSBzZWVkIHwgMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDIwOyBrKyspIHtcbiAgICBtZS5iIF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmEgPSBmLmE7XG4gIHQuYiA9IGYuYjtcbiAgdC5jID0gZi5jO1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy50eWNoZWkgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBBbGVhKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgbWFzaCA9IE1hc2goKTtcblxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogbWUuczAgKyBtZS5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICBtZS5zMCA9IG1lLnMxO1xuICAgIG1lLnMxID0gbWUuczI7XG4gICAgcmV0dXJuIG1lLnMyID0gdCAtIChtZS5jID0gdCB8IDApO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgbWUuYyA9IDE7XG4gIG1lLnMwID0gbWFzaCgnICcpO1xuICBtZS5zMSA9IG1hc2goJyAnKTtcbiAgbWUuczIgPSBtYXNoKCcgJyk7XG4gIG1lLnMwIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMCA8IDApIHsgbWUuczAgKz0gMTsgfVxuICBtZS5zMSAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczEgPCAwKSB7IG1lLnMxICs9IDE7IH1cbiAgbWUuczIgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMyIDwgMCkgeyBtZS5zMiArPSAxOyB9XG4gIG1hc2ggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5jID0gZi5jO1xuICB0LnMwID0gZi5zMDtcbiAgdC5zMSA9IGYuczE7XG4gIHQuczIgPSBmLnMyO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBBbGVhKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0geGcubmV4dDtcbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSAqIDB4MTAwMDAwMDAwKSB8IDA7IH1cbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJuZygpICsgKHBybmcoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2OyAvLyAyXi01M1xuICB9O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuXG4gIHZhciBtYXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG5cbiAgcmV0dXJuIG1hc2g7XG59XG5cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5hbGVhID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvKipcbiAqIEBvdmVydmlldyBDb25zdGFudHMgYW5kIGVudW1zIHVzZWQgYWNyb3NzIEludGVybmV0IFNpbXVsYXRvci5cbiAqL1xuLyoganNoaW50XG4gZnVuY3Njb3BlOiB0cnVlLFxuIG5ld2NhcDogdHJ1ZSxcbiBub25ldzogdHJ1ZSxcbiBzaGFkb3c6IGZhbHNlLFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHN0YXRlbWVudHM6IDIwMFxuICovXG4vKiBnbG9iYWwgZXhwb3J0cyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5CSVRTX1BFUl9OSUJCTEUgPSA0O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5CSVRTX1BFUl9CWVRFID0gODtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydHMuQklUU19QRVJfS0lMT0JZVEUgPSAxMDI0ICogZXhwb3J0cy5CSVRTX1BFUl9CWVRFO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5CSVRTX1BFUl9NRUdBQllURSA9IDEwMjQgKiBleHBvcnRzLkJJVFNfUEVSX0tJTE9CWVRFO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5CSVRTX1BFUl9HSUdBQllURSA9IDEwMjQgKiBleHBvcnRzLkJJVFNfUEVSX01FR0FCWVRFO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5CSVRTX1BFUl9LSUxPQklUID0gMTAyNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydHMuQklUU19QRVJfTUVHQUJJVCA9IDEwMjQgKiBleHBvcnRzLkJJVFNfUEVSX0tJTE9CSVQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5leHBvcnRzLkJJVFNfUEVSX0dJR0FCSVQgPSAxMDI0ICogZXhwb3J0cy5CSVRTX1BFUl9NRUdBQklUO1xuXG4vKipcbiAqIFR5cGVzIG9mIG5vZGVzIHRoYXQgY2FuIHNob3cgdXAgaW4gdGhlIHNpbXVsYXRpb24uXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLk5vZGVUeXBlID0ge1xuICBDTElFTlQ6ICdjbGllbnQnLFxuICBST1VURVI6ICdyb3V0ZXInXG59O1xuXG4vKipcbiAqIFdoYXQgdHlwZSBvZiBtZXNzYWdlIG1ha2VzIHVwIHRoZSAnYXRvbScgb2YgY29tbXVuaWNhdGlvbiBmb3IgdGhpc1xuICogc2ltdWxhdG9yIG1vZGUgLSBzaW5nbGUtYml0IG1lc3NhZ2VzICh2YXJpYW50IDEpIG9yIHdob2xlIHBhY2tldHMgKHZhcmlhbnRzXG4gKiAyIGFuZCB1cClcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuTWVzc2FnZUdyYW51bGFyaXR5ID0ge1xuICBQQUNLRVRTOiAncGFja2V0cycsXG4gIEJJVFM6ICdiaXRzJ1xufTtcblxuLyoqXG4gKiBETlMgbW9kZXMgZm9yIHRoZSBzaW11bGF0b3IuICBPbmx5IGFwcGxpZXMgaW4gdmFyaWFudCAzLCB3aGVuIGNvbm5lY3RpbmdcbiAqIHRvIGEgcm91dGVyLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5EbnNNb2RlID0ge1xuICAvKiogVGhlcmUgaXMgbm8gRE5TIG5vZGUuICBFdmVyeW9uZSBjYW4gc2VlIGV2ZXJ5IG90aGVyIG5vZGUncyBhZGRyZXNzLiAqL1xuICBOT05FOiAnbm9uZScsXG5cbiAgLyoqIE9uZSB1c2VyIGFjdHMgYXMgdGhlIEROUyBub2RlIGF0IGEgdGltZS4gIEV2ZXJ5b25lIGNhbiBzZWUgdGhlaXIgb3duXG4gICAqICBhZGRyZXNzIGFuZCB0aGUgRE5TIG5vZGUncyBhZGRyZXNzLCBidXQgbm90aGluZyBlbHNlLiAqL1xuICBNQU5VQUw6ICdtYW51YWwnLFxuXG4gIC8qKiBBbiBhdXRvbWF0aWMgRE5TIG5vZGUgaXMgYWRkZWQgdG8gdGhlIHNpbXVsYXRpb24uICBOb2RlcyBhcmUgYXV0b21hdGljYWxseVxuICAgKiAgcmVnaXN0ZXJlZCB3aXRoIHRoZSBETlMgb24gY29ubmVjdGlvbi4gKi9cbiAgQVVUT01BVElDOiAnYXV0b21hdGljJ1xufTtcblxuLyoqXG4gKiBFbmNvZGluZ3MgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnRlcnByZXQgYW5kIGRpc3BsYXkgYmluYXJ5IG1lc3NhZ2VzIGluXG4gKiB0aGUgc2ltdWxhdG9yLlxuICogTWFwIHRvIGNsYXNzLW5hbWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gcmVsYXRlZCB0YWJsZSByb3dzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5FbmNvZGluZ1R5cGUgPSB7XG4gIC8qKiBSZW5kZXJzIGVhY2ggY2h1bmsgb2YgYml0cyAodXNpbmcgdmFyaWFibGUgY2h1bmtzaXplKSBpbiBhc2NpaSAqL1xuICBBU0NJSTogJ2FzY2lpJyxcblxuICAvKiogUmVuZGVycyBlYWNoIGNodW5rIG9mIGJpdHMgKHVzaW5nIHZhcmlhYmxlIGNodW5rc2l6ZSkgaW4gZGVjaW1hbCAqL1xuICBERUNJTUFMOiAnZGVjaW1hbCcsXG5cbiAgLyoqIFJlbmRlcnMgZWFjaCBiaW5hcnkgbmliYmxlIGFzIGEgaGV4IGNoYXJhY3Rlci4gKi9cbiAgSEVYQURFQ0lNQUw6ICdoZXhhZGVjaW1hbCcsXG5cbiAgLyoqIEFsbCBwYWNrZXQgZGF0YSBpcyBhY3R1YWxseSBzdG9yZWQgYW5kIG1vdmVkIGFyb3VuZCBpbiBiaW5hcnksIHNvXG4gICAqICB0aGUgJ2JpbmFyeScgZW5jb2RpbmcganVzdCByZXByZXNlbnRzIGFjY2VzcyB0byB0aGF0IHJhdyBkYXRhLiAqL1xuICBCSU5BUlk6ICdiaW5hcnknLFxuXG4gIC8qKiBBbiBlbmNvZGluZyB1c2VkIGVhcmx5IGluIHRoZSBsZXNzb25zIHRvIHNob3cgdGhhdCBiaW5hcnkgaXNuJ3QgYWx3YXlzXG4gICAqICAxcyBhbmQgMHMuICBKdXN0IGxpa2UgYmluYXJ5LCBidXQgcmVwbGFjZXMgMS8wIHdpdGggQS9CLiAqL1xuICBBX0FORF9COiAnYV9hbmRfYidcbn07XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgdGFicyBmb3IgbGV2ZWwgY29uZmlndXJhdGlvblxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5OZXRTaW1UYWJUeXBlID0ge1xuICBJTlNUUlVDVElPTlM6ICdpbnN0cnVjdGlvbnMnLFxuICBNWV9ERVZJQ0U6ICdteV9kZXZpY2UnLFxuICBST1VURVI6ICdyb3V0ZXInLFxuICBETlM6ICdkbnMnXG59O1xuXG4vKipcbiAqIENvbHVtbiB0eXBlcyB0aGF0IGNhbiBiZSB1c2VkIGFueSB0aW1lIGEgcGFja2V0IGlzIGRpc3BsYXllZCBvbiB0aGUgcGFnZS5cbiAqIFJlbGF0ZWQgdG8gUGFja2V0LkhlYWRlclR5cGUsIGJ1dCBkaWZmZXJlbnQgYmVjYXVzZSB0aGlzIGluY2x1ZGVzIGNvbHVtbnNcbiAqIHRoYXQgYXJlbid0IHBhcnQgb2YgdGhlIGhlYWRlciwgYW5kIGdyb3VwcyB0aGUgcGFja2V0SW5mbyB0b2dldGhlci5cbiAqIE1hcCB0byBjbGFzcy1uYW1lcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHJlbGF0ZWQgdGFibGUgY2VsbHMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLlBhY2tldFVJQ29sdW1uVHlwZSA9IHtcbiAgRU5DT0RJTkdfTEFCRUw6ICdlbmNvZGluZ0xhYmVsJyxcbiAgVE9fQUREUkVTUzogJ3RvQWRkcmVzcycsXG4gIEZST01fQUREUkVTUzogJ2Zyb21BZGRyZXNzJyxcbiAgUEFDS0VUX0lORk86ICdwYWNrZXRJbmZvJyxcbiAgTUVTU0FHRTogJ21lc3NhZ2UnXG59O1xuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgSW50ZXJmYWNlIHRvIGRhc2hib2FyZCB1c2VyIGRhdGEgQVBJLlxuICovXG5cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWN0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgLSBTZWN0aW9uJ3MgbnVtZXJpYyBpZGVudGlmaWVyIGluIERhc2hib2FyZC5cbiAqL1xuXG4vLyBUT0RPIChiYnVjaGFuYW4pOiBUaGlzIHdob2xlIGZpbGUgc2hvdWxkIGdvIGF3YXkgd2hlbiB3ZSBoYXZlIGEgc2hhcmVkXG4vLyAgICAgICAgICAgICAgICAgICBKYXZhc2NyaXB0IFVzZXIgb2JqZWN0IHRoYXQgY2FuIGJlIGF2YWlsYWJsZSBvbiBwYWdlIGxvYWQuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIERhc2hib2FyZCB1c2VyIGFjY291bnQgLSBjb3VsZCBiZSBhIHRlYWNoZXIsIGEgc3R1ZGVudCwgZXRjLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXNoYm9hcmRVc2VyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYXN5bmMgY2FsbCBoYXMgY29tcGxldGVkIHlldC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcblxuICAvKipcbiAgICogUXVldWUgb2YgY2FsbGJhY2tzIHRvIGhpdCB3aGVuIHRoaXMgb2JqZWN0IGdldHMgaW5pdGlhbGl6ZWQuXG4gICAqIEB0eXBlIHtmdW5jdGlvbltdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy53aGVuUmVhZHlDYWxsYmFja3NfID0gW107XG5cbiAgLyoqXG4gICAqIFVzZXIgSURcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFVzZXIgZGlzcGxheSBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm5hbWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGEgc2l0ZSBhZG1pbi5cbiAgICogTk9URTogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIGEgY29udmVuaWVuY2UvZGlzcGxheSBzZW5zZTsgYW55dGhpbmdcbiAgICogICAgICAgcmVxdWlyaW5nIGFjdHVhbCBzZWN1cml0eSBzaG91bGQgYmUgYXV0aGVudGljYXRlZCB0aHJvdWdoIHRoZSBzZXJ2ZXIsXG4gICAqICAgICAgIGFuZCBub3QgZGVwZW5kIG9uIGNsaWVudCBjb2RlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNBZG1pbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHNlY3Rpb25zIG93bmVkIGJ5IHRoaXMgdXNlci5cbiAgICogQHR5cGUge1NlY3Rpb25bXX1cbiAgICovXG4gIHRoaXMub3duZWRTZWN0aW9ucyA9IFtdO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7RGFzaGJvYXJkVXNlcn1cbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cbkRhc2hib2FyZFVzZXIuY3VycmVudFVzZXJfID0gbnVsbDtcblxuLyoqXG4gKiBLaWNrIG9mIGFuIGFzeW5jaHJvbm91cyByZXF1ZXN0IGZvciB0aGUgY3VycmVudCB1c2VyJ3MgZGF0YSwgYW5kIGltbWVkaWF0ZWx5XG4gKiBwYXNzIGJhY2sgYSBwbGFjZWhvbGRlciBvYmplY3QgdGhhdCBoYXMgYSB3aGVuUmVhZHkgbWV0aG9kIG90aGVycyBjYW5cbiAqIHVzZSB0byBndWFyYW50ZWUgdGhlIGRhdGEgaXMgcHJlc2VudC5cbiAqXG4gKiBAcmV0dXJuIHtEYXNoYm9hcmRVc2VyfSB0aGF0IGRvZXNuJ3QgaGF2ZSBpdHMgZGF0YSB5ZXQsIGJ1dCB3aWxsIHNvb24uXG4gKi9cbkRhc2hib2FyZFVzZXIuZ2V0Q3VycmVudFVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghRGFzaGJvYXJkVXNlci5jdXJyZW50VXNlcl8pIHtcbiAgICBEYXNoYm9hcmRVc2VyLmN1cnJlbnRVc2VyXyA9IG5ldyBEYXNoYm9hcmRVc2VyKCk7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy92Mi91c2VyJyxcbiAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhIC8qLCB0ZXh0U3RhdHVzLCBqcVhIUiovKSB7XG4gICAgICAgIERhc2hib2FyZFVzZXIuY3VycmVudFVzZXJfLmluaXRpYWxpemUoZGF0YSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uICgvKmpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biovKSB7XG4gICAgICAgIERhc2hib2FyZFVzZXIuY3VycmVudFVzZXJfLmluaXRpYWxpemUoe1xuICAgICAgICAgIGlzU2lnbmVkSW46IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBEYXNoYm9hcmRVc2VyLmN1cnJlbnRVc2VyXztcbn07XG5cbi8qKlxuICogTG9hZCBkYXRhIGludG8gdXNlciBmcm9tIGFzeW5jIHJlcXVlc3QsIHdoZW4gcmVhZHkuXG4gKiBAcGFyYW0gZGF0YVxuICovXG5EYXNoYm9hcmRVc2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgdGhpcy5pc0FkbWluID0gKGRhdGEuYWRtaW4gPT09IHRydWUpO1xuICB0aGlzLm93bmVkU2VjdGlvbnMgPSBkYXRhLm93bmVkX3NlY3Rpb25zO1xuICB0aGlzLmlzU2lnbmVkSW4gPSBkYXRhLmlzU2lnbmVkSW4gIT09IGZhbHNlO1xuICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuXG4gIC8vIENhbGwgYW55IHF1ZXVlZCBjYWxsYmFja3NcbiAgdGhpcy53aGVuUmVhZHlDYWxsYmFja3NfLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGhpcyk7XG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMud2hlblJlYWR5Q2FsbGJhY2tzXy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBQcm92aWRlIGNvZGUgdG8gYmUgY2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgcmVhZHkgdG8gdXNlXG4gKiBQb3NzaWJsZSBmb3IgaXQgdG8gYmUgY2FsbGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkRhc2hib2FyZFVzZXIucHJvdG90eXBlLndoZW5SZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodGhpcy5pc1JlYWR5KSB7XG4gICAgY2FsbGJhY2sodGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53aGVuUmVhZHlDYWxsYmFja3NfLnB1c2goY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBvd25zIHRoZSBzZWN0aW9uIHdpdGggdGhlIGdpdmVuIHNlY3Rpb24gSUQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VjdGlvbklEXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuRGFzaGJvYXJkVXNlci5wcm90b3R5cGUub3duc1NlY3Rpb24gPSBmdW5jdGlvbiAoc2VjdGlvbklEKSB7XG4gIHJldHVybiB0aGlzLm93bmVkU2VjdGlvbnMuc29tZShmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgIHJldHVybiBzZWN0aW9uLmlkID09PSBzZWN0aW9uSUQ7XG4gIH0pO1xufTtcbiIsIi8qKlxuICogQG92ZXJ2aWV3IFV0aWxpdGllcyBmb3IgdmFsaWRhdGluZyBhbmQgcmV0cmlldmluZyBhcmd1bWVudHMgdG8gYSBtZXRob2QuXG4gKi9cbi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDQsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBwcm92aWRlZCBhbmQgcGFzc2VzIHRoZSB2YWxpZGF0aW9uIGNoZWNrLlxuICogQHBhcmFtIHs/fSBhcmcgLSB0aGUgYXJndW1lbnQgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7IXN0cmluZ30gYXJnTmFtZSAtIEFyZ3VtZW50IG5hbWUgKGZvciB1c2VmdWwgZXJyb3IgcmVwb3J0aW5nKVxuICogQHBhcmFtIHtmdW5jdGlvbig/KX0gW3ZhbGlkYXRvcl0gLSB2YWxpZGF0aW9uIGNoZWNrIHRvIHJ1biBvbiB0aGUgYXJndW1lbnQuXG4gKiAgICAgICAgRGVmYXVsdHMgdG8gbm8gY2hlY2sgKGFueXRoaW5nIHBhc3NlcykuXG4gKiBAcmV0dXJucyB7P30gdGhlIG9yaWdpbmFsIGFyZ3VtZW50LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB0aGUgYXJndW1lbnQgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5leHBvcnRzLnZhbGlkYXRlUmVxdWlyZWQgPSBmdW5jdGlvbiAoYXJnLCBhcmdOYW1lLCB2YWxpZGF0b3IpIHtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhcmdOYW1lICsgJyBpcyByZXF1aXJlZC4nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsaWRhdG9yID09PSAnZnVuY3Rpb24nICYmICF2YWxpZGF0b3IoYXJnKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgJyArIGFyZ05hbWUgKyAnIHRvICcgKyBhcmcgKyAnLicpO1xuICB9XG4gIHJldHVybiBhcmc7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gb3B0aW9uIGdldHRlciB0byB0aGUgcHJvdmlkZWQgb3B0aW9ucyBPYmplY3QgdGhhdCB2YWxpZGF0ZXNcbiAqIHRoZSBwYXNzZWQgYXJndW1lbnRzIGFuZCBjYW4gcHJvdmlkZSBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zT2JqZWN0IC0gdGhlIHJhdyBvcHRpb25zIG9iamVjdC4gIE1heSBiZSBwYXNzZWRcbiAqICAgICAgICB1bmRlZmluZWQgKGFzIGluIGFuIG9taXR0ZWQgb3B0aW9ucyBvYmplY3QpIGJ1dCBtdXN0IG5vdCBiZSBudWxsXG4gKiAgICAgICAgb3IgYSBub24tb2JqZWN0IHR5cGUuICBOb3QgbW9kaWZpZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGF0IGluY2x1ZGVzIGEgYGdldGAgbWV0aG9kLiAgV2lsbCBiZSBhbiBvYmplY3RcbiAqICAgICAgICAgIGV2ZW4gaWYgb3JpZ2luYWwgb3B0aW9uc09iamVjdCBhcmd1bWVudCB3YXMgdW5kZWZpbmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBhIG5vbi1vYmplY3QgaXMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBleHRlbmRpbmcgdGhlIG9iamVjdCB3b3VsZCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgcHJvcGVydHkuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kT3B0aW9uc09iamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zT2JqZWN0KSB7XG4gIC8vIEFsbG93IGB1bmRlZmluZWRgIGFuZCBhbGwgb2JqZWN0cyBleGNlcHQgZm9yIGBudWxsYFxuICB2YXIgaXNVbmRlZmluZWQgPSAob3B0aW9uc09iamVjdCA9PT0gdW5kZWZpbmVkKTtcbiAgdmFyIGlzUmVhbE9iamVjdCA9ICh0eXBlb2Ygb3B0aW9uc09iamVjdCA9PT0gJ29iamVjdCcgJiYgb3B0aW9uc09iamVjdCAhPT0gbnVsbCk7XG4gIGlmICghKGlzVW5kZWZpbmVkIHx8IGlzUmVhbE9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcHRpb25zIG9iamVjdCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zT2JqZWN0ICYmIG9wdGlvbnNPYmplY3QuaGFzT3duUHJvcGVydHkoJ2dldCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIG9wdGlvbnM7IHByb3BlcnR5IFwiZ2V0XCIgd291bGQgYmUgb3ZlcndyaXR0ZW4uJyk7XG4gIH1cblxuICByZXR1cm4gJC5leHRlbmQoe30sIG9wdGlvbnNPYmplY3QsIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbiBvcHRpb25hbCB2YWx1ZSBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCwgcGFzc2luZyBpdCB0aHJvdWdoIHRoZVxuICAgICAqIHByb3ZpZGVkIHZhbGlkYXRpb24gZnVuY3Rpb24sIGFuZCByZXR1cm5pbmcgdGhlIGdpdmVuIGRlZmF1bHQgdmFsdWUgaWZcbiAgICAgKiB0aGUgcmVxdWVzdGVkIG9wdGlvbiB3YXMgbm90IHNldC5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IG9wdGlvbktleSAtIG5hbWUgb2YgdGhlIG9wdGlvbiBpbiB0aGUgcmF3IG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyl9IFt2YWxpZGF0b3JdIC0gdmFsaWRhdGlvbiBjaGVjayB0byBydW4gb24gdGhlIHZhbHVlLFxuICAgICAqICAgICAgICBpZiBpdCBoYXMgYmVlbiBzZXQuICBTaG91bGQgcmV0dXJuIFRSVUUgaWYgdmFsaWQgYW5kIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKiAgICAgICAgRGVmYXVsdHMgdG8gbm8gY2hlY2sgKGFueXRoaW5nIHBhc3NlcykuXG4gICAgICogQHBhcmFtIHs/fSBbZGVmYXVsdFZhbHVlXSAtIFdoYXQgdG8gcmV0dXJuIGlmIHRoZSBvcHRpb24gd2FzIG5vdCBzZXQuXG4gICAgICogICAgICAgIERlZmF1bHRzIHRvIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHs/fSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBpZiBpdCB3YXMgc2V0LCBhbmQgdGhlIHByb3ZpZGVkXG4gICAgICogICAgICAgICAgZGVmYXVsdCB2YWx1ZSBpZiBpdCB3YXMgbm90IHNldC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb24gcmV0dXJucyBGQUxTRSB3aGVuIGNhbGxlZFxuICAgICAqICAgICAgICAgb24gdGhlIG9wdGlvbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIChvcHRpb25LZXksIHZhbGlkYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBpZiAoIW9wdGlvbnNPYmplY3QgfHwgb3B0aW9uc09iamVjdFtvcHRpb25LZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgPT09ICdmdW5jdGlvbicgJiYgIXZhbGlkYXRvcihvcHRpb25zT2JqZWN0W29wdGlvbktleV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgJyArIG9wdGlvbktleSArICcgdG8gJyArXG4gICAgICAgICAgICBvcHRpb25zT2JqZWN0W29wdGlvbktleV0gKyAnLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uc09iamVjdFtvcHRpb25LZXldO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgdmVyaWZpZXMgdGhhdCB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGlzXG4gKiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVybywgYW5kIGlzIG5vdCBJbmZpbml0eS5cbiAqIEBwYXJhbSBhcmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHByb3ZpZGVkIGFyZ3VtZW50IGlzIHZhbGlkLlxuICogQHN0YXRpY1xuICovXG5leHBvcnRzLmlzUG9zaXRpdmVOb25pbmZpbml0ZU51bWJlciA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICYmXG4gICAgICAhaXNOYU4oYXJnKSAmJlxuICAgICAgYXJnID49IDAgJiZcbiAgICAgIGFyZyAhPT0gSW5maW5pdHk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHZlcmlmaWVzIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpc1xuICogZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8sIGFuZCBpcyBub3QgSW5maW5pdHkuXG4gKiBAcGFyYW0gez99IGFyZ1xuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgcHJvdmlkZWQgYXJndW1lbnQgaXMgdmFsaWQuXG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuaXNCb29sZWFuID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0b3IgZnVuY3Rpb24gdGhhdCB2ZXJpZmllcyB0aGF0IHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7P30gYXJnXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVFJVRSBpZiBwcm92aWRlZCBhcmd1bWVudCBpcyB2YWxpZC5cbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0b3IgZnVuY3Rpb24gdGhhdCB2ZXJpZmllcyB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkuXG4gKiBTdXJlIHRoaXMgc2VlbXMgcmVkdW5kYW50LCBidXQgaW5jbHVkZWQgaGVyZSBmb3IgZGlzY292ZXJhYmlsaXR5LlxuICogQHBhcmFtIHs/fSBhcmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBUUlVFIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudCBpcyBhbiBhcnJheS5cbiAqL1xuZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0b3IgZnVuY3Rpb24gdGhhdCB2ZXJpZmllcyB0aGF0IGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gez99IGFyZ1xuICogQHJldHVybnMge2Jvb2xlYW59IFRSVUUgaWYgcHJvdmlkZWQgYXJndW1lbnQgaXMgYW4gYXJyYXkgYW5kIGV2ZXJ5IGVsZW1lbnRcbiAqICAgICAgICAgIGluIHRoZSBhcnJheSBpcyBhIHN0cmluZy5cbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5pc0FycmF5T2ZTdHJpbmdzID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5ldmVyeShleHBvcnRzLmlzU3RyaW5nKTtcbn07XG4iLCIvKiBqc2hpbnRcbiBmdW5jc2NvcGU6IHRydWUsXG4gbmV3Y2FwOiB0cnVlLFxuIG5vbmV3OiB0cnVlLFxuIHNoYWRvdzogZmFsc2UsXG4gdW51c2VkOiB0cnVlLFxuXG4gbWF4bGVuOiA5MCxcbiBtYXhwYXJhbXM6IDMsXG4gbWF4c3RhdGVtZW50czogMjAwXG4gKi9cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE9ic2VydmFibGVFdmVudCA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZUV2ZW50Jyk7XG5cbi8vIEl0IGlzIG1vcmUgYWNjdXJhdGUgdG8gdXNlIHBlcmZvcm1hbmNlLm5vdygpLCBidXQgd2UgdXNlIERhdGUubm93KClcbi8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggU2FmYXJpIGFuZCBvbGRlciBicm93c2Vycy4gVGhpcyBzaG91bGQgb25seSBjYXVzZVxuLy8gYSBzbWFsbCBlcnJvciBpbiB0aGUgZGVsdGFUaW1lIGZvciB0aGUgaW5pdGlhbCBmcmFtZSBhbnl3YXkuXG4vLyBTZWUgQWxzbzpcbi8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbi8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlLm5vd1xudmFyIHdpbmRvd05vdyA9ICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdykgP1xuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3c7XG5cbi8qKlxuICogSG93IG1hbnkgdGlja3Mgd2UgdHJ5IHRvIGZpcmUgZXZlcnkgc2Vjb25kLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgUFJFRkVSUkVEX1RJQ0tTX1BFUl9TRUNPTkQgPSAxMDtcblxuLyoqXG4gKiBQcmVjYWxjdWxhdGVkIG1pbGxpc2Vjb25kcyBwZXIgdGljay5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xudmFyIFBSRUZFUlJFRF9NU19QRVJfVElDSyA9ICgxMDAwIC8gUFJFRkVSUkVEX1RJQ0tTX1BFUl9TRUNPTkQpO1xuXG4vKipcbiAqIFJlbmRlcmVkIGZyYW1lcyBwZXIgc2Vjb25kIG9uIG9sZGVyIGJyb3dzZXJzIHdoZXJlIHdlIGNhbid0IGxvY2sgdG8gdGhlXG4gKiByZXBhaW50IGV2ZW50LlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG52YXIgRkFMTEJBQ0tfRlBTID0gMzA7XG5cbi8qKlxuICogUHJlY2FsY3VsYXRlZCBtaWxsaXNlY29uZHMgcGVyIGZyYW1lIGZvciBmYWxsYmFjayBjYXNlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbnZhciBGQUxMQkFDS19NU19QRVJfRlJBTUUgPSAoMTAwMCAvIEZBTExCQUNLX0ZQUyk7XG5cblxuXG4vKipcbiAqIFNpbXBsZSBydW4tbG9vcCBtYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJ1bkxvb3AgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcnVuLWxvb3Agd2lsbCBjb250aW51ZSBydW5uaW5nLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgY3VycmVudCB0aW1lIGFuZCBkZWx0YSB0aW1lIGZvciB0aGUgdGljayBsb29wLlxuICAgKiBQYXNzZWQgdG8gb2JzZXJ2ZXJzIHdoZW4gZXZlbnRzIGZpcmUuXG4gICAqIEB0eXBlIHtSdW5Mb29wLkNsb2NrfVxuICAgKi9cbiAgdGhpcy50aWNrQ2xvY2sgPSBuZXcgUnVuTG9vcC5DbG9jaygpO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgY3VycmVudCB0aW1lIGFuZCBkZWx0YSB0aW1lIGZvciB0aGUgcmVuZGVyIGxvb3AuXG4gICAqIFBhc3NlZCB0byBvYnNlcnZlcnMgd2hlbiBldmVudHMgZmlyZS5cbiAgICogQHR5cGUge1J1bkxvb3AuQ2xvY2t9XG4gICAqL1xuICB0aGlzLnJlbmRlckNsb2NrID0gbmV3IFJ1bkxvb3AuQ2xvY2soKTtcblxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb3ZlciBhbmQgb3ZlciwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIE5ldFNpbVxuICAgKiBpcyBpbiBmb2N1cyBvciBub3QuICBDYWxsZWQgbGVzcyBvZnRlbiB0aGFuIHJlbmRlcigpLiAgQ2FuIGJlIHNsb3dlZFxuICAgKiB0byBhYm91dCBvbmNlIHBlciBzZWNvbmQgd2hlbiBOZXRTaW0gaXMgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudGlja18gPSB0aGlzLmJ1aWxkVGlja01ldGhvZF8oKTtcblxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb3ZlciBhbmQgb3ZlciB3aGVuIE5ldFNpbSBpcyB2aXNpYmxlLiAgR2V0cyBhc1xuICAgKiBjbG9zZSB0byBtYXhpbXVtIGZyYW1lcmF0ZSBhcyBwb3NzaWJsZS4gIENhbGxlZCBtb3JlIG9mdGVuIHRoYW4gdGljaygpLCBidXRcbiAgICogY2FuIGJlIHBhdXNlZCBlbnRpcmVseSB3aGVuIE5ldFNpbSBpcyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZW5kZXJfID0gdGhpcy5idWlsZFJlbmRlck1ldGhvZF8oKTtcblxuICAvKiogIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9ICovXG4gIHRoaXMudGljayA9IG5ldyBPYnNlcnZhYmxlRXZlbnQoKTtcblxuICAvKiogQHR5cGUge09ic2VydmFibGVFdmVudH0gKi9cbiAgdGhpcy5yZW5kZXIgPSBuZXcgT2JzZXJ2YWJsZUV2ZW50KCk7XG59O1xuXG4vKipcbiAqIFNpbXBsZSB0cmFja2luZyBmb3IgdGltZSB2YWx1ZXNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5SdW5Mb29wLkNsb2NrID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGltZSB0aGUgY3VycmVudC9tb3N0IHJlY2VudCB0aWNrIHN0YXJ0ZWQsIGluIG1zLlxuICAgKiBEZXBlbmRpbmcgb24gYnJvd3NlciB0aGlzIG1pZ2h0IGJlIGVwb2NoIHRpbWUgb3IgdGltZSBzaW5jZSBsb2FkIC1cbiAgICogIHRoZXJlZm9yZSwgZG9uJ3QgdXNlIGZvciBhYnNvbHV0ZSB0aW1lIVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy50aW1lID0gd2luZG93Tm93KCk7XG5cbiAgLyoqXG4gICAqIFRpbWUgaW4gbXMgYmV0d2VlbiB0aGUgbGF0ZXN0L2N1cnJlbnQgdGljayBhbmQgdGhlIHByZXZpb3VzIHRpY2suXG4gICAqIFByZWNpc2lvbiBkZXBlbmRlbnQgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmRlbHRhVGltZSA9IDA7XG59O1xuXG5SdW5Mb29wLnByb3RvdHlwZS5idWlsZFRpY2tNZXRob2RfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGlja01ldGhvZDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aWNrTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgIHZhciBjdXJUaW1lID0gd2luZG93Tm93KCk7XG4gICAgICBzZWxmLnRpY2tDbG9jay5kZWx0YVRpbWUgPSBjdXJUaW1lIC0gc2VsZi50aWNrQ2xvY2sudGltZTtcbiAgICAgIHNlbGYudGlja0Nsb2NrLnRpbWUgPSBjdXJUaW1lO1xuICAgICAgc2VsZi50aWNrLm5vdGlmeU9ic2VydmVycyhzZWxmLnRpY2tDbG9jayk7XG4gICAgICBzZXRUaW1lb3V0KHRpY2tNZXRob2QsIFBSRUZFUlJFRF9NU19QRVJfVElDSyAtIHNlbGYudGlja0Nsb2NrLmRlbHRhVGltZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGlja01ldGhvZDtcbn07XG5cblJ1bkxvb3AucHJvdG90eXBlLmJ1aWxkUmVuZGVyTWV0aG9kXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlbmRlck1ldGhvZDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHJlbmRlck1ldGhvZCA9IGZ1bmN0aW9uIChoaVJlc1RpbWVTdGFtcCkge1xuICAgICAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgICAgICBzZWxmLnJlbmRlckNsb2NrLmRlbHRhVGltZSA9IGhpUmVzVGltZVN0YW1wIC0gc2VsZi5yZW5kZXJDbG9jay50aW1lO1xuICAgICAgICBzZWxmLnJlbmRlckNsb2NrLnRpbWUgPSBoaVJlc1RpbWVTdGFtcDtcbiAgICAgICAgc2VsZi5yZW5kZXIubm90aWZ5T2JzZXJ2ZXJzKHNlbGYucmVuZGVyQ2xvY2spO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyTWV0aG9kKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJlbmRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGN1clRpbWUgPSB3aW5kb3dOb3coKTtcbiAgICAgICAgc2VsZi5yZW5kZXJDbG9jay5kZWx0YVRpbWUgPSBjdXJUaW1lIC0gc2VsZi5yZW5kZXJDbG9jay50aW1lO1xuICAgICAgICBzZWxmLnJlbmRlckNsb2NrLnRpbWUgPSBjdXJUaW1lO1xuICAgICAgICBzZWxmLnJlbmRlci5ub3RpZnlPYnNlcnZlcnMoc2VsZi5yZW5kZXJDbG9jayk7XG4gICAgICAgIHNldFRpbWVvdXQocmVuZGVyTWV0aG9kLCBGQUxMQkFDS19NU19QRVJfRlJBTUUgLSBzZWxmLnJlbmRlckNsb2NrLmRlbHRhVGltZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVuZGVyTWV0aG9kO1xufTtcblxuLyoqIFN0YXJ0IHRoZSBydW4gbG9vcCAocnVucyBpbW1lZGlhdGVseSkgKi9cblJ1bkxvb3AucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB0aGlzLnRpY2tDbG9jay50aW1lID0gd2luZG93Tm93KCk7XG4gIHRoaXMucmVuZGVyQ2xvY2sudGltZSA9IHdpbmRvd05vdygpO1xuICB0aGlzLnRpY2tfKHRoaXMudGlja0Nsb2NrLnRpbWUpO1xuICB0aGlzLnJlbmRlcl8odGhpcy5yZW5kZXJDbG9jay50aW1lKTtcbn07XG5cbi8qKlxuICogU3RvcCB0aGUgcnVuIGxvb3BcbiAqIElmIGluIHRoZSBtaWRkbGUgb2YgYSB0aWNrLCB3aWxsIGZpbmlzaCB0aGUgY3VycmVudCB0aWNrLlxuICogSWYgY2FsbGVkIGJ5IGFuIGV2ZW50IGJldHdlZW4gdGlja3MsIHdpbGwgcHJldmVudCB0aGUgbmV4dCB0aWNrIGZyb20gZmlyaW5nLlxuICovXG5SdW5Mb29wLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xufTtcbiIsIi8qIGpzaGludFxuIGZ1bmNzY29wZTogdHJ1ZSxcbiBuZXdjYXA6IHRydWUsXG4gbm9uZXc6IHRydWUsXG4gc2hhZG93OiBmYWxzZSxcbiB1bnVzZWQ6IHRydWUsXG5cbiBtYXhsZW46IDkwLFxuIG1heHBhcmFtczogMyxcbiBtYXhzdGF0ZW1lbnRzOiAyMDBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgc3Vic2NyaXB0aW9uL25vdGlmaWNhdGlvbiBhdG9tLCB1c2VkIHRvIGNsZWFubHkgaG9vayB1cCBjYWxsYmFja3NcbiAqIHdpdGhvdXQgYXR0YWNoaW5nIGFueXRoaW5nIHRvIHRoZSBET00gb3Igb3RoZXIgZ2xvYmFsIHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPYnNlcnZhYmxlRXZlbnQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIE9iamVjdHMgb2JzZXJ2aW5nIHRoaXMuXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMub2JzZXJ2ZXJMaXN0XyA9IFtdO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgYSBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gbm90aWZ5T2JzZXJ2ZXJzIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uTm90aWZ5IC0gbWV0aG9kIGNhbGxlZCB3aGVuIG5vdGlmeU9ic2VydmVycyBnZXRzIGNhbGxlZC5cbiAqICAgICAgICBXaWxsIHJlY2VpdmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gbm90aWZ5T2JzZXJ2ZXJzLlxuICogQHJldHVybnMge09iamVjdH0ga2V5IC0gdXNlZCB0byB1bnJlZ2lzdGVyIGZyb20gb2JzZXJ2YWJsZVxuICovXG5PYnNlcnZhYmxlRXZlbnQucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9uTm90aWZ5KSB7XG4gIHZhciBrZXkgPSB7dG9DYWxsOm9uTm90aWZ5fTtcbiAgT2JqZWN0LmZyZWV6ZShrZXkpO1xuICB0aGlzLm9ic2VydmVyTGlzdF8ucHVzaChrZXkpO1xuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIG5vdGlmaWNhdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5T2JqIC0gS2V5IGdlbmVyYXRlZCB3aGVuIHJlZ2lzdGVyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIGFuIHVucmVnaXN0cmF0aW9uIGFjdHVhbGx5IG9jY3VycmVkXG4gKi9cbk9ic2VydmFibGVFdmVudC5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXlPYmopIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVyTGlzdF8ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5T2JqID09PSB0aGlzLm9ic2VydmVyTGlzdF9baV0pIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJMaXN0Xy5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBtZXRob2RzIHN1YnNjcmliZWQgdG8gdGhpcyBPYnNlcnZhYmxlRXZlbnQsIHBhc3NpbmcgdGhyb3VnaFxuICogYW55IGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7Li4ufSBBbnkgYXJndW1lbnRzLCB3aGljaCBhcmUgcGFzc2VkIHRocm91Z2ggdG8gdGhlIG9ic2VydmluZ1xuICogICAgICAgICAgICAgIGZ1bmN0aW9ucy5cbiAqL1xuT2JzZXJ2YWJsZUV2ZW50LnByb3RvdHlwZS5ub3RpZnlPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuICB0aGlzLm9ic2VydmVyTGlzdF8uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci50b0NhbGwuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSk7XG59OyJdfQ==
