require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/ubuntu/staging/apps/build/js/level_base.js":[function(require,module,exports){
// Functions for checking required blocks.

/**
 * Generate a required blocks dictionary for a call to a procedure that does
 * not have a return value.
 * @param {string} name The name of the procedure being called.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
'use strict';

exports.call = function (name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_callnoreturn' && block.getTitleValue('NAME').toLowerCase() == name.toLowerCase();
    },
    type: 'procedures_callnoreturn',
    titles: { 'NAME': name }
  };
};

/**
 * Generate a required blocks dictionary for a call to a procedure with a
 * single argument.
 * @param {string} func_name The name of the procedure being called.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.callWithArg = function (func_name, arg_name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_callnoreturn' && block.getTitleValue('NAME').toLowerCase() == func_name.toLowerCase();
    },
    type: 'procedures_callnoreturn',
    extra: '<mutation name="' + func_name + '"><arg name="' + arg_name + '"></arg></mutation>'
  };
};

/**
 * Generate a required blocks dictionary for the definition of a procedure
 * that does not have a return value.  This does not check if any arguments
 * are defined for the procedure.
 * @param {string} name The name of the procedure being defined.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.define = function (name) {
  return {
    test: function test(block) {
      return block.type == 'procedures_defnoreturn' && block.getTitleValue('NAME').toLowerCase() == name.toLowerCase();
    },
    type: 'procedures_defnoreturn',
    titles: { 'NAME': name }
  };
};

},{}],"/home/ubuntu/staging/apps/node_modules/canvg/canvg.js":[function(require,module,exports){
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
 (function ( global, factory ) {

	'use strict';

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
		define('canvgModule', [ 'rgbcolor', 'stackblur' ], factory );
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );
	}

	global.canvg = factory( global.RGBColor, global.stackBlur );

}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {

	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	var canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.querySelectorAll('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}

		if (typeof target == 'string') {
			target = document.getElementById(target);
		}

		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build(opts || {});
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

		var ctx = target.getContext('2d');
		if (typeof s.documentElement != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
	var matchesSelector;
	if (typeof Element.prototype.matches != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.matches(selector);
		};
	} else if (typeof Element.prototype.webkitMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.webkitMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.mozMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.mozMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.msMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.msMatchesSelector(selector);
		};
	} else if (typeof Element.prototype.oMatchesSelector != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.oMatchesSelector(selector);
		};
	} else {
		// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
		// or jQuery: http://jquery.com/download/
		// or Zepto: http://zeptojs.com/#
		// without it, this is a ReferenceError

		if (typeof jQuery === 'function' || typeof Zepto === 'function') {
			matchesSelector = function (node, selector) {
				return $(node).is(selector);
			};
		}

		if (typeof matchesSelector === 'undefined') {
			matchesSelector = Sizzle.matchesSelector;
		}
	}

	// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
	var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	function getSelectorSpecificity(selector) {
		var typeCount = [0, 0, 0];
		var findMatch = function(regex, type) {
			var matches = selector.match(regex);
			if (matches == null) {
				return;
			}
			typeCount[type] += matches.length;
			selector = selector.replace(regex, ' ');
		};

		selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
		selector = selector.replace(/{[^]*/gm, ' ');
		findMatch(attributeRegex, 1);
		findMatch(idRegex, 0);
		findMatch(classRegex, 1);
		findMatch(pseudoElementRegex, 2);
		findMatch(pseudoClassWithBracketsRegex, 1);
		findMatch(pseudoClassRegex, 1);
		selector = selector.replace(/[\*\s\+>~]/g, ' ');
		selector = selector.replace(/[#\.]/g, ' ');
		findMatch(elementRegex, 2);
		return typeCount.join('');
	}

	function build(opts) {
		var svg = { opts: opts };

		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;

		svg.log = function(msg) {};
		if (svg.opts['log'] == true && typeof console != 'undefined') {
			svg.log = function(msg) { console.log(msg); };
		};

		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.StylesSpecificity = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof d == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
				}
			});
		}
		svg.init();

		// images loaded
		svg.ImagesLoaded = function() {
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		}

		// parse xml
		svg.parseXml = function(xml) {
			if (typeof Windows != 'undefined' && typeof Windows.Data != 'undefined' && typeof Windows.Data.Xml != 'undefined') {
				var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
				var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
				settings.prohibitDtd = false;
				xmlDoc.loadXml(xml, settings);
				return xmlDoc;
			}
			else if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml);
				return xmlDoc;
			}
		}

		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}
			svg.Property.prototype.getValue = function() {
				return this.value;
			}

			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}

			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;

				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}

			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}

			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}

			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacityProp) {
					var newValue = this.value;
					if (opacityProp.value != null && opacityProp.value != '' && typeof this.value == 'string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}

			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}

				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}

				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();

					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}

					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}

					return null;
				}

			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}

				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;

					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

					return em;
				}

				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}

				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}

			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}

			// text extensions
				// get the text baseline
				var textBaselineMapping = {
					'baseline': 'alphabetic',
					'before-edge': 'top',
					'text-before-edge': 'top',
					'middle': 'middle',
					'central': 'middle',
					'after-edge': 'bottom',
					'text-after-edge': 'bottom',
					'ideographic': 'ideographic',
					'alphabetic': 'alphabetic',
					'hanging': 'hanging',
					'mathematical': 'alphabetic'
				};
				svg.Property.prototype.toTextBaseline = function () {
					if (!this.hasValue()) return null;
					return textBaselineMapping[this.value];
				}

		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return {
					fontFamily: fontFamily || f.fontFamily,
					fontSize: fontSize || f.fontSize,
					fontStyle: fontStyle || f.fontStyle,
					fontWeight: fontWeight || f.fontWeight,
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
				}
			}

			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});

		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}

			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}

		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;

			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }

			this.addPoint = function(x, y) {
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}

				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }

			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}

			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}

			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);

				for (i=0; i<=1; i++) {
					var f = function(t) {
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}

					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];

					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}

					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}

			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}

			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}

		// transforms
		svg.Transform = function(v) {
			var that = this;
			this.Type = {}

			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}

			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}
			}

			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}
			}

			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.unapply = function(ctx) {
					var a = this.m[0];
					var b = this.m[2];
					var c = this.m[4];
					var d = this.m[1];
					var e = this.m[3];
					var f = this.m[5];
					var g = 0.0;
					var h = 0.0;
					var i = 1.0;
					var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
					ctx.transform(
						det*(e*i-f*h),
						det*(f*g-d*i),
						det*(c*h-b*i),
						det*(a*i-c*g),
						det*(b*f-c*e),
						det*(c*d-a*f)
					);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}
			}

			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;

			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;

			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;

			this.transforms = [];

			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}

			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}

			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}

			var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transformType = this.Type[type];
				if (typeof transformType != 'undefined') {
					var transform = new transformType(s);
					transform.type = type;
					this.transforms.push(transform);
				}
			}
		}

		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			}
			else {
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
			}

			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
		}

		// elements
		svg.Element = {}

		svg.EmptyProperty = new svg.Property('EMPTY', '');

		svg.Element.ElementBase = function(node) {
			this.attributes = {};
			this.styles = {};
			this.stylesSpecificity = {};
			this.children = [];

			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;

				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}

			this.getHrefAttribute = function() {
				for (var a in this.attributes) {
					if (a == 'href' || a.match(/:href$/)) {
						return this.attributes[a];
					}
				}
				return svg.EmptyProperty;
			}

			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists, skipAncestors) {
				var s = this.styles[name];
				if (s != null) return s;

				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}

				if (skipAncestors != true) {
					var p = this.parent;
					if (p != null) {
						var ps = p.style(name);
						if (ps != null && ps.hasValue()) {
							return ps;
						}
					}
				}

				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}

			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;

				// don't render visibility=hidden
				if (this.style('visibility').value == 'hidden') return;

				ctx.save();
				if (this.style('mask').hasValue()) { // mask
					var mask = this.style('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {
					this.setContext(ctx);
					this.renderChildren(ctx);
					this.clearContext(ctx);
				}
				ctx.restore();
			}

			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}

			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				if (child.type != 'title') { this.children.push(child);	}
			}

			this.addStylesFromStyleDefinition = function () {
				// add styles
				for (var selector in svg.Styles) {
					if (selector[0] != '@' && matchesSelector(node, selector)) {
						var styles = svg.Styles[selector];
						var specificity = svg.StylesSpecificity[selector];
						if (styles != null) {
							for (var name in styles) {
								var existingSpecificity = this.stylesSpecificity[name];
								if (typeof existingSpecificity == 'undefined') {
									existingSpecificity = '000';
								}
								if (specificity > existingSpecificity) {
									this.styles[name] = styles[name];
									this.stylesSpecificity[name] = specificity;
								}
							}
						}
					}
				}
			};
			
			// Microsoft Edge fix
			var allUppercase = new RegExp("^[A-Z\-]+$");
			var normalizeAttributeName = function (name) {
				if (allUppercase.test(name)) {
					return name.toLowerCase();
				}
				return name;
			};

			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					var nodeName = normalizeAttributeName(attribute.nodeName);
					this.attributes[nodeName] = new svg.Property(nodeName, attribute.value);
				}

				this.addStylesFromStyleDefinition();

				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}

				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
						var text = childNode.value || childNode.text || childNode.textContent || '';
						if (svg.compressSpaces(text) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
			}
		}

		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
					ctx.fillStyle = fillStyle.value;
				}

				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof ctx.setLineDash != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof ctx.webkitLineDash != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof ctx.mozDash != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof ctx.lineDashOffset != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof ctx.webkitLineDashOffset != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof ctx.mozDashOffset != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof ctx.font != 'undefined') {
					ctx.font = svg.Font.CreateFont(
						this.style('font-style').value,
						this.style('font-variant').value,
						this.style('font-weight').value,
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
						this.style('font-family').value).toString();
				}

				// transform
				if (this.style('transform', false, true).hasValue()) {
					var transform = new svg.Transform(this.style('transform', false, true).value);
					transform.apply(ctx);
				}

				// clip
				if (this.style('clip-path', false, true).hasValue()) {
					var clip = this.style('clip-path', false, true).getDefinition();
					if (clip != null) clip.apply(ctx);
				}

				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}

			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();

				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}
			}

			this.getBoundingBox = function() {
				return this.path();
			}

			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values and defaults
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;
				if (typeof ctx.font != 'undefined' && typeof window.getComputedStyle != 'undefined') {
					ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
				}

				this.baseSetContext(ctx);

				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();

				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof this.root == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');

					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}

					if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
						ctx.beginPath();
						ctx.moveTo(x, y);
						ctx.lineTo(width, y);
						ctx.lineTo(width, height);
						ctx.lineTo(x, height);
						ctx.closePath();
						ctx.clip();
					}
				}
				svg.ViewPort.SetCurrent(width, height);

				// viewbox
				if (this.attribute('viewBox').hasValue()) {
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];

					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									svg.ViewPort.width(),
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);

					svg.ViewPort.RemoveCurrent();
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
				}
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}

				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;

		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();

				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}

			this.path = function(ctx) {
				var points = this.getPoints();

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}

				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}

			this.getMarkers = function() {
				var points = this.getPoints();
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;

		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}

			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				if (markers.length > 0) {
					markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				}
				return markers;
			}
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;

		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);

			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			// As the end of a match can also be the start of the next match, we need to run this replace twice.
			for(var i=0; i<2; i++)
				d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
			// Again, we need to run this twice to find all occurances
			for(var i=0; i<2; i++)
				d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');

				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}

				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}

				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}

				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}

				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}

				this.getScalar = function() {
					return parseFloat(this.getToken());
				}

				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}

				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}

				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}

				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;
				}

				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' &&
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' &&
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}

					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
					return p;
				}

				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}

				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}

				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}

				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();

				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;

		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;

				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
						tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;

		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);

				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;

		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;

		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.stops = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}

			this.getGradient = function() {
				// OVERRIDE ME!
			}
			
			this.gradientUnits = function () {
				return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			}
			
			this.attributesToInherit = ['gradientUnits'];
			
			this.inheritStopContainer = function (stopsContainer) {
				for (var i=0; i<this.attributesToInherit.length; i++) {
					var attributeToInherit = this.attributesToInherit[i];
					if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
						this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
					}
				}
			}

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
					this.inheritStopContainer(stopsContainer);
				}

				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp).value;
					}
					return color;
				};

				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}

				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];

					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];

					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];

					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);
					return tempCtx.createPattern(c, 'no-repeat');
				}

				return g;
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('x1');
			this.attributesToInherit.push('y1');
			this.attributesToInherit.push('x2');
			this.attributesToInherit.push('y2');

			this.getGradient = function(ctx, element) {
				var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }

				var x1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x1').numValue()
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('cx');
			this.attributesToInherit.push('cy');
			this.attributesToInherit.push('r');
			this.attributesToInherit.push('fx');
			this.attributesToInherit.push('fy');

			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();

				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

				var cx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('cx').numValue()
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('cy').numValue()
					: this.attribute('cy').toPixels('y'));

				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('fx').numValue()
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('fy').numValue()
					: this.attribute('fy').toPixels('y'));
				}

				var r = (this.gradientUnits() == 'objectBoundingBox'
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());

				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;

			var stopColor = this.style('stop-color', true);
			if (stopColor.value === '') stopColor.value = '#000';
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;

		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			svg.Animations.push(this);

			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;

				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);
			};

			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}

			this.update = function(delta) {
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}

				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
						this.frozen = true;
						this.parent.animationFrozen = true;
						this.parent.animationFrozenValue = this.getProperty().value;
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
						return true;
					}
					return false;
				}
				this.duration = this.duration + delta;

				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween

					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}

					this.getProperty().value = newValue;
					updated = true;
				}

				return updated;
			}

			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');

			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;

		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);

				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;

		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();

			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof this.glyphs[child.unicode] == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;

		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;

		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;

		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;

		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);

				var textBaseline = this.style('dominant-baseline').toTextBaseline();
				if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
				if (textBaseline != null) ctx.textBaseline = textBaseline;
			}

			this.getBoundingBox = function () {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
			}

			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
				if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, this, i);
				}
			}

			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}

			this.renderChild = function(ctx, textParent, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + textParent.getAnchorDelta(ctx, parent, i);
					if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
				}
				else {
					if (child.attribute('dx').hasValue()) textParent.x += child.attribute('dx').toPixels('x');
					child.x = textParent.x;
				}
				textParent.x = child.x + child.measureText(ctx);

				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
					if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
				}
				else {
					if (child.attribute('dy').hasValue()) textParent.y += child.attribute('dy').toPixels('y');
					child.y = textParent.y;
				}
				textParent.y = child.y;

				child.render(ctx);

				for (var i=0; i<child.children.length; i++) {
					textParent.renderChild(ctx, textParent, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;

		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof font.glyphs[c] != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}

			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");

					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);

						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}

				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}

			this.getText = function() {
				// OVERRIDE ME
			}

			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}

			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}

				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;

				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

		// tspan
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
			this.getText = function() {
				// if this node has children, then they own the text
				if (this.children.length > 0) { return ''; }
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;

		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;

		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.hasText = node.childNodes.length > 0;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}

			// this might contain text
			this.text = this.hasText ? node.childNodes[0].value : '';
			this.getText = function() {
				return this.text;
			}

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
				}
				else if (this.children.length > 0) {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}

			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}

			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;

		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			var href = this.getHrefAttribute().value;
			if (href == '') { return; }
			var isSvg = href.match(/\.svg$/)

			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}

			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');

				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				if (width == 0 || height == 0) return;

				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);
					ctx.drawImage(this.img, 0, 0);
				}
				ctx.restore();
			}

			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;

		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NO RENDER
			};
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

		// style element
		svg.Element.style = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].data;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = svg.Styles[cssClass] || {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;

		// use element
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}

			var element = this.getHrefAttribute().getDefinition();

			this.path = function(ctx) {
				if (element != null) element.path(ctx);
			}

			this.getBoundingBox = function() {
				if (element != null) return element.getBoundingBox();
			}

			this.renderChildren = function(ctx) {
				if (element != null) {
					var tempSvg = element;
					if (element.type == 'symbol') {
						// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
						tempSvg = new svg.Element.svg();
						tempSvg.type = 'svg';
						tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
						tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
						tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
						tempSvg.children = element.children;
					}
					if (tempSvg.type == 'svg') {
						// if symbol or svg, inherit width/height from me
						if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
						if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
					}
					var oldParent = tempSvg.parent;
					tempSvg.parent = null;
					tempSvg.render(ctx);
					tempSvg.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;

		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');

				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}

				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';

					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);

					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);

					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);

				// reassign mask
				element.attribute('mask').value = mask;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;

		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx) {
				var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
				CanvasRenderingContext2D.prototype.beginPath = function () { };

				var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
				CanvasRenderingContext2D.prototype.closePath = function () { };

				oldBeginPath.call(ctx);
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof child.path != 'undefined') {
						var transform = null;
						if (child.style('transform', false, true).hasValue()) {
							transform = new svg.Transform(child.style('transform', false, true).value);
							transform.apply(ctx);
						}
						child.path(ctx);
						CanvasRenderingContext2D.prototype.closePath = oldClosePath;
						if (transform) { transform.unapply(ctx); }
					}
				}
				oldClosePath.call(ctx);
				ctx.clip();

				CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
				CanvasRenderingContext2D.prototype.closePath = oldClosePath;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';

				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}

				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);

				// apply filters
				for (var i=0; i<this.children.length; i++) {
					if (typeof this.children[i].apply == 'function') {
						this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
					}
				}

				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

				// reassign filter
				element.style('filter', true).value = filter;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;

		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

		svg.Element.feComposite = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feComposite.prototype = new svg.Element.ElementBase;

		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			var matrix = svg.ToNumberArray(this.attribute('values').value);
			switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
				case 'saturate':
					var s = matrix[0];
					matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'hueRotate':
					var a = matrix[0] * Math.PI / 180.0;
					var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
					matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
							  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
							  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'luminanceToAlpha':
					matrix = [0,0,0,0,0,
							  0,0,0,0,0,
							  0,0,0,0,0,
							  0.2125,0.7154,0.0721,0,0,
							  0,0,0,0,1];
					break;
			}

			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}

			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}

			function m(i, v) {
				var mi = matrix[i];
				return mi * (mi < 0 ? v - 255 : v);
			}

			this.apply = function(ctx, x, y, width, height) {
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var a = imGet(srcData.data, x, y, width, height, 3);
						imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
						imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
						imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
						imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;

			this.apply = function(ctx, x, y, width, height) {
				if (typeof stackBlur.canvasRGBA == 'undefined') {
					svg.log('ERROR: StackBlur.js must be included for blur to work');
					return;
				}

				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;

		svg.Element.MISSING = function(node) {
			svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;

		// element factory
		svg.CreateElement = function(node) {
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof svg.Element[className] != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}

		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}

		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}

		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);

			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}

			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}

			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
			e.addStylesFromStyleDefinition();

			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);

				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
					var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

					if (svg.opts['scaleWidth'] != null) {
						if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
						else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					}

					if (svg.opts['scaleHeight'] != null) {
						if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
						else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					}

					if (xRatio == null) { xRatio = yRatio; }
					if (yRatio == null) { yRatio = xRatio; }

					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];
					e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
				}

				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof svg.opts['renderCallback'] == 'function') svg.opts['renderCallback'](dom);
				}
			}

			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() {
				var needUpdate = false;

				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}

				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}

				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}

				// need update from redraw?
				if (typeof svg.opts['forceRedraw'] == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}

				// render if needed
				if (needUpdate) {
					draw();
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}

		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}

		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }

			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y,
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}

			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}

			this.eventElements = [];

			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';

				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}

				// done running, clear
				this.events = [];
				this.eventElements = [];
			}
		});

		return svg;
	};

	if (typeof CanvasRenderingContext2D  != 'undefined') {
		CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh, opts) {
			var cOpts = {
				ignoreMouse: true,
				ignoreAnimation: true,
				ignoreDimensions: true,
				ignoreClear: true,
				offsetX: dx,
				offsetY: dy,
				scaleWidth: dw,
				scaleHeight: dh
			}
			
			for(var prop in opts) {
				if(opts.hasOwnProperty(prop)){
					cOpts[prop] = opts[prop];
				}
			}
			canvg(this.canvas, s, cOpts);
		}
	}

	return canvg;

}));

},{"rgbcolor":"/home/ubuntu/staging/apps/node_modules/rgbcolor/index.js","stackblur":"/home/ubuntu/staging/apps/node_modules/stackblur/index.js"}],"/home/ubuntu/staging/apps/node_modules/stackblur/index.js":[function(require,module,exports){
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function blur( pixels, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;

	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa != 0 )
			{
				pa = 255 / pa;
				pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
			} else {
				pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa > 0 )
			{
				pa = 255 / pa;
				pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
			} else {
				pixels[p] = pixels[p+1] = pixels[p+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

module.exports = blur;
},{}],"/home/ubuntu/staging/apps/node_modules/rgbcolor/index.js":[function(require,module,exports){
/*
	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
	http://www.phpied.com/rgb-color-parser-in-javascript/
*/

module.exports = function(color_string) {
    this.ok = false;
    this.alpha = 1.0;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    color_string = simple_colors[color_string] || color_string;
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        },
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            if (channels.length > 3) {
                this.alpha = channels[3];
            }
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toRGBA = function () {
        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}

},{}],"/home/ubuntu/staging/apps/build/js/canvg/svg_todataurl.js":[function(require,module,exports){
/**
	The missing SVG.toDataURL library for your SVG elements.

	Usage: SVGElement.toDataURL( type, { options } )

	Returns: the data URL, except when using native PNG renderer (needs callback).

	type	MIME type of the exported data.
			Default: image/svg+xml.
			Must support: image/png.
			Additional: image/jpeg.

	options is a map of options: {
		callback: function(dataURL)
			Callback function which is called when the data URL is ready.
			This is only necessary when using native PNG renderer.
			Default: undefined.

		[the rest of the options only apply when type="image/png" or type="image/jpeg"]

		renderer: "native"|"canvg"
			PNG renderer to use. Native renderer might cause a security exception.
			Default: canvg if available, otherwise native.

		keepNonSafe: true|false
			Export non-safe (image and foreignObject) elements.
			This will set the Canvas origin-clean property to false, if this data is transferred to Canvas.
			Default: false, to keep origin-clean true.
			NOTE: not currently supported and is just ignored.

		keepOutsideViewport: true|false
			Export all drawn content, even if not visible.
			Default: false, export only visible viewport, similar to Canvas toDataURL().
			NOTE: only supported with canvg renderer.
	}

	See original paper for more info on SVG to Canvas exporting.

	 http://svgopen.org/2010/papers/62-From_SVG_to_Canvas_and_Back/#svg_to_canvas
*/

"use strict";

SVGElement.prototype.toDataURL = function (type, options) {
	var _svg = this;

	function debug(s) {
		// We could find to a way to make this display depending on environment, but
		// for now I think it's okay to just disable.
		// console.log("SVG.toDataURL:", s);
	}

	function exportSVG() {
		var svg_xml = XMLSerialize(_svg);
		var svg_dataurl = base64dataURLencode(svg_xml);
		debug(type + " length: " + svg_dataurl.length);

		// NOTE double data carrier
		if (options.callback) options.callback(svg_dataurl);
		return svg_dataurl;
	}

	function XMLSerialize(svg) {

		// quick-n-serialize an SVG dom, needed for IE9 where there's no XMLSerializer nor SVG.xml
		// s: SVG dom, which is the <svg> elemennt
		function XMLSerializerForIE(s) {
			var out = "";

			out += "<" + s.nodeName;
			for (var n = 0; n < s.attributes.length; n++) {
				out += " " + s.attributes[n].name + "=" + "'" + s.attributes[n].value + "'";
			}

			if (s.hasChildNodes()) {
				out += ">\n";

				for (var n = 0; n < s.childNodes.length; n++) {
					out += XMLSerializerForIE(s.childNodes[n]);
				}

				out += "</" + s.nodeName + ">" + "\n";
			} else out += " />\n";

			return out;
		}

		if (window.XMLSerializer) {
			debug("using standard XMLSerializer.serializeToString");
			return new XMLSerializer().serializeToString(svg);
		} else {
			debug("using custom XMLSerializerForIE");
			return XMLSerializerForIE(svg);
		}
	}

	function base64dataURLencode(s) {
		var b64 = "data:image/svg+xml;base64,";

		// https://developer.mozilla.org/en/DOM/window.btoa
		if (window.btoa) {
			debug("using window.btoa for base64 encoding");
			b64 += btoa(s);
		} else {
			debug("using custom base64 encoder");
			b64 += Base64.encode(s);
		}

		return b64;
	}

	function exportImage(type) {
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext('2d');

		// TODO: if (options.keepOutsideViewport), do some translation magic?

		var svg_img = new Image();
		var svg_xml = XMLSerialize(_svg);
		svg_img.src = base64dataURLencode(svg_xml);

		svg_img.onload = function () {
			debug("exported image size: " + [svg_img.width, svg_img.height]);
			canvas.width = svg_img.width;
			canvas.height = svg_img.height;
			ctx.drawImage(svg_img, 0, 0);

			// SECURITY_ERR WILL HAPPEN NOW
			var png_dataurl = canvas.toDataURL(type);
			debug(type + " length: " + png_dataurl.length);

			if (options.callback) options.callback(png_dataurl);else debug("WARNING: no callback set, so nothing happens.");
		};

		svg_img.onerror = function () {
			console.log("Can't export! Maybe your browser doesn't support " + "SVG in img element or SVG input for Canvas drawImage?\n" + "http://en.wikipedia.org/wiki/SVG#Native_support");
		};

		// NOTE: will not return anything
	}

	function exportImageCanvg(type) {
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext('2d');
		var svg_xml = XMLSerialize(_svg);

		// NOTE: canvg gets the SVG element dimensions incorrectly if not specified as attributes
		//debug("detected svg dimensions " + [_svg.clientWidth, _svg.clientHeight])
		//debug("canvas dimensions " + [canvas.width, canvas.height])

		var keepBB = options.keepOutsideViewport;
		if (keepBB) var bb = _svg.getBBox();

		// NOTE: this canvg call is synchronous and blocks (no it does not)
		canvg(canvas, svg_xml, {
			ignoreMouse: true, ignoreAnimation: true,
			offsetX: keepBB ? -bb.x : undefined,
			offsetY: keepBB ? -bb.y : undefined,
			scaleWidth: keepBB ? bb.width + bb.x : undefined,
			scaleHeight: keepBB ? bb.height + bb.y : undefined,
			renderCallback: function renderCallback() {
				debug("exported image dimensions " + [canvas.width, canvas.height]);
				var png_dataurl = canvas.toDataURL(type);
				debug(type + " length: " + png_dataurl.length);

				if (options.callback) options.callback(png_dataurl);
			}
		});

		// NOTE: return in addition to callback
		return canvas.toDataURL(type);
	}

	// BEGIN MAIN

	if (!type) type = "image/svg+xml";
	if (!options) options = {};

	if (options.keepNonSafe) debug("NOTE: keepNonSafe is NOT supported and will be ignored!");
	if (options.keepOutsideViewport) debug("NOTE: keepOutsideViewport is only supported with canvg exporter.");

	switch (type) {
		case "image/svg+xml":
			return exportSVG();
			break;

		case "image/png":
		case "image/jpeg":

			if (!options.renderer) {
				if (window.canvg) options.renderer = "canvg";else options.renderer = "native";
			}

			switch (options.renderer) {
				case "canvg":
					debug("using canvg renderer for png export");
					return exportImageCanvg(type);
					break;

				case "native":
					debug("using native renderer for png export. THIS MIGHT FAIL.");
					return exportImage(type);
					break;

				default:
					debug("unknown png renderer given, doing noting (" + options.renderer + ")");
			}

			break;

		default:
			debug("Sorry! Exporting as '" + type + "' is not supported!");
	}
};

},{}],"/home/ubuntu/staging/apps/build/js/sharedFunctionalBlocks.js":[function(require,module,exports){
/**
 * A set of functional blocks
 */
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();
var msg = require('./locale');

var ARITHMETIC_TITLE_FONT_SIZE = 25;

exports.install = function (blockly, generator, gensym) {
  installPlus(blockly, generator, gensym);
  installMinus(blockly, generator, gensym);
  installTimes(blockly, generator, gensym);
  installDividedBy(blockly, generator, gensym);
  installGreaterThan(blockly, generator, gensym);
  installLessThan(blockly, generator, gensym);
  installNumberEquals(blockly, generator, gensym);
  installStringEquals(blockly, generator, gensym);
  installLogicalAnd(blockly, generator, gensym);
  installLogicalOr(blockly, generator, gensym);
  installLogicalNot(blockly, generator, gensym);
  installBoolean(blockly, generator, gensym);
  installMathNumber(blockly, generator, gensym);
  installString(blockly, generator, gensym);
  installCond(blockly, generator);
  installSqrt(blockly, generator);
  installPow(blockly, generator);
  installSquared(blockly, generator);
};

function installPlus(blockly, generator, gensym) {
  blockly.Blocks.functional_plus = {

    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '+', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_plus = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " + " + arg2 + ")";
  };
}

function installMinus(blockly, generator, gensym) {
  blockly.Blocks.functional_minus = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '-', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_minus = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " - " + arg2 + ")";
  };
}

function installTimes(blockly, generator, gensym) {
  blockly.Blocks.functional_times = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '*', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_times = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " * " + arg2 + ")";
  };
}

function installDividedBy(blockly, generator, gensym) {
  blockly.Blocks.functional_dividedby = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '/', blockly.BlockValueType.NUMBER, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }], { titleFontSize: ARITHMETIC_TITLE_FONT_SIZE });
    }
  };

  generator.functional_dividedby = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return "(" + arg1 + " / " + arg2 + ")";
  };
}

// Install comparators

function installGreaterThan(blockly, generator, gensym) {
  blockly.Blocks.functional_greater_than = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '>', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_greater_than = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " > " + arg2 + ')';
  };
}

function installLessThan(blockly, generator, gensym) {
  blockly.Blocks.functional_less_than = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '<', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_less_than = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " < " + arg2 + ')';
  };
}

function installNumberEquals(blockly, generator, gensym) {
  blockly.Blocks.functional_number_equals = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, '=', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.NUMBER }, { name: 'ARG2', type: blockly.BlockValueType.NUMBER }]);
    }
  };

  generator.functional_number_equals = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " == " + arg2 + ')';
  };
}

function installStringEquals(blockly, generator, gensym) {
  blockly.Blocks.functional_string_equals = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, msg.stringEquals(), blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.STRING }, { name: 'ARG2', type: blockly.BlockValueType.STRING }]);
    }
  };

  generator.functional_string_equals = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || '';
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || '';
    return '(' + arg1 + " == " + arg2 + ')';
  };
}

// Install boolean operators

function installLogicalAnd(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_and = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'and', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }, { name: 'ARG2', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_and = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " && " + arg2 + ')';
  };
}

function installLogicalOr(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_or = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'or', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }, { name: 'ARG2', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_or = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return '(' + arg1 + " || " + arg2 + ')';
  };
}

function installLogicalNot(blockly, generator, gensym) {
  blockly.Blocks.functional_logical_not = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'not', blockly.BlockValueType.BOOLEAN, [{ name: 'ARG1', type: blockly.BlockValueType.BOOLEAN }]);
    }
  };

  generator.functional_logical_not = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return '!(' + arg1 + ')';
  };
}

function installBoolean(blockly, generator, gensym) {
  blockly.Blocks.functional_boolean = {
    // Boolean value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.BOOLEAN]);
      var values = blockly.Blocks.functional_boolean.VALUES;
      this.appendDummyInput().appendTitle(new blockly.FieldDropdown(values), 'VAL').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.BOOLEAN);
    }
  };

  blockly.Blocks.functional_boolean.VALUES = [[msg.booleanTrue(), 'true'], [msg.booleanFalse(), 'false']];

  generator.functional_boolean = function () {
    return this.getTitleValue('VAL');
  };
}

function installMathNumber(blockly, generator, gensym) {
  blockly.Blocks.functional_math_number = {
    // Numeric value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.NUMBER]);
      this.appendDummyInput().appendTitle(new Blockly.FieldTextInput('0', Blockly.FieldTextInput.numberValidator), 'NUM').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.NUMBER);
    }
  };

  generator.functional_math_number = function () {
    return this.getTitleValue('NUM');
  };

  blockly.Blocks.functional_math_number_dropdown = {
    // Numeric value.
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.NUMBER]);
      this.appendDummyInput().appendTitle(new Blockly.FieldDropdown(), 'NUM').setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.NUMBER);
    }
  };

  generator.functional_math_number_dropdown = generator.functional_math_number;
}

function installString(blockly, generator) {
  blockly.Blocks.functional_string = {
    init: function init() {
      this.setFunctional(true, {
        headerHeight: 0,
        rowBuffer: 3
      });
      this.setHSV.apply(this, blockly.FunctionalTypeColors[blockly.BlockValueType.STRING]);
      this.appendDummyInput().appendTitle(new Blockly.FieldLabel('"')).appendTitle(new Blockly.FieldTextInput(''), 'VAL').appendTitle(new Blockly.FieldLabel('"')).setAlign(Blockly.ALIGN_CENTRE);
      this.setFunctionalOutput(true, blockly.BlockValueType.STRING);
    }
  };

  generator.functional_string = function () {
    return blockly.JavaScript.quote_(this.getTitleValue('VAL'));
  };
}

function installSqrt(blockly, generator) {
  blockly.Blocks.functional_sqrt = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'sqrt', 'Number', [{ name: 'ARG1', type: 'Number' }]);
    }
  };

  generator.functional_sqrt = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return 'Math.sqrt(' + arg1 + ')';
  };
}

function installPow(blockly, generator) {
  blockly.Blocks.functional_pow = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'pow', 'Number', [{ name: 'ARG1', type: 'Number' }, { name: 'ARG2', type: 'Number' }]);
    }
  };

  generator.functional_pow = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    var arg2 = Blockly.JavaScript.statementToCode(this, 'ARG2', false) || 0;
    return 'Math.pow(' + arg1 + ', ' + arg2 + ')';
  };
}

function installSquared(blockly, generator) {
  blockly.Blocks.functional_squared = {
    helpUrl: '',
    init: function init() {
      blockly.FunctionalBlockUtils.initTitledFunctionalBlock(this, 'sqr', 'Number', [{ name: 'ARG1', type: 'Number' }]);
    }
  };

  generator.functional_squared = function () {
    var arg1 = Blockly.JavaScript.statementToCode(this, 'ARG1', false) || 0;
    return arg1 + ' * ' + arg1;
  };
}

/**
 * Implements the cond block. numPairs represents the number of
 * condition-value pairs before the default value.
 */
function installCond(blockly, generator) {
  // TODO(brent) - rtl
  var types = [Blockly.BlockValueType.NONE, Blockly.BlockValueType.NUMBER, Blockly.BlockValueType.STRING, Blockly.BlockValueType.IMAGE, Blockly.BlockValueType.BOOLEAN];

  // Generates the following blocks:
  // functional_cond (deprecated)
  // functional_cond_number
  // functional_cond_string
  // functional_cond_boolean
  // functional_cond_image
  types.forEach(function (type) {
    installCondForType(blockly, generator, type);
  });
}

function installCondForType(blockly, generator, type) {
  var blockName = 'functional_cond';
  if (type !== Blockly.BlockValueType.NONE) {
    blockName += '_' + type.toLowerCase();
  }

  blockly.Blocks[blockName] = {
    helpUrl: '',
    init: function init() {
      this.pairs_ = [];
      this.setFunctional(true, {
        headerHeight: 30
      });

      var options = {
        fixedSize: { height: 35 }
      };

      this.setHSV.apply(this, Blockly.FunctionalTypeColors[type]);

      var plusField = new Blockly.FieldIcon('+');
      Blockly.bindEvent_(plusField.getRootElement(), 'mousedown', this, this.addConditionalRow);

      this.appendDummyInput().appendTitle(new Blockly.FieldLabel('cond', options)).setAlign(Blockly.ALIGN_CENTRE);

      this.appendDummyInput('ELSE').appendTitle(new Blockly.FieldLabel('else', options));
      var defaultInput = this.appendFunctionalInput('DEFAULT').setInline(true);
      defaultInput.setHSV.apply(defaultInput, Blockly.FunctionalTypeColors[type]);

      this.appendDummyInput('PLUS').appendTitle(plusField).setInline(true);

      this.setFunctionalOutput(true, type === Blockly.BlockValueType.NONE ? undefined : type);

      this.addConditionalRow();
    },

    /**
     * Add another condition/value pair to the end.
     */
    addConditionalRow: function addConditionalRow() {
      // id is either the last value plus 1, or if we have no values yet 0
      // we can't just have pairs_.length, since there could be gaps
      var id = this.pairs_.length > 0 ? _(this.pairs_).last() * 1 + 1 : 0;
      this.pairs_.push(id);

      var cond = this.appendFunctionalInput('COND' + id);
      cond.setHSV.apply(cond, blockly.FunctionalTypeColors[blockly.BlockValueType.BOOLEAN]);
      cond.setCheck(blockly.BlockValueType.BOOLEAN);
      this.moveInputBefore('COND' + id, 'ELSE');

      var input = this.appendFunctionalInput('VALUE' + id).setInline(true);
      input.setHSV.apply(input, Blockly.FunctionalTypeColors[type]);
      this.moveInputBefore('VALUE' + id, 'ELSE');

      var minusInput = this.appendDummyInput('MINUS' + id).setInline(true);

      if (this.pairs_.length > 1) {
        var minusField = new Blockly.FieldIcon('-');
        Blockly.bindEvent_(minusField.getRootElement(), 'mousedown', this, _.bind(this.removeConditionalRow, this, id));
        minusInput.appendTitle(minusField);
      }

      this.moveInputBefore('MINUS' + id, 'ELSE');
    },

    /**
     * Remove the condition/value pair with the given id. No-op if no row with
     * that id.
     */
    removeConditionalRow: function removeConditionalRow(id) {
      var index = this.pairs_.indexOf(id);
      if (!_(this.pairs_).contains(id) || this.pairs_.length === 1) {
        return;
      }
      this.pairs_.splice(index, 1);

      var cond = this.getInput('COND' + id);
      var child = cond.connection.targetBlock();
      if (child) {
        child.dispose();
      }
      this.removeInput('COND' + id);

      var val = this.getInput('VALUE' + id);
      child = val.connection.targetBlock();
      if (child) {
        child.dispose();
      }
      this.removeInput('VALUE' + id);

      this.removeInput('MINUS' + id);
    },

    /**
     * Serialize pairs so that we can deserialize with the same ids
     */
    mutationToDom: function mutationToDom() {
      if (this.pairs_.length <= 1) {
        return null;
      }
      var container = document.createElement('mutation');
      container.setAttribute('pairs', this.pairs_.join(','));
      return container;
    },

    /**
     * Deserialize and cause our block to have same ids
     */
    domToMutation: function domToMutation(element) {
      var i;
      var pairs = element.getAttribute('pairs');
      if (!pairs) {
        return;
      }

      pairs = pairs.split(',').map(function (item) {
        return parseInt(item, 10);
      });

      // Our pairs, which are used to name rows, are not necessarily contiguous.
      // We ensure that we end up with the same set of pairs by adding lots
      // of rows, and then deleting the unneeded ones (simulating what happened
      // to originally create this block)
      var lastRow = _(pairs).last();
      for (i = 1; i <= lastRow; i++) {
        this.addConditionalRow();
      }

      for (i = 0; i < lastRow; i++) {
        if (!_(pairs).contains(i)) {
          this.removeConditionalRow(i);
        }
      }
    }
  };

  /**
   * // generates code like:
   * function() {
   *   if (cond1) { return value1; }
   *   else if (cond2) {return value2; }
   *   ...
   *   else { return default; }
   * }()
   */
  generator[blockName] = function () {
    var cond, value, defaultValue;
    var code = '(function () {\n  ';
    for (var i = 0; i < this.pairs_.length; i++) {
      if (i > 0) {
        code += 'else ';
      }
      var id = this.pairs_[i];
      cond = Blockly.JavaScript.statementToCode(this, 'COND' + id, false) || false;
      value = Blockly.JavaScript.statementToCode(this, 'VALUE' + id, false) || '';
      code += 'if (' + cond + ') { return ' + value + '; }\n  ';
    }
    defaultValue = Blockly.JavaScript.statementToCode(this, 'DEFAULT', false) || '';
    code += 'else { return ' + defaultValue + '; }\n';
    code += '})()';
    return code;
  };
}

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/templates/AppView.jsx":[function(require,module,exports){
'use strict';

var ProtectedStatefulDiv = require('./ProtectedStatefulDiv.jsx');
var StudioAppWrapper = require('./StudioAppWrapper.jsx');

/**
 * Top-level React wrapper for our standard blockly apps.
 */
var AppView = React.createClass({
  displayName: 'AppView',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired,
    isEmbedView: React.PropTypes.bool.isRequired,
    isShareView: React.PropTypes.bool.isRequired,
    renderCodeWorkspace: React.PropTypes.func.isRequired,
    renderVisualizationColumn: React.PropTypes.func.isRequired,
    onMount: React.PropTypes.func.isRequired
  },

  componentDidMount: function componentDidMount() {
    this.props.onMount();
  },

  render: function render() {
    return React.createElement(
      StudioAppWrapper,
      {
        assetUrl: this.props.assetUrl,
        isEmbedView: this.props.isEmbedView,
        isShareView: this.props.isShareView },
      React.createElement(ProtectedStatefulDiv, {
        id: 'visualizationColumn',
        renderContents: this.props.renderVisualizationColumn }),
      React.createElement(ProtectedStatefulDiv, { id: 'visualizationResizeBar', className: 'fa fa-ellipsis-v' }),
      React.createElement(ProtectedStatefulDiv, {
        id: 'codeWorkspace',
        renderContents: this.props.renderCodeWorkspace })
    );
  }
});
module.exports = AppView;

},{"./ProtectedStatefulDiv.jsx":"/home/ubuntu/staging/apps/build/js/templates/ProtectedStatefulDiv.jsx","./StudioAppWrapper.jsx":"/home/ubuntu/staging/apps/build/js/templates/StudioAppWrapper.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/visualizationColumn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var msg = require('../locale');
var hideRunButton = locals.hideRunButton || false;
; buf.push('\n\n');6; var gameButtons = function() {; buf.push('<div id="gameButtons">\n  <button id="runButton" class="launch blocklyLaunch ', escape((7,  hideRunButton ? 'invisible' : '')), '">\n    <div>', escape((8,  msg.runProgram() )), '</div>\n    <img src="', escape((9,  assetUrl('media/1x1.gif') )), '" class="run26"/>\n  </button>\n  <button id="resetButton" class="launch blocklyLaunch" style="display: none">\n    <div>', escape((12,  msg.resetProgram() )), '</div>\n    <img src="', escape((13,  assetUrl('media/1x1.gif') )), '" class="reset26"/>\n  </button>\n  ');15; if (data.controls) { ; buf.push('\n    ', (16,  data.controls ), '\n  ');17; } ; buf.push('\n  ');18; if (!data.pinWorkspaceToBottom && data.extraControlRows) { ; buf.push('\n    ', (19,  data.extraControlRows ), '\n  ');20; } ; buf.push('\n</div>\n');22; };; buf.push('\n<div id="visualization">\n  ', (24,  data.visualization ), '\n</div>\n\n');27; gameButtons() ; buf.push('\n\n<div id="belowVisualization">\n\n  <div id="bubble" class="clearfix">\n    <table id="prompt-table">\n      <tr>\n        <td id="prompt-icon-cell" style="display: none">\n          <img id="prompt-icon"/>\n        </td>\n        <td id="prompt-cell">\n          <p id="prompt">\n          <p id="prompt2" style="display:none">\n          </p>\n        </td>\n      </tr>\n    </table>\n    ');44; if (data.inputOutputTable) { ; buf.push('\n      <div id="input-table">\n        <table>\n          <tr>\n            <th>Input</th>\n            <th>Output</th>\n          </tr>\n          ');51; for (var i = 0; i < data.inputOutputTable.length; i++) { ; buf.push('\n          <tr>\n            <td>', (53,  data.inputOutputTable[i][0] ), '</td>\n            <td>', (54,  data.inputOutputTable[i][1] ), '</td>\n          </tr>\n          ');56; } ; buf.push('\n        </table>\n      </div>\n    ');59; } ; buf.push('\n    <div id="ani-gif-preview-wrapper">\n      <div id="ani-gif-preview">\n      </div>\n    </div>\n  </div>\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/codeWorkspace.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1;
var msg = require('../locale');
; buf.push('\n\n<div id="codeWorkspaceWrapper">\n  <div id="headers" dir="', escape((6,  data.localeDirection )), '">\n    <div id="codeModeHeaders">\n      <div id="toolbox-header" class="workspace-header">\n        <i id="hide-toolbox-icon" style="display:none;" class="fa fa-chevron-circle-right"></i>\n        <span>', escape((10,  data.editCode ? msg.toolboxHeaderDroplet() : msg.toolboxHeader() )), '</span>\n      </div>\n      <div id="show-toolbox-header" class="workspace-header" style="display:none;">\n        <i id="show-toolbox-icon" class="fa fa-chevron-circle-right"></i>\n        <span>', escape((14,  msg.showToolbox() )), '</span>\n      </div>\n      <div id="show-code-header" class="workspace-header workspace-header-button"><span><img src="', escape((16,  assetUrl('media/applab/blocks_glyph.gif') )), '" class="blocks-glyph" /><i class="fa fa-code"></i>', escape((16,  msg.showCodeHeader() )), '</span></div>\n      ');17; if (!data.readonlyWorkspace) { ; buf.push('\n        <div id="clear-puzzle-header" class="workspace-header workspace-header-button"><span><i class="fa fa-undo"></i>', escape((18,  msg.clearPuzzle() )), '</span></div>\n      ');19; } ; buf.push('\n      <div id="versions-header" class="workspace-header workspace-header-button"><span><i class="fa fa-clock-o"></i>', escape((20,  msg.showVersionsHeader() )), '</span></div>\n      <div id="workspace-header" class="workspace-header">\n        <span id="workspace-header-span">\n          ', escape((23,  data.readonlyWorkspace ? msg.readonlyWorkspaceHeader() : msg.workspaceHeaderShort() )), '\n        </span>\n        <div id="blockCounter">\n          <div id="blockUsed" class=', escape((26,  data.blockCounterClass )), '>\n            ', escape((27,  data.blockUsed )), '\n          </div>\n          <span>/</span>\n          <span id="idealBlockNumber">', escape((30,  data.idealBlockNumber )), '</span>\n          <span> ', escape((31,  msg.blocks() )), '</span>\n        </div>\n      </div>\n    </div>\n  </div>\n  ');36; if (data.editCode) { ; buf.push('\n    <div id="codeTextbox"></div>\n  ');38; } ; buf.push('\n  ');39; if (data.pinWorkspaceToBottom && data.extraControlRows) { ; buf.push('\n    ', (40,  data.extraControlRows ), '\n  ');41; } ; buf.push('\n</div>\n');43; if (data.hasDesignMode) { ; buf.push('\n  <div id="designWorkspace" style="display:none;">\n</div>\n');46; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/skins.js":[function(require,module,exports){
// avatar: A 1029x51 set of 21 avatar images.

'use strict';

exports.load = function (assetUrl, id) {
  var skinUrl = function skinUrl(path) {
    if (path !== undefined) {
      return assetUrl('media/skins/' + id + '/' + path);
    } else {
      return null;
    }
  };

  var skin = {
    id: id,
    assetUrl: skinUrl,
    // Images
    avatar: skinUrl('avatar.png'),
    avatar_2x: skinUrl('avatar_2x.png'),
    goal: skinUrl('goal.png'),
    obstacle: skinUrl('obstacle.png'),
    smallStaticAvatar: skinUrl('small_static_avatar.png'),
    staticAvatar: skinUrl('static_avatar.png'),
    winAvatar: skinUrl('win_avatar.png'),
    failureAvatar: skinUrl('failure_avatar.png'),
    decorationAnimation: skinUrl('decoration_animation.png'),
    decorationAnimation_2x: skinUrl('decoration_animation_2x.png'),
    repeatImage: assetUrl('media/common_images/repeat-arrows.png'),
    leftArrow: assetUrl('media/common_images/moveleft.png'),
    downArrow: assetUrl('media/common_images/movedown.png'),
    upArrow: assetUrl('media/common_images/moveup.png'),
    rightArrow: assetUrl('media/common_images/moveright.png'),
    leftJumpArrow: assetUrl('media/common_images/jumpleft.png'),
    downJumpArrow: assetUrl('media/common_images/jumpdown.png'),
    upJumpArrow: assetUrl('media/common_images/jumpup.png'),
    rightJumpArrow: assetUrl('media/common_images/jumpright.png'),
    northLineDraw: assetUrl('media/common_images/draw-north.png'),
    southLineDraw: assetUrl('media/common_images/draw-south.png'),
    eastLineDraw: assetUrl('media/common_images/draw-east.png'),
    westLineDraw: assetUrl('media/common_images/draw-west.png'),
    shortLineDraw: assetUrl('media/common_images/draw-short.png'),
    longLineDraw: assetUrl('media/common_images/draw-long.png'),
    shortLineDrawRight: assetUrl('media/common_images/draw-short-right.png'),
    longLineDrawRight: assetUrl('media/common_images/draw-long-right.png'),
    longLine: assetUrl('media/common_images/move-long.png'),
    shortLine: assetUrl('media/common_images/move-short.png'),
    soundIcon: assetUrl('media/common_images/play-sound.png'),
    clickIcon: assetUrl('media/common_images/when-click-hand.png'),
    startIcon: assetUrl('media/common_images/when-run.png'),
    runArrow: assetUrl('media/common_images/run-arrow.png'),
    endIcon: assetUrl('media/common_images/end-icon.png'),
    speedFast: assetUrl('media/common_images/speed-fast.png'),
    speedMedium: assetUrl('media/common_images/speed-medium.png'),
    speedSlow: assetUrl('media/common_images/speed-slow.png'),
    scoreCard: assetUrl('media/common_images/increment-score-75percent.png'),
    rainbowMenu: assetUrl('media/common_images/rainbow-menuicon.png'),
    ropeMenu: assetUrl('media/common_images/rope-menuicon.png'),
    squigglyMenu: assetUrl('media/common_images/squiggly-menuicon.png'),
    swirlyMenu: assetUrl('media/common_images/swirlyline-menuicon.png'),
    patternDefault: assetUrl('media/common_images/defaultline-menuicon.png'),
    rainbowLine: assetUrl('media/common_images/rainbow.png'),
    ropeLine: assetUrl('media/common_images/rope.png'),
    squigglyLine: assetUrl('media/common_images/squiggly.png'),
    swirlyLine: assetUrl('media/common_images/swirlyline.png'),
    randomPurpleIcon: assetUrl('media/common_images/random-purple.png'),

    // Sounds
    startSound: [skinUrl('start.mp3'), skinUrl('start.ogg')],
    winSound: [skinUrl('win.mp3'), skinUrl('win.ogg')],
    failureSound: [skinUrl('failure.mp3'), skinUrl('failure.ogg')],

    // Stickers
    stickers: {
      elephant: assetUrl('media/common_images/stickers/elephant.png'),
      dragon: assetUrl('media/common_images/stickers/dragon.png'),
      triceratops: assetUrl('media/common_images/stickers/triceratops.png'),
      monkey: assetUrl('media/common_images/stickers/monkey.png'),
      cat: assetUrl('media/common_images/stickers/cat.png'),
      turtle: assetUrl('media/common_images/stickers/turtle.png'),
      goat: assetUrl('media/common_images/stickers/goat.png'),
      zebra: assetUrl('media/common_images/stickers/zebra.png'),
      hippo: assetUrl('media/common_images/stickers/hippo.png'),
      bunny: assetUrl('media/common_images/stickers/bunny.png'),
      peacock: assetUrl('media/common_images/stickers/peacock.png'),
      llama: assetUrl('media/common_images/stickers/llama.png'),
      giraffe: assetUrl('media/common_images/stickers/giraffe.png'),
      mouse: assetUrl('media/common_images/stickers/mouse.png'),
      beaver: assetUrl('media/common_images/stickers/beaver.png'),
      bat: assetUrl('media/common_images/stickers/bat.png'),
      grasshopper: assetUrl('media/common_images/stickers/grasshopper.png'),
      chicken: assetUrl('media/common_images/stickers/chicken.png'),
      moose: assetUrl('media/common_images/stickers/moose.png'),
      owl: assetUrl('media/common_images/stickers/owl.png'),
      penguin: assetUrl('media/common_images/stickers/penguin.png'),
      lion: assetUrl('media/common_images/stickers/lion.png'),
      robot: assetUrl('media/common_images/stickers/robot.png'),
      rocket: assetUrl('media/common_images/stickers/rocket.png')
    }
  };

  return skin;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/getAssetDropdown.js":[function(require,module,exports){
/* global Dialog, dashboard, Applab */
// TODO (josh) - don't pass `Dialog` into `createModalDialog`.

'use strict';

var assetListStore = require('./assetListStore');
var showAssetManager = require('./show');
var commonMsg = require('../locale');
var utils = require('../utils');

/**
 * Returns a list of options (optionally filtered by type) for code-mode
 * asset dropdowns.
 */
module.exports = function (typeFilter) {
  var options = assetListStore.list(typeFilter).map(function (asset) {
    return {
      text: utils.quote(asset.filename),
      display: utils.quote(asset.filename)
    };
  });
  var handleChooseClick = function handleChooseClick(callback) {
    showAssetManager(function (filename) {
      callback(utils.quote(filename));
    }, typeFilter);
  };
  options.push({
    text: commonMsg.choosePrefix(),
    display: '<span class="chooseAssetDropdownOption">' + commonMsg.choosePrefix() + '</a>',
    click: handleChooseClick
  });
  return options;
};

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","../utils":"/home/ubuntu/staging/apps/build/js/utils.js","./assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js","./show":"/home/ubuntu/staging/apps/build/js/assetManagement/show.js"}],"/home/ubuntu/staging/apps/build/js/timeoutList.js":[function(require,module,exports){
"use strict";

var timeoutList = [];

/**
 * call setTimeout and track the returned id
 */
exports.setTimeout = function (fn, time) {
  var timeout = window.setTimeout.apply(window, arguments);
  timeoutList.push(timeout);
  return timeout;
};

/**
 * Clears all timeouts in our timeoutList and resets the timeoutList
 */
exports.clearTimeouts = function () {
  timeoutList.forEach(window.clearTimeout, window);
  timeoutList = [];
};

/**
 * Clears a timeout and removes the item from the timeoutList
 */
exports.clearTimeout = function (id) {
  window.clearTimeout(id);
  // List removal requires IE9+
  var index = timeoutList.indexOf(id);
  if (index > -1) {
    timeoutList.splice(index, 1);
  }
};

var intervalList = [];

/**
 * call setInterval and track the returned id
 */
exports.setInterval = function (fn, time) {
  var interval = window.setInterval.apply(window, arguments);
  intervalList.push(interval);
  return interval;
};

/**
 * Clears all interval timeouts in our intervalList and resets the intervalList
 */
exports.clearIntervals = function () {
  intervalList.forEach(window.clearInterval, window);
  intervalList = [];
};

/**
 * Clears a timeout and removes the item from the intervalList
 */
exports.clearInterval = function (id) {
  window.clearInterval(id);
  // List removal requires IE9+
  var index = intervalList.indexOf(id);
  if (index > -1) {
    intervalList.splice(index, 1);
  }
};

},{}],"/home/ubuntu/staging/apps/node_modules/lodash/dist/lodash.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","readable-stream/duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/duplex.js","readable-stream/passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js","readable-stream/readable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/readable.js","readable-stream/transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/transform.js","readable-stream/writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/writable.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/readable.js":[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js","buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","events":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js","inherits":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js","isarray":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/isarray/index.js","stream":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/stream-browserify/index.js","string_decoder/":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/string_decoder/index.js","util":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/string_decoder/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})

},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js":[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){
arguments[4]["/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/show.js":[function(require,module,exports){
/* global Dialog, dashboard, Applab */
// TODO (josh) - don't pass `Dialog` into `createModalDialog`.

'use strict';

var AssetManager = require('./AssetManager.jsx');
var studioApp = require('../StudioApp').singleton;

/**
 * Display the "Manage Assets" modal.
 * @param assetChosen {Function} Called when the user chooses an asset. The
 *   "Choose" button in the UI only appears if this optional param is provided.
 * @param typeFilter {String} The type of assets to show and allow to be
 *   uploaded.
 */
module.exports = function (assetChosen, typeFilter) {
  var codeDiv = document.createElement('div');
  var showChoseImageButton = assetChosen && typeof assetChosen === 'function';
  var dialog = studioApp.createModalDialog({
    contentDiv: codeDiv,
    defaultBtnSelector: 'again-button',
    id: 'manageAssetsModal'
  });
  React.render(React.createElement(AssetManager, {
    typeFilter: typeFilter,
    channelId: dashboard.project.getCurrentId(),
    uploadsEnabled: !dashboard.project.exceedsAbuseThreshold(),
    assetChosen: showChoseImageButton ? function (fileWithPath) {
      dialog.hide();
      assetChosen(fileWithPath);
    } : null
  }), codeDiv);

  dialog.show();
};

},{"../StudioApp":"/home/ubuntu/staging/apps/build/js/StudioApp.js","./AssetManager.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetManager.jsx"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetManager.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;
var AssetRow = require('./AssetRow.jsx');
var AssetUploader = require('./AssetUploader.jsx');
var assetListStore = require('./assetListStore');

var errorMessages = {
  403: 'Quota exceeded. Please delete some files and try again.',
  413: 'The file is too large.',
  415: 'This type of file is not supported.',
  500: 'The server responded with an error.',
  unknown: 'An unknown error occurred.'
};

var errorUploadDisabled = "This project has been reported for abusive content, " + "so uploading new assets is disabled.";

function getErrorMessage(status) {
  return errorMessages[status] || errorMessages.unknown;
}

/**
 * A component for managing hosted assets.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    assetChosen: React.PropTypes.func,
    typeFilter: React.PropTypes.string,
    channelId: React.PropTypes.string.isRequired,
    uploadsEnabled: React.PropTypes.bool.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      assets: null,
      statusMessage: this.props.uploadsEnabled ? '' : errorUploadDisabled
    };
  },

  componentWillMount: function componentWillMount() {
    // TODO: Use Dave's client api when it's finished.
    assetsApi.ajax('GET', '', this.onAssetListReceived, this.onAssetListFailure);
  },

  /**
   * Called after the component mounts, when the server responds with the
   * current list of assets.
   * @param xhr
   */
  onAssetListReceived: function onAssetListReceived(xhr) {
    assetListStore.reset(JSON.parse(xhr.responseText));
    this.setState({ assets: assetListStore.list(this.props.typeFilter) });
  },

  /**
   * Called after the component mounts, if the server responds with an error
   * when loading the current list of assets.
   * @param xhr
   */
  onAssetListFailure: function onAssetListFailure(xhr) {
    this.setState({ statusMessage: 'Error loading asset list: ' + getErrorMessage(xhr.status) });
  },

  onUploadStart: function onUploadStart() {
    this.setState({ statusMessage: 'Uploading...' });
  },

  onUploadDone: function onUploadDone(result) {
    assetListStore.add(result);
    this.setState({
      assets: assetListStore.list(this.props.typeFilter),
      statusMessage: 'File "' + result.filename + '" successfully uploaded!'
    });
  },

  onUploadError: function onUploadError(status) {
    this.setState({ statusMessage: 'Error uploading file: ' + getErrorMessage(status) });
  },

  deleteAssetRow: function deleteAssetRow(name) {
    this.setState({
      assets: assetListStore.remove(name),
      statusMessage: 'File "' + name + '" successfully deleted!'
    });
  },

  render: function render() {
    var uploadButton = React.createElement(
      'div',
      null,
      React.createElement(AssetUploader, {
        uploadsEnabled: this.props.uploadsEnabled,
        typeFilter: this.props.typeFilter,
        channelId: this.props.channelId,
        onUploadStart: this.onUploadStart,
        onUploadDone: this.onUploadDone,
        onUploadError: this.onUploadError }),
      React.createElement(
        'span',
        { style: { margin: '0 10px' }, id: 'manage-asset-status' },
        this.state.statusMessage
      )
    );

    var assetList;
    // If `this.state.assets` is null, the asset list is still loading. If it's
    // empty, the asset list has loaded and there are no assets in the current
    // channel (matching the `typeFilter`, if one was provided).
    if (this.state.assets === null) {
      assetList = React.createElement(
        'div',
        { style: { margin: '1em 0', textAlign: 'center' } },
        React.createElement('i', { className: 'fa fa-spinner fa-spin', style: { fontSize: '32px' } })
      );
    } else if (this.state.assets.length === 0) {
      assetList = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { margin: '1em 0' } },
          'Your assets will appear here. Click "Upload File" to add a new asset for this project.'
        ),
        uploadButton
      );
    } else {
      var rows = this.state.assets.map((function (asset) {
        var choose = this.props.assetChosen && this.props.assetChosen.bind(this, asset.filename);

        return React.createElement(AssetRow, {
          key: asset.filename,
          name: asset.filename,
          type: asset.category,
          size: asset.size,
          onChoose: choose,
          onDelete: this.deleteAssetRow.bind(this, asset.filename) });
      }).bind(this));

      assetList = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { maxHeight: '330px', overflowY: 'scroll', margin: '1em 0', paddingRight: '15px' } },
          React.createElement(
            'table',
            { style: { width: '100%' } },
            React.createElement(
              'tbody',
              null,
              rows
            )
          )
        ),
        uploadButton
      );
    }

    var title = this.props.assetChosen ? React.createElement(
      'p',
      { className: 'dialog-title' },
      'Choose Assets'
    ) : React.createElement(
      'p',
      { className: 'dialog-title' },
      'Manage Assets'
    );

    return React.createElement(
      'div',
      { className: 'modal-content', style: { margin: 0 } },
      title,
      assetList
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./AssetRow.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetRow.jsx","./AssetUploader.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetUploader.jsx","./assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetUploader.jsx":[function(require,module,exports){

/**
 * A component for managing hosted assets.
 */
'use strict';

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    onUploadStart: React.PropTypes.func.isRequired,
    onUploadDone: React.PropTypes.func.isRequired,
    channelId: React.PropTypes.string.isRequired,
    typeFilter: React.PropTypes.string,
    uploadsEnabled: React.PropTypes.bool.isRequired
  },

  componentDidMount: function componentDidMount() {
    var props = this.props;

    $(React.findDOMNode(this.refs.uploader)).fileupload({
      dataType: 'json',
      url: '/v3/assets/' + props.channelId + '/',
      // prevent fileupload from replacing the input DOM element, which
      // React does not like
      replaceFileInput: false,
      add: function add(e, data) {
        props.onUploadStart();
        data.submit();
      },
      done: function done(e, data) {
        props.onUploadDone(data.result);
      },
      error: function error(e, data) {
        props.onUploadError(e.status);
      }
    });
  },

  componentWillUnmount: function componentWillUnmount() {
    $(React.findDOMNode(this.refs.uploader)).fileupload('destroy');
  },

  /**
   * We've hidden the <input type="file"/> and replaced it with a big button.
   * Forward clicks on the button to the hidden file input.
   */
  fileUploadClicked: function fileUploadClicked() {
    var uploader = React.findDOMNode(this.refs.uploader);
    uploader.click();
  },

  render: function render() {
    // NOTE: IE9 will ignore accept, which means on this browser we can end
    // up uploading files that dont match typeFilter
    return React.createElement(
      'span',
      null,
      React.createElement('input', {
        ref: 'uploader',
        type: 'file',
        style: { display: 'none' },
        accept: (this.props.typeFilter || '*') + '/*' }),
      React.createElement(
        'button',
        {
          onClick: this.fileUploadClicked,
          className: 'share',
          id: 'upload-asset',
          disabled: !this.props.uploadsEnabled },
        React.createElement('i', { className: 'fa fa-upload' }),
        'Upload File'
      )
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetRow.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;
var AssetThumbnail = require('./AssetThumbnail.jsx');

/**
 * A single row in the AssetManager, describing one asset.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    name: React.PropTypes.string.isRequired,
    type: React.PropTypes.oneOf(['image', 'audio', 'video']).isRequired,
    size: React.PropTypes.number,
    onChoose: React.PropTypes.func,
    onDelete: React.PropTypes.func.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      action: 'normal',
      actionText: ''
    };
  },

  /**
   * Confirm the user actually wants to delete this asset.
   */
  confirmDelete: function confirmDelete() {
    this.setState({ action: 'confirming delete', actionText: '' });
  },

  /**
   * This user didn't want to delete this asset.
   */
  cancelDelete: function cancelDelete() {
    this.setState({ action: 'normal', actionText: '' });
  },

  /**
   * Delete this asset and notify the parent to remove this row. If the delete
   * fails, flip back to 'confirming delete' and display a message.
   */
  handleDelete: function handleDelete() {
    this.setState({ action: 'deleting', actionText: '' });

    // TODO: Use Dave's client api when it's finished.
    assetsApi.ajax('DELETE', this.props.name, this.props.onDelete, (function () {
      this.setState({ action: 'confirming delete',
        actionText: 'Error deleting file.' });
    }).bind(this));
  },

  render: function render() {
    var actions, flex;
    // `flex` is the "Choose" button in file-choose mode, or the filesize.
    if (this.props.onChoose) {
      flex = React.createElement(
        'button',
        { onClick: this.props.onChoose },
        'Choose'
      );
    } else {
      var size = (this.props.size / 1000).toFixed(2);
      flex = size + ' kb';
    }

    switch (this.state.action) {
      case 'normal':
        var src = assetsApi.basePath(this.props.name);
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          flex,
          React.createElement(
            'a',
            { href: src,
              target: '_blank',
              style: { backgroundColor: 'transparent' } },
            React.createElement(
              'button',
              null,
              React.createElement('i', { className: 'fa fa-eye' })
            )
          ),
          React.createElement(
            'button',
            { className: 'btn-danger', onClick: this.confirmDelete },
            React.createElement('i', { className: 'fa fa-trash-o' })
          ),
          this.state.actionText
        );
        break;
      case 'confirming delete':
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          React.createElement(
            'button',
            { className: 'btn-danger', onClick: this.handleDelete },
            'Delete File'
          ),
          React.createElement(
            'button',
            { onClick: this.cancelDelete },
            'Cancel'
          ),
          this.state.actionText
        );
        break;
      case 'deleting':
        actions = React.createElement(
          'td',
          { width: '250', style: { textAlign: 'right' } },
          React.createElement('i', { className: 'fa fa-spinner fa-spin', style: {
              fontSize: '32px',
              marginRight: '15px'
            } })
        );
        break;
    }

    return React.createElement(
      'tr',
      { className: 'assetRow', onDoubleClick: this.props.onChoose },
      React.createElement(AssetThumbnail, { type: this.props.type, name: this.props.name }),
      React.createElement(
        'td',
        null,
        this.props.name
      ),
      actions
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./AssetThumbnail.jsx":"/home/ubuntu/staging/apps/build/js/assetManagement/AssetThumbnail.jsx"}],"/home/ubuntu/staging/apps/build/js/assetManagement/AssetThumbnail.jsx":[function(require,module,exports){
'use strict';

var assetsApi = require('../clientApi').assets;

var defaultIcons = {
  image: 'fa fa-picture-o',
  audio: 'fa fa-music',
  video: 'fa fa-video-camera',
  unknown: 'fa fa-question'
};

var assetThumbnailStyle = {
  width: 'auto',
  maxWidth: '100%',
  height: 'auto',
  maxHeight: '100%',
  marginTop: '50%',
  transform: 'translateY(-50%)',
  msTransform: 'translateY(-50%)',
  WebkitTransform: 'translateY(-50%)'
};

var assetIconStyle = {
  margin: '15px 0',
  fontSize: '32px'
};

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    name: React.PropTypes.string.isRequired,
    type: React.PropTypes.oneOf(['image', 'audio', 'video']).isRequired
  },

  render: function render() {
    var type = this.props.type;
    var name = this.props.name;

    return React.createElement(
      'td',
      { width: '80' },
      React.createElement(
        'div',
        { className: 'assetThumbnail', style: {
            width: '60px',
            height: '60px',
            margin: '10px auto',
            background: '#eee',
            border: '1px solid #ccc',
            textAlign: 'center'
          } },
        type === 'image' ? React.createElement('img', { src: assetsApi.basePath(name), style: assetThumbnailStyle }) : React.createElement('i', { className: defaultIcons[type] || defaultIcons.unknown, style: assetIconStyle })
      )
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js"}],"/home/ubuntu/staging/apps/build/js/templates/StudioAppWrapper.jsx":[function(require,module,exports){
'use strict';

var RotateContainer = require('../templates/RotateContainer.jsx');

/**
 * Wrapper component for all Code Studio app types, which provides rotate
 * container and clear-div but otherwise just renders children.
 */
var StudioAppWrapper = React.createClass({
  displayName: 'StudioAppWrapper',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired,
    isEmbedView: React.PropTypes.bool.isRequired,
    isShareView: React.PropTypes.bool.isRequired
  },

  requiresLandscape: function requiresLandscape() {
    return !(this.props.isEmbedView || this.props.isShareView);
  },

  render: function render() {
    return React.createElement(
      'div',
      null,
      this.requiresLandscape() && React.createElement(RotateContainer, { assetUrl: this.props.assetUrl }),
      this.props.children,
      React.createElement('div', { className: 'clear' })
    );
  }
});
module.exports = StudioAppWrapper;

},{"../templates/RotateContainer.jsx":"/home/ubuntu/staging/apps/build/js/templates/RotateContainer.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/RotateContainer.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');

/**
 * "Rotate your device" overlay.
 */
var RotateContainer = React.createClass({
  displayName: 'RotateContainer',

  propTypes: {
    assetUrl: React.PropTypes.func.isRequired
  },

  render: function render() {
    return React.createElement(
      'div',
      { id: 'rotateContainer', style: this.getStyle() },
      React.createElement(
        'div',
        { id: 'rotateText' },
        React.createElement(
          'p',
          null,
          msg.rotateText(),
          React.createElement('br', null),
          msg.orientationLock()
        )
      )
    );
  },

  getStyle: function getStyle() {
    return {
      backgroundImage: 'url(' + this.props.assetUrl('media/turnphone_horizontal.png') + ')'
    };
  }
});
module.exports = RotateContainer;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/templates/ProtectedStatefulDiv.jsx":[function(require,module,exports){
'use strict';

/**
 * A div DOM element that will never update its contents and will throw an
 * exception if it is ever unmounted, enforcing that it must always be rendered
 * because its contents may contain state that the application is depending on.
 *
 * Useful when React is wrapping external libraries or parts of our UI that are
 * not yet driven by React.
 */

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ProtectedStatefulDiv = React.createClass({
  displayName: 'ProtectedStatefulDiv',

  propTypes: {
    renderContents: React.PropTypes.func
  },

  shouldComponentUpdate: function shouldComponentUpdate() {
    return false;
  },

  componentDidMount: function componentDidMount() {
    if (typeof this.props.renderContents === 'function') {
      this.refs.root.getDOMNode().innerHTML = this.props.renderContents();
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    throw new Error("Unmounting a ProtectedStatefulDiv is not allowed.");
  },

  render: function render() {
    return React.createElement('div', _extends({}, this.props, { ref: 'root' }));
  }
});
module.exports = ProtectedStatefulDiv;

},{}],"/home/ubuntu/staging/apps/build/js/appMain.js":[function(require,module,exports){
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();
var requiredBlockUtils = require('./required_block_utils');
var studioApp = require('./StudioApp').singleton;
var authoredHintUtils = require('./authoredHintUtils');

// TODO (br-pair) : This is to expose methods we need in the global namespace
// for testing purpose. Would be nice to eliminate this eventually.
window.__TestInterface = {
  loadBlocks: _.bind(studioApp.loadBlocks, studioApp),
  arrangeBlockPosition: _.bind(studioApp.arrangeBlockPosition, studioApp),
  getDropletContents: function getDropletContents() {
    return _.bind(studioApp.editor.getValue, studioApp.editor)();
  },
  getDroplet: function getDroplet() {
    return studioApp.editor;
  },
  // Set to true to ignore onBeforeUnload events
  ignoreOnBeforeUnload: false
};

var addReadyListener = require('./dom').addReadyListener;
var blocksCommon = require('./blocksCommon');

module.exports = function (app, levels, options) {

  // If a levelId is not provided, then options.level is specified in full.
  // Otherwise, options.level overrides resolved level on a per-property basis.
  if (options.levelId) {
    var level = levels[options.levelId];
    options.level = options.level || {};
    options.level.id = options.levelId;
    for (var prop in options.level) {
      level[prop] = options.level[prop];
    }

    if (options.level.levelBuilderRequiredBlocks) {
      level.requiredBlocks = requiredBlockUtils.makeTestsFromBuilderRequiredBlocks(options.level.levelBuilderRequiredBlocks);
    }
    if (options.level.levelBuilderRecommendedBlocks) {
      level.recommendedBlocks = requiredBlockUtils.makeTestsFromBuilderRequiredBlocks(options.level.levelBuilderRecommendedBlocks);
    }

    if (options.level.authoredHints) {
      level.authoredHints = authoredHintUtils.generateAuthoredHints(options.level.authoredHints);
    }

    options.level = level;
  }

  studioApp.configure(options);

  options.skin = options.skinsModule.load(studioApp.assetUrl, options.skinId);

  if (studioApp.isUsingBlockly()) {
    var blockInstallOptions = {
      skin: options.skin,
      isK1: options.level && options.level.isK1,
      level: options.level
    };

    if (options.level && options.level.edit_blocks) {
      utils.wrapNumberValidatorsForLevelBuilder();
    }

    blocksCommon.install(Blockly, blockInstallOptions);
    options.blocksModule.install(Blockly, blockInstallOptions);
  }

  addReadyListener(function () {
    if (options.readonly) {
      if (app.initReadonly) {
        app.initReadonly(options);
      } else {
        studioApp.initReadonly(options);
      }
    } else {
      app.init(options);
      if (options.onInitialize) {
        options.onInitialize();
      }
    }
  });
};

},{"./StudioApp":"/home/ubuntu/staging/apps/build/js/StudioApp.js","./authoredHintUtils":"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js","./blocksCommon":"/home/ubuntu/staging/apps/build/js/blocksCommon.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./required_block_utils":"/home/ubuntu/staging/apps/build/js/required_block_utils.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/required_block_utils.js":[function(require,module,exports){
/* global Text */

'use strict';

var xml = require('./xml');
var blockUtils = require('./block_utils');
var utils = require('./utils');
var msg = require('./locale');
var _ = utils.getLodash();

/**
 * Create the textual XML for a math_number block.
 * @param {number|string} number The numeric amount, expressed as a
 *     number or string.  Non-numeric strings may also be specified,
 *     such as '???'.
 * @return {string} The textual representation of a math_number block.
 */
exports.makeMathNumber = function (number) {
  return '<block type="math_number"><title name="NUM">' + number + '</title></block>';
};

/**
 * Generate a required blocks dictionary for a simple block that does not
 * have any parameters or values.
 * @param {string} block_type The block type.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.simpleBlock = function (block_type) {
  return { test: function test(block) {
      return block.type == block_type;
    },
    type: block_type };
};

/**
 * Generate a required blocks dictionary for a repeat loop.  This does not
 * test for the specified repeat count but includes it in the suggested block.
 * @param {number|string} count The suggested repeat count.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.repeat = function (count) {
  // This checks for a controls_repeat block rather than looking for 'for',
  // since the latter may be generated by Turtle 2's draw_a_square.
  return { test: function test(block) {
      return block.type == 'controls_repeat';
    },
    type: 'controls_repeat', titles: { 'TIMES': count } };
};

/**
 * Generate a required blocks dictionary for a simple repeat loop.  This does not
 * test for the specified repeat count but includes it in the suggested block.
 * @param {number|string} count The suggested repeat count.
 * @return {Object} A required blocks dictionary able to check for and
 *     generate the specified block.
 */
exports.repeatSimpleBlock = function (count) {
  return { test: function test(block) {
      return block.type == 'controls_repeat_simplified';
    },
    type: 'controls_repeat_simplified', titles: { 'TIMES': count } };
};

/**
 * Returns an array of required blocks by comparing a list of blocks with
 * a list of app specific block tests (defined in <app>/requiredBlocks.js)
 */
exports.makeTestsFromBuilderRequiredBlocks = function (customRequiredBlocks) {
  var blocksXml = xml.parseElement(customRequiredBlocks);

  var requiredBlocksTests = [];
  Array.prototype.forEach.call(blocksXml.childNodes, function (childNode) {
    // Only look at element nodes
    if (childNode.nodeType !== 1) {
      return;
    }
    switch (childNode.getAttribute('type')) {
      case 'pick_one':
        requiredBlocksTests.push(testsFromPickOne(childNode));
        break;
      case 'procedures_defnoreturn':
      case 'procedures_defreturn':
        requiredBlocksTests.push(testsFromProcedure(childNode));
        break;
      case 'functional_definition':
        break;
      case 'functional_call':
        requiredBlocksTests.push(testsFromFunctionalCall(childNode, blocksXml));
        break;
      default:
        requiredBlocksTests.push([testFromBlock(childNode)]);
    }
  });

  return requiredBlocksTests;
};

/**
 * Given xml for a single block generates a block test
 */
function testFromBlock(node) {
  return {
    test: function test(userBlock) {
      // Encode userBlock while ignoring child statements
      var userElement = Blockly.Xml.blockToDom(userBlock, true);
      return elementsEquivalent(node, userElement);
    },
    blockDisplayXML: xml.serialize(node)
  };
}

/**
 * Given xml for a pick_one block, generates a test that checks that at least
 * one of the child blocks is used.  If none are used, the first option will be
 * displayed as feedback
 */
function testsFromPickOne(node) {
  var tests = [];
  // child of pick_one is a statement block.  we want first child of that
  var statement = node.getElementsByTagName('statement')[0];
  var block = statement.getElementsByTagName('block')[0];
  var next;
  do {
    // if we have a next block, we want to generate our test without that
    next = block.getElementsByTagName('next')[0];
    if (next) {
      block.removeChild(next);
    }
    tests.push(testFromBlock(block));
    if (next) {
      block = next.getElementsByTagName('block')[0];
    }
  } while (next);
  return tests;
}

/**
 * Given xml for a procedure block, generates tests that check for required
 * number of params not declared
 */
function testsFromProcedure(node) {
  var paramCount = node.querySelectorAll('mutation > arg').length;
  var emptyBlock = node.cloneNode(true);
  emptyBlock.removeChild(emptyBlock.lastChild);
  return [{
    // Ensure that all required blocks match a block with the same number of
    // params. There's no guarantee users will name their function the same as
    // the required block, so only match on number of params.
    test: function test(userBlock) {
      if (userBlock.type === node.getAttribute('type')) {
        return paramCount === userBlock.parameterNames_.length;
      }
      // Block isn't the same type, return false to keep searching.
      return false;
    },
    message: msg.errorRequiredParamsMissing(),
    blockDisplayXML: '<xml></xml>'
  }];
}

function testsFromFunctionalCall(node, blocksXml) {
  var name = node.querySelector('mutation').getAttribute('name');
  var argElements = node.querySelectorAll('arg');
  var types = [];
  for (var i = 0; i < argElements.length; i++) {
    types.push(argElements[i].getAttribute('type'));
  }

  var definition = _.find(blocksXml.childNodes, function (sibling) {
    if (sibling.getAttribute('type') !== 'functional_definition') {
      return false;
    }
    var nameElement = sibling.querySelector('title[name="NAME"]');
    if (!nameElement) {
      return false;
    }
    return nameElement.textContent === name;
  });

  if (!definition) {
    throw new Error('No matching definition for functional_call');
  }

  return [{
    test: function test(userBlock) {
      if (userBlock.type !== 'functional_call' || userBlock.getCallName() !== name) {
        return false;
      }
      var userTypes = userBlock.getParamTypes();
      return _.isEqual(userTypes, types);
    },
    blockDisplayXML: xml.serialize(definition) + xml.serialize(node)
  }];
}

/**
 * Checks two DOM elements to see whether or not they are equivalent
 * We consider them equivalent if they have the same tagName, attributes,
 * and children
 */
function elementsEquivalent(expected, given) {
  if (!(expected instanceof Element && given instanceof Element)) {
    // if we expect ???, allow match with anything
    if (expected instanceof Text && expected.textContent === '???') {
      return true;
    }
    return expected.isEqualNode(given);
  }
  // Not fully clear to me why, but blockToDom seems to return us an element
  // with a tagName in all caps
  if (expected.tagName.toLowerCase() !== given.tagName.toLowerCase()) {
    return false;
  }

  if (!attributesEquivalent(expected, given)) {
    return false;
  }

  if (!childrenEquivalent(expected, given)) {
    return false;
  }

  return true;
}

/**
 * A list of attributes we want to ignore when comparing attributes, and a
 * function for easily determining whether an attribute is in the list.
 */
var ignorableAttributes = ['deletable', 'movable', 'editable', 'inline', 'uservisible', 'usercreated', 'id'];

ignorableAttributes.contains = function (attr) {
  return ignorableAttributes.indexOf(attr.name) !== -1;
};

/**
 * Checks whether the attributes for two different elements are equivalent
 */
function attributesEquivalent(expected, given) {
  var attributes1 = _.reject(expected.attributes, ignorableAttributes.contains);
  var attributes2 = _.reject(given.attributes, ignorableAttributes.contains);
  if (attributes1.length !== attributes2.length) {
    return false;
  }
  for (var i = 0; i < attributes1.length; i++) {
    var attr1 = attributes1[i];
    var attr2 = attributes2[i];
    if (attr1.name !== attr2.name) {
      return false;
    }
    if (attr1.value !== attr2.value) {
      return false;
    }
  }
  return true;
}

/**
 * Checks whether the children of two different elements are equivalent
 */
function childrenEquivalent(expected, given) {
  var children1 = expected.childNodes;
  var children2 = given.childNodes;
  if (children1.length !== children2.length) {
    return false;
  }
  for (var i = 0; i < children1.length; i++) {
    if (!elementsEquivalent(children1[i], children2[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Checks if two blocks are "equivalent"
 * Currently means their type and all of their titles match exactly
 * @param blockA
 * @param blockB
 */
exports.blocksMatch = function (blockA, blockB) {
  var typesMatch = blockA.type === blockB.type;
  var titlesMatch = exports.blockTitlesMatch(blockA, blockB);
  return typesMatch && titlesMatch;
};

/**
 * Compares two blocks' titles, returns true if they all match
 * @returns {boolean}
 * @param blockA
 * @param blockB
 */
exports.blockTitlesMatch = function (blockA, blockB) {
  var blockATitles = blockA.getTitles();
  var blockBTitles = blockB.getTitles();

  var nameCompare = function nameCompare(a, b) {
    return a.name < b.name;
  };
  blockATitles.sort(nameCompare);
  blockBTitles.sort(nameCompare);

  for (var i = 0; i < blockATitles.length || i < blockBTitles.length; i++) {
    var blockATitle = blockATitles[i];
    var blockBTitle = blockBTitles[i];
    if (!blockATitle || !blockBTitle || !titlesMatch(blockATitle, blockBTitle)) {
      return false;
    }
  }
  return true;
};

var titlesMatch = function titlesMatch(titleA, titleB) {
  return titleB.name === titleA.name && titleB.getValue() === titleA.getValue();
};

},{"./block_utils":"/home/ubuntu/staging/apps/build/js/block_utils.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/blocksCommon.js":[function(require,module,exports){
/**
 * Defines blocks useful in multiple blockly apps
 */
'use strict';

var commonMsg = require('./locale');

/**
 * Install extensions to Blockly's language and JavaScript generator
 * @param blockly instance of Blockly
 */
exports.install = function (blockly, blockInstallOptions) {
  var skin = blockInstallOptions.skin;
  var isK1 = blockInstallOptions.isK1;

  installControlsRepeatSimplified(blockly, skin);
  installControlsRepeatDropdown(blockly);
  installNumberDropdown(blockly);
  installPickOne(blockly);
  installCategory(blockly);
  installWhenRun(blockly, skin, isK1);
};

function installControlsRepeatSimplified(blockly, skin) {
  // Re-uses the repeat block generator from core
  blockly.JavaScript.controls_repeat_simplified = blockly.JavaScript.controls_repeat;
  blockly.JavaScript.controls_repeat_simplified_dropdown = blockly.JavaScript.controls_repeat;

  blockly.Blocks.controls_repeat_simplified = {
    // Repeat n times (internal number) with simplified UI
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldTextInput('10', blockly.FieldTextInput.nonnegativeIntegerValidator), 'TIMES');
      this.appendStatementInput('DO').appendTitle(new blockly.FieldImage(skin.repeatImage));
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };

  blockly.Blocks.controls_repeat_simplified_dropdown = {
    // Repeat n times (internal number) with simplified UI
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldDropdown(), 'TIMES');
      this.appendStatementInput('DO').appendTitle(new blockly.FieldImage(skin.repeatImage));
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };
}

function installControlsRepeatDropdown(blockly) {
  blockly.JavaScript.controls_repeat_dropdown = blockly.JavaScript.controls_repeat;

  blockly.Blocks.controls_repeat_dropdown = {
    // Repeat n times (internal number) with a customizable dropdown of # choices.
    init: function init() {
      this.setHelpUrl(blockly.Msg.CONTROLS_REPEAT_HELPURL);
      this.setHSV(322, 0.90, 0.95);
      this.appendDummyInput().appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_REPEAT).appendTitle(new blockly.FieldDropdown(), 'TIMES').appendTitle(blockly.Msg.CONTROLS_REPEAT_TITLE_TIMES);
      this.appendStatementInput('DO').appendTitle(blockly.Msg.CONTROLS_REPEAT_INPUT_DO);
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(blockly.Msg.CONTROLS_REPEAT_TOOLTIP);
    }
  };
}

function installNumberDropdown(blockly) {
  blockly.JavaScript.math_number_dropdown = blockly.JavaScript.math_number;

  blockly.Blocks.math_number_dropdown = {
    // Numeric value with a customizable dropdown.
    init: function init() {
      this.setHelpUrl(blockly.Msg.MATH_NUMBER_HELPURL);
      this.setHSV(258, 0.35, 0.62);
      this.appendDummyInput().appendTitle(new blockly.FieldDropdown(), 'NUM');
      this.setOutput(true, Blockly.BlockValueType.NUMBER);
      this.setTooltip(blockly.Msg.MATH_NUMBER_TOOLTIP);
    }
  };
}

// A "Pick 1" block for level editing, where you want to require that one of a
// set of blocks is used.
function installPickOne(blockly) {
  blockly.Blocks.pick_one = {
    // Repeat n times (internal number).
    init: function init() {
      this.setHSV(322, 0.90, 0.95);

      // Not localized as this is only used by level builders
      this.appendDummyInput().appendTitle('Pick one (Use only in required blocks)');
      this.appendStatementInput('PICK');
    }
  };

  blockly.JavaScript.pick_one = function () {
    return '\n';
  };
}

// A "Category" block for level editing, for delineating category groups.
function installCategory(blockly) {
  blockly.Blocks.category = {
    // Repeat n times (internal number).
    init: function init() {
      this.setHSV(322, 0.90, 0.95);
      this.setInputsInline(true);

      // Not localized as this is only used by level builders
      this.appendDummyInput().appendTitle('Category').appendTitle(new blockly.FieldTextInput('Name'), 'CATEGORY');
      this.setPreviousStatement(false);
      this.setNextStatement(false);
    }
  };

  blockly.JavaScript.category = function () {
    return '\n';
  };
}

function installWhenRun(blockly, skin, isK1) {
  blockly.Blocks.when_run = {
    // Block to handle event where mouse is clicked
    helpUrl: '',
    init: function init() {
      this.setHSV(39, 1.00, 0.99);
      if (isK1) {
        this.appendDummyInput().appendTitle(commonMsg.whenRun()).appendTitle(new blockly.FieldImage(skin.runArrow));
      } else {
        this.appendDummyInput().appendTitle(commonMsg.whenRun());
      }
      this.setPreviousStatement(false);
      this.setNextStatement(true);
    },
    shouldBeGrayedOut: function shouldBeGrayedOut() {
      return false;
    }
  };

  blockly.JavaScript.when_run = function () {
    // Generate JavaScript for handling click event.
    return '\n';
  };
}

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/StudioApp.js":[function(require,module,exports){
/* global Blockly, ace:true, droplet, marked, dashboard, addToHome */

'use strict';

var aceMode = require('./acemode/mode-javascript_codeorg');
var parseXmlElement = require('./xml').parseElement;
var utils = require('./utils');
var dropletUtils = require('./dropletUtils');
var _ = utils.getLodash();
var dom = require('./dom');
var constants = require('./constants.js');
var msg = require('./locale');
var blockUtils = require('./block_utils');
var DropletTooltipManager = require('./blockTooltips/DropletTooltipManager');
var url = require('url');
var FeedbackUtils = require('./feedback');
var VersionHistory = require('./templates/VersionHistory.jsx');
var Alert = require('./templates/alert.jsx');
var codegen = require('./codegen');
var puzzleRatingUtils = require('./puzzleRatingUtils');
var logToCloud = require('./logToCloud');
var AuthoredHints = require('./authoredHints');
var Instructions = require('./templates/Instructions.jsx');
var WireframeSendToPhone = require('./templates/WireframeSendToPhone.jsx');
var assetsApi = require('./clientApi').assets;
var assetPrefix = require('./assetManagement/assetPrefix');
var assetListStore = require('./assetManagement/assetListStore');
var copyrightStrings;

/**
* The minimum width of a playable whole blockly game.
*/
var MIN_WIDTH = 900;
var DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH = 320;
var MAX_VISUALIZATION_WIDTH = 400;
var MIN_VISUALIZATION_WIDTH = 200;

var ENGLISH_LOCALE = 'en_us';

/**
 * Treat mobile devices with screen.width less than the value below as phones.
 */
var MAX_PHONE_WIDTH = 500;

var StudioApp = function StudioApp() {
  this.feedback_ = new FeedbackUtils(this);
  this.authoredHintsController_ = new AuthoredHints(this);

  /**
  * The parent directory of the apps. Contains common.js.
  */
  this.BASE_URL = undefined;

  /**
  * The current locale code.
  */
  this.LOCALE = ENGLISH_LOCALE;

  this.enableShowCode = true;
  this.editCode = false;
  this.usingBlockly_ = true;

  /**
   * @type {AudioPlayer}
   */
  this.cdoSounds = null;
  this.Dialog = null;
  /**
   * @type {?Droplet.Editor}
   */
  this.editor = null;
  /**
   * @type {?DropletTooltipManager}
   */
  this.dropletTooltipManager = null;

  // @type {string} for all of these
  this.icon = undefined;
  this.smallIcon = undefined;
  this.winIcon = undefined;
  this.failureIcon = undefined;

  // The following properties get their non-default values set by the application.

  /**
   * Whether to alert user to empty blocks, short-circuiting all other tests.
   * @member {boolean}
   */
  this.checkForEmptyBlocks_ = false;

  /**
  * The ideal number of blocks to solve this level.  Users only get 2
  * stars if they use more than this number.
  * @type {number}
  */
  this.IDEAL_BLOCK_NUM = undefined;

  /**
   * @typedef {Object} TestableBlock
   * @property {string|function} test - A test whether the block is
   *           present, either:
   *           - A string, in which case the string is searched for in
   *             the generated code.
   *           - A single-argument function is called on each user-added
   *             block individually.  If any call returns true, the block
   *             is deemed present.  "User-added" blocks are ones that are
   *             neither disabled or undeletable.
   * @property {string} type - The type of block to be produced for
   *           display to the user if the test failed.
   * @property {Object} [titles] - A dictionary, where, for each
   *           KEY-VALUE pair, this is added to the block definition:
   *           <title name="KEY">VALUE</title>.
   * @property {Object} [value] - A dictionary, where, for each
   *           KEY-VALUE pair, this is added to the block definition:
   *           <value name="KEY">VALUE</value>
   * @property {string} [extra] - A string that should be blacked
   *           between the "block" start and end tags.
   */

  /**
  * @type {!TestableBlock[]}
  */
  this.requiredBlocks_ = [];

  /**
  * The number of required blocks to give hints about at any one time.
  * Set this to Infinity to show all.
  * @type {number}
  */
  this.maxRequiredBlocksToFlag_ = 1;

  /**
  * @type {!TestableBlock[]}
  */
  this.recommendedBlocks_ = [];

  /**
  * The number of recommended blocks to give hints about at any one time.
  * Set this to Infinity to show all.
  * @type {number}
  */
  this.maxRecommendedBlocksToFlag_ = 1;

  /**
  * The number of attempts (how many times the run button has been pressed)
  * @type {?number}
  */
  this.attempts = 0;

  /**
  * Stores the time at init. The delta to current time is used for logging
  * and reporting to capture how long it took to arrive at an attempt.
  * @type {?number}
  */
  this.initTime = undefined;

  /**
  * Enumeration of user program execution outcomes.
  */
  this.ResultType = constants.ResultType;

  /**
  * Enumeration of test results.
  */
  this.TestResults = constants.TestResults;

  /**
   * If true, we don't show blockspace. Used when viewing shared levels
   */
  this.hideSource = false;

  /**
   * If true, we're viewing a shared level.
   */
  this.share = false;

  /**
   * By default, we center our embedded levels. Can be overriden by apps.
   */
  this.centerEmbedded = true;

  /**
   * If set to true, we use our wireframe share (or chromeless share on mobile)
   */
  this.wireframeShare = false;

  this.onAttempt = undefined;
  this.onContinue = undefined;
  this.onResetPressed = undefined;
  this.backToPreviousLevel = undefined;
  this.sendToPhone = undefined;
  this.enableShowBlockCount = true;

  this.disableSocialShare = false;
  this.noPadding = false;

  this.MIN_WORKSPACE_HEIGHT = undefined;
};
module.exports = StudioApp;
StudioApp.singleton = new StudioApp();

/**
 * Configure StudioApp options
 */
StudioApp.prototype.configure = function (options) {
  this.BASE_URL = options.baseUrl;
  this.LOCALE = options.locale || this.LOCALE;
  // NOTE: editCode (which currently implies droplet) and usingBlockly_ are
  // currently mutually exclusive.
  this.editCode = options.level && options.level.editCode;
  this.usingBlockly_ = !this.editCode;

  // TODO (bbuchanan) : Replace this editorless-hack with setting an editor enum
  // or (even better) inject an appropriate editor-adaptor.
  if (options.isEditorless) {
    this.editCode = false;
    this.usingBlockly_ = false;
  }

  this.cdoSounds = options.cdoSounds;
  this.Dialog = options.Dialog;

  // Bind assetUrl to the instance so that we don't need to depend on callers
  // binding correctly as they pass this function around.
  this.assetUrl = _.bind(this.assetUrl_, this);

  this.maxVisualizationWidth = options.maxVisualizationWidth || MAX_VISUALIZATION_WIDTH;
  this.minVisualizationWidth = options.minVisualizationWidth || MIN_VISUALIZATION_WIDTH;
};

StudioApp.prototype.hasInstructionsToShow = function (config) {
  return !!(config.level.instructions || config.level.aniGifURL);
};

/**
 * Common startup tasks for all apps. Happens after configure.
 */
StudioApp.prototype.init = function (config) {
  if (!config) {
    config = {};
  }

  config.getCode = this.getCode.bind(this);
  copyrightStrings = config.copyrightStrings;

  if (config.isLegacyShare && config.hideSource) {
    $("body").addClass("legacy-share-view");
    if (dom.isMobile()) {
      $('#main-logo').hide();
    }
    if (dom.isIOS() && !window.navigator.standalone) {
      addToHome.show(true);
    }
  }

  this.setConfigValues_(config);

  this.configureDom(config);

  if (config.usesAssets) {
    assetPrefix.init(config);

    // Pre-populate asset list
    assetsApi.ajax('GET', '', function (xhr) {
      assetListStore.reset(JSON.parse(xhr.responseText));
    }, function () {
      // Unable to load asset list
    });
  }

  if (config.hideSource) {
    this.handleHideSource_({
      containerId: config.containerId,
      embed: config.embed,
      level: config.level,
      level_source_id: config.level_source_id,
      phone_share_url: config.send_to_phone_url,
      sendToPhone: config.sendToPhone,
      twitter: config.twitter,
      app: config.app,
      isLegacyShare: config.isLegacyShare
    });
  }

  if (config.share) {
    this.handleSharing_({
      makeUrl: config.makeUrl,
      makeString: config.makeString,
      makeImage: config.makeImage,
      makeYourOwn: config.makeYourOwn
    });
  }

  this.authoredHintsController_.init(config.level.authoredHints, config.scriptId, config.serverLevelId);
  if (config.authoredHintViewRequestsUrl) {
    this.authoredHintsController_.submitHints(config.authoredHintViewRequestsUrl);
  }

  if (config.puzzleRatingsUrl) {
    puzzleRatingUtils.submitCachedPuzzleRatings(config.puzzleRatingsUrl);
  }

  // Record time at initialization.
  this.initTime = new Date().getTime();

  // Fixes viewport for small screens.
  var viewport = document.querySelector('meta[name="viewport"]');
  if (viewport) {
    this.fixViewportForSmallScreens_(viewport, config);
  }

  var showCode = document.getElementById('show-code-header');
  if (showCode && this.enableShowCode) {
    dom.addClickTouchEvent(showCode, _.bind(function () {
      if (this.editCode) {
        var result;
        var nonDropletError = false;
        // are we trying to toggle from blocks to text (or the opposite)
        var fromBlocks = this.editor.currentlyUsingBlocks;
        try {
          result = this.editor.toggleBlocks();
        } catch (err) {
          nonDropletError = true;
          result = { error: err };
        }
        if (result && result.error) {
          logToCloud.addPageAction(logToCloud.PageAction.DropletTransitionError, {
            dropletError: !nonDropletError,
            fromBlocks: fromBlocks
          });
          this.feedback_.showToggleBlocksError(this.Dialog);
        }
        this.onDropletToggle_();
      } else {
        this.feedback_.showGeneratedCode(this.Dialog, config.appStrings);
      }
    }, this));
  }

  var blockCount = document.getElementById('blockCounter');
  if (blockCount && !this.enableShowBlockCount) {
    blockCount.style.display = 'none';
  }

  this.setIconsFromSkin(config.skin);

  if (config.level.instructionsIcon) {
    this.icon = config.skin[config.level.instructionsIcon];
    this.winIcon = config.skin[config.level.instructionsIcon];
  }

  if (config.showInstructionsWrapper) {
    config.showInstructionsWrapper(_.bind(function () {
      var shouldAutoClose = !!config.level.aniGifURL;
      this.showInstructions_(config.level, shouldAutoClose, false);
    }, this));
  }

  // In embed mode, the display scales down when the width of the
  // visualizationColumn goes below the min width
  if (config.embed && config.centerEmbedded) {
    var resized = false;
    var resize = function resize() {
      var vizCol = document.getElementById('visualizationColumn');
      var width = vizCol.offsetWidth;
      var height = vizCol.offsetHeight;
      var displayWidth = DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH;
      var scale = Math.min(width / displayWidth, height / displayWidth);
      var viz = document.getElementById('visualization');
      viz.style['transform-origin'] = 'left top';
      viz.style['-webkit-transform'] = 'scale(' + scale + ')';
      viz.style['max-height'] = displayWidth * scale + 'px';
      viz.style.display = 'block';
      vizCol.style.width = '';
      vizCol.style.maxWidth = displayWidth + 'px';
      // Needs to run twice on initialization
      if (!resized) {
        resized = true;
        resize();
      }
    };
    // Depends on ResizeSensor.js
    var ResizeSensor = require('./ResizeSensor');
    ResizeSensor(document.getElementById('visualizationColumn'), resize);
  }

  var orientationHandler = function orientationHandler() {
    window.scrollTo(0, 0); // Browsers like to mess with scroll on rotate.
  };
  window.addEventListener('orientationchange', orientationHandler);
  orientationHandler();

  if (config.loadAudio) {
    config.loadAudio();
  }

  var promptDiv = document.getElementById('prompt');
  var prompt2Div = document.getElementById('prompt2');
  if (config.level.instructions) {
    var instructionsHtml = this.substituteInstructionImages(config.level.instructions);
    $(promptDiv).html(instructionsHtml);
  }
  if (config.level.instructions2) {
    var instructions2Html = this.substituteInstructionImages(config.level.instructions2);
    $(prompt2Div).html(instructions2Html);
    $(prompt2Div).show();
  }

  if (this.hasInstructionsToShow(config)) {
    var promptIcon = document.getElementById('prompt-icon');
    if (this.smallIcon) {
      promptIcon.src = this.smallIcon;
      $('#prompt-icon-cell').show();
    }

    var bubble = document.getElementById('bubble');

    this.authoredHintsController_.display(promptIcon, bubble, (function () {
      this.showInstructions_(config.level, false, true);
    }).bind(this));
  }

  var aniGifPreview = document.getElementById('ani-gif-preview');
  if (config.level.aniGifURL) {
    aniGifPreview.style.backgroundImage = "url('" + config.level.aniGifURL + "')";
    var promptTable = document.getElementById('prompt-table');
    promptTable.className += " with-ani-gif";
  } else {
    var wrapper = document.getElementById('ani-gif-preview-wrapper');
    wrapper.style.display = 'none';
  }

  if (this.editCode) {
    this.handleEditCode_(config);
  }

  if (this.isUsingBlockly()) {
    this.handleUsingBlockly_(config);
  } else {
    // handleUsingBlockly_ already does an onResize. We still want that goodness
    // if we're not blockly
    this.onResize();
  }

  var vizResizeBar = document.getElementById('visualizationResizeBar');
  if (vizResizeBar) {
    dom.addMouseDownTouchEvent(vizResizeBar, _.bind(this.onMouseDownVizResizeBar, this));

    // Can't use dom.addMouseUpTouchEvent() because it will preventDefault on
    // all touchend events on the page, breaking click events...
    document.body.addEventListener('mouseup', _.bind(this.onMouseUpVizResizeBar, this));
    var mouseUpTouchEventName = dom.getTouchEventName('mouseup');
    if (mouseUpTouchEventName) {
      document.body.addEventListener(mouseUpTouchEventName, _.bind(this.onMouseUpVizResizeBar, this));
    }
  }

  window.addEventListener('resize', _.bind(this.onResize, this));

  this.reset(true);

  // Add display of blocks used.
  this.setIdealBlockNumber_();

  // TODO (cpirich): implement block count for droplet (for now, blockly only)
  if (this.isUsingBlockly()) {
    Blockly.mainBlockSpaceEditor.addChangeListener(_.bind(function () {
      this.updateBlockCount();
    }, this));

    if (config.level.openFunctionDefinition) {
      this.openFunctionDefinition_(config);
    }
  }

  // Bind listener to 'Clear Puzzle' button
  var hideIcon = utils.valueOr(config.skin.hideIconInClearPuzzle, false);
  var clearPuzzleHeader = document.getElementById('clear-puzzle-header');
  if (clearPuzzleHeader) {
    dom.addClickTouchEvent(clearPuzzleHeader, (function () {
      this.feedback_.showClearPuzzleConfirmation(this.Dialog, hideIcon, (function () {
        this.handleClearPuzzle(config);
      }).bind(this));
    }).bind(this));
  }

  // Bind listener to 'Version History' button
  var versionsHeader = document.getElementById('versions-header');
  if (versionsHeader) {
    dom.addClickTouchEvent(versionsHeader, (function () {
      var codeDiv = document.createElement('div');
      var dialog = this.createModalDialog({
        Dialog: this.Dialog,
        contentDiv: codeDiv,
        defaultBtnSelector: 'again-button',
        id: 'showVersionsModal'
      });
      React.render(React.createElement(VersionHistory, {
        handleClearPuzzle: this.handleClearPuzzle.bind(this, config)
      }), codeDiv);

      dialog.show();
    }).bind(this));
  }

  if (this.isUsingBlockly() && Blockly.contractEditor) {
    Blockly.contractEditor.registerTestsFailedOnCloseHandler((function () {
      this.feedback_.showSimpleDialog(this.Dialog, {
        headerText: undefined,
        bodyText: msg.examplesFailedOnClose(),
        cancelText: msg.ignore(),
        confirmText: msg.tryAgain(),
        onConfirm: null,
        onCancel: function onCancel() {
          Blockly.contractEditor.hideIfOpen();
        }
      });

      // return true to indicate to blockly-core that we'll own closing the
      // contract editor
      return true;
    }).bind(this));
  }

  if (config.isLegacyShare && config.hideSource) {
    this.setupLegacyShareView();
  }
};

/**
 * Create a phone frame and container. Scale shared content (everything currently inside the visualization column)
 * to container width, fit container to the phone frame and add share footer.
 */
StudioApp.prototype.setupLegacyShareView = function () {
  var vizContainer = document.createElement('div');
  vizContainer.id = 'visualizationContainer';
  var vizColumn = document.getElementById('visualizationColumn');
  if (dom.isMobile()) {
    $(vizContainer).width($(vizColumn).width());
  }
  $(vizContainer).append(vizColumn.children);

  var phoneFrameScreen = document.createElement('div');
  phoneFrameScreen.id = 'phoneFrameScreen';
  $(phoneFrameScreen).append(vizContainer);
  $(vizColumn).append(phoneFrameScreen);

  this.renderShareFooter_(phoneFrameScreen);
  if (dom.isMobile) {
    // re-scale on resize events to adjust to orientation and navbar changes
    $(window).resize(this.scaleLegacyShare);
  }
  this.scaleLegacyShare();
};

StudioApp.prototype.scaleLegacyShare = function () {
  var vizContainer = document.getElementById('visualizationContainer');
  var vizColumn = document.getElementById('visualizationColumn');
  var phoneFrameScreen = document.getElementById('phoneFrameScreen');
  var vizWidth = $(vizContainer).width();

  // On mobile, scale phone frame to full screen (portrait). Otherwise use given dimensions from css.
  if (dom.isMobile()) {
    var screenWidth = Math.min(window.innerWidth, window.innerHeight);
    var screenHeight = Math.max(window.innerWidth, window.innerHeight);
    $(phoneFrameScreen).width(screenWidth);
    $(phoneFrameScreen).height(screenHeight);
    $(vizColumn).width(screenWidth);
  }

  var frameWidth = $(phoneFrameScreen).width();
  var scale = frameWidth / vizWidth;
  applyTransformOrigin(vizContainer, 'left top');
  applyTransformScale(vizContainer, 'scale(' + scale + ')');
};

StudioApp.prototype.substituteInstructionImages = function (htmlText) {
  if (htmlText) {
    for (var prop in this.skin.instructions2ImageSubstitutions) {
      var value = this.skin.instructions2ImageSubstitutions[prop];
      var substitutionHtml = '<span class="instructionsImageContainer"><img src="' + value + '" class="instructionsImage"/></span>';
      var re = new RegExp('\\[' + prop + '\\]', 'g');
      htmlText = htmlText.replace(re, substitutionHtml);
    }
  }

  return htmlText;
};

StudioApp.prototype.getCode = function () {
  if (!this.editCode) {
    throw "getCode() requires editCode";
  }
  if (this.hideSource) {
    return this.startBlocks_;
  } else {
    return this.editor.getValue();
  }
};

StudioApp.prototype.setIconsFromSkin = function (skin) {
  this.icon = skin.staticAvatar;
  this.smallIcon = skin.smallStaticAvatar;
  this.winIcon = skin.winAvatar;
  this.failureIcon = skin.failureAvatar;
};

/**
 * Reset the puzzle back to its initial state.
 * Search aliases: "Start Over", startOver
 * @param {Object} config - same config object passed to studioApp.init().
 */
StudioApp.prototype.handleClearPuzzle = function (config) {
  if (this.isUsingBlockly()) {
    if (Blockly.functionEditor) {
      Blockly.functionEditor.hideIfOpen();
    }
    Blockly.mainBlockSpace.clear();
    this.setStartBlocks_(config, false);
    if (config.level.openFunctionDefinition) {
      this.openFunctionDefinition_(config);
    }
  } else {
    var resetValue = '';
    if (config.level.startBlocks) {
      // Don't pass CRLF pairs to droplet until they fix CR handling:
      resetValue = config.level.startBlocks.replace(/\r\n/g, '\n');
    }
    // TODO (bbuchanan): This getValue() call is a workaround for a Droplet bug,
    // See https://github.com/droplet-editor/droplet/issues/137
    // Calling getValue() updates the cached ace editor value, which can be
    // out-of-date in droplet and cause an incorrect early-out.
    // Remove this line once that bug is fixed and our Droplet lib is updated.
    this.editor.getValue();
    this.editor.setValue(resetValue);
  }
  if (config.afterClearPuzzle) {
    config.afterClearPuzzle();
  }
};

/**
 * TRUE if the current app uses blockly (as opposed to editCode or another
 * editor)
 * @return {boolean}
 */
StudioApp.prototype.isUsingBlockly = function () {
  return this.usingBlockly_;
};

/**
 *
 */
StudioApp.prototype.handleSharing_ = function (options) {
  // 1. Move the buttons, 2. Hide the slider in the share page for mobile.
  var belowVisualization = document.getElementById('belowVisualization');
  if (dom.isMobile()) {
    var sliderCell = document.getElementById('slider-cell');
    if (sliderCell) {
      sliderCell.style.display = 'none';
    }
    if (belowVisualization) {
      var visualization = document.getElementById('visualization');
      belowVisualization.style.display = 'none';
      visualization.style.marginBottom = '0px';
    }
  }

  // Show flappy upsale on desktop and mobile.  Show learn upsale only on desktop
  var upSale = document.createElement('div');
  if (options.makeYourOwn) {
    upSale.innerHTML = require('./templates/makeYourOwn.html.ejs')({
      data: {
        makeUrl: options.makeUrl,
        makeString: options.makeString,
        makeImage: options.makeImage
      }
    });
    if (this.noPadding) {
      upSale.style.marginLeft = '10px';
    }
    belowVisualization.appendChild(upSale);
  } else if (typeof options.makeYourOwn === 'undefined') {
    upSale.innerHTML = require('./templates/learn.html.ejs')({
      assetUrl: this.assetUrl
    });
    belowVisualization.appendChild(upSale);
  }
};

StudioApp.prototype.renderShareFooter_ = function (container) {
  var footerDiv = document.createElement('div');
  footerDiv.setAttribute('id', 'footerDiv');
  container.appendChild(footerDiv);

  var reactProps = {
    i18nDropdown: '',
    copyrightInBase: false,
    copyrightStrings: copyrightStrings,
    baseMoreMenuString: window.dashboard.i18n.t('footer.built_on_code_studio'),
    baseStyle: {
      paddingLeft: 0,
      width: $("#visualization").width()
    },
    className: 'dark',
    menuItems: [{
      text: window.dashboard.i18n.t('footer.try_hour_of_code'),
      link: 'https://code.org/learn',
      newWindow: true
    }, {
      text: window.dashboard.i18n.t('footer.how_it_works'),
      link: location.href + "/edit",
      newWindow: false
    }, {
      text: window.dashboard.i18n.t('footer.copyright'),
      link: '#',
      copyright: true
    }, {
      text: window.dashboard.i18n.t('footer.tos'),
      link: "https://code.org/tos",
      newWindow: true
    }, {
      text: window.dashboard.i18n.t('footer.privacy'),
      link: "https://code.org/privacy",
      newWindow: true
    }],
    phoneFooter: true
  };

  React.render(React.createElement(window.dashboard.SmallFooter, reactProps), footerDiv);
};

/**
 * Get the url of path appended to BASE_URL
 */
StudioApp.prototype.assetUrl_ = function (path) {
  if (this.BASE_URL === undefined) {
    throw new Error('StudioApp BASE_URL has not been set. ' + 'Call configure() first');
  }
  return this.BASE_URL + path;
};

/**
 * Reset the playing field to the start position and kill any pending
 * animation tasks.  This will typically be replaced by an application.
 * @param {boolean} shouldPlayOpeningAnimation True if an opening animation is
 *   to be played.
 */
StudioApp.prototype.reset = function (shouldPlayOpeningAnimation) {
  // TODO (bbuchanan): Look for comon reset logic we can pull here
  // Override in app subclass
};

/**
 * Override to change run behavior.
 */
StudioApp.prototype.runButtonClick = function () {};

/**
 * Toggle whether run button or reset button is shown
 * @param {string} button Button to show, either "run" or "reset"
 */
StudioApp.prototype.toggleRunReset = function (button) {
  var showRun = button === 'run';
  if (button !== 'run' && button !== 'reset') {
    throw "Unexpected input";
  }

  var run = document.getElementById('runButton');
  var reset = document.getElementById('resetButton');
  run.style.display = showRun ? 'inline-block' : 'none';
  run.disabled = !showRun;
  reset.style.display = !showRun ? 'inline-block' : 'none';
  reset.disabled = showRun;

  // Toggle soft-buttons (all have the 'arrow' class set):
  $('.arrow').prop("disabled", showRun);
};

/**
 * Attempts to associate a set of audio files to a given name
 * Handles the case where cdoSounds does not exist, e.g. in tests
 * and grunt dev preview mode
 * @param {Object} audioConfig sound configuration
 */
StudioApp.prototype.registerAudio = function (audioConfig) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.register(audioConfig);
};

/**
 * Attempts to associate a set of audio files to a given name
 * Handles the case where cdoSounds does not exist, e.g. in tests
 * and grunt dev preview mode
 * @param {Array.<string>} filenames file paths for sounds
 * @param {string} name ID to associate sound effect with
 */
StudioApp.prototype.loadAudio = function (filenames, name) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.registerByFilenamesAndID(filenames, name);
};

/**
 * Attempts to play a sound effect
 * @param {string} name sound ID
 * @param {Object} options for sound playback
 * @param {number} options.volume value between 0.0 and 1.0 specifying volume
 * @param {function} [options.onEnded]
 */
StudioApp.prototype.playAudio = function (name, options) {
  if (!this.cdoSounds) {
    return;
  }

  options = options || {};
  var defaultOptions = { volume: 0.5 };
  var newOptions = utils.extend(defaultOptions, options);
  this.cdoSounds.play(name, newOptions);
};

/**
 * Stops looping a given sound
 * @param {string} name ID of sound
 */
StudioApp.prototype.stopLoopingAudio = function (name) {
  if (!this.cdoSounds) {
    return;
  }

  this.cdoSounds.stopLoopingAudio(name);
};

/**
* @param {Object} options Configuration parameters for Blockly. Parameters are
* optional and include:
*  - {string} path The root path to the /apps directory, defaults to the
*    the directory in which this script is located.
*  - {boolean} rtl True if the current language right to left.
*  - {DomElement} toolbox The element in which to insert the toolbox,
*    defaults to the element with 'toolbox'.
*  - {boolean} trashcan True if the trashcan should be displayed, defaults to
*    true.
* @param {Element} div The parent div in which to insert Blockly.
*/
StudioApp.prototype.inject = function (div, options) {
  var defaults = {
    assetUrl: this.assetUrl,
    rtl: this.isRtl(),
    toolbox: document.getElementById('toolbox'),
    trashcan: true,
    customSimpleDialog: this.feedback_.showSimpleDialog.bind(this.feedback_, this.Dialog)
  };
  Blockly.inject(div, utils.extend(defaults, options), this.cdoSounds);
};

/**
 * Returns true if the current HTML page is in right-to-left language mode.
 */
StudioApp.prototype.isRtl = function () {
  var head = document.getElementsByTagName('head')[0];
  if (head && head.parentElement) {
    var dir = head.parentElement.getAttribute('dir');
    return dir && dir.toLowerCase() === 'rtl';
  } else {
    return false;
  }
};

/**
 * @return {string} Locale direction string based on app direction.
 */
StudioApp.prototype.localeDirection = function () {
  return this.isRtl() ? 'rtl' : 'ltr';
};

/**
* Initialize Blockly for a readonly iframe.  Called on page load. No sounds.
* XML argument may be generated from the console with:
* Blockly.Xml.domToText(Blockly.Xml.blockSpaceToDom(Blockly.mainBlockSpace)).slice(5, -6)
*/
StudioApp.prototype.initReadonly = function (options) {
  Blockly.inject(document.getElementById('codeWorkspace'), {
    assetUrl: this.assetUrl,
    readOnly: true,
    rtl: this.isRtl(),
    scrollbars: false
  });
  this.loadBlocks(options.blocks);
};

/**
* Load the editor with blocks.
* @param {string} blocksXml Text representation of blocks.
*/
StudioApp.prototype.loadBlocks = function (blocksXml) {
  var xml = parseXmlElement(blocksXml);
  Blockly.Xml.domToBlockSpace(Blockly.mainBlockSpace, xml);
};

/**
* Applies the specified arrangement to top startBlocks. If any
* individual blocks have x or y properties set in the XML, those values
* take priority. If no arrangement for a particular block type is
* specified, blocks are automatically positioned by Blockly.
*
* Note that, currently, only bounce and flappy use arrangements.
*
* @param {string} startBlocks String representation of start blocks xml.
* @param {Object.<Object>} arrangement A map from block type to position.
* @return {string} String representation of start blocks xml, including
*    block position.
*/
StudioApp.prototype.arrangeBlockPosition = function (startBlocks, arrangement) {

  var type, xmlChild;

  var xml = parseXmlElement(startBlocks);

  var xmlChildNodes = xml.childNodes || [];
  arrangement = arrangement || {};

  for (var i = 0; i < xmlChildNodes.length; i++) {
    xmlChild = xmlChildNodes[i];

    // Only look at element nodes
    if (xmlChild.nodeType === 1) {
      // look to see if we have a predefined arrangement for this type
      type = xmlChild.getAttribute('type');
      if (arrangement[type]) {
        if (arrangement[type].x && !xmlChild.hasAttribute('x')) {
          xmlChild.setAttribute('x', arrangement[type].x);
        }
        if (arrangement[type].y && !xmlChild.hasAttribute('y')) {
          xmlChild.setAttribute('y', arrangement[type].y);
        }
      }
    }
  }
  return Blockly.Xml.domToText(xml);
};

StudioApp.prototype.createModalDialog = function (options) {
  options.Dialog = utils.valueOr(options.Dialog, this.Dialog);
  return this.feedback_.createModalDialog(options);
};

/**
 * Simple passthrough to AuthoredHints.displayMissingBlockHints
 * @param {String[]} blocks An array of XML strings representing the
 *        missing recommended Blockly Blocks for which we want to
 *        display hints.
 */
StudioApp.prototype.displayMissingBlockHints = function (blocks) {
  this.authoredHintsController_.displayMissingBlockHints(blocks);
};

StudioApp.prototype.onReportComplete = function (response) {
  this.authoredHintsController_.finishHints(response);
};

StudioApp.prototype.showInstructions_ = function (level, autoClose, showHints) {
  var instructionsDiv = document.createElement('div');
  var renderedMarkdown;
  var headerElement;

  var puzzleTitle = msg.puzzleTitle({
    stage_total: level.stage_total,
    puzzle_number: level.puzzle_number
  });

  var markdownMode = window.marked && level.markdownInstructions && this.LOCALE === ENGLISH_LOCALE;

  if (markdownMode) {
    var markdownWithImages = this.substituteInstructionImages(level.markdownInstructions);
    renderedMarkdown = marked(markdownWithImages);
    instructionsDiv.className += ' markdown-instructions-container';
    headerElement = document.createElement('h1');
    headerElement.className = 'markdown-level-header-text dialog-title';
    headerElement.innerHTML = puzzleTitle;
    if (!this.icon) {
      headerElement.className += ' no-modal-icon';
    }
  }

  var authoredHints;
  if (showHints) {
    authoredHints = this.authoredHintsController_.getHintsDisplay();
  }

  var instructionsContent = React.createElement(Instructions, {
    puzzleTitle: puzzleTitle,
    instructions: this.substituteInstructionImages(level.instructions),
    instructions2: this.substituteInstructionImages(level.instructions2),
    renderedMarkdown: renderedMarkdown,
    markdownClassicMargins: level.markdownInstructionsWithClassicMargins,
    aniGifURL: level.aniGifURL,
    authoredHints: authoredHints
  });

  // Create a div to eventually hold this content, and add it to the
  // overall container. We don't want to render directly into the
  // container just yet, because our React component could contain some
  // elements that don't want to be rendered until they are in the DOM
  var instructionsReactContainer = document.createElement('div');
  instructionsReactContainer.className = 'instructions-container';
  instructionsDiv.appendChild(instructionsReactContainer);

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });

  instructionsDiv.appendChild(buttons);

  // If there is an instructions block on the screen, we want the instructions dialog to
  // shrink down to that instructions block when it's dismissed.
  // We then want to flash the instructions block.
  var hideOptions = null;
  var endTargetSelector = "#bubble";

  if ($(endTargetSelector).length) {
    hideOptions = {};
    hideOptions.endTarget = endTargetSelector;
  }

  var hideFn = _.bind(function () {
    // Momentarily flash the instruction block white then back to regular.
    if ($(endTargetSelector).length) {
      $(endTargetSelector).css({ "background-color": "rgba(255,255,255,1)" }).delay(500).animate({ "background-color": "rgba(0,0,0,0)" }, 1000);
    }
    // Set focus to ace editor when instructions close:
    if (this.editCode && this.editor && !this.editor.currentlyUsingBlocks) {
      this.editor.aceEditor.focus();
    }

    // Fire a custom event on the document so that other code can respond
    // to instructions being closed.
    var event = document.createEvent('Event');
    event.initEvent('instructionsHidden', true, true);
    document.dispatchEvent(event);
  }, this);

  this.instructionsDialog = this.createModalDialog({
    markdownMode: markdownMode,
    contentDiv: instructionsDiv,
    icon: this.icon,
    defaultBtnSelector: '#ok-button',
    onHidden: hideFn,
    scrollContent: true,
    scrollableSelector: ".instructions-container",
    header: headerElement
  });

  // Now that our elements are guaranteed to be in the DOM, we can
  // render in our react components
  $(this.instructionsDialog.div).on('show.bs.modal', function () {
    React.render(instructionsContent, instructionsReactContainer);
  });

  if (autoClose) {
    setTimeout(_.bind(function () {
      this.instructionsDialog.hide();
    }, this), 32000);
  }

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, _.bind(function () {
      if (this.instructionsDialog) {
        this.instructionsDialog.hide();
      }
    }, this));
  }

  this.instructionsDialog.show({ hideOptions: hideOptions });

  if (renderedMarkdown) {
    // process <details> tags with polyfill jQuery plugin
    $('details').details();
  }

  // Fire a custom event on the document so that other code can respond
  // to instructions being shown.
  var event = document.createEvent('Event');
  event.initEvent('instructionsShown', true, true);
  document.dispatchEvent(event);
};

/**
*  Resizes the blockly workspace.
*/
StudioApp.prototype.onResize = function () {
  var workspaceWidth = document.getElementById('codeWorkspace').clientWidth;

  // Keep blocks static relative to the right edge in RTL mode
  if (this.isUsingBlockly() && Blockly.RTL) {
    if (this.lastWorkspaceWidth && this.lastWorkspaceWidth !== workspaceWidth) {
      var blockOffset = workspaceWidth - this.lastWorkspaceWidth;
      Blockly.mainBlockSpace.getTopBlocks().forEach(function (topBlock) {
        topBlock.moveBy(blockOffset, 0);
      });
    }
  }
  this.lastWorkspaceWidth = workspaceWidth;

  // Droplet toolbox width varies as the window size changes, so refresh:
  this.resizeToolboxHeader();

  // Content below visualization is a resizing scroll area in pinned mode
  onResizeSmallFooter();
};

/**
 * Resizes the content area below the visualization in pinned (viewport height)
 * view mode.
 */
function resizePinnedBelowVisualizationArea() {
  var pinnedBelowVisualization = document.querySelector('#visualizationColumn.pin_bottom #belowVisualization');
  if (!pinnedBelowVisualization) {
    return;
  }

  var playSpaceHeader = document.getElementById('playSpaceHeader');
  var visualization = document.getElementById('visualization');
  var gameButtons = document.getElementById('gameButtons');
  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');

  var top = 0;
  if (playSpaceHeader) {
    top += $(playSpaceHeader).outerHeight(true);
  }

  if (visualization) {
    top += $(visualization).outerHeight(true);
  }

  if (gameButtons) {
    top += $(gameButtons).outerHeight(true);
  }

  var bottom = 0;
  if (smallFooter) {
    var codeApp = $('#codeApp');
    bottom += $(smallFooter).outerHeight(true);
    // Footer is relative to the document, not codeApp, so we need to
    // remove the codeApp bottom offset to get the correct margin.
    bottom -= parseInt(codeApp.css('bottom'), 10);
  }

  pinnedBelowVisualization.style.top = top + 'px';
  pinnedBelowVisualization.style.bottom = bottom + 'px';
}

/**
 * Debounced onResize operations that update the layout to support sizing
 * to viewport height and using the small footer.
 * @type {Function}
 */
var onResizeSmallFooter = _.debounce(function () {
  resizePinnedBelowVisualizationArea();
}, 10);

StudioApp.prototype.onMouseDownVizResizeBar = function (event) {
  // When we see a mouse down in the resize bar, start tracking mouse moves:

  if (!this.onMouseMoveBoundHandler) {
    this.onMouseMoveBoundHandler = _.bind(this.onMouseMoveVizResizeBar, this);
    document.body.addEventListener('mousemove', this.onMouseMoveBoundHandler);
    this.mouseMoveTouchEventName = dom.getTouchEventName('mousemove');
    if (this.mouseMoveTouchEventName) {
      document.body.addEventListener(this.mouseMoveTouchEventName, this.onMouseMoveBoundHandler);
    }

    event.preventDefault();
  }
};

function applyTransformScaleToChildren(element, scale) {
  for (var i = 0; i < element.children.length; i++) {
    applyTransformScale(element.children[i], scale);
  }
}
function applyTransformScale(element, scale) {
  element.style.transform = scale;
  element.style.msTransform = scale;
  element.style.webkitTransform = scale;
}
function applyTransformOrigin(element, origin) {
  element.style.transformOrigin = origin;
  element.style.msTransformOrigin = origin;
  element.style.webkitTransformOrigin = origin;
}

/**
*  Handle mouse moves while dragging the visualization resize bar. We set
*  styles on each of the elements directly, overriding the normal responsive
*  classes that would typically adjust width and scale.
*/
StudioApp.prototype.onMouseMoveVizResizeBar = function (event) {
  var visualizationResizeBar = document.getElementById('visualizationResizeBar');

  var rect = visualizationResizeBar.getBoundingClientRect();
  var offset;
  var newVizWidth;
  if (this.isRtl()) {
    offset = window.innerWidth - (window.pageXOffset + rect.left + rect.width / 2) - parseInt(window.getComputedStyle(visualizationResizeBar).right, 10);
    newVizWidth = window.innerWidth - event.pageX - offset;
  } else {
    offset = window.pageXOffset + rect.left + rect.width / 2 - parseInt(window.getComputedStyle(visualizationResizeBar).left, 10);
    newVizWidth = event.pageX - offset;
  }
  this.resizeVisualization(newVizWidth);
};

/**
 * Resize the visualization to the given width
 */
StudioApp.prototype.resizeVisualization = function (width) {
  var codeWorkspace = document.getElementById('codeWorkspace');
  var visualization = document.getElementById('visualization');
  var visualizationResizeBar = document.getElementById('visualizationResizeBar');
  var visualizationColumn = document.getElementById('visualizationColumn');
  var visualizationEditor = document.getElementById('visualizationEditor');

  var oldVizWidth = $(visualizationColumn).width();
  var newVizWidth = Math.max(this.minVisualizationWidth, Math.min(this.maxVisualizationWidth, width));
  var newVizWidthString = newVizWidth + 'px';
  var newVizHeightString = newVizWidth / this.vizAspectRatio + 'px';
  var vizSideBorderWidth = visualization.offsetWidth - visualization.clientWidth;

  if (this.isRtl()) {
    visualizationResizeBar.style.right = newVizWidthString;
    codeWorkspace.style.right = newVizWidthString;
  } else {
    visualizationResizeBar.style.left = newVizWidthString;
    codeWorkspace.style.left = newVizWidthString;
  }
  visualizationResizeBar.style.lineHeight = newVizHeightString;
  // Add extra width to visualizationColumn if visualization has a border:
  visualizationColumn.style.maxWidth = newVizWidth + vizSideBorderWidth + 'px';
  visualization.style.maxWidth = newVizWidthString;
  visualization.style.maxHeight = newVizHeightString;

  // We don't get the benefits of our responsive styling, so set height
  // explicitly
  if (!utils.browserSupportsCssMedia()) {
    visualization.style.height = newVizHeightString;
    visualization.style.width = newVizWidthString;
  }
  var scale = newVizWidth / this.nativeVizWidth;

  applyTransformScaleToChildren(visualization, 'scale(' + scale + ')');
  if (visualizationEditor) {
    visualizationEditor.style.marginLeft = newVizWidthString;
  }

  if (oldVizWidth < 230 && newVizWidth >= 230) {
    $('#soft-buttons').removeClass('soft-buttons-compact');
  } else if (oldVizWidth > 230 && newVizWidth <= 230) {
    $('#soft-buttons').addClass('soft-buttons-compact');
  }

  var smallFooter = document.querySelector('#page-small-footer .small-footer-base');
  if (smallFooter) {
    smallFooter.style.maxWidth = newVizWidthString;

    // If the small print and language selector are on the same line,
    // the small print should float right.  Otherwise, it should float left.
    var languageSelector = smallFooter.querySelector('form');
    var smallPrint = smallFooter.querySelector('small');
    if (languageSelector && smallPrint.offsetTop === languageSelector.offsetTop) {
      smallPrint.style.float = 'right';
    } else {
      smallPrint.style.float = 'left';
    }
  }

  // Fire resize so blockly and droplet handle this type of resize properly:
  utils.fireResizeEvent();
};

StudioApp.prototype.onMouseUpVizResizeBar = function (event) {
  // If we have been tracking mouse moves, remove the handler now:
  if (this.onMouseMoveBoundHandler) {
    document.body.removeEventListener('mousemove', this.onMouseMoveBoundHandler);
    if (this.mouseMoveTouchEventName) {
      document.body.removeEventListener(this.mouseMoveTouchEventName, this.onMouseMoveBoundHandler);
    }
    this.onMouseMoveBoundHandler = null;
  }
};

/**
*  Updates the width of the toolbox-header to match the width of the toolbox
*  or palette in the workspace below the header.
*/
StudioApp.prototype.resizeToolboxHeader = function () {
  var toolboxWidth = 0;
  if (this.editCode && this.editor && this.editor.paletteEnabled) {
    // If in the droplet editor, set toolboxWidth based on the block palette width:
    var categories = document.querySelector('.droplet-palette-wrapper');
    toolboxWidth = categories.getBoundingClientRect().width;
  } else if (this.isUsingBlockly()) {
    toolboxWidth = Blockly.mainBlockSpaceEditor.getToolboxWidth();
  }
  document.getElementById('toolbox-header').style.width = toolboxWidth + 'px';
};

/**
* Highlight the block (or clear highlighting).
* @param {?string} id ID of block that triggered this action.
* @param {boolean} spotlight Optional.  Highlight entire block if true
*/
StudioApp.prototype.highlight = function (id, spotlight) {
  if (this.isUsingBlockly()) {
    if (id) {
      var m = id.match(/^block_id_(\d+)$/);
      if (m) {
        id = m[1];
      }
    }

    Blockly.mainBlockSpace.highlightBlock(id, spotlight);
  }
};

/**
* Remove highlighting from all blocks
*/
StudioApp.prototype.clearHighlighting = function () {
  if (this.isUsingBlockly()) {
    this.highlight(null);
  } else if (this.editCode && this.editor) {
    // Clear everything (step highlighting, errors, etc.)
    codegen.clearDropletAceHighlighting(this.editor, true);
  }
};

/**
* Display feedback based on test results.  The test results must be
* explicitly provided.
* @param {{feedbackType: number}} Test results (a constant property of
*     this.TestResults).
*/
StudioApp.prototype.displayFeedback = function (options) {
  options.Dialog = this.Dialog;
  options.onContinue = this.onContinue;
  options.backToPreviousLevel = this.backToPreviousLevel;
  options.sendToPhone = this.sendToPhone;

  // Special test code for edit blocks.
  if (options.level.edit_blocks) {
    options.feedbackType = this.TestResults.EDIT_BLOCKS;
  }

  this.feedback_.displayFeedback(options, this.requiredBlocks_, this.maxRequiredBlocksToFlag_, this.recommendedBlocks_, this.maxRecommendedBlocksToFlag_);
};

/**
 * Runs the tests and returns results.
 * @param {boolean} levelComplete Was the level completed successfully?
 * @param {Object} options
 * @return {number} The appropriate property of TestResults.
 */
StudioApp.prototype.getTestResults = function (levelComplete, options) {
  return this.feedback_.getTestResults(levelComplete, this.requiredBlocks_, this.recommendedBlocks_, this.checkForEmptyBlocks_, options);
};

// Builds the dom to get more info from the user. After user enters info
// and click "create level" onAttemptCallback is called to deliver the info
// to the server.
StudioApp.prototype.builderForm_ = function (onAttemptCallback) {
  var builderDetails = document.createElement('div');
  builderDetails.innerHTML = require('./templates/builder.html.ejs')();
  var dialog = this.createModalDialog({
    contentDiv: builderDetails,
    icon: this.icon
  });
  var createLevelButton = document.getElementById('create-level-button');
  dom.addClickTouchEvent(createLevelButton, function () {
    var instructions = builderDetails.querySelector('[name="instructions"]').value;
    var name = builderDetails.querySelector('[name="level_name"]').value;
    var query = url.parse(window.location.href, true).query;
    onAttemptCallback(utils.extend({
      "instructions": instructions,
      "name": name
    }, query));
  });

  dialog.show({ backdrop: 'static' });
};

/**
* Report back to the server, if available.
* @param {object} options - parameter block which includes:
* {string} app The name of the application.
* {number} id A unique identifier generated when the page was loaded.
* {string} level The ID of the current level.
* {number} result An indicator of the success of the code.
* {number} testResult More specific data on success or failure of code.
* {boolean} submitted Whether the (submittable) level is being submitted.
* {string} program The user program, which will get URL-encoded.
* {function} onComplete Function to be called upon completion.
*/
StudioApp.prototype.report = function (options) {
  // copy from options: app, level, result, testResult, program, onComplete
  var report = $.extend({}, options, {
    pass: this.feedback_.canContinueToNextLevel(options.testResult),
    time: new Date().getTime() - this.initTime,
    attempt: this.attempts,
    lines: this.feedback_.getNumBlocksUsed()
  });

  this.lastTestResult = options.testResult;

  // If hideSource is enabled, the user is looking at a shared level that
  // they cannot have modified. In that case, don't report it to the service
  // or call the onComplete() callback expected. The app will just sit
  // there with the Reset button as the only option.
  var self = this;
  if (!(this.hideSource && this.share)) {
    var onAttemptCallback = (function () {
      return function (builderDetails) {
        for (var option in builderDetails) {
          report[option] = builderDetails[option];
        }
        self.onAttempt(report);
      };
    })();

    // If this is the level builder, go to builderForm to get more info from
    // the level builder.
    if (options.builder) {
      this.builderForm_(onAttemptCallback);
    } else {
      onAttemptCallback();
    }
  }
};

/**
* Click the reset button.  Reset the application.
*/
StudioApp.prototype.resetButtonClick = function () {
  this.onResetPressed();
  this.toggleRunReset('run');
  this.clearHighlighting();
  if (this.isUsingBlockly()) {
    Blockly.mainBlockSpaceEditor.setEnableToolbox(true);
    Blockly.mainBlockSpace.traceOn(false);
  }
  this.reset(false);
};

/**
* Add count of blocks used.
*/
StudioApp.prototype.updateBlockCount = function () {
  // If the number of block used is bigger than the ideal number of blocks,
  // set it to be yellow, otherwise, keep it as black.
  var element = document.getElementById('blockUsed');
  if (this.IDEAL_BLOCK_NUM < this.feedback_.getNumCountableBlocks()) {
    element.className = "block-counter-overflow";
  } else {
    element.className = "block-counter-default";
  }

  // Update number of blocks used.
  if (element) {
    element.innerHTML = ''; // Remove existing children or text.
    element.appendChild(document.createTextNode(this.feedback_.getNumCountableBlocks()));
  }
};

/**
 * Set the ideal Number of blocks.
 */
StudioApp.prototype.setIdealBlockNumber_ = function () {
  var element = document.getElementById('idealBlockNumber');
  if (!element) {
    return;
  }

  var idealBlockNumberMsg = this.IDEAL_BLOCK_NUM === Infinity ? msg.infinity() : this.IDEAL_BLOCK_NUM;
  element.innerHTML = ''; // Remove existing children or text.
  element.appendChild(document.createTextNode(idealBlockNumberMsg));
};

/**
 *
 */
StudioApp.prototype.fixViewportForSmallScreens_ = function (viewport, config) {
  var deviceWidth;
  var desiredWidth;
  var minWidth;
  if (this.share && dom.isMobile()) {
    var mobileNoPaddingShareWidth = config.mobileNoPaddingShareWidth || DEFAULT_MOBILE_NO_PADDING_SHARE_WIDTH;
    // for mobile sharing, favor portrait mode, so width is the shorter of the two
    deviceWidth = desiredWidth = Math.min(screen.width, screen.height);
    if (this.noPadding && deviceWidth < MAX_PHONE_WIDTH) {
      desiredWidth = Math.min(desiredWidth, mobileNoPaddingShareWidth);
    }
    minWidth = mobileNoPaddingShareWidth;
  } else {
    // assume we are in landscape mode, so width is the longer of the two
    deviceWidth = desiredWidth = Math.max(screen.width, screen.height);
    minWidth = MIN_WIDTH;
  }
  var width = Math.max(minWidth, desiredWidth);
  var scale = deviceWidth / width;
  var content = ['width=' + width, 'minimal-ui', 'initial-scale=' + scale, 'maximum-scale=' + scale, 'minimum-scale=' + scale, 'target-densityDpi=device-dpi', 'user-scalable=no'];
  viewport.setAttribute('content', content.join(', '));
};

/**
 *
 */
StudioApp.prototype.setConfigValues_ = function (config) {
  this.share = config.share;
  this.centerEmbedded = utils.valueOr(config.centerEmbedded, this.centerEmbedded);
  this.wireframeShare = utils.valueOr(config.wireframeShare, this.wireframeShare);

  // if true, dont provide links to share on fb/twitter
  this.disableSocialShare = config.disableSocialShare;
  this.sendToPhone = config.sendToPhone;
  this.noPadding = config.noPadding;

  // contract editor requires more vertical space. set height to 1250 unless
  // explicitly specified
  if (config.level.useContractEditor) {
    config.level.minWorkspaceHeight = config.level.minWorkspaceHeight || 1250;
  }

  this.appMsg = config.appMsg;
  this.IDEAL_BLOCK_NUM = config.level.ideal || Infinity;
  this.MIN_WORKSPACE_HEIGHT = config.level.minWorkspaceHeight || 800;
  this.requiredBlocks_ = config.level.requiredBlocks || [];
  this.recommendedBlocks_ = config.level.recommendedBlocks || [];
  this.startBlocks_ = config.level.lastAttempt || config.level.startBlocks || '';
  this.vizAspectRatio = config.vizAspectRatio || 1.0;
  this.nativeVizWidth = config.nativeVizWidth || this.maxVisualizationWidth;

  // enableShowCode defaults to true if not defined
  this.enableShowCode = config.enableShowCode !== false;
  this.enableShowLinesCount = config.enableShowLinesCount !== false;

  // If the level has no ideal block count, don't show a block count. If it does
  // have an ideal, show block count unless explicitly configured not to.
  if (config.level && (config.level.ideal === undefined || config.level.ideal === Infinity)) {
    this.enableShowBlockCount = false;
  } else {
    this.enableShowBlockCount = config.enableShowBlockCount !== false;
  }

  // Store configuration.
  this.onAttempt = config.onAttempt || function () {};
  this.onContinue = config.onContinue || function () {};
  this.onInitialize = config.onInitialize ? config.onInitialize.bind(config) : function () {};
  this.onResetPressed = config.onResetPressed || function () {};
  this.backToPreviousLevel = config.backToPreviousLevel || function () {};
  this.skin = config.skin;
  this.showInstructions = this.showInstructions_.bind(this, config.level, false);
  this.polishCodeHook = config.polishCodeHook;
};

// Overwritten by applab.
StudioApp.prototype.runButtonClickWrapper = function (callback) {
  if (window.$) {
    $(window).trigger('run_button_pressed');
    $(window).trigger('appModeChanged');
  }
  callback();
};

/**
 * Begin modifying the DOM based on config.
 * Note: Has side effects on config
 */
StudioApp.prototype.configureDom = function (config) {
  var container = document.getElementById(config.containerId);
  if (!this.enableShowCode) {
    document.getElementById('show-code-header').style.display = 'none';
  }
  var codeWorkspace = container.querySelector('#codeWorkspace');

  var runButton = container.querySelector('#runButton');
  var resetButton = container.querySelector('#resetButton');
  var runClick = this.runButtonClick.bind(this);
  var throttledRunClick = _.debounce(this.runButtonClickWrapper.bind(this, runClick), 250, true);
  dom.addClickTouchEvent(runButton, _.bind(throttledRunClick, this));
  dom.addClickTouchEvent(resetButton, _.bind(this.resetButtonClick, this));

  // TODO (cpirich): make conditional for applab
  var belowViz = document.getElementById('belowVisualization');
  var referenceArea = document.getElementById('reference_area');
  if (referenceArea) {
    belowViz.appendChild(referenceArea);
  }

  var visualizationColumn = document.getElementById('visualizationColumn');
  var visualization = document.getElementById('visualization');

  if (!config.hideSource || config.embed) {
    var vizHeight = this.MIN_WORKSPACE_HEIGHT;
    if (this.isUsingBlockly() && config.level.edit_blocks) {
      // Set a class on the main blockly div so CSS can style blocks differently
      $(codeWorkspace).addClass('edit');
      // If in level builder editing blocks, make workspace extra tall
      vizHeight = 3000;
      // Modify the arrangement of toolbox blocks so categories align left
      if (config.level.edit_blocks == "toolbox_blocks") {
        this.blockYCoordinateInterval = 80;
        config.blockArrangement = { category: { x: 20 } };
      }
      // Enable param & var editing in levelbuilder, regardless of level setting
      config.level.disableParamEditing = false;
      config.level.disableVariableEditing = false;
    }

    if (config.pinWorkspaceToBottom) {
      var bodyElement = document.body;
      bodyElement.style.overflow = "hidden";
      bodyElement.className = bodyElement.className + " pin_bottom";
      container.className = container.className + " pin_bottom";
      visualizationColumn.className = visualizationColumn.className + " pin_bottom";
      codeWorkspace.className = codeWorkspace.className + " pin_bottom";
      if (this.editCode) {
        var codeTextbox = document.getElementById('codeTextbox');
        codeTextbox.className = codeTextbox.className + " pin_bottom";
      }
    } else {
      visualizationColumn.style.minHeight = vizHeight + 'px';
      container.style.minHeight = vizHeight + 'px';
    }
  }

  if (config.readonlyWorkspace) {
    $(codeWorkspace).addClass('readonly');
  }

  // NOTE: Can end up with embed true and hideSource false in level builder
  // scenarios. See https://github.com/code-dot-org/code-dot-org/pull/1744
  if (config.embed && config.hideSource && this.centerEmbedded) {
    container.className = container.className + " centered_embed";
    visualizationColumn.className = visualizationColumn.className + " centered_embed";
  }

  if (!config.embed && !config.hideSource) {
    // Make the visualization responsive to screen size, except on share page.
    visualization.className += " responsive";
    visualizationColumn.className += " responsive";
    var smallFooter = document.querySelector('#page-small-footer .small-footer-base');
    if (smallFooter) {
      smallFooter.className += " responsive";
    }
  }
};

/**
 *
 */
StudioApp.prototype.handleHideSource_ = function (options) {
  var container = document.getElementById(options.containerId);
  this.hideSource = true;
  var workspaceDiv = document.getElementById('codeWorkspace');
  if (!options.embed || options.level.skipInstructionsPopup) {
    container.className = 'hide-source';
  }
  workspaceDiv.style.display = 'none';
  document.getElementById('visualizationResizeBar').style.display = 'none';

  // Chrome-less share page.
  if (this.share) {
    if (options.isLegacyShare || this.wireframeShare) {
      document.body.style.backgroundColor = '#202B34';

      $('.header-wrapper').hide();
      var vizColumn = document.getElementById('visualizationColumn');
      if (dom.isMobile() && (options.isLegacyShare || !dom.isIPad())) {
        $(vizColumn).addClass('chromelessShare');
      } else {
        $(vizColumn).addClass('wireframeShare');

        var div = document.createElement('div');
        document.body.appendChild(div);
        React.render(React.createElement(WireframeSendToPhone, {
          channelId: dashboard.project.getCurrentId(),
          appType: dashboard.project.getStandaloneApp()
        }), div);
      }

      if (!options.embed) {
        var runButton = document.getElementById('runButton');
        var buttonRow = runButton.parentElement;
        var openWorkspace = document.createElement('button');
        openWorkspace.setAttribute('id', 'open-workspace');
        openWorkspace.appendChild(document.createTextNode(msg.openWorkspace()));

        dom.addClickTouchEvent(openWorkspace, function () {
          // /c/ URLs go to /edit when we click open workspace.
          // /project/ URLs we want to go to /view (which doesnt require login)
          if (/^\/c\//.test(location.pathname)) {
            location.href += '/edit';
          } else {
            location.href += '/view';
          }
        });

        buttonRow.appendChild(openWorkspace);
      }
    }
  }
};

StudioApp.prototype.handleEditCode_ = function (config) {

  if (this.hideSource) {
    // In hide source mode, just call afterInject and exit immediately
    if (config.afterInject) {
      config.afterInject();
    }
    return;
  }

  var displayMessage, examplePrograms, messageElement, onChange, startingText;

  // Ensure global ace variable is the same as window.ace
  // (important because they can be different in our test environment)

  /* jshint ignore:start */
  ace = window.ace;
  /* jshint ignore:end */

  var fullDropletPalette = dropletUtils.generateDropletPalette(config.level.codeFunctions, config.dropletConfig);
  this.editor = new droplet.Editor(document.getElementById('codeTextbox'), {
    mode: 'javascript',
    modeOptions: dropletUtils.generateDropletModeOptions(config),
    palette: fullDropletPalette,
    showPaletteInTextMode: true,
    showDropdownInPalette: config.showDropdownInPalette,
    allowFloatingBlocks: false,
    dropIntoAceAtLineStart: config.dropIntoAceAtLineStart,
    enablePaletteAtStart: !config.readonlyWorkspace,
    textModeAtStart: config.level.textModeAtStart
  });

  this.editor.aceEditor.setShowPrintMargin(false);

  // Init and define our custom ace mode:
  aceMode.defineForAce(config.dropletConfig, config.unusedConfig, this.editor);
  // Now set the editor to that mode:
  var aceEditor = this.editor.aceEditor;
  aceEditor.session.setMode('ace/mode/javascript_codeorg');

  // Extend the command list on the ace Autocomplete object to include the period:
  var Autocomplete = window.ace.require("ace/autocomplete").Autocomplete;
  Autocomplete.prototype.commands['.'] = function (editor) {
    // First, insert the period and update the completions:
    editor.insert(".");
    editor.completer.updateCompletions(true);
    var filtered = editor.completer.completions && editor.completer.completions.filtered;
    for (var i = 0; i < (filtered && filtered.length); i++) {
      // If we have any exact maches in our filtered completions that include
      // this period, allow the completer to stay active:
      if (filtered[i].exactMatch) {
        return;
      }
    }
    // Otherwise, detach the completer:
    editor.completer.detach();
  };

  var langTools = window.ace.require("ace/ext/language_tools");

  // We don't want to include the textCompleter. langTools doesn't give us a way
  // to remove base completers (note: it does in newer versions of ace), so
  // we set aceEditor.completers manually
  aceEditor.completers = [langTools.snippetCompleter, langTools.keyWordCompleter];
  // make setCompleters fail so that attempts to use it result in clear failure
  // instead of just silently not working
  langTools.setCompleters = function () {
    throw new Error('setCompleters disabled. set aceEditor.completers directly');
  };

  // Add an ace completer for the API functions exposed for this level
  if (config.dropletConfig) {
    var functionsFilter = null;
    if (config.level.autocompletePaletteApisOnly) {
      functionsFilter = config.level.codeFunctions;
    }

    aceEditor.completers.push(dropletUtils.generateAceApiCompleter(functionsFilter, config.dropletConfig));
  }

  this.editor.aceEditor.setOptions({
    enableBasicAutocompletion: true,
    enableLiveAutocompletion: true
  });

  this.dropletTooltipManager = new DropletTooltipManager(this.appMsg, config.dropletConfig, config.level.codeFunctions, config.level.autocompletePaletteApisOnly);
  if (config.level.dropletTooltipsDisabled) {
    this.dropletTooltipManager.setTooltipsEnabled(false);
  }
  this.dropletTooltipManager.registerBlocks();

  // Bind listener to palette/toolbox 'Hide' and 'Show' links
  var hideToolboxHeader = document.getElementById('toolbox-header');
  var hideToolboxIcon = document.getElementById('hide-toolbox-icon');
  var showToolboxHeader = document.getElementById('show-toolbox-header');
  if (hideToolboxHeader && hideToolboxIcon && showToolboxHeader) {
    hideToolboxHeader.className += ' toggleable';
    hideToolboxIcon.style.display = 'inline-block';
    var handleTogglePalette = (function () {
      if (this.editor) {
        this.editor.enablePalette(!this.editor.paletteEnabled);
        showToolboxHeader.style.display = this.editor.paletteEnabled ? 'none' : 'inline-block';
        hideToolboxIcon.style.display = !this.editor.paletteEnabled ? 'none' : 'inline-block';
        this.resizeToolboxHeader();
      }
    }).bind(this);
    dom.addClickTouchEvent(hideToolboxHeader, handleTogglePalette);
    dom.addClickTouchEvent(showToolboxHeader, handleTogglePalette);
  }

  this.resizeToolboxHeader();

  var startBlocks = config.level.lastAttempt || config.level.startBlocks;
  if (startBlocks) {

    try {
      // Don't pass CRLF pairs to droplet until they fix CR handling:
      this.editor.setValue(startBlocks.replace(/\r\n/g, '\n'));
    } catch (err) {
      // catch errors without blowing up entirely. we may still not be in a
      // great state
      console.error(err.message);
    }
    // Reset droplet Undo stack:
    this.editor.clearUndoStack();
    // Reset ace Undo stack:
    var UndoManager = window.ace.require("ace/undomanager").UndoManager;
    this.editor.aceEditor.getSession().setUndoManager(new UndoManager());
  }

  if (config.readonlyWorkspace) {
    // When in readOnly mode, show source, but do not allow editing,
    // disable the palette, and hide the UI to show the palette:
    this.editor.setReadOnly(true);
    showToolboxHeader.style.display = 'none';
  }

  // droplet may now be in code mode if it couldn't parse the code into
  // blocks, so update the UI based on the current state (don't autofocus
  // if we have already created an instructionsDialog at this stage of init)
  this.onDropletToggle_(!this.instructionsDialog);

  this.dropletTooltipManager.registerDropletBlockModeHandlers(this.editor);

  this.editor.on('palettetoggledone', function (e) {
    // Reposition callouts after block/text toggle (in case they need to move)
    $('.cdo-qtips').qtip('reposition', null, false);
  });

  if (this.instructionsDialog) {
    // Initializing the droplet editor in text mode (ace) can steal the focus
    // from our visible instructions dialog. Restore focus where it belongs:
    this.instructionsDialog.focus();
  }

  if (config.afterEditorReady) {
    config.afterEditorReady();
  }

  if (config.afterInject) {
    config.afterInject();
  }
};

/**
 * Enable adding/removing breakpoints by clicking in the gutter of the editor.
 * Prerequisites: Droplet editor must be in use and initialized (e.g. you have
 * to call handleEditCode_ first).
 */
StudioApp.prototype.enableBreakpoints = function () {
  if (!this.editor) {
    throw new Error('Droplet editor must be in use to enable breakpoints.');
  }

  // Set up an event handler to create breakpoints when clicking in the gutter:
  this.editor.on('guttermousedown', (function (e) {
    var bps = this.editor.getBreakpoints();
    if (bps[e.line]) {
      this.editor.clearBreakpoint(e.line);
    } else {
      this.editor.setBreakpoint(e.line);
    }
  }).bind(this));
};

/**
 * Set whether to alert user to empty blocks, short-circuiting all other tests.
 * @param {boolean} checkBlocks Whether to check for empty blocks.
 */
StudioApp.prototype.setCheckForEmptyBlocks = function (checkBlocks) {
  this.checkForEmptyBlocks_ = checkBlocks;
};

/**
 * Add the starting block(s).  Don't load lastAttempt for Jigsaw levels or the
 * level will advance as soon as it's loaded.
 * @param loadLastAttempt If true, try to load config.lastAttempt.
 */
StudioApp.prototype.setStartBlocks_ = function (config, loadLastAttempt) {
  if (config.level.edit_blocks) {
    loadLastAttempt = false;
  }
  var startBlocks = config.level.startBlocks || '';
  if (loadLastAttempt && config.levelGameName !== 'Jigsaw') {
    startBlocks = config.level.lastAttempt || startBlocks;
  }
  if (config.forceInsertTopBlock) {
    startBlocks = blockUtils.forceInsertTopBlock(startBlocks, config.forceInsertTopBlock);
  }
  startBlocks = this.arrangeBlockPosition(startBlocks, config.blockArrangement);
  try {
    this.loadBlocks(startBlocks);
  } catch (e) {
    if (loadLastAttempt) {
      Blockly.mainBlockSpace.clear();
      // Try loading the default start blocks instead.
      this.setStartBlocks_(config, false);
    } else {
      throw e;
    }
  }
};

/**
 * Show the configured starting function definition.
 */
StudioApp.prototype.openFunctionDefinition_ = function (config) {
  if (Blockly.contractEditor) {
    Blockly.contractEditor.autoOpenWithLevelConfiguration({
      autoOpenFunction: config.level.openFunctionDefinition,
      contractCollapse: config.level.contractCollapse,
      contractHighlight: config.level.contractHighlight,
      examplesCollapse: config.level.examplesCollapse,
      examplesHighlight: config.level.examplesHighlight,
      definitionCollapse: config.level.definitionCollapse,
      definitionHighlight: config.level.definitionHighlight
    });
  } else {
    Blockly.functionEditor.autoOpenFunction(config.level.openFunctionDefinition);
  }
};

/**
 *
 */
StudioApp.prototype.handleUsingBlockly_ = function (config) {
  // Allow empty blocks if editing blocks.
  if (config.level.edit_blocks) {
    this.checkForEmptyBlocks_ = false;
    if (config.level.edit_blocks === 'required_blocks' || config.level.edit_blocks === 'toolbox_blocks' || config.level.edit_blocks === 'recommended_blocks') {
      // Don't show when run block for toolbox/required/recommended block editing
      config.forceInsertTopBlock = null;
    }
  }

  // If levelbuilder provides an empty toolbox, some apps (like artist)
  // replace it with a full toolbox. I think some levels may depend on this
  // behavior. We want a way to specify no toolbox, which is <xml></xml>
  if (config.level.toolbox) {
    var toolboxWithoutWhitespace = config.level.toolbox.replace(/\s/g, '');
    if (toolboxWithoutWhitespace === '<xml></xml>' || toolboxWithoutWhitespace === '<xml/>') {
      config.level.toolbox = undefined;
    }
  }

  var div = document.getElementById('codeWorkspace');
  var options = {
    toolbox: config.level.toolbox,
    disableParamEditing: utils.valueOr(config.level.disableParamEditing, true),
    disableVariableEditing: utils.valueOr(config.level.disableVariableEditing, false),
    useModalFunctionEditor: utils.valueOr(config.level.useModalFunctionEditor, false),
    useContractEditor: utils.valueOr(config.level.useContractEditor, false),
    disableExamples: utils.valueOr(config.level.disableExamples, false),
    defaultNumExampleBlocks: utils.valueOr(config.level.defaultNumExampleBlocks, 2),
    scrollbars: config.level.scrollbars,
    hasVerticalScrollbars: config.hasVerticalScrollbars,
    hasHorizontalScrollbars: config.hasHorizontalScrollbars,
    editBlocks: utils.valueOr(config.level.edit_blocks, false),
    readOnly: utils.valueOr(config.readonlyWorkspace, false),
    showExampleTestButtons: utils.valueOr(config.showExampleTestButtons, false)
  };
  ['trashcan', 'varsInGlobals', 'grayOutUndeletableBlocks', 'disableParamEditing'].forEach(function (prop) {
    if (config[prop] !== undefined) {
      options[prop] = config[prop];
    }
  });
  this.inject(div, options);
  this.onResize();

  if (config.afterInject) {
    config.afterInject();
  }
  this.setStartBlocks_(config, true);
};

/**
 * Modify the workspace header after a droplet blocks/code or palette toggle
 */
StudioApp.prototype.updateHeadersAfterDropletToggle_ = function (usingBlocks) {
  // Update header titles:
  var showCodeHeader = document.getElementById('show-code-header');
  var contentSpan = showCodeHeader.firstChild;
  var fontAwesomeGlyph = _.find(contentSpan.childNodes, function (node) {
    return (/\bfa\b/.test(node.className)
    );
  });
  var imgBlocksGlyph = _.find(contentSpan.childNodes, function (node) {
    return (/\bblocks-glyph\b/.test(node.className)
    );
  });

  // Change glyph
  if (usingBlocks) {
    if (fontAwesomeGlyph && imgBlocksGlyph) {
      fontAwesomeGlyph.style.display = 'inline-block';
      imgBlocksGlyph.style.display = 'none';
    }
    contentSpan.lastChild.textContent = msg.showTextHeader();
  } else {
    if (fontAwesomeGlyph && imgBlocksGlyph) {
      fontAwesomeGlyph.style.display = 'none';
      imgBlocksGlyph.style.display = 'inline-block';
    }
    contentSpan.lastChild.textContent = msg.showBlocksHeader();
  }

  var blockCount = document.getElementById('blockCounter');
  if (blockCount) {
    blockCount.style.display = usingBlocks && this.enableShowBlockCount ? 'inline-block' : 'none';
  }
};

/**
 * Handle updates after a droplet toggle between blocks/code has taken place
 */
StudioApp.prototype.onDropletToggle_ = function (autoFocus) {
  autoFocus = utils.valueOr(autoFocus, true);
  this.updateHeadersAfterDropletToggle_(this.editor.currentlyUsingBlocks);
  if (!this.editor.currentlyUsingBlocks) {
    if (autoFocus) {
      this.editor.aceEditor.focus();
    }
    this.dropletTooltipManager.registerDropletTextModeHandlers(this.editor);
  }
};

/**
 * Do we have any floating blocks not attached to an event block or function block?
 */
StudioApp.prototype.hasExtraTopBlocks = function () {
  return this.feedback_.hasExtraTopBlocks();
};

/**
 *
 */
StudioApp.prototype.hasQuestionMarksInNumberField = function () {
  return this.feedback_.hasQuestionMarksInNumberField();
};

/**
 * @returns true if any non-example block in the workspace has an unfilled input
 */
StudioApp.prototype.hasUnfilledFunctionalBlock = function () {
  return !!this.getUnfilledFunctionalBlock();
};

/**
 * @returns {Block} The first block that has an unfilled input, or undefined
 *   if there isn't one.
 */
StudioApp.prototype.getUnfilledFunctionalBlock = function () {
  return this.getFilteredUnfilledFunctionalBlock_(function (rootBlock) {
    return rootBlock.type !== 'functional_example';
  });
};

/**
 * @returns {Block} The first example block that has an unfilled input, or
 *   undefined if there isn't one. Ignores example blocks that don't have a
 *   call portion, as these are considered invalid.
 */
StudioApp.prototype.getUnfilledFunctionalExample = function () {
  return this.getFilteredUnfilledFunctionalBlock_(function (rootBlock) {
    if (rootBlock.type !== 'functional_example') {
      return false;
    }
    var actual = rootBlock.getInputTargetBlock('ACTUAL');
    return actual && actual.getTitleValue('NAME');
  });
};

/**
 * @param {function} filter Run against root block in chain. Returns true if
 *   this is a block we care about
 */
StudioApp.prototype.getFilteredUnfilledFunctionalBlock_ = function (filter) {
  var unfilledBlock;
  Blockly.mainBlockSpace.getAllBlocks().some(function (block) {
    // Get the root block in the chain
    var rootBlock = block.getRootBlock();
    if (!filter(rootBlock)) {
      return false;
    }

    if (block.hasUnfilledFunctionalInput()) {
      unfilledBlock = block;
      return true;
    }
  });

  return unfilledBlock;
};

/**
 * @returns {string} The name of a function that doesn't have any examples, or
 *   undefined if all have at least one.
 */
StudioApp.prototype.getFunctionWithoutTwoExamples = function () {
  var definitionNames = Blockly.mainBlockSpace.getTopBlocks().filter(function (block) {
    return block.type === 'functional_definition' && !block.isVariable();
  }).map(function (definitionBlock) {
    return definitionBlock.getProcedureInfo().name;
  });

  var exampleNames = Blockly.mainBlockSpace.getTopBlocks().filter(function (block) {
    if (block.type !== 'functional_example') {
      return false;
    }

    // Only care about functional_examples that have an ACTUAL input (i.e. it's
    // clear which function they're for
    var actual = block.getInputTargetBlock('ACTUAL');
    return actual && actual.getTitleValue('NAME');
  }).map(function (exampleBlock) {
    return exampleBlock.getInputTargetBlock('ACTUAL').getTitleValue('NAME');
  });

  var definitionWithLessThanTwoExamples;
  definitionNames.forEach(function (def) {
    var definitionExamples = exampleNames.filter(function (example) {
      return def === example;
    });

    if (definitionExamples.length < 2) {
      definitionWithLessThanTwoExamples = def;
    }
  });
  return definitionWithLessThanTwoExamples;
};

/**
 * Get the error message when we have an unfilled block
 * @param {string} topLevelType The block.type For our expected top level block
 */
StudioApp.prototype.getUnfilledFunctionalBlockError = function (topLevelType) {
  var unfilled = this.getUnfilledFunctionalBlock();

  if (!unfilled) {
    return null;
  }

  var topParent = unfilled;
  while (topParent.getParent()) {
    topParent = topParent.getParent();
  }

  if (unfilled.type === topLevelType) {
    return msg.emptyTopLevelBlock({ topLevelBlockName: unfilled.getTitleValue() });
  }

  if (topParent.type !== 'functional_definition') {
    return msg.emptyFunctionalBlock();
  }

  var procedureInfo = topParent.getProcedureInfo();
  if (topParent.isVariable()) {
    return msg.emptyBlockInVariable({ name: procedureInfo.name });
  } else {
    return msg.emptyBlockInFunction({ name: procedureInfo.name });
  }
};

/**
 * Looks for failing examples, and updates the result text for them if they're
 * open in the contract editor
 * @param {function} failureChecker Apps example tester that takes in an example
 *   block, and outputs a failure string (or null if success)
 * @returns {string} Name of block containing first failing example we found, or
 *   empty string if no failures.
 */
StudioApp.prototype.checkForFailingExamples = function (failureChecker) {
  var failingBlockName = '';
  Blockly.mainBlockSpace.findFunctionExamples().forEach(function (exampleBlock) {
    var failure = failureChecker(exampleBlock, false);

    // Update the example result. No-op if we're not currently editing this
    // function.
    Blockly.contractEditor.updateExampleResult(exampleBlock, failure);

    if (failure) {
      failingBlockName = exampleBlock.getInputTargetBlock('ACTUAL').getTitleValue('NAME');
    }
  });
  return failingBlockName;
};

/**
 * @returns {boolean} True if we have a function or variable named "" (empty string)
 */
StudioApp.prototype.hasEmptyFunctionOrVariableName = function () {
  return Blockly.mainBlockSpace.getTopBlocks().some(function (block) {
    if (block.type !== 'functional_definition') {
      return false;
    }

    return !block.getProcedureInfo().name;
  });
};

StudioApp.prototype.createCoordinateGridBackground = function (options) {
  var svgName = options.svg;
  var origin = options.origin;
  var firstLabel = options.firstLabel;
  var lastLabel = options.lastLabel;
  var increment = options.increment;

  var CANVAS_HEIGHT = 400;
  var CANVAS_WIDTH = 400;

  var svg = document.getElementById(svgName);

  var bbox, text, rect;
  for (var label = firstLabel; label <= lastLabel; label += increment) {
    // create x axis labels
    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.appendChild(document.createTextNode(label));
    svg.appendChild(text);
    bbox = text.getBBox();
    text.setAttribute('x', label - origin - bbox.width / 2);
    text.setAttribute('y', CANVAS_HEIGHT);
    text.setAttribute('font-weight', 'bold');
    rect = rectFromElementBoundingBox(text);
    rect.setAttribute('fill', 'white');
    svg.insertBefore(rect, text);

    // create y axis labels
    text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.appendChild(document.createTextNode(label));
    svg.appendChild(text);
    bbox = text.getBBox();
    text.setAttribute('x', 0);
    text.setAttribute('y', CANVAS_HEIGHT - (label - origin));
    text.setAttribute('dominant-baseline', 'central');
    text.setAttribute('font-weight', 'bold');
    rect = rectFromElementBoundingBox(text);
    rect.setAttribute('fill', 'white');
    svg.insertBefore(rect, text);
  }
};

function rectFromElementBoundingBox(element) {
  var bbox = element.getBBox();
  var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rect.setAttribute('x', bbox.x);
  rect.setAttribute('y', bbox.y);
  rect.setAttribute('width', bbox.width);
  rect.setAttribute('height', bbox.height);
  return rect;
}

/**
 * Displays a small alert box inside DOM element at parentSelector.
 * @param {string} parentSelector
 * @param {object} props A set of React properties passed to the AbuseError
 *   component
 */
StudioApp.prototype.displayAlert = function (parentSelector, props) {
  // Each parent is assumed to have at most a single alert. This assumption
  // could be changed, but we would then want to clean up our DOM element on
  // close
  var parent = $(parentSelector);
  var container = parent.children('.react-alert');
  if (container.length === 0) {
    container = $("<div class='react-alert'/>");
    parent.append(container);
  }

  var reactProps = $.extend({}, {
    className: 'alert-error',
    onClose: function onClose() {
      React.unmountComponentAtNode(container[0]);
    }
  }, props);

  var element = React.createElement(Alert, reactProps);
  React.render(element, container[0]);
};

/**
 * If the current project is considered abusive, display a small alert box
 * @param {string} parentSelector The selector for the DOM element parent we
 *   should display the error in.
 */
StudioApp.prototype.alertIfAbusiveProject = function (parentSelector) {
  if (window.dashboard && dashboard.project.exceedsAbuseThreshold()) {
    this.displayAlert(parentSelector, {
      body: React.createElement(dashboard.AbuseError, {
        i18n: {
          tos: window.dashboard.i18n.t('project.abuse.tos'),
          contact_us: window.dashboard.i18n.t('project.abuse.contact_us')
        }
      }),
      style: {
        top: 45,
        left: 350,
        right: 50
      }
    });
  }
};

/**
 * Searches for cases where we have two (or more) nested for loops in which
 * both loops use the same variable. This can cause infinite loops.
 * @returns {boolean} True if we detect an instance of this.
 */
StudioApp.prototype.hasDuplicateVariablesInForLoops = function () {
  if (this.editCode) {
    return false;
  }
  return Blockly.mainBlockSpace.getAllBlocks().some(this.forLoopHasDuplicatedNestedVariables_);
};

/**
 * Looks to see if a particular block is (a) a for loop and (b) has a descendant
 * for loop using the same variable.
 * @returns {boolean} True if that is true of this block
 */
StudioApp.prototype.forLoopHasDuplicatedNestedVariables_ = function (block) {
  if (!block || block.type !== 'controls_for' && block.type !== 'controls_for_counter') {
    return;
  }

  var innerBlock = block.getInput('DO').connection.targetBlock();

  // Not the most efficient of algo's, but we shouldn't have enough blocks for
  // it to matter.
  return block.getVars().some(function (varName) {
    return innerBlock.getDescendants().some(function (descendant) {
      if (descendant.type !== 'controls_for' && descendant.type !== 'controls_for_counter') {
        return false;
      }
      return descendant.getVars().indexOf(varName) !== -1;
    });
  });
};

/**
 * Polishes the generated code string before displaying it to the user. If the
 * app provided a polishCodeHook function, it will be called.
 * @returns {string} code string that may/may not have been modified
 */
StudioApp.prototype.polishGeneratedCodeString = function (code) {
  if (this.polishCodeHook) {
    return this.polishCodeHook(code);
  } else {
    return code;
  }
};

},{"./ResizeSensor":"/home/ubuntu/staging/apps/build/js/ResizeSensor.js","./acemode/mode-javascript_codeorg":"/home/ubuntu/staging/apps/build/js/acemode/mode-javascript_codeorg.js","./assetManagement/assetListStore":"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js","./assetManagement/assetPrefix":"/home/ubuntu/staging/apps/build/js/assetManagement/assetPrefix.js","./authoredHints":"/home/ubuntu/staging/apps/build/js/authoredHints.js","./blockTooltips/DropletTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletTooltipManager.js","./block_utils":"/home/ubuntu/staging/apps/build/js/block_utils.js","./clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./constants.js":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./feedback":"/home/ubuntu/staging/apps/build/js/feedback.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./logToCloud":"/home/ubuntu/staging/apps/build/js/logToCloud.js","./puzzleRatingUtils":"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js","./templates/Instructions.jsx":"/home/ubuntu/staging/apps/build/js/templates/Instructions.jsx","./templates/VersionHistory.jsx":"/home/ubuntu/staging/apps/build/js/templates/VersionHistory.jsx","./templates/WireframeSendToPhone.jsx":"/home/ubuntu/staging/apps/build/js/templates/WireframeSendToPhone.jsx","./templates/alert.jsx":"/home/ubuntu/staging/apps/build/js/templates/alert.jsx","./templates/builder.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/builder.html.ejs","./templates/buttons.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs","./templates/learn.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/learn.html.ejs","./templates/makeYourOwn.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/makeYourOwn.html.ejs","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js","url":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/url/url.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/url/url.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/punycode/punycode.js","querystring":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/index.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/index.js":[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/decode.js","./encode":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/encode.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/encode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/querystring-es3/decode.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/punycode/punycode.js":[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/build/js/templates/makeYourOwn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale') ; buf.push('\n\n<div id="make-your-own">\n\n  <h1><a href=', escape((5,  data.makeUrl )), '>', escape((5,  data.makeString )), '</a></h1>\n  <a href=', escape((6,  data.makeUrl )), '><img src=', escape((6,  data.makeImage )), '></a>\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/learn.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale') ; buf.push('\n\n');3; var root = location.protocol + '//' + location.host.replace('learn\.', '').replace('studio\.', ''); 
; buf.push('\n\n<div id="learn">\n\n  <h1><a href="', escape((7,  root )), '">', escape((7,  msg.wantToLearn() )), '</a></h1>\n  <a href="', escape((8,  root )), '"><img id="learn-to-code" src="', escape((8,  assetUrl('media/promo.png') )), '"></a>\n  <a href="', escape((9,  root )), '">', escape((9,  msg.watchVideo() )), '</a>\n  <a href="', escape((10,  root )), '">', escape((10,  msg.tryHOC() )), '</a>\n  <a href="', escape((11,  location.protocol + '//' + location.host 
)), '">', escape((11,  msg.signup() )), '</a>\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/builder.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div><span>Instructions: </span><textarea type="text" name="instructions"></textarea></div>\n<div><span>Level Name: </span><textarea type="text" name="level_name"></textarea></div>\n<button id="create-level-button" class="launch">\n  Create Level\n</button>\n<div id="builder-error"></div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/alert.jsx":[function(require,module,exports){
/* global $ */

/**
 * Simple boot-strapped style alert.
 */
'use strict';

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    body: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]).isRequired,
    className: React.PropTypes.string,
    style: React.PropTypes.object,
    onClose: React.PropTypes.func.isRequired
  },

  render: function render() {
    var style = $.extend({}, {
      position: 'absolute',
      zIndex: 1000
    }, this.props.style);

    return React.createElement(
      'div',
      { style: style },
      React.createElement(
        'div',
        { className: "alert fade in " + (this.props.className || '') },
        React.createElement(
          'button',
          { type: 'button',
            className: 'alert-button close',
            style: { margin: 0 } },
          React.createElement(
            'span',
            { onClick: this.props.onClose },
            ''
          )
        ),
        this.props.body
      )
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/WireframeSendToPhone.jsx":[function(require,module,exports){
/* globals $, dashboard */

'use strict';

var SendToPhone = window.dashboard ? window.dashboard.SendToPhone : undefined;

var styles = {
  main: {
    position: 'absolute',
    bottom: 10,
    right: 10,
    textAlign: 'right',
    textShadow: '#000 -1px -1px 0',
    font: '12pt "Gotham 5r", sans-serif',
    color: '#8F9499'
  },
  icon: {
    fontSize: '1.5em'
  },
  sendToPhone: {
    label: {
      font: '12pt "Gotham 5r", sans-serif',
      color: '#8F9499'
    },
    div: {
      margin: 0
    }
  }
};

/**
 * Shows a prompt for SendToPhone. On click, replaces prompt with our
 * SendToPhone component.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    channelId: React.PropTypes.string.isRequired,
    appType: React.PropTypes.string.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      clicked: false
    };
  },

  handleClick: function handleClick() {
    this.setState({ clicked: !this.state.clicked });
    return false; // so the # link doesn't go anywhere.
  },

  render: function render() {
    return React.createElement(
      'div',
      { style: styles.main },
      this.renderSendToPhone(),
      React.createElement(
        'a',
        { className: 'WireframeSendToPhone_send-to-phone-link', href: '#', onClick: this.handleClick },
        React.createElement('i', { style: styles.icon, className: 'fa fa-mobile' }),
        ' See this app on your phone'
      )
    );
  },

  renderSendToPhone: function renderSendToPhone() {
    if (this.state.clicked) {
      return React.createElement(SendToPhone, {
        styles: styles.sendToPhone,
        channelId: this.props.channelId,
        appType: this.props.appType
      });
    }
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/VersionHistory.jsx":[function(require,module,exports){
/* global dashboard */
'use strict';

var VersionRow = require('./VersionRow.jsx');
var sourcesApi = require('../clientApi').sources;

/**
 * A component for viewing project version history.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    handleClearPuzzle: React.PropTypes.func.isRequired
  },

  /**
   * @returns {{statusMessage: string, versions: (null|{
   *   lastModified: Date,
   *   isLatest: boolean,
   *   versionId: string
   * }[])}}
   */
  getInitialState: function getInitialState() {
    return {
      versions: null,
      statusMessage: '',
      showSpinner: true,
      confirmingClearPuzzle: false
    };
  },

  componentWillMount: function componentWillMount() {
    // TODO: Use Dave's client api when it's finished.
    sourcesApi.ajax('GET', 'main.json/versions', this.onVersionListReceived, this.onAjaxFailure);
  },

  /**
   * Called after the component mounts, when the server responds with the
   * current list of versions.
   * @param xhr
   */
  onVersionListReceived: function onVersionListReceived(xhr) {
    this.setState({ versions: JSON.parse(xhr.responseText), showSpinner: false });
  },

  /**
   * Called if the server responds with an error when loading an API request.
   */
  onAjaxFailure: function onAjaxFailure() {
    this.setState({ statusMessage: 'An error occurred.' });
  },

  /**
   * Called when the server responds to a request to restore a previous version.
   */
  onRestoreSuccess: function onRestoreSuccess() {
    location.reload();
  },

  /**
   * Called when the user chooses a previous version to restore.
   * @param versionId
   */
  onChooseVersion: function onChooseVersion(versionId) {
    // TODO: Use Dave's client api when it's finished.
    sourcesApi.ajax('PUT', 'main.json/restore?version=' + versionId, this.onRestoreSuccess, this.onAjaxFailure);

    // Show the spinner.
    this.setState({ showSpinner: true });
  },

  onConfirmClearPuzzle: function onConfirmClearPuzzle() {
    this.setState({ confirmingClearPuzzle: true });
  },

  onCancelClearPuzzle: function onCancelClearPuzzle() {
    this.setState({ confirmingClearPuzzle: false });
  },

  onClearPuzzle: function onClearPuzzle() {
    this.setState({ showSpinner: true });
    this.props.handleClearPuzzle();
    dashboard.project.save(function () {
      location.reload();
    }, true);
  },

  render: function render() {
    var body;
    if (this.state.showSpinner) {
      body = React.createElement(
        'div',
        { style: { margin: '1em 0', textAlign: 'center' } },
        React.createElement('i', { className: 'fa fa-spinner fa-spin', style: { fontSize: '32px' } })
      );
    } else if (this.state.confirmingClearPuzzle) {
      body = React.createElement(
        'div',
        null,
        React.createElement(
          'p',
          null,
          'Are you sure you want to clear all progress for this level?'
        ),
        React.createElement(
          'button',
          { id: 'confirm-button', style: { float: 'right' }, onClick: this.onClearPuzzle },
          'Start Over'
        ),
        React.createElement(
          'button',
          { id: 'again-button', onClick: this.onCancelClearPuzzle },
          'Cancel'
        )
      );
    } else {
      var rows = this.state.versions.map((function (version) {
        return React.createElement(VersionRow, {
          lastModified: new Date(version.lastModified),
          isLatest: version.isLatest,
          onChoose: this.onChooseVersion.bind(this, version.versionId) });
      }).bind(this));

      body = React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { maxHeight: '330px', overflowX: 'scroll', margin: '1em 0' } },
          React.createElement(
            'table',
            { style: { width: '100%' } },
            React.createElement(
              'tbody',
              null,
              rows,
              React.createElement(
                'tr',
                null,
                React.createElement(
                  'td',
                  null,
                  React.createElement(
                    'p',
                    { style: { margin: 0 } },
                    'Initial version'
                  )
                ),
                React.createElement(
                  'td',
                  { width: '250', style: { textAlign: 'right' } },
                  React.createElement(
                    'button',
                    { className: 'btn-danger', onClick: this.onConfirmClearPuzzle, style: { float: 'right' } },
                    'Delete Progress'
                  )
                )
              )
            )
          )
        )
      );
    }

    return React.createElement(
      'div',
      { className: 'modal-content', style: { margin: 0 } },
      React.createElement(
        'p',
        { className: 'dialog-title' },
        'Version History'
      ),
      body,
      this.state.statusMessage
    );
  }
});

},{"../clientApi":"/home/ubuntu/staging/apps/build/js/clientApi.js","./VersionRow.jsx":"/home/ubuntu/staging/apps/build/js/templates/VersionRow.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/VersionRow.jsx":[function(require,module,exports){
/* globals $ */

/**
 * A single row in the VersionHistory dialog, describing one version of a project.
 */
"use strict";

module.exports = React.createClass({
  displayName: "exports",

  propTypes: {
    lastModified: React.PropTypes.instanceOf(Date),
    isLatest: React.PropTypes.bool,
    onChoose: React.PropTypes.func
  },

  getLastModifiedTimestamp: function getLastModifiedTimestamp() {
    var timestamp = this.props.lastModified;
    if (timestamp.toLocaleString) {
      return timestamp.toLocaleString();
    }
    return timestamp.toString();
  },

  render: function render() {
    var button;
    if (this.props.isLatest) {
      button = React.createElement(
        "button",
        { className: "btn-default", disabled: "disabled", style: { cursor: "default" } },
        "Current Version"
      );
    } else {
      button = React.createElement(
        "button",
        { className: "btn-info", onClick: this.props.onChoose },
        "Restore this Version"
      );
    }

    return React.createElement(
      "tr",
      { className: "versionRow" },
      React.createElement(
        "td",
        null,
        React.createElement(
          "p",
          null,
          "Saved ",
          React.createElement(
            "time",
            { className: "versionTimestamp", dateTime: this.props.lastModified.toISOString() },
            this.getLastModifiedTimestamp()
          )
        ),
        this.getLastModifiedTimestamp()
      ),
      React.createElement(
        "td",
        { width: "250", style: { textAlign: 'right' } },
        button
      )
    );
  },

  componentDidMount: function componentDidMount() {
    $('.versionTimestamp').timeago();
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/Instructions.jsx":[function(require,module,exports){
'use strict';

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    puzzleTitle: React.PropTypes.string,
    instructions: React.PropTypes.string,
    instructions2: React.PropTypes.string,
    renderedMarkdown: React.PropTypes.string,
    markdownClassicMargins: React.PropTypes.bool,
    aniGifURL: React.PropTypes.string,
    authoredHints: React.PropTypes.element
  },

  render: function render() {

    // Body logic is as follows:
    //
    // If we have been given rendered markdown, render a div containing
    // that, optionally with inline-styled margins. We don't need to
    // worry about the title in this case, as it is rendered by the
    // Dialog header
    //
    // Otherwise, render the title and up to two sets of instructions.
    // These instructions may contain spans and images as determined by
    // StudioApp.substituteInstructionImages
    var body;
    if (this.props.renderedMarkdown) {
      // Optionally give markdown dialog wide left margin so it looks more like a
      // non-markdown instructions dialog (useful if mixing markdown instructions
      // with non-markdown instructions in one tutorial).
      var bodyStyle = this.props.markdownClassicMargins ? {
        paddingTop: 0,
        marginLeft: '90px'
      } : {};

      body = React.createElement('div', {
        className: 'instructions-markdown',
        style: bodyStyle,
        dangerouslySetInnerHTML: { __html: this.props.renderedMarkdown }
      });
    } else {
      body = [React.createElement(
        'p',
        { className: 'dialog-title' },
        this.props.puzzleTitle
      )];

      if (this.props.instructions) {
        body.push(React.createElement('p', { dangerouslySetInnerHTML: { __html: this.props.instructions } }));
      }

      if (this.props.instructions2) {
        body.push(React.createElement('p', { className: 'instructions2', dangerouslySetInnerHTML: { __html: this.props.instructions2 } }));
      }
    }

    var aniGif;
    if (this.props.aniGifURL) {
      aniGif = React.createElement('img', { className: 'aniGif example-image', src: this.props.aniGifURL });
    }

    return React.createElement(
      'div',
      null,
      body,
      aniGif,
      this.props.authoredHints
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/logToCloud.js":[function(require,module,exports){
'use strict';

var PageAction = {
  DropletTransitionError: 'DropletTransitionError',
  SanitizedLevelHtml: 'SanitizedLevelHtml',
  UserJavaScriptError: 'UserJavaScriptError'
};

var MAX_FIELD_LENGTH = 4095;

/**
 * Shims window.newrelic, which is only included in production. This causes us
 * to no-op in other environments.
 */
module.exports = {
  PageAction: PageAction,

  /**
   * @param {string} actionName - Must be one of the keys from PageAction
   * @param {object} value - Object literal representing columns we want to
   *   add for this action
   */
  addPageAction: function addPageAction(actionName, value) {
    if (!window.newrelic) {
      return;
    }

    if (!PageAction[actionName]) {
      console.log('Unknown actionName: ' + actionName);
      return;
    }

    if (typeof value !== "object") {
      console.log('Expected value to be an object');
      return;
    }

    for (var prop in value) {
      if (typeof value[prop] === 'string') {
        value[prop] = value[prop].substring(0, MAX_FIELD_LENGTH);
      }
    }

    window.newrelic.addPageAction(actionName, value);
  },

  /**
   * Sets an attribute that will be included on any subsequent generated events
   */
  setCustomAttribute: function setCustomAttribute(key, value) {
    if (!window.newrelic) {
      return;
    }

    window.newrelic.setCustomAttribute(key, value);
  }
};

},{}],"/home/ubuntu/staging/apps/build/js/feedback.js":[function(require,module,exports){
/* global trackEvent, appOptions */

// NOTE: These must be kept in sync with activity_hint.rb in dashboard.
'use strict';

var HINT_REQUEST_PLACEMENT = {
  NONE: 0, // This value must not be changed.
  LEFT: 1, // Hint request button is on left.
  RIGHT: 2 // Hint request button is on right.
};

/**
 * Bag of utility functions related to building and displaying feedback
 * to students.
 * @class
 * @param {StudioApp} studioApp A studioApp instance used to pull
 *   configuration and perform operations.
 */
var FeedbackUtils = function FeedbackUtils(studioApp) {
  this.studioApp_ = studioApp;
};
module.exports = FeedbackUtils;

// Globals used in this file:
//   Blockly

var trophy = require('./templates/trophy.html.ejs');
var utils = require('./utils');
var _ = utils.getLodash();
var codegen = require('./codegen');
var msg = require('./locale');
var dom = require('./dom');
var xml = require('./xml');
var FeedbackBlocks = require('./feedbackBlocks');
var constants = require('./constants');
var TestResults = constants.TestResults;
var KeyCodes = constants.KeyCodes;
var puzzleRatingUtils = require('./puzzleRatingUtils');

/**
 * @typedef {Object} TestableBlock
 * @property {string|function} test - A test whether the block is
 *           present, either:
 *           - A string, in which case the string is searched for in
 *             the generated code.
 *           - A single-argument function is called on each user-added
 *             block individually.  If any call returns true, the block
 *             is deemed present.  "User-added" blocks are ones that are
 *             neither disabled or undeletable.
 * @property {string} type - The type of block to be produced for
 *           display to the user if the test failed.
 * @property {Object} [titles] - A dictionary, where, for each
 *           KEY-VALUE pair, this is added to the block definition:
 *           <title name="KEY">VALUE</title>.
 * @property {Object} [value] - A dictionary, where, for each
 *           KEY-VALUE pair, this is added to the block definition:
 *           <value name="KEY">VALUE</value>
 * @property {string} [extra] - A string that should be blacked
 *           between the "block" start and end tags.
 */

/**
 * @param {Object} options
 * @param {!TestableBlock[]} requiredBlocks The blocks that are required to be used in
 *   the solution to this level.
 * @param {number} maxRequiredBlocksToFlag The number of required blocks to
 *   give hints about at any one time.  Set this to Infinity to show all.
 * @param {!TestableBlock[]} recommendedBlocks The blocks that are recommended to be used in
 *   the solution to this level.
 * @param {number} maxRecommendedBlocksToFlag The number of recommended blocks to
 *   give hints about at any one time.  Set this to Infinity to show all.
 */
FeedbackUtils.prototype.displayFeedback = function (options, requiredBlocks, maxRequiredBlocksToFlag, recommendedBlocks, maxRecommendedBlocksToFlag) {

  options.level = options.level || {};
  options.numTrophies = this.numTrophiesEarned_(options);

  // Tracking event for level newly completed
  if (options.response && options.response.new_level_completed) {
    trackEvent('Puzzle', 'Completed', options.response.level_path, options.response.level_attempts);
  }

  var hadShareFailure = options.response && options.response.share_failure;
  // options.response.level_source is the url that we are sharing; can't
  // share without it
  var canShare = options.response && options.response.level_source;
  var showingSharing = options.showingSharing && !hadShareFailure && canShare;

  var canContinue = this.canContinueToNextLevel(options.feedbackType);
  var displayShowCode = this.studioApp_.enableShowCode && this.studioApp_.enableShowLinesCount && canContinue && !showingSharing;
  var feedback = document.createElement('div');
  var sharingDiv = canContinue && showingSharing ? this.createSharingDiv(options) : null;
  var showCode = displayShowCode ? this.getShowCodeElement_(options) : null;
  var shareFailureDiv = hadShareFailure ? this.getShareFailure_(options) : null;
  if (hadShareFailure) {
    trackEvent('Share', 'Failure', options.response.share_failure.type);
  }
  var feedbackBlocks;
  if (this.studioApp_.isUsingBlockly()) {
    feedbackBlocks = new FeedbackBlocks(options, this.getMissingBlocks_(requiredBlocks, maxRequiredBlocksToFlag), this.getMissingBlocks_(recommendedBlocks, maxRecommendedBlocksToFlag), this.studioApp_);
  }
  // feedbackMessage must be initialized after feedbackBlocks
  // because FeedbackBlocks can mutate options.response.hint.
  var feedbackMessage = this.getFeedbackMessage_(options);

  if (feedbackMessage) {
    feedback.appendChild(feedbackMessage);
  }
  if (options.numTrophies) {
    // Tracking event for new trophy earned
    if (options.numTrophies > 0) {
      for (var i = 0; i < options.numTrophies; i++) {
        var concept_name = options.response.trophy_updates[i][0];
        var trophy_name = options.response.trophy_updates[i][1];
        trackEvent('Trophy', concept_name, trophy_name);
      }
    }
    var trophies = this.getTrophiesElement_(options);
    feedback.appendChild(trophies);
  }
  if (feedbackBlocks && feedbackBlocks.div) {
    if (feedbackMessage && this.useSpecialFeedbackDesign_(options)) {
      // put the blocks iframe inside the feedbackMessage for this special case:
      feedbackMessage.appendChild(feedbackBlocks.div);
    } else {
      feedback.appendChild(feedbackBlocks.div);
    }
  }
  if (sharingDiv) {
    feedback.appendChild(sharingDiv);
  }
  if (showingSharing) {
    var shareCodeSpacer = document.createElement('div');
    shareCodeSpacer.className = "share-code-spacer";
    feedback.appendChild(shareCodeSpacer);
  }
  if (shareFailureDiv) {
    feedback.appendChild(shareFailureDiv);
  }
  if (showCode) {
    feedback.appendChild(showCode);
  }
  if (options.level.isK1) {
    feedback.className += " k1";
  }
  if (options.appDiv) {
    feedback.appendChild(options.appDiv);
  }

  feedback.className += canContinue ? " win-feedback" : " failure-feedback";

  var finalLevel = options.response && options.response.message === "no more levels";

  feedback.appendChild(this.getFeedbackButtons_({
    feedbackType: options.feedbackType,
    tryAgainText: options.tryAgainText,
    keepPlayingText: options.keepPlayingText,
    continueText: options.continueText,
    showPreviousButton: options.level.showPreviousLevelButton,
    isK1: options.level.isK1,
    freePlay: options.level.freePlay,
    finalLevel: finalLevel
  }));

  var againButton = feedback.querySelector('#again-button');
  var hintRequestButton = feedback.querySelector('#hint-request-button');
  var previousLevelButton = feedback.querySelector('#back-button');
  var continueButton = feedback.querySelector('#continue-button');

  var onlyContinue = continueButton && !againButton && !previousLevelButton;

  // get the topmost missing recommended block, if it exists, to be
  // added to the queue of contextual hints. If the user views the block
  // in the dialog, mark it as seen and add it to the list as such.
  var missingRecommendedBlockHints = this.getMissingBlocks_(recommendedBlocks, 1).blocksToDisplay.map(function (block) {
    block.alreadySeen = false;
    return block;
  });
  var markContextualHintsAsSeen = function markContextualHintsAsSeen() {
    missingRecommendedBlockHints.filter(function (hint) {
      return feedbackBlocks && feedbackBlocks.xml && feedbackBlocks.xml.indexOf(hint.blockDisplayXML) > -1;
    }).forEach(function (hint) {
      hint.alreadySeen = true;
    });
  };

  var onHidden = onlyContinue ? options.onContinue : (function () {
    this.studioApp_.displayMissingBlockHints(missingRecommendedBlockHints);
  }).bind(this);

  var icon;
  if (!options.hideIcon) {
    icon = canContinue ? this.studioApp_.winIcon : this.studioApp_.failureIcon;
  }
  var defaultBtnSelector = onlyContinue ? '#continue-button' : '#again-button';

  var feedbackDialog = this.createModalDialog({
    Dialog: options.Dialog,
    contentDiv: feedback,
    icon: icon,
    defaultBtnSelector: defaultBtnSelector,
    onHidden: onHidden,
    id: 'feedback-dialog'
  });

  // Update the background color if it is set to be in special design.
  if (this.useSpecialFeedbackDesign_(options)) {
    if (options.response.design == "white_background") {
      document.getElementById('feedback-dialog').className += " white-background";
      document.getElementById('feedback-content').className += " light-yellow-background";
    }
  }

  if (againButton) {
    dom.addClickTouchEvent(againButton, function () {
      feedbackDialog.hide();
    });
  }

  if (previousLevelButton) {
    dom.addClickTouchEvent(previousLevelButton, function () {
      feedbackDialog.hide();
      options.backToPreviousLevel();
    });
  }

  // If there is a hint request button, hide the hint that would ordinarily
  // be shown (including any feedback blocks), and add code to restore the
  // hint if the button gets pressed.
  if (hintRequestButton) {

    var alreadySeen = options.response && options.response.hint_view_requests && options.response.hint_view_requests.some(function (request) {
      var requestMatchesFeedback = request.feedback_type === options.feedbackType;
      if (feedbackBlocks && feedbackBlocks.xml) {
        requestMatchesFeedback = requestMatchesFeedback && request.feedback_xml === feedbackBlocks.xml;
      }
      return requestMatchesFeedback;
    });

    if (alreadySeen) {
      // Remove "Show hint" button.  Making it invisible isn't enough,
      // because it will still take up space.
      hintRequestButton.parentNode.removeChild(hintRequestButton);

      // mark the corresponding block hint as seen
      markContextualHintsAsSeen();
    } else {

      // Generate a generic feedback message to display when we show the
      // feedback block
      var genericFeedback = this.getFeedbackMessage_({ message: msg.tryBlocksBelowFeedback() });

      // If there are feedback blocks, temporarily hide them.
      if (feedbackBlocks && feedbackBlocks.div) {
        feedbackBlocks.hide();
      }

      // If the user requests the hint...
      dom.addClickTouchEvent(hintRequestButton, function () {
        // mark the corresponding block hint as seen
        markContextualHintsAsSeen();

        // Swap out the specific feedback message with a generic one.
        var parentNode = feedbackMessage.parentNode;
        parentNode.replaceChild(genericFeedback, feedbackMessage);

        // Remove "Show hint" button.  Making it invisible isn't enough,
        // because it will still take up space.
        hintRequestButton.parentNode.removeChild(hintRequestButton);

        // Restore feedback blocks, if present.
        if (feedbackBlocks && feedbackBlocks.div) {
          feedbackBlocks.show();
        }

        // Report hint request to server.
        if (options.response.hint_view_request_url) {
          $.ajax({
            url: options.response.hint_view_request_url,
            type: 'POST',
            data: {
              script_id: options.response.script_id,
              level_id: options.response.level_id,
              feedback_type: options.feedbackType,
              feedback_xml: feedbackBlocks ? feedbackBlocks.xml : undefined
            }
          });
        }
      });
    }
  }

  if (continueButton) {

    if (options.response && options.response.puzzle_ratings_enabled) {
      feedback.appendChild(puzzleRatingUtils.buildPuzzleRatingButtons());
    }

    dom.addClickTouchEvent(continueButton, function () {
      feedbackDialog.hide();

      if (options.response && options.response.puzzle_ratings_enabled) {
        puzzleRatingUtils.cachePuzzleRating(feedback, {
          script_id: options.response.script_id,
          level_id: options.response.level_id
        });
      }

      // onContinue will fire already if there was only a continue button
      if (!onlyContinue) {
        options.onContinue();
      }
    });
  }

  // set up the Save To Gallery button if necessary
  var saveToGalleryButton = feedback.querySelector('#save-to-gallery-button');
  if (saveToGalleryButton && options.response && options.response.save_to_gallery_url) {
    dom.addClickTouchEvent(saveToGalleryButton, function () {
      $.post(options.response.save_to_gallery_url, function () {
        $('#save-to-gallery-button').prop('disabled', true).text("Saved!");
      });
    });
  }

  function createHiddenPrintWindow(src) {
    var iframe = $('<iframe id="print_frame" style="display: none"></iframe>'); // Created a hidden iframe with just the desired image as its contents
    iframe.appendTo("body");
    iframe[0].contentWindow.document.write("<img src='" + src + "'/>");
    iframe[0].contentWindow.document.write("<script>if (document.execCommand('print', false, null)) {  } else { window.print();  } </script>");
    $("#print_frame").remove(); // Remove the iframe when the print dialogue has been launched
  }

  var printButton = feedback.querySelector('#print-button');
  if (printButton) {
    dom.addClickTouchEvent(printButton, function () {
      createHiddenPrintWindow(options.feedbackImage);
    });
  }

  feedbackDialog.show({
    backdrop: options.app === 'flappy' ? 'static' : true
  });

  if (feedbackBlocks && feedbackBlocks.div) {
    feedbackBlocks.render();
  }
};

/**
 * Counts the number of blocks used.  Blocks are only counted if they are
 * not disabled, are deletable.
 * @return {number} Number of blocks used.
 */
FeedbackUtils.prototype.getNumBlocksUsed = function () {
  var i;
  if (this.studioApp_.editCode) {
    var codeLines = 0;
    // quick and dirty method to count non-blank lines that don't start with //
    var lines = this.getGeneratedCodeString_().split("\n");
    for (i = 0; i < lines.length; i++) {
      if (lines[i].length > 1 && (lines[i][0] != '/' || lines[i][1] != '/')) {
        codeLines++;
      }
    }
    return codeLines;
  }
  return this.getUserBlocks_().length;
};

/**
 * Counts the total number of blocks. Blocks are only counted if they are
 * not disabled.
 * @return {number} Total number of blocks.
 */
FeedbackUtils.prototype.getNumCountableBlocks = function () {
  var i;
  if (this.studioApp_.editCode) {
    var codeLines = 0;
    // quick and dirty method to count non-blank lines that don't start with //
    var lines = this.getGeneratedCodeString_().split("\n");
    for (i = 0; i < lines.length; i++) {
      if (lines[i].length > 1 && (lines[i][0] != '/' || lines[i][1] != '/')) {
        codeLines++;
      }
    }
    return codeLines;
  }
  return this.getCountableBlocks_().length;
};

/**
 *
 */
FeedbackUtils.prototype.getFeedbackButtons_ = function (options) {
  var buttons = document.createElement('div');
  buttons.id = 'feedbackButtons';

  var tryAgainText = '';
  if (options.feedbackType !== TestResults.ALL_PASS) {
    tryAgainText = utils.valueOr(options.tryAgainText, msg.tryAgain());
  }
  if (options.keepPlayingText) {
    tryAgainText = options.keepPlayingText;
  }

  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      previousLevel: !this.canContinueToNextLevel(options.feedbackType) && options.showPreviousButton,
      tryAgain: tryAgainText,
      continueText: options.continueText || (options.finalLevel ? msg.finish() : msg['continue']()),
      nextLevel: this.canContinueToNextLevel(options.feedbackType),
      shouldPromptForHint: this.shouldPromptForHint(options.feedbackType),
      isK1: options.isK1,
      assetUrl: this.studioApp_.assetUrl,
      freePlay: options.freePlay
    }
  });

  return buttons;
};

/**
 *
 */
FeedbackUtils.prototype.getShareFailure_ = function (options) {
  var shareFailure = options.response.share_failure;
  var shareFailureDiv = document.createElement('div');
  shareFailureDiv.innerHTML = require('./templates/shareFailure.html.ejs')({ shareFailure: shareFailure });
  return shareFailureDiv;
};

/**
 *
 */
FeedbackUtils.prototype.useSpecialFeedbackDesign_ = function (options) {
  return options.response && options.response.design && options.response.hint;
};

// This returns a document element with the appropriate feedback message.
// The message will be one of the following, from highest to lowest precedence:
// 0. Failure override message specified on level (options.level.failureMessageOverride)
// 1. Message passed in by caller (options.message).
// 2. Message from dashboard database (options.response.hint).
// 3. Header message due to dashboard text check fail (options.response.share_failure).
// 4. Level-specific message (e.g., options.level.emptyBlocksErrorMsg) for
//    specific result type (e.g., TestResults.EMPTY_BLOCK_FAIL).
// 5. System-wide message (e.g., msg.emptyBlocksErrorMsg()) for specific
//    result type (e.g., TestResults.EMPTY_BLOCK_FAIL).
FeedbackUtils.prototype.getFeedbackMessage_ = function (options) {
  var feedback = document.createElement('p');
  feedback.className = 'congrats';
  var message;

  // If a message was explicitly passed in, use that.
  if (options.feedbackType !== TestResults.ALL_PASS && options.level && options.level.failureMessageOverride) {
    message = options.level.failureMessageOverride;
  } else if (options.message) {
    message = options.message;
  } else if (options.response && options.response.share_failure) {
    message = msg.shareFailure();
  } else if (options.response && options.response.hint) {
    // Otherwise, if there's a dashboard database hint, use that.
    message = options.response.hint;
  } else {
    // Otherwise, the message will depend on the test result.
    switch (options.feedbackType) {
      case TestResults.RUNTIME_ERROR_FAIL:
        message = msg.runtimeErrorMsg({ lineNumber: options.executionError.lineNumber });
        break;
      case TestResults.SYNTAX_ERROR_FAIL:
        message = msg.syntaxErrorMsg({ lineNumber: options.executionError.lineNumber });
        break;
      case TestResults.EMPTY_BLOCK_FAIL:
        message = options.level.emptyBlocksErrorMsg || msg.emptyBlocksErrorMsg();
        break;
      case TestResults.EMPTY_FUNCTION_BLOCK_FAIL:
        if (options.level.emptyFunctionBlocksErrorMsg) {
          message = options.level.emptyFunctionBlocksErrorMsg;
        } else if (Blockly.useContractEditor || Blockly.useModalFunctionEditor) {
          message = msg.errorEmptyFunctionBlockModal();
        } else {
          message = msg.emptyFunctionBlocksErrorMsg();
        }
        break;
      case TestResults.TOO_FEW_BLOCKS_FAIL:
        message = options.level.tooFewBlocksMsg || msg.tooFewBlocksMsg();
        break;
      case TestResults.LEVEL_INCOMPLETE_FAIL:
        message = options.level.levelIncompleteError || msg.levelIncompleteError();
        break;
      case TestResults.EXTRA_TOP_BLOCKS_FAIL:
        var hasWhenRun = Blockly.mainBlockSpace.getTopBlocks().some(function (block) {
          return block.type === 'when_run' && block.isUserVisible();
        });

        var defaultMessage = hasWhenRun ? msg.extraTopBlocksWhenRun() : msg.extraTopBlocks();
        message = options.level.extraTopBlocks || defaultMessage;
        break;
      case TestResults.APP_SPECIFIC_FAIL:
        message = options.level.appSpecificFailError;
        break;
      case TestResults.UNUSED_PARAM:
        message = msg.errorUnusedParam();
        break;
      case TestResults.UNUSED_FUNCTION:
        message = msg.errorUnusedFunction();
        break;
      case TestResults.PARAM_INPUT_UNATTACHED:
        message = msg.errorParamInputUnattached();
        break;
      case TestResults.INCOMPLETE_BLOCK_IN_FUNCTION:
        message = msg.errorIncompleteBlockInFunction();
        break;
      case TestResults.QUESTION_MARKS_IN_NUMBER_FIELD:
        message = msg.errorQuestionMarksInNumberField();
        break;
      case TestResults.TOO_MANY_BLOCKS_FAIL:
        // Allow apps to override the "too many blocks" failure message
        // Passed as a msg function to allow the parameters to be passed in.
        var messageFunction = options.appStrings && options.appStrings.tooManyBlocksFailMsgFunction || msg.numBlocksNeeded;
        message = messageFunction({
          numBlocks: this.studioApp_.IDEAL_BLOCK_NUM,
          puzzleNumber: options.level.puzzle_number || 0
        });
        break;
      case TestResults.APP_SPECIFIC_ACCEPTABLE_FAIL:
        message = options.level.appSpecificAcceptableFailError;
        break;
      case TestResults.EDIT_BLOCKS:
        message = options.level.edit_blocks_success;
        break;
      case TestResults.MISSING_BLOCK_UNFINISHED:
      /* fallthrough */
      case TestResults.MISSING_BLOCK_FINISHED:
        message = options.level.missingRequiredBlocksErrorMsg || msg.missingRequiredBlocksErrorMsg();
        break;
      case TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED:
        message = msg.missingRecommendedBlocksErrorMsg();
        break;
      case TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED:
        var numEnabledBlocks = this.getNumCountableBlocks();
        if (this.studioApp_.IDEAL_BLOCK_NUM && numEnabledBlocks > this.studioApp_.IDEAL_BLOCK_NUM) {
          message = msg.numBlocksNeeded({
            numBlocks: this.studioApp_.IDEAL_BLOCK_NUM,
            puzzleNumber: options.level.puzzle_number || 0
          });
        } else {
          message = msg.completedWithoutRecommendedBlock({
            puzzleNumber: options.level.puzzle_number || 0
          });
        }
        break;
      case TestResults.NESTED_FOR_SAME_VARIABLE:
        message = msg.nestedForSameVariable();
        break;

      // Success.
      case TestResults.ALL_PASS:
      case TestResults.FREE_PLAY:
        var finalLevel = options.response && options.response.message === "no more levels";
        var stageCompleted = null;
        if (options.response && options.response.stage_changing) {
          stageCompleted = options.response.stage_changing.previous.name;
        }
        var msgParams = {
          numTrophies: options.numTrophies,
          stageNumber: 0, // TODO: remove once localized strings have been fixed
          stageName: stageCompleted,
          puzzleNumber: options.level.puzzle_number || 0
        };
        if (options.feedbackType === TestResults.FREE_PLAY && !options.level.disableSharing) {
          var reinfFeedbackMsg = options.appStrings && options.appStrings.reinfFeedbackMsg || '';

          if (options.level.disableFinalStageMessage) {
            message = reinfFeedbackMsg;
          } else {
            message = finalLevel ? msg.finalStage(msgParams) + ' ' : '';
            message = message + reinfFeedbackMsg;
          }
        } else if (options.numTrophies > 0) {
          message = finalLevel ? msg.finalStageTrophies(msgParams) : stageCompleted ? msg.nextStageTrophies(msgParams) : msg.nextLevelTrophies(msgParams);
        } else {
          var nextLevelMsg = options.appStrings && options.appStrings.nextLevelMsg || msg.nextLevel(msgParams);
          message = finalLevel ? msg.finalStage(msgParams) : stageCompleted ? msg.nextStage(msgParams) : nextLevelMsg;
        }
        break;
    }
  }

  $(feedback).text(message);

  // Update the feedback box design, if the hint message came from server.
  if (this.useSpecialFeedbackDesign_(options)) {
    // Setup a new div
    var feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'feedback-callout';
    feedbackDiv.id = 'feedback-content';

    // Insert an image
    var imageDiv = document.createElement('img');
    imageDiv.className = "hint-image";
    imageDiv.src = this.studioApp_.assetUrl('media/lightbulb_for_' + options.response.design + '.png');
    feedbackDiv.appendChild(imageDiv);
    // Add new text
    var hintHeader = document.createElement('p');
    $(hintHeader).text(msg.hintHeader());
    feedbackDiv.appendChild(hintHeader);
    hintHeader.className = 'hint-header';
    // Append the original text
    feedbackDiv.appendChild(feedback);
    return feedbackDiv;
  }
  return feedback;
};

/**
 *
 */
FeedbackUtils.prototype.createSharingDiv = function (options) {
  // TODO: this bypasses the config encapsulation to ensure we have the most up-to-date value.
  if (this.studioApp_.disableSocialShare || window.appOptions.disableSocialShare) {
    // Clear out our urls so that we don't display any of our social share links
    options.twitterUrl = undefined;
    options.facebookUrl = undefined;
    options.sendToPhone = false;
  } else {

    // set up the twitter share url
    var twitterUrl = "https://twitter.com/intent/tweet?url=" + options.response.level_source;

    if (options.twitter && options.twitter.text !== undefined) {
      twitterUrl += "&text=" + encodeURI(options.twitter.text);
    } else {
      twitterUrl += "&text=" + encodeURI(msg.defaultTwitterText() + " @codeorg");
    }

    if (options.twitter && options.twitter.hashtag !== undefined) {
      twitterUrl += "&hashtags=" + options.twitter.hashtag;
    } else {
      twitterUrl += "&hashtags=" + 'HourOfCode';
    }

    if (options.twitter && options.twitter.related !== undefined) {
      twitterUrl += "&related=" + options.twitter.related;
    } else {
      twitterUrl += "&related=codeorg";
    }

    options.twitterUrl = twitterUrl;

    // set up the facebook share url
    var facebookUrl = "https://www.facebook.com/sharer/sharer.php?u=" + options.response.level_source;
    options.facebookUrl = facebookUrl;
  }

  options.assetUrl = this.studioApp_.assetUrl;

  var sharingDiv = document.createElement('div');
  sharingDiv.setAttribute('id', 'sharing');
  sharingDiv.innerHTML = require('./templates/sharing.html.ejs')({
    options: options
  });

  // Note: We have a dependency on dashboard here. This dependency has always
  // been here (we used to mysteriously just always bubble clicks on body to
  // a.popup-window if it existed), but it is now more explicit
  if (window.dashboard && window.dashboard.popupWindow) {
    $(sharingDiv).find('a.popup-window').click(window.dashboard.popupWindow);
  }

  var sharingInput = sharingDiv.querySelector('#sharing-input');
  if (sharingInput) {
    dom.addClickTouchEvent(sharingInput, function () {
      sharingInput.focus();
      sharingInput.select();
      sharingInput.setSelectionRange(0, 9999);
    });
  }

  //  SMS-to-phone feature
  var sharingPhone = sharingDiv.querySelector('#sharing-phone');
  if (sharingPhone && options.sendToPhone) {
    dom.addClickTouchEvent(sharingPhone, function () {
      var sendToPhone = sharingDiv.querySelector('#send-to-phone');
      if ($(sendToPhone).is(':hidden')) {
        $(sendToPhone).show();
        var phone = $(sharingDiv.querySelector("#phone"));
        var submitted = false;
        var submitButton = sharingDiv.querySelector('#phone-submit');
        submitButton.disabled = true;
        phone.mask('(000) 000-0000', {
          onComplete: function onComplete() {
            if (!submitted) {
              submitButton.disabled = false;
            }
          },
          onChange: function onChange() {
            submitButton.disabled = true;
          }
        });
        phone.focus();
        dom.addClickTouchEvent(submitButton, function () {
          var phone = $(sharingDiv.querySelector("#phone"));
          var params = jQuery.param({
            level_source: options.response.level_source_id,
            phone: phone.val()
          });
          $(submitButton).val("Sending..");
          phone.prop('readonly', true);
          submitButton.disabled = true;
          submitted = true;
          jQuery.post(options.response.phone_share_url, params).done(function (response) {
            $(submitButton).text("Sent!");
            trackEvent("SendToPhone", "success");
          }).fail(function (xhr) {
            $(submitButton).text("Error!");
            trackEvent("SendToPhone", "error");
          });
        });
      } else {
        // not hidden, hide
        $(sendToPhone).hide();
      }
    });
  }

  return sharingDiv;
};

/**
 *
 */
FeedbackUtils.prototype.numTrophiesEarned_ = function (options) {
  if (options.response && options.response.trophy_updates) {
    return options.response.trophy_updates.length;
  } else {
    return 0;
  }
};

/**
 *
 */
FeedbackUtils.prototype.getTrophiesElement_ = function (options) {
  var html = "";
  for (var i = 0; i < options.numTrophies; i++) {
    html += trophy({
      img_url: options.response.trophy_updates[i][2],
      concept_name: options.response.trophy_updates[i][0]
    });
  }
  var trophies = document.createElement('div');
  trophies.innerHTML = html;
  return trophies;
};

/**
 *
 */
FeedbackUtils.prototype.getShowCodeElement_ = function (options) {
  var showCodeDiv = document.createElement('div');
  showCodeDiv.setAttribute('id', 'show-code');

  var numLinesWritten = this.getNumBlocksUsed();
  var shouldShowTotalLines = options.response && options.response.total_lines && options.response.total_lines !== numLinesWritten;
  var totalNumLinesWritten = shouldShowTotalLines ? options.response.total_lines : 0;

  showCodeDiv.innerHTML = require('./templates/showCode.html.ejs')({
    numLinesWritten: numLinesWritten,
    totalNumLinesWritten: totalNumLinesWritten
  });

  var showCodeButton = showCodeDiv.querySelector('#show-code-button');
  showCodeButton.addEventListener('click', _.bind(function () {
    var generatedCodeElement = this.getGeneratedCodeElement_({
      generatedCodeDescription: options.appStrings && options.appStrings.generatedCodeDescription
    });
    showCodeDiv.appendChild(generatedCodeElement);
    showCodeButton.style.display = 'none';
  }, this));

  return showCodeDiv;
};

/**
 * Determines whether the user can proceed to the next level, based on the level feedback
 * @param {number} feedbackType A constant property of TestResults,
 *     typically produced by StudioApp.getTestResults().
 */
FeedbackUtils.prototype.canContinueToNextLevel = function (feedbackType) {
  return feedbackType === TestResults.ALL_PASS || feedbackType === TestResults.TOO_MANY_BLOCKS_FAIL || feedbackType === TestResults.APP_SPECIFIC_ACCEPTABLE_FAIL || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED || feedbackType === TestResults.FREE_PLAY;
};

/**
 * Determines whether we should prompt the user to show the given
 * feedback, rather than showing it to them automatically. Currently
 * only used for missing block feedback; may expand in the future
 * @param {number} feedbackType A constant property of TestResults,
 *     typically produced by StudioApp.getTestResults().
 */
FeedbackUtils.prototype.shouldPromptForHint = function (feedbackType) {
  return feedbackType === TestResults.MISSING_BLOCK_UNFINISHED || feedbackType === TestResults.MISSING_BLOCK_FINISHED || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED || feedbackType === TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED;
};

/**
 * Retrieve a string containing the user's generated Javascript code.
 */
FeedbackUtils.prototype.getGeneratedCodeString_ = function () {
  if (this.studioApp_.editCode) {
    return this.studioApp_.editor ? this.studioApp_.editor.getValue() : '';
  } else {
    return codegen.workspaceCode(Blockly);
  }
};

/**
 * Generates a "show code" div with a description of what code is.
 * @param {Object} [options] - optional
 * @param {string} [options.generatedCodeDescription] - optional description
 *        of code to put in place instead of the default
 * @returns {Element}
 * @private
 */
FeedbackUtils.prototype.getGeneratedCodeElement_ = function (options) {
  options = options || {};

  var codeInfoMsgParams = {
    berkeleyLink: "<a href='http://bjc.berkeley.edu/' target='_blank'>Berkeley</a>",
    harvardLink: "<a href='https://cs50.harvard.edu/' target='_blank'>Harvard</a>"
  };

  var infoMessage = this.getGeneratedCodeDescription(codeInfoMsgParams, options.generatedCodeDescription);
  var code = this.studioApp_.polishGeneratedCodeString(this.getGeneratedCodeString_());

  var codeDiv = document.createElement('div');
  codeDiv.innerHTML = require('./templates/code.html.ejs')({
    message: infoMessage,
    code: code
  });

  return codeDiv;
};

/**
 * Generates explanation of what code is.
 * @param {Object} codeInfoMsgParams - params for generatedCodeInfo msg function
 * @param {String} [generatedCodeDescription] - optional description to use
 *        instead of the default
 * @returns {string}
 */
FeedbackUtils.prototype.getGeneratedCodeDescription = function (codeInfoMsgParams, generatedCodeDescription) {
  if (this.studioApp_.editCode) {
    return '';
  }

  if (generatedCodeDescription) {
    return generatedCodeDescription;
  }

  return msg.generatedCodeInfo(codeInfoMsgParams);
};

/**
 * Display the 'Show Code' modal dialog.
 * @param {Dialog} Dialog
 * @param {Object} [appStrings] - optional app strings to override
 * @param {string} [appStrings.generatedCodeDescription] - string
 *        to display instead of the usual show code description
 */
FeedbackUtils.prototype.showGeneratedCode = function (Dialog, appStrings) {
  var codeDiv = this.getGeneratedCodeElement_({
    generatedCodeDescription: appStrings && appStrings.generatedCodeDescription
  });

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });
  codeDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: codeDiv,
    icon: this.studioApp_.icon,
    defaultBtnSelector: '#ok-button'
  });

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, function () {
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 * Display the "Clear Puzzle" confirmation dialog.  Takes a parameter to hide
 * the icon.  Calls `callback` if the user confirms they want to clear the puzzle.
 */
FeedbackUtils.prototype.showClearPuzzleConfirmation = function (Dialog, hideIcon, callback) {
  this.showSimpleDialog(Dialog, {
    headerText: msg.clearPuzzleConfirmHeader(),
    bodyText: msg.clearPuzzleConfirm(),
    confirmText: msg.clearPuzzle(),
    cancelText: msg.dialogCancel(),
    onConfirm: callback,
    onCancel: null,
    hideIcon: hideIcon
  });
};

/**
 * Shows a simple dialog that has a header, body, continue button, and cancel
 * button
 * @param {object} options Configurable options.
 * @param {string} headerText Text for header portion
 * @param {string} bodyText Text for body portion
 * @param {string} cancelText Text for cancel button
 * @param {string} confirmText Text for confirm button
 * @param {boolean} hideIcon Whether to hide the icon
 * @param {function} [onConfirm] Function to be called after clicking confirm
 * @param {function} [onCancel] Function to be called after clicking cancel
 */
FeedbackUtils.prototype.showSimpleDialog = function (Dialog, options) {
  var contentDiv = document.createElement('div');
  contentDiv.innerHTML = '';
  if (options.headerText) {
    contentDiv.innerHTML += '<p class="dialog-title">' + options.headerText + '</p>';
  }
  if (options.bodyText) {
    contentDiv.innerHTML += '<p>' + options.bodyText + '</p>';
  }

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      confirmText: options.confirmText,
      cancelText: options.cancelText,
      cancelButtonClass: options.cancelButtonClass
    }
  });
  contentDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: contentDiv,
    icon: options.hideIcon ? null : this.studioApp_.icon,
    defaultBtnSelector: '#again-button'
  });

  var cancelButton = buttons.querySelector('#again-button');
  if (cancelButton) {
    dom.addClickTouchEvent(cancelButton, function () {
      if (options.onCancel) {
        options.onCancel();
      }
      dialog.hide();
    });
  }

  var confirmButton = buttons.querySelector('#confirm-button');
  if (confirmButton) {
    dom.addClickTouchEvent(confirmButton, function () {
      if (options.onConfirm) {
        options.onConfirm();
      }
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 *
 */
FeedbackUtils.prototype.showToggleBlocksError = function (Dialog) {
  var contentDiv = document.createElement('div');
  contentDiv.innerHTML = msg.toggleBlocksErrorMsg();

  var buttons = document.createElement('div');
  buttons.innerHTML = require('./templates/buttons.html.ejs')({
    data: {
      ok: true
    }
  });
  contentDiv.appendChild(buttons);

  var dialog = this.createModalDialog({
    Dialog: Dialog,
    contentDiv: contentDiv,
    icon: this.studioApp_.icon,
    defaultBtnSelector: '#ok-button'
  });

  var okayButton = buttons.querySelector('#ok-button');
  if (okayButton) {
    dom.addClickTouchEvent(okayButton, function () {
      dialog.hide();
    });
  }

  dialog.show();
};

/**
 * Get an empty container block, if any are present.
 * @return {Blockly.Block} an empty container block, or null if none exist.
 */
FeedbackUtils.prototype.getEmptyContainerBlock_ = function () {
  var blocks = Blockly.mainBlockSpace.getAllBlocks();
  return Blockly.findEmptyContainerBlock(blocks);
};

/**
 * Check for empty container blocks, and return an appropriate failure
 * code if any are found.
 * @return {TestResults} ALL_PASS if no empty blocks are present, or
 *   EMPTY_BLOCK_FAIL or EMPTY_FUNCTION_BLOCK_FAIL if empty blocks
 *   are found.
 */
FeedbackUtils.prototype.checkForEmptyContainerBlockFailure_ = function () {
  var emptyBlock = this.getEmptyContainerBlock_();
  if (!emptyBlock) {
    return TestResults.ALL_PASS;
  }

  var type = emptyBlock.type;
  if (type === 'procedures_defnoreturn' || type === 'procedures_defreturn') {
    return TestResults.EMPTY_FUNCTION_BLOCK_FAIL;
  }

  // Block is assumed to be "if" or "repeat" if we reach here.
  // This is where to add checks if you want a different TestResult
  // for "controls_for_counter" blocks, for example.
  return TestResults.EMPTY_BLOCK_FAIL;
};

/**
 * Throws errors with descriptive messages when example call or result blocks
 * don't exist or have unfilled functional inputs.
 * @param {Blockly.Block} callBlock
 * @param {Blockly.Block} resultBlock
 */
FeedbackUtils.prototype.throwOnInvalidExampleBlocks = function (callBlock, resultBlock) {
  if (!callBlock) {
    throw new Error('Invalid Call Block');
  }

  if (!resultBlock) {
    throw new Error('Invalid Result Block');
  }

  if (resultBlock.hasUnfilledFunctionalInput()) {
    throw new Error('Result has unfilled inputs');
  }

  if (callBlock.hasUnfilledFunctionalInput()) {
    throw new Error('Call has unfilled inputs');
  }
};

/**
 * Check whether the user code has all the given blocks
 * @param {!TestableBlock[]} blocks
 * @return {boolean} true if all blocks are present, false otherwise.
 */
FeedbackUtils.prototype.hasAllBlocks_ = function (blocks) {
  // It's okay (maybe faster) to pass 1 for maxBlocksToFlag, since in the end
  // we want to check that there are zero blocks missing.
  var maxBlocksToFlag = 1;
  return this.getMissingBlocks_(blocks, maxBlocksToFlag).blocksToDisplay.length === 0;
};

/**
 * Get blocks that the user intends in the program. These are the blocks
 * that are used when checking for required and recommended blocks and
 * when determining lines of code written.
 * @return {Array<Object>} The blocks.
 */
FeedbackUtils.prototype.getUserBlocks_ = function () {
  var allBlocks = Blockly.mainBlockSpace.getAllBlocks();
  var blocks = allBlocks.filter(function (block) {
    var blockValid = !block.disabled && block.type !== 'when_run';
    // If Blockly is in readOnly mode, then all blocks are uneditable
    // so this filter would be useless. Ignore uneditable blocks only if
    // Blockly is in edit mode.
    if (!Blockly.mainBlockSpace.isReadOnly()) {
      blockValid = blockValid && block.isEditable();
    }
    return blockValid;
  });
  return blocks;
};

/**
 * Get countable blocks in the program, namely any that are not disabled.
 * These are used when determined the number of blocks relative to the ideal
 * block count.
 * @return {Array<Object>} The blocks.
 */
FeedbackUtils.prototype.getCountableBlocks_ = function () {
  var allBlocks = Blockly.mainBlockSpace.getAllBlocks();
  var blocks = allBlocks.filter(function (block) {
    return !block.disabled;
  });
  return blocks;
};

/**
 * Check to see if the user's code contains the given blocks for a level.
 * @param {!TestableBlock[]} blocks
 * @param {number} maxBlocksToFlag The maximum number of blocks to
 *   return. We most often only care about a single block at a time
 * @return {{blocksToDisplay:!Array, message:?string}} 'missingBlocks' is an
 *   array of array of strings where each array of strings is a set of blocks
 *   that at least one of them should be used. Each block is represented as the
 *   prefix of an id in the corresponding template.soy. 'message' is an
 *   optional message to override the default error text.
 */
FeedbackUtils.prototype.getMissingBlocks_ = function (blocks, maxBlocksToFlag) {
  var missingBlocks = [];
  var customMessage = null;
  var code = null; // JavaScript code, which is initialized lazily.
  if (blocks && blocks.length) {
    var userBlocks = this.getUserBlocks_();
    // For each list of blocks
    // Keep track of the number of the missing block lists. It should not be
    // bigger than the maxBlocksToFlag param.
    var missingBlockNum = 0;
    for (var i = 0; i < blocks.length && missingBlockNum < maxBlocksToFlag; i++) {
      var block = blocks[i];
      // For each of the test
      // If at least one of the tests succeeded, we consider the block
      // is used
      var usedBlock = false;
      for (var testId = 0; testId < block.length; testId++) {
        var test = block[testId].test;
        if (typeof test === 'string') {
          code = code || Blockly.Generator.blockSpaceToCode('JavaScript');
          if (code.indexOf(test) !== -1) {
            // Succeeded, moving to the next list of tests
            usedBlock = true;
            break;
          }
        } else if (typeof test === 'function') {
          if (userBlocks.some(test)) {
            // Succeeded, moving to the next list of tests
            usedBlock = true;
            break;
          } else {
            customMessage = block[testId].message || customMessage;
          }
        } else {
          throw new Error('Bad test: ' + test);
        }
      }
      if (!usedBlock) {
        missingBlockNum++;
        missingBlocks = missingBlocks.concat(blocks[i][0]);
      }
    }
  }
  return {
    blocksToDisplay: missingBlocks,
    message: customMessage
  };
};

/**
 * Do we have any floating blocks not attached to an event block or function block?
 */
FeedbackUtils.prototype.hasExtraTopBlocks = function () {
  if (this.studioApp_.editCode) {
    return false;
  }
  var topBlocks = Blockly.mainBlockSpace.getTopBlocks();
  for (var i = 0; i < topBlocks.length; i++) {
    // ignore disabled top blocks. we have a level turtle:2_7 that depends on
    // having disabled top level blocks
    if (topBlocks[i].disabled) {
      continue;
    }
    // Ignore top blocks which are functional definitions.
    if (topBlocks[i].type === 'functional_definition') {
      continue;
    }
    // None of our top level blocks should have a previous or output connection
    // (they should only have a next)
    if (topBlocks[i].previousConnection || topBlocks[i].outputConnection) {
      return true;
    }
  }
  return false;
};

/**
 * Runs the tests and returns results.
 * @param {boolean} levelComplete Did the user successfully complete the level?
 * @param {!TestableBlock[]} requiredBlocks The blocks that are required
 *   to be used in the solution to this level.
 * @param {!TestableBlock[]} recommendedBlocks The blocks that are
 *   recommended to be used in the solution to this level.
 * @param {boolean} shouldCheckForEmptyBlocks Whether empty blocks should cause
 *   a test fail result.
 * @param {Object} options
 * @return {number} The appropriate property of TestResults.
 */
FeedbackUtils.prototype.getTestResults = function (levelComplete, requiredBlocks, recommendedBlocks, shouldCheckForEmptyBlocks, options) {
  options = options || {};
  if (this.studioApp_.editCode) {
    if (levelComplete) {
      return this.studioApp_.TestResults.ALL_PASS;
    } else if (options.executionError && options.executionError.err instanceof SyntaxError) {
      return this.studioApp_.TestResults.SYNTAX_ERROR_FAIL;
    } else if (options.executionError) {
      return this.studioApp_.TestResults.RUNTIME_ERROR_FAIL;
    } else {
      return this.studioApp_.TestResults.TOO_FEW_BLOCKS_FAIL;
    }
  }
  if (shouldCheckForEmptyBlocks) {
    var emptyBlockFailure = this.checkForEmptyContainerBlockFailure_();
    if (emptyBlockFailure !== TestResults.ALL_PASS) {
      return emptyBlockFailure;
    }
  }
  if (!options.allowTopBlocks && this.hasExtraTopBlocks()) {
    return TestResults.EXTRA_TOP_BLOCKS_FAIL;
  }
  if (this.studioApp_.hasDuplicateVariablesInForLoops()) {
    return TestResults.NESTED_FOR_SAME_VARIABLE;
  }
  if (Blockly.useContractEditor || Blockly.useModalFunctionEditor) {
    if (this.hasUnusedParam_()) {
      return TestResults.UNUSED_PARAM;
    }
    if (this.hasUnusedFunction_()) {
      return TestResults.UNUSED_FUNCTION;
    }
    if (this.hasParamInputUnattached_()) {
      return TestResults.PARAM_INPUT_UNATTACHED;
    }
    if (this.hasIncompleteBlockInFunction_()) {
      return TestResults.INCOMPLETE_BLOCK_IN_FUNCTION;
    }
  }
  if (this.hasQuestionMarksInNumberField()) {
    return TestResults.QUESTION_MARKS_IN_NUMBER_FIELD;
  }
  if (!this.hasAllBlocks_(requiredBlocks)) {
    return levelComplete ? TestResults.MISSING_BLOCK_FINISHED : TestResults.MISSING_BLOCK_UNFINISHED;
  }
  if (!this.hasAllBlocks_(recommendedBlocks)) {
    return levelComplete ? TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED : TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED;
  }
  var numEnabledBlocks = this.getNumCountableBlocks();
  if (!levelComplete) {
    if (this.studioApp_.IDEAL_BLOCK_NUM && this.studioApp_.IDEAL_BLOCK_NUM !== Infinity && numEnabledBlocks < this.studioApp_.IDEAL_BLOCK_NUM) {
      return TestResults.TOO_FEW_BLOCKS_FAIL;
    }
    return TestResults.LEVEL_INCOMPLETE_FAIL;
  }
  if (this.studioApp_.IDEAL_BLOCK_NUM && numEnabledBlocks > this.studioApp_.IDEAL_BLOCK_NUM) {
    return TestResults.TOO_MANY_BLOCKS_FAIL;
  } else {
    return TestResults.ALL_PASS;
  }
};

/**
 * Show a modal dialog without an icon.
 * @param {Object} options
 * @param {Dialog} options.Dialog
 * @param {string} options.icon
 * @param {HTMLElement} options.contentDiv
 * @param {string} options.defaultBtnSelector
 * @param {boolean} options.markdownMode
 * @param {boolean} options.scrollContent
 * @param {boolean} options.scrollableSelector
 * @param {function} options.onHidden
 * @param {string} options.id
 * @param {HTMLElement} options.header
 */
FeedbackUtils.prototype.createModalDialog = function (options) {
  var modalBody = document.createElement('div');
  if (options.icon) {
    var imageDiv;
    imageDiv = document.createElement('img');
    imageDiv.className = "modal-image";
    imageDiv.src = options.icon;
    modalBody.appendChild(imageDiv);
  } else {
    options.contentDiv.className += ' no-modal-icon';
  }

  if (options.markdownMode) {
    modalBody.className += ' markdown';
  }

  options.contentDiv.className += ' modal-content';
  modalBody.appendChild(options.contentDiv);

  var btn = options.contentDiv.querySelector(options.defaultBtnSelector);
  var keydownHandler = function keydownHandler(e) {
    if (e.keyCode == KeyCodes.ENTER || e.keyCode == KeyCodes.SPACE) {
      // Simulate a 'click':
      var event = new MouseEvent('click', {
        'view': window,
        'bubbles': true,
        'cancelable': true
      });
      btn.dispatchEvent(event);

      e.stopPropagation();
      e.preventDefault();
    }
  };

  var scrollableSelector = options.scrollableSelector || '.modal-content';
  var elementToScroll = options.scrollContent ? scrollableSelector : null;
  return new options.Dialog({
    body: modalBody,
    onHidden: options.onHidden,
    onKeydown: btn ? keydownHandler : undefined,
    autoResizeScrollableElement: elementToScroll,
    id: options.id,
    header: options.header
  });
};

/**
 * Check for '???' instead of a value in block fields.
 */
FeedbackUtils.prototype.hasQuestionMarksInNumberField = function () {
  return Blockly.mainBlockSpace.getAllBlocks().some(function (block) {
    return block.getTitles().some(function (title) {
      return title.value_ === '???' || title.text_ === '???';
    });
  });
};

/**
 * Ensure that all procedure definitions actually use the parameters they define
 * inside the procedure.
 */
FeedbackUtils.prototype.hasUnusedParam_ = function () {
  var self = this;
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    var params = userBlock.parameterNames_;
    // Only search procedure definitions
    return params && params.some(function (paramName) {
      // Unused param if there's no parameters_get descendant with the same name
      return !self.hasMatchingDescendant_(userBlock, function (block) {
        return (block.type === 'parameters_get' || block.type === 'functional_parameters_get' || block.type === 'variables_get') && block.getTitleValue('VAR') === paramName;
      });
    });
  });
};

/**
 * Ensure that all procedure calls have each parameter input connected.
 */
FeedbackUtils.prototype.hasParamInputUnattached_ = function () {
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    // Only check procedure_call* blocks
    if (!/^procedures_call/.test(userBlock.type)) {
      return false;
    }
    return userBlock.inputList.filter(function (input) {
      return (/^ARG/.test(input.name)
      );
    }).some(function (argInput) {
      // Unattached param input if any ARG* connection target is null
      return !argInput.connection.targetConnection;
    });
  });
};

/**
 * Ensure that all user-declared procedures have associated call blocks.
 */
FeedbackUtils.prototype.hasUnusedFunction_ = function () {
  var userDefs = [];
  var callBlocks = {};
  Blockly.mainBlockSpace.getAllBlocks().forEach(function (block) {
    var name = block.getTitleValue('NAME');
    if (/^procedures_def/.test(block.type) && block.userCreated) {
      userDefs.push(name);
    } else if (/^procedures_call/.test(block.type)) {
      callBlocks[name] = true;
    }
  });
  // Unused function if some user def doesn't have a matching call
  return userDefs.some(function (name) {
    return !callBlocks[name];
  });
};

/**
 * Ensure there are no incomplete blocks inside any function definitions.
 */
FeedbackUtils.prototype.hasIncompleteBlockInFunction_ = function () {
  var self = this;
  return Blockly.mainBlockSpace.getAllBlocks().some(function (userBlock) {
    // Only search procedure definitions
    if (!userBlock.parameterNames_) {
      return false;
    }
    return self.hasMatchingDescendant_(userBlock, function (block) {
      // Incomplete block if any input connection target is null
      return block.inputList.some(function (input) {
        return input.type === Blockly.INPUT_VALUE && !input.connection.targetConnection;
      });
    });
  });
};

/**
 * Returns true if any descendant (inclusive) of the given node matches the
 * given filter.
 */
FeedbackUtils.prototype.hasMatchingDescendant_ = function (node, filter) {
  if (filter(node)) {
    return true;
  }
  var self = this;
  return node.childBlocks_.some(function (child) {
    return self.hasMatchingDescendant_(child, filter);
  });
};

},{"./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./feedbackBlocks":"/home/ubuntu/staging/apps/build/js/feedbackBlocks.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./puzzleRatingUtils":"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js","./templates/buttons.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs","./templates/code.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/code.html.ejs","./templates/shareFailure.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/shareFailure.html.ejs","./templates/sharing.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/sharing.html.ejs","./templates/showCode.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/showCode.html.ejs","./templates/trophy.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/trophy.html.ejs","./utils":"/home/ubuntu/staging/apps/build/js/utils.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/templates/trophy.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class=\'trophy\'><img class=\'trophyimg\' src=\'', escape((1,  img_url )), '\'><br>', escape((1,  concept_name )), '</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/showCode.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n\n<p id="num-lines-of-code" class="lines-of-code-message">\n  ', escape((4,  msg.numLinesOfCodeWritten({ numLines: numLinesWritten }) )), '\n  <button id="show-code-button" href="#">\n    ', escape((6,  msg.showGeneratedCode() )), '\n  </button>\n</p>\n\n');10; if (totalNumLinesWritten !== 0) { ; buf.push('\n  <p id="total-num-lines-of-code" class="lines-of-code-message">\n    ', escape((12,  msg.totalNumLinesOfCodeWritten({ numLines: totalNumLinesWritten }) )), '\n  </p>\n');14; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/sharing.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n');2; if (options.feedbackImage) { ; buf.push('\n  <img class="feedback-image" src="', escape((3,  options.feedbackImage )), '"/>\n  <div class="sharing-content">\n');5; } else { ; buf.push('\n  <div class="sharing-content no-image">\n');7; } ; buf.push('\n\n\n');10; if (options.response && options.response.level_source) { ; buf.push('\n  ');11; if (options.appStrings && options.appStrings.sharingText) { ; buf.push('\n    <div>', escape((12,  options.appStrings.sharingText )), '</div>\n  ');13; } ; buf.push('\n\n  <div>\n    <input type="text" id="sharing-input" value=', escape((16,  options.response.level_source )), ' readonly>\n  </div>\n  <div class=\'social-buttons\'>\n    ');19; if (options.facebookUrl) {; buf.push('      <a href=\'', escape((19,  options.facebookUrl )), '\' target="_blank" class="popup-window">\n        <button>\n          <i class="fa fa-facebook fa-lg"></i>\n        </button>\n      </a>\n    ');24; }; buf.push('    ');24; if (options.twitterUrl) {; buf.push('      <a href=\'', escape((24,  options.twitterUrl )), '\' target="_blank" class="popup-window">\n        <button>\n          <i class="fa fa-twitter fa-lg"></i>\n        </button>\n      </a>\n    ');29; }; buf.push('    ');29; if (!options.onMainPage && !options.disablePrinting) { ; buf.push('\n      <button id="print-button">\n        <i class="fa fa-print fa-lg"></i>\n      </button>\n    ');33; } ; buf.push('\n    ');34; if (options.alreadySaved) { ; buf.push('\n      <button class="saved-to-gallery" disabled>\n        ', escape((36,  msg.savedToGallery() )), '\n      </button>\n    ');38; } else if (options.saveToGalleryUrl && !options.disableSaveToGallery) { ; buf.push('\n      <button id="save-to-gallery-button" class="launch">\n        ', escape((40,  msg.saveToGallery() )), '\n      </button>\n    ');42; } ; buf.push('\n    ');43; if (options.sendToPhone) {; buf.push('      <button id="sharing-phone">\n        <i class="fa fa-mobile fa-lg"></i>\n        ', escape((45,  msg.sendToPhone() )), '\n      </button>\n    ');47; }; buf.push('\n  </div>\n  <div id="send-to-phone" style="display: none">\n    <label for="phone">Enter a US phone number:</label>\n    <input type="tel" id="phone" name="phone" />\n    <button id="phone-submit" onClick="return false;">Send</button>\n    <div id="phone-charges">A text message will be sent via <a href="http://twilio.com" target="_blank">Twilio</a>. Charges may apply to the recipient.</div>\n  </div>\n');55; } ; buf.push('\n\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/shareFailure.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<p id="share-fail-explanation">', escape((1,  shareFailure.message )), '</p>\n\n');3; if (shareFailure.contents) { ; buf.push('\n  <div class="share-fail-excerpt">\n    <pre class="generatedCode">', escape((5,  shareFailure.contents )), '</pre>\n  </div>\n');7; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/code.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="generated-code-container">\n  <p class="generatedCodeMessage">', (2,  message ), '</p>\n  <pre class="generatedCode">', escape((3,  code )), '</pre>\n</div>\n\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/buttons.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var msg = require('../locale'); ; buf.push('\n\n');3; if (data.ok) {; buf.push('  <div class="farSide" style="padding: 1ex 3ex 0">\n    <button id="ok-button" class="secondary">\n      ', escape((5,  msg.dialogOK() )), '\n    </button>\n  </div>\n');8; }; buf.push('\n');9; if (data.cancelText) {; buf.push('<button id="again-button" class="', escape((9,  data.cancelButtonClass || '' )), '">\n    ', escape((10,  data.cancelText )), '\n</button>\n');12; }; buf.push('\n');13; if (data.confirmText) {; buf.push('<button id="confirm-button" class="launch" style="float: right">\n    ', escape((14,  data.confirmText )), '\n</button>\n');16; }; buf.push('\n');17; if (data.previousLevel) {; buf.push('  <button id="back-button" class="launch">\n    ', escape((18,  msg.backToPreviousLevel() )), '\n  </button>\n');20; }; buf.push('\n');21; if (data.tryAgain) {; buf.push('  ');21; if (data.isK1 && !data.freePlay) {; buf.push('    <div id="again-button" class="launch arrow-container arrow-left">\n      <div class="arrow-head"><img src="', escape((22,  data.assetUrl('media/tryagain-arrow-head.png') )), '" alt="Arrowhead" width="67" height="130"/></div>\n      <div class="arrow-text">', escape((23,  data.tryAgain )), '</div>\n    </div>\n  ');25; } else {; buf.push('    ');25; if (data.shouldPromptForHint) {; buf.push('      <button id="hint-request-button" class="lightbulb-button">\n        <span>' + (function(){var buf = [];
 buf.push('<svg version="1.1"\n	 id="svg3013" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" sodipodi:docname="light_bulb_font_awesome.svg" inkscape:version="0.48.3.1 r9886"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<g id="bulb">\n  <path fill="#EFB834" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n    c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n    c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n  <g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n    <path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n      s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n      c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n      c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n      S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n      s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n      c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n      c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n      c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n      C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n      c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n      c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n      c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n      s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n      c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n      s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n      c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n      c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n      C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n      c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n      c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="473.582" y1="208.1" x2="560.578" y2="159.16"/>\n    <path fill="#EFB834" d="M473.141,207.315c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n      c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.462-3.3,6.831-5.055\n      c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n      c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n      c2.529-0.971,4.998-1.751,7.331-2.377c4.655-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n      c0.843,0.007,1.313,0.047,1.313,0.047l0.883,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n      c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n      c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n      c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n      c-2.511,1.004-4.885,1.953-7.076,2.83c-2.189,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n      c-2.587,0.968-4.08,1.494-4.08,1.494L473.141,207.315z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="492.348" y1="410.008" x2="589.509" y2="432.883"/>\n    <path fill="#EFB834" d="M492.555,409.132c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n      c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n      c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.247,0.691,9.346,0.922\n      c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.857,0.628,5.548,1.531,8.064,2.543\n      c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n      c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n      c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n      c-1.415-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n      c-2.968-1.004-5.944-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n      c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n      c-2.559-1.039-4.015-1.663-4.015-1.663L492.555,409.132z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="502.559" y1="301.7" x2="602.37" y2="300.685"/>\n    <path fill="#EFB834" d="M502.55,300.8c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n      c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n      c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.3-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n      c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n      c2.685,0.366,5.224,0.871,7.57,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n      c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.727,0.45-1.793,1.031-3.151,1.687\n      c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n      c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n      c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n      c-2.684-0.329-5.222-0.639-7.564-0.926c-2.342-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n      c-2.734-0.397-4.296-0.655-4.296-0.655L502.55,300.8z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="135.661" y1="212.764" x2="48.665" y2="163.824"/>\n    <path fill="#EFB834" d="M135.22,213.548c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n      c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n      c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n      c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n      c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.874-1.229-1.53-2.251-1.95-2.995\n      c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.572,0.111\n      c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.801,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n      c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n      c2.573,1.789,5.161,3.549,7.677,5.341c2.529,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n      c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.117,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n      c2.17,1.708,3.396,2.711,3.396,2.711L135.22,213.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="120.895" y1="411.672" x2="23.734" y2="434.547"/>\n    <path fill="#EFB834" d="M121.101,412.548c0,0-1.456,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n      c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n      c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n      c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n      c-2.699,0.231-5.288,0.295-7.702,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n      c-0.808-0.241-1.248-0.41-1.248-0.41l-0.413-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n      c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n      c1.431-0.302,2.9-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n      c3.104-0.425,6.201-0.882,9.265-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n      c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n      c2.754-0.212,4.335-0.303,4.335-0.303L121.101,412.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="112.684" y1="306.364" x2="12.873" y2="305.349"/>\n    <path fill="#EFB834" d="M112.675,307.264c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n      c-1.904,0.25-4.051,0.568-6.394,0.849c-2.343,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n      c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n      c-1.537,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n      c-2.676-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n      c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.814-0.994,3.185-1.622\n      c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n      c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n      c3.116,0.329,6.232,0.626,9.299,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.92,0.398,5.744,0.75,8.421,1.142\n      c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n      c2.725,0.453,4.282,0.742,4.282,0.742L112.675,307.264z"/>\n  </g>\n</g>\n<g id="count">\n  <text x="400" y="700" id="hintCount"></text>\n</g>\n</svg>\n');
return buf.join('');})() + '</span>\n        ', escape((27,  msg.hintRequest() )), '\n      </button>\n    ');29; } ; buf.push('\n    <button id="again-button" class="launch">\n      ', escape((31,  data.tryAgain )), '\n    </button>\n  ');33; }; buf.push('');33; }; buf.push('\n');34; if (data.nextLevel) {; buf.push('  ');34; if (data.isK1 && !data.freePlay) {; buf.push('    <div id="continue-button" class="launch arrow-container arrow-right">\n      <div class="arrow-head"><img src="', escape((35,  data.assetUrl('media/next-arrow-head.png') )), '" alt="Arrowhead" width="66" height="130"/></div>\n      <div class="arrow-text">', escape((36,  data.continueText )), '</div>\n    </div>\n  ');38; } else {; buf.push('    <button id="continue-button" class="launch" style="float: right">\n      ', escape((39,  data.continueText )), '\n    </button>\n  ');41; }; buf.push('');41; }; buf.push('<div class="after-feedback-buttons"/>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/puzzleRatingUtils.js":[function(require,module,exports){
/**
 * @overview A helper class for all actions associated with Puzzle
 * Ratings, aka the Fun-O-Meter.
 */

'use strict';

var puzzleRatingUtils = {};

module.exports = puzzleRatingUtils;

var dom = require('./dom');

/**
 * Construct the puzzle rating buttons themselves
 *
 * @returns {Element} div containing puzzle ratng buttons with attached
 *          click handlers
 */
puzzleRatingUtils.buildPuzzleRatingButtons = function () {
  var buttonContainer = document.createElement('div');
  buttonContainer.id = 'puzzleRatingButtons';
  buttonContainer.innerHTML = require('./templates/puzzleRating.html.ejs')();

  var buttons = buttonContainer.querySelectorAll('.puzzle-rating-btn');
  var buttonClickHandler = function buttonClickHandler() {
    for (var i = 0, button; button = buttons[i]; i++) {
      if (button != this) {
        $(button).removeClass('enabled');
      }
    }
    $(this).toggleClass('enabled');
  };
  for (var i = 0, button; button = buttons[i]; i++) {
    dom.addClickTouchEvent(button, buttonClickHandler);
  }

  return buttonContainer;
};

/**
 * @typedef {Object} PuzzleRating
 *
 * @property {number} script_id
 * @property {number} level_id
 * @property {number|string} rating - can be a number or an
 *           integer-parseable string
 */

/**
 * Private getter/localStorage proxy
 * @returns {PuzzleRating[]} - ratings
 */
puzzleRatingUtils.getPuzzleRatings_ = function () {
  var ratings = localStorage.getItem('puzzleRatings');
  try {
    return ratings ? JSON.parse(ratings) : [];
  } catch (e) {
    return [];
  }
};

/**
 * Private setter/localStorage proxy
 * @param {PuzzleRating[]} ratings
 */
puzzleRatingUtils.setPuzzleRatings_ = function (ratings) {
  localStorage.setItem('puzzleRatings', JSON.stringify(ratings));
};

/**
 * Private deleter/localStorage proxy
 * @param {PuzzleRating} rating
 */
puzzleRatingUtils.removePuzzleRating_ = function (rating) {
  var ratings = puzzleRatingUtils.getPuzzleRatings_().filter(function (other) {
    var otherEqualsRating = rating.level_id === other.level_id && rating.script_id === other.script_id && rating.rating === other.rating;
    return !otherEqualsRating;
  });
  puzzleRatingUtils.setPuzzleRatings_(ratings);
};

/**
 * Cache the selected rating, to be submitted (possibly with other
 * cached ratings) at some later point
 *
 * @param {jQuery} container - some element that contains the buttons
 * @param {Object} options - other data to be submitted along with the
 *        rating. Usually script_id and level_id
 */
puzzleRatingUtils.cachePuzzleRating = function (container, options) {
  var selectedButton = container.querySelector('.puzzle-rating-btn.enabled');
  if (selectedButton) {
    var rating = $.extend({}, options, { rating: selectedButton.getAttribute('data-value') });
    var ratings = puzzleRatingUtils.getPuzzleRatings_();
    ratings.push(rating);
    puzzleRatingUtils.setPuzzleRatings_(ratings);
  }
};

/**
 * POST the cached ratings to the given URL and clear the cache
 * @param {string} url 
 */
puzzleRatingUtils.submitCachedPuzzleRatings = function (url) {
  var ratings = puzzleRatingUtils.getPuzzleRatings_();
  ratings.forEach(function (rating) {
    $.ajax({
      url: url,
      type: 'POST',
      data: rating,
      complete: function complete() {
        puzzleRatingUtils.removePuzzleRating_(rating);
      }
    });
  });
};

},{"./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./templates/puzzleRating.html.ejs":"/home/ubuntu/staging/apps/build/js/templates/puzzleRating.html.ejs"}],"/home/ubuntu/staging/apps/build/js/templates/puzzleRating.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<hr>\n<p>Did you like this puzzle?</p>\n\n<a class="puzzle-rating-btn" id="like" data-value="1">\n  <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      width="27px" height="27px" viewBox="0 0 26.055 21.058" enable-background="new 0 0 26.055 21.058" xml:space="preserve" value="1">\n    <path d="M14.426,2.5c0.986-1.348,2.83-2.5,5.092-2.5c3.613,0,6.537,3.044,6.537,6.537\n        c0,2.357-1.076,3.709-1.894,4.525c-0.941,0.941-8.082,8.082-9.113,9.113c-1.244,1.243-3.019,1.137-4.246-0.09\n        c-1.314-1.314-7.158-7.158-9.131-9.131C0.408,9.693,0,8.113,0,6.537C0,2.926,3.197,0,6.537,0c2.451,0,4.438,1.508,5.188,2.535\n        C12.4,3.459,13.643,3.564,14.426,2.5z"/>\n  </svg>\n</a>\n\n<a class="puzzle-rating-btn" id="dislike" data-value="0">\n  <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      width="27px" height="27px" viewBox="382.321 292.82 26.37 26.371" enable-background="new 382.321 292.82 26.37 26.371"\n      xml:space="preserve">\n    <path d="M395.506,292.82c-7.282,0.002-13.184,5.904-13.185,13.185c0.001,7.283,5.902,13.184,13.185,13.186\n        c7.281-0.002,13.183-5.902,13.185-13.186C408.689,298.725,402.787,292.822,395.506,292.82z M402.5,313\n        c-1.795,1.793-4.257,2.896-6.994,2.898c-2.737-0.002-5.199-1.105-6.994-2.898c-1.794-1.795-2.897-4.258-2.897-6.994\n        s1.103-5.199,2.897-6.994c1.795-1.793,4.257-2.897,6.994-2.897s5.199,1.104,6.994,2.897c1.792,1.795,2.896,4.258,2.896,6.994\n        S404.292,311.205,402.5,313z M391.317,304.951c1.054,0,1.907-0.854,1.907-1.906c0-1.053-0.854-1.906-1.907-1.906\n        c-1.054,0-1.907,0.854-1.907,1.906C389.41,304.098,390.264,304.951,391.317,304.951z M399.691,304.951\n        c1.053,0,1.906-0.854,1.906-1.906c0-1.053-0.853-1.906-1.906-1.906s-1.907,0.854-1.907,1.906\n        C397.784,304.098,398.639,304.951,399.691,304.951z M391.773,311.928c1.037-1.035,2.379-1.543,3.739-1.545\n        c1.352,0.002,2.689,0.512,3.724,1.545c0.642,0.643,1.685,0.643,2.328,0c0.645-0.643,0.645-1.686,0-2.33\n        c-1.665-1.666-3.864-2.51-6.052-2.508h-0.008c-2.185,0-4.39,0.838-6.06,2.51c-0.642,0.643-0.643,1.686,0,2.328\n        C390.088,312.571,391.131,312.571,391.773,311.928z"/>\n  </svg>\n</a>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/feedbackBlocks.js":[function(require,module,exports){
'use strict';

var constants = require('./constants');
var parseXmlElement = require('./xml').parseElement;

var TestResults = constants.TestResults;

// TODO (br-pair): can we not pass in the studioApp
var FeedbackBlocks = function FeedbackBlocks(options, missingRequiredBlocks, missingRecommendedBlocks, studioApp) {
  // Check whether blocks are embedded in the hint returned from dashboard.
  // See below comment for format.
  var embeddedBlocks = options.response && options.response.hint && options.response.hint.indexOf("[{") !== 0;
  if (!embeddedBlocks && options.feedbackType !== TestResults.MISSING_BLOCK_UNFINISHED && options.feedbackType !== TestResults.MISSING_BLOCK_FINISHED && options.feedbackType !== TestResults.MISSING_RECOMMENDED_BLOCK_UNFINISHED && options.feedbackType !== TestResults.MISSING_RECOMMENDED_BLOCK_FINISHED) {
    return;
  }

  var blocksToDisplay = [];
  if (embeddedBlocks) {
    // Hint should be of the form: SOME TEXT [{..}, {..}, ..] IGNORED.
    // Example: 'Try the following block: [{"type": "maze_moveForward"}]'
    // Note that double quotes are required by the JSON parser.
    var parts = options.response.hint.match(/(.*)(\[.*\])/);
    if (!parts) {
      return;
    }
    options.response.hint = parts[1].trim(); // Remove blocks from hint.
    try {
      blocksToDisplay = JSON.parse(parts[2]);
    } catch (err) {
      // The blocks could not be parsed.  Ignore them.
      return;
    }
  } else if (missingRequiredBlocks.blocksToDisplay.length) {
    handleMissingBlocks(missingRequiredBlocks);
  } else {
    handleMissingBlocks(missingRecommendedBlocks);
  }

  function handleMissingBlocks(blocks) {
    blocksToDisplay = blocks.blocksToDisplay;
    if (blocks.message) {
      options.message = blocks.message;
    }
  }

  if (blocksToDisplay.length === 0) {
    return;
  }

  this.xml = this.generateXMLForBlocks_(blocksToDisplay);

  this.div = document.createElement('div');
  this.div.setAttribute('id', 'feedbackBlocks');

  // Will be set by this.render()
  this.blockSpaceEditor = undefined;
};

module.exports = FeedbackBlocks;

FeedbackBlocks.prototype.render = function () {
  // Only render if this.div exists in the DOM
  if (!document.body.contains(this.div)) {
    return;
  }

  var parsedXml = parseXmlElement(this.xml);
  var blockSpace = Blockly.BlockSpace.createReadOnlyBlockSpace(this.div, parsedXml);
  this.blockSpaceEditor = blockSpace.blockSpaceEditor;
};

FeedbackBlocks.prototype.show = function () {
  this.div.style.visibility = '';
  this.div.style.height = '';
  if (this.blockSpaceEditor) {
    this.blockSpaceEditor.svgResize();
  }
};

FeedbackBlocks.prototype.hide = function () {
  this.div.style.visibility = 'hidden';
  this.div.style.height = '0px';
};

/**
 * Creates the XML for blocks to be displayed in a read-only frame.
 * @param {Array} blocks An array of blocks to display (with optional args).
 * @return {string} The generated string of XML.
 */
FeedbackBlocks.prototype.generateXMLForBlocks_ = function (blocks) {
  var blockXMLStrings = ['<xml>'];
  var blockX = 10; // Prevent left output plugs from being cut off.
  var blockY = 0;
  var blockXPadding = 200;
  var blockYPadding = 120;
  var blocksPerLine = 2;
  var k, name;
  for (var i = 0; i < blocks.length; i++) {
    var block = blocks[i];
    if (block.blockDisplayXML) {
      blockXMLStrings.push(block.blockDisplayXML);
      continue;
    }
    blockXMLStrings.push('<block', ' type="', block.type, '" x="', blockX.toString(), '" y="', blockY, '">');
    if (block.titles) {
      var titleNames = Object.keys(block.titles);
      for (k = 0; k < titleNames.length; k++) {
        name = titleNames[k];
        blockXMLStrings.push('<title name="', name, '">', block.titles[name], '</title>');
      }
    }
    if (block.values) {
      var valueNames = Object.keys(block.values);
      for (k = 0; k < valueNames.length; k++) {
        name = valueNames[k];
        blockXMLStrings.push('<value name="', name, '">', block.values[name], '</value>');
      }
    }
    if (block.extra) {
      blockXMLStrings.push(block.extra);
    }
    blockXMLStrings.push('</block>');
    if ((i + 1) % blocksPerLine === 0) {
      blockY += blockYPadding;
      blockX = 0;
    } else {
      blockX += blockXPadding;
    }
  }
  blockXMLStrings.push('</xml>');
  return blockXMLStrings.join('');
};

},{"./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/clientApi.js":[function(require,module,exports){
/* global dashboard */
// TODO(dave): Merge with the client API in /shared.
// TODO: The client API should be instantiated with the channel ID, instead of grabbing it from the `dashboard.project` global.

'use strict';

module.exports = {
  assets: clientApi('assets'),
  sources: clientApi('sources')
};

function clientApi(endpoint) {
  return {
    basePath: function basePath(path) {
      return '/v3/' + endpoint + '/' + dashboard.project.getCurrentId() + (path ? '/' + path : '');
    },
    ajax: function ajax(method, file, success, error, data) {
      if (!window.dashboard) {
        error({ status: "No dashboard" });
        return;
      }
      var xhr = new XMLHttpRequest();
      xhr.addEventListener('load', function () {
        if (xhr.status >= 400) {
          error(xhr);
          return;
        }
        success(xhr);
      });
      xhr.addEventListener('error', function () {
        error(xhr);
      });

      xhr.open(method, this.basePath(file), true);
      xhr.send(data);
    }
  };
}

},{}],"/home/ubuntu/staging/apps/build/js/block_utils.js":[function(require,module,exports){
'use strict';

var xml = require('./xml');

/**
 * Create the xml for a level's toolbox
 * @param {string} blocks The xml of the blocks to go in the toolbox
 */
exports.createToolbox = function (blocks) {
  return '<xml id="toolbox" style="display: none;">' + blocks + '</xml>';
};

/**
 * Create the xml for a block of the given type
 * @param {string} type The type of the block
 * @param {Object.<string,string>} [titles] Dictionary of titles mapping name to value
 */
exports.blockOfType = function (type, titles) {
  var titleText = '';
  if (titles) {
    for (var key in titles) {
      titleText += '<title name="' + key + '">' + titles[key] + '</title>';
    }
  }
  return '<block type="' + type + '">' + titleText + '</block>';
};

/**
 * Create the xml for a block of the given type, with the provided child nested
 * in a next block
 * @param {string} type The type of the block
 * @param {Object.<string,string>} [titles] Dictionary of titles mapping name to value
 * @param {string} child Xml for the child block
 */
exports.blockWithNext = function (type, titles, child) {
  var titleText = '';
  if (titles) {
    for (var key in titles) {
      titleText += '<title name="' + key + '">' + titles[key] + '</title>';
    }
  }
  return '<block type="' + type + '">' + titleText + '<next>' + child + '</next></block>';
};

/**
 * Give a list of types, returns the xml assuming each block is a child of
 * the previous block.
 */
exports.blocksFromList = function (types) {
  if (types.length === 1) {
    return this.blockOfType(types[0]);
  }

  return this.blockWithNext(types[0], {}, this.blocksFromList(types.slice(1)));
};

/**
 * Create the xml for a category in a toolbox
 */
exports.createCategory = function (name, blocks, custom) {
  return '<category name="' + name + '"' + (custom ? ' custom="' + custom + '"' : '') + '>' + blocks + '</category>';
};

/**
 * Generate a simple block with a plain title and next/previous connectors.
 */
exports.generateSimpleBlock = function (blockly, generator, options) {
  ['name', 'title', 'tooltip', 'functionName'].forEach(function (param) {
    if (!options[param]) {
      throw new Error('generateSimpleBlock requires param "' + param + '"');
    }
  });

  var name = options.name;
  var helpUrl = options.helpUrl || ""; // optional param
  var title = options.title;
  var titleImage = options.titleImage;
  var tooltip = options.tooltip;
  var functionName = options.functionName;

  blockly.Blocks[name] = {
    helpUrl: helpUrl,
    init: function init() {
      // Note: has a fixed HSV.  Could make this customizable if need be
      this.setHSV(184, 1.00, 0.74);
      var input = this.appendDummyInput();
      if (title) {
        input.appendTitle(title);
      }
      if (titleImage) {
        input.appendTitle(new blockly.FieldImage(titleImage));
      }
      this.setPreviousStatement(true);
      this.setNextStatement(true);
      this.setTooltip(tooltip);
    }
  };

  generator[name] = function () {
    // Generate JavaScript for putting dirt on to a tile.
    return functionName + '(\'block_id_' + this.id + '\');\n';
  };
};

/**
 * Generates a single block from a <block/> DOM element, adding it to the main workspace
 * @param blockDOM {Element}
 * @returns {*}
 */
exports.domToBlock = function (blockDOM) {
  return Blockly.Xml.domToBlock(Blockly.mainBlockSpace, blockDOM);
};

/**
 * Generates a single block from a block XML stringe.g., <block type="testBlock"></block>,
 * and adds it to the main workspace
 * @param blockDOMString
 * @returns {*}
 */
exports.domStringToBlock = function (blockDOMString) {
  return exports.domToBlock(xml.parseElement(blockDOMString).firstChild);
};

/**
 * Takes a set of start blocks, and returns them with a particular top level
 * block inserted in front of the first non-function block.  If we already have
 * this block, does nothing.
 */
exports.forceInsertTopBlock = function (input, blockType) {
  input = input || '';

  if (blockType === null || input.indexOf(blockType) !== -1) {
    return input;
  }

  var root = xml.parseElement(input);

  // Extract the document from the root. The reason I do this instead of just
  // using document.createElement elsewhere is
  var doc = root.parentNode;

  var topBlock = doc.createElement('block');
  topBlock.setAttribute('type', blockType);
  topBlock.setAttribute('movable', 'false');
  topBlock.setAttribute('deletable', 'false');

  var numChildren = root.childNodes ? root.childNodes.length : 0;

  // find the first non-function definition block and extract it
  var firstBlock = null,
      i = 0;
  while (i < numChildren && firstBlock === null) {
    var child = root.childNodes[i];
    // only look at element nodes
    if (child.nodeType === 1) {
      var type = child.getAttribute('type');
      if (type !== 'procedures_defnoreturn' && type !== 'procedures_defreturn') {
        firstBlock = root.removeChild(child);
        numChildren--;
      }
    }
    i++;
  }

  if (firstBlock !== null) {
    // when run -> next -> firstBlock
    var next;
    if (/^functional/.test(blockType)) {
      next = doc.createElement('functional_input');
      next.setAttribute('name', 'ARG1');
    } else {
      next = doc.createElement('next');
    }
    next.appendChild(firstBlock);
    topBlock.appendChild(next);
  }

  if (numChildren > 0) {
    root.insertBefore(topBlock, root.childNodes[0]);
  } else {
    root.appendChild(topBlock);
  }
  return xml.serialize(root);
};

/**
 * Generate the xml for a block for the calc app.
 * @param {string} type Type for this block
 * @param {number[]|string[]} args List of args, where each arg is either the
 *   xml for a child block, a number, or the name of a variable.
 */
exports.calcBlockXml = function (type, args) {
  var str = '<block type="' + type + '" inline="false">';
  for (var i = 1; i <= args.length; i++) {
    str += '<functional_input name="ARG' + i + '">';
    var arg = args[i - 1];
    if (typeof arg === "number") {
      arg = '<block type="functional_math_number"><title name="NUM">' + arg + '</title></block>';
    } else if (/^<block/.test(arg)) {
      // we have xml, dont make any changes
      arg = arg;
    } else {
      // we think we have a variable
      arg = exports.calcBlockGetVar(arg);
    }
    str += arg;
    str += '</functional_input>';
  }
  str += '</block>';

  return str;
};

/**
 * @returns the xml for a functional_parameters_get block with the given
 *   variableName
 */
exports.calcBlockGetVar = function (variableName) {
  return '' + '<block type="functional_parameters_get" uservisible="false">' + '  <mutation>' + '    <outputtype>Number</outputtype>' + '  </mutation>' + '  <title name="VAR">' + variableName + '</title>' + '</block>';
};

/**
 * Generate the xml for a math block (either calc or eval apps).
 * @param {string} type Type for this block
 * @param {Object.<string,string} inputs Dictionary mapping input name to the
     xml for that input
 * @param {Object.<string.string>} [titles] Dictionary of titles mapping name to value
 */
exports.mathBlockXml = function (type, inputs, titles) {
  var str = '<block type="' + type + '" inline="false">';
  for (var title in titles) {
    str += '<title name="' + title + '">' + titles[title] + '</title>';
  }

  for (var input in inputs) {
    str += '<functional_input name="' + input + '">' + inputs[input] + '</functional_input>';
  }

  str += '</block>';

  return str;
};

/**
 * Generate xml for a functional defintion
 * @param {string} name The name of the function
 * @param {string} outputType Function's output type
 * @param {Object<string, string>[]} argList Name and type for each arg
 * @param {string} blockXml Xml for the blocks that actually define the function
 */
exports.functionalDefinitionXml = function (name, outputType, argList, blockXml) {
  var mutation = '<mutation>';
  argList.forEach(function (argInfo) {
    mutation += '<arg name="' + argInfo.name + '" type="' + argInfo.type + '"></arg>';
  });
  mutation += '<outputtype>' + outputType + '</outputtype></mutation>';

  return '<block type="functional_definition" inline="false">' + mutation + '<title name="NAME">' + name + '</title>' + '<functional_input name="STACK">' + blockXml + '</functional_input>' + '</block>';
};

/**
 * Generate xml for a calling a functional function
 * @param {string} name The name of the function
 * @param {Object<string, string>[]} argList Name and type for each arg
 */
exports.functionalCallXml = function (name, argList, inputContents) {
  if (argList.length !== inputContents.length) {
    throw new Error('must define contents for each arg');
  }

  var mutation = '<mutation name="' + name + '">';
  argList.forEach(function (argInfo) {
    mutation += '<arg name="' + argInfo.name + '" type="' + argInfo.type + '"></arg>';
  });
  mutation += '</mutation>';

  var contents = '';
  inputContents.forEach(function (blockXml, index) {
    contents += '<functional_input name="ARG' + index + '">' + blockXml + '</functional_input>';
  });

  return '<block type="functional_call">' + mutation + contents + '</block>';
};

},{"./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltip = require('./DropletFunctionTooltip');
var DropletBlockTooltipManager = require('./DropletBlockTooltipManager');
var DropletAutocompletePopupTooltipManager = require('./DropletAutocompletePopupTooltipManager');
var DropletAutocompleteParameterTooltipManager = require('./DropletAutocompleteParameterTooltipManager');
var dropletUtils = require('../dropletUtils');

/**
 * @fileoverview Manages a store of known blocks and tooltips
 */

/**
 * Store for finding tooltips for blocks
 * @constructor
 */
function DropletTooltipManager(appMsg, dropletConfig, codeFunctions, autocompletePaletteApisOnly) {
  /**
   * App-specific strings (to override common msg)
   * @type {Object.<String, Function>}
   */
  this.appMsg = appMsg || {};
  this.tooltipsEnabled = true;

  /**
   * Droplet config for this app
   */
  this.dropletConfig = dropletConfig || {};

  /**
   * Code functions
   * @type {Object.<String>} optional object with keys to modify the blocks
   */
  this.codeFunctions = codeFunctions;

  /**
   * Flag to limit the number of APIs that see autocomplete behavior
   */
  this.autocompletePaletteApisOnly = autocompletePaletteApisOnly;

  /**
   * Map of block types to tooltip objects
   * @type {Object.<String, DropletFunctionTooltip>}
   */
  this.blockTypeToTooltip_ = {};

  /**
   * Maps func from one block type to another, such that we use the target for
   * documentation instead of the source
   * @type {Object.<String, String>}
   */
  this.docFuncMapping_ = {};

  /**
   * @type {DropletBlockTooltipManager}
   * @private
   */
  this.dropletBlockTooltipManager_ = new DropletBlockTooltipManager(this);

  /**
   * @type {DropletAutocompletePopupTooltipManager}
   * @private
   */
  this.dropletAutocompletePopupTooltipManager_ = new DropletAutocompletePopupTooltipManager(this);

  /**
   * @type {DropletAutocompletePopupTooltipManager}
   * @private
   */
  this.dropletAutocompleteParameterTooltipManager_ = new DropletAutocompleteParameterTooltipManager(this);
}

/**
 * Registers handlers for droplet block tooltips.
 * @param dropletEditor
 */
DropletTooltipManager.prototype.registerDropletBlockModeHandlers = function (dropletEditor) {
  this.dropletBlockTooltipManager_.installTooltipsForEditor_(dropletEditor);
};

/**
 * Registers handlers for ACE mode tooltips
 * @param dropletEditor
 */
DropletTooltipManager.prototype.registerDropletTextModeHandlers = function (dropletEditor) {
  this.dropletAutocompletePopupTooltipManager_.installTooltipsForEditor_(dropletEditor);
  this.dropletAutocompleteParameterTooltipManager_.installTooltipsForEditor_(dropletEditor);
};

/**
 * Registers block tooltips for blocks based on the dropletBlocks and
 * codeFunctions passed to the constructor
 */
DropletTooltipManager.prototype.registerBlocks = function () {
  var blocks = dropletUtils.getAllAvailableDropletBlocks(this.dropletConfig, this.codeFunctions, this.autocompletePaletteApisOnly);
  blocks.forEach(function (dropletBlockDefinition) {
    var key = dropletBlockDefinition.modeOptionName || dropletBlockDefinition.func;
    if (dropletBlockDefinition.docFunc) {
      // If a docFunc was specified, update our mapping
      this.docFuncMapping_[key] = dropletBlockDefinition.docFunc;
    } else {
      this.blockTypeToTooltip_[key] = new DropletFunctionTooltip(this.appMsg, dropletBlockDefinition);
    }
  }, this);
};

DropletTooltipManager.prototype.getDocFor = function (functionName) {
  var docFuncName = this.docFuncMapping_[functionName] || functionName;
  return this.blockTypeToTooltip_[docFuncName];
};

DropletTooltipManager.prototype.showDocFor = function (functionName) {
  if (!this.tooltipsEnabled) {
    return;
  }
  $('.tooltipstered').tooltipster('hide');
  var dialog = new window.Dialog({
    body: $('<iframe>').addClass('markdown-instructions-container').width('100%').attr('src', this.getDropletTooltip(functionName).getFullDocumentationURL()),
    autoResizeScrollableElement: '.markdown-instructions-container',
    id: 'block-documentation-lightbox'
  });
  dialog.show();
};

/**
 * @param {String} functionName
 * @returns {DropletFunctionTooltip}
 */
DropletTooltipManager.prototype.getDropletTooltip = function (functionName) {
  var tooltip = this.getDocFor(functionName);
  if (!tooltip) {
    throw "Function name " + functionName + " not registered in documentation manager.";
  }

  return tooltip;
};

/**
 * @param {boolean} enabled if tooltips should be enabled.
 */
DropletTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
  this.dropletAutocompletePopupTooltipManager_.setTooltipsEnabled(enabled);
  this.dropletAutocompleteParameterTooltipManager_.setTooltipsEnabled(enabled);
  this.dropletBlockTooltipManager_.setTooltipsEnabled(enabled);
};

module.exports = DropletTooltipManager;

},{"../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./DropletAutocompleteParameterTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompleteParameterTooltipManager.js","./DropletAutocompletePopupTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompletePopupTooltipManager.js","./DropletBlockTooltipManager":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletBlockTooltipManager.js","./DropletFunctionTooltip":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletBlockTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltip = require('./DropletFunctionTooltip');
var DropletFunctionTooltipMarkup = require('./DropletFunctionTooltip.html.ejs');
var dom = require('../dom');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet blocks
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletBlockTooltipManager = function DropletBlockTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.tooltipsEnabled = true;
};

var DEFAULT_TOOLTIP_CONFIG = {
  interactive: true,
  speed: 150,
  maxWidth: 450,
  position: 'right',
  contentAsHTML: true,
  theme: 'droplet-block-tooltipster',
  offsetY: 2,
  delay: 400
};

/**
 * Simple helper function that will swallow exceptions, and log them as
 * console.error. This is done because the way that some of our callbacks are
 * called by droplet, exceptions would bubble down to the droplet code, and
 * prevent desired behavior (i.e. we fail to transition back to block mode).
 */
function swallowErrors(fn) {
  return function () {
    try {
      fn();
    } catch (err) {
      if (typeof console !== "undefined" && console.error) {
        console.error(err);
      }
    }
  };
}

/**
 * @param {Editor} dropletEditor
 */
DropletBlockTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  this.installTooltipsForCurrentCategoryBlocks_();
  this.hideTooltipsOnBlockPick_(dropletEditor);

  dropletEditor.on('changepalette', swallowErrors(this.installTooltipsForCurrentCategoryBlocks_.bind(this)));
  dropletEditor.on('toggledone', swallowErrors(this.installTooltipsIfNotInstalled_.bind(this)));
};

DropletBlockTooltipManager.prototype.installTooltipsIfNotInstalled_ = function () {
  if (!$('.droplet-hover-div').hasClass('tooltipstered')) {
    this.installTooltipsForCurrentCategoryBlocks_();
  }
};

DropletBlockTooltipManager.prototype.installTooltipsForCurrentCategoryBlocks_ = function () {
  if (!this.tooltipsEnabled) {
    return;
  }

  $('.droplet-hover-div').each((function (_, blockHoverDiv) {
    if ($(blockHoverDiv).hasClass('tooltipstered')) {
      return;
    }

    var funcName = $(blockHoverDiv).attr('title');

    var hoverDivWidth = $(blockHoverDiv).width();
    var hoverDivLeftToToolboxRight = $('.droplet-palette-canvas').width() - parseInt(blockHoverDiv.style.left, 10);
    var desiredXPosition = Math.min(hoverDivWidth, hoverDivLeftToToolboxRight);
    var tooltipOffsetX = desiredXPosition - hoverDivWidth;

    var configuration = $.extend({}, DEFAULT_TOOLTIP_CONFIG, {
      content: this.getTooltipHTML(funcName),
      offsetX: tooltipOffsetX,
      functionReady: (function (_, contents) {
        if (!this.showExamplesLink) {
          return;
        }
        var seeExamplesLink = contents.find('.tooltip-example-link > a')[0];
        // Important this binds to mouseDown/touchDown rather than click, needs to
        // happen before `blur` which triggers the ace editor completer popup
        // hide which in turn would hide the link and not show the docs.
        dom.addClickTouchEvent(seeExamplesLink, (function (event) {
          this.dropletTooltipManager.showDocFor(funcName);
          event.stopPropagation();
        }).bind(this));
      }).bind(this)
    });

    // Store the title/funcName as a block id so we can attach callouts later:
    $(blockHoverDiv).attr('id', 'droplet_palette_block_' + funcName);
    $(blockHoverDiv).tooltipster(configuration);
  }).bind(this));
};

/**
 * Tooltipster's hideOnClick setting does not work with the droplet hover
 * overlay as-is. Hide the tooltip on block picking explicitly.
 */
DropletBlockTooltipManager.prototype.hideTooltipsOnBlockPick_ = function (dropletEditor) {
  dropletEditor.on('pickblock', function () {
    $('.tooltipstered').tooltipster('hide');
  });
};

/**
 * @returns {String} HTML for tooltip
 */
DropletBlockTooltipManager.prototype.getTooltipHTML = function (functionName) {
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(functionName);
  return DropletFunctionTooltipMarkup({
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink
  });
};

/**
 * @param {boolean} enabled if tooltips should be enabled
 */

DropletBlockTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
};

module.exports = DropletBlockTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","./DropletFunctionTooltip":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js","./DropletFunctionTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.js":[function(require,module,exports){
'use strict';

var msg = require('../locale');
var utils = require('../utils');

/**
 * @fileoverview Representation of a droplet function/block's tooltip
 */

var DROPLET_BLOCK_I18N_PREFIX = "dropletBlock_";

/**
 * @typedef {Object} parameterInfo
 * @property {String} name
 * @property {?String} description
 */

/**
 * Stores a block's tooltip information and helps render it
 * Grabs much of the tooltip's information from either app-specific locale
 * file (passed in as appMsg) or, if not present, the 'common' locale file,
 * (apps/i18n/common/en_us.json), keyed by the function name.
 *
 * e.g.,
 *
 * "dropletBlock_readRecords_description": "Reads records [...].",
 * "dropletBlock_readRecords_param0": "table",
 * "dropletBlock_readRecords_param1": "searchParams",
 * "dropletBlock_readRecords_param2": "onSuccess",
 *
 * Will result in a tooltip with the contents:
 *
 *    readRecords(table, searchParams, onSuccess)
 *    Reads records [...].
 *    [Read More] (links to `readRecords` doc file)
 *
 * Blocks which have functionNames that should not be user-visible can define
 * their own signature override.
 *
 * e.g.,
 *
 * "dropletBlock_functionParams_n_description": "Define a function with a given parameter",
 * "dropletBlock_functionParams_n_signatureOverride": "Function with a Parameter",
 *
 * Will result in a tooltip with the contents:
 *
 *    Function with a Parameter <-- note, no ()s
 *    Define a function with a given parameter.
 *    [Read More] (links to `functionParams_n` doc file)
 *
 * @constructor
 */
var DropletFunctionTooltip = function DropletFunctionTooltip(appMsg, definition) {
  this.appMsg = appMsg;

  /** @type {string} */
  this.functionName = definition.func;

  /** @type {boolean} */
  this.isProperty = definition.type === 'property';

  /** @type {string} */
  this.tipPrefix = definition.tipPrefix;

  var description = this.getLocalization(this.descriptionKey());
  if (description) {
    this.description = description();
  }

  var signatureOverride = this.getLocalization(this.signatureOverrideKey());
  if (signatureOverride) {
    this.signatureOverride = signatureOverride();
  }

  /** @type {Array.<parameterInfo>} */
  this.parameterInfos = [];

  for (var paramId = 0;; paramId++) {
    var paramInfo = {};
    /*
     * Parameter names can be specified in the localization file if desired,
     * but will also be pulled from the block definition's paletteParams array.
     */
    var paramName = this.getLocalization(this.parameterNameKey(paramId));
    if (paramName) {
      paramInfo.name = paramName();
    } else {
      paramInfo.name = definition.paletteParams && definition.paletteParams[paramId];
    }
    if (!paramInfo.name) {
      break;
    }

    var paramDesc = this.getLocalization(this.parameterDescriptionKey(paramId));
    if (paramDesc) {
      paramInfo.description = paramDesc();
    }
    if (definition.assetTooltip) {
      paramInfo.assetTooltip = definition.assetTooltip[paramId];
    }
    this.parameterInfos.push(paramInfo);
  }
};

/**
 * @param {string} key
 * @returns {Function}
 */
DropletFunctionTooltip.prototype.getLocalization = function (key) {
  return this.appMsg[key] || msg[key];
};

/**
 * @returns {string}
 */
DropletFunctionTooltip.prototype.descriptionKey = function () {
  return this.i18nPrefix() + "_description";
};

/**
 * @returns {string}
 */
DropletFunctionTooltip.prototype.signatureOverrideKey = function () {
  return this.i18nPrefix() + "_signatureOverride";
};

/**
 * @param {Number} paramIndex
 * @returns {string}
 */
DropletFunctionTooltip.prototype.parameterNameKey = function (paramIndex) {
  return this.i18nPrefix() + "_param" + paramIndex;
};

/**
 * @param {Number} paramIndex
 * @returns {string}
 */
DropletFunctionTooltip.prototype.parameterDescriptionKey = function (paramIndex) {
  return this.i18nPrefix() + "_param" + paramIndex + '_description';
};

/**
 * @returns {string} i18n file prefix for this function
 */
DropletFunctionTooltip.prototype.i18nPrefix = function () {
  return DROPLET_BLOCK_I18N_PREFIX + this.functionName;
};

/**
 * @returns {string} URL for full doc about this function
 */
DropletFunctionTooltip.prototype.getFullDocumentationURL = function () {
  return '//' + utils.getPegasusHost() + '/applab/docs/' + this.functionName + '?embedded';
};

module.exports = DropletFunctionTooltip;

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","../utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompletePopupTooltipManager.js":[function(require,module,exports){
'use strict';

var DropletFunctionTooltipMarkup = require('./DropletFunctionTooltip.html.ejs');
var dom = require('../dom');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet's ACE editor autocomplete dropdown
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletAutocompletePopupTooltipManager = function DropletAutocompletePopupTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.tooltipsEnabled = true;
};

var DEFAULT_TOOLTIP_CONFIG = {
  interactive: true,
  autoClose: false,
  trigger: 'custom',
  speed: 100,
  maxWidth: 450,
  position: 'left',
  contentAsHTML: true,
  theme: 'droplet-block-tooltipster',
  offsetY: 2,
  restoration: 'none',
  updateAnimation: false
};

/**
 * @param {Editor} dropletEditor
 */
DropletAutocompletePopupTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  var aceEditor = dropletEditor.aceEditor;

  this.editorChangedEventHandler_ = this.setupOnPopupShown_.bind(this, aceEditor);
  aceEditor.commands.on("afterExec", this.editorChangedEventHandler_);
};

/**
 * When an autocomplete popup has been shown the first time, register event
 * handlers to show and hide tooltips during autocomplete popup usage.
 * @param aceEditor - ace editor instance
 * @param changeEvent - event from aceEditor.commands.on("afterExec")
 * @private
 */
DropletAutocompletePopupTooltipManager.prototype.setupOnPopupShown_ = function (aceEditor, changeEvent) {
  if (changeEvent.command.name !== 'insertstring') {
    return;
  }

  var popupHasBeenShownOnce = aceEditor.completer && aceEditor.completer.popup;
  if (!popupHasBeenShownOnce) {
    return;
  }

  this.setupForEditorPopup_(aceEditor);

  aceEditor.commands.removeListener("afterExec", this.editorChangedEventHandler_);
  this.editorChangedEventHandler_ = null;
};

DropletAutocompletePopupTooltipManager.prototype.setupForEditorPopup_ = function (aceEditor) {
  aceEditor.completer.popup.setSelectOnHover(true);

  aceEditor.completer.popup.renderer.on("afterRender", (function () {
    this.updateAutocompletePopupTooltip(aceEditor);
  }).bind(this));

  aceEditor.completer.popup.on("hide", (function () {
    this.destroyAutocompleteTooltips_();
  }).bind(this));
};

DropletAutocompletePopupTooltipManager.prototype.updateAutocompletePopupTooltip = function (aceEditor) {
  if (!this.tooltipsEnabled || !aceEditor.completer.completions) {
    return;
  }

  var keyboardRow = aceEditor.completer.popup.getRow();

  if (keyboardRow < 0) {
    return;
  }

  var filteredCompletions = aceEditor.completer.completions.filtered;
  var funcName = filteredCompletions[keyboardRow].docFunc || filteredCompletions[keyboardRow].value;

  this.destroyAutocompleteTooltips_();

  if (!this.dropletTooltipManager.getDocFor(funcName)) {
    return;
  }

  this.attachTooltipForFunction(funcName);
};

DropletAutocompletePopupTooltipManager.prototype.attachTooltipForFunction = function (funcName) {
  var tooltipDOM = this.getTooltipHTML(funcName);
  var configuration = $.extend({}, DEFAULT_TOOLTIP_CONFIG, {
    content: tooltipDOM,
    functionReady: (function (_, contents) {
      if (!this.showExamplesLink) {
        return;
      }
      var seeExamplesLink = contents.find('.tooltip-example-link > a')[0];
      // Important this binds to mouseDown/touchDown rather than click, needs to
      // happen before `blur` which triggers the ace editor completer popup
      // hide which in turn would hide the link and not show the docs.
      dom.addClickTouchEvent(seeExamplesLink, (function (event) {
        this.dropletTooltipManager.showDocFor(funcName);
        event.stopPropagation();
      }).bind(this));
    }).bind(this)
  });

  var rowOverlayDiv = $('.ace_selected');
  rowOverlayDiv.tooltipster(configuration);
  rowOverlayDiv.tooltipster('show');
};

DropletAutocompletePopupTooltipManager.prototype.destroyAutocompleteTooltips_ = function () {
  $('.ace_autocomplete .tooltipstered').tooltipster('destroy');
};

/**
 * @returns {String} HTML for tooltip
 */
DropletAutocompletePopupTooltipManager.prototype.getTooltipHTML = function (functionName) {
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(functionName);
  var dropletFunctionTooltipMarkup = DropletFunctionTooltipMarkup({
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink
  });
  return dropletFunctionTooltipMarkup;
};

/**
 * @param {boolean} enabled if tooltips are enabled
 */

DropletAutocompletePopupTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipsEnabled = !!enabled;
};

module.exports = DropletAutocompletePopupTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","./DropletFunctionTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletFunctionTooltip.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; function getPrefixedName () {
  return tipPrefix ? tipPrefix + functionName : functionName;
} ; buf.push('\n<div class="function-name">\n  ');5; if (signatureOverride) {; buf.push('    ', escape((5,  signatureOverride )), '\n  ');6; } else if (isProperty) {; buf.push('    ', escape((6,  getPrefixedName() )), '\n  ');7; } else {
    /**
     * TODO(bjordan): would be nice to split the following line up, can't figure
     * out how to do so without inserting extraneous spaces between parameters.
     */
   ; buf.push('    ', escape((12,  getPrefixedName() )), '(');12; for (var i = 0; i < parameters.length; i++) {; buf.push('', (12,  parameters[i].name), '');12; if (i < parameters.length - 1) {; buf.push(', ');12; }; buf.push('');12; }; buf.push(')  ');12; } ; buf.push('\n</div>\n');14; if (functionShortDescription) { ; buf.push('<div>', escape((14,  functionShortDescription )), '</div>');14; } ; buf.push('\n');15; if (showExamplesLink) { ; buf.push('\n  <div class="tooltip-example-link">\n    <a href="javascript:void(0);">See examples</a>\n  </div>\n');19; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletAutocompleteParameterTooltipManager.js":[function(require,module,exports){
/* global ace */
'use strict';

var DropletFunctionTooltipMarkup = require('./DropletParameterTooltip.html.ejs');
var tooltipUtils = require('./tooltipUtils.js');
var dom = require('../dom');
var dropletUtils = require('../dropletUtils');

/**
 * @fileoverview Displays tooltips for Droplet blocks
 */

/**
 * Handles displaying tooltips on Droplet's ACE editor when filling in
 * an empty parameter.
 * Also will augment ACE editor's Live autocomplete by invoking scoped
 * autocomplete dropdowns for each parameter.
 * @param {DropletTooltipManager} dropletTooltipManager
 * @constructor
 */
var DropletAutocompleteParameterTooltipManager = function DropletAutocompleteParameterTooltipManager(dropletTooltipManager) {
  this.dropletTooltipManager = dropletTooltipManager;
  this.showExamplesLink = dropletTooltipManager.dropletConfig.showExamplesLink;
  this.showParamDropdowns = dropletTooltipManager.dropletConfig.showParamDropdowns;
  this.tooltipConfig = {
    interactive: true,
    autoClose: false,
    trigger: 'custom',
    speed: 100,
    maxWidth: 450,
    position: this.showParamDropdowns ? 'top' : 'bottom',
    contentAsHTML: true,
    theme: 'droplet-block-tooltipster',
    offsetY: 2,
    restoration: 'none',
    updateAnimation: false,
    positionTracker: true,
    tooltipsEnabled: true
  };
};

/**
 * @param {Editor} dropletEditor
 */
DropletAutocompleteParameterTooltipManager.prototype.installTooltipsForEditor_ = function (dropletEditor) {
  var aceEditor = dropletEditor.aceEditor;

  var cursorMovementHandler = this.onCursorMovement_.bind(this, aceEditor);
  aceEditor.commands.on('afterExec', cursorMovementHandler);
  aceEditor.on('mousedown', (function (e) {
    this.getCursorTooltip_().tooltipster('hide');
  }).bind(this));
};

/**
 * @param editor - ace editor instance
 * @param changeEvent - event from aceEditor.session.selection.on('changeCursor')
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.onCursorMovement_ = function (editor, changeEvent) {
  this.getCursorTooltip_().tooltipster('hide');

  if (!editor.selection.isEmpty()) {
    return;
  }

  var cursorPosition = editor.selection.getCursor();

  var currentParameterInfo = tooltipUtils.findFunctionAndParamNumber(editor, cursorPosition);
  if (!currentParameterInfo) {
    return;
  }

  if (this.blockDropdownsAndTooltips || this.startingAutoComplete) {
    // Guard against re-entrancy that occurs inside the showParamDropdownIfNeeded_() and the click
    // handlers below
    return;
  }

  if (editor.completer && this.showParamDropdowns) {
    this.showParamDropdownIfNeeded_(editor, currentParameterInfo);
  }

  this.updateParameterTooltip_(editor, currentParameterInfo);
};

/**
 * @param editor - ace editor instance
 * @param paramInfo - parameter info already retrieved based on the cursor position
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.showParamDropdownIfNeeded_ = function (editor, paramInfo) {
  // Check the dropletConfig to see if we can find dropdown info for this parameter
  var dropdownList;
  dropletUtils.getAllAvailableDropletBlocks(this.dropletTooltipManager.dropletConfig, this.dropletTooltipManager.codeFunctions, this.autocompletePaletteApisOnly).forEach(function (block) {
    if (!block.dropdown || block.func !== paramInfo.funcName && block.func !== paramInfo.fullFuncName) {
      // Not the right block or no dropdown specified
      return;
    }
    if (block.noAutocomplete) {
      // Block doesn't want autocomplete, so ignore
      return;
    }
    if (this.dropletTooltipManager.autocompletePaletteApisOnly && this.dropletTooltipManager.codeFunctions && typeof this.dropletTooltipManager.codeFunctions[block.func] === 'undefined') {
      // In autocompletePaletteApisOnly mode and block is not in the palette:
      return;
    }
    if (typeof block.dropdown[paramInfo.currentParameterIndex] === 'function') {
      dropdownList = block.dropdown[paramInfo.currentParameterIndex]();
    } else {
      dropdownList = block.dropdown[paramInfo.currentParameterIndex];
    }
  }, this);

  if (dropdownList && !editor.completer.activated) {
    // The cursor is positioned where a parameter with a dropdown should appear
    // and autocomplete is not already active, so let's pop up a special dropdown
    // autocomplete

    // First, install our hooks to modify the normal ace AutoComplete (these are
    // safe to leave in place, and we can call this multiple times):
    this.installAceCompleterHooks_(editor);

    // Create a new ace completer based on the dropdown info and mark it as the
    // "overrideCompleter" which will stay in place for the next popup from
    // autocomplete only:
    var dropdownCompletions = [];
    dropdownList.forEach(function (listValue) {
      var valString, valClick;
      if (typeof listValue === 'string') {
        valString = listValue;
      } else {
        // Support the { text: x, display: x } form, but ignore the display field
        valString = listValue.text;
        // Tack on the special click handler if present
        valClick = listValue.click;
      }
      dropdownCompletions.push({
        name: 'dropdown',
        value: valString,
        click: valClick
      });
    });
    editor.completer.overrideCompleter = {
      getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
        callback(null, dropdownCompletions);
      }
    };
    // Mark the we are starting auto-complete so that we can guard against
    // re-entrancy when we see more cursor movement events:
    this.startingAutoComplete = true;
    editor.execCommand("startAutocomplete");
    this.startingAutoComplete = false;
  }
};

DropletAutocompleteParameterTooltipManager.prototype.updateParameterTooltip_ = function (aceEditor, paramInfo) {
  if (!this.tooltipConfig.tooltipsEnabled) {
    return;
  }

  var docFunc;
  if (this.dropletTooltipManager.getDocFor(paramInfo.funcName)) {
    docFunc = paramInfo.funcName;
  } else if (this.dropletTooltipManager.getDocFor(paramInfo.fullFuncName)) {
    docFunc = paramInfo.fullFuncName;
  } else {
    return;
  }
  var tooltipInfo = this.dropletTooltipManager.getDropletTooltip(docFunc);

  var hasTooltipParams = tooltipInfo.parameterInfos.length > 0;
  if (hasTooltipParams && paramInfo.currentParameterIndex >= tooltipInfo.parameterInfos.length) {
    return;
  }

  var cursorTooltip = this.getCursorTooltip_();

  cursorTooltip.tooltipster('content', this.getTooltipHTML(tooltipInfo, paramInfo.currentParameterIndex));
  cursorTooltip.tooltipster('show');

  if (this.showExamplesLink) {
    var seeExamplesLink = $(cursorTooltip.tooltipster('elementTooltip')).find('.tooltip-example-link > a')[0];
    dom.addClickTouchEvent(seeExamplesLink, (function (event) {
      this.dropletTooltipManager.showDocFor(docFunc);
      event.stopPropagation();
    }).bind(this));
  }

  if (!hasTooltipParams) {
    return;
  }

  var chooseAsset = tooltipInfo.parameterInfos[paramInfo.currentParameterIndex].assetTooltip;
  if (chooseAsset) {
    var chooseAssetLink = $(cursorTooltip.tooltipster('elementTooltip')).find('.tooltip-choose-link > a')[0];
    dom.addClickTouchEvent(chooseAssetLink, (function (event) {
      cursorTooltip.tooltipster('hide');
      chooseAsset(function (filename) {
        aceEditor.onTextInput('"' + filename + '"');
      });
      event.stopPropagation();
    }).bind(this));
  }
};

DropletAutocompleteParameterTooltipManager.prototype.getCursorTooltip_ = function () {
  if (!this.cursorTooltip_) {
    this.cursorTooltip_ = $('.droplet-ace .ace_cursor');
    this.cursorTooltip_.tooltipster(this.tooltipConfig);
  }
  return this.cursorTooltip_;
};

/**
 * @returns {String} HTML for tooltip
 */
DropletAutocompleteParameterTooltipManager.prototype.getTooltipHTML = function (tooltipInfo, currentParameterIndex) {
  return DropletFunctionTooltipMarkup({
    funcName: tooltipInfo.functionName,
    functionName: tooltipInfo.functionName,
    isProperty: tooltipInfo.isProperty,
    tipPrefix: tooltipInfo.tipPrefix,
    functionShortDescription: tooltipInfo.description,
    parameters: tooltipInfo.parameterInfos,
    signatureOverride: tooltipInfo.signatureOverride,
    showExamplesLink: this.showExamplesLink,
    currentParameterIndex: currentParameterIndex
  });
};

/**
 * @param editor - ace editor instance
 * @private
 */
DropletAutocompleteParameterTooltipManager.prototype.installAceCompleterHooks_ = function (editor) {
  if (editor.completer.showPopup !== DropletAutocompleteParameterTooltipManager.showPopup) {
    DropletAutocompleteParameterTooltipManager.originalShowPopup = editor.completer.showPopup;
    editor.completer.showPopup = DropletAutocompleteParameterTooltipManager.showPopup;
  }
  if (editor.completer.gatherCompletions !== DropletAutocompleteParameterTooltipManager.gatherCompletions) {
    DropletAutocompleteParameterTooltipManager.originalGatherCompletions = editor.completer.gatherCompletions;
    editor.completer.gatherCompletions = DropletAutocompleteParameterTooltipManager.gatherCompletions;
  }
  if (!editor.completer.insertMatchOverride) {
    editor.completer.insertMatchOverride = DropletAutocompleteParameterTooltipManager.insertMatch.bind(editor.completer, this);
  }
  if (editor.completer.insertMatch !== editor.completer.insertMatchOverride) {
    DropletAutocompleteParameterTooltipManager.originalInsertMatch = editor.completer.insertMatch;
    editor.completer.insertMatch = editor.completer.insertMatchOverride;
  }
};

/**
 * @param this completer instance
 * @param editor ace editor
 * @param callback we pass this through
 */
DropletAutocompleteParameterTooltipManager.gatherCompletions = function (editor, callback) {
  // Override normal ace AutoComplete behavior by using only overrideCompleter
  // instead of the normal set of completers when overrideCompleter is set
  if (this.overrideCompleter) {
    var allCompleters = editor.completers;
    editor.completers = [this.overrideCompleter];

    // Ensure that autoInsert is off so we don't insert immediately when there is only one option:
    editor.completer.autoInsert = false;

    DropletAutocompleteParameterTooltipManager.originalGatherCompletions.call(this, editor, callback);
    editor.completers = allCompleters;
  } else {
    DropletAutocompleteParameterTooltipManager.originalGatherCompletions.call(this, editor, callback);
  }
};

/**
 * @param this completer instance
 * @param editor ace editor
 */
DropletAutocompleteParameterTooltipManager.showPopup = function (editor) {
  // Override normal ace AutoComplete behavior by guaranteeing that overrideCompleter is reset
  // after each call to showPopup()
  DropletAutocompleteParameterTooltipManager.originalShowPopup.call(this, editor);
  this.overrideCompleter = null;
};

/**
 * @param this completer instance
 * @param self DropletAutocompleteParameterTooltipManager instance
 * @param data info passed to ace's insertMatch
 */
DropletAutocompleteParameterTooltipManager.insertMatch = function (self, data) {
  // Modify normal ace AutoComplete behavior by calling our special 'click' handler when supplied
  // and passing it the default implementation of insertMatch() to be called within
  if (!data) {
    data = this.popup.getData(this.popup.getRow());
  }
  if (!data) {
    return false;
  }

  if (data.click) {
    // Execute detach() method here to ensure that the popup goes
    // away before we call the click() method
    this.detach();

    // And hide our cursor tooltip as well:
    self.getCursorTooltip_().tooltipster('hide');

    // Note: stop dropdowns and tooltips until the callback is complete...
    self.blockDropdownsAndTooltips = true;

    var lang = ace.require("./lib/lang");

    // Use delayedCall so the popup and tooltip disappear in the case where the
    // Enter key was pressed before we choose this autocomplete item
    var clickFunc = lang.delayedCall((function () {
      // We create a callback function which the click function will call, passing a
      // string which will be inserted.
      data.click((function (data) {
        this.editor.execCommand("insertstring", data);
        self.blockDropdownsAndTooltips = false;
      }).bind(this));
    }).bind(this));

    clickFunc.schedule();
  } else {
    DropletAutocompleteParameterTooltipManager.originalInsertMatch.call(this, data);
  }
};

/**
 * @param {boolean} enabled if tooltips should be enabled
 */
DropletAutocompleteParameterTooltipManager.prototype.setTooltipsEnabled = function (enabled) {
  this.tooltipConfig.tooltipsEnabled = !!enabled;
};

module.exports = DropletAutocompleteParameterTooltipManager;

},{"../dom":"/home/ubuntu/staging/apps/build/js/dom.js","../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./DropletParameterTooltip.html.ejs":"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletParameterTooltip.html.ejs","./tooltipUtils.js":"/home/ubuntu/staging/apps/build/js/blockTooltips/tooltipUtils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/tooltipUtils.js":[function(require,module,exports){
/* global ace */
'use strict';

var utils = require('../utils');
var _ = utils.getLodash();

/**
 * @typedef {Object} parameterSlotInfo
 * @property {string} funcName
 * @property {number} currentParameterIndex
 */

var ONLY_WHITESPACE_REGEXP = /^\s*$/;
var ENDING_OF_BLOCK_COMMENT = /\*\/$/;
var START_OF_BLOCK_COMMENT = /^\/\*/;

/**
 * Returns the number of instances of character within string
 * @param {string} string
 * @param {string} character
 * @returns {number}
 */
function countNumberOfCharacter(string, character) {
  return string.split(character).length - 1;
}

function openerMatchesCloser(opener, closer) {
  var closersToOpeners = {
    '}': '{',
    ')': '(',
    ']': '['
  };
  return closersToOpeners[closer] === opener;
}

/**
 * Given an ace editor and row/column position, returns the function
 * name and index of the currently edited parameter.
 * If a parameter is not currently being filled in, returns null.
 * TODO(bjordan): Unit test once ace.require available in utility tests
 * @param editor
 * @param position
 * @returns {parameterSlotInfo|null}
 */
exports.findFunctionAndParamNumber = function (editor, position) {
  var seenCloserStack = [];
  var sameDepthPrecedingCommaCount = 0;

  var TokenIterator = ace.require("./token_iterator").TokenIterator;
  var iterator = new TokenIterator(editor.session, position.row, position.column);

  var token = iterator.getCurrentToken();

  // Special cases for first token

  if (position.column === 0) {
    // At beginning of a line. Step back one for first token.
    token = iterator.stepBackward();
  } else if (token && token.type.match(/^comment/)) {
    var isBlockComment = token.type === "comment.doc" || token.value.match(START_OF_BLOCK_COMMENT);
    if (isBlockComment) {
      var tokenIsEndOfDocComment = token.value.match(ENDING_OF_BLOCK_COMMENT);
      var cursorIsEndOfToken = token.start + token.value.length === position.column;
      var cursorIsEndOfBlockComment = tokenIsEndOfDocComment && cursorIsEndOfToken;
      if (!cursorIsEndOfBlockComment) {
        // Starting within a block comment
        return null;
      }
    } else {
      // Starting within a comment
      return null;
    }
  }

  while (token) {
    switch (token.type) {
      case "paren.rparen":
        var closers = token.value.split();
        for (var i = closers.length - 1; i >= 0; i--) {
          var currentCloser = closers[i];
          seenCloserStack.push(currentCloser);
        }
        break;
      case "paren.lparen":
        var openers = token.value.split();
        for (var j = openers.length - 1; j >= 0; j--) {
          var currentOpener = openers[j];

          var isBeginningOfFunctionCall = seenCloserStack.length === 0 && currentOpener === '(';
          if (isBeginningOfFunctionCall) {
            var funcName = iterator.stepBackward().value;
            // if we have text "foo.bar(", store "foo.bar" as fullFuncName and
            // "*.bar" as funcName:
            var fullFuncName;
            var previousToken = iterator.stepBackward();
            if (previousToken && previousToken.value === '.') {
              fullFuncName = iterator.stepBackward().value + '.' + funcName;
              funcName = '*.' + funcName;
            }

            return {
              funcName: funcName,
              fullFuncName: fullFuncName,
              currentParameterIndex: sameDepthPrecedingCommaCount
            };
          }

          var lastCloser = seenCloserStack.pop();
          if (!lastCloser || !openerMatchesCloser(currentOpener, lastCloser)) {
            return null;
          }
        }
        break;
      case "punctuation.operator":
        if (seenCloserStack.length === 0) {
          if (_.contains(token.value, ';')) {
            return null;
          }
          if (_.contains(token.value, ',')) {
            sameDepthPrecedingCommaCount += countNumberOfCharacter(token.value, ',');
          }
        }
        break;
      case "comment":
      case "comment.doc":
        break;
      case "text":
        // Whitespace or random non-identifier characters
        if (seenCloserStack.length !== 0 || token.value.match(ONLY_WHITESPACE_REGEXP)) {
          break;
        }
        return null;
      case "string":
      case "storage.type":
      case "identifier":
      /* falls through */
      default:
        if (seenCloserStack.length === 0 && sameDepthPrecedingCommaCount === 0) {
          // Something substantial between cursor and start of parameter slot
          return null;
        }
        break;
    }

    token = iterator.stepBackward();
  }

  return null;
};

},{"../utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/blockTooltips/DropletParameterTooltip.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<div class="function-name">\n  ');2; if (signatureOverride) {; buf.push('    ', escape((2,  signatureOverride )), '\n  ');3; } else {
    /**
     * TODO(bjordan): would be nice to split the following line up, can't figure
     * out how to do so without inserting extraneous spaces between parameters.
     */
   ; buf.push('    ', escape((8,  functionName )), '(');8; for (var i = 0; i < parameters.length; i++) {; buf.push('<span class="tooltip-parameter-name ');8; if (i === currentParameterIndex) { ; buf.push(' current-tooltip-parameter-name');8; } ; buf.push('">', (8,  parameters[i].name), '</span>');8; if (i < parameters.length - 1) {; buf.push(', ');8; }; buf.push('');8; }; buf.push(')  ');8; } ; buf.push('\n</div>\n');10; if (parameters[currentParameterIndex] && parameters[currentParameterIndex].description) { ; buf.push('<div>', escape((10,  parameters[currentParameterIndex].description )), '</div>');10; } ; buf.push('\n');11; if (parameters[currentParameterIndex] && parameters[currentParameterIndex].assetTooltip) { ; buf.push('\n  <div class="tooltip-choose-link">\n    <a href="javascript:void(0);">Choose...</a>\n  </div>\n');15; } ; buf.push('\n');16; if (showExamplesLink) { ; buf.push('\n  <div class="tooltip-example-link">\n    <a href="javascript:void(0);">See examples</a>\n  </div>\n');20; } ; buf.push('\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/authoredHints.js":[function(require,module,exports){
/**
 * @overview helper class to manage the state of the Authored Hint UI.
 * Used exclusively by StudioApp.
 */

'use strict';

var dom = require('./dom');
var msg = require('./locale');
var HintSelect = require('./templates/HintSelect.jsx');
var HintsDisplay = require('./templates/HintsDisplay.jsx');
var authoredHintUtils = require('./authoredHintUtils');
var lightbulbSVG = require('./templates/lightbulb.svg.ejs')();
var lightbulbDimSVG = require('./templates/lightbulb_dim.svg.ejs')();

var AuthoredHints = function AuthoredHints(studioApp) {
  this.studioApp_ = studioApp;

  /**
   * @typedef {Object} AuthoredHint
   * @property {string} content
   * @property {string} hintId
   * @property {string} hintClass
   * @property {string} hintType
   * @property {boolean} alreadySeen
   */
  /**
   * @type {!AuthoredHint[]}
   */
  this.hints_ = [];
  this.contextualHints_ = [];

  /**
   * @type {number}
   */
  this.scrptId_ = undefined;

  /**
   * @type {number}
   */
  this.levelId_ = undefined;

  /**
   * @type {Element}
   */
  this.lightbulb = document.createElement('div');
  this.lightbulb.id = "lightbulb";
};

module.exports = AuthoredHints;

/**
 * @return {AuthoredHints[]}
 */
AuthoredHints.prototype.getUnseenHints = function () {
  var hints = this.contextualHints_.concat(this.hints_ || []);
  return hints.filter(function (hint) {
    return hint.alreadySeen === false;
  });
};

/**
 * @return {AuthoredHints[]}
 */
AuthoredHints.prototype.getSeenHints = function () {
  var hints = this.contextualHints_.concat(this.hints_ || []);
  return hints.filter(function (hint) {
    return hint.alreadySeen === true;
  });
};

/**
 * Creates contextual hints for the specified blocks and adds them to
 * the queue of hints to display. Triggers an animation on the hint
 * lightbulb if the queue has changed.
 * @param {Object[]} blocks @see authoredHintUtils.createContextualHintsFromBlocks
 */
AuthoredHints.prototype.displayMissingBlockHints = function (blocks) {
  var newContextualHints = authoredHintUtils.createContextualHintsFromBlocks(blocks);

  // if the set of contextual hints currently being shown has changed,
  // animate the hint display lightbulb when we update it.
  var oldContextualHints = this.contextualHints_.filter(function (hint) {
    return hint.alreadySeen === false;
  });
  var animateLightbulb = oldContextualHints.length !== newContextualHints.length;

  this.contextualHints_ = newContextualHints;
  this.updateLightbulbDisplay_(animateLightbulb);
};

/**
 * @param {Object} response
 */
AuthoredHints.prototype.finishHints = function (response) {
  authoredHintUtils.finishHints({
    time: new Date().getTime() - this.studioApp_.initTime,
    attempt: this.studioApp_.attempts,
    testResult: this.studioApp_.lastTestResult,
    activityId: response && response.activity_id,
    levelSourceId: response && response.level_source_id
  });
};

/**
 * @param {string} url
 */
AuthoredHints.prototype.submitHints = function (url) {
  authoredHintUtils.submitHints(url);
};

/**
 * @param {AuthoredHint[]} hints
 * @param {number} scriptId
 * @param {number} levelId
 */
AuthoredHints.prototype.init = function (hints, scriptId, levelId) {
  this.hints_ = hints;
  this.scriptId_ = scriptId;
  this.levelId_ = levelId;
};

/**
 * Sets up the Authored Hints UI; decorates the specified element with a
 * lightbulb image and hint counter, and adds a click handler to show
 * a qtip for the next unseen hint.
 *
 * @param {Element} promptIcon - the page element to "decorate" with the
 *        lightbulb
 * @param {Element} clickTarget
 * @param {function} callback - a StudioApp function to be treated as
 *        the "default" action when there are no unseen hints. 
 */
AuthoredHints.prototype.display = function (promptIcon, clickTarget, callback) {
  this.promptIcon = promptIcon;
  this.updateLightbulbDisplay_();
  clickTarget.addEventListener('click', (function () {
    var hintsToShow = this.getUnseenHints();
    if (hintsToShow.length > 0) {
      this.showHint_(hintsToShow[0], callback);
    } else {
      callback();
    }
  }).bind(this));
};

/**
 * Mostly a passthrough to authoredHintUtils.recordUnfinishedHint. Also
 * marks the given hint as seen.
 * @param {AuthoredHint} hint
 */
AuthoredHints.prototype.recordUserViewedHint_ = function (hint) {
  hint.alreadySeen = true;
  this.updateLightbulbDisplay_();

  authoredHintUtils.recordUnfinishedHint({
    // level info
    scriptId: this.scriptId_,
    levelId: this.levelId_,

    // hint info
    hintId: hint.hintId,
    hintClass: hint.hintClass,
    hintType: hint.hintType
  });
};

/**
 * Adjusts the displayed number of unseen hints. Dims the lightbulb
 * image if there are no hints. Optionally plays a simple CSS animation
 * to highlight the update.
 * @param {boolean} animate defaults to false
 */
AuthoredHints.prototype.updateLightbulbDisplay_ = function (animate) {
  animate = animate || false;

  var hintCount = this.getUnseenHints().length;

  // If we have hints to show, but are not in the DOM, insert ourselves
  // into the DOM. This can happen when contextual hints appear in a
  // level that was initialized with no hints. Note that we can be in
  // the DOM and have zero hints to show, and that's just fine.
  if (hintCount > 0 && !document.body.contains(this.lightbulb)) {
    this.promptIcon.parentNode.className += ' authored_hints';
    this.promptIcon.parentNode.insertBefore(this.lightbulb, this.promptIcon);
  }

  // If there are more than nine hints, simply display "9+"
  var hintText = hintCount > 9 ? "9+" : hintCount;
  if (hintCount === 0) {
    this.lightbulb.innerHTML = lightbulbDimSVG;
  } else {
    this.lightbulb.innerHTML = lightbulbSVG;
    this.lightbulb.querySelector('#hintCount').textContent = hintText;
  }

  var bulb = document.getElementById("bulb");
  if (animate && bulb) {
    bulb.setAttribute('class', 'animate-hint');
  }
};

AuthoredHints.prototype.getHintsDisplay = function () {
  var hintsDisplay = React.createElement(HintsDisplay, {
    hintReviewTitle: msg.hintReviewTitle(),
    seenHints: this.getSeenHints(),
    unseenHints: this.getUnseenHints(),
    lightbulbSVG: lightbulbSVG,
    onUserViewedHint: (function () {
      var nextHint = this.getUnseenHints()[0];
      this.recordUserViewedHint_(nextHint);
    }).bind(this)
  });

  return hintsDisplay;
};

/**
 * Render a qtip popup containing an interface which gives the user the
 * option of viewing the instructions for the level (along with all
 * previously-viewed hints) or viewing a new hint.
 * @param {AuthoredHint} hint
 * @param {function} callback
 */
AuthoredHints.prototype.showHint_ = function (hint, callback) {
  $('#prompt-icon').qtip({
    content: {
      text: (function (html, api) {
        var container = document.createElement('div');

        var element = React.createElement(HintSelect, {
          showInstructions: (function () {
            api.destroy();
            callback();
          }).bind(this),
          showHint: (function () {
            if (hint.block) {
              var content = document.createElement('div');
              content.innerHTML = hint.content;
              var blockContainer = document.createElement('div');
              blockContainer.style.height = '100px';
              content.appendChild(blockContainer);
              api.set('content.text', content);

              Blockly.BlockSpace.createReadOnlyBlockSpace(blockContainer, hint.block);
            } else {
              api.set('content.text', hint.content);
            }
            $(api.elements.content).find('img').on('load', function (e) {
              api.reposition(e);
            });
            this.recordUserViewedHint_(hint);
          }).bind(this)
        });

        React.render(element, container);

        return container;
      }).bind(this),
      title: {
        button: $('<div class="tooltip-x-close"/>')
      }
    },
    style: {
      classes: "cdo-qtips",
      tip: {
        width: 20,
        height: 20
      }
    },
    position: {
      my: "bottom left",
      at: "top right"
    },
    hide: {
      event: 'unfocus'
    },
    show: false // don't show on mouseover
  }).qtip('show');
};

},{"./authoredHintUtils":"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./templates/HintSelect.jsx":"/home/ubuntu/staging/apps/build/js/templates/HintSelect.jsx","./templates/HintsDisplay.jsx":"/home/ubuntu/staging/apps/build/js/templates/HintsDisplay.jsx","./templates/lightbulb.svg.ejs":"/home/ubuntu/staging/apps/build/js/templates/lightbulb.svg.ejs","./templates/lightbulb_dim.svg.ejs":"/home/ubuntu/staging/apps/build/js/templates/lightbulb_dim.svg.ejs"}],"/home/ubuntu/staging/apps/build/js/templates/lightbulb_dim.svg.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<svg version="1.1"\n	 id="svg3013" inkscape:version="0.48.3.1 r9886" sodipodi:docname="light_bulb_font_awesome.svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:cc="http://creativecommons.org/ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns:dc="http://purl.org/dc/elements/1.1/"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<sodipodi:namedview  inkscape:pageopacity="0" inkscape:window-width="640" inkscape:pageshadow="2" inkscape:window-height="480" inkscape:window-x="0" inkscape:window-y="25" inkscape:window-maximized="0" inkscape:current-layer="svg3013" guidetolerance="10" pagecolor="#ffffff" objecttolerance="10" gridtolerance="10" showgrid="false" inkscape:cx="896" inkscape:cy="896" borderopacity="1" bordercolor="#666666" inkscape:zoom="0.13169643" id="namedview3019">\n	</sodipodi:namedview>\n<path fill="#C9C9C9" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n<g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n		s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n		c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n		c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n		S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n		s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n		c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n		c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n		c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n		C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n		c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n		c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n		c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n		s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n		c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n		s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n		c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n		c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n		C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n		c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n		c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n</g>\n<path fill="#EFB834" d="M1538.775-187.844c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502S1538.775-277.039,1538.775-187.844z"/>\n<g id="g3015_1_" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017_1_" inkscape:connector-curvature="0" fill="#5D5D5D" d="M1092.357,1521.857c0-2.96-1.082-5.521-3.244-7.684\n		c-2.163-2.163-4.724-3.245-7.684-3.245s-5.521,1.082-7.684,3.245c-2.163,2.163-3.244,4.724-3.244,7.684\n		c0,10.473-6.147,18.556-18.442,24.248c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244\n		c-2.163,2.163-3.244,4.724-3.244,7.684c0,2.96,1.081,5.521,3.244,7.684c2.163,2.163,4.724,3.244,7.684,3.244\n		c11.384,0,22.711-1.821,33.981-5.464c11.27-3.643,21.174-9.79,29.712-18.442\n		C1088.088,1543.942,1092.357,1533.696,1092.357,1521.857z M1147,1521.857c0,16.393-3.927,31.647-11.782,45.763\n		s-18.1,25.671-30.737,34.664c-12.636,8.993-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684\n		c-15.368-5.123-29.371-12.181-42.007-21.174s-22.882-20.548-30.737-34.664s-11.782-29.371-11.782-45.763\n		c0-22.995,7.741-43.487,23.223-61.473c2.277-2.505,5.749-6.261,10.416-11.27s8.139-8.766,10.416-11.27\n		c29.143-34.835,45.194-68.759,48.154-101.772h77.866c2.96,33.013,19.011,66.938,48.154,101.772\n		c2.277,2.505,5.749,6.261,10.416,11.27c4.667,5.009,8.14,8.766,10.416,11.27C1139.259,1478.37,1147,1498.862,1147,1521.857z\n		 M1190.714,1521.857c0-35.29-11.725-65.799-35.176-91.527c-10.245-11.156-18.727-21.06-25.443-29.712\n		c-6.717-8.652-13.49-19.524-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713c10.701-6.375,16.051-15.71,16.051-28.005\n		c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857c0-11.839-5.123-21.06-15.368-27.663\n		c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248c-7.172-5.692-15.995-8.538-26.468-8.538\n		c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879c-10.701,0-20.605,2.96-29.712,8.879\n		c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538c-7.172,5.692-10.758,13.775-10.758,24.248\n		c0,5.464,1.48,10.815,4.44,16.051c-10.245,6.603-15.368,15.824-15.368,27.663c0,8.424,2.846,15.71,8.538,21.857\n		c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.63,16.051,28.005c-0.911,11.384-4.781,23.622-11.612,36.713\n		c-6.83,13.091-13.604,23.963-20.32,32.615c-6.717,8.652-15.198,18.556-25.443,29.712c-23.451,25.728-35.176,56.237-35.176,91.527\n		c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496c16.507,12.864,35.176,22.995,56.009,30.395\n		s42.064,11.099,63.693,11.099c21.629,0,42.86-3.7,63.693-11.099c20.833-7.4,39.502-17.531,56.009-30.395\n		c16.507-12.864,29.826-29.029,39.958-48.496C1185.648,1565.401,1190.714,1544.397,1190.714,1521.857z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1558.582" y1="-332.9" x2="1645.578" y2="-381.84"/>\n	<path fill="#EFB834" d="M1558.141-333.685c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n		c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.463-3.3,6.831-5.055\n		c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n		c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n		c2.529-0.971,4.998-1.751,7.331-2.377c4.656-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n		c0.843,0.007,1.313,0.047,1.313,0.047l0.882,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n		c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n		c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n		c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n		c-2.511,1.004-4.885,1.953-7.076,2.83c-2.188,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n		c-2.587,0.968-4.08,1.494-4.08,1.494L1558.141-333.685z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1577.348" y1="-130.992" x2="1674.509" y2="-108.117"/>\n	<path fill="#EFB834" d="M1577.555-131.868c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n		c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n		c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.246,0.691,9.346,0.922\n		c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.856,0.628,5.548,1.531,8.064,2.543\n		c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n		c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n		c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n		c-1.416-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n		c-2.968-1.004-5.943-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n		c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n		c-2.559-1.039-4.015-1.663-4.015-1.663L1577.555-131.868z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1587.559" y1="-239.3" x2="1687.37" y2="-240.315"/>\n	<path fill="#EFB834" d="M1587.55-240.2c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n		c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n		c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.299-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n		c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n		c2.684,0.366,5.224,0.871,7.569,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n		c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.726,0.45-1.793,1.031-3.151,1.687\n		c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n		c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n		c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n		c-2.684-0.329-5.222-0.639-7.564-0.926c-2.343-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n		c-2.734-0.397-4.296-0.655-4.296-0.655L1587.55-240.2z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1220.661" y1="-328.236" x2="1133.665" y2="-377.176"/>\n	<path fill="#EFB834" d="M1220.22-327.452c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n		c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n		c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n		c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n		c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.875-1.229-1.53-2.251-1.95-2.995\n		c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.573,0.111\n		c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.802,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n		c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n		c2.573,1.789,5.161,3.549,7.677,5.341c2.53,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n		c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.116,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n		c2.171,1.708,3.396,2.711,3.396,2.711L1220.22-327.452z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1205.895" y1="-129.328" x2="1108.734" y2="-106.453"/>\n	<path fill="#EFB834" d="M1206.101-128.452c0,0-1.455,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n		c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n		c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n		c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n		c-2.7,0.231-5.288,0.295-7.703,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n		c-0.808-0.241-1.248-0.41-1.248-0.41l-0.412-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n		c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n		c1.431-0.302,2.901-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n		c3.104-0.425,6.202-0.882,9.266-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n		c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n		c2.754-0.212,4.335-0.303,4.335-0.303L1206.101-128.452z"/>\n</g>\n<g>\n	<line fill="#EFB834" x1="1197.684" y1="-234.636" x2="1097.873" y2="-235.651"/>\n	<path fill="#EFB834" d="M1197.675-233.736c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n		c-1.904,0.25-4.051,0.568-6.394,0.849c-2.342,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n		c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n		c-1.538,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n		c-2.677-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n		c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.813-0.994,3.185-1.622\n		c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n		c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n		c3.116,0.329,6.233,0.626,9.3,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.921,0.398,5.744,0.75,8.421,1.142\n		c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n		c2.725,0.453,4.282,0.742,4.282,0.742L1197.675-233.736z"/>\n</g>\n<path fill="#C9C9C9" d="M2633.883-46.319c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n	c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n	c0-89.195,64.542-161.502,144.159-161.502C2569.341-207.82,2633.883-135.514,2633.883-46.319z"/>\n<g id="g3015_2_" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n	<path id="path3017_2_" inkscape:connector-curvature="0" fill="#5D5D5D" d="M2187.466,1380.332c0-2.96-1.082-5.521-3.244-7.684\n		c-2.163-2.163-4.724-3.244-7.684-3.244c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n		c0,10.473-6.147,18.556-18.442,24.248c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244\n		c-2.163,2.163-3.244,4.724-3.244,7.684s1.082,5.521,3.244,7.684c2.163,2.163,4.724,3.244,7.684,3.244\n		c11.384,0,22.711-1.821,33.981-5.464c11.27-3.643,21.174-9.79,29.712-18.442\n		C2183.197,1402.416,2187.466,1392.171,2187.466,1380.332z M2242.108,1380.332c0,16.393-3.927,31.647-11.782,45.763\n		c-7.855,14.116-18.1,25.671-30.737,34.664s-26.638,16.051-42.007,21.174c-15.368,5.123-30.907,7.684-46.617,7.684\n		c-15.71,0-31.249-2.561-46.617-7.684c-15.368-5.123-29.371-12.181-42.007-21.174c-12.636-8.993-22.882-20.548-30.737-34.664\n		c-7.855-14.116-11.782-29.37-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473c2.277-2.505,5.749-6.261,10.416-11.27\n		c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n		c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27c4.667,5.009,8.14,8.766,10.417,11.27\n		C2234.367,1336.845,2242.108,1357.336,2242.108,1380.332z M2285.823,1380.332c0-35.29-11.726-65.799-35.177-91.527\n		c-10.245-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n		c10.701-6.375,16.052-15.71,16.052-28.005c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n		c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n		c-7.172-5.692-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n		c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n		c-7.172,5.692-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n		c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.63,16.051,28.005\n		c-0.911,11.384-4.781,23.622-11.612,36.713s-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n		c-23.451,25.728-35.176,56.237-35.176,91.527c0,22.54,5.066,43.543,15.198,63.01s23.451,35.632,39.958,48.495\n		c16.507,12.864,35.176,22.996,56.009,30.395c20.833,7.4,42.063,11.099,63.693,11.099c21.629,0,42.86-3.7,63.693-11.099\n		c20.833-7.4,39.502-17.531,56.009-30.395c16.507-12.864,29.826-29.029,39.958-48.495\n		C2280.757,1423.875,2285.823,1402.872,2285.823,1380.332z"/>\n</g>\n</svg>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/lightbulb.svg.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('<svg version="1.1"\n	 id="svg3013" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" sodipodi:docname="light_bulb_font_awesome.svg" inkscape:version="0.48.3.1 r9886"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px"\n	 viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n<g id="bulb">\n  <path fill="#EFB834" d="M453.775,353.156c0,24.012-57.189,128.942-61.414,132.265c-12.384,9.741-48.514,15.318-82.869,16.518\n    c-8.362,0.292-16.619,0.325-24.403,0.096c-20.716-0.611-38.081-3.079-45.155-7.464c-6.896-4.274-74.477-119.24-74.477-141.415\n    c0-89.195,64.542-161.502,144.159-161.502S453.775,263.961,453.775,353.156z"/>\n  <g id="g3015" transform="matrix(1,0,0,-1,379.66102,1293.0169)">\n    <path id="path3017" inkscape:connector-curvature="0" fill="#5D5D5D" d="M7.357,980.857c0-2.96-1.081-5.521-3.244-7.684\n      s-4.724-3.244-7.684-3.244s-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684c0,10.473-6.147,18.556-18.442,24.248\n      c-12.295,5.692-24.362,8.538-36.201,8.538c-2.96,0-5.521,1.081-7.684,3.244s-3.244,4.724-3.244,7.684\n      c0,2.96,1.081,5.521,3.244,7.684s4.724,3.244,7.684,3.244c11.384,0,22.711-1.821,33.981-5.464s21.174-9.79,29.712-18.442\n      S7.357,992.696,7.357,980.857z M62,980.857c0,16.393-3.927,31.647-11.782,45.763s-18.1,25.671-30.737,34.664\n      s-26.638,16.051-42.007,21.174s-30.907,7.684-46.617,7.684s-31.249-2.561-46.617-7.684s-29.371-12.181-42.007-21.174\n      c-12.636-8.993-22.882-20.548-30.737-34.664c-7.855-14.116-11.782-29.371-11.782-45.763c0-22.996,7.741-43.487,23.223-61.473\n      c2.277-2.504,5.749-6.261,10.416-11.27c4.667-5.009,8.14-8.766,10.416-11.27c29.143-34.835,45.194-68.759,48.154-101.772h77.866\n      c2.96,33.013,19.011,66.938,48.154,101.772c2.277,2.504,5.749,6.261,10.416,11.27s8.14,8.766,10.416,11.27\n      C54.259,937.37,62,957.862,62,980.857z M105.714,980.857c0-35.29-11.725-65.799-35.176-91.527\n      c-10.246-11.156-18.727-21.06-25.443-29.712s-13.49-19.523-20.32-32.615c-6.83-13.092-10.701-25.329-11.612-36.713\n      c10.701-6.375,16.051-15.71,16.051-28.004c0-8.424-2.846-15.71-8.538-21.857c5.692-6.147,8.538-13.433,8.538-21.857\n      c0-11.839-5.123-21.06-15.368-27.663c2.96-5.237,4.44-10.587,4.44-16.051c0-10.473-3.586-18.556-10.758-24.248\n      s-15.994-8.538-26.468-8.538c-4.554-10.018-11.384-17.987-20.491-23.906c-9.107-5.92-19.011-8.879-29.712-8.879\n      c-10.701,0-20.605,2.96-29.712,8.879c-9.107,5.92-15.938,13.888-20.491,23.906c-10.473,0-19.296,2.846-26.468,8.538\n      s-10.758,13.775-10.758,24.248c0,5.464,1.48,10.815,4.44,16.051c-10.246,6.603-15.368,15.824-15.368,27.663\n      c0,8.424,2.846,15.71,8.538,21.857c-5.692,6.147-8.538,13.433-8.538,21.857c0,12.295,5.35,21.629,16.051,28.004\n      c-0.911,11.384-4.781,23.622-11.612,36.713c-6.83,13.091-13.604,23.963-20.32,32.615s-15.198,18.556-25.443,29.712\n      C-232.275,915.058-244,945.567-244,980.857c0,22.54,5.066,43.544,15.198,63.01c10.132,19.467,23.451,35.632,39.958,48.496\n      c16.507,12.864,35.176,22.995,56.009,30.395s42.064,11.099,63.693,11.099s42.86-3.7,63.693-11.099s39.502-17.531,56.009-30.395\n      c16.507-12.864,29.826-29.029,39.958-48.496C100.648,1024.401,105.714,1003.397,105.714,980.857z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="473.582" y1="208.1" x2="560.578" y2="159.16"/>\n    <path fill="#EFB834" d="M473.141,207.315c0,0,1.225-1.003,3.396-2.711c1.08-0.864,2.402-1.894,3.925-3.063\n      c1.525-1.167,3.227-2.514,5.117-3.927c1.887-1.418,3.931-2.954,6.092-4.578c2.158-1.632,4.462-3.3,6.831-5.055\n      c2.386-1.723,4.843-3.519,7.372-5.285c2.515-1.791,5.104-3.552,7.677-5.341c2.578-1.778,5.065-3.721,7.503-5.648\n      c1.228-0.948,2.436-1.907,3.665-2.792c1.231-0.881,2.478-1.695,3.736-2.442c2.527-1.472,5.12-2.629,7.656-3.587\n      c2.529-0.971,4.998-1.751,7.331-2.377c4.655-1.268,8.797-1.858,11.81-2.069c1.504-0.109,2.718-0.138,3.572-0.111\n      c0.843,0.007,1.313,0.047,1.313,0.047l0.883,1.569c0,0-0.21,0.422-0.641,1.146c-0.42,0.744-1.075,1.766-1.95,2.995\n      c-1.745,2.465-4.4,5.698-7.9,9.019c-1.746,1.669-3.694,3.374-5.838,5.031c-2.136,1.671-4.471,3.285-7.041,4.681\n      c-1.291,0.687-2.635,1.331-4.027,1.925c-1.394,0.591-2.841,1.126-4.289,1.683c-2.914,1.083-5.865,2.2-8.723,3.48\n      c-2.865,1.27-5.713,2.568-8.55,3.788c-2.823,1.245-5.633,2.412-8.345,3.556c-2.729,1.113-5.352,2.217-7.867,3.213\n      c-2.511,1.004-4.885,1.953-7.076,2.83c-2.189,0.881-4.224,1.637-6.013,2.334c-1.79,0.695-3.357,1.29-4.656,1.764\n      c-2.587,0.968-4.08,1.494-4.08,1.494L473.141,207.315z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="492.348" y1="410.008" x2="589.509" y2="432.883"/>\n    <path fill="#EFB834" d="M492.555,409.132c0,0,1.581,0.091,4.335,0.303c1.38,0.095,3.05,0.232,4.962,0.403\n      c1.912,0.173,4.077,0.334,6.424,0.574c2.348,0.234,4.892,0.487,7.583,0.755c2.693,0.259,5.519,0.592,8.45,0.904\n      c2.923,0.347,5.947,0.688,9.004,1.101c3.064,0.384,6.161,0.841,9.266,1.266c3.102,0.437,6.247,0.691,9.346,0.922\n      c1.546,0.133,3.084,0.246,4.588,0.426c1.502,0.185,2.972,0.43,4.403,0.732c2.857,0.628,5.548,1.531,8.064,2.543\n      c2.519,0.998,4.864,2.095,7.004,3.213c4.285,2.219,7.732,4.588,10.093,6.472c1.181,0.938,2.094,1.738,2.704,2.337\n      c0.615,0.576,0.934,0.923,0.934,0.923l-0.412,1.752c0,0-0.44,0.169-1.248,0.41c-0.813,0.263-1.987,0.572-3.463,0.885\n      c-2.953,0.633-7.096,1.216-11.92,1.29c-2.414,0.046-5.003-0.018-7.702-0.249c-2.703-0.216-5.515-0.609-8.351-1.322\n      c-1.415-0.368-2.84-0.804-4.267-1.309c-1.426-0.509-2.853-1.095-4.296-1.665c-2.878-1.176-5.805-2.351-8.776-3.344\n      c-2.968-1.004-5.944-1.977-8.857-3c-2.92-0.995-5.779-2.038-8.549-3.032c-2.762-1.029-5.44-1.992-7.965-2.961\n      c-2.528-0.961-4.918-1.869-7.124-2.708c-2.207-0.833-4.217-1.655-6.005-2.353c-1.788-0.7-3.344-1.323-4.621-1.854\n      c-2.559-1.039-4.015-1.663-4.015-1.663L492.555,409.132z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="502.559" y1="301.7" x2="602.37" y2="300.685"/>\n    <path fill="#EFB834" d="M502.55,300.8c0,0,1.557-0.289,4.282-0.742c1.362-0.237,3.017-0.504,4.915-0.795\n      c1.898-0.289,4.039-0.65,6.375-0.979c2.336-0.334,4.867-0.697,7.544-1.08c2.677-0.392,5.5-0.744,8.421-1.142\n      c2.921-0.362,5.939-0.753,9.006-1.084c3.067-0.359,6.183-0.656,9.3-0.985c3.116-0.317,6.23-0.823,9.296-1.339\n      c1.533-0.24,3.053-0.499,4.556-0.683c1.503-0.18,2.989-0.293,4.45-0.342c2.924-0.073,5.753,0.16,8.438,0.542\n      c2.685,0.366,5.224,0.871,7.57,1.446c4.691,1.13,8.605,2.607,11.347,3.872c1.371,0.629,2.449,1.187,3.185,1.622\n      c0.735,0.412,1.128,0.673,1.128,0.673l0.018,1.8c0,0-0.387,0.269-1.114,0.696c-0.727,0.45-1.793,1.031-3.151,1.687\n      c-2.716,1.321-6.6,2.877-11.266,4.102c-2.333,0.622-4.862,1.179-7.539,1.599c-2.676,0.436-5.5,0.727-8.425,0.713\n      c-1.462-0.019-2.95-0.102-4.456-0.251c-1.506-0.153-3.032-0.381-4.569-0.59c-3.075-0.454-6.199-0.895-9.321-1.149\n      c-3.122-0.266-6.244-0.499-9.318-0.796c-3.073-0.268-6.099-0.598-9.026-0.9c-2.928-0.338-5.758-0.634-8.442-0.971\n      c-2.684-0.329-5.222-0.639-7.564-0.926c-2.342-0.281-4.49-0.599-6.394-0.849c-1.903-0.253-3.563-0.486-4.93-0.695\n      c-2.734-0.397-4.296-0.655-4.296-0.655L502.55,300.8z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="135.661" y1="212.764" x2="48.665" y2="163.824"/>\n    <path fill="#EFB834" d="M135.22,213.548c0,0-1.493-0.526-4.08-1.494c-1.299-0.474-2.866-1.069-4.656-1.764\n      c-1.789-0.697-3.824-1.453-6.013-2.334c-2.191-0.876-4.565-1.826-7.076-2.83c-2.515-0.996-5.138-2.1-7.867-3.213\n      c-2.712-1.144-5.522-2.312-8.345-3.556c-2.837-1.22-5.686-2.518-8.55-3.788c-2.859-1.28-5.81-2.397-8.723-3.48\n      c-1.448-0.557-2.895-1.092-4.289-1.683c-1.392-0.594-2.736-1.238-4.027-1.925c-2.57-1.396-4.905-3.01-7.041-4.681\n      c-2.143-1.657-4.092-3.363-5.838-5.031c-3.5-3.32-6.155-6.554-7.9-9.019c-0.874-1.229-1.53-2.251-1.95-2.995\n      c-0.431-0.724-0.641-1.146-0.641-1.146l0.883-1.569c0,0,0.47-0.04,1.313-0.047c0.854-0.027,2.068,0.002,3.572,0.111\n      c3.013,0.211,7.155,0.801,11.81,2.069c2.332,0.625,4.801,1.406,7.331,2.377c2.537,0.958,5.129,2.115,7.656,3.587\n      c1.258,0.746,2.505,1.561,3.736,2.442c1.229,0.885,2.437,1.844,3.665,2.792c2.438,1.928,4.925,3.87,7.503,5.648\n      c2.573,1.789,5.161,3.549,7.677,5.341c2.529,1.766,4.986,3.562,7.372,5.285c2.368,1.755,4.673,3.423,6.831,5.055\n      c2.162,1.625,4.206,3.16,6.092,4.578c1.889,1.413,3.592,2.76,5.117,3.927c1.523,1.169,2.845,2.199,3.925,3.063\n      c2.17,1.708,3.396,2.711,3.396,2.711L135.22,213.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="120.895" y1="411.672" x2="23.734" y2="434.547"/>\n    <path fill="#EFB834" d="M121.101,412.548c0,0-1.456,0.623-4.015,1.663c-1.277,0.53-2.833,1.153-4.621,1.854\n      c-1.788,0.698-3.798,1.52-6.005,2.353c-2.206,0.838-4.596,1.747-7.124,2.708c-2.526,0.969-5.203,1.932-7.965,2.961\n      c-2.77,0.993-5.629,2.037-8.549,3.032c-2.914,1.023-5.889,1.996-8.857,3c-2.971,0.993-5.899,2.169-8.776,3.344\n      c-1.443,0.57-2.87,1.156-4.296,1.665c-1.427,0.505-2.852,0.941-4.267,1.309c-2.836,0.713-5.648,1.105-8.351,1.321\n      c-2.699,0.231-5.288,0.295-7.702,0.249c-4.824-0.074-8.967-0.657-11.92-1.29c-1.476-0.313-2.65-0.621-3.463-0.885\n      c-0.808-0.241-1.248-0.41-1.248-0.41l-0.413-1.752c0,0,0.319-0.347,0.934-0.923c0.61-0.598,1.523-1.399,2.704-2.337\n      c2.36-1.884,5.808-4.254,10.093-6.472c2.14-1.119,4.485-2.216,7.004-3.213c2.516-1.012,5.207-1.915,8.064-2.543\n      c1.431-0.302,2.9-0.547,4.403-0.732c1.503-0.181,3.042-0.293,4.588-0.426c3.1-0.232,6.245-0.486,9.346-0.922\n      c3.104-0.425,6.201-0.882,9.265-1.266c3.057-0.412,6.081-0.754,9.004-1.101c2.931-0.312,5.757-0.644,8.45-0.904\n      c2.691-0.268,5.235-0.521,7.583-0.755c2.347-0.239,4.512-0.4,6.424-0.574c1.913-0.171,3.583-0.308,4.962-0.403\n      c2.754-0.212,4.335-0.303,4.335-0.303L121.101,412.548z"/>\n  </g>\n  <g>\n    <line fill="#EFB834" x1="112.684" y1="306.364" x2="12.873" y2="305.349"/>\n    <path fill="#EFB834" d="M112.675,307.264c0,0-1.562,0.257-4.296,0.655c-1.367,0.21-3.026,0.443-4.93,0.695\n      c-1.904,0.25-4.051,0.568-6.394,0.849c-2.343,0.287-4.88,0.598-7.564,0.926c-2.684,0.337-5.514,0.633-8.442,0.971\n      c-2.928,0.302-5.953,0.632-9.026,0.9c-3.074,0.297-6.195,0.53-9.318,0.796c-3.122,0.254-6.246,0.696-9.321,1.149\n      c-1.537,0.209-3.063,0.437-4.569,0.59c-1.506,0.149-2.994,0.232-4.456,0.251c-2.925,0.014-5.749-0.277-8.425-0.713\n      c-2.676-0.421-5.205-0.977-7.539-1.599c-4.667-1.225-8.55-2.781-11.266-4.102c-1.358-0.656-2.424-1.237-3.151-1.687\n      c-0.727-0.427-1.114-0.696-1.114-0.696l0.018-1.8c0,0,0.393-0.261,1.128-0.673c0.736-0.435,1.814-0.994,3.185-1.622\n      c2.742-1.265,6.657-2.742,11.347-3.872c2.345-0.575,4.885-1.079,7.57-1.446c2.685-0.382,5.514-0.615,8.438-0.542\n      c1.462,0.049,2.947,0.162,4.45,0.342c1.503,0.184,3.024,0.443,4.556,0.683c3.065,0.516,6.18,1.021,9.296,1.339\n      c3.116,0.329,6.232,0.626,9.299,0.985c3.067,0.33,6.085,0.722,9.006,1.084c2.92,0.398,5.744,0.75,8.421,1.142\n      c2.677,0.383,5.208,0.745,7.544,1.08c2.336,0.329,4.477,0.69,6.375,0.979c1.898,0.291,3.552,0.558,4.915,0.795\n      c2.725,0.453,4.282,0.742,4.282,0.742L112.675,307.264z"/>\n  </g>\n</g>\n<g id="count">\n  <text x="400" y="700" id="hintCount"></text>\n</g>\n</svg>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/build/js/templates/HintsDisplay.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');
var Hint = require('./Hint.jsx');

/**
 * @overview React Component for displaying Authored Hints in the
 * Instructions dialog. Any hints the user has already requested to see
 * are listed, along with a button to see the next hint.
 * Pressing the button adds the next hint (or the first hint if none
 * have previously been viewed) to the list of hints and removes the
 * button.
 * Closing the instructions and re-opening them will reset this
 * Component, allowing the button to be pressed once more.
 */
module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    hintReviewTitle: React.PropTypes.string.isRequired,
    seenHints: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    unseenHints: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
    onUserViewedHint: React.PropTypes.func.isRequired,
    lightbulbSVG: React.PropTypes.node.isRequired
  },

  getInitialState: function getInitialState() {
    return {
      showNextUnseenHint: false
    };
  },

  viewHint: function viewHint() {
    this.props.onUserViewedHint();
    this.setState({
      showNextUnseenHint: true
    });
  },

  /**
   * Many of our hints include Blockly blocks. Unfortunately, Blockly
   * BlockSpaces have a real problem with being created before they are
   * in the DOM, so we need to inject this BlockSpace outside of our
   * React render method once we're confident that this component is in
   * the DOM.
   */
  injectBlocklyHint: function injectBlocklyHint(hint) {
    var ref = this.refs[hint.hintId];
    ref.injectBlocklyHint();
  },

  componentDidMount: function componentDidMount() {
    // now that we're in the DOM, we can render our Blockly blocks for
    // those hints that have them
    this.props.seenHints.filter(function (hint) {
      return hint.block;
    }).forEach(this.injectBlocklyHint);
  },

  componentDidUpdate: function componentDidUpdate() {
    // if our update has us showing a new hint, make sure to render the
    // block if it has one
    if (this.state.showNextUnseenHint && this.props.unseenHints[0].block) {
      this.injectBlocklyHint(this.props.unseenHints[0]);
    }
  },

  render: function render() {
    var hintsToShow = this.props.seenHints;
    if (this.state.showNextUnseenHint) {
      hintsToShow = hintsToShow.concat(this.props.unseenHints[0]);
    }

    var seenHints;
    if (hintsToShow && hintsToShow.length) {
      seenHints = [React.createElement(
        'h1',
        null,
        this.props.hintReviewTitle
      ), React.createElement(
        'ul',
        null,
        hintsToShow.map(function (hint) {
          return React.createElement(Hint, { hint: hint, ref: hint.hintId });
        })
      )];
    }

    var viewHintButton;
    if (!this.state.showNextUnseenHint && this.props.unseenHints && this.props.unseenHints.length) {
      viewHintButton = React.createElement(
        'button',
        { id: 'hint-button', onClick: this.viewHint, className: 'lightbulb-button' },
        React.createElement('span', { dangerouslySetInnerHTML: { __html: this.props.lightbulbSVG } }),
        msg.hintSelectNewHint()
      );
    }

    return React.createElement(
      'div',
      { className: 'authored-hints' },
      seenHints,
      viewHintButton
    );
  }
});

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js","./Hint.jsx":"/home/ubuntu/staging/apps/build/js/templates/Hint.jsx"}],"/home/ubuntu/staging/apps/build/js/templates/Hint.jsx":[function(require,module,exports){
"use strict";

module.exports = React.createClass({
  displayName: "exports",

  propTypes: {
    hint: React.PropTypes.object.isRequired
  },

  /**
   * @see HintsDisplay.injectBlocklyHint
   */
  injectBlocklyHint: function injectBlocklyHint() {
    var node = React.findDOMNode(this.refs.hintBlock);
    // Only render if the node exists in the DOM
    if (node && document.body.contains(node)) {
      Blockly.BlockSpace.createReadOnlyBlockSpace(node, this.props.hint.block);
    }
  },

  render: function render() {
    var hintBlock;
    if (this.props.hint.block) {
      hintBlock = React.createElement("div", { className: "block-hint", ref: "hintBlock", id: this.props.hint.hintId, style: { maxHeight: '100px' } });
    }
    return React.createElement(
      "li",
      { style: { marginBottom: '12px' } },
      React.createElement("div", { dangerouslySetInnerHTML: { __html: this.props.hint.content } }),
      hintBlock
    );
  }
});

},{}],"/home/ubuntu/staging/apps/build/js/templates/HintSelect.jsx":[function(require,module,exports){
'use strict';

var msg = require('../locale');

module.exports = React.createClass({
  displayName: 'exports',

  propTypes: {
    showInstructions: React.PropTypes.func.isRequired,
    showHint: React.PropTypes.func.isRequired
  },
  render: function render() {
    return React.createElement(
      'div',
      null,
      React.createElement(
        'h4',
        null,
        msg.hintPrompt()
      ),
      React.createElement(
        'a',
        { className: 'btn btn-link show-instructions', onClick: this.props.showInstructions },
        msg.hintSelectInstructions()
      ),
      React.createElement(
        'a',
        { className: 'btn btn-link show-hint', onClick: this.props.showHint },
        msg.hintSelectNewHint()
      )
    );
  }
});

},{"../locale":"/home/ubuntu/staging/apps/build/js/locale.js"}],"/home/ubuntu/staging/apps/build/js/authoredHintUtils.js":[function(require,module,exports){
/* global marked */
'use strict';

var parseXmlElement = require('./xml').parseElement;
var msg = require('./locale');

/**
 * @overview A helper class for all actions associated with the Authored
 * Hint viewing and logging system.
 *
 * The general pattern for usage is straightforward:
 *
 * Every time a user requests to view a new hint, we log information
 * about that hint as well as the most recent attempt.
 *
 * Every time a user makes an "attempt" at the level and send an attempt
 * report, we save some information about that most recent attempt, and
 * add that information to all hint views from the previous attempt.
 *
 * Finally, when the user navigates to a new page (either by completing
 * the level and moving on or by leaving the level and coming back
 * later), we record for all hints the "final" attempt in that session
 * and post the results to the server.
 *
 * Thus, each hint has three attempt records by the end of the
 * lifecycle:
 *  1) a "previous" attempt (can be empty)
 *  2) a "next" attempt
 *  3) a "final" attempt
 */

/**
 * @typedef {Object} HintData
 * @property {number} scriptId
 * @property {number} levelId
 * @property {string} hintId
 * @property {string} hintClass
 * @property {string} hintType
 *
 * @typedef {Object} UnfinishedHint
 * @augments HintData
 * @property {number} [prevTime]
 * @property {number} [prevAttempt]
 * @property {number} [prevTestResult]
 * @property {number} [prevActivityId]
 * @property {number} [prevLevelSourceId]
 *
 * @typedef {Object} FinishedHint
 * @augments UnfinishedHint
 * @property {number} nextTime
 * @property {number} nextAttempt
 * @property {number} nextTestResult
 * @property {number} nextActivityId
 * @property {number} nextLevelSourceId
 *
 * @typedef {Object} FinalizedHint
 * @augments FinishedHint
 * @property {number} finalTime
 * @property {number} finalAttempt
 * @property {number} finalTestResult
 * @property {number} finalActivityId
 * @property {number} finalLevelSourceId
 *
 * @typedef {Object} AttemptRecord
 * @property {number} time
 * @property {number} attempt
 * @property {number} testResult
 * @property {number} activityId
 * @property {number} levelSourceId
 */

var authoredHintUtils = {};

module.exports = authoredHintUtils;

authoredHintUtils.getFromLocalStorage_ = function (key, defaultValue) {
  var result = localStorage.getItem(key);
  try {
    result = result ? JSON.parse(result) : defaultValue;
  } catch (e) {
    result = defaultValue;
  }
  return result;
};

/**
 * @return {UnfinishedHint[]}
 */
authoredHintUtils.getUnfinishedHints_ = function () {
  return authoredHintUtils.getFromLocalStorage_('unfinished_authored_hint_views', []);
};

/**
 * @return {FinishedHint[]}
 */
authoredHintUtils.getFinishedHints_ = function () {
  return authoredHintUtils.getFromLocalStorage_('finished_authored_hint_views', []);
};

/**
 * @return {AttemptRecord}
 */
authoredHintUtils.getLastAttemptRecord_ = function () {
  return authoredHintUtils.getFromLocalStorage_('last_attempt_record', undefined);
};

/**
 * Appends the given hints to the array of existing FinishedHints
 * @param {FinishedHint[]} hints
 */
authoredHintUtils.recordFinishedHints_ = function (hints) {
  var finishedHintViews = authoredHintUtils.getFinishedHints_();
  finishedHintViews = finishedHintViews.concat(hints);
  localStorage.setItem('finished_authored_hint_views', JSON.stringify(finishedHintViews));
};

authoredHintUtils.clearUnfinishedHints = function () {
  localStorage.setItem('unfinished_authored_hint_views', JSON.stringify([]));
};

authoredHintUtils.clearFinishedHints_ = function () {
  localStorage.setItem('finished_authored_hint_views', JSON.stringify([]));
};

/**
 * @return {FinalizedHints[]}
 */
authoredHintUtils.finalizeHints_ = function () {
  var finalAttemptRecord = authoredHintUtils.getLastAttemptRecord_();
  localStorage.removeItem('last_attempt_record');
  var hints = authoredHintUtils.getFinishedHints_();
  if (finalAttemptRecord) {
    hints = hints.map(function (hint) {
      hint = $.extend({
        finalTime: finalAttemptRecord.time,
        finalAttempt: finalAttemptRecord.attempt,
        finalTestResult: finalAttemptRecord.testResult,
        finalActivityId: finalAttemptRecord.activityId,
        finalLevelSourceId: finalAttemptRecord.levelSourceId
      }, hint);
      return hint;
    });
  }
  return hints;
};

/**
 * Adds a hint to the list of "unfinished" hints for the attempt
 * currently in progress. If this is not the first attempt of the
 * session, save along with the hint a record of the most recent
 * attempt.
 *
 * @param {HintData} hint
 */
authoredHintUtils.recordUnfinishedHint = function (hint) {
  var lastAttemptRecord = authoredHintUtils.getLastAttemptRecord_();
  if (lastAttemptRecord) {
    hint = $.extend({
      prevTime: lastAttemptRecord.time,
      prevAttempt: lastAttemptRecord.attempt,
      prevTestResult: lastAttemptRecord.testResult,
      prevActivityId: lastAttemptRecord.activityId,
      prevLevelSourceId: lastAttemptRecord.levelSourceId
    }, hint);
  }
  var unfinishedHintViews = authoredHintUtils.getUnfinishedHints_();
  unfinishedHintViews.push(hint);
  localStorage.setItem('unfinished_authored_hint_views', JSON.stringify(unfinishedHintViews));
};

/**
 * @param {AttemptRecord} nextAttemptRecord
 */
authoredHintUtils.finishHints = function (nextAttemptRecord) {
  if (!nextAttemptRecord) {
    return;
  }
  localStorage.setItem('last_attempt_record', JSON.stringify(nextAttemptRecord));
  var unfinishedHintViews = authoredHintUtils.getUnfinishedHints_();
  authoredHintUtils.clearUnfinishedHints();
  var finishedHintViews = unfinishedHintViews.map(function (hint) {
    hint = $.extend({
      nextTime: nextAttemptRecord.time,
      nextAttempt: nextAttemptRecord.attempt,
      nextTestResult: nextAttemptRecord.testResult,
      nextActivityId: nextAttemptRecord.activityId,
      nextLevelSourceId: nextAttemptRecord.levelSourceId
    }, hint);
    return hint;
  });
  authoredHintUtils.recordFinishedHints_(finishedHintViews);
};

/**
 * @param {string} url
 */
authoredHintUtils.submitHints = function (url) {
  // first, finish all unfinished hints
  var unfinishedHints = authoredHintUtils.getUnfinishedHints_();
  if (unfinishedHints && unfinishedHints.length) {
    var finalHint = unfinishedHints[unfinishedHints.length - 1];
    authoredHintUtils.finishHints({
      time: finalHint.prevTime,
      attempt: finalHint.prevAttempt,
      testResult: finalHint.prevTestResult,
      activityId: finalHint.prevActivityId,
      levelSourceId: finalHint.prevLevelSourceId
    });
  }

  // then, finalize all hints
  var hints = authoredHintUtils.finalizeHints_();

  // now, all hints should be finished and finalized. So submit them all
  if (hints && hints.length) {
    $.ajax({
      url: url,
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({ hints: hints }),
      complete: function complete() {
        authoredHintUtils.clearFinishedHints_();
      }
    });
  }
};

/**
 * Generates contextual hints as used by StudioApp from Blockly XML
 * @param {Object[]} blocks An array of objects representing the
 *        missing recommended Blockly Blocks for which we want to
 *        create hints.
 * @param {string} blocks[].blockDisplayXML
 * @param {boolean} blocks[].alreadySeen
 * @return {AuthoredHint[]}
 */
authoredHintUtils.createContextualHintsFromBlocks = function (blocks) {
  var hints = blocks.map(function (block) {
    var xmlBlock = parseXmlElement(block.blockDisplayXML);
    var blockType = xmlBlock.firstChild.getAttribute("type");
    return {
      content: marked(msg.recommendedBlockContextualHintTitle()),
      block: xmlBlock,
      hintId: "recommended_block_" + blockType,
      hintClass: 'recommended',
      hintType: 'contextual',
      alreadySeen: block.alreadySeen
    };
  });
  return hints;
};

/**
 * Generates authored hints as used by StudioApp from levelbuilder JSON.
 * @param {string} - JSON representing an array of hints
 * @return {AuthoredHint[]}
 */
authoredHintUtils.generateAuthoredHints = function (levelBuilderAuthoredHints) {
  if (!marked) {
    return [];
  }
  var hints;
  try {
    hints = JSON.parse(levelBuilderAuthoredHints);
  } catch (e) {
    hints = [];
  }
  return hints.map(function (hint) {
    return {
      content: marked(hint.hint_markdown),
      hintId: hint.hint_id,
      hintClass: hint.hint_class,
      hintType: hint.hint_type,
      alreadySeen: false
    };
  });
};

},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./xml":"/home/ubuntu/staging/apps/build/js/xml.js"}],"/home/ubuntu/staging/apps/build/js/xml.js":[function(require,module,exports){
// Serializes an XML DOM node to a string.
'use strict';

exports.serialize = function (node) {
  var serializer = new XMLSerializer();
  return serializer.serializeToString(node);
};

// Parses a single root element string, wrapping it in an <xml/> element
exports.parseElement = function (text) {
  var parser = new DOMParser();
  text = text.trim();
  var dom = text.indexOf('<xml') === 0 ? parser.parseFromString(text, 'text/xml') : parser.parseFromString('<xml>' + text + '</xml>', 'text/xml');
  var errors = dom.getElementsByTagName("parsererror");
  var element = dom.firstChild;
  if (!element) {
    throw new Error('Nothing parsed');
  }
  if (errors.length > 0) {
    throw new Error(exports.serialize(errors[0]));
  }
  if (element !== dom.lastChild) {
    throw new Error('Parsed multiple elements');
  }
  return element;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/assetPrefix.js":[function(require,module,exports){
// For proxying non-https assets
'use strict';

var MEDIA_PROXY = '//' + location.host + '/media?u=';

// starts with http or https
var ABSOLUTE_REGEXP = new RegExp('^https?://', 'i');

var assetPathPrefix = "/v3/assets/";
var channelId;

module.exports.init = function (config) {
  if (config.assetPathPrefix) {
    assetPathPrefix = config.assetPathPrefix;
  }
  if (config.channel) {
    channelId = config.channel;
  }
};

/**
 * If the filename is relative (contains no slashes), then prepend
 * the path to the assets directory for this project to the filename.
 *
 * If the filename URL is absolute, route it through the MEDIA_PROXY.
 * @param {string} filename
 * @returns {string}
 */
module.exports.fixPath = function (filename) {

  if (ABSOLUTE_REGEXP.test(filename)) {
    // We want to be able to handle the case where our filename contains a
    // space, i.e. "www.example.com/images/foo bar.png", even though this is a
    // technically invalid URL. encodeURIComponent will replace space with %20
    // for us, but as soon as it's decoded, we again have an invalid URL. For
    // this reason we first replace space with %20 ourselves, such that we now
    // have a valid URL, and then call encodeURIComponent on the result.
    return MEDIA_PROXY + encodeURIComponent(filename.replace(/ /g, '%20'));
  }

  filename = filename || '';
  if (filename.length === 0) {
    return '/blockly/media/1x1.gif';
  }

  if (filename.indexOf('/') !== -1 || !channelId) {
    return filename;
  }

  return assetPathPrefix + channelId + '/' + filename;
};

},{}],"/home/ubuntu/staging/apps/build/js/assetManagement/assetListStore.js":[function(require,module,exports){
"use strict";

var assets = [];

module.exports = {
  reset: function reset(list) {
    assets = list.slice();
  },

  add: function add(asset) {
    assets.push(asset);
    return assets.slice();
  },

  remove: function remove(filename) {
    assets = assets.filter(function (asset) {
      return asset.filename !== filename;
    });
    return assets.slice();
  },

  list: function list(typeFilter) {
    return typeFilter ? assets.filter(function (asset) {
      return asset.category === typeFilter;
    }) : assets.slice();
  }
};

},{}],"/home/ubuntu/staging/apps/build/js/acemode/mode-javascript_codeorg.js":[function(require,module,exports){
/* global ace */
'use strict';

var dropletUtils = require('../dropletUtils');
var annotationList = require('./annotationList');

exports.defineForAce = function (dropletConfig, unusedConfig, dropletEditor) {
  // define ourselves for ace, so that it knows where to get us
  ace.define("ace/mode/javascript_codeorg", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript", "ace/mode/javascript_highlight_rules", "ace/worker/worker_client", "ace/mode/matching_brace_outdent", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle", "ace/config", "ace/lib/net", "ace/ext/searchbox"], function (acerequire, exports, module) {

    var oop = acerequire("ace/lib/oop");
    var JavaScriptMode = acerequire("ace/mode/javascript").Mode;
    var JavaScriptHighlightRules = acerequire("ace/mode/javascript_highlight_rules").JavaScriptHighlightRules;
    var WorkerModule = acerequire("ace/worker/worker_client");
    var WorkerClient = WorkerModule.WorkerClient;
    if (!window.Worker) {
      // If we don't support web workers, do everything on the UI thread
      WorkerClient = WorkerModule.UIWorkerClient;
      window.Worker = WorkerClient;
    }

    var MatchingBraceOutdent = acerequire("./matching_brace_outdent").MatchingBraceOutdent;
    var CstyleBehaviour = acerequire("./behaviour/cstyle").CstyleBehaviour;
    var CStyleFoldMode = acerequire("./folding/cstyle").FoldMode;

    var Mode = function Mode() {
      this.HighlightRules = JavaScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = new CstyleBehaviour();
      this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, JavaScriptMode);

    (function () {
      // Manually create our highlight rules so that we can modify it
      this.$highlightRules = new JavaScriptHighlightRules();

      // We never want to show any of the builtin keywords in autocomplete
      this.$highlightRules.$keywordList = [];

      this.createWorker = function (session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        var newOptions = {
          unused: true,
          undef: true,
          maxerr: 1000,
          predef: {},
          exported: {}
        };
        // Mark all of our blocks as predefined so that linter doesnt complain about
        // using undefined variables
        dropletUtils.getAllAvailableDropletBlocks(dropletConfig).forEach(function (block) {
          newOptions.predef[block.func] = false;
        });

        if (dropletConfig.additionalPredefValues) {
          dropletConfig.additionalPredefValues.forEach(function (val) {
            newOptions.predef[val] = false;
          });
        }

        // Do the same with unusedConfig if available
        if (unusedConfig) {
          unusedConfig.forEach(function (unusedVar) {
            newOptions.exported[unusedVar] = false;
          });
        }

        annotationList.attachToSession(session, dropletEditor);

        worker.send("changeOptions", [newOptions]);

        worker.on("jslint", annotationList.setJSLintAnnotations);

        worker.on("terminate", function () {
          session.clearAnnotations();
        });

        return worker;
      };

      this.cleanup = function () {
        annotationList.detachFromSession();
      };
    }).call(Mode.prototype);

    exports.Mode = Mode;
  });
};

},{"../dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./annotationList":"/home/ubuntu/staging/apps/build/js/acemode/annotationList.js"}],"/home/ubuntu/staging/apps/build/js/acemode/annotationList.js":[function(require,module,exports){
'use strict';

var errorMapper = require('./errorMapper');

var lintAnnotations = [];
var runtimeAnnotations = [];
var aceSession;
var dropletEditor;

/**
 * Update gutter with our annotation list
 * @private
 */
function updateGutter() {
  if (!aceSession) {
    return;
  }

  if (dropletEditor) {
    // Droplet will call aceSession.setAnnotations() under the hood
    // for us
    dropletEditor.setAnnotations(lintAnnotations.concat(runtimeAnnotations));
  } else {
    aceSession.setAnnotations(lintAnnotations.concat(runtimeAnnotations));
  }
}

/**
 * Object for tracking annotations placed in gutter. General design is as
 * follows:
 * When jslint runs (i.e. code changes) display just jslint errors
 * When code runs, display jslint errors and runtime errors. Runtime errors will
 * go away the next time jstlint gets run (when code changes)
 */
module.exports = {
  detachFromSession: function detachFromSession() {
    aceSession = null;
    dropletEditor = null;
  },

  attachToSession: function attachToSession(session, editor) {
    if (aceSession && session !== aceSession) {
      throw new Error('Already attached to ace session');
    }
    aceSession = session;
    dropletEditor = editor;
  },

  setJSLintAnnotations: function setJSLintAnnotations(jslintResults) {
    errorMapper.processResults(jslintResults);
    // clone annotations in case anyone else has a reference to data
    lintAnnotations = jslintResults.data.slice();
    updateGutter();
  },

  /**
   * @param {string} level
   * @param {number} lineNumber One index line number
   * @param {string} text Error string
   */
  addRuntimeAnnotation: function addRuntimeAnnotation(level, lineNumber, text) {
    var annotation = {
      row: lineNumber - 1,
      col: 0,
      raw: text,
      text: text,
      type: level.toLowerCase()
    };
    runtimeAnnotations.push(annotation);
    updateGutter();
  },

  clearRuntimeAnnotations: function clearRuntimeAnnotations() {
    if (runtimeAnnotations.length === 0) {
      return;
    }
    runtimeAnnotations = [];
    updateGutter();
  }
};

},{"./errorMapper":"/home/ubuntu/staging/apps/build/js/acemode/errorMapper.js"}],"/home/ubuntu/staging/apps/build/js/acemode/errorMapper.js":[function(require,module,exports){
"use strict";

var errorMap = [{
  original: /Assignment in conditional expression/,
  replacement: "For conditionals, use the comparison operator (===) to check if two things are equal."
}, {
  original: /(.*)\sis defined but never used./,
  replacement: "$1 is defined, but it's not called in your program."
}, {
  original: /(.*)\sis not defined./,
  replacement: "$1 hasn't been declared yet."
}];

/**
 * Takes the results of a JSLint pass, and modifies the error text according to
 * our mapping. Note this makes changes in place to the passed in results
 * object.
 */
module.exports.processResults = function (results) {
  results.data.forEach(function (item) {
    if (item.type === 'info') {
      item.type = 'warning';
    }

    errorMap.forEach(function (errorMapping) {
      if (!errorMapping.original.test(item.text)) {
        return;
      }

      item.text = item.text.replace(errorMapping.original, errorMapping.replacement);
    });
  });
};

},{}],"/home/ubuntu/staging/apps/build/js/ResizeSensor.js":[function(require,module,exports){
/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */

/**
 * Class for dimension change detection.
 *
 * @param {Element|Element[]|Elements|jQuery} element
 * @param {Function} callback
 *
 * @constructor
 */
'use strict';

module.exports = function (element, callback) {
    /**
     *
     * @constructor
     */
    function EventQueue() {
        this.q = [];
        this.add = function (ev) {
            this.q.push(ev);
        };

        var i, j;
        this.call = function () {
            for (i = 0, j = this.q.length; i < j; i++) {
                this.q[i].call();
            }
        };
    }

    /**
     * @param {HTMLElement} element
     * @param {String}      prop
     * @returns {String|Number}
     */
    function getComputedStyle(element, prop) {
        if (element.currentStyle) {
            return element.currentStyle[prop];
        } else if (window.getComputedStyle) {
            return window.getComputedStyle(element, null).getPropertyValue(prop);
        } else {
            return element.style[prop];
        }
    }

    /**
     *
     * @param {HTMLElement} element
     * @param {Function}    resized
     */
    function attachResizeEvent(element, resized) {
        if (!element.resizedAttached) {
            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);
        } else if (element.resizedAttached) {
            element.resizedAttached.add(resized);
            return;
        }

        element.resizeSensor = document.createElement('div');
        element.resizeSensor.className = 'resize-sensor';
        var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
        var styleChild = 'position: absolute; left: 0; top: 0;';

        element.resizeSensor.style.cssText = style;
        element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '">' + '<div style="' + styleChild + '"></div>' + '</div>' + '<div class="resize-sensor-shrink" style="' + style + '">' + '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' + '</div>';
        element.appendChild(element.resizeSensor);

        if ('absolute' !== getComputedStyle(element, 'position')) {
            element.style.position = 'relative';
        }

        var expand = element.resizeSensor.childNodes[0];
        var expandChild = expand.childNodes[0];
        var shrink = element.resizeSensor.childNodes[1];
        var shrinkChild = shrink.childNodes[0];

        var lastWidth, lastHeight;

        var reset = function reset() {
            expandChild.style.width = expand.offsetWidth + 10 + 'px';
            expandChild.style.height = expand.offsetHeight + 10 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
            shrink.scrollLeft = shrink.scrollWidth;
            shrink.scrollTop = shrink.scrollHeight;
            lastWidth = element.offsetWidth;
            lastHeight = element.offsetHeight;
        };

        reset();

        var changed = function changed() {
            element.resizedAttached.call();
        };

        var addEvent = function addEvent(el, name, cb) {
            if (el.attachEvent) {
                el.attachEvent('on' + name, cb);
            } else {
                el.addEventListener(name, cb);
            }
        };

        addEvent(expand, 'scroll', function () {
            if (element.offsetWidth > lastWidth || element.offsetHeight > lastHeight) {
                changed();
            }
            reset();
        });

        addEvent(shrink, 'scroll', function () {
            if (element.offsetWidth < lastWidth || element.offsetHeight < lastHeight) {
                changed();
            }
            reset();
        });
    }

    if (element && element.constructor === Array || 'undefined' !== typeof jQuery && element instanceof jQuery || //jquery
    'undefined' !== typeof Elements && element instanceof Elements //mootools
    ) {
            var i = 0,
                j = element.length;
            for (; i < j; i++) {
                attachResizeEvent(element[i], callback);
            }
        } else {
        attachResizeEvent(element, callback);
    }
};

},{}],"/home/ubuntu/staging/apps/build/js/MusicController.js":[function(require,module,exports){
/** @file The maestro! Helper that knows which music tracks can be played, and
 *        which one is playing now, and selects and plays them appropriately. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();

var debugLogging = false;
function debug(msg) {
  if (debugLogging && console && console.info) {
    console.info(new Date().getTime() + ': MusicController: ' + msg);
  }
}

/**
 * @typedef {Object} MusicTrackDefinition
 * External track representation, used to define track info in skins.js.
 *
 * @property {string} name - corresponds to music filenames
 * @property {number} volume - on a 0..1 scale
 * @property {boolean} hasOgg - whether a .ogg version of the file should also
 *           available in addition to the .mp3
 */

/**
 * @typedef {Object} MusicTrack
 * Internal track representation, includes track metadata and references to
 * loaded sound object.
 *
 * @property {string} name
 * @property {string[]} assetUrls
 * @property {number} volume
 * @property {Sound} sound
 * @property {boolean} isLoaded
 */

/**
 * A helper class that handles loading, choosing, playing and stopping
 * background music for certain studio apps (e.g. playlab, craft).
 *
 * @param {AudioPlayer} audioPlayer - Reference to the Sounds object.
 * @param {function} assetUrl - Function for generating paths to static assets
 *        for the current skin.
 * @param {MusicTrackDefinition[]} [trackDefinitions] - List of music assets and
 *        general info about how they should be played. Can be omitted or empty
 *        if no music should be played.
 * @param {Number} [loopRandomWithDelay] - if specified, after a song is
 *        completed, will play a random track after given duration (in ms).
 * @constructor
 */
var MusicController = function MusicController(audioPlayer, assetUrl, trackDefinitions, loopRandomWithDelay) {
  /** @private {AudioPlayer} */
  this.audioPlayer_ = audioPlayer;

  /** @private {function} */
  this.assetUrl_ = assetUrl;

  /** @private {MusicTrack[]} */
  this.trackList_ = buildTrackData(trackDefinitions, assetUrl);

  /** @private {string} */
  this.nowPlaying_ = null;

  /** @private {string} Name of track to play on load */
  this.playOnLoad_ = null;

  /** @private {number} */
  this.loopRandomWithDelay_ = loopRandomWithDelay;

  /**
   * @private {boolean} whether we stopped playing music due to video being
   *          shown
   */
  this.wasPlayingWhenVideoShown_ = false;

  /** @private {number} setTimeout callback identifier for un-binding repeat */
  this.betweenTrackTimeout_ = null;

  // If the video player gets pulled up, make sure we stop the music.
  document.addEventListener('videoShown', (function () {
    debug("video shown");
    if (this.nowPlaying_ || this.betweenTrackTimeout_) {
      this.wasPlayingWhenVideoShown_ = true;

      if (this.betweenTrackTimeout_) {
        window.clearTimeout(this.betweenTrackTimeout_);
        this.betweenTrackTimeout_ = null;
      }
      this.fadeOut();
    }
  }).bind(this));

  // If the video player gets closed, make sure we re-start the music.
  document.addEventListener('videoHidden', (function () {
    if (this.wasPlayingWhenVideoShown_ && this.loopRandomWithDelay_ && !this.nowPlaying_) {
      this.play();
    }
    this.wasPlayingWhenVideoShown_ = false;
  }).bind(this));

  debug('constructed');
};
module.exports = MusicController;

/**
 * Build up initial internal track metadata.
 * @param {MusicTrackDefinition[]} trackDefinitions
 * @param {function} assetUrl
 * @return {MusicTrack[]}
 */
function buildTrackData(trackDefinitions, assetUrl) {
  trackDefinitions = utils.valueOr(trackDefinitions, []);
  return trackDefinitions.map(function (trackDef) {

    var assetUrls = [];
    assetUrls.push(assetUrl(trackDef.name + '.mp3'));
    if (trackDef.hasOgg) {
      assetUrls.push(assetUrl(trackDef.name + '.ogg'));
    }

    return {
      name: trackDef.name,
      assetUrls: assetUrls,
      volume: utils.valueOr(trackDef.volume, 1),
      sound: null,
      isLoaded: false
    };
  });
}

/**
 * Preload all music assets
 */
MusicController.prototype.preload = function () {
  if (!this.audioPlayer_) {
    return;
  }

  this.trackList_.forEach(function (track) {
    track.sound = this.audioPlayer_.registerByFilenamesAndID(track.assetUrls, track.name);
    track.sound.onLoad = (function () {
      debug('done loading ' + track.name);
      track.isLoaded = true;
      if (this.playOnLoad_ === track.name) {
        this.play(track.name);
      }
    }).bind(this);
  }, this);
};

/**
 * Begins playing a particular piece of music immediately.
 * @param {string} trackName
 */
MusicController.prototype.play = function (trackName) {
  debug('play ' + trackName);
  if (!this.audioPlayer_) {
    return;
  }

  var track;
  if (trackName) {
    track = this.getTrackByName_(trackName);
  } else {
    track = this.getRandomTrack_();
  }

  if (!track) {
    // No track to play - throw an exception?
    return;
  }

  if (track.sound && track.isLoaded) {
    debug('playing now');
    var callback = this.whenMusicStopped_.bind(this, track.name);
    track.sound.play({ volume: track.volume, onEnded: callback });
    this.nowPlaying_ = track.name;
  } else {
    debug('not done loading, playing after load');
    this.playOnLoad_ = track.name;
  }
};

/**
 * Stops playing whatever music is currently playing, immediately.
 */
MusicController.prototype.stop = function () {
  if (!this.nowPlaying_) {
    return;
  }

  var sound = this.audioPlayer_.get(this.nowPlaying_);
  if (sound) {
    sound.stop();
  }
};

/**
 * Fades music to nothing, then stops it.
 * @param {number} [durationSeconds] in seconds.  Default 3.
 */
MusicController.prototype.fadeOut = function (durationSeconds) {
  if (!this.nowPlaying_) {
    return;
  }

  durationSeconds = utils.valueOr(durationSeconds, 3);

  // Trigger a fade
  var sound = this.audioPlayer_.get(this.nowPlaying_);
  if (sound) {
    sound.fadeToGain(0, durationSeconds);
  }

  // Stop the audio after the fade.
  // Add a small margin due to poor fade granularity on fallback player.
  window.setTimeout((function () {
    this.stop();
  }).bind(this), 1000 * durationSeconds + 100);
};

/**
 * Callback for when music stops, to update internal state.
 * @param {string} musicName that was playing.  Should be bound when music
 *        is started.
 * @private
 */
MusicController.prototype.whenMusicStopped_ = function (musicName) {
  if (this.nowPlaying_ === musicName) {
    this.nowPlaying_ = null;
  }
  if (this.loopRandomWithDelay_ && !this.wasPlayingWhenVideoShown_) {
    this.betweenTrackTimeout_ = window.setTimeout((function () {
      this.betweenTrackTimeout_ = null;
      if (!this.nowPlaying_ && !this.wasPlayingWhenVideoShown_) {
        this.play();
      }
    }).bind(this), this.loopRandomWithDelay_);
  }
};

/**
 * @param {string} name
 * @returns {MusicTrack|undefined}
 * @private
 */
MusicController.prototype.getTrackByName_ = function (name) {
  return _.find(this.trackList_, function (track) {
    return track.name === name;
  });
};

/**
 * @returns {MusicTrack|undefined}
 * @private
 */
MusicController.prototype.getRandomTrack_ = function () {
  var trackIndex = Math.floor(Math.random() * this.trackList_.length);
  return this.trackList_[trackIndex];
};

},{"./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/JsInterpreterLogger.js":[function(require,module,exports){
/** @file Observes a JSInterpreter and logs to the designated browser console. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var Observer = require('./Observer');

/**
 * Observer responsible for logging to the provided browser console when
 * the interpreter it is observing raises log-worthy events.
 * @constructor
 * @param {Console} window console API
 */
var JsInterpreterLogger = module.exports = function (outputConsole) {
  /** @private {Console} */
  this.outputConsole_ = outputConsole;

  /** @private {Observer} */
  this.observer_ = new Observer();
};

/**
 * Attach the logger to a particular JSInterpreter instance.
 * @param {JSInterpreter} jsInterpreter
 */
JsInterpreterLogger.prototype.attachTo = function (jsInterpreter) {
  this.observer_.observe(jsInterpreter.onExecutionWarning, this.log.bind(this));
};

/**
 * Detach the logger from whatever interpreter instance it is currently
 * attached to, unregistering handlers.
 * Safe to call when the logger is already detached.
 */
JsInterpreterLogger.prototype.detach = function () {
  this.observer_.unobserveAll();
};

/**
 * Log to the console object we were constructed with.
 * @param {*} arguments...
 * @see Console.log
 */
JsInterpreterLogger.prototype.log = function () {
  if (this.outputConsole_ && this.outputConsole_.log) {
    this.outputConsole_.log.apply(this.outputConsole_, arguments);
  }
};

},{"./Observer":"/home/ubuntu/staging/apps/build/js/Observer.js"}],"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.js":[function(require,module,exports){
/** @file Debugger controls and debug console used in our rich JavaScript IDEs */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var CommandHistory = require('./CommandHistory');
var constants = require('./constants');
var DebugArea = require('./DebugArea');
var dom = require('./dom');
var JSInterpreter = require('./JSInterpreter');
var Observer = require('./Observer');
var Slider = require('./slider');
var utils = require('./utils');

var KeyCodes = constants.KeyCodes;
var StepType = JSInterpreter.StepType;

/** @const {number} */
var MIN_DEBUG_AREA_HEIGHT = 120;
/** @const {number} */
var MAX_DEBUG_AREA_HEIGHT = 400;

/**
 * Debugger controls and debug console used in our rich JavaScript IDEs, like
 * App Lab, Game Lab, etc.
 * @param {!function} runApp - callback for "launching" the app, which is used
 *        by the "Step In" button when the app isn't running.
 * @constructor
 */
var JsDebuggerUi = module.exports = function (runApp) {
  /**
   * Reference to currently attached JSInterpreter, null if unattached.
   * @private {JSInterpreter}
   */
  this.jsInterpreter_ = null;

  /** @private {Observer} */
  this.observer_ = new Observer();

  /**
   * Callback for "launching" the app, used by the "Step In" button when the app
   * isn't currently running.
   * @private {function}
   */
  this.runApp_ = runApp;

  /**
   * Browseable history of commands entered into the debug console.
   * @private {CommandHistory}
   */
  this.history_ = new CommandHistory();

  /**
   * Helper that handles open/shut actions for debugger UI
   * @private {DebugArea}
   */
  this.debugOpenShutController_ = null;

  /**
   * Root element for debug UI: div#debug-area
   * @private {HTMLDivElement}
   */
  this.rootDiv_ = null;
};

/**
 * Generate DOM element markup from an ejs file for the debug area.
 * @param {!function} assetUrl - Helper for getting asset URLs.
 * @param {!Object} options
 * @param {!boolean} options.showButtons - Whether to show the debug buttons
 * @param {!boolean} options.showConsole - Whether to show the debug console
 * @returns {string} of HTML markup to be embedded in codeWorkspace.html.ejs
 */
JsDebuggerUi.prototype.getMarkup = function (assetUrl, options) {
  return require('./JsDebuggerUi.html.ejs')({
    assetUrl: assetUrl,
    debugButtons: options.showButtons,
    debugConsole: options.showConsole
  });
};

/**
 * Attach the debugger to a particular JSInterpreter instance.  Reinitializes
 * the UI state and begins listening for interpreter events.
 * @param {JSInterpreter} jsInterpreter
 */
JsDebuggerUi.prototype.attachTo = function (jsInterpreter) {
  this.jsInterpreter_ = jsInterpreter;
  this.observer_.observe(jsInterpreter.onNextStepChanged, this.updatePauseUiState.bind(this));
  this.observer_.observe(jsInterpreter.onPause, this.onPauseContinueButton.bind(this));
  this.observer_.observe(jsInterpreter.onExecutionWarning, this.log.bind(this));

  this.updatePauseUiState();
  this.clearDebugOutput();
  this.clearDebugInput();
};

/**
 * Detach the debugger from whatever interpreter instance it is currently
 * attached to, unregistering handlers and resetting the controls to a
 * 'detached' state.
 * Safe to call when the debugger is already detached.
 */
JsDebuggerUi.prototype.detach = function () {
  this.observer_.unobserveAll();
  this.jsInterpreter_ = null;

  this.resetDebugControls_();
};

/**
 * Element getter for elements within the debugger UI.
 * @type {Function}
 * @private
 * @param {string} selector
 * @returns {HTMLElement}
 */
JsDebuggerUi.prototype.getElement_ = function (selector) {
  var rootDiv = document.getElementById('debug-area');
  if (rootDiv) {
    return rootDiv.querySelector(selector);
  }
  return undefined;
};

/**
 * Post-DOM initialization, which allows this controller to grab all the DOM
 * references it needs, bind handlers, and create any subordinate controllers.
 * @param {!Object} options
 * @param {number} [options.defaultStepSpeed] in range 0..1
 */
JsDebuggerUi.prototype.initializeAfterDomCreated = function (options) {
  // Get references to important elements of the DOM
  this.rootDiv_ = document.getElementById('debug-area');

  // Create controller for open/shut behavior of debug area
  this.debugOpenShutController_ = new DebugArea(this.rootDiv_, document.getElementById('codeTextbox'));

  // Initialize debug speed slider
  var slider = this.rootDiv_.querySelector('#speed-slider');
  if (slider) {
    var sliderXOffset = 10,
        sliderYOffset = 22,
        sliderWidth = 130;
    this.speedSlider_ = new Slider(sliderXOffset, sliderYOffset, sliderWidth, slider);

    // Change default speed (eg Speed up levels that have lots of steps).
    if (options.defaultStepSpeed) {
      this.setStepSpeed(options.defaultStepSpeed);
    }
  }

  // Attach keydown handler for debug console input area
  var debugInput = this.rootDiv_.querySelector('#debug-input');
  if (debugInput) {
    debugInput.addEventListener('keydown', this.onDebugInputKeyDown.bind(this));
  }

  // Attach click handler for focusing on console input when clicking output
  var debugOutput = this.rootDiv_.querySelector('#debug-output');
  if (debugOutput) {
    debugOutput.addEventListener('mouseup', this.onDebugOutputMouseUp.bind(this));
  }

  // Attach handlers for the debug area resize control
  var resizeBar = this.getElement_('#debugResizeBar');
  if (resizeBar) {
    dom.addMouseDownTouchEvent(resizeBar, this.onMouseDownDebugResizeBar.bind(this));

    // Can't use dom.addMouseUpTouchEvent() because it will preventDefault on
    // all touchend events on the page, breaking click events...
    document.body.addEventListener('mouseup', this.onMouseUpDebugResizeBar.bind(this));
    var mouseUpTouchEventName = dom.getTouchEventName('mouseup');
    if (mouseUpTouchEventName) {
      document.body.addEventListener(mouseUpTouchEventName, this.onMouseUpDebugResizeBar.bind(this));
    }
  }

  // Attach handler for console clear button
  var clearButton = this.rootDiv_.querySelector('#clear-console-header');
  if (clearButton) {
    dom.addClickTouchEvent(clearButton, this.clearDebugOutput.bind(this));
  }

  // Attach handlers for debugger controls
  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (pauseButton && continueButton && stepInButton && stepOverButton && stepOutButton) {
    dom.addClickTouchEvent(pauseButton, this.onPauseContinueButton.bind(this));
    dom.addClickTouchEvent(continueButton, this.onPauseContinueButton.bind(this));
    dom.addClickTouchEvent(stepInButton, this.onStepInButton.bind(this));
    dom.addClickTouchEvent(stepOverButton, this.onStepOverButton.bind(this));
    dom.addClickTouchEvent(stepOutButton, this.onStepOutButton.bind(this));
  }
};

/**
 * Get the step delay in milliseconds from the speed slider in the debugger UI.
 * If no speed slider is present, returns undefined.
 * @return {number|undefined}
 */
JsDebuggerUi.prototype.getStepDelay = function () {
  if (this.speedSlider_) {
    return JsDebuggerUi.stepDelayFromStepSpeed(this.speedSlider_.getValue());
  }
  return undefined;
};

/**
 * Set the speed slider position.
 * @param {!number} speed - in range 0..1
 */
JsDebuggerUi.prototype.setStepSpeed = function (speed) {
  if (this.speedSlider_) {
    this.speedSlider_.setValue(speed);
  }
};

/**
 * Exponential conversion from step speed (as slider position, range 0..1) to
 * a step delay in milliseconds.
 * @param {!number} stepSpeed in range 0..1
 * @returns {number} step delay in milliseconds
 */
JsDebuggerUi.stepDelayFromStepSpeed = function (stepSpeed) {
  return 300 * Math.pow(1 - stepSpeed, 2);
};

/**
 * Given some object or message, attempt to log it both to the browser console
 * and to the user-facing debug console.
 * @param {*} output
 */
JsDebuggerUi.prototype.log = function (output) {
  var debugOutputDiv = this.getElement_('#debug-output');
  if (debugOutputDiv) {
    if (debugOutputDiv.textContent.length > 0) {
      debugOutputDiv.textContent += '\n';
    }
    debugOutputDiv.textContent += stringifyNonStrings(output);

    debugOutputDiv.scrollTop = debugOutputDiv.scrollHeight;
  }
};

/**
 * @param {*} object
 * @returns {string}
 */
function stringifyNonStrings(object) {
  if (typeof object === 'string' || object instanceof String) {
    return object;
  } else {
    return JSON.stringify(object);
  }
}

/**
 * Handler for key events in the debug console input box.
 * @param {KeyboardEvent} e
 */
JsDebuggerUi.prototype.onDebugInputKeyDown = function (e) {
  var input = e.target.textContent;
  if (e.keyCode === KeyCodes.ENTER) {
    e.preventDefault();
    this.history_.push(input);
    e.target.textContent = '';
    this.log('> ' + input);
    var jsInterpreter = this.jsInterpreter_;
    if (jsInterpreter) {
      try {
        var result = jsInterpreter.evalInCurrentScope(input);
        this.log('< ' + String(result));
      } catch (err) {
        this.log('< ' + String(err));
      }
    } else {
      this.log('< (not running)');
    }
  } else if (e.keyCode === KeyCodes.UP) {
    e.target.textContent = this.history_.goBack(input);
    moveCaretToEndOfDiv(e.target);
    e.preventDefault(); // Block default Home/End-like behavior in Chrome
  } else if (e.keyCode === KeyCodes.DOWN) {
      e.target.textContent = this.history_.goForward(input);
      moveCaretToEndOfDiv(e.target);
      e.preventDefault(); // Block default Home/End-like behavior in Chrome
    }
};

/**
 * Set the cursor position to the end of the text content in a div element.
 * @see http://stackoverflow.com/a/6249440/5000129
 * @param {!HTMLDivElement} element
 */
function moveCaretToEndOfDiv(element) {
  var range = document.createRange();
  if (element.childNodes.length === 0) {
    return;
  }

  range.setStart(element.lastChild, element.lastChild.nodeValue.length);
  range.collapse(true);

  // Change window selection to new range to set cursor position
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
}

/**
 * On mouseup over the console output, if the user hasn't just selected some
 * text, place the focus in the console input box.
 * @param {MouseEvent} e
 */
JsDebuggerUi.prototype.onDebugOutputMouseUp = function (e) {
  var debugInput = this.getElement_('#debug-input');
  if (debugInput && e.target.tagName === "DIV" && window.getSelection().toString().length === 0) {
    debugInput.focus();
  }
};

/** @type {boolean} */
var draggingDebugResizeBar = false;

/** @type {function} */
var boundMouseMoveHandler;

/** @type {string} */
var mouseMoveTouchEventName;

JsDebuggerUi.prototype.onMouseDownDebugResizeBar = function (event) {
  // When we see a mouse down in the resize bar, start tracking mouse moves:
  var eventSourceElm = event.srcElement || event.target;
  if (eventSourceElm.id === 'debugResizeBar') {
    draggingDebugResizeBar = true;
    boundMouseMoveHandler = this.onMouseMoveDebugResizeBar.bind(this);
    document.body.addEventListener('mousemove', boundMouseMoveHandler);
    mouseMoveTouchEventName = dom.getTouchEventName('mousemove');
    if (mouseMoveTouchEventName) {
      document.body.addEventListener(mouseMoveTouchEventName, boundMouseMoveHandler);
    }

    event.preventDefault();
  }
};

/**
 *  Handle mouse moves while dragging the debug resize bar.
 */
JsDebuggerUi.prototype.onMouseMoveDebugResizeBar = function (event) {
  var codeApp = document.getElementById('codeApp');
  var codeTextbox = document.getElementById('codeTextbox');

  var resizeBar = this.getElement_('#debugResizeBar');
  var rect = resizeBar.getBoundingClientRect();
  var offset = (parseInt(window.getComputedStyle(codeApp).bottom, 10) || 0) - rect.height / 2;
  var newDbgHeight = Math.max(MIN_DEBUG_AREA_HEIGHT, Math.min(MAX_DEBUG_AREA_HEIGHT, window.innerHeight - event.pageY - offset));

  if (this.debugOpenShutController_.isShut()) {
    this.debugOpenShutController_.snapOpen();
  }

  codeTextbox.style.bottom = newDbgHeight + 'px';
  this.rootDiv_.style.height = newDbgHeight + 'px';

  // Fire resize so blockly and droplet handle this type of resize properly:
  utils.fireResizeEvent();
};

JsDebuggerUi.prototype.onMouseUpDebugResizeBar = function () {
  // If we have been tracking mouse moves, remove the handler now:
  if (draggingDebugResizeBar) {
    document.body.removeEventListener('mousemove', boundMouseMoveHandler);
    if (mouseMoveTouchEventName) {
      document.body.removeEventListener(mouseMoveTouchEventName, boundMouseMoveHandler);
    }
    draggingDebugResizeBar = false;
  }
};

/**
 * Empty the contents of the debug console scrollback area.
 */
JsDebuggerUi.prototype.clearDebugOutput = function () {
  var debugOutputDiv = this.getElement_('#debug-output');
  if (debugOutputDiv) {
    debugOutputDiv.textContent = '';
  }
};

/**
 * Empty the debug console input area.
 */
JsDebuggerUi.prototype.clearDebugInput = function () {
  var debugInput = this.getElement_('#debug-input');
  if (debugInput) {
    debugInput.textContent = '';
  }
};

JsDebuggerUi.prototype.onPauseContinueButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    // We have code and are either running or paused
    if (jsInterpreter.paused && jsInterpreter.nextStep === StepType.RUN) {
      jsInterpreter.paused = false;
    } else {
      jsInterpreter.paused = true;
      jsInterpreter.nextStep = StepType.RUN;
    }

    this.updatePauseUiState();
  }
};

JsDebuggerUi.prototype.updatePauseUiState = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (!jsInterpreter) {
    return;
  }

  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var spinner = this.getElement_('#running-spinner');
  var pausedIcon = this.getElement_('#paused-icon');
  if (pauseButton && continueButton && spinner && pausedIcon) {
    if (jsInterpreter.paused && jsInterpreter.nextStep === StepType.RUN) {
      pauseButton.style.display = "none";
      continueButton.style.display = "inline-block";
      continueButton.disabled = false;
      spinner.style.display = 'none';
      pausedIcon.style.display = 'inline-block';
    } else {
      pauseButton.style.display = "inline-block";
      pauseButton.disabled = false;
      continueButton.style.display = "none";
      spinner.style.display = 'inline-block';
      pausedIcon.style.display = 'none';
    }
  }

  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (stepInButton && stepOverButton && stepOutButton) {
    stepInButton.disabled = !jsInterpreter.paused;
    stepOverButton.disabled = !jsInterpreter.paused;
    stepOutButton.disabled = !jsInterpreter.paused;
  }
};

/**
 * Put the debug controls back into a detached state.
 * @private
 */
JsDebuggerUi.prototype.resetDebugControls_ = function () {
  var spinner = this.getElement_('#running-spinner');
  if (spinner) {
    spinner.style.display = 'none';
  }

  var pausedIcon = this.getElement_('#paused-icon');
  if (pausedIcon) {
    pausedIcon.style.display = 'none';
  }

  var pauseButton = this.getElement_('#pauseButton');
  var continueButton = this.getElement_('#continueButton');
  var stepInButton = this.getElement_('#stepInButton');
  var stepOverButton = this.getElement_('#stepOverButton');
  var stepOutButton = this.getElement_('#stepOutButton');
  if (pauseButton && continueButton && stepInButton && stepOverButton && stepOutButton) {
    pauseButton.style.display = "inline-block";
    pauseButton.disabled = true;
    continueButton.style.display = "none";
    stepInButton.disabled = false;
    stepOverButton.disabled = true;
    stepOutButton.disabled = true;
  }
};

JsDebuggerUi.prototype.onStepOverButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    jsInterpreter.paused = true;
    jsInterpreter.nextStep = StepType.OVER;
    this.updatePauseUiState();
  }
};

JsDebuggerUi.prototype.onStepInButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (!jsInterpreter) {
    this.runApp_();
    this.onPauseContinueButton();
    jsInterpreter = this.jsInterpreter_;
  }
  jsInterpreter.paused = true;
  jsInterpreter.nextStep = StepType.IN;
  this.updatePauseUiState();
};

JsDebuggerUi.prototype.onStepOutButton = function () {
  var jsInterpreter = this.jsInterpreter_;
  if (jsInterpreter) {
    jsInterpreter.paused = true;
    jsInterpreter.nextStep = StepType.OUT;
    this.updatePauseUiState();
  }
};

},{"./CommandHistory":"/home/ubuntu/staging/apps/build/js/CommandHistory.js","./DebugArea":"/home/ubuntu/staging/apps/build/js/DebugArea.js","./JSInterpreter":"/home/ubuntu/staging/apps/build/js/JSInterpreter.js","./JsDebuggerUi.html.ejs":"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.html.ejs","./Observer":"/home/ubuntu/staging/apps/build/js/Observer.js","./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./slider":"/home/ubuntu/staging/apps/build/js/slider.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/slider.js":[function(require,module,exports){
/**
 * Blockly Apps: SVG Slider
 *
 * Copyright 2012 Google Inc.
 * http://blockly.googlecode.com/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview A slider control in SVG.
 * @author fraser@google.com (Neil Fraser)
 */
'use strict';
var SVG_NS = require('./constants').SVG_NS;
var dom = require('./dom');

/**
 * Object representing a horizontal slider widget.
 * @param {number} x The horizontal offset of the slider.
 * @param {number} y The vertical offset of the slider.
 * @param {number} width The total width of the slider.
 * @param {!Element} svgParent The SVG element to append the slider to.
 * @param {Function} opt_changeFunc Optional callback function that will be
 *     called when the slider is moved.  The current value is passed.
 * @constructor
 */
var Slider = function Slider(x, y, width, svgParent, opt_changeFunc) {
  this.KNOB_Y_ = y - 12;
  this.KNOB_MIN_X_ = x + 8;
  this.KNOB_MAX_X_ = x + width - 8;
  this.value_ = 0.5;
  this.changeFunc_ = opt_changeFunc;
  this.isAndroid_ = dom.isAndroid();
  this.isIOS_ = dom.isIOS();
  this.isWindowsTouch_ = dom.isWindowsTouch();

  // Draw the slider.
  /*
  <line class="sliderTrack" x1="10" y1="35" x2="140" y2="35" />
  <path id="knob"
      transform="translate(67, 23)"
      d="m 8,0 l -8,8 v 12 h 16 v -12 z" />
  */
  var track = document.createElementNS(SVG_NS, 'line');
  track.setAttribute('class', 'sliderTrack');
  track.setAttribute('x1', x);
  track.setAttribute('y1', y);
  track.setAttribute('x2', x + width);
  track.setAttribute('y2', y);
  svgParent.appendChild(track);
  this.track_ = track;
  var knob = document.createElementNS(SVG_NS, 'path');
  knob.setAttribute('class', 'sliderKnob');
  knob.setAttribute('d', 'm 0,0 l -8,8 v 12 h 16 v -12 z');
  svgParent.appendChild(knob);
  this.knob_ = knob;
  this.setValue(0.5);

  // Find the root SVG object.
  while (svgParent && svgParent.nodeName.toLowerCase() != 'svg') {
    svgParent = svgParent.parentNode;
  }
  this.SVG_ = svgParent;

  // Bind the events to this slider.
  var thisSlider = this;
  dom.addMouseDownTouchEvent(this.knob_, function (e) {
    return thisSlider.knobMouseDown_(e);
  });
  dom.addMouseDownTouchEvent(this.track_, function (e) {
    return thisSlider.trackMouseDown_(e);
  });
  dom.addMouseUpTouchEvent(this.SVG_, Slider.knobMouseUp_);
  dom.addMouseMoveTouchEvent(this.SVG_, Slider.knobMouseMove_);
  // Don't add touch events for mouseover. The UX is better on Android
  // and iOS if the drag action is allowed to continue when the
  // touchmove target moves above or below the SVG element.
  Slider.bindEvent_(document, 'mouseover', Slider.mouseOver_);
};

Slider.activeSlider_ = null;
Slider.startMouseX_ = 0;
Slider.startKnobX_ = 0;

/**
 * Start a drag when clicking down on the knob.
 * @param {!Event} e Mouse-down event.
 * @private
 */
Slider.prototype.knobMouseDown_ = function (e) {
  this.beginDrag_(this.mouseToSvg_(e));

  // Stop browser from attempting to drag the knob.
  e.preventDefault();
  return false;
};

/**
 * Snap the knob to the mouse location and start a drag
 * when clicking on the track (but not on the knob).
 * @param {!Event} e Mouse-down event.
 * @private
 */
Slider.prototype.trackMouseDown_ = function (e) {
  var mouseSVGPosition = this.mouseToSvg_(e);
  this.snapToPosition_(mouseSVGPosition.x);
  this.beginDrag_(mouseSVGPosition);

  // Stop browser from attempting to drag the track.
  e.preventDefault();
  return false;
};

/**
 * Start dragging the slider knob.
 * @param {!Object} mouseStartSVG Mouse start position in SVG space
 * @private
 */
Slider.prototype.beginDrag_ = function (startMouseSVG) {
  Slider.activeSlider_ = this;
  Slider.startMouseX_ = startMouseSVG.x;
  Slider.startKnobX_ = 0;
  var transform = this.knob_.getAttribute('transform');
  if (transform) {
    var r = transform.match(/translate\(\s*([-\d.]+)/);
    if (r) {
      Slider.startKnobX_ = Number(r[1]);
    }
  }
};

/**
 * Snap the slider knob to the clicked position.
 * @param {number} xPosition SVG x-coordinate
 * @private
 */
Slider.prototype.snapToPosition_ = function (xPosition) {
  var x = Math.min(Math.max(xPosition, this.KNOB_MIN_X_), this.KNOB_MAX_X_);
  this.knob_.setAttribute('transform', 'translate(' + x + ',' + this.KNOB_Y_ + ')');

  this.value_ = (x - this.KNOB_MIN_X_) / (this.KNOB_MAX_X_ - this.KNOB_MIN_X_);
  if (this.changeFunc_) {
    this.changeFunc_(this.value_);
  }
};

/**
 * Stop a drag when clicking up anywhere.
 * @param {Event} e Mouse-up event.
 * @private
 */
Slider.knobMouseUp_ = function (e) {
  Slider.activeSlider_ = null;
};

/**
 * Stop a drag when the mouse enters a node not part of the SVG.
 * @param {Event} e Mouse-up event.
 * @private
 */
Slider.mouseOver_ = function (e) {
  if (!Slider.activeSlider_) {
    return;
  }
  // Find the root SVG object.
  for (var node = e.target; node; node = node.parentNode) {
    if (node == Slider.activeSlider_.SVG_) {
      return;
    }
  }
  Slider.knobMouseUp_(e);
};

/**
 * Drag the knob to follow the mouse.
 * @param {!Event} e Mouse-move event.
 * @private
 */
Slider.knobMouseMove_ = function (e) {
  var thisSlider = Slider.activeSlider_;
  if (!thisSlider) {
    return;
  }
  var x = thisSlider.mouseToSvg_(e).x - Slider.startMouseX_ + Slider.startKnobX_;
  thisSlider.snapToPosition_(x);
};

/**
 * Returns the slider's value (0.0 - 1.0).
 * @return {number} Current value.
 */
Slider.prototype.getValue = function () {
  return this.value_;
};

/**
 * Sets the slider's value (0.0 - 1.0).
 * @param {number} value New value.
 */
Slider.prototype.setValue = function (value) {
  this.value_ = Math.min(Math.max(value, 0), 1);
  var x = this.KNOB_MIN_X_ + (this.KNOB_MAX_X_ - this.KNOB_MIN_X_) * this.value_;
  this.knob_.setAttribute('transform', 'translate(' + x + ',' + this.KNOB_Y_ + ')');
};

/**
 * Convert the mouse coordinates into SVG coordinates.
 * @param {!Object} e Object with x and y mouse coordinates.
 * @return {!Object} Object with x and y properties in SVG coordinates.
 * @private
 */
Slider.prototype.mouseToSvg_ = function (e) {
  var svgPoint = this.SVG_.createSVGPoint();
  // Most browsers provide clientX/Y. iOS only provides pageX/Y.
  // Android Chrome only provides coordinates within e.changedTouches.
  if (this.isWindowsTouch_) {
    // Only screenX/Y properly accounts for zooming in on windows touch.
    svgPoint.x = e.screenX;
    svgPoint.y = e.screenY;
  } else if (this.isAndroid_) {
    svgPoint.x = e.changedTouches[0].pageX;
    svgPoint.y = e.changedTouches[0].pageY;
  } else if (this.isIOS_) {
    svgPoint.x = e.pageX;
    svgPoint.y = e.pageY;
  } else {
    svgPoint.x = e.clientX;
    svgPoint.y = e.clientY;
  }
  var matrix = this.SVG_.getScreenCTM().inverse();
  return svgPoint.matrixTransform(matrix);
};

/**
 * Bind an event to a function call.
 * @param {!Element} element Element upon which to listen.
 * @param {string} name Event name to listen to (e.g. 'mousedown').
 * @param {!Function} func Function to call when event is triggered.
 * @private
 */
Slider.bindEvent_ = function (element, name, func) {
  element.addEventListener(name, func, false);
};

module.exports = Slider;

},{"./constants":"/home/ubuntu/staging/apps/build/js/constants.js","./dom":"/home/ubuntu/staging/apps/build/js/dom.js"}],"/home/ubuntu/staging/apps/build/js/constants.js":[function(require,module,exports){
/**
 * @fileoverview Constants used in production code and tests.
 */

/**
 * Enumeration of user program execution outcomes.
 * These are determined by each app.
 */
'use strict';

exports.ResultType = {
  UNSET: 0, // The result has not yet been computed.
  SUCCESS: 1, // The program completed successfully, achieving the goal.
  FAILURE: -1, // The program ran without error but did not achieve goal.
  TIMEOUT: 2, // The program did not complete (likely infinite loop).
  ERROR: -2 // The program generated an error.
};

/**
 * Enumeration of test results.
 * EMPTY_BLOCK_FAIL and EMPTY_FUNCTION_BLOCK_FAIL can only occur if
 * StudioApp.checkForEmptyBlocks_ is true.
 * NOTE: We store the results for user attempts in our db, so changing these
 * values would necessitate a migration
 */
exports.TestResults = {
  // Default value before any tests are run.
  NO_TESTS_RUN: -1,

  // The level was not solved.
  EMPTY_BLOCK_FAIL: 1, // An "if" or "repeat" block was empty.
  TOO_FEW_BLOCKS_FAIL: 2, // Fewer than the ideal number of blocks used.
  LEVEL_INCOMPLETE_FAIL: 3, // Default failure to complete a level.
  MISSING_BLOCK_UNFINISHED: 4, // A required block was not used.
  EXTRA_TOP_BLOCKS_FAIL: 5, // There was more than one top-level block.
  RUNTIME_ERROR_FAIL: 6, // There was a runtime error in the program.
  SYNTAX_ERROR_FAIL: 7, // There was a syntax error in the program.
  MISSING_BLOCK_FINISHED: 10, // The level was solved without required block.
  APP_SPECIFIC_FAIL: 11, // Application-specific failure.
  EMPTY_FUNCTION_BLOCK_FAIL: 12, // A "function" block was empty
  UNUSED_PARAM: 13, // Param declared but not used in function.
  UNUSED_FUNCTION: 14, // Function declared but not used in workspace.
  PARAM_INPUT_UNATTACHED: 15, // Function not called with enough params.
  INCOMPLETE_BLOCK_IN_FUNCTION: 16, // Incomplete block inside a function.
  QUESTION_MARKS_IN_NUMBER_FIELD: 17, // Block has ??? instead of a value.
  EMPTY_FUNCTIONAL_BLOCK: 18, // There's a functional block with an open input
  EXAMPLE_FAILED: 19, // One of our examples didn't match the definition

  // start using negative values, since we consider >= 20 to be "solved"
  NESTED_FOR_SAME_VARIABLE: -2, // We have nested for loops each using the same counter variable
  // NOTE: for smoe period of time, this was -1 and conflicted with NO_TESTS_RUN
  EMPTY_FUNCTION_NAME: -3, // We have a variable or function with the name ""
  MISSING_RECOMMENDED_BLOCK_UNFINISHED: -4, // The level was attempted but not solved without a recommended block
  EXTRA_FUNCTION_FAIL: -5, // The program contains a JavaScript function when it should not
  LOCAL_FUNCTION_FAIL: -6, // The program contains an unexpected JavaScript local function

  // The level was solved in a non-optimal way.  User may advance or retry.
  TOO_MANY_BLOCKS_FAIL: 20, // More than the ideal number of blocks were used.
  APP_SPECIFIC_ACCEPTABLE_FAIL: 21, // Application-specific acceptable failure.
  MISSING_RECOMMENDED_BLOCK_FINISHED: 22, // The level was solved without a recommended block

  // Other.
  FREE_PLAY: 30, // The user is in free-play mode.
  EDIT_BLOCKS: 70, // The user is creating/editing a new level.

  // The level was solved in the ideal manner.
  ALL_PASS: 100
};

exports.BeeTerminationValue = {
  FAILURE: false,
  SUCCESS: true,
  INFINITE_LOOP: Infinity,
  NOT_AT_FLOWER: 1, // Tried to get nectar when not at flower.
  FLOWER_EMPTY: 2, // Tried to get nectar when flower empty.
  NOT_AT_HONEYCOMB: 3, // Tried to make honey when not at honeycomb.
  HONEYCOMB_FULL: 4, // Tried to make honey, but no room at honeycomb.
  UNCHECKED_CLOUD: 5, // Finished puzzle, but didn't check every clouded item
  UNCHECKED_PURPLE: 6, // Finished puzzle, but didn't check every purple flower
  INSUFFICIENT_NECTAR: 7, // Didn't collect all nectar by finish
  INSUFFICIENT_HONEY: 8, // Didn't make all honey by finish
  DID_NOT_COLLECT_EVERYTHING: 9 // For quantum levels, didn't try to collect all available honey/nectar
};

exports.KeyCodes = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 127
};

/** @const {string} SVG element namespace */
exports.SVG_NS = 'http://www.w3.org/2000/svg';

},{}],"/home/ubuntu/staging/apps/build/js/Observer.js":[function(require,module,exports){
/** @file Helper for consuming ObservableEvents. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

/**
 * Helper object for consuming ObservableEvents, designed for composition into
 * other classes.  Remembers what it's observing and provides safer ways to
 * stop observing those things.
 * @constructor
 */
var Observer = module.exports = function () {
  /**
   * @private {Array.<Object>} event-key pairs of observed events, for easy
   *          unregistering later.
   */
  this.observed_ = [];
};

/**
 * Begin observing the given event, forwarding it to the provided callback
 * whenever the event occurs.
 * @param {!ObservableEvent} event
 * @param {!function} callback
 */
Observer.prototype.observe = function (event, callback) {
  var key = event.register(callback);
  this.observed_.push({
    event: event,
    key: key
  });
};

/**
 * Unregister all callbacks from all observed events.
 */
Observer.prototype.unobserveAll = function () {
  this.observed_.forEach(function (observable) {
    observable.event.unregister(observable.key);
  });
  this.observed_.length = 0;
};

},{}],"/home/ubuntu/staging/apps/build/js/JsDebuggerUi.html.ejs":[function(require,module,exports){
module.exports= (function() {
  var t = function anonymous(locals, filters, escape
/**/) {
escape = escape || function (html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
var buf = [];
with (locals || {}) { (function(){ 
 buf.push('');1; var i18n = require('./locale'); ; buf.push('\n\n<div id="debug-area">\n  <div id="debugResizeBar" class="fa fa-ellipsis-h"></div>\n  <div id="debug-area-header">\n    <span class="header-text">', escape((6,  i18n.debugConsoleHeader() )), '</span>\n    <i id="show-hide-debug-icon" class="fa fa-chevron-circle-down"></i>\n    ');8; if (debugButtons) { ; buf.push('\n    <div id="debug-commands-header" class="workspace-header">\n      <i id="running-spinner" style="display: none;" class="fa fa-spinner fa-spin"></i>\n      <i id="paused-icon" style="display: none;" class="fa fa-pause"></i>\n      <span class="header-text">', escape((12,  i18n.debugCommandsHeaderWhenOpen() )), '</span>\n    </div>\n    <div id="clear-console-header" class="workspace-header workspace-header-button"><span><i class="fa fa-eraser"></i>Clear</span></div>\n    ');15; } ; buf.push('\n    <div id="slider-cell" style="margin-left: ', escape((16,  debugButtons ? 0 : 40 )), 'px">\n      <svg id="speed-slider"\n           xmlns="http://www.w3.org/2000/svg"\n           xmlns:svg="http://www.w3.org/2000/svg"\n           xmlns:xlink="http://www.w3.org/1999/xlink"\n           version="1.1"\n           width="150"\n           height="28">\n          <!-- Slow icon. -->\n          <clipPath id="slowClipPath">\n            <rect width=26 height=12 x=5 y=6 />\n          </clipPath>\n          <image xlink:href="', escape((28,  assetUrl('media/turtle_icons.png') )), '" height=42 width=84 x=-21 y=-18\n              clip-path="url(#slowClipPath)" />\n          <!-- Fast icon. -->\n          <clipPath id="fastClipPath">\n            <rect width=26 height=16 x=120 y=2 />\n          </clipPath>\n          <image xlink:href="', escape((34,  assetUrl('media/turtle_icons.png') )), '" height=42 width=84 x=120 y=-19\n              clip-path="url(#fastClipPath)" />\n      </svg>\n    </div>\n  </div>\n\n  ');40; if (debugButtons) { ; buf.push('\n  <div id="debug-commands" class="debug-commands">\n    <div id="debug-buttons">\n      <button id="pauseButton" class="debugger_button">\n        <img src="', escape((44,  assetUrl('media/1x1.gif') )), '" class="pause-btn icon21">\n        ', escape((45,  i18n.pause() )), '\n      </button>\n      <button id="continueButton" class="debugger_button">\n        <img src="', escape((48,  assetUrl('media/1x1.gif') )), '" class="continue-btn icon21">\n        ', escape((49,  i18n.continue() )), '\n      </button>\n      <button id="stepOverButton" class="debugger_button">\n        <img src="', escape((52,  assetUrl('media/1x1.gif') )), '" class="step-over-btn icon21">\n        ', escape((53,  i18n.stepOver() )), '\n      </button>\n      <button id="stepOutButton" class="debugger_button">\n        <img src="', escape((56,  assetUrl('media/1x1.gif') )), '" class="step-out-btn icon21">\n        ', escape((57,  i18n.stepOut() )), '\n      </button>\n      <button id="stepInButton" class="debugger_button">\n        <img src="', escape((60,  assetUrl('media/1x1.gif') )), '" class="step-in-btn icon21">\n        ', escape((61,  i18n.stepIn() )), '\n      </button>\n    </div>\n  </div>\n  ');65; } ; buf.push('\n  ');66; if (debugConsole) { ; buf.push('\n  <div id="debug-console" class="debug-console ', escape((67,  debugButtons ? '' : 'full' )), '">\n    <div id="debug-output" class="debug-output"></div>\n    <span class="debug-input-prompt">\n      &gt;\n    </span>\n    <div contenteditable spellcheck="false" id="debug-input" class="debug-input"></div>\n  </div>\n  ');74; } ; buf.push('\n</div>\n'); })();
} 
return buf.join('');
};
  return function(locals) {
    return t(locals, require("ejs").filters);
  }
}());
},{"./locale":"/home/ubuntu/staging/apps/build/js/locale.js","ejs":"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js"}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/ejs.js":[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils')
  , path = require('path')
  , basename = path.basename
  , dirname = path.dirname
  , extname = path.extname
  , join = path.join
  , fs = require('fs')
  , read = fs.readFileSync;

/**
 * Filters.
 *
 * @type Object
 */

var filters = exports.filters = require('./filters');

/**
 * Intermediate js cache.
 *
 * @type Object
 */

var cache = {};

/**
 * Clear intermediate js cache.
 *
 * @api public
 */

exports.clearCache = function(){
  cache = {};
};

/**
 * Translate filtered code into function calls.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function filtered(js) {
  return js.substr(1).split('|').reduce(function(js, filter){
    var parts = filter.split(':')
      , name = parts.shift()
      , args = parts.join(':') || '';
    if (args) args = ', ' + args;
    return 'filters.' + name + '(' + js + args + ')';
  });
};

/**
 * Re-throw the given `err` in context to the
 * `str` of ejs, `filename`, and `lineno`.
 *
 * @param {Error} err
 * @param {String} str
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

function rethrow(err, str, filename, lineno){
  var lines = str.split('\n')
    , start = Math.max(lineno - 3, 0)
    , end = Math.min(lines.length, lineno + 3);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;
  
  throw err;
}

/**
 * Parse the given `str` of ejs, returning the function body.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

var parse = exports.parse = function(str, options){
  var options = options || {}
    , open = options.open || exports.open || '<%'
    , close = options.close || exports.close || '%>'
    , filename = options.filename
    , compileDebug = options.compileDebug !== false
    , buf = [];

  buf.push('var buf = [];');
  if (false !== options._with) buf.push('\nwith (locals || {}) { (function(){ ');
  buf.push('\n buf.push(\'');

  var lineno = 1;

  var consumeEOL = false;
  for (var i = 0, len = str.length; i < len; ++i) {
    if (str.slice(i, open.length + i) == open) {
      i += open.length
  
      var prefix, postfix, line = (compileDebug ? '__stack.lineno=' : '') + lineno;
      switch (str.substr(i, 1)) {
        case '=':
          prefix = "', escape((" + line + ', ';
          postfix = ")), '";
          ++i;
          break;
        case '-':
          prefix = "', (" + line + ', ';
          postfix = "), '";
          ++i;
          break;
        default:
          prefix = "');" + line + ';';
          postfix = "; buf.push('";
      }

      var end = str.indexOf(close, i)
        , js = str.substring(i, end)
        , start = i
        , include = null
        , n = 0;

      if ('-' == js[js.length-1]){
        js = js.substring(0, js.length - 2);
        consumeEOL = true;
      }

      if (0 == js.trim().indexOf('include')) {
        var name = js.trim().slice(7).trim();
        if (!filename) throw new Error('filename option is required for includes');
        var path = resolveInclude(name, filename);
        include = read(path, 'utf8');
        include = exports.parse(include, { filename: path, _with: false, open: open, close: close, compileDebug: compileDebug });
        buf.push("' + (function(){" + include + "})() + '");
        js = '';
      }

      while (~(n = js.indexOf("\n", n))) n++, lineno++;
      if (js.substr(0, 1) == ':') js = filtered(js);
      if (js) {
        if (js.lastIndexOf('//') > js.lastIndexOf('\n')) js += '\n';
        buf.push(prefix, js, postfix);
      }
      i += end - start + close.length - 1;

    } else if (str.substr(i, 1) == "\\") {
      buf.push("\\\\");
    } else if (str.substr(i, 1) == "'") {
      buf.push("\\'");
    } else if (str.substr(i, 1) == "\r") {
      // ignore
    } else if (str.substr(i, 1) == "\n") {
      if (consumeEOL) {
        consumeEOL = false;
      } else {
        buf.push("\\n");
        lineno++;
      }
    } else {
      buf.push(str.substr(i, 1));
    }
  }

  if (false !== options._with) buf.push("'); })();\n} \nreturn buf.join('');")
  else buf.push("');\nreturn buf.join('');");

  return buf.join('');
};

/**
 * Compile the given `str` of ejs into a `Function`.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var compile = exports.compile = function(str, options){
  options = options || {};
  var escape = options.escape || utils.escape;
  
  var input = JSON.stringify(str)
    , compileDebug = options.compileDebug !== false
    , client = options.client
    , filename = options.filename
        ? JSON.stringify(options.filename)
        : 'undefined';
  
  if (compileDebug) {
    // Adds the fancy stack trace meta info
    str = [
      'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',
      rethrow.toString(),
      'try {',
      exports.parse(str, options),
      '} catch (err) {',
      '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',
      '}'
    ].join("\n");
  } else {
    str = exports.parse(str, options);
  }
  
  if (options.debug) console.log(str);
  if (client) str = 'escape = escape || ' + escape.toString() + ';\n' + str;

  try {
    var fn = new Function('locals, filters, escape', str);
  } catch (err) {
    if ('SyntaxError' == err.name) {
      err.message += options.filename
        ? ' in ' + filename
        : ' while compiling ejs';
    }
    throw err;
  }

  if (client) return fn;

  return function(locals){
    return fn.call(this, locals, filters, escape);
  }
};

/**
 * Render the given `str` of ejs.
 *
 * Options:
 *
 *   - `locals`          Local variables object
 *   - `cache`           Compiled functions are cached, requires `filename`
 *   - `filename`        Used by `cache` to key caches
 *   - `scope`           Function execution context
 *   - `debug`           Output generated function body
 *   - `open`            Open tag, defaulting to "<%"
 *   - `close`           Closing tag, defaulting to "%>"
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api public
 */

exports.render = function(str, options){
  var fn
    , options = options || {};

  if (options.cache) {
    if (options.filename) {
      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));
    } else {
      throw new Error('"cache" option requires "filename".');
    }
  } else {
    fn = compile(str, options);
  }

  options.__proto__ = options.locals;
  return fn.call(options.scope, options);
};

/**
 * Render an EJS file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  options.filename = path;

  var str;
  try {
    str = options.cache
      ? cache[key] || (cache[key] = read(path, 'utf8'))
      : read(path, 'utf8');
  } catch (err) {
    fn(err);
    return;
  }
  fn(null, exports.render(str, options));
};

/**
 * Resolve include `name` relative to `filename`.
 *
 * @param {String} name
 * @param {String} filename
 * @return {String}
 * @api private
 */

function resolveInclude(name, filename) {
  var path = join(dirname(filename), name);
  var ext = extname(name);
  if (!ext) path += '.ejs';
  return path;
}

// express support

exports.__express = exports.renderFile;

/**
 * Expose to require().
 */

if (require.extensions) {
  require.extensions['.ejs'] = function(module, filename) {
    source = require('fs').readFileSync(filename, 'utf-8');
    module._compile(compile(source, {}), filename);
  };
} else if (require.registerExtension) {
  require.registerExtension('.ejs', function(src) {
    return compile(src, {});
  });
}

},{"./filters":"/home/ubuntu/staging/apps/node_modules/ejs/lib/filters.js","./utils":"/home/ubuntu/staging/apps/node_modules/ejs/lib/utils.js","fs":"/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js","path":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/path-browserify/index.js"}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/utils.js":[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};
 
},{}],"/home/ubuntu/staging/apps/node_modules/ejs/lib/filters.js":[function(require,module,exports){

/*!
 * EJS - Filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * First element of the target `obj`.
 */

exports.first = function(obj) {
  return obj[0];
};

/**
 * Last element of the target `obj`.
 */

exports.last = function(obj) {
  return obj[obj.length - 1];
};

/**
 * Capitalize the first letter of the target `str`.
 */

exports.capitalize = function(str){
  str = String(str);
  return str[0].toUpperCase() + str.substr(1, str.length);
};

/**
 * Downcase the target `str`.
 */

exports.downcase = function(str){
  return String(str).toLowerCase();
};

/**
 * Uppercase the target `str`.
 */

exports.upcase = function(str){
  return String(str).toUpperCase();
};

/**
 * Sort the target `obj`.
 */

exports.sort = function(obj){
  return Object.create(obj).sort();
};

/**
 * Sort the target `obj` by the given `prop` ascending.
 */

exports.sort_by = function(obj, prop){
  return Object.create(obj).sort(function(a, b){
    a = a[prop], b = b[prop];
    if (a > b) return 1;
    if (a < b) return -1;
    return 0;
  });
};

/**
 * Size or length of the target `obj`.
 */

exports.size = exports.length = function(obj) {
  return obj.length;
};

/**
 * Add `a` and `b`.
 */

exports.plus = function(a, b){
  return Number(a) + Number(b);
};

/**
 * Subtract `b` from `a`.
 */

exports.minus = function(a, b){
  return Number(a) - Number(b);
};

/**
 * Multiply `a` by `b`.
 */

exports.times = function(a, b){
  return Number(a) * Number(b);
};

/**
 * Divide `a` by `b`.
 */

exports.divided_by = function(a, b){
  return Number(a) / Number(b);
};

/**
 * Join `obj` with the given `str`.
 */

exports.join = function(obj, str){
  return obj.join(str || ', ');
};

/**
 * Truncate `str` to `len`.
 */

exports.truncate = function(str, len){
  str = String(str);
  return str.substr(0, len);
};

/**
 * Truncate `str` to `n` words.
 */

exports.truncate_words = function(str, n){
  var str = String(str)
    , words = str.split(/ +/);
  return words.slice(0, n).join(' ');
};

/**
 * Replace `pattern` with `substitution` in `str`.
 */

exports.replace = function(str, pattern, substitution){
  return String(str).replace(pattern, substitution || '');
};

/**
 * Prepend `val` to `obj`.
 */

exports.prepend = function(obj, val){
  return Array.isArray(obj)
    ? [val].concat(obj)
    : val + obj;
};

/**
 * Append `val` to `obj`.
 */

exports.append = function(obj, val){
  return Array.isArray(obj)
    ? obj.concat(val)
    : obj + val;
};

/**
 * Map the given `prop`.
 */

exports.map = function(arr, prop){
  return arr.map(function(obj){
    return obj[prop];
  });
};

/**
 * Reverse the given `obj`.
 */

exports.reverse = function(obj){
  return Array.isArray(obj)
    ? obj.reverse()
    : String(obj).split('').reverse().join('');
};

/**
 * Get `prop` of the given `obj`.
 */

exports.get = function(obj, prop){
  return obj[prop];
};

/**
 * Packs the given `obj` into json string
 */
exports.json = function(obj){
  return JSON.stringify(obj);
};
},{}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js"}],"/home/ubuntu/staging/apps/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/home/ubuntu/staging/apps/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/home/ubuntu/staging/apps/build/js/JSInterpreter.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */

'use strict';

var codegen = require('./codegen');
var ObservableEvent = require('./ObservableEvent');
var utils = require('./utils');

/**
 * Create a JSInterpreter object. This object wraps an Interpreter object and
 * adds stepping, batching of steps, code highlighting, error handling,
 * breakpoints, general debug capabilities (step in, step out, step over), and
 * an optional event queue.
 * @constructor
 * @param {!Object} options
 * @param {!StudioApp} options.studioApp
 * @param {function} [options.shouldRunAtMaxSpeed]
 * @param {number} [options.maxInterpreterStepsPerTick]
 * @param {Object} [options.customMarshalGlobalProperties]
 */
var JSInterpreter = module.exports = function (options) {
  this.studioApp = options.studioApp;
  this.shouldRunAtMaxSpeed = options.shouldRunAtMaxSpeed || function () {
    return true;
  };
  this.maxInterpreterStepsPerTick = options.maxInterpreterStepsPerTick || 10000;
  this.customMarshalGlobalProperties = options.customMarshalGlobalProperties || {};

  // Publicly-exposed events that anyone with access to the JSInterpreter can
  // observe and respond to.

  /** @type {ObservableEvent} */
  this.onNextStepChanged = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onPause = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onExecutionError = new ObservableEvent();

  /** @type {ObservableEvent} */
  this.onExecutionWarning = new ObservableEvent();

  this.paused = false;
  this.yieldExecution = false;
  this.startedHandlingEvents = false;
  this.executionError = null;
  this.nextStep = StepType.RUN;
  this.maxValidCallExpressionDepth = 0;
  this.executeLoopDepth = 0;
  this.callExpressionSeenAtDepth = [];
  this.stoppedAtBreakpointRows = [];
};

/**
 * Initialize the JSInterpreter, parsing the provided code and preparing to
 * execute it one step at a time.
 *
 * @param {!Object} options - for now, same options passed to the constructor
 * @param {!string} options.code - Code to be executed by the interpreter.
 * @param {Array} [options.blocks] - in dropletConfig.blocks format.  If a block
 *        has a parent property, we will populate that function into the
 *        interpreter global scope.
 * @param {Object} [options.blockFilter] - an object with block-name keys that
 *        should be used to filter which blocks are populated.
 * @param {Array} [options.globalFunctions] - objects containing functions to
 *        place in the interpreter global scope.
 * @param {boolean} [options.enableEvents] - allow the interpreter to define
 *        event handlers that can be invoked by native code. (default false)
 */
JSInterpreter.prototype.parse = function (options) {
  if (!this.studioApp.hideSource) {
    this.calculateCodeInfo(options.code);

    var session = this.studioApp.editor.aceEditor.getSession();
    this.isBreakpointRow = codegen.isAceBreakpointRow.bind(null, session);
  } else {
    this.isBreakpointRow = function () {
      return false;
    };
  }

  var self = this;
  if (options.enableEvents) {
    this.eventQueue = [];
    // Append our mini-runtime after the user's code. This will spin and process
    // callback functions:
    options.code += '\nwhile (true) { var obj = getCallback(); ' + 'if (obj) { var ret = obj.fn.apply(null, obj.arguments ? obj.arguments : null);' + 'setCallbackRetVal(ret); }}';

    codegen.createNativeFunctionFromInterpreterFunction = function (intFunc) {
      return function () {
        if (self.initialized()) {
          self.queueEvent(intFunc, arguments);

          if (self.executeLoopDepth === 0) {
            // Execute the interpreter and if a return value is sent back from the
            // interpreter's event handler, pass that back in the native world

            // NOTE: the interpreter will not execute forever, if the event handler
            // takes too long, executeInterpreter() will return and the native side
            // will just see 'undefined' as the return value. The rest of the interpreter
            // event handler will run in the next onTick(), but the return value will
            // no longer have any effect.
            self.executeInterpreter(false, true);
            return self.lastCallbackRetVal;
          }
        }
      };
    };
  }

  var initFunc = function initFunc(interpreter, scope) {
    // Store Interpreter on JSInterpreter
    self.interpreter = interpreter;
    // Store globalScope on JSInterpreter
    self.globalScope = scope;
    // Override Interpreter's get/set Property functions with JSInterpreter
    interpreter.getProperty = self.getProperty.bind(self, interpreter, interpreter.getProperty);
    // Store this for later because we need to bypass our overriden function
    // in createGlobalProperty()
    self.baseSetProperty = interpreter.setProperty;
    interpreter.setProperty = self.setProperty.bind(self, interpreter, interpreter.setProperty);
    codegen.initJSInterpreter(interpreter, options.blocks, options.blockFilter, scope, options.globalFunctions);

    // Only allow five levels of depth when marshalling the return value
    // since we will occasionally return DOM Event objects which contain
    // properties that recurse over and over...
    var wrapper = codegen.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: self.nativeGetCallback.bind(self),
      maxDepth: 5
    });
    interpreter.setProperty(scope, 'getCallback', interpreter.createNativeFunction(wrapper));

    wrapper = codegen.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: self.nativeSetCallbackRetVal.bind(self)
    });
    interpreter.setProperty(scope, 'setCallbackRetVal', interpreter.createNativeFunction(wrapper));
  };

  try {
    // Return value will be stored as this.interpreter inside the supplied
    // initFunc() (other code in initFunc() depends on this.interpreter, so
    // we can't wait until the constructor returns)
    /* jshint nonew:false */
    new window.Interpreter(options.code, initFunc);
    /* jshint nonew:true */
  } catch (err) {
    this.executionError = err;
    this.handleError();
  }
};

/**
 * Init `this.codeInfo` with cumulative length info (used to locate breakpoints).
 * @param code
 */
JSInterpreter.prototype.calculateCodeInfo = function (code) {
  this.codeInfo = {};
  this.codeInfo.userCodeStartOffset = 0;
  this.codeInfo.userCodeLength = code.length;
  this.codeInfo.cumulativeLength = codegen.calculateCumulativeLength(code);
};

/**
 * Returns true if the JSInterpreter instance initialized successfully. This
 * would typically fail when the program contains a syntax error.
 */
JSInterpreter.prototype.initialized = function () {
  return !!this.interpreter;
};

/**
 * Detech the Interpreter instance. Call before releasing references to
 * JSInterpreter so any async callbacks will not execute.
 */
JSInterpreter.prototype.deinitialize = function () {
  this.interpreter = null;
};

JSInterpreter.StepType = {
  RUN: 0,
  IN: 1,
  OVER: 2,
  OUT: 3
};

/**
 * A miniature runtime in the interpreted world calls this function repeatedly
 * to check to see if it should invoke any callbacks from within the
 * interpreted world. If the eventQueue is not empty, we will return an object
 * that contains an interpreted callback function (stored in "fn") and,
 * optionally, callback arguments (stored in "arguments")
 */
JSInterpreter.prototype.nativeGetCallback = function () {
  this.startedHandlingEvents = true;
  var retVal = this.eventQueue.shift();
  if (typeof retVal === "undefined") {
    this['yield']();
  }
  return retVal;
};

JSInterpreter.prototype.nativeSetCallbackRetVal = function (retVal) {
  if (this.eventQueue.length === 0) {
    // If nothing else is in the event queue, then store this return value
    // away so it can be returned in the native event handler
    this.seenReturnFromCallbackDuringExecution = true;
    this.lastCallbackRetVal = retVal;
  }
  // Provide warnings to the user if this function has been called with a
  // meaningful return value while we are no longer in the native event handler

  // TODO (cpirich): Check to see if the DOM event object was modified
  // (preventDefault(), stopPropagation(), returnValue) and provide a similar
  // warning since these won't work as expected unless running atMaxSpeed
  if (!this.runUntilCallbackReturn && typeof this.lastCallbackRetVal !== 'undefined') {
    this.onExecutionWarning.notifyObservers("Function passed to onEvent() " + "has taken too long - the return value was ignored.");
    if (!this.shouldRunAtMaxSpeed()) {
      this.onExecutionWarning.notifyObservers("  (try moving the speed " + "slider to its maximum value)");
    }
  }
};

/**
 * Queue an event to be fired in the interpreter. The nativeArgs are optional.
 * The function must be an interpreter function object (not native).
 */
JSInterpreter.prototype.queueEvent = function (interpreterFunc, nativeArgs) {
  this.eventQueue.push({
    'fn': interpreterFunc,
    'arguments': nativeArgs ? Array.prototype.slice.call(nativeArgs) : []
  });
};

/**
 * Yield execution (causes executeInterpreter loop to break out if this is
 * called by APIs called by interpreted code)
 */
JSInterpreter.prototype['yield'] = function () {
  this.yieldExecution = true;
};

var StepType = JSInterpreter.StepType;

/**
 * Small helper to step the interpreter so that exception handler can exist outside
 * of the core executeInterpeter() function (improves browser JS engine performance)
 */
function safeStepInterpreter(jsi) {
  try {
    jsi.interpreter.step();
  } catch (err) {
    return err;
  }
}

/**
 * Find a bpRow from the "stopped at breakpoint" array by matching the scope
 *
 * @param {!Object} scope to match from the list
 * @param {number} [row] to match from the list - in addition to scope
 */
JSInterpreter.prototype.findStoppedAtBreakpointRow = function (scope, row) {
  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      if (typeof row === 'undefined' || row === bpRow.row) {
        return bpRow;
      }
    }
  }
};

/**
 * Replace a bpRow from the "stopped at breakpoint" array by matching
 * the scope.
 *
 * If no rows are found matching the given scope, a new one is introduced.
 *
 * @param {!Object} scope to match from the list
 * @param {!number} row to replace in the list.
 * @throws {TypeError} when given an invalid row.
 */
JSInterpreter.prototype.replaceStoppedAtBreakpointRowForScope = function (scope, row) {
  if (typeof row !== 'number' || row < 0) {
    throw new TypeError('Row ' + row + ' is not a valid row in user code.');
  }

  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      // Update row number
      bpRow.row = row;
      return;
    }
  }
  // Scope not found, insert new object in array:
  this.stoppedAtBreakpointRows.unshift({
    row: row,
    scope: scope
  });
};

/**
 * Remove a bpRow from the "stopped at breakpoint" array by matching
 * the scope.
 *
 * Does nothing if no rows are found matching the given scope.
 *
 * @param {!Object} scope to match from the list
 */
JSInterpreter.prototype.removeStoppedAtBreakpointRowForScope = function (scope) {
  for (var i = 0; i < this.stoppedAtBreakpointRows.length; i++) {
    var bpRow = this.stoppedAtBreakpointRows[i];
    if (bpRow.scope === scope) {
      // Remove from array
      this.stoppedAtBreakpointRows.splice(i, 1);
      return;
    }
  }
};

/**
 * Determines if the program is done executing.
 *
 * @return {boolean} true if program is complete (or an error has occurred).
 */
JSInterpreter.prototype.isProgramDone = function () {
  return this.executionError || !this.interpreter || !this.interpreter.stateStack.length;
};

/**
 * Nodes that are visited between expressions, signifying the previous
 * expression is done.
 */
var INTERSTITIAL_NODES = {
  Program: true,
  BlockStatement: true,
  SwitchStatement: true
};

/**
 * Execute the interpreter
 */
JSInterpreter.prototype.executeInterpreter = function (firstStep, runUntilCallbackReturn) {
  this.executeLoopDepth++;
  this.runUntilCallbackReturn = runUntilCallbackReturn;
  if (runUntilCallbackReturn) {
    delete this.lastCallbackRetVal;
  }
  this.yieldExecution = false;
  this.seenReturnFromCallbackDuringExecution = false;

  var atInitialBreakpoint = this.paused && this.nextStep === StepType.IN && firstStep;
  var atMaxSpeed = false;

  if (this.paused) {
    switch (this.nextStep) {
      case StepType.RUN:
        // Bail out here if in a break state (paused), but make sure that we still
        // have the next tick queued first, so we can resume after un-pausing):
        return;
      case StepType.OUT:
        // If we haven't yet set stepOutToStackDepth, work backwards through the
        // history of callExpressionSeenAtDepth until we find the one we want to
        // step out to - and store that in stepOutToStackDepth:
        if (this.interpreter && typeof this.stepOutToStackDepth === 'undefined') {
          this.stepOutToStackDepth = 0;
          for (var i = this.maxValidCallExpressionDepth; i > 0; i--) {
            if (this.callExpressionSeenAtDepth[i]) {
              this.stepOutToStackDepth = i;
              break;
            }
          }
        }
        break;
    }
  }

  var doneUserLine = false;
  var reachedBreak = false;
  var unwindingAfterStep = false;
  var inUserCode;
  var userCodeRow;

  // In each tick, we will step the interpreter multiple times in a tight
  // loop as long as we are interpreting code that the user can't see
  // (function aliases at the beginning, getCallback event loop at the end)
  for (var stepsThisTick = 0; stepsThisTick < this.maxInterpreterStepsPerTick || unwindingAfterStep; stepsThisTick++) {
    // Check this every time because the speed is allowed to change...
    atMaxSpeed = this.shouldRunAtMaxSpeed();
    // NOTE:
    // (1) When running with no source visible AND at max speed, always set
    //   `userCodeRow` to -1. We'll never hit a breakpoint or need to add delay.
    // (2) When running with no source visible OR at max speed, call a simple
    //   function to just get the line number. Need to check `inUserCode` to
    //   maybe stop at a breakpoint, or add a `speed(n)` delay.
    // (3) Otherwise call a function that also highlights the code.
    var selectCodeFunc;
    if (this.studioApp.hideSource && atMaxSpeed) {
      selectCodeFunc = function () {
        return -1;
      };
    } else if (this.studioApp.hideSource || atMaxSpeed) {
      selectCodeFunc = this.getUserCodeLine;
    } else {
      selectCodeFunc = this.selectCurrentCode;
    }
    var currentScope = this.interpreter.getScope();

    if (reachedBreak && !unwindingAfterStep || doneUserLine && !unwindingAfterStep && !atMaxSpeed || this.yieldExecution || this.interpreter.paused_ || runUntilCallbackReturn && this.seenReturnFromCallbackDuringExecution) {
      // stop stepping the interpreter and wait until the next tick once we:
      // (1) reached a breakpoint and are done unwinding OR
      // (2) completed a line of user code and are are done unwinding
      //     (while not running atMaxSpeed) OR
      // (3) we've been asked to yield our executeInterpeter() loop OR
      // (4) the interpreter is paused (handling a native async func that is
      //     going to block to return a value synchronously in the interpreter) OR
      // (5) have seen an empty event queue in nativeGetCallback (no events) OR
      // (6) have seen a nativeSetCallbackRetVal call in runUntilCallbackReturn mode
      break;
    }
    userCodeRow = selectCodeFunc.call(this);
    inUserCode = -1 !== userCodeRow;
    // Check to see if we've arrived at a new breakpoint:
    //  (1) should be in user code
    //  (2) should never happen while unwinding
    //  (3) should never happen when revisiting an interstitial node
    //  (4) requires either
    //   (a) atInitialBreakpoint OR
    //   (b) isAceBreakpointRow() AND not still at the same line number where
    //       we have already stopped from the last step/breakpoint
    if (inUserCode && !unwindingAfterStep && !this.atInterstitialNode && (atInitialBreakpoint || this.isBreakpointRow(userCodeRow) && !this.findStoppedAtBreakpointRow(currentScope, userCodeRow))) {
      // Yes, arrived at a new breakpoint:
      if (this.paused) {
        // Overwrite the nextStep value. (If we hit a breakpoint during a step
        // out or step over, this will cancel that step operation early)
        this.nextStep = StepType.RUN;
        this.onNextStepChanged.notifyObservers();
      } else {
        this.onPause.notifyObservers();
      }
      // Store some properties about where we stopped:
      this.replaceStoppedAtBreakpointRowForScope(currentScope, userCodeRow);

      // Mark reachedBreak to stop stepping, and start unwinding if needed:
      reachedBreak = true;
      unwindingAfterStep = codegen.isNextStepSafeWhileUnwinding(this.interpreter);
      continue;
    }
    // If we've moved past the place of the last breakpoint hit without being
    // deeper in the stack, we will discard the stoppedAtBreakpoint properties:
    if (inUserCode && !this.findStoppedAtBreakpointRow(currentScope, userCodeRow)) {
      this.removeStoppedAtBreakpointRowForScope(currentScope);
    }
    // If we're unwinding, continue to update the stoppedAtBreakpoint properties
    // to ensure that we have the right properties stored when the unwind completes:
    if (inUserCode && unwindingAfterStep) {
      this.replaceStoppedAtBreakpointRowForScope(currentScope, userCodeRow);
    }
    this.executionError = safeStepInterpreter(this);
    if (!this.executionError && this.interpreter.stateStack.length) {
      var state = this.interpreter.stateStack[0],
          nodeType = state.node.type;
      this.atInterstitialNode = INTERSTITIAL_NODES.hasOwnProperty(nodeType);
      if (inUserCode) {
        doneUserLine = doneUserLine || state.done || this.atInterstitialNode;
      }

      var stackDepth = this.interpreter.stateStack.length;
      // Remember the stack depths of call expressions (so we can implement 'step out')

      // Truncate any history of call expressions seen deeper than our current stack position:
      for (var depth = stackDepth + 1; depth <= this.maxValidCallExpressionDepth; depth++) {
        this.callExpressionSeenAtDepth[depth] = false;
      }
      this.maxValidCallExpressionDepth = stackDepth;

      if (inUserCode && this.interpreter.stateStack[0].node.type === "CallExpression") {
        // Store that we've seen a call expression at this depth in callExpressionSeenAtDepth:
        this.callExpressionSeenAtDepth[stackDepth] = true;
      }

      if (this.paused) {
        // Store the first call expression stack depth seen while in this step operation:
        if (inUserCode && this.interpreter.stateStack[0].node.type === "CallExpression") {
          if (typeof this.firstCallStackDepthThisStep === 'undefined') {
            this.firstCallStackDepthThisStep = stackDepth;
          }
        }

        // For the step in case, we want to stop the interpreter as soon as we enter the callee:
        if (!doneUserLine && inUserCode && this.nextStep === StepType.IN && stackDepth > this.firstCallStackDepthThisStep) {
          reachedBreak = true;
        }
        // After the interpreter says a node is "done" (meaning it is time to stop), we will
        // advance a little further to the start of the next statement. We achieve this by
        // continuing to set unwindingAfterStep to true to keep the loop going:
        if (doneUserLine || reachedBreak) {
          var wasUnwinding = unwindingAfterStep;
          // step() additional times if we know it to be safe to get us to the next statement:
          unwindingAfterStep = codegen.isNextStepSafeWhileUnwinding(this.interpreter);
          if (wasUnwinding && !unwindingAfterStep) {
            // done unwinding.. select code that is next to execute:
            userCodeRow = selectCodeFunc.call(this);
            inUserCode = -1 !== userCodeRow;
            if (!inUserCode) {
              // not in user code, so keep unwinding after all...
              unwindingAfterStep = true;
            }
          }
        }

        if ((reachedBreak || doneUserLine) && !unwindingAfterStep) {
          if (this.nextStep === StepType.OUT && stackDepth > this.stepOutToStackDepth) {
            // trying to step out, but we didn't get out yet... continue on.
          } else if (this.nextStep === StepType.OVER && typeof this.firstCallStackDepthThisStep !== 'undefined' && stackDepth > this.firstCallStackDepthThisStep) {
              // trying to step over, and we're in deeper inside a function call... continue next onTick
            } else {
                // Our step operation is complete, reset nextStep to StepType.RUN to
                // return to a normal 'break' state:
                this.nextStep = StepType.RUN;
                this.onNextStepChanged.notifyObservers();
                if (inUserCode) {
                  // Store some properties about where we stopped:
                  this.replaceStoppedAtBreakpointRowForScope(this.interpreter.getScope(), userCodeRow);
                }
                delete this.stepOutToStackDepth;
                delete this.firstCallStackDepthThisStep;
                break;
              }
        }
      }
    } else {
      if (this.executionError) {
        this.handleError(inUserCode ? userCodeRow + 1 : undefined);
      }
      this.executeLoopDepth--;
      return;
    }
  }
  if (reachedBreak && atMaxSpeed) {
    // If we were running atMaxSpeed and just reached a breakpoint, the
    // code may not be selected in the editor, so do it now:
    this.selectCurrentCode();
  }
  this.executeLoopDepth--;
};

/**
 * Helper that wraps some error preprocessing before we notify observers that
 * an execution error has occurred. Operates on the current error that is
 * already saved as this.executionError
 *
 * @param {number} [lineNumber]
 */
JSInterpreter.prototype.handleError = function (lineNumber) {
  if (!lineNumber && this.executionError instanceof SyntaxError) {
    // syntax errors came before execution (during parsing), so we need
    // to determine the proper line number by looking at the exception
    lineNumber = this.executionError.loc.line;
    // Now select this location in the editor, since we know we didn't hit
    // this while executing (in which case, it would already have been selected)
    codegen.selectEditorRowColError(this.studioApp.editor, lineNumber - 1, this.executionError.loc.column);
  }

  // Select code that just executed:
  this.selectCurrentCode("ace_error");
  // Grab line number if we don't have one already:
  if (!lineNumber) {
    lineNumber = 1 + this.getNearestUserCodeLine();
  }

  this.onExecutionError.notifyObservers(this.executionError, lineNumber);
};

/**
 * Helper to create an interpeter primitive value. Useful when extending the
 * interpreter without relying on codegen marshalling helpers.
 */
JSInterpreter.prototype.createPrimitive = function (data) {
  if (this.interpreter) {
    return this.interpreter.createPrimitive(data);
  }
};

/**
 * Wrapper to Interpreter's getProperty (extended for custom marshaling)
 *
 * Fetch a property value from a data object.
 * @param {!Object} interpeter Interpreter instance.
 * @param {!Function} baseGetProperty Original getProperty() implementation.
 * @param {!Object} obj Data object.
 * @param {*} name Name of property.
 * @return {!Object} Property value (may be UNDEFINED).
 */
JSInterpreter.prototype.getProperty = function (interpreter, baseGetProperty, obj, name) {
  name = name.toString();
  var nativeParent;
  if (obj.isCustomMarshal || obj === this.globalScope && !!(nativeParent = this.customMarshalGlobalProperties[name])) {
    var value;
    if (obj.isCustomMarshal) {
      value = obj.data[name];
    } else {
      value = nativeParent[name];
    }
    var type = typeof value;
    if (type === 'number' || type === 'boolean' || type === 'string' || type === 'undefined' || value === null) {
      return interpreter.createPrimitive(value);
    } else {
      return codegen.marshalNativeToInterpreter(interpreter, value, obj.data);
    }
  } else {
    return baseGetProperty.call(interpreter, obj, name);
  }
};

/**
 * Wrapper to Interpreter's setProperty (extended for custom marshaling)
 *
 * Set a property value on a data object.
 * @param {!Object} interpeter Interpreter instance.
 * @param {!Function} baseSetProperty Original setProperty() implementation.
 * @param {!Object} obj Data object.
 * @param {*} name Name of property.
 * @param {*} value New property value.
 * @param {boolean} opt_fixed Unchangeable property if true.
 * @param {boolean} opt_nonenum Non-enumerable property if true.
 */
JSInterpreter.prototype.setProperty = function (interpreter, baseSetProperty, obj, name, value, opt_fixed, opt_nonenum) {
  name = name.toString();
  var nativeParent;
  if (obj.isCustomMarshal) {
    obj.data[name] = codegen.marshalInterpreterToNative(interpreter, value);
  } else if (obj === this.globalScope && !!(nativeParent = this.customMarshalGlobalProperties[name])) {
    nativeParent[name] = codegen.marshalInterpreterToNative(interpreter, value);
  } else {
    return baseSetProperty.call(interpreter, obj, name, value, opt_fixed, opt_nonenum);
  }
};

/**
 * Selects code in droplet/ace editor.
 *
 * Returns the row (line) of code highlighted. If nothing is highlighted
 * because it is outside of the userCode area, the return value is -1
 */
JSInterpreter.prototype.selectCurrentCode = function (highlightClass) {
  if (this.studioApp.hideSource) {
    return -1;
  }
  return codegen.selectCurrentCode(this.interpreter, this.codeInfo.cumulativeLength, this.codeInfo.userCodeStartOffset, this.codeInfo.userCodeLength, this.studioApp.editor, highlightClass);
};

/**
 * Finds the current line of code in droplet/ace editor.
 *
 * Returns the line of code where the interpreter is at. If it is outside
 * of the userCode area, the return value is -1
 */
JSInterpreter.prototype.getUserCodeLine = function () {
  var userCodeRow = -1;
  if (this.interpreter.stateStack[0]) {
    var node = this.interpreter.stateStack[0].node;
    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - this.codeInfo.userCodeStartOffset;

    // Only return a valid userCodeRow if the node being executed is inside the
    // user's code (not inside code we inserted before or after their code that
    // is not visible in the editor):
    if (start >= 0 && start < this.codeInfo.userCodeLength) {
      userCodeRow = codegen.aceFindRow(this.codeInfo.cumulativeLength, 0, this.codeInfo.cumulativeLength.length, start);
    }
  }
  return userCodeRow;
};

/**
 * Finds the current line of code in droplet/ace editor. Walks up the stack if
 * not currently in the user code area.
 */
JSInterpreter.prototype.getNearestUserCodeLine = function () {
  if (this.studioApp.hideSource) {
    return -1;
  }
  var userCodeRow = -1;
  for (var i = 0; i < this.interpreter.stateStack.length; i++) {
    var node = this.interpreter.stateStack[i].node;
    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - this.codeInfo.userCodeStartOffset;

    // Only return a valid userCodeRow if the node being executed is inside the
    // user's code (not inside code we inserted before or after their code that
    // is not visible in the editor):
    if (start >= 0 && start < this.codeInfo.userCodeLength) {
      userCodeRow = codegen.aceFindRow(this.codeInfo.cumulativeLength, 0, this.codeInfo.cumulativeLength.length, start);
      break;
    }
  }
  return userCodeRow;
};

/**
 * Creates a property in the interpreter's global scope. When a parent is
 * supplied and that parent object is in codegen's customMarshalObjectList,
 * property gets/sets in the interpreter will be reflected on the native parent
 * object. Functions can also be inserted into the global namespace using this
 * method. If a parent is supplied, they will be invoked natively with that
 * parent as the this parameter.
 *
 * @param {String} name Name for the property in the global scope.
 * @param {*} value Native value that will be marshalled to the interpreter.
 * @param {Object} parent (Optional) parent for the native value.
 */
JSInterpreter.prototype.createGlobalProperty = function (name, value, parent) {

  var interpreterVal;
  if (typeof value === 'function') {
    var wrapper = codegen.makeNativeMemberFunction({
      interpreter: this.interpreter,
      nativeFunc: value,
      nativeParentObj: parent
    });
    interpreterVal = this.interpreter.createNativeFunction(wrapper);
  } else {
    interpreterVal = codegen.marshalNativeToInterpreter(this.interpreter, value, utils.valueOr(parent, window));
  }

  // Bypass setProperty since we've hooked it and it will not create the
  // property if it is in customMarshalGlobalProperties
  this.baseSetProperty.call(this.interpreter, this.globalScope, name, interpreterVal);
};

/**
 * Returns the interpreter function object corresponding to 'funcName' if a
 * function with that name is found in the interpreter's global scope.
 */
JSInterpreter.prototype.findGlobalFunction = function (funcName) {
  var funcObj = this.interpreter.getProperty(this.globalScope, funcName);
  if (funcObj.type === 'function') {
    return funcObj;
  }
};

/**
 * Returns an array containing the names of all of the global functions
 * in the interpreter's global scope. Built-in global functions are excluded.
 */
JSInterpreter.prototype.getGlobalFunctionNames = function () {
  var builtInExclusionList = ["eval", "getCallback", "setCallbackRetVal"];

  var names = [];
  for (var objName in this.globalScope.properties) {
    var object = this.globalScope.properties[objName];
    if (object.type === 'function' && !object.nativeFunc && builtInExclusionList.indexOf(objName) === -1) {
      names.push(objName);
    }
  }
  return names;
};

/**
 * Returns an array containing the names of all of the functions defined
 * inside other functions.
 */
JSInterpreter.prototype.getLocalFunctionNames = function (scope) {
  if (!scope) {
    scope = this.globalScope;
  }
  var names = [];
  for (var objName in scope.properties) {
    var object = scope.properties[objName];
    if (object.type === 'function' && !object.nativeFunc && object.node) {
      if (scope !== this.globalScope) {
        names.push(objName);
      }
      var localScope = this.interpreter.createScope(object.node.body, object.parentScope);
      var localNames = this.getLocalFunctionNames(localScope);
      names = names.concat(localNames);
    }
  }
  return names;
};

/**
 * Returns the current interpreter state object.
 */
JSInterpreter.prototype.getCurrentState = function () {
  return this.interpreter && this.interpreter.stateStack[0];
};

/**
 * Evaluate an expression in the interpreter's current scope, and return the
 * value of the evaluated expression.
 * @param {!string} expression
 * @returns {?} value of the expression
 * @throws if there's a problem evaluating the expression
 */
JSInterpreter.prototype.evalInCurrentScope = function (expression) {
  var currentScope = this.interpreter.getScope();
  var evalInterpreter = new window.Interpreter(expression);
  // Set scope to the current scope of the running program
  // NOTE: we are being a little tricky here (we are re-running
  // part of the Interpreter constructor with a different interpreter's
  // scope)
  evalInterpreter.populateScope_(evalInterpreter.ast, currentScope);
  evalInterpreter.stateStack = [{
    node: evalInterpreter.ast,
    scope: currentScope,
    thisExpression: currentScope
  }];
  // Copy these properties directly into the evalInterpreter so the .isa()
  // method behaves as expected
  ['ARRAY', 'BOOLEAN', 'DATE', 'FUNCTION', 'NUMBER', 'OBJECT', 'STRING', 'UNDEFINED'].forEach(function (prop) {
    evalInterpreter[prop] = this.interpreter[prop];
  }, this);

  // Patch getProperty and setProperty to enable custom marshalling
  evalInterpreter.getProperty = this.getProperty.bind(this, evalInterpreter, evalInterpreter.getProperty);
  evalInterpreter.setProperty = this.setProperty.bind(this, evalInterpreter, evalInterpreter.setProperty);

  // run() may throw if there's a problem in the expression
  evalInterpreter.run();
  return evalInterpreter.value;
};

},{"./ObservableEvent":"/home/ubuntu/staging/apps/build/js/ObservableEvent.js","./codegen":"/home/ubuntu/staging/apps/build/js/codegen.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/codegen.js":[function(require,module,exports){
/* global Interpreter, CanvasPixelArray, ace */

'use strict';

var dropletUtils = require('./dropletUtils');
var utils = require('./utils');

/**
 * Evaluates a string of code parameterized with a dictionary.
 */
exports.evalWith = function (code, options) {
  if (options.StudioApp && options.StudioApp.editCode) {
    // Use JS interpreter on editCode levels
    var initFunc = function initFunc(interpreter, scope) {
      exports.initJSInterpreter(interpreter, null, null, scope, options);
    };
    var myInterpreter = new Interpreter(code, initFunc);
    // interpret the JS program all at once:
    myInterpreter.run();
  } else {
    // execute JS code "natively"
    var params = [];
    var args = [];
    for (var k in options) {
      params.push(k);
      args.push(options[k]);
    }
    params.push(code);
    var ctor = function ctor() {
      return Function.apply(this, params);
    };
    ctor.prototype = Function.prototype;
    return new ctor().apply(null, args);
  }
};

/**
 * Returns a function based on a string of code parameterized with a dictionary.
 */
exports.functionFromCode = function (code, options) {
  if (options.StudioApp && options.StudioApp.editCode) {
    // Since this returns a new native function, it doesn't make sense in the
    // editCode case (we assume that the app will be using JSInterpreter)
    throw "Unexpected";
  } else {
    var params = [];
    var args = [];
    for (var k in options) {
      params.push(k);
      args.push(options[k]);
    }
    params.push(code);
    var ctor = function ctor() {
      return Function.apply(this, params);
    };
    ctor.prototype = Function.prototype;
    return new ctor();
  }
};

//
// Blockly specific codegen functions:
//

var INFINITE_LOOP_TRAP = '  executionInfo.checkTimeout(); if (executionInfo.isTerminated()){return;}\n';

var LOOP_HIGHLIGHT = 'loopHighlight();\n';
var LOOP_HIGHLIGHT_RE = new RegExp(LOOP_HIGHLIGHT.replace(/\(.*\)/, '\\(.*\\)'), 'g');

/**
 * Returns javascript code to call a timeout check
 */
exports.loopTrap = function () {
  return INFINITE_LOOP_TRAP;
};

exports.loopHighlight = function (apiName, blockId) {
  var args = "'block_id_" + blockId + "'";
  if (blockId === undefined) {
    args = "%1";
  }
  return apiName + '.' + LOOP_HIGHLIGHT.replace('()', '(' + args + ')');
};

/**
 * Extract the user's code as raw JavaScript.
 * @param {string} code Generated code.
 * @return {string} The code without serial numbers and timeout checks.
 */
exports.strip = function (code) {
  return code
  // Strip out serial numbers.
  .replace(/(,\s*)?'block_id_\d+'\)/g, ')')
  // Remove timeouts.
  .replace(INFINITE_LOOP_TRAP, '')
  // Strip out loop highlight
  .replace(LOOP_HIGHLIGHT_RE, '')
  // Strip out class namespaces.
  .replace(/(StudioApp|Maze|Turtle)\./g, '')
  // Strip out particular helper functions.
  .replace(/^function (colour_random)[\s\S]*?^}/gm, '')
  // Collapse consecutive blank lines.
  .replace(/\n\n+/gm, '\n\n')
  // Trim.
  .replace(/^\s+|\s+$/g, '');
};

/**
 * Extract the user's code as raw JavaScript.
 */
exports.workspaceCode = function (blockly) {
  var code = blockly.Generator.blockSpaceToCode('JavaScript', null, false);
  return exports.strip(code);
};

//
// Property access wrapped in try/catch. This is in an indepedendent function
// so the JIT compiler can optimize the calling function.
//

function safeReadProperty(object, property) {
  try {
    return object[property];
  } catch (e) {}
}

//
// Marshal a single native object from native to interpreter. This is in an
// indepedendent function so the JIT compiler can optimize the calling function.
// (Chrome V8 says ForInStatement is not fast case)
//

/**
 * Marshal a native object to an interpreter object.
 *
 * @param {Interpreter} interpreter Interpreter instance
 * @param {Object} nativeObject Object to marshal
 * @param {Number} maxDepth Optional maximum depth to traverse in properties
 * @param {Object} interpreterObject Optional existing interpreter object
 * @return {!Object} The interpreter object, which was created if needed.
 */
function marshalNativeToInterpreterObject(interpreter, nativeObject, maxDepth, interpreterObject) {
  var retVal = interpreterObject || interpreter.createObject(interpreter.OBJECT);
  var isFunc = interpreter.isa(retVal, interpreter.FUNCTION);
  for (var prop in nativeObject) {
    var value = safeReadProperty(nativeObject, prop);
    if (isFunc && (value === Function.prototype.trigger || value === Function.prototype.inherits)) {
      // Don't marshal these that were added by jquery or else we will recurse
      continue;
    }
    interpreter.setProperty(retVal, prop, exports.marshalNativeToInterpreter(interpreter, value, nativeObject, maxDepth));
  }
  return retVal;
}

function isCanvasImageData(nativeVar) {
  // IE 9/10 don't know about Uint8ClampedArray and call it CanvasPixelArray instead
  if (typeof Uint8ClampedArray !== "undefined") {
    return nativeVar instanceof Uint8ClampedArray;
  }
  return nativeVar instanceof CanvasPixelArray;
}

/**
 * Create a new "custom marshal" interpreter object that corresponds to a native
 * object.
 * @param {Interpreter} interpreter Interpreter instance
 * @param {Object} nativeObj Object to wrap
 * @param {Object} nativeParentObj Parent of object to wrap
 * @return {!Object} New interpreter object.
 */
var createCustomMarshalObject = function createCustomMarshalObject(interpreter, nativeObj, nativeParentObj) {
  if (nativeObj === undefined && interpreter.UNDEFINED) {
    return interpreter.UNDEFINED; // Reuse the same object.
  }
  var type = typeof nativeObj;
  var obj = {
    data: nativeObj,
    isPrimitive: false,
    isCustomMarshal: true,
    type: typeof nativeObj,
    parent: nativeParentObj, // TODO (cpirich): replace with interpreter object?
    toBoolean: function toBoolean() {
      return Boolean(this.data);
    },
    toNumber: function toNumber() {
      return Number(this.data);
    },
    toString: function toString() {
      return String(this.data);
    },
    valueOf: function valueOf() {
      return this.data;
    }
  };
  return obj;
};

exports.customMarshalObjectList = [];
exports.asyncFunctionList = [];
exports.nativeCallsInterpreterFunctionList = [];

// If this is on our list of "custom marshal" objects - or if it a property
// on one of those objects (other than a function), return true

var shouldCustomMarshalObject = function shouldCustomMarshalObject(nativeVar, nativeParentObj) {
  for (var i = 0; i < exports.customMarshalObjectList.length; i++) {
    var marshalObj = exports.customMarshalObjectList[i];
    if (nativeVar instanceof marshalObj.instance && (typeof marshalObj.requiredMethod === 'undefined' || nativeVar[marshalObj.requiredMethod] !== undefined) || typeof nativeVar !== 'function' && nativeParentObj instanceof marshalObj.instance) {
      return true;
    }
  }
  return false;
};

// When marshaling methods on "custom marshal" objects, we may need to augment
// the marshaling options. This returns those options.

var getCustomMarshalMethodOptions = function getCustomMarshalMethodOptions(nativeParentObj) {
  for (var i = 0; i < exports.customMarshalObjectList.length; i++) {
    var marshalObj = exports.customMarshalObjectList[i];
    if (nativeParentObj instanceof marshalObj.instance) {
      if (typeof marshalObj.requiredMethod === 'undefined' || nativeParentObj[marshalObj.requiredMethod] !== undefined) {
        return marshalObj.methodOpts || {};
      } else {
        return {};
      }
    }
  }
  return {};
};

//
// Droplet/JavaScript/Interpreter codegen functions:
//
exports.marshalNativeToInterpreter = function (interpreter, nativeVar, nativeParentObj, maxDepth) {
  if (maxDepth === 0 || typeof nativeVar === 'undefined') {
    return interpreter.UNDEFINED;
  }
  var i, retVal;
  if (typeof maxDepth === "undefined") {
    maxDepth = Infinity; // default to infinite levels of depth
  }
  if (shouldCustomMarshalObject(nativeVar, nativeParentObj)) {
    return createCustomMarshalObject(interpreter, nativeVar, nativeParentObj);
  }
  if (nativeVar instanceof Array) {
    retVal = interpreter.createObject(interpreter.ARRAY);
    for (i = 0; i < nativeVar.length; i++) {
      retVal.properties[i] = exports.marshalNativeToInterpreter(interpreter, nativeVar[i], null, maxDepth - 1);
    }
    retVal.length = nativeVar.length;
  } else if (isCanvasImageData(nativeVar)) {
    // Special case for canvas image data - could expand to support TypedArray
    retVal = interpreter.createObject(interpreter.ARRAY);
    for (i = 0; i < nativeVar.length; i++) {
      retVal.properties[i] = interpreter.createPrimitive(nativeVar[i]);
    }
    retVal.length = nativeVar.length;
  } else if (nativeVar instanceof Function) {
    var makeNativeOpts = {
      interpreter: interpreter,
      nativeFunc: nativeVar,
      nativeParentObj: nativeParentObj
    };
    if (exports.asyncFunctionList.indexOf(nativeVar) !== -1) {
      // Mark if this should be nativeIsAsync:
      makeNativeOpts.nativeIsAsync = true;
    }
    if (exports.nativeCallsInterpreterFunctionList.indexOf(nativeVar) !== -1) {
      // Mark if this should be nativeCallsBackInterpreter:
      makeNativeOpts.nativeCallsBackInterpreter = true;
    }
    var extraOpts = getCustomMarshalMethodOptions(nativeParentObj);
    // Add extra options if the parent of this function is in our custom marshal
    // modified object list:
    for (var prop in extraOpts) {
      makeNativeOpts[prop] = extraOpts[prop];
    }
    var wrapper = exports.makeNativeMemberFunction(makeNativeOpts);
    if (makeNativeOpts.nativeIsAsync) {
      retVal = interpreter.createAsyncFunction(wrapper);
    } else {
      retVal = interpreter.createNativeFunction(wrapper);
    }
    // Also marshal properties on the native function object:
    marshalNativeToInterpreterObject(interpreter, nativeVar, maxDepth - 1, retVal);
  } else if (nativeVar instanceof Object) {
    // note Object must be checked after Function and Array (since they are also Objects)
    if (interpreter.isa(nativeVar, interpreter.FUNCTION)) {
      // Special case to see if we are trying to marshal an interpreter object
      // (this currently happens when we store interpreter function objects in native
      //  and return them back in nativeGetCallback)

      // NOTE: this check could be expanded to check for other interpreter object types
      // if we have reason to believe that we may be passing those back

      retVal = nativeVar;
    } else {
      retVal = marshalNativeToInterpreterObject(interpreter, nativeVar, maxDepth - 1);
    }
  } else {
    retVal = interpreter.createPrimitive(nativeVar);
  }
  return retVal;
};

exports.createNativeFunctionFromInterpreterFunction = null;

exports.marshalInterpreterToNative = function (interpreter, interpreterVar) {
  if (interpreterVar.isPrimitive || interpreterVar.isCustomMarshal) {
    return interpreterVar.data;
  } else if (interpreter.isa(interpreterVar, interpreter.ARRAY)) {
    var nativeArray = [];
    nativeArray.length = interpreterVar.length;
    for (var i = 0; i < nativeArray.length; i++) {
      nativeArray[i] = exports.marshalInterpreterToNative(interpreter, interpreterVar.properties[i]);
    }
    return nativeArray;
  } else if (interpreter.isa(interpreterVar, interpreter.OBJECT) || interpreterVar.type === 'object') {
    var nativeObject = {};
    for (var prop in interpreterVar.properties) {
      nativeObject[prop] = exports.marshalInterpreterToNative(interpreter, interpreterVar.properties[prop]);
    }
    return nativeObject;
  } else if (interpreter.isa(interpreterVar, interpreter.FUNCTION)) {
    if (exports.createNativeFunctionFromInterpreterFunction) {
      return exports.createNativeFunctionFromInterpreterFunction(interpreterVar);
    } else {
      // Just return the interpreter object if we can't convert it. This is needed
      // for passing interpreter callback functions into native.

      return interpreterVar;
    }
  } else {
    throw "Can't marshal type " + typeof interpreterVar;
  }
};

/**
 * Generate a function wrapper for an interpreter async function callback.
 * The interpreter async function callback takes a single parameter, which
 * becomes the return value of the synchronous function in the interpreter
 * world. Here, we wrap the supplied callback to marshal the single parameter
 * from native to interpreter before calling the supplied callback.
 *
 * @param {Object} opts Options block with interpreter and maxDepth provided
 * @param {function} callback The interpreter supplied callback function
 */
var createNativeCallbackForAsyncFunction = function createNativeCallbackForAsyncFunction(opts, callback) {
  return function (nativeValue) {
    callback(exports.marshalNativeToInterpreter(opts.interpreter, nativeValue, null, opts.maxDepth));
  };
};

/**
 * Generate a function wrapper for an interpreter callback that will be
 * invoked by a special native function that can execute these callbacks inline
 * on the interpreter stack.
 *
 * @param {Object} opts Options block with interpreter and maxDepth provided
 * @param {function} intFunc The interpreter supplied callback function
 */
var createNativeInterpreterCallback = function createNativeInterpreterCallback(opts, intFunc) {
  return function (nativeValue) {
    var args = Array.prototype.slice.call(arguments);
    var intArgs = [];
    for (var i = 0; i < args.length; i++) {
      intArgs[i] = exports.marshalNativeToInterpreter(opts.interpreter, args[i], null, opts.maxDepth);
    }
    // Shift a CallExpression node on the stack that already has its func_,
    // arguments, and other state populated:
    var state = {
      node: {
        type: 'CallExpression',
        arguments: intArgs /* this just needs to be array of the same size */
      },
      doneCallee_: true,
      func_: intFunc,
      arguments: intArgs,
      n_: intArgs.length
    };
    opts.interpreter.stateStack.unshift(state);
  };
};

/**
 * Generate a native function wrapper for use with the JS interpreter.
 */
exports.makeNativeMemberFunction = function (opts) {
  if (opts.dontMarshal) {
    return function () {
      // Just call the native function and marshal the return value:
      var nativeRetVal = opts.nativeFunc.apply(opts.nativeParentObj, arguments);
      return exports.marshalNativeToInterpreter(opts.interpreter, nativeRetVal, null, opts.maxDepth);
    };
  } else {
    return function () {
      // Call the native function after marshalling parameters:
      var nativeArgs = [];
      for (var i = 0; i < arguments.length; i++) {
        if (opts.nativeIsAsync && i === arguments.length - 1) {
          // Async functions receive a native callback method as their last
          // parameter, and we want to wrap that callback to ease marshalling:
          nativeArgs[i] = createNativeCallbackForAsyncFunction(opts, arguments[i]);
        } else if (opts.nativeCallsBackInterpreter && typeof arguments[i] === 'object' && opts.interpreter.isa(arguments[i], opts.interpreter.FUNCTION)) {
          // A select class of native functions is aware of the interpreter and
          // capable of calling the interpreter on the stack immediately. We
          // marshal these differently:
          nativeArgs[i] = createNativeInterpreterCallback(opts, arguments[i]);
        } else {
          nativeArgs[i] = exports.marshalInterpreterToNative(opts.interpreter, arguments[i]);
        }
      }
      var nativeRetVal = opts.nativeFunc.apply(opts.nativeParentObj, nativeArgs);
      return exports.marshalNativeToInterpreter(opts.interpreter, nativeRetVal, null, opts.maxDepth);
    };
  }
};

function populateFunctionsIntoScope(interpreter, scope, funcsObj, parentObj, options) {
  for (var prop in funcsObj) {
    var func = funcsObj[prop];
    if (func instanceof Function) {
      // Populate the scope with native functions
      // NOTE: other properties are not currently passed to the interpreter
      var parent = parentObj ? parentObj : funcsObj;
      var wrapper = exports.makeNativeMemberFunction(utils.extend(options, {
        interpreter: interpreter,
        nativeFunc: func,
        nativeParentObj: parent
      }));
      interpreter.setProperty(scope, prop, interpreter.createNativeFunction(wrapper));
    }
  }
}

function populateGlobalFunctions(interpreter, blocks, blockFilter, scope) {
  for (var i = 0; i < blocks.length; i++) {
    var block = blocks[i];
    if (block.parent && (!blockFilter || typeof blockFilter[block.func] !== 'undefined')) {
      var funcScope = scope;
      var funcName = block.func;
      var funcComponents = funcName.split('.');
      if (funcComponents.length === 2) {
        // Special accommodation for Object.function syntax (2 components only):
        var objName = funcComponents[0];
        // Find or create global object named 'objName' and make it the scope:
        funcScope = interpreter.getProperty(scope, objName);
        if (interpreter.UNDEFINED === funcScope) {
          funcScope = interpreter.createObject(interpreter.OBJECT);
          interpreter.setProperty(scope, objName, funcScope);
        }
        funcName = funcComponents[1];
      }
      var func = block.parent[funcName];
      var wrapper = exports.makeNativeMemberFunction({
        interpreter: interpreter,
        nativeFunc: func,
        nativeParentObj: block.parent,
        dontMarshal: block.dontMarshal,
        nativeIsAsync: block.nativeIsAsync
      });
      var intFunc;
      if (block.nativeIsAsync) {
        intFunc = interpreter.createAsyncFunction(wrapper);
      } else {
        intFunc = interpreter.createNativeFunction(wrapper);
      }
      interpreter.setProperty(funcScope, funcName, intFunc);
    }
  }
}

function populateJSFunctions(interpreter) {
  // The interpreter is missing some basic JS functions. Add them as needed:
  var wrapper;

  // Add static methods from String:
  var functions = ['fromCharCode'];
  for (var i = 0; i < functions.length; i++) {
    wrapper = exports.makeNativeMemberFunction({
      interpreter: interpreter,
      nativeFunc: String[functions[i]],
      nativeParentObj: String
    });
    interpreter.setProperty(interpreter.STRING, functions[i], interpreter.createNativeFunction(wrapper), false, true);
  }

  // Add String.prototype.includes
  wrapper = function (searchStr) {
    // Polyfill based off of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
    return interpreter.createPrimitive(String.prototype.indexOf.apply(this, arguments) !== -1);
  };
  interpreter.setProperty(interpreter.STRING.properties.prototype, 'includes', interpreter.createNativeFunction(wrapper), false, true);
}

/**
 * Initialize a JS interpreter.
 *
 * interpreter (required): JS interpreter instance.
 * blocks (optional): blocks in dropletConfig.blocks format. If a block has
 *  a parent property, we will populate that function into the specified scope.
 * blockFilter (optional): an object with block-name keys that should be used
 *  to filter which blocks are populated.
 * scope (required): interpreter's global scope.
 * globalObjects (optional): objects containing functions to placed in a new scope
 *  created beneath the supplied scope.
 */
exports.initJSInterpreter = function (interpreter, blocks, blockFilter, scope, globalObjects) {
  for (var globalObj in globalObjects) {
    // The globalObjects object contains objects that will be referenced
    // by the code we plan to execute. Since these objects exist in the native
    // world, we need to create associated objects in the interpreter's world
    // so the interpreted code can call out to these native objects

    // Create global objects in the interpreter for everything in options
    var obj = interpreter.createObject(interpreter.OBJECT);
    interpreter.setProperty(scope, globalObj.toString(), obj);
    // Marshal return values with a maxDepth of 2 (just an object and its child
    // methods and properties only)
    populateFunctionsIntoScope(interpreter, obj, globalObjects[globalObj], null, { maxDepth: 2 });
  }
  populateGlobalFunctions(interpreter, dropletUtils.dropletGlobalConfigBlocks, blockFilter, scope);
  if (blocks) {
    populateGlobalFunctions(interpreter, blocks, blockFilter, scope);
  }
  populateJSFunctions(interpreter);
};

/**
 * Check to see if it is safe to step the interpreter while we are unwinding.
 * (Called repeatedly after completing a step where the node was marked 'done')
 */
exports.isNextStepSafeWhileUnwinding = function (interpreter) {
  var state = interpreter.stateStack[0];
  var type = state.node.type;
  if (state.done) {
    return true;
  }
  if (type === "SwitchStatement") {
    // Safe to skip over SwitchStatement's except the very start (before a
    // switchValue has been set):
    return typeof state.switchValue !== 'undefined';
  }
  if (type === "VariableDeclaration") {
    // Only stop the first time this VariableDeclaration is processed (the
    // interpreter will stop on this node multiple times, but with different
    // `state.n` representing which VariableDeclarator is being executed).
    return state.n > 0;
  }
  switch (type) {
    // Declarations:
    case "VariableDeclarator":
    // Statements:
    case "BlockStatement":
    case "BreakStatement":
    // All Expressions:
    case "ThisExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "ArrowExpression":
    case "SequenceExpression":
    case "UnaryExpression":
    case "BinaryExpression":
    case "UpdateExpression":
    case "LogicalExpression":
    case "ConditionalExpression":
    case "NewExpression":
    case "CallExpression":
    case "MemberExpression":
    case "FunctionExpression":
    case "AssignmentExpression":
    // Other:
    case "Identifier":
    case "Literal":
    case "Program":
      return true;
  }
  return false;
};

// session is an instance of Ace editSession
// Usage
// var lengthArray = calculateCumulativeLength(editor.getSession());
// Need to call this only if the document is updated after the last call.
exports.calculateCumulativeLength = function (code) {
  var regex = /\n/g,
      result = [];
  do {
    result.push(regex.lastIndex);
    regex.exec(code);
  } while (regex.lastIndex !== 0);

  result.push(code.length + 1);
  return result;
};

// Fast binary search implementation
// Pass the cumulative length array here.
// Usage
// var row = aceFindRow(lengthArray, 0, lengthArray.length, 2512);
// tries to find 2512th character lies in which row.
exports.aceFindRow = function (cumulativeLength, rows, rowe, pos) {
  if (rows > rowe) {
    return null;
  }
  if (rows + 1 === rowe) {
    return rows;
  }

  var mid = Math.floor((rows + rowe) / 2);

  if (pos < cumulativeLength[mid]) {
    return exports.aceFindRow(cumulativeLength, rows, mid, pos);
  } else if (pos > cumulativeLength[mid]) {
    return exports.aceFindRow(cumulativeLength, mid, rowe, pos);
  }
  return mid;
};

exports.isAceBreakpointRow = function (session, userCodeRow) {
  if (!session) {
    return false;
  }
  var bps = session.getBreakpoints();
  return Boolean(bps[userCodeRow]);
};

var lastHighlightMarkerIds = {};

/**
 * Clears all highlights that we have added in the ace editor.
 */
function clearAllHighlightedAceLines(aceEditor) {
  var session = aceEditor.getSession();
  for (var hlClass in lastHighlightMarkerIds) {
    session.removeMarker(lastHighlightMarkerIds[hlClass]);
  }
  lastHighlightMarkerIds = {};
}

/**
 * Highlights lines in the ace editor. Always moves the previous highlight with
 * the same class to the new location.
 *
 * If the row parameters are not supplied, just clear the last highlight.
 */
function highlightAceLines(aceEditor, className, startRow, startColumn, endRow, endColumn) {
  var session = aceEditor.getSession();
  className = className || 'ace_step';
  if (lastHighlightMarkerIds[className]) {
    session.removeMarker(lastHighlightMarkerIds[className]);
    lastHighlightMarkerIds[className] = null;
  }
  if (typeof startRow !== 'undefined') {
    lastHighlightMarkerIds[className] = session.addMarker(new (window.ace.require('ace/range').Range)(startRow, startColumn, endRow, endColumn), className, 'text');
    if (!aceEditor.isRowFullyVisible(startRow)) {
      aceEditor.scrollToLine(startRow, true);
    }
  }
}

/**
 * Selects and highlights code in droplet/ace editor to indicate an error.
 *
 * This function simply highlights one spot, not a range. It is typically used
 * to highlight where an error has occurred.
 */
exports.selectEditorRowColError = function (editor, row, col) {
  if (!editor) {
    return;
  }
  if (editor.currentlyUsingBlocks) {
    var style = { color: '#FFFF22' };
    editor.clearLineMarks();
    editor.markLine(row, style);
  } else {
    var selection = editor.aceEditor.getSelection();
    var range = selection.getRange();

    range.start.row = row;
    range.start.column = col;
    range.end.row = row;
    range.end.column = col + 1;

    // setting with the backwards parameter set to true - this prevents horizontal
    // scrolling to the right
    selection.setSelectionRange(range, true);
  }
  lastHighlightMarkerIds.ace_error = editor.aceEditor.getSession().highlightLines(row, row, 'ace_error').id;
};

/**
 * Removes highlights (for the default ace_step class) and selection in
 * droplet and ace editors.
 *
 * @param {boolean} allClasses When set to true, remove all classes of
 * highlights (including ace_step, ace_error, and anything else)
 */
exports.clearDropletAceHighlighting = function (editor, allClasses) {
  if (editor.currentlyUsingBlocks) {
    editor.clearLineMarks();
  } else {
    editor.aceEditor.getSelection().clearSelection();
  }
  if (allClasses) {
    clearAllHighlightedAceLines(editor.aceEditor);
  } else {
    // when calling without a class or rows, highlightAceLines() will clear
    // everything highlighted with the default highlight class
    highlightAceLines(editor.aceEditor);
  }
};

function selectAndHighlightCode(aceEditor, cumulativeLength, start, end, highlightClass) {
  var selection = aceEditor.getSelection();
  var range = selection.getRange();

  range.start.row = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, start);
  range.start.column = start - cumulativeLength[range.start.row];
  range.end.row = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, end);
  range.end.column = end - cumulativeLength[range.end.row];

  highlightAceLines(aceEditor, highlightClass || "ace_step", range.start.row, range.start.column, range.end.row, range.end.column);
}

/**
 * Selects code in droplet/ace editor.
 *
 * Returns the row (line) of code highlighted. If nothing is highlighted
 * because it is outside of the userCode area, the return value is -1
 *
 * @param {string} highlightClass CSS class to use when highlighting in ACE
 */
exports.selectCurrentCode = function (interpreter, cumulativeLength, userCodeStartOffset, userCodeLength, editor, highlightClass) {
  var userCodeRow = -1;
  if (interpreter && interpreter.stateStack[0]) {
    var node = interpreter.stateStack[0].node;

    if (node.type === 'ForStatement') {
      var mode = interpreter.stateStack[0].mode || 0,
          subNode;
      if (mode === 0) {
        subNode = node.init;
      } else if (mode === 1) {
        subNode = node.test;
      } else if (mode === 2) {
        subNode = node.body;
      } else if (mode === 3) {
        subNode = node.update;
      }
      node = subNode || node;
    }

    // Adjust start/end by userCodeStartOffset since the code running
    // has been expanded vs. what the user sees in the editor window:
    var start = node.start - userCodeStartOffset;
    var end = node.end - userCodeStartOffset;

    // Only show selection if the node being executed is inside the user's
    // code (not inside code we inserted before or after their code that is
    // not visible in the editor):
    if (start >= 0 && start < userCodeLength && end <= userCodeLength) {
      userCodeRow = exports.aceFindRow(cumulativeLength, 0, cumulativeLength.length, start);
      // Highlight the code being executed in each step:
      if (editor.currentlyUsingBlocks) {
        var style = { color: '#FFFF22' };
        editor.clearLineMarks();
        editor.mark({ row: userCodeRow, col: start - cumulativeLength[userCodeRow] }, style);
      } else {
        selectAndHighlightCode(editor.aceEditor, cumulativeLength, start, end, highlightClass);
      }
    } else {
      exports.clearDropletAceHighlighting(editor);
    }
  } else {
    exports.clearDropletAceHighlighting(editor);
  }
  return userCodeRow;
};

},{"./dropletUtils":"/home/ubuntu/staging/apps/build/js/dropletUtils.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/dropletUtils.js":[function(require,module,exports){
'use strict';

var utils = require('./utils');
var _ = utils.getLodash();

/**
 * @name DropletBlock
 * @description Definition of a block to be used in Droplet
 * @property {string} func identifying the function this block runs
 * @property {string} blockPrefix Prepend this string before the normal block name in the palette
 * @property {Object} parent object within which this function is defined as a property, keyed by the func name
 * @property {String} category category within which to place the block
 * @property {String} type type of the block (e.g. value, either, property)
 * @property {string[]} paletteParams
 * @property {string[]} params
 * @property {Object.<number, function>} dropdown
 * @property {Object.<number, function>} assetTooltip
 * @property {bool} dontMarshal API expects params in interpreter form and will return an interpreter value
 * @property {bool} noAutocomplete Do not include this function in our ace completer
 * @property {bool} nativeIsAsync The native function is internally async and will call a callback function to resume the interpreter
 * @property {string} tipPrefix Prepend this string before the tooltip formed from the function name and (optionally) parameters
 * @property {string} docFunc Use the provided func as the key for our documentation.
 * @property {string} modeOptionName Alternate name to be used when generating droplet mode options
 */

/**
 * @name DropletConfig
 * @description Configuration information for Droplet
 * @property {DropletBlock[]} blocks list of blocks
 * @property {Object} categories configuration of categories within which to place blocks
 */

var COLOR_PINK = '#F57AC6';
var COLOR_PURPLE = '#BB77C7';
var COLOR_GREEN = '#68D995';
var COLOR_LIGHT_GREEN = '#D3E965';
var COLOR_WHITE = '#FFFFFF';
var COLOR_BLUE = '#64B5F6';
var COLOR_ORANGE = '#FFB74D';

exports.randomNumber = function (min, max) {
  if (typeof max === 'undefined') {
    // If only one parameter is specified, use it as the max with zero as min:
    max = min;
    min = 0;
  }
  // Use double-tilde to ensure we are dealing with integers:
  return Math.floor(Math.random() * (~ ~max - ~ ~min + 1)) + ~ ~min;
};

exports.getTime = function () {
  return new Date().getTime();
};

/**
 * Use native window.prompt to ask for a value, but continue prompting until we
 * get a numerical value.
 * @returns {number} User value, converted to a number
 */
exports.promptNum = function (text) {
  var val;
  do {
    val = parseInt(window.prompt(text), 10);
  } while (isNaN(val));
  return val;
};

/**
 * @type {DropletBlock[]}
 */
exports.dropletGlobalConfigBlocks = [{ func: 'getTime', parent: exports, category: 'Control', type: 'value' }, { func: 'randomNumber', parent: exports, category: 'Math', type: 'value' }, { func: 'prompt', parent: window, category: 'Variables', type: 'value' }, { func: 'promptNum', parent: exports, category: 'Variables', type: 'value' }];

/**
 * @type {DropletBlock[]}
 */
exports.dropletBuiltinConfigBlocks = [{ func: 'Math.round', category: 'Math', type: 'value', docFunc: 'mathRound' }, { func: 'Math.abs', category: 'Math', type: 'value', docFunc: 'mathAbs' }, { func: 'Math.max', category: 'Math', type: 'value', docFunc: 'mathMax' }, { func: 'Math.min', category: 'Math', type: 'value', docFunc: 'mathMin' }, { func: 'Math.random', category: 'Math', type: 'value', docFunc: 'mathRandom' }];

/**
 * @type {DropletConfig|*}}
 */
var standardConfig = {};

standardConfig.blocks = [
// Control
{ func: 'forLoop_i_0_4', block: 'for (var i = 0; i < 4; i++) {\n  __;\n}', category: 'Control' }, { func: 'whileBlock', block: 'while (__) {\n  __;\n}', category: 'Control' }, { func: 'ifBlock', block: 'if (__) {\n  __;\n}', category: 'Control' }, { func: 'ifElseBlock', block: 'if (__) {\n  __;\n} else {\n  __;\n}', category: 'Control' }, { func: 'getTime', block: 'getTime()', category: 'Control', type: 'value' },

// Math
{ func: 'addOperator', block: '__ + __', category: 'Math' }, { func: 'subtractOperator', block: '__ - __', category: 'Math' }, { func: 'multiplyOperator', block: '__ * __', category: 'Math' }, { func: 'divideOperator', block: '__ / __', category: 'Math' }, { func: 'equalityOperator', block: '__ == __', category: 'Math' }, { func: 'inequalityOperator', block: '__ != __', category: 'Math' }, { func: 'greaterThanOperator', block: '__ > __', category: 'Math' }, { func: 'greaterThanOrEqualOperator', block: '__ >= __', category: 'Math' }, { func: 'lessThanOperator', block: '__ < __', category: 'Math' }, { func: 'lessThanOrEqualOperator', block: '__ <= __', category: 'Math' }, { func: 'andOperator', block: '__ && __', category: 'Math' }, { func: 'orOperator', block: '__ || __', category: 'Math' }, { func: 'notOperator', block: '!__', category: 'Math' },
// randomNumber_max has been deprecated
// {func: 'randomNumber_max', block: 'randomNumber(__)', category: 'Math' },
// Note: We use randomNumber as our base docFunc here so that we get the benefits of param descriptions
{ func: 'randomNumber_min_max', block: 'randomNumber(__, __)', category: 'Math', docFunc: 'randomNumber' }, { func: 'mathRound', block: 'Math.round(__)', category: 'Math' }, { func: 'mathAbs', block: 'Math.abs(__)', category: 'Math' }, { func: 'mathMax', block: 'Math.max(__)', category: 'Math' }, { func: 'mathMin', block: 'Math.min(__)', category: 'Math' }, { func: 'mathRandom', block: 'Math.random()', category: 'Math' },

// Variables
{ func: 'declareAssign_x', block: 'var x = __;', category: 'Variables' }, { func: 'declareNoAssign_x', block: 'var x;', category: 'Variables' }, { func: 'assign_x', block: 'x = __;', category: 'Variables' }, { func: 'declareAssign_x_array_1_4', block: 'var x = [1, 2, 3, 4];', category: 'Variables' }, { func: 'declareAssign_x_prompt', block: 'var x = prompt("Enter a value");', category: 'Variables' }, { func: 'declareAssign_x_promptNum', block: 'var x = promptNum("Enter a value");', category: 'Variables' },

// Functions
{ func: 'functionParams_none', block: 'function myFunction() {\n  __;\n}', category: 'Functions' }, { func: 'functionParams_n', block: 'function myFunction(n) {\n  __;\n}', category: 'Functions' }, { func: 'callMyFunction', block: 'myFunction()', category: 'Functions' }, { func: 'callMyFunction_n', block: 'myFunction(n)', category: 'Functions' }, { func: 'return', block: 'return __;', category: 'Functions' }, { func: 'comment', block: '// Comment', category: 'Functions' }];

standardConfig.categories = {
  Control: {
    color: 'blue',
    rgb: COLOR_BLUE,
    blocks: []
  },
  Math: {
    color: 'orange',
    rgb: COLOR_ORANGE,
    blocks: []
  },
  Variables: {
    color: 'purple',
    rgb: COLOR_PURPLE,
    blocks: []
  },
  Functions: {
    color: 'green',
    rgb: COLOR_GREEN,
    blocks: []
  },
  // create blank category in case level builders want to move all blocks here
  // (which will cause the palette header to disappear)
  '': { 'blocks': [] }
};

/**
 * Given a collection of code functions and a set of dropletteConfig, returns a
 * a list of blocks.
 * @param codeFunctions {object} A collection of named key/value pairs
 *   key is a block name from dropletBlocks or standardBlocks
 *   value is an object that can be used to override block defaults
 * @param {DropletConfig} dropletConfig
 * @param {DropletConfig} otherConfig optionally used to supply a standardConfig
 *  object which is not app specific. It will be used first, then overriden
 *  by the primary dropletConfig if there is overlap between the two.
 * @param {Object} options
 * @param {boolean} options.paletteOnly ignore blocks not in codeFunctions palette
 * @param {boolean} options.ignoreDocFunc don't include based on block.docFunc
 * @returns {Array<DropletBlock>}
 */
function filteredBlocksFromConfig(codeFunctions, dropletConfig, otherConfig, options) {
  if (!codeFunctions || !dropletConfig || !dropletConfig.blocks) {
    return [];
  }

  options = options || {};

  var blocks = [];
  if (otherConfig) {
    blocks = blocks.concat(otherConfig.blocks);
  }
  blocks = blocks.concat(dropletConfig.blocks);

  var docFunctions = {};
  blocks.forEach(function (block) {
    if (!(block.func in codeFunctions)) {
      return;
    }

    if (!options.ignoreDocFunc) {
      // For cases where we use a different block for our tooltips, make sure that
      // the target block ends up in the list of blocks we want
      var docFunc = block.docFunc;
      if (docFunc && !(docFunc in codeFunctions)) {
        docFunctions[docFunc] = null;
      }
    }
  });

  return blocks.filter(function (block) {
    return !options.paletteOnly || block.func in codeFunctions || block.func in docFunctions;
  }).map(function (block) {
    // We found this particular block, now override the defaults with extend
    return $.extend({}, block, codeFunctions[block.func]);
  });
}

/**
 * Return a new categories object with the categories from dropletConfig (app
 * specific configuration) merged with the ones in standardConfig (global
 * configuration). App configuration takes precendence
 */
function mergeCategoriesWithConfig(dropletConfig) {
  // Clone our merged categories so that as we mutate it, we're not mutating
  // our original config
  var dropletCategories = dropletConfig && dropletConfig.categories;
  // We include dropletCategories twice so that (a) it's ordering of categories
  // gets preference and (b) it's value override anything in standardConfig
  return _.cloneDeep($.extend({}, dropletCategories, standardConfig.categories, dropletCategories));
}

/**
 * Generate code aliases in Javascript based on some level data.
 * @param {DropletConfig} dropletConfig
 * @param {String} parentObjName string reference to object upon which func is
 *  a property
 * @returns {String} code
 */
exports.generateCodeAliases = function (dropletConfig, parentObjName) {
  var code = '';
  var aliasFunctions = dropletConfig.blocks;

  // Insert aliases from aliasFunctions into code
  for (var i = 0; i < aliasFunctions.length; i++) {
    var cf = aliasFunctions[i];
    code += "var " + cf.func + " = function() { ";
    if (cf.idArgNone) {
      code += "return " + parentObjName + "." + cf.func + ".apply(" + parentObjName + ", arguments); };\n";
    } else {
      code += "var newArgs = " + (cf.idArgLast ? "arguments.concat(['']);" : "[''].concat(arguments);") + " return " + parentObjName + "." + cf.func + ".apply(" + parentObjName + ", newArgs); };\n";
    }
  }
  return code;
};

function buildFunctionPrototype(prefix, params) {
  var proto = prefix + "(";
  if (params) {
    for (var i = 0; i < params.length; i++) {
      if (i !== 0) {
        proto += ", ";
      }
      proto += params[i];
    }
  }
  return proto + ")";
}

/**
 * Generate a palette for the droplet editor based on some level data.
 * @param {object} codeFunctions The set of functions we want to use for this level
 * @param {object} dropletConfig
 * @param {function} dropletConfig.getBlocks
 * @param {object} dropletConfig.categories
 */
exports.generateDropletPalette = function (codeFunctions, dropletConfig) {
  var mergedCategories = mergeCategoriesWithConfig(dropletConfig);
  var mergedFunctions = filteredBlocksFromConfig(codeFunctions, dropletConfig, standardConfig, { paletteOnly: true, ignoreDocFunc: true });

  for (var i = 0; i < mergedFunctions.length; i++) {
    var funcInfo = mergedFunctions[i];
    var block = funcInfo.block;
    var expansion = funcInfo.expansion;
    if (!block) {
      var nameWithPrefix = funcInfo.func;
      if (funcInfo.blockPrefix) {
        nameWithPrefix = funcInfo.blockPrefix + nameWithPrefix;
      }
      if (funcInfo.type === 'property') {
        block = nameWithPrefix;
      } else {
        var paletteParams = funcInfo.paletteParams || funcInfo.params;
        block = buildFunctionPrototype(nameWithPrefix, paletteParams);
        if (funcInfo.paletteParams) {
          // If paletteParams were specified and used for the 'block', then use
          // the regular params for the 'expansion' which appears when the block
          // is dragged out of the palette:
          expansion = buildFunctionPrototype(nameWithPrefix, funcInfo.params);
        }
      }
    }

    /**
     * Here we set the title attribute to the function shortname,
     * this is later used as a key for function documentation and tooltips
     */
    var blockPair = {
      block: block,
      expansion: expansion,
      title: funcInfo.modeOptionName || funcInfo.func
    };
    mergedCategories[funcInfo.category].blocks.push(blockPair);
  }

  // Convert to droplet's expected palette format:
  var addedPalette = [];
  for (var category in mergedCategories) {
    if (mergedCategories[category].blocks.length > 0) {
      mergedCategories[category].name = category;
      addedPalette.push(mergedCategories[category]);
    }
  }

  return addedPalette;
};

function populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, configBlocks) {
  for (var i = 0; i < configBlocks.length; i++) {
    var block = configBlocks[i];
    if (!block.noAutocomplete) {
      // Use score value of 100 to ensure that our APIs are not replaced by
      // other completers that are suggesting the same name
      var newApi = {
        name: 'api',
        value: block.modeOptionName || block.func,
        score: 100,
        meta: block.category
      };
      if (opts.autocompleteFunctionsWithParens) {
        newApi.completer = {
          insertMatch: (function (value, editor) {
            // Remove the filterText that was already typed (ace's built-in
            // insertMatch would normally do this automatically)
            if (editor.completer.completions.filterText) {
              var ranges = editor.selection.getAllRanges();
              for (var i = 0, range; !!(range = ranges[i]); i++) {
                range.start.column -= editor.completer.completions.filterText.length;
                editor.session.remove(range);
              }
            }
            // Insert the function name plus parentheses and semicolon:
            editor.execCommand("insertstring", value + '();');
            if (this.params) {
              // Move the selection back so parameters can be entered:
              var curRange = editor.selection.getRange();
              curRange.start.column -= 2;
              curRange.end.column -= 2;
              editor.selection.setSelectionRange(curRange);
            }
          }).bind(block, newApi.value)
        };
      }
      if (newApi.value.indexOf('*.') === 0 || newApi.value.indexOf('?.') === 0) {
        // Populate this in a special methodsAndProperties collection:

        // Store the original name in a docFunc property for the
        // benefit of our DropletAutocompletePopupTooltipManager:
        newApi.docFunc = newApi.value;
        // Update the value to skip over the '*.' or '?.' at the beginning:
        newApi.value = newApi.value.substring(2);
        methodsAndProperties.push(newApi);
      } else {
        // Populate this in the "normal" apis collection:
        apis.push(newApi);
      }
    }
  }
}

function populateCompleterFromPredefValues(apis, predefValues) {
  if (predefValues) {
    predefValues.forEach(function (val) {
      // Use score value of 100 to ensure that our APIs are not replaced by
      // other completers that are suggesting the same name
      apis.push({
        name: 'api',
        value: val,
        score: 100,
        meta: 'constants'
      });
    });
  }
}

/**
 * Determines if the ace editor cursor position is at the beginning of a method
 * or property (after a dot).
 * @param {Object} session Ace editor session
 * @param {Object} pos Ace editor position
 * @return {boolean} true if position is at the start of a method or property
 */
function isPositionAfterDot(session, pos) {
  var acUtil = window.ace.require("ace/autocomplete/util");
  var line = session.getLine(pos.row);
  var identifier = acUtil.retrievePrecedingIdentifier(line, pos.column);
  // If we're typing a valid identifier, inspect the preceeding
  // character to see if it is a period and ensure there's at least one
  // character before
  if (identifier.length > 0 && identifier.length < pos.column) {
    // We have an identifier and it is shorter than our column position in
    // this line, which means it is safe to check the line[] before the
    // identifier
    var posBeforeIdentifier = pos.column - identifier.length - 1;
    return line[posBeforeIdentifier] === '.';
  }
  return false;
}

/**
 * Generate an Ace editor completer for a set of APIs based on some level data.
 *
 * If functionFilter is non-null, use it to filter the dropletConfig
 * APIs to be set in autocomplete and create no other autocomplete entries
 */
exports.generateAceApiCompleter = function (functionFilter, dropletConfig) {
  var apis = [];
  var methodsAndProperties = [];
  var opts = {};

  // If autocompleteFunctionsWithParens is set, we will append "();" after functions
  opts.autocompleteFunctionsWithParens = dropletConfig.autocompleteFunctionsWithParens;

  if (functionFilter) {
    var mergedBlocks = filteredBlocksFromConfig(functionFilter, dropletConfig, null, { paletteOnly: true });
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, mergedBlocks);
  } else {
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, exports.dropletGlobalConfigBlocks);
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, exports.dropletBuiltinConfigBlocks);
    populateCompleterApisFromConfigBlocks(opts, apis, methodsAndProperties, dropletConfig.blocks);
    populateCompleterFromPredefValues(apis, dropletConfig.additionalPredefValues);
  }

  return {
    getCompletions: function getCompletions(editor, session, pos, prefix, callback) {
      if (prefix.length === 0) {
        callback(null, []);
        return;
      }
      if (isPositionAfterDot(session, pos)) {
        // Following a dot, we autocomplete from methodsAndProperties:
        callback(null, methodsAndProperties);
      } else {
        callback(null, apis);
      }
    }
  };
};

/**
 * Given a droplet config, create a mode option functions object
 * @param {object} config
 * @param {object[]} config.blocks
 * @param {object[]} config.categories
 */
function getModeOptionFunctionsFromConfig(config) {
  var mergedCategories = mergeCategoriesWithConfig(config);

  var modeOptionFunctions = {};

  for (var i = 0; i < config.blocks.length; i++) {
    var newFunc = {};

    if (config.blocks[i].type === 'value') {
      newFunc.value = true;
    } else if (config.blocks[i].type === 'either') {
      newFunc.value = true;
      newFunc.command = true;
    } else if (config.blocks[i].type === 'property') {
      newFunc.property = true;
      newFunc.value = true;
    }

    var category = mergedCategories[config.blocks[i].category];
    if (category) {
      newFunc.color = category.rgb || category.color;
    }

    newFunc.dropdown = config.blocks[i].dropdown;

    var modeOptionName = config.blocks[i].modeOptionName || config.blocks[i].func;
    newFunc.title = modeOptionName;

    modeOptionFunctions[modeOptionName] = newFunc;
  }
  return modeOptionFunctions;
}

/**
 * Generate modeOptions for the droplet editor based on some level data.
 */
exports.generateDropletModeOptions = function (config) {
  var modeOptions = {
    functions: {},
    categories: {
      arithmetic: { color: COLOR_ORANGE },
      logic: { color: COLOR_ORANGE },
      conditionals: { color: COLOR_BLUE },
      loops: {
        color: COLOR_BLUE,
        beginner: config.level.beginnerMode || false
      },
      functions: { color: COLOR_GREEN },
      returns: { color: COLOR_GREEN },
      comments: { color: COLOR_WHITE },
      containers: { color: COLOR_PURPLE },
      value: { color: COLOR_PURPLE },
      command: { color: COLOR_GREEN },
      assignments: { color: COLOR_PURPLE }
      // errors: { },
    },
    lockZeroParamFunctions: config.level.lockZeroParamFunctions
  };

  $.extend(modeOptions.functions, getModeOptionFunctionsFromConfig({ blocks: exports.dropletGlobalConfigBlocks }), getModeOptionFunctionsFromConfig({ blocks: exports.dropletBuiltinConfigBlocks }), getModeOptionFunctionsFromConfig(config.dropletConfig));

  return modeOptions;
};

/**
 * Returns a set of all blocks
 * @param {DropletConfig|null} dropletConfig custom configuration, may be null
 * @param {codeFunctions|null} codeFunctions with block overrides, may be null
 * @param paletteOnly boolean: filter to only those blocks that are in codeFunctions
 *   palette, or who share documentation (via docFunc) with other blocks that are
 * @returns {DropletBlock[]} a list of all available Droplet blocks,
 *      including the given config's blocks
 */
exports.getAllAvailableDropletBlocks = function (dropletConfig, codeFunctions, paletteOnly) {
  var hasConfiguredBlocks = dropletConfig && dropletConfig.blocks;
  var configuredBlocks = hasConfiguredBlocks ? dropletConfig.blocks : [];
  if (codeFunctions && hasConfiguredBlocks) {
    configuredBlocks = filteredBlocksFromConfig(codeFunctions, dropletConfig, null, { paletteOnly: paletteOnly });
  }
  return exports.dropletGlobalConfigBlocks.concat(exports.dropletBuiltinConfigBlocks).concat(standardConfig.blocks).concat(configuredBlocks);
};

exports.__TestInterface = {
  mergeCategoriesWithConfig: mergeCategoriesWithConfig,
  filteredBlocksFromConfig: filteredBlocksFromConfig
};

},{"./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/ObservableEvent.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

/**
 * A subscription/notification atom, used to cleanly hook up callbacks
 * without attaching anything to the DOM or other global scope.
 * @constructor
 */
var ObservableEvent = module.exports = function () {
  /**
   * Objects observing this.
   * @type {Array}
   * @private
   */
  this.observerList_ = [];
};

/**
 * Subscribe a method to be called when notifyObservers is called.
 * @param {function} onNotify - method called when notifyObservers gets called.
 *        Will receive any arguments passed to notifyObservers.
 * @returns {Object} key - used to unregister from observable
 */
ObservableEvent.prototype.register = function (onNotify) {
  var key = { toCall: onNotify };
  Object.freeze(key);
  this.observerList_.push(key);
  return key;
};

/**
 * Unsubscribe from notifications.
 * @param {Object} keyObj - Key generated when registering
 * @returns {boolean} - Whether an unregistration actually occurred
 */
ObservableEvent.prototype.unregister = function (keyObj) {
  for (var i = 0; i < this.observerList_.length; i++) {
    if (keyObj === this.observerList_[i]) {
      this.observerList_.splice(i, 1);
      return true;
    }
  }
  return false;
};

/**
 * Call all methods subscribed to this ObservableEvent, passing through
 * any arguments.
 * @param {...} Any arguments, which are passed through to the observing
 *              functions.
 */
ObservableEvent.prototype.notifyObservers = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this.observerList_.forEach(function (observer) {
    observer.toCall.apply(undefined, args);
  });
};

},{}],"/home/ubuntu/staging/apps/build/js/DebugArea.js":[function(require,module,exports){
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */

'use strict';

var i18n = require('./locale');
var dom = require('./dom');
var utils = require('./utils');

/**
 * Creates the debug area controller and configures it to operate on the given
 * elements.
 *
 * @param {HTMLDivElement} debugAreaRoot
 * @param {HTMLDivElement} codeTextboxRoot
 * @constructor
 */
var DebugArea = module.exports = function (debugAreaRoot, codeTextboxRoot) {
  if (!debugAreaRoot || !codeTextboxRoot) {
    throw new Error("debugAreaRoot and codeTextboxRoot are required");
  }

  /**
   * @type {jQuery}
   * @private
   */
  this.rootDiv_ = $(debugAreaRoot);

  /**
   * @type {jQuery}
   * @private
   */
  this.codeTextbox_ = $(codeTextboxRoot);

  /**
   * @type {boolean}
   * @private
   */
  this.isOpen_ = true;

  /**
   * @type {number}
   * @private
   */
  this.lastOpenHeight_ = this.rootDiv_.height();

  DebugArea.prototype.bindHandlersForDebugCommandsHeader.call(this);
};

/**
 * Binds mouseover, mouseout, click and touch handlers for the debug commands
 * header div.
 */
DebugArea.prototype.bindHandlersForDebugCommandsHeader = function () {
  var toggleDebugIcon = this.rootDiv_.find('#show-hide-debug-icon');
  dom.addClickTouchEvent(toggleDebugIcon[0], DebugArea.prototype.slideToggle.bind(this));
};

/** @returns {boolean} */
DebugArea.prototype.isOpen = function () {
  return this.isOpen_;
};

/** @returns {boolean} */
DebugArea.prototype.isShut = function () {
  return !this.isOpen_;
};

/**
 * Open/close the debug area to the reverse of its current state, using no
 * animation.
 */
DebugArea.snapToggle = function () {
  if (this.isOpen_) {
    this.snapShut();
  } else {
    this.snapOpen();
  }
};

DebugArea.prototype.snapOpen = function () {
  this.isOpen_ = true;
  this.setContentsVisible(true);
  this.setIconPointingDown(true);
  this.setHeight(this.lastOpenHeight_);

  // Set the 'clear' button visible
  this.rootDiv_.find('#clear-console-header').css('opacity', 1).css('visibility', 'visible');
};

DebugArea.prototype.snapShut = function () {
  this.isOpen_ = false;
  this.lastOpenHeight_ = this.rootDiv_.height();
  this.setContentsVisible(false);
  this.setIconPointingDown(false);
  this.setHeight(this.getHeightWhenClosed());

  // Set the 'clear' button hidden (not display:none, it should take up space)
  this.rootDiv_.find('#clear-console-header').css('opacity', 0).css('visibility', 'hidden');
};

/**
 * Open/close the debug area to the reverse of its current state, using a
 * slide animation.
 */
DebugArea.prototype.slideToggle = function () {
  if (this.isOpen_) {
    this.slideShut();
  } else {
    this.slideOpen();
  }
};

DebugArea.prototype.slideOpen = function () {
  this.isOpen_ = true;
  this.setContentsVisible(true);

  // Manually remove hover effect at start and end of animation to get *close*
  // to the correct effect.
  this.rootDiv_.animate({
    height: this.lastOpenHeight_
  }, {
    complete: (function () {
      this.setIconPointingDown(true);
    }).bind(this)
  });

  // Animate the bottom of the workspace at the same time
  this.codeTextbox_.animate({
    bottom: this.lastOpenHeight_
  }, {
    step: utils.fireResizeEvent
  });

  // Animate the 'clear' button appearing at the same time
  var clearButton = this.rootDiv_.find('#clear-console-header');
  clearButton.css('visibility', 'visible');
  clearButton.animate({
    opacity: 1.0
  });
};

DebugArea.prototype.slideShut = function () {
  this.isOpen_ = false;
  this.lastOpenHeight_ = this.rootDiv_.height();

  // We will leave the header and resize bar visible, so together they
  // constitute our height when closed.
  var closedHeight = this.getHeightWhenClosed();
  // Manually remove hover effect at start and end of animation to get *close*
  // to the correct effect.
  this.rootDiv_.animate({
    height: closedHeight
  }, {
    complete: (function () {
      this.setContentsVisible(false);
      this.setIconPointingDown(false);
    }).bind(this)
  });

  // Animate the bottom of the workspace at the same time
  this.codeTextbox_.animate({
    bottom: closedHeight
  }, {
    step: utils.fireResizeEvent,
    complete: utils.fireResizeEvent
  });

  // Animate the 'clear' button vanishing at the same time
  var clearButton = this.rootDiv_.find('#clear-console-header');
  clearButton.animate({
    opacity: 0.0
  }, {
    complete: function complete() {
      clearButton.css('visibility', 'hidden');
    }
  });
};

DebugArea.prototype.setContentsVisible = function (isVisible) {
  this.rootDiv_.find('#debug-commands').toggle(isVisible);
  this.rootDiv_.find('#debug-console').toggle(isVisible);
};

DebugArea.prototype.setIconPointingDown = function (isPointingDown) {
  var commandsHeader = this.rootDiv_.find('#debug-commands-header');

  var icon = this.rootDiv_.find('#show-hide-debug-icon');
  icon.toggleClass('fa-chevron-circle-up', !isPointingDown);
  icon.toggleClass('fa-chevron-circle-down', isPointingDown);

  var headerText = commandsHeader.find('.header-text');
  headerText.text(isPointingDown ? i18n.debugCommandsHeaderWhenOpen() : i18n.debugCommandsHeaderWhenClosed());
};

DebugArea.prototype.setHeight = function (newHeightInPixels) {
  this.rootDiv_.height(newHeightInPixels);
  this.codeTextbox_.css('bottom', newHeightInPixels);
  utils.fireResizeEvent();
};

DebugArea.prototype.getHeightWhenClosed = function () {
  return this.rootDiv_.find('#debug-area-header').height() + this.rootDiv_.find('#debugResizeBar').height();
};

},{"./dom":"/home/ubuntu/staging/apps/build/js/dom.js","./locale":"/home/ubuntu/staging/apps/build/js/locale.js","./utils":"/home/ubuntu/staging/apps/build/js/utils.js"}],"/home/ubuntu/staging/apps/build/js/utils.js":[function(require,module,exports){
/* global define */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var savedAmd;

// Do some hackery to make it so that lodash doesn't think it's being loaded
// via require js
if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
  savedAmd = define.amd;
  define.amd = false;
}

// get lodash
var _ = require('./lodash');
var Hammer = require('./hammer');

// undo hackery
if (typeof define === 'function' && savedAmd) {
  define.amd = savedAmd;
  savedAmd = null;
}

exports.getLodash = function () {
  return _;
};

exports.getHammer = function () {
  return Hammer;
};

exports.shallowCopy = function (source) {
  var result = {};
  for (var prop in source) {
    result[prop] = source[prop];
  }

  return result;
};

/**
 * Returns a clone of the object, stripping any functions on it.
 */
exports.cloneWithoutFunctions = function (object) {
  return JSON.parse(JSON.stringify(object));
};

/**
 * Returns a string with a double quote before and after.
 */
exports.quote = function (str) {
  return '"' + str + '"';
};

/**
 * Returns a new object with the properties from defaults overridden by any
 * properties in options. Leaves defaults and options unchanged.
 * NOTE: For new code, use $.extend({}, defaults, options) instead
 */
exports.extend = function (defaults, options) {
  var finalOptions = exports.shallowCopy(defaults);
  for (var prop in options) {
    finalOptions[prop] = options[prop];
  }

  return finalOptions;
};

exports.escapeHtml = function (unsafe) {
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
};

/**
 * Version of modulo which, unlike javascript's `%` operator,
 * will always return a positive remainder.
 * @param number
 * @param mod
 */
exports.mod = function (number, mod) {
  return (number % mod + mod) % mod;
};

/**
 * Generates an array of integers from start to end inclusive
 */
exports.range = function (start, end) {
  var ints = [];
  for (var i = start; i <= end; i++) {
    ints.push(i);
  }
  return ints;
};

/**
 * Given two functions, generates a function that returns the result of the
 * second function if and only if the first function returns true
 */
exports.executeIfConditional = function (conditional, fn) {
  return function () {
    if (conditional()) {
      return fn.apply(this, arguments);
    }
  };
};

/**
 * Removes all single and double quotes from a string
 * @param inputString
 * @returns {string} string without quotes
 */
exports.stripQuotes = function (inputString) {
  return inputString.replace(/["']/g, "");
};

/**
 * Defines an inheritance relationship between parent class and this class.
 */
Function.prototype.inherits = function (parent) {
  this.prototype = Object.create(parent.prototype);
  this.prototype.constructor = this;
  this.superPrototype = parent.prototype;
};

/**
 * Wrap a couple of our Blockly number validators to allow for ???.  This is
 * done so that level builders can specify required blocks with wildcard fields.
 */
exports.wrapNumberValidatorsForLevelBuilder = function () {
  var nonNeg = Blockly.FieldTextInput.nonnegativeIntegerValidator;
  var numVal = Blockly.FieldTextInput.numberValidator;

  Blockly.FieldTextInput.nonnegativeIntegerValidator = function (text) {
    if (text === '???') {
      return text;
    }
    return nonNeg(text);
  };

  Blockly.FieldTextInput.numberValidator = function (text) {
    if (text === '???') {
      return text;
    }
    return numVal(text);
  };
};

/**
 * Return a random key name from an object.
 *
 * Slightly modified from: http://stackoverflow.com/a/15106541
 */

exports.randomKey = function (obj) {
  var keys = Object.keys(obj);
  return keys[keys.length * Math.random() << 0];
};

/**
 * Generate a random identifier in a format matching the RFC-4122 specification.
 *
 * Taken from
 * {@link http://byronsalau.com/blog/how-to-create-a-guid-uuid-in-javascript/}
 *
 * @see RFC-4122 standard {@link http://www.ietf.org/rfc/rfc4122.txt}
 *
 * @returns {string} RFC4122-compliant UUID
 */
exports.createUuid = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

exports.fireResizeEvent = function () {
  var ev = document.createEvent('Event');
  ev.initEvent('resize', true, true);
  window.dispatchEvent(ev);
};

// ECMAScript 6 polyfill for String.prototype.repeat
// Polyfill adapted from
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference
//        /Global_Objects/String/repeat
if (!String.prototype.repeat) {
  /**
   * The repeat() method constructs and returns a new string which contains
   * the specified number of copies of the string on which it was called,
   * concatenated together?
   * @param {number} count
   * @returns {string}
   */
  String.prototype.repeat = function (count) {
    if (this === null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count !== count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count === Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length === 0 || count === 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (august 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) === 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count === 0) {
        break;
      }
      str += str;
    }
    return rpt;
  };
}

/**
 * Similar to val || defaultVal, except it's gated on whether or not val is
 * undefined instead of whether val is falsey.
 * @returns {*} val if not undefined, otherwise defaultVal
 */
exports.valueOr = function (val, defaultVal) {
  return val === undefined ? defaultVal : val;
};

/**
 * Attempts to analyze whether or not err represents infinite recursion having
 * occurred. This error differs per browser, and it's possible that we don't
 * properly discover all cases.
 * Note: Other languages probably have localized messages, meaning we won't
 * catch them.
 */
exports.isInfiniteRecursionError = function (err) {
  // Chrome/Safari: message ends in a period in Safari, not in Chrome
  if (err instanceof RangeError && /^Maximum call stack size exceeded/.test(err.message)) {
    return true;
  }

  // Firefox
  /* jshint ignore:start */
  // Linter doesn't like our use of InternalError, even though we gate on its
  // existence.
  if (typeof InternalError !== 'undefined' && err instanceof InternalError && err.message === 'too much recursion') {
    return true;
  }
  /* jshint ignore:end */

  // IE
  if (err instanceof Error && err.message === 'Out of stack space') {
    return true;
  }

  return false;
};

// TODO(dave): move this logic to dashboard.
exports.getPegasusHost = function () {
  switch (window.location.hostname) {
    case 'studio.code.org':
    case 'learn.code.org':
      return 'code.org';
    default:
      var name = window.location.hostname.split('.')[0];
      switch (name) {
        case 'localhost':
          return 'localhost.code.org:3000';
        case 'development':
        case 'staging':
        case 'test':
        case 'levelbuilder':
          return name + '.code.org';
        case 'staging-studio':
          return 'staging.code.org';
        case 'test-studio':
          return 'test.code.org';
        case 'levelbuilder-studio':
          return 'levelbuilder.code.org';
        default:
          return null;
      }
  }
};

/**
 * IE9 throws an exception when trying to access the media field of a stylesheet
 */
exports.browserSupportsCssMedia = function () {
  var styleSheets = document.styleSheets;
  for (var i = 0; i < styleSheets.length; i++) {
    var rules = styleSheets[i].cssRules || styleSheets[i].rules;
    try {
      if (rules.length > 0) {
        // see if we can access media
        var media = rules[0].media; // jshint ignore:line
      }
    } catch (e) {
      return false;
    }
  }
  return true;
};

/**
 * Remove escaped characters and HTML to convert some rendered text to what should appear in user-edited controls
 * @param text
 * @returns String that has no more escape characters and multiple divs converted to newlines
 */
exports.unescapeText = function (text) {
  var cleanedText = text;
  cleanedText = cleanedText.replace(/<div>/gi, '\n'); // Divs generate newlines
  cleanedText = cleanedText.replace(/<[^>]+>/gi, ''); // Strip all other tags

  // This next step requires some explanation
  // In multiline text it's possible for the first line to render wrapped or unwrapped.
  //     Line 1
  //     Line 2
  //   Can render as either of:
  //     Line 1<div>Line 2</div>
  //     <div>Line 1</div><div>Line 2</div>
  //
  // But leading blank lines will always render wrapped and should be preserved
  //
  //     Line 2
  //     Line 3
  //   Renders as
  //    <div><br></div><div>Line 2</div><div>Line 3</div>
  //
  // To handle this behavior we strip leading newlines UNLESS they are followed
  // by another newline, using a negative lookahead (?!)
  cleanedText = cleanedText.replace(/^\n(?!\n)/, ''); // Strip leading nondoubled newline

  cleanedText = cleanedText.replace(/&nbsp;/gi, ' '); // Unescape nonbreaking spaces
  cleanedText = cleanedText.replace(/&gt;/gi, '>'); // Unescape >
  cleanedText = cleanedText.replace(/&lt;/gi, '<'); // Unescape <
  cleanedText = cleanedText.replace(/&amp;/gi, '&'); // Unescape & (must happen last!)
  return cleanedText;
};

/**
 * Escape special characters in a piece of text, and convert newlines to seperate divs
 * @param text
 * @returns String with special characters escaped and newlines converted divs
 */
exports.escapeText = function (text) {
  var escapedText = text.toString();
  escapedText = escapedText.replace(/&/g, '&amp;'); // Escape & (must happen first!)
  escapedText = escapedText.replace(/</g, '&lt;'); // Escape <
  escapedText = escapedText.replace(/>/g, '&gt;'); // Escape >
  escapedText = escapedText.replace(/  /g, ' &nbsp;'); // Escape doubled spaces

  // Now wrap each line except the first line in a <div>,
  // replacing blank lines with <div><br><div>
  var lines = escapedText.split('\n');
  var returnValue = lines[0] + lines.slice(1).map(function (line) {
    return '<div>' + (line.length ? line : '<br>') + '</div>';
  }).join('');

  return returnValue;
};

/**
 * Converts degrees into radians.
 *
 * @param degrees - The degrees to convert to radians
 * @return `degrees` converted to radians
 */
exports.degreesToRadians = function (degrees) {
  return degrees * (Math.PI / 180);
};

/**
 * Simple wrapper around localStorage.setItem that catches any exceptions (for
 * example when we call setItem in Safari's private mode)
 * @return {boolean} True if we set successfully
 */
exports.trySetLocalStorage = function (item, value) {
  try {
    localStorage.setItem(item, value);
    return true;
  } catch (e) {
    return false;
  }
};

},{"./hammer":"/home/ubuntu/staging/apps/build/js/hammer.js","./lodash":"/home/ubuntu/staging/apps/build/js/lodash.js"}],"/home/ubuntu/staging/apps/build/js/lodash.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash include="debounce,reject,map,value,range,without,sample,create,flatten,isEmpty,wrap,size,bind,contains,last,clone,cloneDeep,isEqual,find,sortBy,throttle,uniq" --output src/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
'use strict';

;(function () {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date() + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowedProps = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used as the data object for `iteratorTemplate` */
  var iteratorData = {
    'args': '',
    'array': null,
    'bottom': '',
    'firstArg': '',
    'init': '',
    'keys': null,
    'loop': '',
    'shadowedProps': null,
    'support': null,
    'top': '',
    'useHas': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used as a reference to the global object */
  var root = objectTypes[typeof window] && window || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object' ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[length / 2 | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
  function isNode(value) {
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');

  /** Native method shortcuts */
  var ceil = Math.ceil,
      floor = Math.floor,
      fnToString = Function.prototype.toString,
      hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      unshift = arrayRef.unshift;

  /** Used to set meta data on functions */
  var defineProperty = (function () {
    // IE 8 only accepts DOM elements
    try {
      var o = {},
          func = isNative(func = Object.defineProperty) && func,
          result = func(o, o, o) && func;
    } catch (e) {}
    return result;
  })();

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /** Used to lookup a built-in constructor by [[Class]] */
  var ctorByClass = {};
  ctorByClass[arrayClass] = Array;
  ctorByClass[boolClass] = Boolean;
  ctorByClass[dateClass] = Date;
  ctorByClass[funcClass] = Function;
  ctorByClass[objectClass] = Object;
  ctorByClass[numberClass] = Number;
  ctorByClass[regexpClass] = RegExp;
  ctorByClass[stringClass] = String;

  /** Used to avoid iterating non-enumerable properties in IE < 9 */
  var nonEnumProps = {};
  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
  nonEnumProps[objectClass] = { 'constructor': true };

  (function () {
    var length = shadowedProps.length;
    while (length--) {
      var key = shadowedProps[length];
      for (var className in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
          nonEnumProps[className][key] = false;
        }
      }
    }
  })();

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
    return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
  }

  /**
   * A fast path for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap in a `lodash` instance.
   * @param {boolean} chainAll A flag to enable chaining for all methods
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodashWrapper(value, chainAll) {
    this.__chain__ = !!chainAll;
    this.__wrapped__ = value;
  }
  // ensure `new lodashWrapper` is an instance of `lodash`
  lodashWrapper.prototype = lodash.prototype;

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = lodash.support = {};

  (function () {
    var ctor = function ctor() {
      this.x = 1;
    },
        object = { '0': 1, 'length': 1 },
        props = [];

    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var key in new ctor()) {
      props.push(key);
    }
    for (key in arguments) {}

    /**
     * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsClass = toString.call(arguments) == argsClass;

    /**
     * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

    /**
     * Detect if `name` or `message` properties of `Error.prototype` are
     * enumerable by default. (IE < 9, Safari < 5.1)
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

    /**
     * Detect if `prototype` properties are enumerable by default.
     *
     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
     * (if the prototype or a property on the prototype has been set)
     * incorrectly sets a function's `prototype` property [[Enumerable]]
     * value to `true`.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function () {
      return this;
    });

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * Detect if `arguments` object indexes are non-enumerable
     * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumArgs = key != 0;

    /**
     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
     *
     * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
     * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumShadows = !/valueOf/.test(props);

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

    /**
     * Detect lack of support for accessing string characters by index.
     *
     * IE < 8 can't access characters by index and IE 8 can only access
     * characters by index on string literals.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';

    /**
     * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
     * and that the JS engine errors when attempting to coerce an object to
     * a string without a `toString` function.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
    } catch (e) {
      support.nodeClass = true;
    }
  })(1);

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Object} data The data object used to populate the text.
   * @returns {string} Returns the interpolated text.
   */
  var iteratorTemplate = function iteratorTemplate(obj) {

    var __p = 'var index, iterable = ' + obj.firstArg + ', result = ' + obj.init + ';\nif (!iterable) return result;\n' + obj.top + ';';
    if (obj.array) {
      __p += '\nvar length = iterable.length; index = -1;\nif (' + obj.array + ') {  ';
      if (support.unindexedChars) {
        __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
      }
      __p += '\n  while (++index < length) {\n    ' + obj.loop + ';\n  }\n}\nelse {  ';
    } else if (support.nonEnumArgs) {
      __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' + obj.loop + ';\n    }\n  } else {  ';
    }

    if (support.enumPrototypes) {
      __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
    }

    if (support.enumErrorProps) {
      __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
    }

    var conditions = [];if (support.enumPrototypes) {
      conditions.push('!(skipProto && index == "prototype")');
    }if (support.enumErrorProps) {
      conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
    }

    if (obj.useHas && obj.keys) {
      __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
      if (conditions.length) {
        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
      }
      __p += obj.loop + ';    ';
      if (conditions.length) {
        __p += '\n    }';
      }
      __p += '\n  }  ';
    } else {
      __p += '\n  for (index in iterable) {\n';
      if (obj.useHas) {
        conditions.push("hasOwnProperty.call(iterable, index)");
      }if (conditions.length) {
        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
      }
      __p += obj.loop + ';    ';
      if (conditions.length) {
        __p += '\n    }';
      }
      __p += '\n  }    ';
      if (support.nonEnumShadows) {
        __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
        for (k = 0; k < 7; k++) {
          __p += '\n    index = \'' + obj.shadowedProps[k] + '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
          if (!obj.useHas) {
            __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
          }
          __p += ') {\n      ' + obj.loop + ';\n    }      ';
        }
        __p += '\n  }    ';
      }
    }

    if (obj.array || support.nonEnumArgs) {
      __p += '\n}';
    }
    __p += obj.bottom + ';\nreturn result';

    return __p;
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor's `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * The base implementation of `_.clone` without argument juggling or support
   * for `thisArg` binding.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates clones with source counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, callback, stackA, stackB) {
    if (callback) {
      var result = callback(value);
      if (typeof result != 'undefined') {
        return result;
      }
    }
    // inspect [[Class]]
    var isObj = isObject(value);
    if (isObj) {
      var className = toString.call(value);
      if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
        return value;
      }
      var ctor = ctorByClass[className];
      switch (className) {
        case boolClass:
        case dateClass:
          return new ctor(+value);

        case numberClass:
        case stringClass:
          return new ctor(value);

        case regexpClass:
          result = ctor(value.source, reFlags.exec(value));
          result.lastIndex = value.lastIndex;
          return result;
      }
    } else {
      return value;
    }
    var isArr = isArray(value);
    if (isDeep) {
      // check for circular references and return corresponding clone
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      result = isArr ? ctor(value.length) : {};
    } else {
      result = isArr ? slice(value) : assign({}, value);
    }
    // add array properties assigned by `RegExp#exec`
    if (isArr) {
      if (hasOwnProperty.call(value, 'index')) {
        result.index = value.index;
      }
      if (hasOwnProperty.call(value, 'input')) {
        result.input = value.input;
      }
    }
    // exit for shallow clone
    if (!isDeep) {
      return result;
    }
    // add the source value to the stack of traversed objects
    // and associate it with its clone
    stackA.push(value);
    stackB.push(result);

    // recursively populate clone (susceptible to call stack limits)
    (isArr ? baseEach : forOwn)(value, function (objValue, key) {
      result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
    });

    if (initedStack) {
      releaseArray(stackA);
      releaseArray(stackB);
    }
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(prototype, properties) {
    return isObject(prototype) ? nativeCreate(prototype) : {};
  }
  // fallback for browsers without `Object.create`
  if (!nativeCreate) {
    baseCreate = (function () {
      function Object() {}
      return function (prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object();
          Object.prototype = null;
        }
        return result || root.Object();
      };
    })();
  }

  /**
   * The base implementation of `_.createCallback` without support for creating
   * "_.pluck" or "_.where" style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
      return func;
    }
    var bindData = func.__bindData__;
    if (typeof bindData == 'undefined') {
      if (support.funcNames) {
        bindData = !func.name;
      }
      bindData = bindData || !support.funcDecomp;
      if (!bindData) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          bindData = !reFuncName.test(source);
        }
        if (!bindData) {
          // checks if `func` references the `this` keyword and stores the result
          bindData = reThis.test(source);
          setBindData(func, bindData);
        }
      }
    }
    // exit early if there are no `this` references or `func` is bound
    if (bindData === false || bindData !== true && bindData[1] & 1) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function (value) {
          return func.call(thisArg, value);
        };
      case 2:
        return function (a, b) {
          return func.call(thisArg, a, b);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry && args.length < arity) {
          bitmask |= 16 & ~32;
          return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * The base implementation of `_.difference` that accepts a single array
   * of values to exclude.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {Array} [values] The array of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   */
  function baseDifference(array, values) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        isLarge = length >= largeArraySize && indexOf === baseIndexOf,
        result = [];

    if (isLarge) {
      var cache = createCache(values);
      if (cache) {
        indexOf = cacheIndexOf;
        values = cache;
      } else {
        isLarge = false;
      }
    }
    while (++index < length) {
      var value = array[index];
      if (indexOf(values, value) < 0) {
        result.push(value);
      }
    }
    if (isLarge) {
      releaseObject(values);
    }
    return result;
  }

  /**
   * The base implementation of `_.flatten` without support for callback
   * shorthands or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
   * @param {number} [fromIndex=0] The index to start from.
   * @returns {Array} Returns a new flattened array.
   */
  function baseFlatten(array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
        // recursively flatten arrays (susceptible to call stack limits)
        if (!isShallow) {
          value = baseFlatten(value, isShallow, isStrict);
        }
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        while (++valIndex < valLength) {
          result[resIndex++] = value[valIndex];
        }
      } else if (!isStrict) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isEqual`, without support for `thisArg` binding,
   * that allows partial "_.where" style comparisons.
   *
   * @private
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `a` objects.
   * @param {Array} [stackB=[]] Tracks traversed `b` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(_x, _x2, _x3, _x4, _x5, _x6) {
    var _again = true;

    _function: while (_again) {
      var a = _x,
          b = _x2,
          callback = _x3,
          isWhere = _x4,
          stackA = _x5,
          stackB = _x6;
      _again = false;

      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || 1 / a == 1 / b;
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return a != +a ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : a == 0 ? 1 / a == 1 / b : a == +b;

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          _x = aWrapped ? a.__wrapped__ : a;
          _x2 = bWrapped ? b.__wrapped__ : b;
          _x3 = callback;
          _x4 = isWhere;
          _x5 = stackA;
          _x6 = stackB;
          _again = true;
          result = type = otherType = className = otherClass = isArr = aWrapped = bWrapped = undefined;
          continue _function;
        }
        // exit for functions and DOM nodes
        if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && 'constructor' in a && 'constructor' in b) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function (value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function (value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return result = --size > -1;
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
  }

  /**
   * The base implementation of `_.random` without argument juggling or support
   * for returning floating-point numbers.
   *
   * @private
   * @param {number} min The minimum possible value.
   * @param {number} max The maximum possible value.
   * @returns {number} Returns a random number.
   */
  function baseRandom(min, max) {
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * The base implementation of `_.uniq` without support for callback shorthands
   * or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function} [callback] The function called per iteration.
   * @returns {Array} Returns a duplicate-value-free array.
   */
  function baseUniq(array, isSorted, callback) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
        seen = callback || isLarge ? getArray() : result;

    if (isLarge) {
      var cache = createCache(seen);
      indexOf = cacheIndexOf;
      seen = cache;
    }
    while (++index < length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
        if (callback || isLarge) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    if (isLarge) {
      releaseArray(seen.array);
      releaseObject(seen);
    } else if (callback) {
      releaseArray(seen);
    }
    return result;
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(_x7, _x8, _x9, _x10, _x11, _x12) {
    var _arguments2 = arguments;
    var _again2 = true;

    _function2: while (_again2) {
      var func = _x7,
          bitmask = _x8,
          partialArgs = _x9,
          partialRightArgs = _x10,
          thisArg = _x11,
          arity = _x12;
      _again2 = false;

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError();
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        _arguments2 = bindData;
        _x7 = _arguments2[0];
        _x8 = _arguments2[1];
        _x9 = _arguments2[2];
        _x10 = _arguments2[3];
        _x11 = _arguments2[4];
        _x12 = _arguments2[5];
        _again2 = true;
        isBind = isBindKey = isCurry = isCurryBound = isPartial = isPartialRight = bindData = undefined;
        continue _function2;
      }
      // fast path for `_.bind`
      var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {...Object} [options] The compile options object(s).
   * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
   * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
   * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
   * @param {string} [options.args] A comma separated string of iteration function arguments.
   * @param {string} [options.top] Code to execute before the iteration branches.
   * @param {string} [options.loop] Code to execute in the object loop.
   * @param {string} [options.bottom] Code to execute after the iteration branches.
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    // data properties
    iteratorData.shadowedProps = shadowedProps;

    // iterator options
    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
    iteratorData.init = 'iterable';
    iteratorData.useHas = true;

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        iteratorData[key] = object[key];
      }
    }
    var args = iteratorData.args;
    iteratorData.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function('baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' + 'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' + 'objectTypes, nonEnumProps, stringClass, stringProto, toString', 'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}');

    // return the compiled function
    return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
  }

  /**
   * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
   * customized, this method returns the custom method, otherwise it returns
   * the `baseIndexOf` function.
   *
   * @private
   * @returns {Function} Returns the "indexOf" function.
   */
  function getIndexOf() {
    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
    return result;
  }

  /**
   * Checks if `value` is a native function.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
   */
  function isNative(value) {
    return typeof value == 'function' && reNative.test(value);
  }

  /**
   * Sets `this` binding data on a given function.
   *
   * @private
   * @param {Function} func The function to set data on.
   * @param {Array} value The data array to set.
   */
  var setBindData = !defineProperty ? noop : function (func, value) {
    descriptor.value = value;
    defineProperty(func, '__bindData__', descriptor);
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (!support.argsClass) {
    isArguments = function (value) {
      return value && typeof value == 'object' && typeof value.length == 'number' && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
    };
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function (value) {
    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
  };

  /**
   * A fallback implementation of `Object.keys` which produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @type Function
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   */
  var shimKeys = createIterator({
    'args': 'object',
    'init': '[]',
    'top': 'if (!(objectTypes[typeof object])) return result',
    'loop': 'result.push(index)'
  });

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
   */
  var keys = !nativeKeys ? shimKeys : function (object) {
    if (!isObject(object)) {
      return [];
    }
    if (support.enumPrototypes && typeof object == 'function' || support.nonEnumArgs && object.length && isArguments(object)) {
      return shimKeys(object);
    }
    return nativeKeys(object);
  };

  /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
  var eachIteratorOptions = {
    'args': 'collection, callback, thisArg',
    'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
    'array': "typeof length == 'number'",
    'keys': keys,
    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
  };

  /** Reusable iterator options for `assign` and `defaults` */
  var defaultsIteratorOptions = {
    'args': 'object, source, guard',
    'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
    'keys': keys,
    'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
    'bottom': '  }\n}'
  };

  /** Reusable iterator options for `forIn` and `forOwn` */
  var forOwnIteratorOptions = {
    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
    'array': false
  };

  /**
   * A function compiled to iterate `arguments` objects, arrays, objects, and
   * strings consistenly across environments, executing the callback for each
   * element in the collection. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index|key, collection). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @private
   * @type Function
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   */
  var baseEach = createIterator(eachIteratorOptions);

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
   * // => { 'name': 'fred', 'employer': 'slate' }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == 'undefined' ? b : a;
   * });
   *
   * var object = { 'name': 'barney' };
   * defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  var assign = createIterator(defaultsIteratorOptions, {
    'top': defaultsIteratorOptions.top.replace(';', ';\n' + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + '  callback = args[--argsLength];\n' + '}'),
    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
  });

  /**
   * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
   * be cloned, otherwise they will be assigned by reference. If a callback
   * is provided it will be executed to produce the cloned values. If the
   * callback returns `undefined` cloning will be handled by the method instead.
   * The callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the cloned value.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * var shallow = _.clone(characters);
   * shallow[0] === characters[0];
   * // => true
   *
   * var deep = _.clone(characters, true);
   * deep[0] === characters[0];
   * // => false
   *
   * _.mixin({
   *   'clone': _.partialRight(_.clone, function(value) {
   *     return _.isElement(value) ? value.cloneNode(false) : undefined;
   *   })
   * });
   *
   * var clone = _.clone(document.body);
   * clone.childNodes.length;
   * // => 0
   */
  function clone(value, isDeep, callback, thisArg) {
    // allows working with "Collections" methods without using their `index`
    // and `collection` arguments for `isDeep` and `callback`
    if (typeof isDeep != 'boolean' && isDeep != null) {
      thisArg = callback;
      callback = isDeep;
      isDeep = false;
    }
    return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
  }

  /**
   * Creates a deep clone of `value`. If a callback is provided it will be
   * executed to produce the cloned values. If the callback returns `undefined`
   * cloning will be handled by the method instead. The callback is bound to
   * `thisArg` and invoked with one argument; (value).
   *
   * Note: This method is loosely based on the structured clone algorithm. Functions
   * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
   * objects created by constructors other than `Object` are cloned to plain `Object` objects.
   * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the deep cloned value.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * var deep = _.cloneDeep(characters);
   * deep[0] === characters[0];
   * // => false
   *
   * var view = {
   *   'label': 'docs',
   *   'node': element
   * };
   *
   * var clone = _.cloneDeep(view, function(value) {
   *   return _.isElement(value) ? value.cloneNode(true) : undefined;
   * });
   *
   * clone.node == view.node;
   * // => false
   */
  function cloneDeep(value, callback, thisArg) {
    return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
  }

  /**
   * Creates an object that inherits from the given `prototype` object. If a
   * `properties` object is provided its own enumerable properties are assigned
   * to the created object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} prototype The object to inherit from.
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * function Circle() {
   *   Shape.call(this);
   * }
   *
   * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
   *
   * var circle = new Circle;
   * circle instanceof Circle;
   * // => true
   *
   * circle instanceof Shape;
   * // => true
   */
  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties ? assign(result, properties) : result;
  }

  /**
   * Iterates over own and inherited enumerable properties of an object,
   * executing the callback for each property. The callback is bound to `thisArg`
   * and invoked with three arguments; (value, key, object). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * Shape.prototype.move = function(x, y) {
   *   this.x += x;
   *   this.y += y;
   * };
   *
   * _.forIn(new Shape, function(value, key) {
   *   console.log(key);
   * });
   * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
   */
  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
    'useHas': false
  });

  /**
   * Iterates over own enumerable properties of an object, executing the callback
   * for each property. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   console.log(key);
   * });
   * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
   */
  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

  /**
   * Creates a sorted array of property names of all enumerable properties,
   * own and inherited, of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function (value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * "empty".
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|string} value The value to inspect.
   * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({});
   * // => true
   *
   * _.isEmpty('');
   * // => true
   */
  function isEmpty(value) {
    var result = true;
    if (!value) {
      return result;
    }
    var className = toString.call(value),
        length = value.length;

    if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
      return !length;
    }
    forOwn(value, function () {
      return result = false;
    });
    return result;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other. If a callback is provided it will be executed
   * to compare values. If the callback returns `undefined` comparisons will
   * be handled by the method instead. The callback is bound to `thisArg` and
   * invoked with two arguments; (a, b).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * var copy = { 'name': 'fred' };
   *
   * object == copy;
   * // => false
   *
   * _.isEqual(object, copy);
   * // => true
   *
   * var words = ['hello', 'goodbye'];
   * var otherWords = ['hi', 'goodbye'];
   *
   * _.isEqual(words, otherWords, function(a, b) {
   *   var reGreet = /^(?:hello|hi)$/i,
   *       aGreet = _.isString(a) && reGreet.test(a),
   *       bGreet = _.isString(b) && reGreet.test(b);
   *
   *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
   * });
   * // => true
   */
  function isEqual(a, b, callback, thisArg) {
    return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function (value) {
      return typeof value == 'function' && toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value && objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('fred');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property values.
   * @example
   *
   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
   * // => [1, 2, 3] (property order is not guaranteed across environments)
   */
  function values(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index < length) {
      result[index] = object[props[index]];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given value is present in a collection using strict equality
   * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
   * offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {*} target The value to check for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // => true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // => false
   *
   * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
   * // => true
   *
   * _.contains('pebbles', 'eb');
   * // => true
   */
  function contains(collection, target, fromIndex) {
    var index = -1,
        indexOf = getIndexOf(),
        length = collection ? collection.length : 0,
        result = false;

    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
    if (isArray(collection)) {
      result = indexOf(collection, target, fromIndex) > -1;
    } else if (typeof length == 'number') {
      result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
    } else {
      baseEach(collection, function (value) {
        if (++index >= fromIndex) {
          return !(result = value === target);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning an array of all elements
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.filter(characters, 'blocked');
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   *
   * // using "_.where" callback shorthand
   * _.filter(characters, { 'age': 36 });
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      baseEach(collection, function (value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning the first element that
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias detect, findWhere
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36, 'blocked': false },
   *   { 'name': 'fred',    'age': 40, 'blocked': true },
   *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
   * ];
   *
   * _.find(characters, function(chr) {
   *   return chr.age < 40;
   * });
   * // => { 'name': 'barney', 'age': 36, 'blocked': false }
   *
   * // using "_.where" callback shorthand
   * _.find(characters, { 'age': 1 });
   * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
   *
   * // using "_.pluck" callback shorthand
   * _.find(characters, 'blocked');
   * // => { 'name': 'fred', 'age': 40, 'blocked': true }
   */
  function find(collection, callback, thisArg) {
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          return value;
        }
      }
    } else {
      var result;
      baseEach(collection, function (value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
  }

  /**
   * Iterates over elements of a collection, executing the callback for each
   * element. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * Note: As with other "Collections" methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
   * // => logs each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
   * // => logs each number and returns the object (property order is not guaranteed across environments)
   */
  function forEach(collection, callback, thisArg) {
    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (callback(collection[index], index, collection) === false) {
          break;
        }
      }
    } else {
      baseEach(collection, callback, thisArg);
    }
    return collection;
  }

  /**
   * Creates an array of values by running each element in the collection
   * through the callback. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (property order is not guaranteed across environments)
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(characters, 'name');
   * // => ['barney', 'fred']
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = lodash.createCallback(callback, thisArg, 3);
    if (isArray(collection)) {
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      baseEach(collection, function (value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * The opposite of `_.filter` this method returns the elements of a
   * collection that the callback does **not** return truey for.
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that failed the callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [1, 3, 5]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.reject(characters, 'blocked');
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   *
   * // using "_.where" callback shorthand
   * _.reject(characters, { 'age': 36 });
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   */
  function reject(collection, callback, thisArg) {
    callback = lodash.createCallback(callback, thisArg, 3);
    return filter(collection, function (value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Retrieves a random element or `n` random elements from a collection.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to sample.
   * @param {number} [n] The number of elements to sample.
   * @param- {Object} [guard] Allows working with functions like `_.map`
   *  without using their `index` arguments as `n`.
   * @returns {Array} Returns the random sample(s) of `collection`.
   * @example
   *
   * _.sample([1, 2, 3, 4]);
   * // => 2
   *
   * _.sample([1, 2, 3, 4], 2);
   * // => [3, 1]
   */
  function sample(collection, n, guard) {
    if (collection && typeof collection.length != 'number') {
      collection = values(collection);
    } else if (support.unindexedChars && isString(collection)) {
      collection = collection.split('');
    }
    if (n == null || guard) {
      return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
    }
    var result = shuffle(collection);
    result.length = nativeMin(nativeMax(0, n), result.length);
    return result;
  }

  /**
   * Creates an array of shuffled values, using a version of the Fisher-Yates
   * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // => [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    forEach(collection, function (value) {
      var rand = baseRandom(0, ++index);
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // => 2
   *
   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
   * // => 3
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == 'number' ? length : keys(collection).length;
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection through the callback. This method
   * performs a stable sort, that is, it will preserve the original sort order
   * of equal elements. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an array of property names is provided for `callback` the collection
   * will be sorted by each property value.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Array|Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // => [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // => [3, 1, 2]
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'barney',  'age': 26 },
   *   { 'name': 'fred',    'age': 30 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(_.sortBy(characters, 'age'), _.values);
   * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
   *
   * // sorting by multiple properties
   * _.map(_.sortBy(characters, ['name', 'age']), _.values);
   * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
   */
  function sortBy(collection, callback, thisArg) {
    var index = -1,
        isArr = isArray(callback),
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    if (!isArr) {
      callback = lodash.createCallback(callback, thisArg, 3);
    }
    forEach(collection, function (value, key, collection) {
      var object = result[++index] = getObject();
      if (isArr) {
        object.criteria = map(callback, function (key) {
          return value[key];
        });
      } else {
        (object.criteria = getArray())[0] = callback(value, key, collection);
      }
      object.index = index;
      object.value = value;
    });

    length = result.length;
    result.sort(compareAscending);
    while (length--) {
      var object = result[length];
      result[length] = object.value;
      if (!isArr) {
        releaseArray(object.criteria);
      }
      releaseObject(object);
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Flattens a nested array (the nesting can be to any depth). If `isShallow`
   * is truey, the array will only be flattened a single level. If a callback
   * is provided each element of the array is passed through the callback before
   * flattening. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
   *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.flatten(characters, 'pets');
   * // => ['hoppy', 'baby puss', 'dino']
   */
  function flatten(array, isShallow, callback, thisArg) {
    // juggle arguments
    if (typeof isShallow != 'boolean' && isShallow != null) {
      thisArg = callback;
      callback = typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array ? null : isShallow;
      isShallow = false;
    }
    if (callback != null) {
      array = map(array, callback, thisArg);
    }
    return baseFlatten(array, isShallow);
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the array is already sorted
   * providing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {boolean|number} [fromIndex=0] The index to search from or `true`
   *  to perform a binary search on a sorted array.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    if (typeof fromIndex == 'number') {
      var length = array ? array.length : 0;
      fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
    } else if (fromIndex) {
      var index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    return baseIndexOf(array, value, fromIndex);
  }

  /**
   * Gets the last element or last `n` elements of an array. If a callback is
   * provided elements at the end of the array are returned as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the last element(s) of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   *
   * _.last([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.last([1, 2, 3], function(num) {
   *   return num > 1;
   * });
   * // => [2, 3]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.pluck(_.last(characters, 'blocked'), 'name');
   * // => ['fred', 'pebbles']
   *
   * // using "_.where" callback shorthand
   * _.last(characters, { 'employer': 'na' });
   * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
   */
  function last(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != 'number' && callback != null) {
      var index = length;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (index-- && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[length - 1] : undefined;
      }
    }
    return slice(array, nativeMax(0, length - n));
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `end`. If `start` is less than `stop` a
   * zero-length range is created unless a negative `step` is specified.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @param {number} [step=1] The value to increment or decrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(4);
   * // => [0, 1, 2, 3]
   *
   * _.range(1, 5);
   * // => [1, 2, 3, 4]
   *
   * _.range(0, 20, 5);
   * // => [0, 5, 10, 15]
   *
   * _.range(0, -4, -1);
   * // => [0, -1, -2, -3]
   *
   * _.range(1, 4, 0);
   * // => [1, 1, 1]
   *
   * _.range(0);
   * // => []
   */
  function range(start, end, step) {
    start = +start || 0;
    step = typeof step == 'number' ? step : +step || 1;

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / (step || 1))),
        result = Array(length);

    while (++index < length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * Uses a binary search to determine the smallest index at which a value
   * should be inserted into a given sorted array in order to maintain the sort
   * order of the array. If a callback is provided it will be executed for
   * `value` and each element of `array` to compute their sort ranking. The
   * callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to inspect.
   * @param {*} value The value to evaluate.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // => 2
   *
   * // using "_.pluck" callback shorthand
   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
   * // => 2
   *
   * var dict = {
   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
   * };
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // => 2
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // => 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better inlining in Firefox
    callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
    value = callback(value);

    while (low < high) {
      var mid = low + high >>> 1;
      callback(array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  }

  /**
   * Creates a duplicate-value-free version of an array using strict equality
   * for comparisons, i.e. `===`. If the array is sorted, providing
   * `true` for `isSorted` will use a faster algorithm. If a callback is provided
   * each element of `array` is passed through the callback before uniqueness
   * is computed. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // => [1, 2, 3]
   *
   * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
   * // => ['A', 'b', 'C']
   *
   * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
   * // => [1, 2.5, 3]
   *
   * // using "_.pluck" callback shorthand
   * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniq(array, isSorted, callback, thisArg) {
    // juggle arguments
    if (typeof isSorted != 'boolean' && isSorted != null) {
      thisArg = callback;
      callback = typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array ? null : isSorted;
      isSorted = false;
    }
    if (callback != null) {
      callback = lodash.createCallback(callback, thisArg, 3);
    }
    return baseUniq(array, isSorted, callback);
  }

  /**
   * Creates an array excluding all provided values using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {...*} [value] The values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // => [2, 3, 4]
   */
  function without(array) {
    return baseDifference(array, slice(arguments, 1));
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'fred' }, 'hi');
   * func();
   * // => 'hi fred'
   */
  function bind(func, thisArg) {
    return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked.
   * Provide an options object to indicate that `func` should be invoked on
   * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
   * to the debounced function will return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the debounced function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {number} wait The number of milliseconds to delay.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
   * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // avoid costly calculations while the window size is in flux
   * var lazyLayout = _.debounce(calculateLayout, 150);
   * jQuery(window).on('resize', lazyLayout);
   *
   * // execute `sendMail` when the click event is fired, debouncing subsequent calls
   * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * });
   *
   * // ensure `batchLog` is executed once after 1 second of debounced calls
   * var source = new EventSource('/stream');
   * source.addEventListener('message', _.debounce(batchLog, 250, {
   *   'maxWait': 1000
   * }, false);
   */
  function debounce(func, wait, options) {
    var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = false,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError();
    }
    wait = nativeMax(0, wait) || 0;
    if (options === true) {
      var leading = true;
      trailing = false;
    } else if (isObject(options)) {
      leading = options.leading;
      maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    var delayed = function delayed() {
      var remaining = wait - (now() - stamp);
      if (remaining <= 0) {
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        var isCalled = trailingCall;
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      } else {
        timeoutId = setTimeout(delayed, remaining);
      }
    };

    var maxDelayed = function maxDelayed() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (trailing || maxWait !== wait) {
        lastCalled = now();
        result = func.apply(thisArg, args);
        if (!timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    };

    return function () {
      args = arguments;
      stamp = now();
      thisArg = this;
      trailingCall = trailing && (timeoutId || !leading);

      if (maxWait === false) {
        var leadingCall = leading && !timeoutId;
      } else {
        if (!maxTimeoutId && !leading) {
          lastCalled = stamp;
        }
        var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining <= 0;

        if (isCalled) {
          if (maxTimeoutId) {
            maxTimeoutId = clearTimeout(maxTimeoutId);
          }
          lastCalled = stamp;
          result = func.apply(thisArg, args);
        } else if (!maxTimeoutId) {
          maxTimeoutId = setTimeout(maxDelayed, remaining);
        }
      }
      if (isCalled && timeoutId) {
        timeoutId = clearTimeout(timeoutId);
      } else if (!timeoutId && wait !== maxWait) {
        timeoutId = setTimeout(delayed, wait);
      }
      if (leadingCall) {
        isCalled = true;
        result = func.apply(thisArg, args);
      }
      if (isCalled && !timeoutId && !maxTimeoutId) {
        args = thisArg = null;
      }
      return result;
    };
  }

  /**
   * Creates a function that, when executed, will only call the `func` function
   * at most once per every `wait` milliseconds. Provide an options object to
   * indicate that `func` should be invoked on the leading and/or trailing edge
   * of the `wait` timeout. Subsequent calls to the throttled function will
   * return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the throttled function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {number} wait The number of milliseconds to throttle executions to.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // avoid excessively updating the position while scrolling
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on('scroll', throttled);
   *
   * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
   * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
   *   'trailing': false
   * }));
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError();
    }
    if (options === false) {
      leading = false;
    } else if (isObject(options)) {
      leading = 'leading' in options ? options.leading : leading;
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    debounceOptions.leading = leading;
    debounceOptions.maxWait = wait;
    debounceOptions.trailing = trailing;

    return debounce(func, wait, debounceOptions);
  }

  /**
   * Creates a function that provides `value` to the wrapper function as its
   * first argument. Additional arguments provided to the function are appended
   * to those provided to the wrapper function. The wrapper is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {*} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var p = _.wrap(_.escape, function(func, text) {
   *   return '<p>' + func(text) + '</p>';
   * });
   *
   * p('Fred, Wilma, & Pebbles');
   * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
   */
  function wrap(value, wrapper) {
    return createWrapper(wrapper, 16, [value]);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Produces a callback bound to an optional `thisArg`. If `func` is a property
   * name the created callback will return the property value for a given element.
   * If `func` is an object the created callback will return `true` for elements
   * that contain the equivalent object properties, otherwise it will return `false`.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
   *   return !match ? func(callback, thisArg) : function(object) {
   *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
   *   };
   * });
   *
   * _.filter(characters, 'age__gt38');
   * // => [{ 'name': 'fred', 'age': 40 }]
   */
  function createCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (func == null || type == 'function') {
      return baseCreateCallback(func, thisArg, argCount);
    }
    // handle "_.pluck" style callback shorthands
    if (type != 'object') {
      return property(func);
    }
    var props = keys(func),
        key = props[0],
        a = func[key];

    // handle "_.where" style callback shorthands
    if (props.length == 1 && a === a && !isObject(a)) {
      // fast path the common case of providing an object with a single

      return function (object) {
        var b = object[key];
        return a === b && (a !== 0 || 1 / a == 1 / b);
      };
    }
    return function (object) {
      var length = props.length,
          result = false;

      while (length--) {
        if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
          break;
        }
      }
      return result;
    };
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds function properties of a source object to the destination object.
   * If `object` is a function methods will be added to its prototype as well.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Function|Object} [object=lodash] object The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
   * @example
   *
   * function capitalize(string) {
   *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   * }
   *
   * _.mixin({ 'capitalize': capitalize });
   * _.capitalize('fred');
   * // => 'Fred'
   *
   * _('fred').capitalize().value();
   * // => 'Fred'
   *
   * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
   * _('fred').capitalize();
   * // => 'Fred'
   */
  function mixin(object, source, options) {
    var chain = true,
        methodNames = source && functions(source);

    if (!source || !options && !methodNames.length) {
      if (options == null) {
        options = source;
      }
      ctor = lodashWrapper;
      source = object;
      object = lodash;
      methodNames = functions(source);
    }
    if (options === false) {
      chain = false;
    } else if (isObject(options) && 'chain' in options) {
      chain = options.chain;
    }
    var ctor = object,
        isFunc = isFunction(ctor);

    forEach(methodNames, function (methodName) {
      var func = object[methodName] = source[methodName];
      if (isFunc) {
        ctor.prototype[methodName] = function () {
          var chainAll = this.__chain__,
              value = this.__wrapped__,
              args = [value];

          push.apply(args, arguments);
          var result = func.apply(object, args);
          if (chain || chainAll) {
            if (value === result && isObject(result)) {
              return this;
            }
            result = new ctor(result);
            result.__chain__ = chainAll;
          }
          return result;
        };
      }
    });
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {}
  // no operation performed

  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var stamp = _.now();
   * _.defer(function() { console.log(_.now() - stamp); });
   * // => logs the number of milliseconds it took for the deferred function to be called
   */
  var now = isNative(now = Date.now) && now || function () {
    return new Date().getTime();
  };

  /**
   * Creates a "_.pluck" style function, which returns the `key` value of a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} key The name of the property to retrieve.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var characters = [
   *   { 'name': 'fred',   'age': 40 },
   *   { 'name': 'barney', 'age': 36 }
   * ];
   *
   * var getName = _.property('name');
   *
   * _.map(characters, getName);
   * // => ['barney', 'fred']
   *
   * _.sortBy(characters, getName);
   * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
   */
  function property(key) {
    return function (object) {
      return object[key];
    };
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object that wraps the given value with explicit
   * method chaining enabled.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _.chain(characters)
   *     .sortBy('age')
   *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
   *     .first()
   *     .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    value = new lodashWrapper(value);
    value.__chain__ = true;
    return value;
  }

  /**
   * Enables explicit method chaining on the wrapper object.
   *
   * @name chain
   * @memberOf _
   * @category Chaining
   * @returns {*} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // without explicit chaining
   * _(characters).first();
   * // => { 'name': 'barney', 'age': 36 }
   *
   * // with explicit chaining
   * _(characters).chain()
   *   .first()
   *   .pick('age')
   *   .value();
   * // => { 'age': 36 }
   */
  function wrapperChain() {
    this.__chain__ = true;
    return this;
  }

  /**
   * Produces the `toString` result of the wrapped value.
   *
   * @name toString
   * @memberOf _
   * @category Chaining
   * @returns {string} Returns the string result.
   * @example
   *
   * _([1, 2, 3]).toString();
   * // => '1,2,3'
   */
  function wrapperToString() {
    return String(this.__wrapped__);
  }

  /**
   * Extracts the wrapped value.
   *
   * @name valueOf
   * @memberOf _
   * @alias value
   * @category Chaining
   * @returns {*} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).valueOf();
   * // => [1, 2, 3]
   */
  function wrapperValueOf() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  lodash.assign = assign;
  lodash.bind = bind;
  lodash.chain = chain;
  lodash.create = create;
  lodash.createCallback = createCallback;
  lodash.debounce = debounce;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.forIn = forIn;
  lodash.forOwn = forOwn;
  lodash.functions = functions;
  lodash.keys = keys;
  lodash.map = map;
  lodash.property = property;
  lodash.range = range;
  lodash.reject = reject;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.throttle = throttle;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.without = without;
  lodash.wrap = wrap;

  // add aliases
  lodash.collect = map;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.select = filter;
  lodash.unique = uniq;

  // add functions to `lodash.prototype`
  mixin(lodash);

  /*--------------------------------------------------------------------------*/

  // add functions that return unwrapped values when chaining
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.contains = contains;
  lodash.find = find;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFunction = isFunction;
  lodash.isObject = isObject;
  lodash.isString = isString;
  lodash.mixin = mixin;
  lodash.noop = noop;
  lodash.now = now;
  lodash.size = size;
  lodash.sortedIndex = sortedIndex;

  lodash.detect = find;
  lodash.findWhere = find;
  lodash.include = contains;

  mixin((function () {
    var source = {};
    forOwn(lodash, function (func, methodName) {
      if (!lodash.prototype[methodName]) {
        source[methodName] = func;
      }
    });
    return source;
  })(), false);

  /*--------------------------------------------------------------------------*/

  lodash.last = last;
  lodash.sample = sample;

  forOwn(lodash, function (func, methodName) {
    var callbackable = methodName !== 'sample';
    if (!lodash.prototype[methodName]) {
      lodash.prototype[methodName] = function (n, guard) {
        var chainAll = this.__chain__,
            result = func(this.__wrapped__, n, guard);

        return !chainAll && (n == null || guard && !(callbackable && typeof n == 'function')) ? result : new lodashWrapper(result, chainAll);
      };
    }
  });

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = '2.4.1';

  // add "Chaining" functions to the wrapper
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.toString = wrapperToString;
  lodash.prototype.value = wrapperValueOf;
  lodash.prototype.valueOf = wrapperValueOf;

  // add `Array` functions that return unwrapped values
  baseEach(['join', 'pop', 'shift'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      var chainAll = this.__chain__,
          result = func.apply(this.__wrapped__, arguments);

      return chainAll ? new lodashWrapper(result, chainAll) : result;
    };
  });

  // add `Array` functions that return the existing wrapped value
  baseEach(['push', 'reverse', 'sort', 'unshift'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      func.apply(this.__wrapped__, arguments);
      return this;
    };
  });

  // add `Array` functions that return new wrapped values
  baseEach(['concat', 'slice', 'splice'], function (methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function () {
      return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
    };
  });

  // avoid array-like object bugs with `Array#shift` and `Array#splice`
  // in IE < 9, Firefox < 10, Narwhal, and RingoJS
  if (!support.spliceObjects) {
    baseEach(['pop', 'shift', 'splice'], function (methodName) {
      var func = arrayRef[methodName],
          isSplice = methodName == 'splice';

      lodash.prototype[methodName] = function () {
        var chainAll = this.__chain__,
            value = this.__wrapped__,
            result = func.apply(value, arguments);

        if (value.length === 0) {
          delete value[0];
        }
        return chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
      };
    });
  }

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function () {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
      // in Node.js or RingoJS
      if (moduleExports) {
        (freeModule.exports = lodash)._ = lodash;
      }
      // in Narwhal or Rhino -require
      else {
          freeExports._ = lodash;
        }
    } else {
      // in a browser or Rhino
      root._ = lodash;
    }
}).call(undefined);
// property containing a primitive value

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/ubuntu/staging/apps/build/js/hammer.js":[function(require,module,exports){
/*! Hammer.JS - v1.1.3 - 2014-05-22
 * http://eightmedia.github.io/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

'use strict';

(function (window, undefined) {
    'use strict';

    /**
     * @main
     * @module hammer
     *
     * @class Hammer
     * @static
     */

    /**
     * Hammer, use this to create instances
     * ````
     * var hammertime = new Hammer(myElement);
     * ````
     *
     * @method Hammer
     * @param {HTMLElement} element
     * @param {Object} [options={}]
     * @return {Hammer.Instance}
     */
    var Hammer = function Hammer(element, options) {
        return new Hammer.Instance(element, options || {});
    };

    /**
     * version, as defined in package.json
     * the value will be set at each build
     * @property VERSION
     * @final
     * @type {String}
     */
    Hammer.VERSION = '1.1.3';

    /**
     * default settings.
     * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
     * by setting it's name (like `swipe`) to false.
     * You can set the defaults for all instances by changing this object before creating an instance.
     * @example
     * ````
     *  Hammer.defaults.drag = false;
     *  Hammer.defaults.behavior.touchAction = 'pan-y';
     *  delete Hammer.defaults.behavior.userSelect;
     * ````
     * @property defaults
     * @type {Object}
     */
    Hammer.defaults = {
        /**
         * this setting object adds styles and attributes to the element to prevent the browser from doing
         * its native behavior. The css properties are auto prefixed for the browsers when needed.
         * @property defaults.behavior
         * @type {Object}
         */
        behavior: {
            /**
             * Disables text selection to improve the dragging gesture. When the value is `none` it also sets
             * `onselectstart=false` for IE on the element. Mainly for desktop browsers.
             * @property defaults.behavior.userSelect
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Specifies whether and how a given region can be manipulated by the user (for instance, by panning or zooming).
             * Used by Chrome 35> and IE10>. By default this makes the element blocking any touch event.
             * @property defaults.behavior.touchAction
             * @type {String}
             * @default: 'pan-y'
             */
            touchAction: 'pan-y',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @property defaults.behavior.touchCallout
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @property defaults.behavior.contentZooming
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents.
             * Mainly for desktop browsers.
             * @property defaults.behavior.userDrag
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in Safari on iPhone. This property obeys the alpha value, if specified.
             *
             * If you don't specify an alpha value, Safari on iPhone applies a default alpha value
             * to the color. To disable tap highlighting, set the alpha value to 0 (invisible).
             * If you set the alpha value to 1.0 (opaque), the element is not visible when tapped.
             * @property defaults.behavior.tapHighlightColor
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    /**
     * hammer document where the base events are added at
     * @property DOCUMENT
     * @type {HTMLElement}
     * @default window.document
     */
    Hammer.DOCUMENT = document;

    /**
     * detect support for pointer events
     * @property HAS_POINTEREVENTS
     * @type {Boolean}
     */
    Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

    /**
     * detect support for touch events
     * @property HAS_TOUCHEVENTS
     * @type {Boolean}
     */
    Hammer.HAS_TOUCHEVENTS = 'ontouchstart' in window;

    /**
     * detect mobile browsers
     * @property IS_MOBILE
     * @type {Boolean}
     */
    Hammer.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

    /**
     * detect if we want to support mouseevents at all
     * @property NO_MOUSEEVENTS
     * @type {Boolean}
     */
    Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && Hammer.IS_MOBILE || Hammer.HAS_POINTEREVENTS;

    /**
     * interval in which Hammer recalculates current velocity/direction/angle in ms
     * @property CALCULATE_INTERVAL
     * @type {Number}
     * @default 25
     */
    Hammer.CALCULATE_INTERVAL = 25;

    /**
     * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
     * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
     * @property EVENT_TYPES
     * @private
     * @writeOnce
     * @type {Object}
     */
    var EVENT_TYPES = {};

    /**
     * direction strings, for safe comparisons
     * @property DIRECTION_DOWN|LEFT|UP|RIGHT
     * @final
     * @type {String}
     * @default 'down' 'left' 'up' 'right'
     */
    var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
    var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
    var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
    var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

    /**
     * pointertype strings, for safe comparisons
     * @property POINTER_MOUSE|TOUCH|PEN
     * @final
     * @type {String}
     * @default 'mouse' 'touch' 'pen'
     */
    var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
    var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
    var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

    /**
     * eventtypes
     * @property EVENT_START|MOVE|END|RELEASE|TOUCH
     * @final
     * @type {String}
     * @default 'start' 'change' 'move' 'end' 'release' 'touch'
     */
    var EVENT_START = Hammer.EVENT_START = 'start';
    var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
    var EVENT_END = Hammer.EVENT_END = 'end';
    var EVENT_RELEASE = Hammer.EVENT_RELEASE = 'release';
    var EVENT_TOUCH = Hammer.EVENT_TOUCH = 'touch';

    /**
     * if the window events are set...
     * @property READY
     * @writeOnce
     * @type {Boolean}
     * @default false
     */
    Hammer.READY = false;

    /**
     * plugins namespace
     * @property plugins
     * @type {Object}
     */
    Hammer.plugins = Hammer.plugins || {};

    /**
     * gestures namespace
     * see `/gestures` for the definitions
     * @property gestures
     * @type {Object}
     */
    Hammer.gestures = Hammer.gestures || {};

    /**
     * setup events to detect gestures on the document
     * this function is called when creating an new instance
     * @private
     */
    function setup() {
        if (Hammer.READY) {
            return;
        }

        // find what eventtypes we add listeners to
        Event.determineEventTypes();

        // Register all gestures inside Hammer.gestures
        Utils.each(Hammer.gestures, function (gesture) {
            Detection.register(gesture);
        });

        // Add touch events on the document
        Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
        Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

        // Hammer is ready...!
        Hammer.READY = true;
    }

    /**
     * @module hammer
     *
     * @class Utils
     * @static
     */
    var Utils = Hammer.utils = {
        /**
         * extend method, could also be used for cloning when `dest` is an empty object.
         * changes the dest object
         * @method extend
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge=false]  do a merge
         * @return {Object} dest
         */
        extend: function extend(dest, src, merge) {
            for (var key in src) {
                if (!src.hasOwnProperty(key) || dest[key] !== undefined && merge) {
                    continue;
                }
                dest[key] = src[key];
            }
            return dest;
        },

        /**
         * simple addEventListener wrapper
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        on: function on(element, type, handler) {
            element.addEventListener(type, handler, false);
        },

        /**
         * simple removeEventListener wrapper
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        off: function off(element, type, handler) {
            element.removeEventListener(type, handler, false);
        },

        /**
         * forEach over arrays and objects
         * @method each
         * @param {Object|Array} obj
         * @param {Function} iterator
         * @param {any} iterator.item
         * @param {Number} iterator.index
         * @param {Object|Array} iterator.obj the source object
         * @param {Object} context value to use as `this` in the iterator
         */
        each: function each(obj, iterator, context) {
            var i, len;

            // native forEach on arrays
            if ('forEach' in obj) {
                obj.forEach(iterator, context);
                // arrays
            } else if (obj.length !== undefined) {
                    for (i = 0, len = obj.length; i < len; i++) {
                        if (iterator.call(context, obj[i], i, obj) === false) {
                            return;
                        }
                    }
                    // objects
                } else {
                        for (i in obj) {
                            if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                                return;
                            }
                        }
                    }
        },

        /**
         * find if a string contains the string using indexOf
         * @method inStr
         * @param {String} src
         * @param {String} find
         * @return {Boolean} found
         */
        inStr: function inStr(src, find) {
            return src.indexOf(find) > -1;
        },

        /**
         * find if a array contains the object using indexOf or a simple polyfill
         * @method inArray
         * @param {String} src
         * @param {String} find
         * @return {Boolean|Number} false when not found, or the index
         */
        inArray: function inArray(src, find) {
            if (src.indexOf) {
                var index = src.indexOf(find);
                return index === -1 ? false : index;
            } else {
                for (var i = 0, len = src.length; i < len; i++) {
                    if (src[i] === find) {
                        return i;
                    }
                }
                return false;
            }
        },

        /**
         * convert an array-like object (`arguments`, `touchlist`) to an array
         * @method toArray
         * @param {Object} obj
         * @return {Array}
         */
        toArray: function toArray(obj) {
            return Array.prototype.slice.call(obj, 0);
        },

        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
        hasParent: function hasParent(node, parent) {
            while (node) {
                if (node == parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        },

        /**
         * get the center of all the touches
         * @method getCenter
         * @param {Array} touches
         * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
         */
        getCenter: function getCenter(touches) {
            var pageX = [],
                pageY = [],
                clientX = [],
                clientY = [],
                min = Math.min,
                max = Math.max;

            // no need to loop when only one touch
            if (touches.length === 1) {
                return {
                    pageX: touches[0].pageX,
                    pageY: touches[0].pageY,
                    clientX: touches[0].clientX,
                    clientY: touches[0].clientY
                };
            }

            Utils.each(touches, function (touch) {
                pageX.push(touch.pageX);
                pageY.push(touch.pageY);
                clientX.push(touch.clientX);
                clientY.push(touch.clientY);
            });

            return {
                pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
                pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
                clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
                clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
            };
        },

        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @method getVelocity
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         * @return {Object} velocity `x` and `y`
         */
        getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
            return {
                x: Math.abs(deltaX / deltaTime) || 0,
                y: Math.abs(deltaY / deltaTime) || 0
            };
        },

        /**
         * calculate the angle between two coordinates
         * @method getAngle
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {Number} angle
         */
        getAngle: function getAngle(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.atan2(y, x) * 180 / Math.PI;
        },

        /**
         * do a small comparision to get the direction between two touches.
         * @method getDirection
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
         */
        getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.clientX - touch2.clientX),
                y = Math.abs(touch1.clientY - touch2.clientY);

            if (x >= y) {
                return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
        },

        /**
         * calculate the distance between two touches
         * @method getDistance
         * @param {Touch}touch1
         * @param {Touch} touch2
         * @return {Number} distance
         */
        getDistance: function getDistance(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.sqrt(x * x + y * y);
        },

        /**
         * calculate the scale factor between two touchLists
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @method getScale
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} scale
         */
        getScale: function getScale(start, end) {
            // need two fingers...
            if (start.length >= 2 && end.length >= 2) {
                return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
        },

        /**
         * calculate the rotation degrees between two touchLists
         * @method getRotation
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} rotation
         */
        getRotation: function getRotation(start, end) {
            // need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
        },

        /**
         * find out if the direction is vertical   *
         * @method isVertical
         * @param {String} direction matches `DIRECTION_UP|DOWN`
         * @return {Boolean} is_vertical
         */
        isVertical: function isVertical(direction) {
            return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
        },

        /**
         * set css properties with their prefixes
         * @param {HTMLElement} element
         * @param {String} prop
         * @param {String} value
         * @param {Boolean} [toggle=true]
         * @return {Boolean}
         */
        setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
            var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
            prop = Utils.toCamelCase(prop);

            for (var i = 0; i < prefixes.length; i++) {
                var p = prop;
                // prefixes
                if (prefixes[i]) {
                    p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
                }

                // test the style
                if (p in element.style) {
                    element.style[p] = (toggle == null || toggle) && value || '';
                    break;
                }
            }
        },

        /**
         * toggle browser default behavior by setting css properties.
         * `userSelect='none'` also sets `element.onselectstart` to false
         * `userDrag='none'` also sets `element.ondragstart` to false
         *
         * @method toggleBehavior
         * @param {HtmlElement} element
         * @param {Object} props
         * @param {Boolean} [toggle=true]
         */
        toggleBehavior: function toggleBehavior(element, props, toggle) {
            if (!props || !element || !element.style) {
                return;
            }

            // set the css properties
            Utils.each(props, function (value, prop) {
                Utils.setPrefixedCss(element, prop, value, toggle);
            });

            var falseFn = toggle && function () {
                return false;
            };

            // also the disable onselectstart
            if (props.userSelect == 'none') {
                element.onselectstart = falseFn;
            }
            // and disable ondragstart
            if (props.userDrag == 'none') {
                element.ondragstart = falseFn;
            }
        },

        /**
         * convert a string with underscores to camelCase
         * so prevent_default becomes preventDefault
         * @param {String} str
         * @return {String} camelCaseStr
         */
        toCamelCase: function toCamelCase(str) {
            return str.replace(/[_-]([a-z])/g, function (s) {
                return s[1].toUpperCase();
            });
        }
    };

    /**
     * @module hammer
     */
    /**
     * @class Event
     * @static
     */
    var Event = Hammer.event = {
        /**
         * when touch events have been fired, this is true
         * this is used to stop mouse events
         * @property prevent_mouseevents
         * @private
         * @type {Boolean}
         */
        preventMouseEvents: false,

        /**
         * if EVENT_START has been fired
         * @property started
         * @private
         * @type {Boolean}
         */
        started: false,

        /**
         * when the mouse is hold down, this is true
         * @property should_detect
         * @private
         * @type {Boolean}
         */
        shouldDetect: false,

        /**
         * simple event binder with a hook and support for multiple types
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        on: function on(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function (type) {
                Utils.on(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * simple event unbinder with a hook and support for multiple types
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        off: function off(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function (type) {
                Utils.off(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * the core touch event handler.
         * this finds out if we should to detect gestures
         * @method onTouch
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Function} handler
         * @return onTouchHandler {Function} the core event handler
         */
        onTouch: function onTouch(element, eventType, handler) {
            var self = this;

            var onTouchHandler = function onTouchHandler(ev) {
                var srcType = ev.type.toLowerCase(),
                    isPointer = Hammer.HAS_POINTEREVENTS,
                    isMouse = Utils.inStr(srcType, 'mouse'),
                    triggerType;

                // if we are in a mouseevent, but there has been a touchevent triggered in this session
                // we want to do nothing. simply break out of the event.
                if (isMouse && self.preventMouseEvents) {
                    return;

                    // mousebutton must be down
                } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
                        self.preventMouseEvents = false;
                        self.shouldDetect = true;
                    } else if (isPointer && eventType == EVENT_START) {
                        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
                        // just a valid start event, but no mouse
                    } else if (!isMouse && eventType == EVENT_START) {
                            self.preventMouseEvents = true;
                            self.shouldDetect = true;
                        }

                // update the pointer event before entering the detection
                if (isPointer && eventType != EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }

                // we are in a touch/down state, so allowed detection of gestures
                if (self.shouldDetect) {
                    triggerType = self.doDetect.call(self, ev, eventType, element, handler);
                }

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                if (triggerType == EVENT_END) {
                    self.preventMouseEvents = false;
                    self.shouldDetect = false;
                    PointerEvent.reset();
                    // update the pointerevent object after the detection
                }

                if (isPointer && eventType == EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }
            };

            this.on(element, EVENT_TYPES[eventType], onTouchHandler);
            return onTouchHandler;
        },

        /**
         * the core detection method
         * this finds out what hammer-touch-events to trigger
         * @method doDetect
         * @param {Object} ev
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {HTMLElement} element
         * @param {Function} handler
         * @return {String} triggerType matches `EVENT_START|MOVE|END`
         */
        doDetect: function doDetect(ev, eventType, element, handler) {
            var touchList = this.getTouchList(ev, eventType);
            var touchListLength = touchList.length;
            var triggerType = eventType;
            var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
            var changedLength = touchListLength;

            // at each touchstart-like event we want also want to trigger a TOUCH event...
            if (eventType == EVENT_START) {
                triggerChange = EVENT_TOUCH;
                // ...the same for a touchend-like event
            } else if (eventType == EVENT_END) {
                    triggerChange = EVENT_RELEASE;

                    // keep track of how many touches have been removed
                    changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
                }

            // after there are still touches on the screen,
            // we just want to trigger a MOVE event. so change the START or END to a MOVE
            // but only after detection has been started, the first time we actualy want a START
            if (changedLength > 0 && this.started) {
                triggerType = EVENT_MOVE;
            }

            // detection has been started, we keep track of this, see above
            this.started = true;

            // generate some event data, some basic information
            var evData = this.collectEventData(element, triggerType, touchList, ev);

            // trigger the triggerType event before the change (TOUCH, RELEASE) events
            // but the END event should be at last
            if (eventType != EVENT_END) {
                handler.call(Detection, evData);
            }

            // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
            if (triggerChange) {
                evData.changedLength = changedLength;
                evData.eventType = triggerChange;

                handler.call(Detection, evData);

                evData.eventType = triggerType;
                delete evData.changedLength;
            }

            // trigger the END event
            if (triggerType == EVENT_END) {
                handler.call(Detection, evData);

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                this.started = false;
            }

            return triggerType;
        },

        /**
         * we have different events for each device/browser
         * determine what we need and set them in the EVENT_TYPES constant
         * the `onTouch` method is bind to these properties.
         * @method determineEventTypes
         * @return {Object} events
         */
        determineEventTypes: function determineEventTypes() {
            var types;
            if (Hammer.HAS_POINTEREVENTS) {
                if (window.PointerEvent) {
                    types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
                } else {
                    types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
                }
            } else if (Hammer.NO_MOUSEEVENTS) {
                types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
                types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }

            EVENT_TYPES[EVENT_START] = types[0];
            EVENT_TYPES[EVENT_MOVE] = types[1];
            EVENT_TYPES[EVENT_END] = types[2];
            return EVENT_TYPES;
        },

        /**
         * create touchList depending on the event
         * @method getTouchList
         * @param {Object} ev
         * @param {String} eventType
         * @return {Array} touches
         */
        getTouchList: function getTouchList(ev, eventType) {
            // get the fake pointerEvent touchlist
            if (Hammer.HAS_POINTEREVENTS) {
                return PointerEvent.getTouchList();
            }

            // get the touchlist
            if (ev.touches) {
                if (eventType == EVENT_MOVE) {
                    return ev.touches;
                }

                var identifiers = [];
                var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
                var touchList = [];

                Utils.each(concat, function (touch) {
                    if (Utils.inArray(identifiers, touch.identifier) === false) {
                        touchList.push(touch);
                    }
                    identifiers.push(touch.identifier);
                });

                return touchList;
            }

            // make fake touchList from mouse position
            ev.identifier = 1;
            return [ev];
        },

        /**
         * collect basic event data
         * @method collectEventData
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Array} touches
         * @param {Object} ev
         * @return {Object} ev
         */
        collectEventData: function collectEventData(element, eventType, touches, ev) {
            // find out pointerType
            var pointerType = POINTER_TOUCH;
            if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
                pointerType = POINTER_MOUSE;
            } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
                pointerType = POINTER_PEN;
            }

            return {
                center: Utils.getCenter(touches),
                timeStamp: Date.now(),
                target: ev.target,
                touches: touches,
                eventType: eventType,
                pointerType: pointerType,
                srcEvent: ev,

                /**
                 * prevent the browser default actions
                 * mostly used to disable scrolling of the browser
                 */
                preventDefault: function preventDefault() {
                    var srcEvent = this.srcEvent;
                    srcEvent.preventManipulation && srcEvent.preventManipulation();
                    srcEvent.preventDefault && srcEvent.preventDefault();
                },

                /**
                 * stop bubbling the event up to its parents
                 */
                stopPropagation: function stopPropagation() {
                    this.srcEvent.stopPropagation();
                },

                /**
                 * immediately stop gesture detection
                 * might be useful after a swipe was detected
                 * @return {*}
                 */
                stopDetect: function stopDetect() {
                    return Detection.stopDetect();
                }
            };
        }
    };

    /**
     * @module hammer
     *
     * @class PointerEvent
     * @static
     */
    var PointerEvent = Hammer.PointerEvent = {
        /**
         * holds all pointers, by `identifier`
         * @property pointers
         * @type {Object}
         */
        pointers: {},

        /**
         * get the pointers as an array
         * @method getTouchList
         * @return {Array} touchlist
         */
        getTouchList: function getTouchList() {
            var touchlist = [];
            // we can use forEach since pointerEvents only is in IE10
            Utils.each(this.pointers, function (pointer) {
                touchlist.push(pointer);
            });

            return touchlist;
        },

        /**
         * update the position of a pointer
         * @method updatePointer
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Object} pointerEvent
         */
        updatePointer: function updatePointer(eventType, pointerEvent) {
            if (eventType == EVENT_END) {
                delete this.pointers[pointerEvent.pointerId];
            } else {
                pointerEvent.identifier = pointerEvent.pointerId;
                this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
        },

        /**
         * check if ev matches pointertype
         * @method matchType
         * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
         * @param {PointerEvent} ev
         */
        matchType: function matchType(pointerType, ev) {
            if (!ev.pointerType) {
                return false;
            }

            var pt = ev.pointerType,
                types = {};

            types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
            types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
            types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
            return types[pointerType];
        },

        /**
         * reset the stored pointers
         * @method reset
         */
        reset: function resetList() {
            this.pointers = {};
        }
    };

    /**
     * @module hammer
     *
     * @class Detection
     * @static
     */
    var Detection = Hammer.detection = {
        // contains all registred Hammer.gestures in the correct order
        gestures: [],

        // data of the current Hammer.gesture detection session
        current: null,

        // the previous Hammer.gesture session data
        // is a full clone of the previous gesture.current object
        previous: null,

        // when this becomes true, no gestures are fired
        stopped: false,

        /**
         * start Hammer.gesture detection
         * @method startDetect
         * @param {Hammer.Instance} inst
         * @param {Object} eventData
         */
        startDetect: function startDetect(inst, eventData) {
            // already busy with a Hammer.gesture detection on an element
            if (this.current) {
                return;
            }

            this.stopped = false;

            // holds current session
            this.current = {
                inst: inst, // reference to HammerInstance we're working for
                startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
                lastEvent: false, // last eventData
                lastCalcEvent: false, // last eventData for calculations.
                futureCalcEvent: false, // last eventData for calculations.
                lastCalcData: {}, // last lastCalcData
                name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
            };

            this.detect(eventData);
        },

        /**
         * Hammer.gesture detection
         * @method detect
         * @param {Object} eventData
         * @return {any}
         */
        detect: function detect(eventData) {
            if (!this.current || this.stopped) {
                return;
            }

            // extend event data with calculations about scale, distance etc
            eventData = this.extendEventData(eventData);

            // hammer instance and instance options
            var inst = this.current.inst,
                instOptions = inst.options;

            // call Hammer.gesture handlers
            Utils.each(this.gestures, function triggerGesture(gesture) {
                // only when the instance options have enabled this gesture
                if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
                    gesture.handler.call(gesture, eventData, inst);
                }
            }, this);

            // store as previous event event
            if (this.current) {
                this.current.lastEvent = eventData;
            }

            if (eventData.eventType == EVENT_END) {
                this.stopDetect();
            }

            return eventData;
        },

        /**
         * clear the Hammer.gesture vars
         * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
         * to stop other Hammer.gestures from being fired
         * @method stopDetect
         */
        stopDetect: function stopDetect() {
            // clone current data to the store as the previous gesture
            // used for the double tap gesture, since this is an other gesture detect session
            this.previous = Utils.extend({}, this.current);

            // reset the current
            this.current = null;
            this.stopped = true;
        },

        /**
         * calculate velocity, angle and direction
         * @method getVelocityData
         * @param {Object} ev
         * @param {Object} center
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         */
        getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
            var cur = this.current,
                recalc = false,
                calcEv = cur.lastCalcEvent,
                calcData = cur.lastCalcData;

            if (calcEv && ev.timeStamp - calcEv.timeStamp > Hammer.CALCULATE_INTERVAL) {
                center = calcEv.center;
                deltaTime = ev.timeStamp - calcEv.timeStamp;
                deltaX = ev.center.clientX - calcEv.center.clientX;
                deltaY = ev.center.clientY - calcEv.center.clientY;
                recalc = true;
            }

            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                cur.futureCalcEvent = ev;
            }

            if (!cur.lastCalcEvent || recalc) {
                calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
                calcData.angle = Utils.getAngle(center, ev.center);
                calcData.direction = Utils.getDirection(center, ev.center);

                cur.lastCalcEvent = cur.futureCalcEvent || ev;
                cur.futureCalcEvent = ev;
            }

            ev.velocityX = calcData.velocity.x;
            ev.velocityY = calcData.velocity.y;
            ev.interimAngle = calcData.angle;
            ev.interimDirection = calcData.direction;
        },

        /**
         * extend eventData for Hammer.gestures
         * @method extendEventData
         * @param {Object} ev
         * @return {Object} ev
         */
        extendEventData: function extendEventData(ev) {
            var cur = this.current,
                startEv = cur.startEvent,
                lastEv = cur.lastEvent || startEv;

            // update the start touchlist to calculate the scale/rotation
            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                startEv.touches = [];
                Utils.each(ev.touches, function (touch) {
                    startEv.touches.push({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                });
            }

            var deltaTime = ev.timeStamp - startEv.timeStamp,
                deltaX = ev.center.clientX - startEv.center.clientX,
                deltaY = ev.center.clientY - startEv.center.clientY;

            this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

            Utils.extend(ev, {
                startEvent: startEv,

                deltaTime: deltaTime,
                deltaX: deltaX,
                deltaY: deltaY,

                distance: Utils.getDistance(startEv.center, ev.center),
                angle: Utils.getAngle(startEv.center, ev.center),
                direction: Utils.getDirection(startEv.center, ev.center),
                scale: Utils.getScale(startEv.touches, ev.touches),
                rotation: Utils.getRotation(startEv.touches, ev.touches)
            });

            return ev;
        },

        /**
         * register new gesture
         * @method register
         * @param {Object} gesture object, see `gestures/` for documentation
         * @return {Array} gestures
         */
        register: function register(gesture) {
            // add an enable gesture options if there is no given
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
                options[gesture.name] = true;
            }

            // extend Hammer default options with the Hammer.gesture options
            Utils.extend(Hammer.defaults, options, true);

            // set its index
            gesture.index = gesture.index || 1000;

            // add Hammer.gesture to the list
            this.gestures.push(gesture);

            // sort the list by index
            this.gestures.sort(function (a, b) {
                if (a.index < b.index) {
                    return -1;
                }
                if (a.index > b.index) {
                    return 1;
                }
                return 0;
            });

            return this.gestures;
        }
    };

    /**
     * @module hammer
     */

    /**
     * create new hammer instance
     * all methods should return the instance itself, so it is chainable.
     *
     * @class Instance
     * @constructor
     * @param {HTMLElement} element
     * @param {Object} [options={}] options are merged with `Hammer.defaults`
     * @return {Hammer.Instance}
     */
    Hammer.Instance = function (element, options) {
        var self = this;

        // setup HammerJS window events and register all gestures
        // this also sets up the default options
        setup();

        /**
         * @property element
         * @type {HTMLElement}
         */
        this.element = element;

        /**
         * @property enabled
         * @type {Boolean}
         * @protected
         */
        this.enabled = true;

        /**
         * options, merged with the defaults
         * options with an _ are converted to camelCase
         * @property options
         * @type {Object}
         */
        Utils.each(options, function (value, name) {
            delete options[name];
            options[Utils.toCamelCase(name)] = value;
        });

        this.options = Utils.extend(Utils.extend({}, Hammer.defaults), options || {});

        // add some css to the element to prevent the browser from doing its native behavoir
        if (this.options.behavior) {
            Utils.toggleBehavior(this.element, this.options.behavior, true);
        }

        /**
         * event start handler on the element to start the detection
         * @property eventStartHandler
         * @type {Object}
         */
        this.eventStartHandler = Event.onTouch(element, EVENT_START, function (ev) {
            if (self.enabled && ev.eventType == EVENT_START) {
                Detection.startDetect(self, ev);
            } else if (ev.eventType == EVENT_TOUCH) {
                Detection.detect(ev);
            }
        });

        /**
         * keep a list of user event handlers which needs to be removed when calling 'dispose'
         * @property eventHandlers
         * @type {Array}
         */
        this.eventHandlers = [];
    };

    Hammer.Instance.prototype = {
        /**
         * bind events to the instance
         * @method on
         * @chainable
         * @param {String} gestures multiple gestures by splitting with a space
         * @param {Function} handler
         * @param {Object} handler.ev event object
         */
        on: function onEvent(gestures, handler) {
            var self = this;
            Event.on(self.element, gestures, handler, function (type) {
                self.eventHandlers.push({ gesture: type, handler: handler });
            });
            return self;
        },

        /**
         * unbind events to the instance
         * @method off
         * @chainable
         * @param {String} gestures
         * @param {Function} handler
         */
        off: function offEvent(gestures, handler) {
            var self = this;

            Event.off(self.element, gestures, handler, function (type) {
                var index = Utils.inArray({ gesture: type, handler: handler });
                if (index !== false) {
                    self.eventHandlers.splice(index, 1);
                }
            });
            return self;
        },

        /**
         * trigger gesture event
         * @method trigger
         * @chainable
         * @param {String} gesture
         * @param {Object} [eventData]
         */
        trigger: function triggerEvent(gesture, eventData) {
            // optional
            if (!eventData) {
                eventData = {};
            }

            // create DOM event
            var event = Hammer.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;

            // trigger on the target if it is in the instance element,
            // this is for event delegation tricks
            var element = this.element;
            if (Utils.hasParent(eventData.target, element)) {
                element = eventData.target;
            }

            element.dispatchEvent(event);
            return this;
        },

        /**
         * enable of disable hammer.js detection
         * @method enable
         * @chainable
         * @param {Boolean} state
         */
        enable: function enable(state) {
            this.enabled = state;
            return this;
        },

        /**
         * dispose this hammer instance
         * @method dispose
         * @return {Null}
         */
        dispose: function dispose() {
            var i, eh;

            // undo all changes made by stop_browser_behavior
            Utils.toggleBehavior(this.element, this.options.behavior, false);

            // unbind all custom event handlers
            for (i = -1; eh = this.eventHandlers[++i];) {
                Utils.off(this.element, eh.gesture, eh.handler);
            }

            this.eventHandlers = [];

            // unbind the start event listener
            Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

            return null;
        }
    };

    /**
     * @module gestures
     */
    /**
     * Move with x fingers (default 1) around on the page.
     * Preventing the default browser behavior is a good way to improve feel and working.
     * ````
     *  hammertime.on("drag", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Drag
     * @static
     */
    /**
     * @event drag
     * @param {Object} ev
     */
    /**
     * @event dragstart
     * @param {Object} ev
     */
    /**
     * @event dragend
     * @param {Object} ev
     */
    /**
     * @event drapleft
     * @param {Object} ev
     */
    /**
     * @event dragright
     * @param {Object} ev
     */
    /**
     * @event dragup
     * @param {Object} ev
     */
    /**
     * @event dragdown
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var triggered = false;

        function dragGesture(ev, inst) {
            var cur = Detection.current;

            // max touches
            if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
                return;
            }

            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
                        return;
                    }

                    var startCenter = cur.startEvent.center;

                    // we are dragging!
                    if (cur.name != name) {
                        cur.name = name;
                        if (inst.options.dragDistanceCorrection && ev.distance > 0) {
                            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
                            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
                            // It might be useful to save the original start point somewhere
                            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
                            startCenter.pageX += ev.deltaX * factor;
                            startCenter.pageY += ev.deltaY * factor;
                            startCenter.clientX += ev.deltaX * factor;
                            startCenter.clientY += ev.deltaY * factor;

                            // recalculate event data using new start point
                            ev = Detection.extendEventData(ev);
                        }
                    }

                    // lock drag to axis?
                    if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
                        ev.dragLockToAxis = true;
                    }

                    // keep direction on the axis that the drag gesture started on
                    var lastDirection = cur.lastEvent.direction;
                    if (ev.dragLockToAxis && lastDirection !== ev.direction) {
                        if (Utils.isVertical(lastDirection)) {
                            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                        } else {
                            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                        }
                    }

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    // trigger events
                    inst.trigger(name, ev);
                    inst.trigger(name + ev.direction, ev);

                    var isVertical = Utils.isVertical(ev.direction);

                    // block the browser events
                    if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
                        ev.preventDefault();
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;

                case EVENT_END:
                    triggered = false;
                    break;
            }
        }

        Hammer.gestures.Drag = {
            name: name,
            index: 50,
            handler: dragGesture,
            defaults: {
                /**
                 * minimal movement that have to be made before the drag event gets triggered
                 * @property dragMinDistance
                 * @type {Number}
                 * @default 10
                 */
                dragMinDistance: 10,

                /**
                 * Set dragDistanceCorrection to true to make the starting point of the drag
                 * be calculated from where the drag was triggered, not from where the touch started.
                 * Useful to avoid a jerk-starting drag, which can make fine-adjustments
                 * through dragging difficult, and be visually unappealing.
                 * @property dragDistanceCorrection
                 * @type {Boolean}
                 * @default true
                 */
                dragDistanceCorrection: true,

                /**
                 * set 0 for unlimited, but this can conflict with transform
                 * @property dragMaxTouches
                 * @type {Number}
                 * @default 1
                 */
                dragMaxTouches: 1,

                /**
                 * prevent default browser behavior when dragging occurs
                 * be careful with it, it makes the element a blocking element
                 * when you are using the drag gesture, it is a good practice to set this true
                 * @property dragBlockHorizontal
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockHorizontal: false,

                /**
                 * same as `dragBlockHorizontal`, but for vertical movement
                 * @property dragBlockVertical
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockVertical: false,

                /**
                 * dragLockToAxis keeps the drag gesture on the axis that it started on,
                 * It disallows vertical directions if the initial direction was horizontal, and vice versa.
                 * @property dragLockToAxis
                 * @type {Boolean}
                 * @default false
                 */
                dragLockToAxis: false,

                /**
                 * drag lock only kicks in when distance > dragLockMinDistance
                 * This way, locking occurs only when the distance has become large enough to reliably determine the direction
                 * @property dragLockMinDistance
                 * @type {Number}
                 * @default 25
                 */
                dragLockMinDistance: 25
            }
        };
    })('drag');

    /**
     * @module gestures
     */
    /**
     * trigger a simple gesture event, so you can do anything in your handler.
     * only usable if you know what your doing...
     *
     * @class Gesture
     * @static
     */
    /**
     * @event gesture
     * @param {Object} ev
     */
    Hammer.gestures.Gesture = {
        name: 'gesture',
        index: 1337,
        handler: function releaseGesture(ev, inst) {
            inst.trigger(this.name, ev);
        }
    };

    /**
     * @module gestures
     */
    /**
     * Touch stays at the same place for x time
     *
     * @class Hold
     * @static
     */
    /**
     * @event hold
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var timer;

        function holdGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current;

            switch (ev.eventType) {
                case EVENT_START:
                    clearTimeout(timer);

                    // set the gesture so we can check in the timeout if it still is
                    current.name = name;

                    // set timer and if after the timeout it still is hold,
                    // we trigger the hold event
                    timer = setTimeout(function () {
                        if (current && current.name == name) {
                            inst.trigger(name, ev);
                        }
                    }, options.holdTimeout);
                    break;

                case EVENT_MOVE:
                    if (ev.distance > options.holdThreshold) {
                        clearTimeout(timer);
                    }
                    break;

                case EVENT_RELEASE:
                    clearTimeout(timer);
                    break;
            }
        }

        Hammer.gestures.Hold = {
            name: name,
            index: 10,
            defaults: {
                /**
                 * @property holdTimeout
                 * @type {Number}
                 * @default 500
                 */
                holdTimeout: 500,

                /**
                 * movement allowed while holding
                 * @property holdThreshold
                 * @type {Number}
                 * @default 2
                 */
                holdThreshold: 2
            },
            handler: holdGesture
        };
    })('hold');

    /**
     * @module gestures
     */
    /**
     * when a touch is being released from the page
     *
     * @class Release
     * @static
     */
    /**
     * @event release
     * @param {Object} ev
     */
    Hammer.gestures.Release = {
        name: 'release',
        index: Infinity,
        handler: function releaseGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                inst.trigger(this.name, ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * triggers swipe events when the end velocity is above the threshold
     * for best usage, set `preventDefault` (on the drag gesture) to `true`
     * ````
     *  hammertime.on("dragleft swipeleft", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Swipe
     * @static
     */
    /**
     * @event swipe
     * @param {Object} ev
     */
    /**
     * @event swipeleft
     * @param {Object} ev
     */
    /**
     * @event swiperight
     * @param {Object} ev
     */
    /**
     * @event swipeup
     * @param {Object} ev
     */
    /**
     * @event swipedown
     * @param {Object} ev
     */
    Hammer.gestures.Swipe = {
        name: 'swipe',
        index: 40,
        defaults: {
            /**
             * @property swipeMinTouches
             * @type {Number}
             * @default 1
             */
            swipeMinTouches: 1,

            /**
             * @property swipeMaxTouches
             * @type {Number}
             * @default 1
             */
            swipeMaxTouches: 1,

            /**
             * horizontal swipe velocity
             * @property swipeVelocityX
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityX: 0.6,

            /**
             * vertical swipe velocity
             * @property swipeVelocityY
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityY: 0.6
        },

        handler: function swipeGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                var touches = ev.touches.length,
                    options = inst.options;

                // max touches
                if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
                    return;
                }

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
                    // trigger swipe events
                    inst.trigger(this.name, ev);
                    inst.trigger(this.name + ev.direction, ev);
                }
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * Single tap and a double tap on a place
     *
     * @class Tap
     * @static
     */
    /**
     * @event tap
     * @param {Object} ev
     */
    /**
     * @event doubletap
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var hasMoved = false;

        function tapGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current,
                prev = Detection.previous,
                sincePrev,
                didDoubleTap;

            switch (ev.eventType) {
                case EVENT_START:
                    hasMoved = false;
                    break;

                case EVENT_MOVE:
                    hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
                    break;

                case EVENT_END:
                    if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
                        // previous gesture, for the double tap since these are two different gesture detections
                        sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
                        didDoubleTap = false;

                        // check if double tap
                        if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
                            inst.trigger('doubletap', ev);
                            didDoubleTap = true;
                        }

                        // do a single tap
                        if (!didDoubleTap || options.tapAlways) {
                            current.name = name;
                            inst.trigger(current.name, ev);
                        }
                    }
                    break;
            }
        }

        Hammer.gestures.Tap = {
            name: name,
            index: 100,
            handler: tapGesture,
            defaults: {
                /**
                 * max time of a tap, this is for the slow tappers
                 * @property tapMaxTime
                 * @type {Number}
                 * @default 250
                 */
                tapMaxTime: 250,

                /**
                 * max distance of movement of a tap, this is for the slow tappers
                 * @property tapMaxDistance
                 * @type {Number}
                 * @default 10
                 */
                tapMaxDistance: 10,

                /**
                 * always trigger the `tap` event, even while double-tapping
                 * @property tapAlways
                 * @type {Boolean}
                 * @default true
                 */
                tapAlways: true,

                /**
                 * max distance between two taps
                 * @property doubleTapDistance
                 * @type {Number}
                 * @default 20
                 */
                doubleTapDistance: 20,

                /**
                 * max time between two taps
                 * @property doubleTapInterval
                 * @type {Number}
                 * @default 300
                 */
                doubleTapInterval: 300
            }
        };
    })('tap');

    /**
     * @module gestures
     */
    /**
     * when a touch is being touched at the page
     *
     * @class Touch
     * @static
     */
    /**
     * @event touch
     * @param {Object} ev
     */
    Hammer.gestures.Touch = {
        name: 'touch',
        index: -Infinity,
        defaults: {
            /**
             * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
             * but it improves gestures like transforming and dragging.
             * be careful with using this, it can be very annoying for users to be stuck on the page
             * @property preventDefault
             * @type {Boolean}
             * @default false
             */
            preventDefault: false,

            /**
             * disable mouse events, so only touch (or pen!) input triggers events
             * @property preventMouse
             * @type {Boolean}
             * @default false
             */
            preventMouse: false
        },
        handler: function touchGesture(ev, inst) {
            if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
                ev.stopDetect();
                return;
            }

            if (inst.options.preventDefault) {
                ev.preventDefault();
            }

            if (ev.eventType == EVENT_TOUCH) {
                inst.trigger('touch', ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * User want to scale or rotate with 2 fingers
     * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
     * `preventDefault` option.
     *
     * @class Transform
     * @static
     */
    /**
     * @event transform
     * @param {Object} ev
     */
    /**
     * @event transformstart
     * @param {Object} ev
     */
    /**
     * @event transformend
     * @param {Object} ev
     */
    /**
     * @event pinchin
     * @param {Object} ev
     */
    /**
     * @event pinchout
     * @param {Object} ev
     */
    /**
     * @event rotate
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function (name) {
        var triggered = false;

        function transformGesture(ev, inst) {
            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // at least multitouch
                    if (ev.touches.length < 2) {
                        return;
                    }

                    var scaleThreshold = Math.abs(1 - ev.scale);
                    var rotationThreshold = Math.abs(ev.rotation);

                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
                        return;
                    }

                    // we are transforming!
                    Detection.current.name = name;

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    inst.trigger(name, ev); // basic transform event

                    // trigger rotate event
                    if (rotationThreshold > inst.options.transformMinRotation) {
                        inst.trigger('rotate', ev);
                    }

                    // trigger pinch event
                    if (scaleThreshold > inst.options.transformMinScale) {
                        inst.trigger('pinch', ev);
                        inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength < 2) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;
            }
        }

        Hammer.gestures.Transform = {
            name: name,
            index: 45,
            defaults: {
                /**
                 * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
                 * @property transformMinScale
                 * @type {Number}
                 * @default 0.01
                 */
                transformMinScale: 0.01,

                /**
                 * rotation in degrees
                 * @property transformMinRotation
                 * @type {Number}
                 * @default 1
                 */
                transformMinRotation: 1
            },

            handler: transformGesture
        };
    })('transform');

    /**
     * @module hammer
     */

    // AMD export
    if (typeof define == 'function' && define.amd) {
        define(function () {
            return Hammer;
        });
        // commonjs export
    } else if (typeof module !== 'undefined' && module.exports) {
            module.exports = Hammer;
            // browser export
        } else {
                window.Hammer = Hammer;
            }
})(window);

},{}],"/home/ubuntu/staging/apps/build/js/locale.js":[function(require,module,exports){
// base locale

"use strict";

module.exports = window.blockly.common_locale;

},{}],"/home/ubuntu/staging/apps/build/js/dom.js":[function(require,module,exports){
'use strict';

exports.addReadyListener = function (callback) {
  if (document.readyState === "complete") {
    setTimeout(callback, 1);
  } else {
    window.addEventListener('load', callback, false);
  }
};

exports.getTouchEventName = function (eventName) {
  var isIE11Touch = window.navigator.pointerEnabled;
  var isIE10Touch = window.navigator.msPointerEnabled;
  var isStandardTouch = ('ontouchend' in document.documentElement);

  var key;
  if (isIE11Touch) {
    key = "ie11";
  } else if (isIE10Touch) {
    key = "ie10";
  } else if (isStandardTouch) {
    key = "standard";
  }
  if (key && TOUCH_MAP[eventName]) {
    return TOUCH_MAP[eventName][key];
  }
};

var addEvent = function addEvent(element, eventName, handler) {
  // Scope bound event map to this addEvent call - we only provide for unbinding
  // what we bind right here.
  var boundEvents = {};

  var bindEvent = function bindEvent(type, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    boundEvents[type] = { name: eventName, handler: handler };
  };

  var unbindEvent = function unbindEvent(type) {
    var eventInfo = boundEvents[type];
    if (eventInfo) {
      element.removeEventListener(eventInfo.name, eventInfo.handler);
      delete boundEvents[type];
    }
  };

  // Add click handler
  bindEvent('click', eventName, handler);

  // Optionally add touch handler
  var touchEvent = exports.getTouchEventName(eventName);
  if (touchEvent) {
    bindEvent('touch', touchEvent, function (e) {
      // Stop mouse events and suppress default event handler to prevent
      // unintentional double-clicking
      e.preventDefault();
      unbindEvent('click');
      handler.call(this, e);
    });
  }

  // Return function that unbinds all handlers
  return function () {
    unbindEvent('click');
    unbindEvent('touch');
  };
};

exports.addMouseDownTouchEvent = function (element, handler) {
  return addEvent(element, 'mousedown', handler);
};

exports.addMouseUpTouchEvent = function (element, handler) {
  return addEvent(element, 'mouseup', handler);
};

exports.addMouseMoveTouchEvent = function (element, handler) {
  return addEvent(element, 'mousemove', handler);
};

exports.addClickTouchEvent = function (element, handler) {
  return addEvent(element, 'click', handler);
};

// A map from standard touch events to various aliases.
var TOUCH_MAP = {
  //  Incomplete list, add as needed.
  click: {
    standard: 'touchstart',
    ie10: 'MSPointerDown',
    ie11: 'pointerdown'
  },
  mousedown: {
    standard: 'touchstart',
    ie10: 'MSPointerDown',
    ie11: 'pointerdown'
  },
  mouseup: {
    standard: 'touchend',
    ie10: 'MSPointerUp',
    ie11: 'pointerup'
  },
  mousemove: {
    standard: 'touchmove',
    ie10: 'MSPointerMove',
    ie11: 'pointermove'
  }
};

exports.isMobile = function () {
  var reg = /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile/;
  return reg.test(window.navigator.userAgent);
};

exports.isWindowsTouch = function () {
  var reg = /MSIE.*Touch/;
  return reg.test(window.navigator.userAgent);
};

exports.isAndroid = function () {
  var reg = /Android/;
  return reg.test(window.navigator.userAgent);
};

exports.isIOS = function () {
  var reg = /iP(hone|od|ad)/;
  return reg.test(window.navigator.userAgent);
};

exports.isIPad = function () {
  var reg = /iPad/i;
  return reg.test(window.navigator.userAgent);
};

},{}],"/home/ubuntu/staging/apps/build/js/CommandHistory.js":[function(require,module,exports){
/** @file Provide browsable command history to a textbox with limited depth. */
// Strict linting: Absorb into global config when possible
/* jshint
 unused: true,
 eqeqeq: true,
 maxlen: 120
 */
'use strict';

var CommandHistory = module.exports = function () {
  /**
   * Ordered collection of command entries.
   * @private {string[]}
   */
  this.commands_ = [];

  /**
   * Current index into commands_, where 0 is the oldest command stored
   * @private {number}
   */
  this.currentIndex_ = 0;

  /**
   * The maximum number of entries to store in the command history, to
   * prevent ever-increasing memory for this feature.
   * @private {number}
   */
  this.maxEntries_ = 64;
};

/**
 * Add the given command to the current command history.  If the command
 * history has already reached its maximum depth, the oldest command will
 * drop off so that the newest command can be added.
 * @param {string} command
 */
CommandHistory.prototype.push = function (command) {
  if (this.commands_.length >= this.maxEntries_) {
    this.commands_.shift();
    this.currentIndex_ -= 1;
  }
  this.commands_.push(command);
  this.currentIndex_ = this.commands_.length;
};

/**
 * Move back in time by one entry, returning the command at the new
 * command index.
 * @param {string} currentInput
 * @returns {string}
 */
CommandHistory.prototype.goBack = function (currentInput) {
  this.alterHistory_(this.currentIndex_, currentInput);

  if (this.currentIndex_ > 0) {
    this.currentIndex_ -= 1;
  }
  if (typeof this.commands_[this.currentIndex_] !== 'undefined') {
    return this.commands_[this.currentIndex_];
  }
  return currentInput;
};

/**
 * Move forward in time by one entry, returning the command at the new
 * command index.
 * @param {string} currentInput
 * @returns {string}
 */
CommandHistory.prototype.goForward = function (currentInput) {
  this.alterHistory_(this.currentIndex_, currentInput);

  if (this.currentIndex_ < this.commands_.length) {
    this.currentIndex_ += 1;
  }
  if (this.currentIndex_ === this.commands_.length && currentInput === this.commands_[this.currentIndex_ - 1]) {
    return '';
  }
  if (typeof this.commands_[this.currentIndex_] !== 'undefined') {
    return this.commands_[this.currentIndex_];
  }
  return currentInput;
};

/**
 * Overwrites the currently viewed command entry in the history with a new
 * value.  Will do nothing if attempting overwrite an empty entry.
 * @param {!number} index - position in command history to rewrite
 * @param {!string} newValue
 * @private
 */
CommandHistory.prototype.alterHistory_ = function (index, newValue) {
  if (this.commands_[index] !== undefined) {
    this.commands_[index] = newValue;
  }
};

},{}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC9qcy9sZXZlbF9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZnL2NhbnZnLmpzIiwibm9kZV9tb2R1bGVzL3N0YWNrYmx1ci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZ2Jjb2xvci9pbmRleC5qcyIsImJ1aWxkL2pzL2NhbnZnL3N2Z190b2RhdGF1cmwuanMiLCJidWlsZC9qcy9zaGFyZWRGdW5jdGlvbmFsQmxvY2tzLmpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL0FwcFZpZXcuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL3Zpc3VhbGl6YXRpb25Db2x1bW4uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvY29kZVdvcmtzcGFjZS5odG1sLmVqcyIsImJ1aWxkL2pzL3NraW5zLmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2dldEFzc2V0RHJvcGRvd24uanMiLCJidWlsZC9qcy90aW1lb3V0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGlzdC9sb2Rhc2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsImJ1aWxkL2pzL2Fzc2V0TWFuYWdlbWVudC9zaG93LmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L0Fzc2V0TWFuYWdlci5qc3giLCJidWlsZC9qcy9hc3NldE1hbmFnZW1lbnQvQXNzZXRVcGxvYWRlci5qc3giLCJidWlsZC9qcy9hc3NldE1hbmFnZW1lbnQvQXNzZXRSb3cuanN4IiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L0Fzc2V0VGh1bWJuYWlsLmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9TdHVkaW9BcHBXcmFwcGVyLmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9Sb3RhdGVDb250YWluZXIuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL1Byb3RlY3RlZFN0YXRlZnVsRGl2LmpzeCIsImJ1aWxkL2pzL2FwcE1haW4uanMiLCJidWlsZC9qcy9yZXF1aXJlZF9ibG9ja191dGlscy5qcyIsImJ1aWxkL2pzL2Jsb2Nrc0NvbW1vbi5qcyIsImJ1aWxkL2pzL1N0dWRpb0FwcC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbWFrZVlvdXJPd24uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbGVhcm4uaHRtbC5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvYnVpbGRlci5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9hbGVydC5qc3giLCJidWlsZC9qcy90ZW1wbGF0ZXMvV2lyZWZyYW1lU2VuZFRvUGhvbmUuanN4IiwiYnVpbGQvanMvdGVtcGxhdGVzL1ZlcnNpb25IaXN0b3J5LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9WZXJzaW9uUm93LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9JbnN0cnVjdGlvbnMuanN4IiwiYnVpbGQvanMvbG9nVG9DbG91ZC5qcyIsImJ1aWxkL2pzL2ZlZWRiYWNrLmpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL3Ryb3BoeS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9zaG93Q29kZS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9zaGFyaW5nLmh0bWwuZWpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL3NoYXJlRmFpbHVyZS5odG1sLmVqcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9jb2RlLmh0bWwuZWpzIiwiYnVpbGQvanMvdGVtcGxhdGVzL2J1dHRvbnMuaHRtbC5lanMiLCJidWlsZC9qcy9wdXp6bGVSYXRpbmdVdGlscy5qcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9wdXp6bGVSYXRpbmcuaHRtbC5lanMiLCJidWlsZC9qcy9mZWVkYmFja0Jsb2Nrcy5qcyIsImJ1aWxkL2pzL2NsaWVudEFwaS5qcyIsImJ1aWxkL2pzL2Jsb2NrX3V0aWxzLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0VG9vbHRpcE1hbmFnZXIuanMiLCJidWlsZC9qcy9ibG9ja1Rvb2x0aXBzL0Ryb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy9Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5qcyIsImJ1aWxkL2pzL2Jsb2NrVG9vbHRpcHMvRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5odG1sLmVqcyIsImJ1aWxkL2pzL2Jsb2NrVG9vbHRpcHMvRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLmpzIiwiYnVpbGQvanMvYmxvY2tUb29sdGlwcy90b29sdGlwVXRpbHMuanMiLCJidWlsZC9qcy9ibG9ja1Rvb2x0aXBzL0Ryb3BsZXRQYXJhbWV0ZXJUb29sdGlwLmh0bWwuZWpzIiwiYnVpbGQvanMvYXV0aG9yZWRIaW50cy5qcyIsImJ1aWxkL2pzL3RlbXBsYXRlcy9saWdodGJ1bGJfZGltLnN2Zy5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvbGlnaHRidWxiLnN2Zy5lanMiLCJidWlsZC9qcy90ZW1wbGF0ZXMvSGludHNEaXNwbGF5LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9IaW50LmpzeCIsImJ1aWxkL2pzL3RlbXBsYXRlcy9IaW50U2VsZWN0LmpzeCIsImJ1aWxkL2pzL2F1dGhvcmVkSGludFV0aWxzLmpzIiwiYnVpbGQvanMveG1sLmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2Fzc2V0UHJlZml4LmpzIiwiYnVpbGQvanMvYXNzZXRNYW5hZ2VtZW50L2Fzc2V0TGlzdFN0b3JlLmpzIiwiYnVpbGQvanMvYWNlbW9kZS9tb2RlLWphdmFzY3JpcHRfY29kZW9yZy5qcyIsImJ1aWxkL2pzL2FjZW1vZGUvYW5ub3RhdGlvbkxpc3QuanMiLCJidWlsZC9qcy9hY2Vtb2RlL2Vycm9yTWFwcGVyLmpzIiwiYnVpbGQvanMvUmVzaXplU2Vuc29yLmpzIiwiYnVpbGQvanMvTXVzaWNDb250cm9sbGVyLmpzIiwiYnVpbGQvanMvSnNJbnRlcnByZXRlckxvZ2dlci5qcyIsImJ1aWxkL2pzL0pzRGVidWdnZXJVaS5qcyIsImJ1aWxkL2pzL3NsaWRlci5qcyIsImJ1aWxkL2pzL2NvbnN0YW50cy5qcyIsImJ1aWxkL2pzL09ic2VydmVyLmpzIiwiYnVpbGQvanMvSnNEZWJ1Z2dlclVpLmh0bWwuZWpzIiwibm9kZV9tb2R1bGVzL2Vqcy9saWIvZWpzLmpzIiwibm9kZV9tb2R1bGVzL2Vqcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZWpzL2xpYi9maWx0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiYnVpbGQvanMvSlNJbnRlcnByZXRlci5qcyIsImJ1aWxkL2pzL2NvZGVnZW4uanMiLCJidWlsZC9qcy9kcm9wbGV0VXRpbHMuanMiLCJidWlsZC9qcy9PYnNlcnZhYmxlRXZlbnQuanMiLCJidWlsZC9qcy9EZWJ1Z0FyZWEuanMiLCJidWlsZC9qcy91dGlscy5qcyIsImJ1aWxkL2pzL2xvZGFzaC5qcyIsImJ1aWxkL2pzL2hhbW1lci5qcyIsImJ1aWxkL2pzL2xvY2FsZS5qcyIsImJ1aWxkL2pzL2RvbS5qcyIsImJ1aWxkL2pzL0NvbW1hbmRIaXN0b3J5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7QUNTQSxPQUFPLENBQUMsSUFBSSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzVCLFNBQU87QUFDTCxRQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUU7QUFDcEIsYUFBTyxLQUFLLENBQUMsSUFBSSxJQUFJLHlCQUF5QixJQUMxQyxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNyRTtBQUNELFFBQUksRUFBRSx5QkFBeUI7QUFDL0IsVUFBTSxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQztHQUN2QixDQUFDO0NBQ0gsQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFdBQVcsR0FBRyxVQUFTLFNBQVMsRUFBRSxRQUFRLEVBQUU7QUFDbEQsU0FBTztBQUNMLFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRTtBQUNwQixhQUFPLEtBQUssQ0FBQyxJQUFJLElBQUkseUJBQXlCLElBQzFDLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQzFFO0FBQ0QsUUFBSSxFQUFFLHlCQUF5QjtBQUMvQixTQUFLLEVBQUUsa0JBQWtCLEdBQUcsU0FBUyxHQUFHLGVBQWUsR0FBRyxRQUFRLEdBQzlELHFCQUFxQjtHQUMxQixDQUFDO0NBQ0gsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBUyxJQUFJLEVBQUU7QUFDOUIsU0FBTztBQUNMLFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRTtBQUNwQixhQUFPLEtBQUssQ0FBQyxJQUFJLElBQUksd0JBQXdCLElBQ3pDLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3JFO0FBQ0QsUUFBSSxFQUFFLHdCQUF3QjtBQUM5QixVQUFNLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDO0dBQ3ZCLENBQUM7Q0FDSCxDQUFDOzs7QUN4REY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdjdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BCQSxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNqRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsU0FBUyxDQUFDOzs7Ozs7Ozs7QUFTbEQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFTLFdBQVcsRUFBRSxVQUFVLEVBQUU7QUFDakQsTUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QyxNQUFJLG9CQUFvQixHQUFHLFdBQVcsSUFBSSxPQUFPLFdBQVcsS0FBSyxVQUFVLENBQUM7QUFDNUUsTUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLGlCQUFpQixDQUFDO0FBQ3ZDLGNBQVUsRUFBRSxPQUFPO0FBQ25CLHNCQUFrQixFQUFFLGNBQWM7QUFDbEMsTUFBRSxFQUFFLG1CQUFtQjtHQUN4QixDQUFDLENBQUM7QUFDSCxPQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFO0FBQzdDLGNBQVUsRUFBRSxVQUFVO0FBQ3RCLGFBQVMsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRTtBQUMzQyxrQkFBYyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtBQUMxRCxlQUFXLEVBQUUsb0JBQW9CLEdBQUcsVUFBVSxZQUFZLEVBQUU7QUFDMUQsWUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2QsaUJBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUMzQixHQUFHLElBQUk7R0FDVCxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRWIsUUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0NBQ2YsQ0FBQzs7Ozs7QUNoQ0YsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMvQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUN6QyxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUNuRCxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7QUFFakQsSUFBSSxhQUFhLEdBQUc7QUFDbEIsS0FBRyxFQUFFLHlEQUF5RDtBQUM5RCxLQUFHLEVBQUUsd0JBQXdCO0FBQzdCLEtBQUcsRUFBRSxxQ0FBcUM7QUFDMUMsS0FBRyxFQUFFLHFDQUFxQztBQUMxQyxTQUFPLEVBQUUsNEJBQTRCO0NBQ3RDLENBQUM7O0FBRUYsSUFBSSxtQkFBbUIsR0FBRyxzREFBc0QsR0FDOUUsc0NBQXNDLENBQUM7O0FBRXpDLFNBQVMsZUFBZSxDQUFDLE1BQU0sRUFBRTtBQUMvQixTQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDO0NBQ3ZEOzs7OztBQUtELE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzs7O0FBQ2pDLFdBQVMsRUFBRTtBQUNULGVBQVcsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUk7QUFDakMsY0FBVSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtBQUNsQyxhQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVTtBQUM1QyxrQkFBYyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7R0FDaEQ7O0FBRUQsaUJBQWUsRUFBRSwyQkFBWTtBQUMzQixXQUFPO0FBQ0wsWUFBTSxFQUFFLElBQUk7QUFDWixtQkFBYSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxtQkFBbUI7S0FDcEUsQ0FBQztHQUNIOztBQUVELG9CQUFrQixFQUFFLDhCQUFZOztBQUU5QixhQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0dBQzlFOzs7Ozs7O0FBT0QscUJBQW1CLEVBQUUsNkJBQVUsR0FBRyxFQUFFO0FBQ2xDLGtCQUFjLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7QUFDbkQsUUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0dBQ3JFOzs7Ozs7O0FBT0Qsb0JBQWtCLEVBQUUsNEJBQVUsR0FBRyxFQUFFO0FBQ2pDLFFBQUksQ0FBQyxRQUFRLENBQUMsRUFBQyxhQUFhLEVBQUUsNEJBQTRCLEdBQ3hELGVBQWUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0dBQ2pDOztBQUVELGVBQWEsRUFBRSx5QkFBWTtBQUN6QixRQUFJLENBQUMsUUFBUSxDQUFDLEVBQUMsYUFBYSxFQUFFLGNBQWMsRUFBQyxDQUFDLENBQUM7R0FDaEQ7O0FBRUQsY0FBWSxFQUFFLHNCQUFVLE1BQU0sRUFBRTtBQUM5QixrQkFBYyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixRQUFJLENBQUMsUUFBUSxDQUFDO0FBQ1osWUFBTSxFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7QUFDbEQsbUJBQWEsRUFBRSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRywwQkFBMEI7S0FDdkUsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsZUFBYSxFQUFFLHVCQUFVLE1BQU0sRUFBRTtBQUMvQixRQUFJLENBQUMsUUFBUSxDQUFDLEVBQUMsYUFBYSxFQUFFLHdCQUF3QixHQUNwRCxlQUFlLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0dBQzdCOztBQUVELGdCQUFjLEVBQUUsd0JBQVUsSUFBSSxFQUFFO0FBQzlCLFFBQUksQ0FBQyxRQUFRLENBQUM7QUFDWixZQUFNLEVBQUUsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDbkMsbUJBQWEsRUFBRSxRQUFRLEdBQUcsSUFBSSxHQUFHLHlCQUF5QjtLQUMzRCxDQUFDLENBQUM7R0FDSjs7QUFFRCxRQUFNLEVBQUUsa0JBQVk7QUFDbEIsUUFBSSxZQUFZLEdBQUc7OztNQUNqQixvQkFBQyxhQUFhO0FBQ1osc0JBQWMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQUFBQztBQUMxQyxrQkFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxBQUFDO0FBQ2xDLGlCQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEFBQUM7QUFDaEMscUJBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxBQUFDO0FBQ2xDLG9CQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksQUFBQztBQUNoQyxxQkFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEFBQUMsR0FBRTtNQUN0Qzs7VUFBTSxLQUFLLEVBQUUsRUFBQyxNQUFNLEVBQUUsUUFBUSxFQUFDLEFBQUMsRUFBQyxFQUFFLEVBQUMscUJBQXFCO1FBQ3RELElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYTtPQUNwQjtLQUNILENBQUM7O0FBRVAsUUFBSSxTQUFTLENBQUM7Ozs7QUFJZCxRQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRTtBQUM5QixlQUFTLEdBQ1A7O1VBQUssS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFDLEFBQUM7UUFDakQsMkJBQUcsU0FBUyxFQUFDLHVCQUF1QixFQUFDLEtBQUssRUFBRSxFQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUMsQUFBQyxHQUFLO09BQ2hFLEFBQ1AsQ0FBQztLQUNILE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3pDLGVBQVMsR0FDUDs7O1FBQ0U7O1lBQUssS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLE9BQU8sRUFBQyxBQUFDOztTQUd4QjtRQUNMLFlBQVk7T0FDVCxBQUNQLENBQUM7S0FDSCxNQUFNO0FBQ0wsVUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUEsVUFBVSxLQUFLLEVBQUU7QUFDaEQsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFDbkUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUVwQixlQUFPLG9CQUFDLFFBQVE7QUFDWixhQUFHLEVBQUUsS0FBSyxDQUFDLFFBQVEsQUFBQztBQUNwQixjQUFJLEVBQUUsS0FBSyxDQUFDLFFBQVEsQUFBQztBQUNyQixjQUFJLEVBQUUsS0FBSyxDQUFDLFFBQVEsQUFBQztBQUNyQixjQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQUFBQztBQUNqQixrQkFBUSxFQUFFLE1BQU0sQUFBQztBQUNqQixrQkFBUSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLEFBQUMsR0FBRyxDQUFDO09BQ2xFLENBQUEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7QUFFZCxlQUFTLEdBQ1A7OztRQUNFOztZQUFLLEtBQUssRUFBRSxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUMsQUFBQztVQUMzRjs7Y0FBTyxLQUFLLEVBQUUsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFDLEFBQUM7WUFDNUI7OztjQUNHLElBQUk7YUFDQztXQUNGO1NBQ0o7UUFDTCxZQUFZO09BQ1QsQUFDUCxDQUFDO0tBQ0g7O0FBRUQsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQzlCOztRQUFHLFNBQVMsRUFBQyxjQUFjOztLQUFrQixHQUM3Qzs7UUFBRyxTQUFTLEVBQUMsY0FBYzs7S0FBa0IsQ0FBQzs7QUFFbEQsV0FDRTs7UUFBSyxTQUFTLEVBQUMsZUFBZSxFQUFDLEtBQUssRUFBRSxFQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUMsQUFBQztNQUMvQyxLQUFLO01BQ0wsU0FBUztLQUNOLENBQ047R0FDSDtDQUNGLENBQUMsQ0FBQzs7Ozs7Ozs7O0FDNUpILE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzs7O0FBQ2pDLFdBQVMsRUFBRTtBQUNULGlCQUFhLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVTtBQUM5QyxnQkFBWSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7QUFDN0MsYUFBUyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVU7QUFDNUMsY0FBVSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtBQUNsQyxrQkFBYyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7R0FDaEQ7O0FBRUQsbUJBQWlCLEVBQUUsNkJBQVk7QUFDN0IsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQzs7QUFFdkIsS0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUNsRCxjQUFRLEVBQUUsTUFBTTtBQUNoQixTQUFHLEVBQUUsYUFBYSxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRzs7O0FBRzFDLHNCQUFnQixFQUFFLEtBQUs7QUFDdkIsU0FBRyxFQUFFLGFBQVUsQ0FBQyxFQUFFLElBQUksRUFBRTtBQUN0QixhQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDdEIsWUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO09BQ2Y7QUFDRCxVQUFJLEVBQUUsY0FBVSxDQUFDLEVBQUUsSUFBSSxFQUFFO0FBQ3ZCLGFBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQ2pDO0FBQ0QsV0FBSyxFQUFFLGVBQVUsQ0FBQyxFQUFFLElBQUksRUFBRTtBQUN4QixhQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUMvQjtLQUNGLENBQUMsQ0FBQztHQUNKOztBQUVELHNCQUFvQixFQUFFLGdDQUFZO0FBQ2hDLEtBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDaEU7Ozs7OztBQU1ELG1CQUFpQixFQUFFLDZCQUFZO0FBQzdCLFFBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNyRCxZQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7R0FDbEI7O0FBRUQsUUFBTSxFQUFFLGtCQUFZOzs7QUFHbEIsV0FDRTs7O01BQ0U7QUFDSSxXQUFHLEVBQUMsVUFBVTtBQUNkLFlBQUksRUFBQyxNQUFNO0FBQ1gsYUFBSyxFQUFFLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBQyxBQUFDO0FBQ3pCLGNBQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxJQUFJLEdBQUcsQ0FBQSxHQUFJLElBQUksQUFBQyxHQUFFO01BQ3BEOzs7QUFDSSxpQkFBTyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQUFBQztBQUNoQyxtQkFBUyxFQUFDLE9BQU87QUFDakIsWUFBRSxFQUFDLGNBQWM7QUFDakIsa0JBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxBQUFDO1FBQ3ZDLDJCQUFHLFNBQVMsRUFBQyxjQUFjLEdBQUs7O09BRXpCO0tBQ0osQ0FDUDtHQUNIO0NBQ0YsQ0FBQyxDQUFDOzs7OztBQ3JFSCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQy9DLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDOzs7OztBQUtyRCxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7OztBQUNqQyxXQUFTLEVBQUU7QUFDVCxRQUFJLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVTtBQUN2QyxRQUFJLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVTtBQUNuRSxRQUFJLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNO0FBQzVCLFlBQVEsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUk7QUFDOUIsWUFBUSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7R0FDMUM7O0FBRUQsaUJBQWUsRUFBRSwyQkFBWTtBQUMzQixXQUFPO0FBQ0wsWUFBTSxFQUFFLFFBQVE7QUFDaEIsZ0JBQVUsRUFBRSxFQUFFO0tBQ2YsQ0FBQztHQUNIOzs7OztBQUtELGVBQWEsRUFBRSx5QkFBWTtBQUN6QixRQUFJLENBQUMsUUFBUSxDQUFDLEVBQUMsTUFBTSxFQUFFLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDO0dBQzlEOzs7OztBQUtELGNBQVksRUFBRSx3QkFBWTtBQUN4QixRQUFJLENBQUMsUUFBUSxDQUFDLEVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFDLENBQUMsQ0FBQztHQUNuRDs7Ozs7O0FBTUQsY0FBWSxFQUFFLHdCQUFZO0FBQ3hCLFFBQUksQ0FBQyxRQUFRLENBQUMsRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDOzs7QUFHcEQsYUFBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQSxZQUFZO0FBQ3pFLFVBQUksQ0FBQyxRQUFRLENBQUMsRUFBQyxNQUFNLEVBQUUsbUJBQW1CO0FBQ3RDLGtCQUFVLEVBQUUsc0JBQXNCLEVBQUMsQ0FBQyxDQUFDO0tBQzFDLENBQUEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUNmOztBQUVELFFBQU0sRUFBRSxrQkFBWTtBQUNsQixRQUFJLE9BQU8sRUFBRSxJQUFJLENBQUM7O0FBRWxCLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDdkIsVUFBSSxHQUFHOztVQUFRLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQUFBQzs7T0FBZ0IsQ0FBQztLQUM5RCxNQUFNO0FBQ0wsVUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUEsQ0FBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsVUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLENBQUM7S0FDckI7O0FBRUQsWUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07QUFDdkIsV0FBSyxRQUFRO0FBQ1gsWUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzlDLGVBQU8sR0FDTDs7WUFBSSxLQUFLLEVBQUMsS0FBSyxFQUFDLEtBQUssRUFBRSxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUMsQUFBQztVQUN6QyxJQUFJO1VBQ0w7O2NBQUcsSUFBSSxFQUFFLEdBQUcsQUFBQztBQUNULG9CQUFNLEVBQUMsUUFBUTtBQUNmLG1CQUFLLEVBQUUsRUFBQyxlQUFlLEVBQUUsYUFBYSxFQUFDLEFBQUM7WUFDMUM7OztjQUFRLDJCQUFHLFNBQVMsRUFBQyxXQUFXLEdBQUs7YUFBUztXQUM1QztVQUNKOztjQUFRLFNBQVMsRUFBQyxZQUFZLEVBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxhQUFhLEFBQUM7WUFDekQsMkJBQUcsU0FBUyxFQUFDLGVBQWUsR0FBSztXQUMxQjtVQUNSLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVTtTQUNuQixBQUNOLENBQUM7QUFDRixjQUFNO0FBQUEsQUFDUixXQUFLLG1CQUFtQjtBQUN0QixlQUFPLEdBQ0w7O1lBQUksS0FBSyxFQUFDLEtBQUssRUFBQyxLQUFLLEVBQUUsRUFBQyxTQUFTLEVBQUUsT0FBTyxFQUFDLEFBQUM7VUFDMUM7O2NBQVEsU0FBUyxFQUFDLFlBQVksRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQUFBQzs7V0FFakQ7VUFDVDs7Y0FBUSxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQUFBQzs7V0FBZ0I7VUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVO1NBQ25CLEFBQ04sQ0FBQztBQUNGLGNBQU07QUFBQSxBQUNSLFdBQUssVUFBVTtBQUNiLGVBQU8sR0FDTDs7WUFBSSxLQUFLLEVBQUMsS0FBSyxFQUFDLEtBQUssRUFBRSxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUMsQUFBQztVQUMxQywyQkFBRyxTQUFTLEVBQUMsdUJBQXVCLEVBQUMsS0FBSyxFQUFFO0FBQzFDLHNCQUFRLEVBQUUsTUFBTTtBQUNoQix5QkFBVyxFQUFFLE1BQU07YUFDcEIsQUFBQyxHQUFLO1NBQ0osQUFDTixDQUFDO0FBQ0YsY0FBTTtBQUFBLEtBQ1Q7O0FBRUQsV0FDRTs7UUFBSSxTQUFTLEVBQUMsVUFBVSxFQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQUFBQztNQUMxRCxvQkFBQyxjQUFjLElBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUFDLEVBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUFDLEdBQUU7TUFDL0Q7OztRQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTtPQUFNO01BQ3pCLE9BQU87S0FDTCxDQUNMO0dBQ0g7Q0FDRixDQUFDLENBQUM7Ozs7O0FDN0dILElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLENBQUM7O0FBRS9DLElBQUksWUFBWSxHQUFHO0FBQ2pCLE9BQUssRUFBRSxpQkFBaUI7QUFDeEIsT0FBSyxFQUFFLGFBQWE7QUFDcEIsT0FBSyxFQUFFLG9CQUFvQjtBQUMzQixTQUFPLEVBQUUsZ0JBQWdCO0NBQzFCLENBQUM7O0FBRUYsSUFBSSxtQkFBbUIsR0FBRztBQUN4QixPQUFLLEVBQUUsTUFBTTtBQUNiLFVBQVEsRUFBRSxNQUFNO0FBQ2hCLFFBQU0sRUFBRSxNQUFNO0FBQ2QsV0FBUyxFQUFFLE1BQU07QUFDakIsV0FBUyxFQUFFLEtBQUs7QUFDaEIsV0FBUyxFQUFFLGtCQUFrQjtBQUM3QixhQUFXLEVBQUUsa0JBQWtCO0FBQy9CLGlCQUFlLEVBQUUsa0JBQWtCO0NBQ3BDLENBQUM7O0FBRUYsSUFBSSxjQUFjLEdBQUc7QUFDbkIsUUFBTSxFQUFFLFFBQVE7QUFDaEIsVUFBUSxFQUFFLE1BQU07Q0FDakIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7OztBQUNqQyxXQUFTLEVBQUU7QUFDVCxRQUFJLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVTtBQUN2QyxRQUFJLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVTtHQUNwRTs7QUFFRCxRQUFNLEVBQUUsa0JBQVk7QUFDbEIsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDM0IsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7O0FBRTNCLFdBQ0U7O1FBQUksS0FBSyxFQUFDLElBQUk7TUFDWjs7VUFBSyxTQUFTLEVBQUMsZ0JBQWdCLEVBQUMsS0FBSyxFQUFFO0FBQ3JDLGlCQUFLLEVBQUUsTUFBTTtBQUNiLGtCQUFNLEVBQUUsTUFBTTtBQUNkLGtCQUFNLEVBQUUsV0FBVztBQUNuQixzQkFBVSxFQUFFLE1BQU07QUFDbEIsa0JBQU0sRUFBRSxnQkFBZ0I7QUFDeEIscUJBQVMsRUFBRSxRQUFRO1dBQ3BCLEFBQUM7UUFDQyxJQUFJLEtBQUssT0FBTyxHQUNkLDZCQUFLLEdBQUcsRUFBRSxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxBQUFDLEVBQUMsS0FBSyxFQUFFLG1CQUFtQixBQUFDLEdBQUcsR0FDbEUsMkJBQUcsU0FBUyxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxZQUFZLENBQUMsT0FBTyxBQUFDLEVBQUMsS0FBSyxFQUFFLGNBQWMsQUFBQyxHQUFLO09BRXBGO0tBQ0gsQ0FDTDtHQUNIO0NBQ0YsQ0FBQyxDQUFDOzs7QUNyREgsWUFBWSxDQUFDOztBQUViLElBQUksZUFBZSxHQUFHLE9BQU8sQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDOzs7Ozs7QUFNbEUsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDOzs7QUFDdkMsV0FBUyxFQUFFO0FBQ1QsWUFBUSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7QUFDekMsZUFBVyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7QUFDNUMsZUFBVyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVU7R0FDN0M7O0FBRUQsbUJBQWlCLEVBQUUsNkJBQVk7QUFDN0IsV0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFBLEFBQUMsQ0FBQztHQUM1RDs7QUFFRCxRQUFNLEVBQUUsa0JBQVk7QUFDbEIsV0FDRTs7O01BQ0csSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksb0JBQUMsZUFBZSxJQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQUFBQyxHQUFHO01BQzlFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUTtNQUNwQiw2QkFBSyxTQUFTLEVBQUMsT0FBTyxHQUFPO0tBQ3pCLENBQ047R0FDSDtDQUNGLENBQUMsQ0FBQztBQUNILE1BQU0sQ0FBQyxPQUFPLEdBQUcsZ0JBQWdCLENBQUM7OztBQzdCbEMsWUFBWSxDQUFDOztBQUViLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7Ozs7QUFLL0IsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzs7O0FBQ3RDLFdBQVMsRUFBRTtBQUNULFlBQVEsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVO0dBQzFDOztBQUVELFFBQU0sRUFBRSxrQkFBWTtBQUNsQixXQUNFOztRQUFLLEVBQUUsRUFBQyxpQkFBaUIsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxBQUFDO01BQy9DOztVQUFLLEVBQUUsRUFBQyxZQUFZO1FBQ2xCOzs7VUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFO1VBQUMsK0JBQU07VUFBQyxHQUFHLENBQUMsZUFBZSxFQUFFO1NBQUs7T0FDbEQ7S0FDRixDQUNOO0dBQ0g7O0FBRUQsVUFBUSxFQUFFLG9CQUFZO0FBQ3BCLFdBQU87QUFDTCxxQkFBZSxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxnQ0FBZ0MsQ0FBQyxHQUFHLEdBQUc7S0FDdEYsQ0FBQztHQUNIO0NBQ0YsQ0FBQyxDQUFDO0FBQ0gsTUFBTSxDQUFDLE9BQU8sR0FBRyxlQUFlLENBQUM7OztBQzVCakMsWUFBWSxDQUFDOzs7Ozs7Ozs7Ozs7O0FBVWIsSUFBSSxvQkFBb0IsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDOzs7QUFDM0MsV0FBUyxFQUFFO0FBQ1Qsa0JBQWMsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUk7R0FDckM7O0FBRUQsdUJBQXFCLEVBQUUsaUNBQVk7QUFDakMsV0FBTyxLQUFLLENBQUM7R0FDZDs7QUFFRCxtQkFBaUIsRUFBRSw2QkFBWTtBQUM3QixRQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEtBQUssVUFBVSxFQUFFO0FBQ25ELFVBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0tBQ3JFO0dBQ0Y7O0FBRUQsc0JBQW9CLEVBQUUsZ0NBQVk7QUFDaEMsVUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO0dBQ3RFOztBQUVELFFBQU0sRUFBRSxrQkFBWTtBQUNsQixXQUFPLHdDQUFTLElBQUksQ0FBQyxLQUFLLElBQUUsR0FBRyxFQUFDLE1BQU0sSUFBTyxDQUFDO0dBQy9DO0NBQ0YsQ0FBQyxDQUFDO0FBQ0gsTUFBTSxDQUFDLE9BQU8sR0FBRyxvQkFBb0IsQ0FBQzs7Ozs7QUNqQ3RDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDMUIsSUFBSSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUMzRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ2pELElBQUksaUJBQWlCLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Ozs7QUFJdkQsTUFBTSxDQUFDLGVBQWUsR0FBRztBQUN2QixZQUFVLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQztBQUNuRCxzQkFBb0IsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRSxTQUFTLENBQUM7QUFDdkUsb0JBQWtCLEVBQUUsOEJBQVk7QUFDOUIsV0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0dBQzlEO0FBQ0QsWUFBVSxFQUFFLHNCQUFZO0FBQ3RCLFdBQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQztHQUN6Qjs7QUFFRCxzQkFBb0IsRUFBRSxLQUFLO0NBQzVCLENBQUM7O0FBRUYsSUFBSSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7QUFDekQsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7O0FBRTdDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBUyxHQUFHLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRTs7OztBQUk5QyxNQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7QUFDbkIsUUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwQyxXQUFPLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3BDLFdBQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDbkMsU0FBSyxJQUFJLElBQUksSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQzlCLFdBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ25DOztBQUVELFFBQUksT0FBTyxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRTtBQUM1QyxXQUFLLENBQUMsY0FBYyxHQUFHLGtCQUFrQixDQUFDLGtDQUFrQyxDQUN4RSxPQUFPLENBQUMsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7S0FDL0M7QUFDRCxRQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsNkJBQTZCLEVBQUU7QUFDL0MsV0FBSyxDQUFDLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDLGtDQUFrQyxDQUMzRSxPQUFPLENBQUMsS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDbEQ7O0FBRUQsUUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRTtBQUMvQixXQUFLLENBQUMsYUFBYSxHQUFHLGlCQUFpQixDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDNUY7O0FBRUQsV0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7R0FDdkI7O0FBRUQsV0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFN0IsU0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFNUUsTUFBSSxTQUFTLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDOUIsUUFBSSxtQkFBbUIsR0FBRztBQUN4QixVQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7QUFDbEIsVUFBSSxFQUFFLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJO0FBQ3pDLFdBQUssRUFBRSxPQUFPLENBQUMsS0FBSztLQUNyQixDQUFDOztBQUVGLFFBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtBQUM5QyxXQUFLLENBQUMsbUNBQW1DLEVBQUUsQ0FBQztLQUM3Qzs7QUFFRCxnQkFBWSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztBQUNuRCxXQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztHQUM1RDs7QUFFRCxrQkFBZ0IsQ0FBQyxZQUFXO0FBQzFCLFFBQUksT0FBTyxDQUFDLFFBQVEsRUFBRTtBQUNwQixVQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUU7QUFDcEIsV0FBRyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztPQUMzQixNQUFNO0FBQ0wsaUJBQVMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDakM7S0FDRixNQUFNO0FBQ0wsU0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNsQixVQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7QUFDeEIsZUFBTyxDQUFDLFlBQVksRUFBRSxDQUFDO09BQ3hCO0tBQ0Y7R0FDRixDQUFDLENBQUM7Q0FDSixDQUFDOzs7Ozs7O0FDbkZGLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQy9CLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM5QixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7Ozs7Ozs7OztBQVMxQixPQUFPLENBQUMsY0FBYyxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3hDLFNBQU8sOENBQThDLEdBQ25ELE1BQU0sR0FBRyxrQkFBa0IsQ0FBQztDQUMvQixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsV0FBVyxHQUFHLFVBQVMsVUFBVSxFQUFFO0FBQ3pDLFNBQU8sRUFBQyxJQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUU7QUFBQyxhQUFPLEtBQUssQ0FBQyxJQUFJLElBQUksVUFBVSxDQUFDO0tBQUU7QUFDL0QsUUFBSSxFQUFFLFVBQVUsRUFBQyxDQUFDO0NBQ3JCLENBQUM7Ozs7Ozs7OztBQVNGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBUyxLQUFLLEVBQUU7OztBQUcvQixTQUFPLEVBQUMsSUFBSSxFQUFFLGNBQVMsS0FBSyxFQUFFO0FBQUMsYUFBTyxLQUFLLENBQUMsSUFBSSxJQUFJLGlCQUFpQixDQUFDO0tBQUM7QUFDckUsUUFBSSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUMsRUFBQyxDQUFDO0NBQ3RELENBQUM7Ozs7Ozs7OztBQVNGLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUMxQyxTQUFPLEVBQUMsSUFBSSxFQUFFLGNBQVMsS0FBSyxFQUFFO0FBQUMsYUFBTyxLQUFLLENBQUMsSUFBSSxJQUFJLDRCQUE0QixDQUFDO0tBQUM7QUFDaEYsUUFBSSxFQUFFLDRCQUE0QixFQUFFLE1BQU0sRUFBRSxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUMsRUFBQyxDQUFDO0NBQ2pFLENBQUM7Ozs7OztBQU1GLE9BQU8sQ0FBQyxrQ0FBa0MsR0FBRyxVQUFVLG9CQUFvQixFQUFFO0FBQzNFLE1BQUksU0FBUyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsQ0FBQzs7QUFFdkQsTUFBSSxtQkFBbUIsR0FBRyxFQUFFLENBQUM7QUFDN0IsT0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBUyxTQUFTLEVBQUU7O0FBRXJFLFFBQUksU0FBUyxDQUFDLFFBQVEsS0FBSyxDQUFDLEVBQUU7QUFDNUIsYUFBTztLQUNSO0FBQ0QsWUFBUSxTQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztBQUNwQyxXQUFLLFVBQVU7QUFDYiwyQkFBbUIsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUN0RCxjQUFNO0FBQUEsQUFDUixXQUFLLHdCQUF3QixDQUFDO0FBQzlCLFdBQUssc0JBQXNCO0FBQ3pCLDJCQUFtQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3hELGNBQU07QUFBQSxBQUNSLFdBQUssdUJBQXVCO0FBQzFCLGNBQU07QUFBQSxBQUNSLFdBQUssaUJBQWlCO0FBQ3BCLDJCQUFtQixDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUN4RSxjQUFNO0FBQUEsQUFDUjtBQUNFLDJCQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFBQSxLQUN4RDtHQUNGLENBQUMsQ0FBQzs7QUFFSCxTQUFPLG1CQUFtQixDQUFDO0NBQzVCLENBQUM7Ozs7O0FBS0YsU0FBUyxhQUFhLENBQUUsSUFBSSxFQUFFO0FBQzVCLFNBQU87QUFDTCxRQUFJLEVBQUUsY0FBUyxTQUFTLEVBQUU7O0FBRXhCLFVBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxRCxhQUFPLGtCQUFrQixDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztLQUM5QztBQUNELG1CQUFlLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7R0FDckMsQ0FBQztDQUNIOzs7Ozs7O0FBT0QsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7QUFDOUIsTUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDOztBQUVmLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxNQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkQsTUFBSSxJQUFJLENBQUM7QUFDVCxLQUFHOztBQUVELFFBQUksR0FBRyxLQUFLLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0MsUUFBSSxJQUFJLEVBQUU7QUFDUixXQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3pCO0FBQ0QsU0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNqQyxRQUFJLElBQUksRUFBRTtBQUNSLFdBQUssR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDL0M7R0FDRixRQUFRLElBQUksRUFBRTtBQUNmLFNBQU8sS0FBSyxDQUFDO0NBQ2Q7Ozs7OztBQU1ELFNBQVMsa0JBQWtCLENBQUMsSUFBSSxFQUFFO0FBQ2hDLE1BQUksVUFBVSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNoRSxNQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RDLFlBQVUsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzdDLFNBQU8sQ0FBQzs7OztBQUlOLFFBQUksRUFBRSxjQUFTLFNBQVMsRUFBRTtBQUN4QixVQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUNoRCxlQUFPLFVBQVUsS0FBSyxTQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQztPQUN4RDs7QUFFRCxhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsV0FBTyxFQUFFLEdBQUcsQ0FBQywwQkFBMEIsRUFBRTtBQUN6QyxtQkFBZSxFQUFFLGFBQWE7R0FDL0IsQ0FBQyxDQUFDO0NBQ0o7O0FBRUQsU0FBUyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFO0FBQ2hELE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9ELE1BQUksV0FBVyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMvQyxNQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxTQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztHQUNqRDs7QUFFRCxNQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxPQUFPLEVBQUU7QUFDL0QsUUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLHVCQUF1QixFQUFFO0FBQzVELGFBQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDRCxRQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDOUQsUUFBSSxDQUFDLFdBQVcsRUFBRTtBQUNoQixhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsV0FBTyxXQUFXLENBQUMsV0FBVyxLQUFLLElBQUksQ0FBQztHQUN6QyxDQUFDLENBQUM7O0FBRUgsTUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNmLFVBQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQztHQUMvRDs7QUFFRCxTQUFPLENBQUM7QUFDTixRQUFJLEVBQUUsY0FBVSxTQUFTLEVBQUU7QUFDekIsVUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLGlCQUFpQixJQUNwQyxTQUFTLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxFQUFFO0FBQ3BDLGVBQU8sS0FBSyxDQUFDO09BQ2Q7QUFDRCxVQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDMUMsYUFBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUNwQztBQUNELG1CQUFlLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztHQUNqRSxDQUFDLENBQUM7Q0FFSjs7Ozs7OztBQU9ELFNBQVMsa0JBQWtCLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRTtBQUMzQyxNQUFJLEVBQUUsUUFBUSxZQUFZLE9BQU8sSUFBSSxLQUFLLFlBQVksT0FBTyxDQUFBLEFBQUMsRUFBRTs7QUFFOUQsUUFBSSxRQUFRLFlBQVksSUFBSSxJQUFJLFFBQVEsQ0FBQyxXQUFXLEtBQUssS0FBSyxFQUFFO0FBQzlELGFBQU8sSUFBSSxDQUFDO0tBQ2I7QUFDRCxXQUFPLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDcEM7OztBQUdELE1BQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsS0FBSyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFO0FBQ2xFLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7O0FBRUQsTUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsRUFBRTtBQUMxQyxXQUFPLEtBQUssQ0FBQztHQUNkOztBQUVELE1BQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLEVBQUU7QUFDeEMsV0FBTyxLQUFLLENBQUM7R0FDZDs7QUFFRCxTQUFPLElBQUksQ0FBQztDQUNiOzs7Ozs7QUFNRCxJQUFJLG1CQUFtQixHQUFHLENBQ3hCLFdBQVcsRUFDWCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFFBQVEsRUFDUixhQUFhLEVBQ2IsYUFBYSxFQUNiLElBQUksQ0FDTCxDQUFDOztBQUVGLG1CQUFtQixDQUFDLFFBQVEsR0FBRyxVQUFVLElBQUksRUFBRTtBQUM3QyxTQUFPLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDdEQsQ0FBQzs7Ozs7QUFLRixTQUFTLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUU7QUFDN0MsTUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzlFLE1BQUksV0FBVyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMzRSxNQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUM3QyxXQUFPLEtBQUssQ0FBQztHQUNkO0FBQ0QsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsUUFBSSxLQUFLLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFFBQUksS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQixRQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLElBQUksRUFBRTtBQUM3QixhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsUUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxLQUFLLEVBQUU7QUFDL0IsYUFBTyxLQUFLLENBQUM7S0FDZDtHQUNGO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7Ozs7QUFLRCxTQUFTLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUU7QUFDM0MsTUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQztBQUNwQyxNQUFJLFNBQVMsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO0FBQ2pDLE1BQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxTQUFTLENBQUMsTUFBTSxFQUFFO0FBQ3pDLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7QUFDRCxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxRQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25ELGFBQU8sS0FBSyxDQUFDO0tBQ2Q7R0FDRjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7O0FBUUQsT0FBTyxDQUFDLFdBQVcsR0FBRyxVQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDN0MsTUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQzdDLE1BQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDM0QsU0FBTyxVQUFVLElBQUksV0FBVyxDQUFDO0NBQ2xDLENBQUM7Ozs7Ozs7O0FBUUYsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUNsRCxNQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDdEMsTUFBSSxZQUFZLEdBQUcsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDOztBQUV0QyxNQUFJLFdBQVcsR0FBRyxTQUFkLFdBQVcsQ0FBWSxDQUFDLEVBQUMsQ0FBQyxFQUFFO0FBQUUsV0FBTyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7R0FBRSxDQUFDO0FBQzVELGNBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDL0IsY0FBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFL0IsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkUsUUFBSSxXQUFXLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLFFBQUksV0FBVyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxRQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUM5QixDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLEVBQUU7QUFDeEMsYUFBTyxLQUFLLENBQUM7S0FDZDtHQUNGO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDOztBQUVGLElBQUksV0FBVyxHQUFHLFNBQWQsV0FBVyxDQUFZLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDekMsU0FBTyxNQUFNLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQ2hDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsS0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7Q0FDM0MsQ0FBQzs7Ozs7O0FDNVRGLFlBQVksQ0FBQzs7QUFFYixJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7Ozs7OztBQU1wQyxPQUFPLENBQUMsT0FBTyxHQUFHLFVBQVMsT0FBTyxFQUFFLG1CQUFtQixFQUFFO0FBQ3ZELE1BQUksSUFBSSxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQztBQUNwQyxNQUFJLElBQUksR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUM7O0FBRXBDLGlDQUErQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQywrQkFBNkIsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2Qyx1QkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMvQixnQkFBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLGlCQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDekIsZ0JBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQ3JDLENBQUM7O0FBRUYsU0FBUywrQkFBK0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFOztBQUV0RCxTQUFPLENBQUMsVUFBVSxDQUFDLDBCQUEwQixHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDO0FBQ25GLFNBQU8sQ0FBQyxVQUFVLENBQUMsbUNBQW1DLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUM7O0FBRTVGLFNBQU8sQ0FBQyxNQUFNLENBQUMsMEJBQTBCLEdBQUc7O0FBRTFDLFFBQUksRUFBRSxnQkFBWTtBQUNoQixVQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNyRCxVQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDN0IsVUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQ3BCLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLENBQ3JELFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUMsMkJBQTJCLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUM5RyxVQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQzVCLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFDekQsVUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixVQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsQ0FBQztLQUN0RDtHQUNGLENBQUM7O0FBRUYsU0FBTyxDQUFDLE1BQU0sQ0FBQyxtQ0FBbUMsR0FBRzs7QUFFbkQsUUFBSSxFQUFFLGdCQUFZO0FBQ2hCLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3JELFVBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM3QixVQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FDcEIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FDckQsV0FBVyxDQUFDLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3JELFVBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FDNUIsV0FBVyxDQUFDLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN6RCxVQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEMsVUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVCLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQ3REO0dBQ0YsQ0FBQztDQUNIOztBQUVELFNBQVMsNkJBQTZCLENBQUMsT0FBTyxFQUFFO0FBQzlDLFNBQU8sQ0FBQyxVQUFVLENBQUMsd0JBQXdCLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUM7O0FBRWpGLFNBQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEdBQUc7O0FBRXhDLFFBQUksRUFBRSxnQkFBVztBQUNmLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3JELFVBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM3QixVQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FDcEIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FDckQsV0FBVyxDQUFDLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUNqRCxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3hELFVBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FDNUIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUNyRCxVQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEMsVUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVCLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQ3REO0dBQ0YsQ0FBQztDQUNIOztBQUVELFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFO0FBQ3RDLFNBQU8sQ0FBQyxVQUFVLENBQUMsb0JBQW9CLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7O0FBRXpFLFNBQU8sQ0FBQyxNQUFNLENBQUMsb0JBQW9CLEdBQUc7O0FBRXBDLFFBQUksRUFBRSxnQkFBVztBQUNmLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ2pELFVBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM3QixVQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FDcEIsV0FBVyxDQUFDLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ25ELFVBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDcEQsVUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDbEQ7R0FDRixDQUFDO0NBQ0g7Ozs7QUFJRCxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUU7QUFDL0IsU0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUc7O0FBRXhCLFFBQUksRUFBRSxnQkFBVztBQUNmLFVBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7O0FBRzdCLFVBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUNsQixXQUFXLENBQUMsd0NBQXdDLENBQUMsQ0FBQztBQUMzRCxVQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbkM7R0FDRixDQUFDOztBQUVGLFNBQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLFlBQVk7QUFDeEMsV0FBTyxJQUFJLENBQUM7R0FDYixDQUFDO0NBQ0g7OztBQUdELFNBQVMsZUFBZSxDQUFDLE9BQU8sRUFBRTtBQUNoQyxTQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRzs7QUFFeEIsUUFBSSxFQUFFLGdCQUFXO0FBQ2YsVUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzdCLFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUczQixVQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FDcEIsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUN2QixXQUFXLENBQUMsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQy9ELFVBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQyxVQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDOUI7R0FDRixDQUFDOztBQUVGLFNBQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLFlBQVk7QUFDeEMsV0FBTyxJQUFJLENBQUM7R0FDYixDQUFDO0NBQ0g7O0FBRUQsU0FBUyxjQUFjLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDM0MsU0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUc7O0FBRXhCLFdBQU8sRUFBRSxFQUFFO0FBQ1gsUUFBSSxFQUFFLGdCQUFZO0FBQ2hCLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM1QixVQUFJLElBQUksRUFBRTtBQUNSLFlBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUNwQixXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQ2hDLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7T0FDdkQsTUFBTTtBQUNMLFlBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztPQUMxRDtBQUNELFVBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQyxVQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDN0I7QUFDRCxxQkFBaUIsRUFBRSw2QkFBWTtBQUM3QixhQUFPLEtBQUssQ0FBQztLQUNkO0dBQ0YsQ0FBQzs7QUFFRixTQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsR0FBRyxZQUFZOztBQUV4QyxXQUFPLElBQUksQ0FBQztHQUNiLENBQUM7Q0FDSDs7Ozs7OztBQ25LRCxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsbUNBQW1DLENBQUMsQ0FBQztBQUMzRCxJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ3BELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM3QyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDMUIsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzNCLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQzFDLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM5QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsSUFBSSxxQkFBcUIsR0FBRyxPQUFPLENBQUMsdUNBQXVDLENBQUMsQ0FBQztBQUM3RSxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDekIsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzFDLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQy9ELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzdDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNuQyxJQUFJLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3ZELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6QyxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUMvQyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUMzRCxJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0FBQzNFLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDOUMsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFDM0QsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDakUsSUFBSSxnQkFBZ0IsQ0FBQzs7Ozs7QUFLckIsSUFBSSxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3BCLElBQUkscUNBQXFDLEdBQUcsR0FBRyxDQUFDO0FBQ2hELElBQUksdUJBQXVCLEdBQUcsR0FBRyxDQUFDO0FBQ2xDLElBQUksdUJBQXVCLEdBQUcsR0FBRyxDQUFDOztBQUVsQyxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUM7Ozs7O0FBSzdCLElBQUksZUFBZSxHQUFHLEdBQUcsQ0FBQzs7QUFFMUIsSUFBSSxTQUFTLEdBQUcsU0FBWixTQUFTLEdBQWU7QUFDMUIsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxNQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7O0FBS3hELE1BQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDOzs7OztBQUsxQixNQUFJLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQzs7QUFFN0IsTUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDM0IsTUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFDdEIsTUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7Ozs7O0FBSzFCLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOzs7O0FBSW5CLE1BQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOzs7O0FBSW5CLE1BQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUM7OztBQUdsQyxNQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQztBQUN0QixNQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixNQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztBQUN6QixNQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQzs7Ozs7Ozs7QUFRN0IsTUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQzs7Ozs7OztBQU9sQyxNQUFJLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJqQyxNQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQzs7Ozs7OztBQU8xQixNQUFJLENBQUMsd0JBQXdCLEdBQUcsQ0FBQyxDQUFDOzs7OztBQUtsQyxNQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0FBTzdCLE1BQUksQ0FBQywyQkFBMkIsR0FBRyxDQUFDLENBQUM7Ozs7OztBQU1yQyxNQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQzs7Ozs7OztBQU9sQixNQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQzs7Ozs7QUFLMUIsTUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDOzs7OztBQUt2QyxNQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUM7Ozs7O0FBS3pDLE1BQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDOzs7OztBQUt4QixNQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7Ozs7QUFLbkIsTUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7Ozs7O0FBSzNCLE1BQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDOztBQUU1QixNQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixNQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztBQUM1QixNQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQztBQUNoQyxNQUFJLENBQUMsbUJBQW1CLEdBQUcsU0FBUyxDQUFDO0FBQ3JDLE1BQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBQzdCLE1BQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7O0FBRWpDLE1BQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7QUFDaEMsTUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7O0FBRXZCLE1BQUksQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLENBQUM7Q0FDdkMsQ0FBQztBQUNGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBQzNCLFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQzs7Ozs7QUFLdEMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFDakQsTUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQ2hDLE1BQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDOzs7QUFHNUMsTUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0FBQ3hELE1BQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDOzs7O0FBSXBDLE1BQUksT0FBTyxDQUFDLFlBQVksRUFBRTtBQUN4QixRQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUN0QixRQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztHQUM1Qjs7QUFFRCxNQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDbkMsTUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDOzs7O0FBSTdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUU3QyxNQUFJLENBQUMscUJBQXFCLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixJQUFJLHVCQUF1QixDQUFDO0FBQ3RGLE1BQUksQ0FBQyxxQkFBcUIsR0FBRyxPQUFPLENBQUMscUJBQXFCLElBQUksdUJBQXVCLENBQUM7Q0FDdkYsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLHFCQUFxQixHQUFHLFVBQVUsTUFBTSxFQUFFO0FBQzVELFNBQU8sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFBLEFBQUMsQ0FBQztDQUNoRSxDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQzFDLE1BQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxVQUFNLEdBQUcsRUFBRSxDQUFDO0dBQ2I7O0FBRUQsUUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxrQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7O0FBRTNDLE1BQUksTUFBTSxDQUFDLGFBQWEsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFO0FBQzdDLEtBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUN4QyxRQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRTtBQUNsQixPQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDeEI7QUFDRCxRQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFO0FBQy9DLGVBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEI7R0FDRjs7QUFFRCxNQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTlCLE1BQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTFCLE1BQUksTUFBTSxDQUFDLFVBQVUsRUFBRTtBQUNyQixlQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7QUFHekIsYUFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLFVBQVUsR0FBRyxFQUFFO0FBQ3ZDLG9CQUFjLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7S0FDcEQsRUFBRSxZQUFZOztLQUVkLENBQUMsQ0FBQztHQUNKOztBQUVELE1BQUksTUFBTSxDQUFDLFVBQVUsRUFBRTtBQUNyQixRQUFJLENBQUMsaUJBQWlCLENBQUM7QUFDckIsaUJBQVcsRUFBRSxNQUFNLENBQUMsV0FBVztBQUMvQixXQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUs7QUFDbkIsV0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLO0FBQ25CLHFCQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7QUFDdkMscUJBQWUsRUFBRSxNQUFNLENBQUMsaUJBQWlCO0FBQ3pDLGlCQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7QUFDL0IsYUFBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO0FBQ3ZCLFNBQUcsRUFBRSxNQUFNLENBQUMsR0FBRztBQUNmLG1CQUFhLEVBQUUsTUFBTSxDQUFDLGFBQWE7S0FDcEMsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsTUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO0FBQ2hCLFFBQUksQ0FBQyxjQUFjLENBQUM7QUFDbEIsYUFBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO0FBQ3ZCLGdCQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7QUFDN0IsZUFBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO0FBQzNCLGlCQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7S0FDaEMsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsTUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0RyxNQUFJLE1BQU0sQ0FBQywyQkFBMkIsRUFBRTtBQUN0QyxRQUFJLENBQUMsd0JBQXdCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0dBQy9FOztBQUVELE1BQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQzNCLHFCQUFpQixDQUFDLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0dBQ3RFOzs7QUFHRCxNQUFJLENBQUMsUUFBUSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7OztBQUdyQyxNQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDL0QsTUFBSSxRQUFRLEVBQUU7QUFDWixRQUFJLENBQUMsMkJBQTJCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQ3BEOztBQUVELE1BQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUMzRCxNQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO0FBQ25DLE9BQUcsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFXO0FBQ2pELFVBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNqQixZQUFJLE1BQU0sQ0FBQztBQUNYLFlBQUksZUFBZSxHQUFHLEtBQUssQ0FBQzs7QUFFNUIsWUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQztBQUNsRCxZQUFJO0FBQ0YsZ0JBQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ3JDLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDWix5QkFBZSxHQUFHLElBQUksQ0FBQztBQUN2QixnQkFBTSxHQUFHLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxDQUFDO1NBQ3ZCO0FBQ0QsWUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtBQUMxQixvQkFBVSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLHNCQUFzQixFQUFFO0FBQ3JFLHdCQUFZLEVBQUUsQ0FBQyxlQUFlO0FBQzlCLHNCQUFVLEVBQUUsVUFBVTtXQUN2QixDQUFDLENBQUM7QUFDSCxjQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNuRDtBQUNELFlBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO09BQ3pCLE1BQU07QUFDTCxZQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQ2xFO0tBQ0YsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0dBQ1g7O0FBRUQsTUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6RCxNQUFJLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtBQUM1QyxjQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7R0FDbkM7O0FBRUQsTUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFbkMsTUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFO0FBQ2pDLFFBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDdkQsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUMzRDs7QUFFRCxNQUFJLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRTtBQUNsQyxVQUFNLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZO0FBQ2hELFVBQUksZUFBZSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUMvQyxVQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDOUQsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0dBQ1g7Ozs7QUFJRCxNQUFHLE1BQU0sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLGNBQWMsRUFBRTtBQUN4QyxRQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDcEIsUUFBSSxNQUFNLEdBQUcsU0FBVCxNQUFNLEdBQWM7QUFDdEIsVUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzVELFVBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7QUFDL0IsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQztBQUNqQyxVQUFJLFlBQVksR0FBRyxxQ0FBcUMsQ0FBQztBQUN6RCxVQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxZQUFZLEVBQUUsTUFBTSxHQUFHLFlBQVksQ0FBQyxDQUFDO0FBQ2xFLFVBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDbkQsU0FBRyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLFVBQVUsQ0FBQztBQUMzQyxTQUFHLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsUUFBUSxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7QUFDeEQsU0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxBQUFDLFlBQVksR0FBRyxLQUFLLEdBQUksSUFBSSxDQUFDO0FBQ3hELFNBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUM1QixZQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDeEIsWUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsWUFBWSxHQUFHLElBQUksQ0FBQzs7QUFFNUMsVUFBRyxDQUFDLE9BQU8sRUFBRTtBQUNYLGVBQU8sR0FBRyxJQUFJLENBQUM7QUFDZixjQUFNLEVBQUUsQ0FBQztPQUNWO0tBQ0YsQ0FBQzs7QUFFRixRQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM3QyxnQkFBWSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztHQUN0RTs7QUFFRCxNQUFJLGtCQUFrQixHQUFHLFNBQXJCLGtCQUFrQixHQUFjO0FBQ2xDLFVBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQ3ZCLENBQUM7QUFDRixRQUFNLENBQUMsZ0JBQWdCLENBQUMsbUJBQW1CLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztBQUNqRSxvQkFBa0IsRUFBRSxDQUFDOztBQUVyQixNQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7QUFDcEIsVUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO0dBQ3BCOztBQUVELE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbEQsTUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNwRCxNQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFO0FBQzdCLFFBQUksZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDbkYsS0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0dBQ3JDO0FBQ0QsTUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRTtBQUM5QixRQUFJLGlCQUFpQixHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3JGLEtBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUN0QyxLQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7R0FDdEI7O0FBRUQsTUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDdEMsUUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN4RCxRQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbEIsZ0JBQVUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNoQyxPQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUMvQjs7QUFFRCxRQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUUvQyxRQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQSxZQUFZO0FBQ3BFLFVBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNuRCxDQUFBLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7R0FDZjs7QUFFRCxNQUFJLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDL0QsTUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRTtBQUMxQixpQkFBYSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztBQUM5RSxRQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzFELGVBQVcsQ0FBQyxTQUFTLElBQUksZUFBZSxDQUFDO0dBQzFDLE1BQU07QUFDTCxRQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDakUsV0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0dBQ2hDOztBQUVELE1BQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNqQixRQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQzlCOztBQUVELE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxFQUFFO0FBQ3pCLFFBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUNsQyxNQUFNOzs7QUFHTCxRQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7R0FDakI7O0FBRUQsTUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ3JFLE1BQUksWUFBWSxFQUFFO0FBQ2hCLE9BQUcsQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLEVBQ1osQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQzs7OztBQUl2RSxZQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFDVCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3pFLFFBQUkscUJBQXFCLEdBQUcsR0FBRyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzdELFFBQUkscUJBQXFCLEVBQUU7QUFDekIsY0FBUSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFDckIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUMxRTtHQUNGOztBQUVELFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7O0FBRS9ELE1BQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUdqQixNQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQzs7O0FBRzVCLE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxFQUFFO0FBQ3pCLFdBQU8sQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVc7QUFDL0QsVUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7S0FDekIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDOztBQUVWLFFBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsRUFBRTtBQUN2QyxVQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdEM7R0FDRjs7O0FBR0QsTUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3ZFLE1BQUksaUJBQWlCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3ZFLE1BQUksaUJBQWlCLEVBQUU7QUFDckIsT0FBRyxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLENBQUMsWUFBVztBQUNwRCxVQUFJLENBQUMsU0FBUyxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUMsWUFBVztBQUM1RSxZQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDaEMsQ0FBQSxDQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ2hCLENBQUEsQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUNoQjs7O0FBR0QsTUFBSSxjQUFjLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ2hFLE1BQUksY0FBYyxFQUFFO0FBQ2xCLE9BQUcsQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxZQUFXO0FBQ2pELFVBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUMsVUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBQ2xDLGNBQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtBQUNuQixrQkFBVSxFQUFFLE9BQU87QUFDbkIsMEJBQWtCLEVBQUUsY0FBYztBQUNsQyxVQUFFLEVBQUUsbUJBQW1CO09BQ3hCLENBQUMsQ0FBQztBQUNILFdBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxjQUFjLEVBQUU7QUFDL0MseUJBQWlCLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDO09BQzdELENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFYixZQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDZixDQUFBLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7R0FDaEI7O0FBRUQsTUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksT0FBTyxDQUFDLGNBQWMsRUFBRTtBQUNuRCxXQUFPLENBQUMsY0FBYyxDQUFDLGlDQUFpQyxDQUFDLENBQUEsWUFBWTtBQUNuRSxVQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDM0Msa0JBQVUsRUFBRSxTQUFTO0FBQ3JCLGdCQUFRLEVBQUUsR0FBRyxDQUFDLHFCQUFxQixFQUFFO0FBQ3JDLGtCQUFVLEVBQUUsR0FBRyxDQUFDLE1BQU0sRUFBRTtBQUN4QixtQkFBVyxFQUFFLEdBQUcsQ0FBQyxRQUFRLEVBQUU7QUFDM0IsaUJBQVMsRUFBRSxJQUFJO0FBQ2YsZ0JBQVEsRUFBRSxvQkFBWTtBQUNwQixpQkFBTyxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNyQztPQUNGLENBQUMsQ0FBQzs7OztBQUlILGFBQU8sSUFBSSxDQUFDO0tBQ2IsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0dBQ2Y7O0FBRUQsTUFBSSxNQUFNLENBQUMsYUFBYSxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7QUFDN0MsUUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7R0FDN0I7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLFlBQVc7QUFDcEQsTUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqRCxjQUFZLENBQUMsRUFBRSxHQUFHLHdCQUF3QixDQUFDO0FBQzNDLE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUMvRCxNQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRTtBQUNsQixLQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0dBQzdDO0FBQ0QsR0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTNDLE1BQUksZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyRCxrQkFBZ0IsQ0FBQyxFQUFFLEdBQUcsa0JBQWtCLENBQUM7QUFDekMsR0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3pDLEdBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7QUFFdEMsTUFBSSxDQUFDLGtCQUFrQixDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDMUMsTUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFOztBQUVoQixLQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0dBQ3pDO0FBQ0QsTUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7Q0FDekIsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFlBQVc7QUFDaEQsTUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ3JFLE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUMvRCxNQUFJLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNuRSxNQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7OztBQUd2QyxNQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRTtBQUNsQixRQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ2xFLFFBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbkUsS0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZDLEtBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN6QyxLQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0dBQ2pDOztBQUVELE1BQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQzdDLE1BQUksS0FBSyxHQUFHLFVBQVUsR0FBRyxRQUFRLENBQUM7QUFDbEMsc0JBQW9CLENBQUMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQy9DLHFCQUFtQixDQUFDLFlBQVksRUFBRSxRQUFRLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQzNELENBQUM7O0FBRUYsU0FBUyxDQUFDLFNBQVMsQ0FBQywyQkFBMkIsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUNuRSxNQUFJLFFBQVEsRUFBRTtBQUNaLFNBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQywrQkFBK0IsRUFBRTtBQUMxRCxVQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLCtCQUErQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVELFVBQUksZ0JBQWdCLEdBQUcscURBQXFELEdBQUcsS0FBSyxHQUFHLHNDQUFzQyxDQUFDO0FBQzlILFVBQUksRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQy9DLGNBQVEsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0tBQ25EO0dBQ0Y7O0FBRUQsU0FBTyxRQUFRLENBQUM7Q0FDakIsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFZO0FBQ3hDLE1BQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2xCLFVBQU0sNkJBQTZCLENBQUM7R0FDckM7QUFDRCxNQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDbkIsV0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0dBQzFCLE1BQU07QUFDTCxXQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7R0FDL0I7Q0FDRixDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDckQsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQzlCLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBQ3hDLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUM5QixNQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7Q0FDdkMsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsVUFBVSxNQUFNLEVBQUU7QUFDeEQsTUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDekIsUUFBSSxPQUFPLENBQUMsY0FBYyxFQUFFO0FBQzFCLGFBQU8sQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLENBQUM7S0FDckM7QUFDRCxXQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQy9CLFFBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3BDLFFBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsRUFBRTtBQUN2QyxVQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdEM7R0FDRixNQUFNO0FBQ0wsUUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFFBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUU7O0FBRTVCLGdCQUFVLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM5RDs7Ozs7O0FBTUQsUUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN2QixRQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUNsQztBQUNELE1BQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQzNCLFVBQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0dBQzNCO0NBQ0YsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFlBQVk7QUFDL0MsU0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0NBQzNCLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsVUFBVSxPQUFPLEVBQUU7O0FBRXRELE1BQUksa0JBQWtCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ3ZFLE1BQUksR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFO0FBQ2xCLFFBQUksVUFBVSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDeEQsUUFBSSxVQUFVLEVBQUU7QUFDZCxnQkFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0tBQ25DO0FBQ0QsUUFBSSxrQkFBa0IsRUFBRTtBQUN0QixVQUFJLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzdELHdCQUFrQixDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQzFDLG1CQUFhLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7S0FDMUM7R0FDRjs7O0FBR0QsTUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQyxNQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUU7QUFDdkIsVUFBTSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUM3RCxVQUFJLEVBQUU7QUFDSixlQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87QUFDeEIsa0JBQVUsRUFBRSxPQUFPLENBQUMsVUFBVTtBQUM5QixpQkFBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTO09BQzdCO0tBQ0YsQ0FBQyxDQUFDO0FBQ0gsUUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2xCLFlBQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztLQUNsQztBQUNELHNCQUFrQixDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUN4QyxNQUFNLElBQUksT0FBTyxPQUFPLENBQUMsV0FBVyxLQUFLLFdBQVcsRUFBRTtBQUNyRCxVQUFNLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBQ3ZELGNBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtLQUN4QixDQUFDLENBQUM7QUFDSCxzQkFBa0IsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7R0FDeEM7Q0FDRixDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEdBQUcsVUFBUyxTQUFTLEVBQUU7QUFDM0QsTUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM5QyxXQUFTLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMxQyxXQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUVqQyxNQUFJLFVBQVUsR0FBRztBQUNmLGdCQUFZLEVBQUUsRUFBRTtBQUNoQixtQkFBZSxFQUFFLEtBQUs7QUFDdEIsb0JBQWdCLEVBQUUsZ0JBQWdCO0FBQ2xDLHNCQUFrQixFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQztBQUMxRSxhQUFTLEVBQUU7QUFDVCxpQkFBVyxFQUFFLENBQUM7QUFDZCxXQUFLLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxFQUFFO0tBQ25DO0FBQ0QsYUFBUyxFQUFFLE1BQU07QUFDakIsYUFBUyxFQUFFLENBQ1Q7QUFDRSxVQUFJLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHlCQUF5QixDQUFDO0FBQ3hELFVBQUksRUFBRSx3QkFBd0I7QUFDOUIsZUFBUyxFQUFFLElBQUk7S0FDaEIsRUFDRDtBQUNFLFVBQUksRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUM7QUFDcEQsVUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsT0FBTztBQUM3QixlQUFTLEVBQUUsS0FBSztLQUNqQixFQUNEO0FBQ0UsVUFBSSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQztBQUNqRCxVQUFJLEVBQUUsR0FBRztBQUNULGVBQVMsRUFBRSxJQUFJO0tBQ2hCLEVBQ0Q7QUFDRSxVQUFJLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUMzQyxVQUFJLEVBQUUsc0JBQXNCO0FBQzVCLGVBQVMsRUFBRSxJQUFJO0tBQ2hCLEVBQ0Q7QUFDRSxVQUFJLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO0FBQy9DLFVBQUksRUFBRSwwQkFBMEI7QUFDaEMsZUFBUyxFQUFFLElBQUk7S0FDaEIsQ0FDRjtBQUNELGVBQVcsRUFBRSxJQUFJO0dBQ2xCLENBQUM7O0FBRUYsT0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxFQUN4RSxTQUFTLENBQUMsQ0FBQztDQUNkLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDOUMsTUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMvQixVQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxHQUNyRCx3QkFBd0IsQ0FBQyxDQUFDO0dBQzdCO0FBQ0QsU0FBTyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztDQUM3QixDQUFDOzs7Ozs7OztBQVFGLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFVBQVUsMEJBQTBCLEVBQUU7OztDQUdqRSxDQUFDOzs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFlBQVcsRUFBRSxDQUFDOzs7Ozs7QUFNbkQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDcEQsTUFBSSxPQUFPLEdBQUksTUFBTSxLQUFLLEtBQUssQUFBQyxDQUFDO0FBQ2pDLE1BQUksTUFBTSxLQUFLLEtBQUssSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFFO0FBQzFDLFVBQU0sa0JBQWtCLENBQUM7R0FDMUI7O0FBRUQsTUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUMvQyxNQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ25ELEtBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sR0FBRyxjQUFjLEdBQUcsTUFBTSxDQUFDO0FBQ3RELEtBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUM7QUFDeEIsT0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxPQUFPLEdBQUcsY0FBYyxHQUFHLE1BQU0sQ0FBQztBQUN6RCxPQUFLLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQzs7O0FBR3pCLEdBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ3ZDLENBQUM7Ozs7Ozs7O0FBUUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBUyxXQUFXLEVBQUU7QUFDeEQsTUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbkIsV0FBTztHQUNSOztBQUVELE1BQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ3RDLENBQUM7Ozs7Ozs7OztBQVNGLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVMsU0FBUyxFQUFFLElBQUksRUFBRTtBQUN4RCxNQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtBQUNuQixXQUFPO0dBQ1I7O0FBRUQsTUFBSSxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDMUQsQ0FBQzs7Ozs7Ozs7O0FBU0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3RELE1BQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ25CLFdBQU87R0FDUjs7QUFFRCxTQUFPLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztBQUN4QixNQUFJLGNBQWMsR0FBRyxFQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUMsQ0FBQztBQUNuQyxNQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN2RCxNQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7Q0FDdkMsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFTLElBQUksRUFBRTtBQUNwRCxNQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtBQUNuQixXQUFPO0dBQ1I7O0FBRUQsTUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUN2QyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWNGLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsR0FBRyxFQUFFLE9BQU8sRUFBRTtBQUNsRCxNQUFJLFFBQVEsR0FBRztBQUNiLFlBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtBQUN2QixPQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNqQixXQUFPLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUM7QUFDM0MsWUFBUSxFQUFFLElBQUk7QUFDZCxzQkFBa0IsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUNuRSxJQUFJLENBQUMsTUFBTSxDQUFDO0dBQ2pCLENBQUM7QUFDRixTQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDdEUsQ0FBQzs7Ozs7QUFLRixTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxZQUFXO0FBQ3JDLE1BQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxNQUFJLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO0FBQzlCLFFBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pELFdBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLEVBQUUsS0FBSyxLQUFLLENBQUU7R0FDN0MsTUFBTTtBQUNMLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Q0FDRixDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFlBQVc7QUFDL0MsU0FBUSxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBRTtDQUN2QyxDQUFDOzs7Ozs7O0FBT0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDbkQsU0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxFQUFFO0FBQ3ZELFlBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtBQUN2QixZQUFRLEVBQUUsSUFBSTtBQUNkLE9BQUcsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ2pCLGNBQVUsRUFBRSxLQUFLO0dBQ2xCLENBQUMsQ0FBQztBQUNILE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ2pDLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVMsU0FBUyxFQUFFO0FBQ25ELE1BQUksR0FBRyxHQUFHLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNyQyxTQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0NBQzFELENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEdBQUcsVUFBUyxXQUFXLEVBQUUsV0FBVyxFQUFFOztBQUU1RSxNQUFJLElBQUksRUFBRSxRQUFRLENBQUM7O0FBRW5CLE1BQUksR0FBRyxHQUFHLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFdkMsTUFBSSxhQUFhLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7QUFDekMsYUFBVyxHQUFHLFdBQVcsSUFBSSxFQUFFLENBQUM7O0FBRWhDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzdDLFlBQVEsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7OztBQUc1QixRQUFJLFFBQVEsQ0FBQyxRQUFRLEtBQUssQ0FBQyxFQUFFOztBQUUzQixVQUFJLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNyQyxVQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNyQixZQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3RELGtCQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7QUFDRCxZQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3RELGtCQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7T0FDRjtLQUNGO0dBQ0Y7QUFDRCxTQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ25DLENBQUM7O0FBRUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUN4RCxTQUFPLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDNUQsU0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ2xELENBQUM7Ozs7Ozs7O0FBUUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRyxVQUFVLE1BQU0sRUFBRTtBQUMvRCxNQUFJLENBQUMsd0JBQXdCLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDaEUsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFVBQVUsUUFBUSxFQUFFO0FBQ3pELE1BQUksQ0FBQyx3QkFBd0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDckQsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVMsS0FBSyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUU7QUFDNUUsTUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNwRCxNQUFJLGdCQUFnQixDQUFDO0FBQ3JCLE1BQUksYUFBYSxDQUFDOztBQUVsQixNQUFJLFdBQVcsR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDO0FBQ2hDLGVBQVcsRUFBRSxLQUFLLENBQUMsV0FBVztBQUM5QixpQkFBYSxFQUFFLEtBQUssQ0FBQyxhQUFhO0dBQ25DLENBQUMsQ0FBQzs7QUFFSCxNQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLGNBQWMsQ0FBQzs7QUFFakcsTUFBSSxZQUFZLEVBQUU7QUFDaEIsUUFBSSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdEYsb0JBQWdCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDOUMsbUJBQWUsQ0FBQyxTQUFTLElBQUksa0NBQWtDLENBQUM7QUFDaEUsaUJBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdDLGlCQUFhLENBQUMsU0FBUyxHQUFHLHlDQUF5QyxDQUFDO0FBQ3BFLGlCQUFhLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQztBQUN0QyxRQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtBQUNkLG1CQUFhLENBQUMsU0FBUyxJQUFJLGdCQUFnQixDQUFDO0tBQzdDO0dBQ0Y7O0FBRUQsTUFBSSxhQUFhLENBQUM7QUFDbEIsTUFBSSxTQUFTLEVBQUU7QUFDYixpQkFBYSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxlQUFlLEVBQUUsQ0FBQztHQUNqRTs7QUFFRCxNQUFJLG1CQUFtQixHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFO0FBQzFELGVBQVcsRUFBRSxXQUFXO0FBQ3hCLGdCQUFZLEVBQUUsSUFBSSxDQUFDLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUM7QUFDbEUsaUJBQWEsRUFBRSxJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQztBQUNwRSxvQkFBZ0IsRUFBRSxnQkFBZ0I7QUFDbEMsMEJBQXNCLEVBQUUsS0FBSyxDQUFDLHNDQUFzQztBQUNwRSxhQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7QUFDMUIsaUJBQWEsRUFBRSxhQUFhO0dBQzdCLENBQUMsQ0FBQzs7Ozs7O0FBTUgsTUFBSSwwQkFBMEIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9ELDRCQUEwQixDQUFDLFNBQVMsR0FBQyx3QkFBd0IsQ0FBQztBQUM5RCxpQkFBZSxDQUFDLFdBQVcsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDOztBQUV4RCxNQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVDLFNBQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFDMUQsUUFBSSxFQUFFO0FBQ0osUUFBRSxFQUFFLElBQUk7S0FDVDtHQUNGLENBQUMsQ0FBQzs7QUFFSCxpQkFBZSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7Ozs7QUFLckMsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLE1BQUksaUJBQWlCLEdBQUcsU0FBUyxDQUFDOztBQUVsQyxNQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRTtBQUMvQixlQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLGVBQVcsQ0FBQyxTQUFTLEdBQUcsaUJBQWlCLENBQUM7R0FDM0M7O0FBRUQsTUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFXOztBQUU3QixRQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRTtBQUMvQixPQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBQyxrQkFBa0IsRUFBQyxxQkFBcUIsRUFBQyxDQUFDLENBQ2pFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FDVixPQUFPLENBQUMsRUFBQyxrQkFBa0IsRUFBQyxlQUFlLEVBQUMsRUFBQyxJQUFJLENBQUMsQ0FBQztLQUN2RDs7QUFFRCxRQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLEVBQUU7QUFDckUsVUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDL0I7Ozs7QUFJRCxRQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzFDLFNBQUssQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xELFlBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDL0IsRUFBRSxJQUFJLENBQUMsQ0FBQzs7QUFFVCxNQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBQy9DLGdCQUFZLEVBQUUsWUFBWTtBQUMxQixjQUFVLEVBQUUsZUFBZTtBQUMzQixRQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7QUFDZixzQkFBa0IsRUFBRSxZQUFZO0FBQ2hDLFlBQVEsRUFBRSxNQUFNO0FBQ2hCLGlCQUFhLEVBQUUsSUFBSTtBQUNuQixzQkFBa0IsRUFBRSx5QkFBeUI7QUFDN0MsVUFBTSxFQUFFLGFBQWE7R0FDdEIsQ0FBQyxDQUFDOzs7O0FBSUgsR0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFLFlBQVk7QUFDN0QsU0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0dBQy9ELENBQUMsQ0FBQzs7QUFFSCxNQUFJLFNBQVMsRUFBRTtBQUNiLGNBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVc7QUFDM0IsVUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxDQUFDO0tBQ2hDLEVBQUUsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDbEI7O0FBRUQsTUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNyRCxNQUFJLFVBQVUsRUFBRTtBQUNkLE9BQUcsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFXO0FBQ25ELFVBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO0FBQzNCLFlBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztPQUNoQztLQUNGLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUNYOztBQUVELE1BQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsRUFBQyxXQUFXLEVBQUUsV0FBVyxFQUFDLENBQUMsQ0FBQzs7QUFFekQsTUFBSSxnQkFBZ0IsRUFBRTs7QUFFcEIsS0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQ3hCOzs7O0FBSUQsTUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMxQyxPQUFLLENBQUMsU0FBUyxDQUFDLG1CQUFtQixFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqRCxVQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQy9CLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUN4QyxNQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBQzs7O0FBRzFFLE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDeEMsUUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUssSUFBSSxDQUFDLGtCQUFrQixLQUFLLGNBQWMsQUFBQyxFQUFFO0FBQzNFLFVBQUksV0FBVyxHQUFHLGNBQWMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUM7QUFDM0QsYUFBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBVSxRQUFRLEVBQUU7QUFDaEUsZ0JBQVEsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQ2pDLENBQUMsQ0FBQztLQUNKO0dBQ0Y7QUFDRCxNQUFJLENBQUMsa0JBQWtCLEdBQUcsY0FBYyxDQUFDOzs7QUFHekMsTUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7OztBQUczQixxQkFBbUIsRUFBRSxDQUFDO0NBQ3ZCLENBQUM7Ozs7OztBQU1GLFNBQVMsa0NBQWtDLEdBQUc7QUFDNUMsTUFBSSx3QkFBd0IsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUNqRCxxREFBcUQsQ0FBQyxDQUFDO0FBQzNELE1BQUksQ0FBQyx3QkFBd0IsRUFBRTtBQUM3QixXQUFPO0dBQ1I7O0FBRUQsTUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ2pFLE1BQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDN0QsTUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN6RCxNQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHVDQUF1QyxDQUFDLENBQUM7O0FBRWxGLE1BQUksR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNaLE1BQUksZUFBZSxFQUFFO0FBQ25CLE9BQUcsSUFBSSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzdDOztBQUVELE1BQUksYUFBYSxFQUFFO0FBQ2pCLE9BQUcsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzNDOztBQUVELE1BQUksV0FBVyxFQUFFO0FBQ2YsT0FBRyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDekM7O0FBRUQsTUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsTUFBSSxXQUFXLEVBQUU7QUFDZixRQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDNUIsVUFBTSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUczQyxVQUFNLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDL0M7O0FBRUQsMEJBQXdCLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2hELDBCQUF3QixDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztDQUN2RDs7Ozs7OztBQU9ELElBQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFZO0FBQy9DLG9DQUFrQyxFQUFFLENBQUM7Q0FDdEMsRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFUCxTQUFTLENBQUMsU0FBUyxDQUFDLHVCQUF1QixHQUFHLFVBQVUsS0FBSyxFQUFFOzs7QUFHN0QsTUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtBQUNqQyxRQUFJLENBQUMsdUJBQXVCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDMUUsWUFBUSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDMUUsUUFBSSxDQUFDLHVCQUF1QixHQUFHLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNsRSxRQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtBQUNoQyxjQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFDNUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7S0FDOUQ7O0FBRUQsU0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0dBQ3hCO0NBQ0YsQ0FBQzs7QUFFRixTQUFTLDZCQUE2QixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUU7QUFDckQsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hELHVCQUFtQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDakQ7Q0FDRjtBQUNELFNBQVMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRTtBQUMzQyxTQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDaEMsU0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBQ2xDLFNBQU8sQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQztDQUN2QztBQUNELFNBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRTtBQUM3QyxTQUFPLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUM7QUFDdkMsU0FBTyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7QUFDekMsU0FBTyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxNQUFNLENBQUM7Q0FDOUM7Ozs7Ozs7QUFPRCxTQUFTLENBQUMsU0FBUyxDQUFDLHVCQUF1QixHQUFHLFVBQVUsS0FBSyxFQUFFO0FBQzdELE1BQUksc0JBQXNCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDOztBQUUvRSxNQUFJLElBQUksR0FBRyxzQkFBc0IsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0FBQzFELE1BQUksTUFBTSxDQUFDO0FBQ1gsTUFBSSxXQUFXLENBQUM7QUFDaEIsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUU7QUFDaEIsVUFBTSxHQUFHLE1BQU0sQ0FBQyxVQUFVLElBQ3ZCLE1BQU0sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBSSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxBQUFDLEdBQ25ELFFBQVEsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDdEUsZUFBVyxHQUFHLEFBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFJLE1BQU0sQ0FBQztHQUMxRCxNQUFNO0FBQ0wsVUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBSSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQUFBQyxHQUN4RCxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3JFLGVBQVcsR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztHQUNwQztBQUNELE1BQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztDQUN2QyxDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDekQsTUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUM3RCxNQUFJLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzdELE1BQUksc0JBQXNCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQy9FLE1BQUksbUJBQW1CLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3pFLE1BQUksbUJBQW1CLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDOztBQUV6RSxNQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUNqRCxNQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFDOUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNwRSxNQUFJLGlCQUFpQixHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDM0MsTUFBSSxrQkFBa0IsR0FBRyxBQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxHQUFJLElBQUksQ0FBQztBQUNwRSxNQUFJLGtCQUFrQixHQUFHLGFBQWEsQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzs7QUFFL0UsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUU7QUFDaEIsMEJBQXNCLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxpQkFBaUIsQ0FBQztBQUN2RCxpQkFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsaUJBQWlCLENBQUM7R0FDL0MsTUFBTTtBQUNMLDBCQUFzQixDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUM7QUFDdEQsaUJBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLGlCQUFpQixDQUFDO0dBQzlDO0FBQ0Qsd0JBQXNCLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxrQkFBa0IsQ0FBQzs7QUFFN0QscUJBQW1CLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxBQUFDLFdBQVcsR0FBRyxrQkFBa0IsR0FBSSxJQUFJLENBQUM7QUFDL0UsZUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsaUJBQWlCLENBQUM7QUFDakQsZUFBYSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLENBQUM7Ozs7QUFJbkQsTUFBSSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxFQUFFO0FBQ3BDLGlCQUFhLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQztBQUNoRCxpQkFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsaUJBQWlCLENBQUM7R0FDL0M7QUFDRCxNQUFJLEtBQUssR0FBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQUFBQyxDQUFDOztBQUVoRCwrQkFBNkIsQ0FBQyxhQUFhLEVBQUUsUUFBUSxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNyRSxNQUFJLG1CQUFtQixFQUFFO0FBQ3ZCLHVCQUFtQixDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsaUJBQWlCLENBQUM7R0FDMUQ7O0FBRUQsTUFBSSxXQUFXLEdBQUcsR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUU7QUFDM0MsS0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0dBQ3hELE1BQU0sSUFBSSxXQUFXLEdBQUcsR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUU7QUFDbEQsS0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0dBQ3JEOztBQUVELE1BQUksV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsdUNBQXVDLENBQUMsQ0FBQztBQUNsRixNQUFJLFdBQVcsRUFBRTtBQUNmLGVBQVcsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLGlCQUFpQixDQUFDOzs7O0FBSS9DLFFBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN6RCxRQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3BELFFBQUksZ0JBQWdCLElBQUksVUFBVSxDQUFDLFNBQVMsS0FBSyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUU7QUFDM0UsZ0JBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQztLQUNsQyxNQUFNO0FBQ0wsZ0JBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztLQUNqQztHQUNGOzs7QUFHRCxPQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7Q0FDekIsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLHFCQUFxQixHQUFHLFVBQVUsS0FBSyxFQUFFOztBQUUzRCxNQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtBQUNoQyxZQUFRLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUM3RSxRQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtBQUNoQyxjQUFRLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFDNUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7S0FDakU7QUFDRCxRQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDO0dBQ3JDO0NBQ0YsQ0FBQzs7Ozs7O0FBT0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsR0FBRyxZQUFXO0FBQ25ELE1BQUksWUFBWSxHQUFHLENBQUMsQ0FBQztBQUNyQixNQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRTs7QUFFOUQsUUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBQ3BFLGdCQUFZLEdBQUcsVUFBVSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxDQUFDO0dBQ3pELE1BQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDaEMsZ0JBQVksR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsZUFBZSxFQUFFLENBQUM7R0FDL0Q7QUFDRCxVQUFRLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDO0NBQzdFLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEVBQUUsRUFBRSxTQUFTLEVBQUU7QUFDdEQsTUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDekIsUUFBSSxFQUFFLEVBQUU7QUFDTixVQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDckMsVUFBSSxDQUFDLEVBQUU7QUFDTCxVQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ1g7S0FDRjs7QUFFRCxXQUFPLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDdEQ7Q0FDRixDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsWUFBWTtBQUNsRCxNQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRTtBQUN6QixRQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQ3RCLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7O0FBRXZDLFdBQU8sQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0dBQ3hEO0NBQ0YsQ0FBQzs7Ozs7Ozs7QUFRRixTQUFTLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUN0RCxTQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDN0IsU0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQ3JDLFNBQU8sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7QUFDdkQsU0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7QUFHdkMsTUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtBQUM3QixXQUFPLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO0dBQ3JEOztBQUVELE1BQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsZUFBZSxFQUN4RCxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUN0RCxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQztDQUN2QyxDQUFDOzs7Ozs7OztBQVFGLFNBQVMsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFVBQVMsYUFBYSxFQUFFLE9BQU8sRUFBRTtBQUNwRSxTQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFDOUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ3hGLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxpQkFBaUIsRUFBRTtBQUM3RCxNQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25ELGdCQUFjLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQyxFQUFFLENBQUM7QUFDckUsTUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBQ2xDLGNBQVUsRUFBRSxjQUFjO0FBQzFCLFFBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtHQUNoQixDQUFDLENBQUM7QUFDSCxNQUFJLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUN2RSxLQUFHLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsWUFBVztBQUNuRCxRQUFJLFlBQVksR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFDLENBQUMsS0FBSyxDQUFDO0FBQy9FLFFBQUksSUFBSSxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDckUsUUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDeEQscUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUM3QixvQkFBYyxFQUFFLFlBQVk7QUFDNUIsWUFBTSxFQUFFLElBQUk7S0FDYixFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7R0FDWixDQUFDLENBQUM7O0FBRUgsUUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0NBQ3JDLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FBY0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBUyxPQUFPLEVBQUU7O0FBRTdDLE1BQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRTtBQUNqQyxRQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQy9ELFFBQUksRUFBRyxBQUFDLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUksSUFBSSxDQUFDLFFBQVEsQUFBQztBQUM5QyxXQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVE7QUFDdEIsU0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUU7R0FDekMsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxjQUFjLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQzs7Ozs7O0FBT3pDLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFBLEFBQUMsRUFBRTtBQUNwQyxRQUFJLGlCQUFpQixHQUFHLENBQUMsWUFBVztBQUNsQyxhQUFPLFVBQVMsY0FBYyxFQUFFO0FBQzlCLGFBQUssSUFBSSxNQUFNLElBQUksY0FBYyxFQUFFO0FBQ2pDLGdCQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3pDO0FBQ0QsWUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUN4QixDQUFDO0tBQ0gsQ0FBQSxFQUFHLENBQUM7Ozs7QUFJTCxRQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7QUFDbkIsVUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3RDLE1BQU07QUFDTCx1QkFBaUIsRUFBRSxDQUFDO0tBQ3JCO0dBQ0Y7Q0FDRixDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBVztBQUNoRCxNQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdEIsTUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQixNQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztBQUN6QixNQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRTtBQUN6QixXQUFPLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEQsV0FBTyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDdkM7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQ25CLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxZQUFXOzs7QUFHaEQsTUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNuRCxNQUFJLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxFQUFFO0FBQ2pFLFdBQU8sQ0FBQyxTQUFTLEdBQUcsd0JBQXdCLENBQUM7R0FDOUMsTUFBTTtBQUNMLFdBQU8sQ0FBQyxTQUFTLEdBQUcsdUJBQXVCLENBQUM7R0FDN0M7OztBQUdELE1BQUksT0FBTyxFQUFFO0FBQ1gsV0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDdkIsV0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQzVDO0NBQ0YsQ0FBQzs7Ozs7QUFLRixTQUFTLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLFlBQVc7QUFDcEQsTUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQzFELE1BQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixXQUFPO0dBQ1I7O0FBRUQsTUFBSSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsZUFBZSxLQUFLLFFBQVEsR0FDekQsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7QUFDeEMsU0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDdkIsU0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUN6QyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7Q0FDekIsQ0FBQzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLDJCQUEyQixHQUFHLFVBQVUsUUFBUSxFQUFFLE1BQU0sRUFBRTtBQUM1RSxNQUFJLFdBQVcsQ0FBQztBQUNoQixNQUFJLFlBQVksQ0FBQztBQUNqQixNQUFJLFFBQVEsQ0FBQztBQUNiLE1BQUksSUFBSSxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUU7QUFDaEMsUUFBSSx5QkFBeUIsR0FDM0IsTUFBTSxDQUFDLHlCQUF5QixJQUFJLHFDQUFxQyxDQUFDOztBQUU1RSxlQUFXLEdBQUcsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbkUsUUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLFdBQVcsR0FBRyxlQUFlLEVBQUU7QUFDbkQsa0JBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2xFO0FBQ0QsWUFBUSxHQUFHLHlCQUF5QixDQUFDO0dBQ3RDLE1BQU07O0FBRUwsZUFBVyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ25FLFlBQVEsR0FBRyxTQUFTLENBQUM7R0FDdEI7QUFDRCxNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztBQUM3QyxNQUFJLEtBQUssR0FBRyxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLE1BQUksT0FBTyxHQUFHLENBQUMsUUFBUSxHQUFHLEtBQUssRUFDN0IsWUFBWSxFQUNaLGdCQUFnQixHQUFHLEtBQUssRUFDeEIsZ0JBQWdCLEdBQUcsS0FBSyxFQUN4QixnQkFBZ0IsR0FBRyxLQUFLLEVBQ3hCLDhCQUE4QixFQUM5QixrQkFBa0IsQ0FBQyxDQUFDO0FBQ3RCLFVBQVEsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUN0RCxDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsVUFBVSxNQUFNLEVBQUU7QUFDdkQsTUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQzFCLE1BQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNoRixNQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7OztBQUdoRixNQUFJLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDO0FBQ3BELE1BQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUN0QyxNQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7Ozs7QUFJbEMsTUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQ2xDLFVBQU0sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUM7R0FDM0U7O0FBRUQsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDO0FBQ3RELE1BQUksQ0FBQyxvQkFBb0IsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQixJQUFJLEdBQUcsQ0FBQztBQUNuRSxNQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxJQUFJLEVBQUUsQ0FBQztBQUN6RCxNQUFJLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsSUFBSSxFQUFFLENBQUM7QUFDL0QsTUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUM7QUFDL0UsTUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxJQUFJLEdBQUcsQ0FBQztBQUNuRCxNQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDOzs7QUFHMUUsTUFBSSxDQUFDLGNBQWMsR0FBSSxNQUFNLENBQUMsY0FBYyxLQUFLLEtBQUssQUFBQyxDQUFDO0FBQ3hELE1BQUksQ0FBQyxvQkFBb0IsR0FBSSxNQUFNLENBQUMsb0JBQW9CLEtBQUssS0FBSyxBQUFDLENBQUM7Ozs7QUFJcEUsTUFBSSxNQUFNLENBQUMsS0FBSyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUEsQUFBQyxFQUFFO0FBQ3pGLFFBQUksQ0FBQyxvQkFBb0IsR0FBRyxLQUFLLENBQUM7R0FDbkMsTUFBTTtBQUNMLFFBQUksQ0FBQyxvQkFBb0IsR0FBRyxNQUFNLENBQUMsb0JBQW9CLEtBQUssS0FBSyxDQUFDO0dBQ25FOzs7QUFHRCxNQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLElBQUksWUFBWSxFQUFFLENBQUM7QUFDcEQsTUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ3RELE1BQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLFlBQVksR0FDakIsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUM7QUFDeEUsTUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQzlELE1BQUksQ0FBQyxtQkFBbUIsR0FBRyxNQUFNLENBQUMsbUJBQW1CLElBQUksWUFBWSxFQUFFLENBQUM7QUFDeEUsTUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQy9FLE1BQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQztDQUM3QyxDQUFDOzs7QUFHRixTQUFTLENBQUMsU0FBUyxDQUFDLHFCQUFxQixHQUFHLFVBQVUsUUFBUSxFQUFFO0FBQzlELE1BQUksTUFBTSxDQUFDLENBQUMsRUFBRTtBQUNaLEtBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN4QyxLQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FDckM7QUFDRCxVQUFRLEVBQUUsQ0FBQztDQUNaLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFVBQVUsTUFBTSxFQUFFO0FBQ25ELE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzVELE1BQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO0FBQ3hCLFlBQVEsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztHQUNwRTtBQUNELE1BQUksYUFBYSxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7QUFFOUQsTUFBSSxTQUFTLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN0RCxNQUFJLFdBQVcsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzFELE1BQUksUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzlDLE1BQUksaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDL0YsS0FBRyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDbkUsS0FBRyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7QUFHekUsTUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzdELE1BQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM5RCxNQUFJLGFBQWEsRUFBRTtBQUNqQixZQUFRLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0dBQ3JDOztBQUVELE1BQUksbUJBQW1CLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3pFLE1BQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7O0FBRTdELE1BQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7QUFDdEMsUUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO0FBQzFDLFFBQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFOztBQUVyRCxPQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUVsQyxlQUFTLEdBQUcsSUFBSSxDQUFDOztBQUVqQixVQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLGdCQUFnQixFQUFFO0FBQ2hELFlBQUksQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLENBQUM7QUFDbkMsY0FBTSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsUUFBUSxFQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7T0FDcEQ7O0FBRUQsWUFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUM7QUFDekMsWUFBTSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLENBQUM7S0FDN0M7O0FBRUQsUUFBSSxNQUFNLENBQUMsb0JBQW9CLEVBQUU7QUFDL0IsVUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztBQUNoQyxpQkFBVyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ3RDLGlCQUFXLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDO0FBQzlELGVBQVMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7QUFDMUQseUJBQW1CLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7QUFDOUUsbUJBQWEsQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7QUFDbEUsVUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2pCLFlBQUksV0FBVyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDekQsbUJBQVcsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7T0FDL0Q7S0FDRixNQUFNO0FBQ0wseUJBQW1CLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ3ZELGVBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUM7S0FDOUM7R0FDRjs7QUFFRCxNQUFJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTtBQUM1QixLQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0dBQ3ZDOzs7O0FBSUQsTUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUM1RCxhQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEdBQUcsaUJBQWlCLENBQUM7QUFDOUQsdUJBQW1CLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQztHQUNuRjs7QUFFRCxNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7O0FBRXZDLGlCQUFhLENBQUMsU0FBUyxJQUFJLGFBQWEsQ0FBQztBQUN6Qyx1QkFBbUIsQ0FBQyxTQUFTLElBQUksYUFBYSxDQUFDO0FBQy9DLFFBQUksV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsdUNBQXVDLENBQUMsQ0FBQztBQUNsRixRQUFJLFdBQVcsRUFBRTtBQUNmLGlCQUFXLENBQUMsU0FBUyxJQUFJLGFBQWEsQ0FBQztLQUN4QztHQUNGO0NBQ0YsQ0FBQzs7Ozs7QUFLRixTQUFTLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVUsT0FBTyxFQUFFO0FBQ3pELE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdELE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLE1BQUksWUFBWSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDNUQsTUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsRUFBRTtBQUN6RCxhQUFTLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztHQUNyQztBQUNELGNBQVksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUNwQyxVQUFRLENBQUMsY0FBYyxDQUFDLHdCQUF3QixDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7OztBQUd6RSxNQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDZCxRQUFJLE9BQU8sQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUNoRCxjQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDOztBQUVoRCxPQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUM1QixVQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDL0QsVUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssT0FBTyxDQUFDLGFBQWEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQSxBQUFDLEVBQUU7QUFDOUQsU0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO09BQzFDLE1BQU07QUFDTCxTQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUM7O0FBRXhDLFlBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEMsZ0JBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQy9CLGFBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsRUFBRTtBQUNyRCxtQkFBUyxFQUFFLFNBQVMsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO0FBQzNDLGlCQUFPLEVBQUUsU0FBUyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRTtTQUM5QyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7T0FDVjs7QUFFRCxVQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtBQUNsQixZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3JELFlBQUksU0FBUyxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUM7QUFDeEMsWUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNyRCxxQkFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztBQUNuRCxxQkFBYSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0FBRXhFLFdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLEVBQUUsWUFBWTs7O0FBR2hELGNBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDcEMsb0JBQVEsQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDO1dBQzFCLE1BQU07QUFDTCxvQkFBUSxDQUFDLElBQUksSUFBSSxPQUFPLENBQUM7V0FDMUI7U0FDRixDQUFDLENBQUM7O0FBRUgsaUJBQVMsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7T0FDdEM7S0FDRjtHQUNGO0NBQ0YsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxVQUFVLE1BQU0sRUFBRTs7QUFFdEQsTUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFOztBQUVuQixRQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7QUFDdEIsWUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3RCO0FBQ0QsV0FBTztHQUNSOztBQUVELE1BQUksY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQzs7Ozs7O0FBTTVFLEtBQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDOzs7QUFHakIsTUFBSSxrQkFBa0IsR0FBRyxZQUFZLENBQUMsc0JBQXNCLENBQzFELE1BQU0sQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUNwRCxNQUFJLENBQUMsTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQ3ZFLFFBQUksRUFBRSxZQUFZO0FBQ2xCLGVBQVcsRUFBRSxZQUFZLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDO0FBQzVELFdBQU8sRUFBRSxrQkFBa0I7QUFDM0IseUJBQXFCLEVBQUUsSUFBSTtBQUMzQix5QkFBcUIsRUFBRSxNQUFNLENBQUMscUJBQXFCO0FBQ25ELHVCQUFtQixFQUFFLEtBQUs7QUFDMUIsMEJBQXNCLEVBQUUsTUFBTSxDQUFDLHNCQUFzQjtBQUNyRCx3QkFBb0IsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUI7QUFDL0MsbUJBQWUsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWU7R0FDOUMsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDOzs7QUFHaEQsU0FBTyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUU3RSxNQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUN0QyxXQUFTLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDOzs7QUFHekQsTUFBSSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxZQUFZLENBQUM7QUFDdkUsY0FBWSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBUyxNQUFNLEVBQUU7O0FBRXRELFVBQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkIsVUFBTSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxRQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsSUFDdkMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO0FBQzFDLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQSxBQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7OztBQUd0RCxVQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7QUFDMUIsZUFBTztPQUNSO0tBQ0Y7O0FBRUQsVUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztHQUMzQixDQUFDOztBQUVGLE1BQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7Ozs7O0FBSzdELFdBQVMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUUsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUM7OztBQUdoRixXQUFTLENBQUMsYUFBYSxHQUFHLFlBQVk7QUFDcEMsVUFBTSxJQUFJLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO0dBQzlFLENBQUM7OztBQUdGLE1BQUksTUFBTSxDQUFDLGFBQWEsRUFBRTtBQUN4QixRQUFJLGVBQWUsR0FBRyxJQUFJLENBQUM7QUFDM0IsUUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFO0FBQzNDLHFCQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7S0FDL0M7O0FBRUQsYUFBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQ3ZCLFlBQVksQ0FBQyx1QkFBdUIsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7R0FDaEY7O0FBRUQsTUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO0FBQy9CLDZCQUF5QixFQUFFLElBQUk7QUFDL0IsNEJBQXdCLEVBQUUsSUFBSTtHQUMvQixDQUFDLENBQUM7O0FBRUgsTUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUkscUJBQXFCLENBQ3BELElBQUksQ0FBQyxNQUFNLEVBQ1gsTUFBTSxDQUFDLGFBQWEsRUFDcEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQzFCLE1BQU0sQ0FBQyxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUM1QyxNQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEVBQUU7QUFDeEMsUUFBSSxDQUFDLHFCQUFxQixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ3REO0FBQ0QsTUFBSSxDQUFDLHFCQUFxQixDQUFDLGNBQWMsRUFBRSxDQUFDOzs7QUFHNUMsTUFBSSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDbEUsTUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ25FLE1BQUksaUJBQWlCLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3ZFLE1BQUksaUJBQWlCLElBQUksZUFBZSxJQUFJLGlCQUFpQixFQUFFO0FBQzdELHFCQUFpQixDQUFDLFNBQVMsSUFBSSxhQUFhLENBQUM7QUFDN0MsbUJBQWUsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQztBQUMvQyxRQUFJLG1CQUFtQixHQUFHLENBQUMsWUFBVztBQUNwQyxVQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDZixZQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDdkQseUJBQWlCLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEdBQUcsTUFBTSxHQUFHLGNBQWMsQ0FBQztBQUN6RCx1QkFBZSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQ3pCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEdBQUcsTUFBTSxHQUFHLGNBQWMsQ0FBQztBQUMxRCxZQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztPQUM1QjtLQUNGLENBQUEsQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDZCxPQUFHLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztBQUMvRCxPQUFHLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztHQUNoRTs7QUFFRCxNQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQzs7QUFFM0IsTUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7QUFDdkUsTUFBSSxXQUFXLEVBQUU7O0FBRWYsUUFBSTs7QUFFRixVQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQzFELENBQUMsT0FBTyxHQUFHLEVBQUU7OztBQUdaLGFBQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQzVCOztBQUVELFFBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7O0FBRTdCLFFBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3BFLFFBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLFdBQVcsRUFBRSxDQUFDLENBQUM7R0FDdEU7O0FBRUQsTUFBSSxNQUFNLENBQUMsaUJBQWlCLEVBQUU7OztBQUc1QixRQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5QixxQkFBaUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztHQUMxQzs7Ozs7QUFLRCxNQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7QUFFaEQsTUFBSSxDQUFDLHFCQUFxQixDQUFDLGdDQUFnQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFekUsTUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsbUJBQW1CLEVBQUUsVUFBUyxDQUFDLEVBQUU7O0FBRTlDLEtBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztHQUNqRCxDQUFDLENBQUM7O0FBRUgsTUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7OztBQUczQixRQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUM7R0FDakM7O0FBRUQsTUFBSSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU7QUFDM0IsVUFBTSxDQUFDLGdCQUFnQixFQUFFLENBQUM7R0FDM0I7O0FBRUQsTUFBSSxNQUFNLENBQUMsV0FBVyxFQUFFO0FBQ3RCLFVBQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztHQUN0QjtDQUNGLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFlBQVk7QUFDbEQsTUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDaEIsVUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsQ0FBQyxDQUFDO0dBQ3pFOzs7QUFHRCxNQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFBLFVBQVMsQ0FBQyxFQUFFO0FBQzVDLFFBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkMsUUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2YsVUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JDLE1BQU07QUFDTCxVQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbkM7R0FDRixDQUFBLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Q0FDZixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLHNCQUFzQixHQUFHLFVBQVUsV0FBVyxFQUFFO0FBQ2xFLE1BQUksQ0FBQyxvQkFBb0IsR0FBRyxXQUFXLENBQUM7Q0FDekMsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFVBQVUsTUFBTSxFQUFFLGVBQWUsRUFBRTtBQUN2RSxNQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFO0FBQzVCLG1CQUFlLEdBQUcsS0FBSyxDQUFDO0dBQ3pCO0FBQ0QsTUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO0FBQ2pELE1BQUksZUFBZSxJQUFJLE1BQU0sQ0FBQyxhQUFhLEtBQUssUUFBUSxFQUFFO0FBQ3hELGVBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsSUFBSSxXQUFXLENBQUM7R0FDdkQ7QUFDRCxNQUFJLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTtBQUM5QixlQUFXLEdBQUcsVUFBVSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsRUFDcEQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUM7R0FDakM7QUFDRCxhQUFXLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM5RSxNQUFJO0FBQ0YsUUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztHQUM5QixDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsUUFBSSxlQUFlLEVBQUU7QUFDbkIsYUFBTyxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFL0IsVUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDckMsTUFBTTtBQUNMLFlBQU0sQ0FBQyxDQUFDO0tBQ1Q7R0FDRjtDQUNGLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRyxVQUFTLE1BQU0sRUFBRTtBQUM3RCxNQUFJLE9BQU8sQ0FBQyxjQUFjLEVBQUU7QUFDMUIsV0FBTyxDQUFDLGNBQWMsQ0FBQyw4QkFBOEIsQ0FBQztBQUNwRCxzQkFBZ0IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQjtBQUNyRCxzQkFBZ0IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQjtBQUMvQyx1QkFBaUIsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQjtBQUNqRCxzQkFBZ0IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQjtBQUMvQyx1QkFBaUIsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQjtBQUNqRCx3QkFBa0IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQjtBQUNuRCx5QkFBbUIsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQjtLQUN0RCxDQUFDLENBQUM7R0FDSixNQUFNO0FBQ0wsV0FBTyxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7R0FDOUU7Q0FDRixDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEdBQUcsVUFBVSxNQUFNLEVBQUU7O0FBRTFELE1BQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUU7QUFDNUIsUUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztBQUNsQyxRQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxLQUFLLGlCQUFpQixJQUM5QyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsS0FBSyxnQkFBZ0IsSUFDN0MsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEtBQUssb0JBQW9CLEVBQUU7O0FBRXJELFlBQU0sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUM7S0FDbkM7R0FDRjs7Ozs7QUFLRCxNQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO0FBQ3hCLFFBQUksd0JBQXdCLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN2RSxRQUFJLHdCQUF3QixLQUFLLGFBQWEsSUFDMUMsd0JBQXdCLEtBQUssUUFBUSxFQUFFO0FBQ3pDLFlBQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztLQUNsQztHQUNGOztBQUVELE1BQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDbkQsTUFBSSxPQUFPLEdBQUc7QUFDWixXQUFPLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPO0FBQzdCLHVCQUFtQixFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUM7QUFDMUUsMEJBQXNCLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFLEtBQUssQ0FBQztBQUNqRiwwQkFBc0IsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLEVBQUUsS0FBSyxDQUFDO0FBQ2pGLHFCQUFpQixFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUM7QUFDdkUsbUJBQWUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQztBQUNuRSwyQkFBdUIsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxDQUFDO0FBQy9FLGNBQVUsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVU7QUFDbkMseUJBQXFCLEVBQUUsTUFBTSxDQUFDLHFCQUFxQjtBQUNuRCwyQkFBdUIsRUFBRSxNQUFNLENBQUMsdUJBQXVCO0FBQ3ZELGNBQVUsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQztBQUMxRCxZQUFRLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxDQUFDO0FBQ3hELDBCQUFzQixFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFLEtBQUssQ0FBQztHQUM1RSxDQUFDO0FBQ0YsR0FBQyxVQUFVLEVBQUUsZUFBZSxFQUFFLDBCQUEwQixFQUN0RCxxQkFBcUIsQ0FBQyxDQUFDLE9BQU8sQ0FDOUIsVUFBVSxJQUFJLEVBQUU7QUFDZCxRQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7QUFDOUIsYUFBTyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QjtHQUNGLENBQUMsQ0FBQztBQUNMLE1BQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzFCLE1BQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQzs7QUFFaEIsTUFBSSxNQUFNLENBQUMsV0FBVyxFQUFFO0FBQ3RCLFVBQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztHQUN0QjtBQUNELE1BQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQ3BDLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxnQ0FBZ0MsR0FBRyxVQUFVLFdBQVcsRUFBRTs7QUFFNUUsTUFBSSxjQUFjLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2pFLE1BQUksV0FBVyxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUM7QUFDNUMsTUFBSSxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxJQUFJLEVBQUU7QUFDcEUsV0FBTyxTQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7TUFBQztHQUN0QyxDQUFDLENBQUM7QUFDSCxNQUFJLGNBQWMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxJQUFJLEVBQUU7QUFDbEUsV0FBTyxtQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztNQUFDO0dBQ2hELENBQUMsQ0FBQzs7O0FBR0gsTUFBSSxXQUFXLEVBQUU7QUFDZixRQUFJLGdCQUFnQixJQUFJLGNBQWMsRUFBRTtBQUN0QyxzQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQztBQUNoRCxvQkFBYyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0tBQ3ZDO0FBQ0QsZUFBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO0dBQzFELE1BQU07QUFDTCxRQUFJLGdCQUFnQixJQUFJLGNBQWMsRUFBRTtBQUN0QyxzQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN4QyxvQkFBYyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDO0tBQy9DO0FBQ0QsZUFBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixFQUFFLENBQUM7R0FDNUQ7O0FBRUQsTUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6RCxNQUFJLFVBQVUsRUFBRTtBQUNkLGNBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUN0QixBQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEdBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQztHQUN4RTtDQUNGLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLFNBQVMsRUFBRTtBQUMxRCxXQUFTLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDM0MsTUFBSSxDQUFDLGdDQUFnQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN4RSxNQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTtBQUNyQyxRQUFJLFNBQVMsRUFBRTtBQUNiLFVBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQy9CO0FBQ0QsUUFBSSxDQUFDLHFCQUFxQixDQUFDLCtCQUErQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUN6RTtDQUNGLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxZQUFZO0FBQ2xELFNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0NBQzNDLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyw2QkFBNkIsR0FBRyxZQUFZO0FBQzlELFNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO0NBQ3ZELENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQywwQkFBMEIsR0FBRyxZQUFZO0FBQzNELFNBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDO0NBQzVDLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsMEJBQTBCLEdBQUcsWUFBWTtBQUMzRCxTQUFPLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxVQUFVLFNBQVMsRUFBRTtBQUNuRSxXQUFPLFNBQVMsQ0FBQyxJQUFJLEtBQUssb0JBQW9CLENBQUM7R0FDaEQsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsNEJBQTRCLEdBQUcsWUFBWTtBQUM3RCxTQUFPLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxVQUFVLFNBQVMsRUFBRTtBQUNuRSxRQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssb0JBQW9CLEVBQUU7QUFDM0MsYUFBTyxLQUFLLENBQUM7S0FDZDtBQUNELFFBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNyRCxXQUFPLE1BQU0sSUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQy9DLENBQUMsQ0FBQztDQUNKLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsbUNBQW1DLEdBQUcsVUFBVSxNQUFNLEVBQUU7QUFDMUUsTUFBSSxhQUFhLENBQUM7QUFDbEIsU0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLEVBQUU7O0FBRTFELFFBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUNyQyxRQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQ3RCLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7O0FBRUQsUUFBSSxLQUFLLENBQUMsMEJBQTBCLEVBQUUsRUFBRTtBQUN0QyxtQkFBYSxHQUFHLEtBQUssQ0FBQztBQUN0QixhQUFPLElBQUksQ0FBQztLQUNiO0dBQ0YsQ0FBQyxDQUFDOztBQUVILFNBQU8sYUFBYSxDQUFDO0NBQ3RCLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsNkJBQTZCLEdBQUcsWUFBWTtBQUM5RCxNQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEtBQUssRUFBRTtBQUNsRixXQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssdUJBQXVCLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7R0FDdEUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLGVBQWUsRUFBRTtBQUNoQyxXQUFPLGVBQWUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQztHQUNoRCxDQUFDLENBQUM7O0FBRUgsTUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxLQUFLLEVBQUU7QUFDL0UsUUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLG9CQUFvQixFQUFFO0FBQ3ZDLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7Ozs7QUFJRCxRQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakQsV0FBTyxNQUFNLElBQUksTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUMvQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsWUFBWSxFQUFFO0FBQzdCLFdBQU8sWUFBWSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUN6RSxDQUFDLENBQUM7O0FBRUgsTUFBSSxpQ0FBaUMsQ0FBQztBQUN0QyxpQkFBZSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsRUFBRTtBQUNyQyxRQUFJLGtCQUFrQixHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBUyxPQUFPLEVBQUU7QUFDN0QsYUFBTyxHQUFHLEtBQUssT0FBTyxDQUFDO0tBQ3hCLENBQUMsQ0FBQzs7QUFFSCxRQUFJLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDakMsdUNBQWlDLEdBQUcsR0FBRyxDQUFDO0tBQ3pDO0dBQ0YsQ0FBQyxDQUFDO0FBQ0gsU0FBTyxpQ0FBaUMsQ0FBQztDQUMxQyxDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLCtCQUErQixHQUFHLFVBQVUsWUFBWSxFQUFFO0FBQzVFLE1BQUksUUFBUSxHQUFHLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDOztBQUVqRCxNQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsV0FBTyxJQUFJLENBQUM7R0FDYjs7QUFFRCxNQUFJLFNBQVMsR0FBRyxRQUFRLENBQUM7QUFDekIsU0FBTyxTQUFTLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDNUIsYUFBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztHQUNuQzs7QUFFRCxNQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFFO0FBQ2xDLFdBQU8sR0FBRyxDQUFDLGtCQUFrQixDQUFDLEVBQUMsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLGFBQWEsRUFBRSxFQUFDLENBQUMsQ0FBQztHQUM5RTs7QUFFRCxNQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssdUJBQXVCLEVBQUU7QUFDOUMsV0FBTyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztHQUNuQzs7QUFFRCxNQUFJLGFBQWEsR0FBRyxTQUFTLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztBQUNqRCxNQUFJLFNBQVMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtBQUMxQixXQUFPLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFDLElBQUksRUFBRSxhQUFhLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztHQUM3RCxNQUFNO0FBQ0wsV0FBTyxHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUM7R0FDN0Q7Q0FDRixDQUFDOzs7Ozs7Ozs7O0FBVUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRyxVQUFVLGNBQWMsRUFBRTtBQUN0RSxNQUFJLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUMxQixTQUFPLENBQUMsY0FBYyxDQUFDLG9CQUFvQixFQUFFLENBQUMsT0FBTyxDQUFDLFVBQVUsWUFBWSxFQUFFO0FBQzVFLFFBQUksT0FBTyxHQUFHLGNBQWMsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7Ozs7QUFJbEQsV0FBTyxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRWxFLFFBQUksT0FBTyxFQUFFO0FBQ1gsc0JBQWdCLEdBQUcsWUFBWSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUMxRCxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDMUI7R0FDRixDQUFDLENBQUM7QUFDSCxTQUFPLGdCQUFnQixDQUFDO0NBQ3pCLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyw4QkFBOEIsR0FBRyxZQUFZO0FBQy9ELFNBQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLEVBQUU7QUFDakUsUUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLHVCQUF1QixFQUFFO0FBQzFDLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7O0FBRUQsV0FBTyxDQUFFLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQUFBQyxDQUFDO0dBQ3pDLENBQUMsQ0FBQztDQUNKLENBQUM7O0FBRUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyw4QkFBOEIsR0FBRyxVQUFVLE9BQU8sRUFBRTtBQUN0RSxNQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQzFCLE1BQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7QUFDNUIsTUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNwQyxNQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO0FBQ2xDLE1BQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7O0FBRWxDLE1BQUksYUFBYSxHQUFHLEdBQUcsQ0FBQztBQUN4QixNQUFJLFlBQVksR0FBRyxHQUFHLENBQUM7O0FBRXZCLE1BQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRTNDLE1BQUksSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7QUFDckIsT0FBSyxJQUFJLEtBQUssR0FBRyxVQUFVLEVBQUUsS0FBSyxJQUFJLFNBQVMsRUFBRSxLQUFLLElBQUksU0FBUyxFQUFFOztBQUVuRSxRQUFJLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyw0QkFBNEIsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN0RSxRQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNqRCxPQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RCLFFBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdEIsUUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsS0FBSyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3hELFFBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLFFBQUksR0FBRywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QyxRQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNuQyxPQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7O0FBRzdCLFFBQUksR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLDRCQUE0QixFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3RFLFFBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ2pELE9BQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsUUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN0QixRQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQixRQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxhQUFhLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQSxBQUFDLENBQUMsQ0FBQztBQUN6RCxRQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELFFBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLFFBQUksR0FBRywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QyxRQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNuQyxPQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUYsU0FBUywwQkFBMEIsQ0FBQyxPQUFPLEVBQUU7QUFDM0MsTUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzdCLE1BQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsNEJBQTRCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDMUUsTUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9CLE1BQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvQixNQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkMsTUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7O0FBUUQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBVSxjQUFjLEVBQUUsS0FBSyxFQUFFOzs7O0FBSWxFLE1BQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUMvQixNQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ2hELE1BQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDMUIsYUFBUyxHQUFHLENBQUMsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBQzVDLFVBQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDMUI7O0FBRUQsTUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU7QUFDNUIsYUFBUyxFQUFFLGFBQWE7QUFDeEIsV0FBTyxFQUFFLG1CQUFZO0FBQ25CLFdBQUssQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM1QztHQUNGLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRVYsTUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDckQsT0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDckMsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMscUJBQXFCLEdBQUcsVUFBVSxjQUFjLEVBQUU7QUFDcEUsTUFBSSxNQUFNLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUUsRUFBRTtBQUNqRSxRQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRTtBQUNoQyxVQUFJLEVBQUUsS0FBSyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFO0FBQzlDLFlBQUksRUFBRTtBQUNKLGFBQUcsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUM7QUFDakQsb0JBQVUsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsMEJBQTBCLENBQUM7U0FDaEU7T0FDRixDQUFDO0FBQ0YsV0FBSyxFQUFFO0FBQ0wsV0FBRyxFQUFFLEVBQUU7QUFDUCxZQUFJLEVBQUUsR0FBRztBQUNULGFBQUssRUFBRSxFQUFFO09BQ1Y7S0FDRixDQUFDLENBQUM7R0FDSjtDQUNGLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLCtCQUErQixHQUFHLFlBQVk7QUFDaEUsTUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2pCLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7QUFDRCxTQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0NBQzlGLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLG9DQUFvQyxHQUFHLFVBQVUsS0FBSyxFQUFFO0FBQzFFLE1BQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxjQUFjLElBQ3ZDLEtBQUssQ0FBQyxJQUFJLEtBQUssc0JBQXNCLEVBQUU7QUFDekMsV0FBTztHQUNSOztBQUVELE1BQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDOzs7O0FBSS9ELFNBQU8sS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLE9BQU8sRUFBRTtBQUM3QyxXQUFPLFVBQVUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxVQUFVLEVBQUU7QUFDNUQsVUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLGNBQWMsSUFDbEMsVUFBVSxDQUFDLElBQUksS0FBSyxzQkFBc0IsRUFBRTtBQUM5QyxlQUFPLEtBQUssQ0FBQztPQUNkO0FBQ0QsYUFBTyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ3JELENBQUMsQ0FBQztHQUNKLENBQUMsQ0FBQztDQUNKLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLHlCQUF5QixHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQzlELE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUN2QixXQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDbEMsTUFBTTtBQUNMLFdBQU8sSUFBSSxDQUFDO0dBQ2I7Q0FDRixDQUFDOzs7QUM3NEVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Ozs7O0FBUUYsY0FBYyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBVSxZQUFZLEVBQUU7QUFDM0QsTUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDOztBQUVyRCxNQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7QUFDOUMsUUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUM7R0FDekI7QUFDRCxNQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQzVDLFlBQVksS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDM0QsV0FBTyxFQUFFLENBQUM7R0FDWDtBQUNELE1BQUksT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFDN0QsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztHQUMzQztBQUNELFNBQU8sWUFBWSxDQUFDO0NBQ3JCLENBQUM7Ozs7Ozs7OztBQVNGLGNBQWMsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVUsS0FBSyxFQUFFLFFBQVEsRUFBRTtBQUNsRSxNQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ3ZDLFFBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDO0dBQ2xDO0NBQ0YsQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBGdW5jdGlvbnMgZm9yIGNoZWNraW5nIHJlcXVpcmVkIGJsb2Nrcy5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGZvciBhIGNhbGwgdG8gYSBwcm9jZWR1cmUgdGhhdCBkb2VzXG4gKiBub3QgaGF2ZSBhIHJldHVybiB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9jZWR1cmUgYmVpbmcgY2FsbGVkLlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMuY2FsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXN0OiBmdW5jdGlvbihibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLnR5cGUgPT0gJ3Byb2NlZHVyZXNfY2FsbG5vcmV0dXJuJyAmJlxuICAgICAgICAgIGJsb2NrLmdldFRpdGxlVmFsdWUoJ05BTUUnKS50b0xvd2VyQ2FzZSgpID09IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuICAgIHR5cGU6ICdwcm9jZWR1cmVzX2NhbGxub3JldHVybicsXG4gICAgdGl0bGVzOiB7J05BTUUnOiBuYW1lfVxuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGZvciBhIGNhbGwgdG8gYSBwcm9jZWR1cmUgd2l0aCBhXG4gKiBzaW5nbGUgYXJndW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY19uYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9jZWR1cmUgYmVpbmcgY2FsbGVkLlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMuY2FsbFdpdGhBcmcgPSBmdW5jdGlvbihmdW5jX25hbWUsIGFyZ19uYW1lKSB7XG4gIHJldHVybiB7XG4gICAgdGVzdDogZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay50eXBlID09ICdwcm9jZWR1cmVzX2NhbGxub3JldHVybicgJiZcbiAgICAgICAgICBibG9jay5nZXRUaXRsZVZhbHVlKCdOQU1FJykudG9Mb3dlckNhc2UoKSA9PSBmdW5jX25hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuICAgIHR5cGU6ICdwcm9jZWR1cmVzX2NhbGxub3JldHVybicsXG4gICAgZXh0cmE6ICc8bXV0YXRpb24gbmFtZT1cIicgKyBmdW5jX25hbWUgKyAnXCI+PGFyZyBuYW1lPVwiJyArIGFyZ19uYW1lICtcbiAgICAgICAgJ1wiPjwvYXJnPjwvbXV0YXRpb24+J1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGZvciB0aGUgZGVmaW5pdGlvbiBvZiBhIHByb2NlZHVyZVxuICogdGhhdCBkb2VzIG5vdCBoYXZlIGEgcmV0dXJuIHZhbHVlLiAgVGhpcyBkb2VzIG5vdCBjaGVjayBpZiBhbnkgYXJndW1lbnRzXG4gKiBhcmUgZGVmaW5lZCBmb3IgdGhlIHByb2NlZHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9jZWR1cmUgYmVpbmcgZGVmaW5lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBhYmxlIHRvIGNoZWNrIGZvciBhbmRcbiAqICAgICBnZW5lcmF0ZSB0aGUgc3BlY2lmaWVkIGJsb2NrLlxuICovXG5leHBvcnRzLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXN0OiBmdW5jdGlvbihibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLnR5cGUgPT0gJ3Byb2NlZHVyZXNfZGVmbm9yZXR1cm4nICYmXG4gICAgICAgICAgYmxvY2suZ2V0VGl0bGVWYWx1ZSgnTkFNRScpLnRvTG93ZXJDYXNlKCkgPT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgdHlwZTogJ3Byb2NlZHVyZXNfZGVmbm9yZXR1cm4nLFxuICAgIHRpdGxlczogeydOQU1FJzogbmFtZX1cbiAgfTtcbn07XG4iLCIvKlxyXG4gKiBjYW52Zy5qcyAtIEphdmFzY3JpcHQgU1ZHIHBhcnNlciBhbmQgcmVuZGVyZXIgb24gQ2FudmFzXHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKiBHYWJlIExlcm5lciAoZ2FiZWxlcm5lckBnbWFpbC5jb20pXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9jYW52Zy9cclxuICpcclxuICogUmVxdWlyZXM6IHJnYmNvbG9yLmpzIC0gaHR0cDovL3d3dy5waHBpZWQuY29tL3JnYi1jb2xvci1wYXJzZXItaW4tamF2YXNjcmlwdC9cclxuICovXHJcbiAoZnVuY3Rpb24gKCBnbG9iYWwsIGZhY3RvcnkgKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0Ly8gZXhwb3J0IGFzIEFNRC4uLlxyXG5cdGlmICggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCApIHtcclxuXHRcdGRlZmluZSgnY2FudmdNb2R1bGUnLCBbICdyZ2Jjb2xvcicsICdzdGFja2JsdXInIF0sIGZhY3RvcnkgKTtcclxuXHR9XHJcblxyXG5cdC8vIC4uLm9yIGFzIGJyb3dzZXJpZnlcclxuXHRlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoICdyZ2Jjb2xvcicgKSwgcmVxdWlyZSggJ3N0YWNrYmx1cicgKSApO1xyXG5cdH1cclxuXHJcblx0Z2xvYmFsLmNhbnZnID0gZmFjdG9yeSggZ2xvYmFsLlJHQkNvbG9yLCBnbG9iYWwuc3RhY2tCbHVyICk7XHJcblxyXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICggUkdCQ29sb3IsIHN0YWNrQmx1ciApIHtcclxuXHJcblx0Ly8gY2FudmcodGFyZ2V0LCBzKVxyXG5cdC8vIGVtcHR5IHBhcmFtZXRlcnM6IHJlcGxhY2UgYWxsICdzdmcnIGVsZW1lbnRzIG9uIHBhZ2Ugd2l0aCAnY2FudmFzJyBlbGVtZW50c1xyXG5cdC8vIHRhcmdldDogY2FudmFzIGVsZW1lbnQgb3IgdGhlIGlkIG9mIGEgY2FudmFzIGVsZW1lbnRcclxuXHQvLyBzOiBzdmcgc3RyaW5nLCB1cmwgdG8gc3ZnIGZpbGUsIG9yIHhtbCBkb2N1bWVudFxyXG5cdC8vIG9wdHM6IG9wdGlvbmFsIGhhc2ggb2Ygb3B0aW9uc1xyXG5cdC8vXHRcdCBpZ25vcmVNb3VzZTogdHJ1ZSA9PiBpZ25vcmUgbW91c2UgZXZlbnRzXHJcblx0Ly9cdFx0IGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSA9PiBpZ25vcmUgYW5pbWF0aW9uc1xyXG5cdC8vXHRcdCBpZ25vcmVEaW1lbnNpb25zOiB0cnVlID0+IGRvZXMgbm90IHRyeSB0byByZXNpemUgY2FudmFzXHJcblx0Ly9cdFx0IGlnbm9yZUNsZWFyOiB0cnVlID0+IGRvZXMgbm90IGNsZWFyIGNhbnZhc1xyXG5cdC8vXHRcdCBvZmZzZXRYOiBpbnQgPT4gZHJhd3MgYXQgYSB4IG9mZnNldFxyXG5cdC8vXHRcdCBvZmZzZXRZOiBpbnQgPT4gZHJhd3MgYXQgYSB5IG9mZnNldFxyXG5cdC8vXHRcdCBzY2FsZVdpZHRoOiBpbnQgPT4gc2NhbGVzIGhvcml6b250YWxseSB0byB3aWR0aFxyXG5cdC8vXHRcdCBzY2FsZUhlaWdodDogaW50ID0+IHNjYWxlcyB2ZXJ0aWNhbGx5IHRvIGhlaWdodFxyXG5cdC8vXHRcdCByZW5kZXJDYWxsYmFjazogZnVuY3Rpb24gPT4gd2lsbCBjYWxsIHRoZSBmdW5jdGlvbiBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIGlzIGNvbXBsZXRlZFxyXG5cdC8vXHRcdCBmb3JjZVJlZHJhdzogZnVuY3Rpb24gPT4gd2lsbCBjYWxsIHRoZSBmdW5jdGlvbiBvbiBldmVyeSBmcmFtZSwgaWYgaXQgcmV0dXJucyB0cnVlLCB3aWxsIHJlZHJhd1xyXG5cdHZhciBjYW52ZyA9IGZ1bmN0aW9uICh0YXJnZXQsIHMsIG9wdHMpIHtcclxuXHRcdC8vIG5vIHBhcmFtZXRlcnNcclxuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCAmJiBzID09IG51bGwgJiYgb3B0cyA9PSBudWxsKSB7XHJcblx0XHRcdHZhciBzdmdUYWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3ZnJyk7XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxzdmdUYWdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHN2Z1RhZyA9IHN2Z1RhZ3NbaV07XHJcblx0XHRcdFx0dmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHRcdFx0XHRjLndpZHRoID0gc3ZnVGFnLmNsaWVudFdpZHRoO1xyXG5cdFx0XHRcdGMuaGVpZ2h0ID0gc3ZnVGFnLmNsaWVudEhlaWdodDtcclxuXHRcdFx0XHRzdmdUYWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYywgc3ZnVGFnKTtcclxuXHRcdFx0XHRzdmdUYWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdmdUYWcpO1xyXG5cdFx0XHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0XHRkaXYuYXBwZW5kQ2hpbGQoc3ZnVGFnKTtcclxuXHRcdFx0XHRjYW52ZyhjLCBkaXYuaW5uZXJIVE1MKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0dGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdG9yZSBjbGFzcyBvbiBjYW52YXNcclxuXHRcdGlmICh0YXJnZXQuc3ZnICE9IG51bGwpIHRhcmdldC5zdmcuc3RvcCgpO1xyXG5cdFx0dmFyIHN2ZyA9IGJ1aWxkKG9wdHMgfHwge30pO1xyXG5cdFx0Ly8gb24gaS5lLiA4IGZvciBmbGFzaCBjYW52YXMsIHdlIGNhbid0IGFzc2lnbiB0aGUgcHJvcGVydHkgc28gY2hlY2sgZm9yIGl0XHJcblx0XHRpZiAoISh0YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiB0YXJnZXQuY2hpbGROb2Rlc1swXS5ub2RlTmFtZSA9PSAnT0JKRUNUJykpIHRhcmdldC5zdmcgPSBzdmc7XHJcblxyXG5cdFx0dmFyIGN0eCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdFx0aWYgKHR5cGVvZiBzLmRvY3VtZW50RWxlbWVudCAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHQvLyBsb2FkIGZyb20geG1sIGRvY1xyXG5cdFx0XHRzdmcubG9hZFhtbERvYyhjdHgsIHMpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAocy5zdWJzdHIoMCwxKSA9PSAnPCcpIHtcclxuXHRcdFx0Ly8gbG9hZCBmcm9tIHhtbCBzdHJpbmdcclxuXHRcdFx0c3ZnLmxvYWRYbWwoY3R4LCBzKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHQvLyBsb2FkIGZyb20gdXJsXHJcblx0XHRcdHN2Zy5sb2FkKGN0eCwgcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQubWF0Y2hlc1xyXG5cdHZhciBtYXRjaGVzU2VsZWN0b3I7XHJcblx0aWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm1vek1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm9NYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gcmVxdWlyZXMgU2l6emxlOiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS93aWtpL1NpenpsZS1Eb2N1bWVudGF0aW9uXHJcblx0XHQvLyBvciBqUXVlcnk6IGh0dHA6Ly9qcXVlcnkuY29tL2Rvd25sb2FkL1xyXG5cdFx0Ly8gb3IgWmVwdG86IGh0dHA6Ly96ZXB0b2pzLmNvbS8jXHJcblx0XHQvLyB3aXRob3V0IGl0LCB0aGlzIGlzIGEgUmVmZXJlbmNlRXJyb3JcclxuXHJcblx0XHRpZiAodHlwZW9mIGpRdWVyeSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgWmVwdG8gPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XHJcblx0XHRcdFx0cmV0dXJuICQobm9kZSkuaXMoc2VsZWN0b3IpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgbWF0Y2hlc1NlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRtYXRjaGVzU2VsZWN0b3IgPSBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2VlZ2Fuc3RyZWV0L3NwZWNpZmljaXR5L2Jsb2IvbWFzdGVyL3NwZWNpZmljaXR5LmpzXHJcblx0dmFyIGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xyXG5cdHZhciBpZFJlZ2V4ID0gLygjW15cXHNcXCs+flxcLlxcWzpdKykvZztcclxuXHR2YXIgY2xhc3NSZWdleCA9IC8oXFwuW15cXHNcXCs+flxcLlxcWzpdKykvZztcclxuXHR2YXIgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzXFwrPn5cXC5cXFs6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XHJcblx0dmFyIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXggPSAvKDpbXFx3LV0rXFwoW15cXCldKlxcKSkvZ2k7XHJcblx0dmFyIHBzZXVkb0NsYXNzUmVnZXggPSAvKDpbXlxcc1xcKz5+XFwuXFxbOl0rKS9nO1xyXG5cdHZhciBlbGVtZW50UmVnZXggPSAvKFteXFxzXFwrPn5cXC5cXFs6XSspL2c7XHJcblx0ZnVuY3Rpb24gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShzZWxlY3Rvcikge1xyXG5cdFx0dmFyIHR5cGVDb3VudCA9IFswLCAwLCAwXTtcclxuXHRcdHZhciBmaW5kTWF0Y2ggPSBmdW5jdGlvbihyZWdleCwgdHlwZSkge1xyXG5cdFx0XHR2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yLm1hdGNoKHJlZ2V4KTtcclxuXHRcdFx0aWYgKG1hdGNoZXMgPT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlQ291bnRbdHlwZV0gKz0gbWF0Y2hlcy5sZW5ndGg7XHJcblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWdleCwgJyAnKTtcclxuXHRcdH07XHJcblxyXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC86bm90XFwoKFteXFwpXSopXFwpL2csICcgICAgICQxICcpO1xyXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC97W15dKi9nbSwgJyAnKTtcclxuXHRcdGZpbmRNYXRjaChhdHRyaWJ1dGVSZWdleCwgMSk7XHJcblx0XHRmaW5kTWF0Y2goaWRSZWdleCwgMCk7XHJcblx0XHRmaW5kTWF0Y2goY2xhc3NSZWdleCwgMSk7XHJcblx0XHRmaW5kTWF0Y2gocHNldWRvRWxlbWVudFJlZ2V4LCAyKTtcclxuXHRcdGZpbmRNYXRjaChwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4LCAxKTtcclxuXHRcdGZpbmRNYXRjaChwc2V1ZG9DbGFzc1JlZ2V4LCAxKTtcclxuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvW1xcKlxcc1xcKz5+XS9nLCAnICcpO1xyXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9bI1xcLl0vZywgJyAnKTtcclxuXHRcdGZpbmRNYXRjaChlbGVtZW50UmVnZXgsIDIpO1xyXG5cdFx0cmV0dXJuIHR5cGVDb3VudC5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkKG9wdHMpIHtcclxuXHRcdHZhciBzdmcgPSB7IG9wdHM6IG9wdHMgfTtcclxuXHJcblx0XHRzdmcuRlJBTUVSQVRFID0gMzA7XHJcblx0XHRzdmcuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XHJcblxyXG5cdFx0c3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykge307XHJcblx0XHRpZiAoc3ZnLm9wdHNbJ2xvZyddID09IHRydWUgJiYgdHlwZW9mIGNvbnNvbGUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0c3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykgeyBjb25zb2xlLmxvZyhtc2cpOyB9O1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBnbG9iYWxzXHJcblx0XHRzdmcuaW5pdCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHR2YXIgdW5pcXVlSWQgPSAwO1xyXG5cdFx0XHRzdmcuVW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7IHVuaXF1ZUlkKys7IHJldHVybiAnY2FudmcnICsgdW5pcXVlSWQ7XHR9O1xyXG5cdFx0XHRzdmcuRGVmaW5pdGlvbnMgPSB7fTtcclxuXHRcdFx0c3ZnLlN0eWxlcyA9IHt9O1xyXG5cdFx0XHRzdmcuU3R5bGVzU3BlY2lmaWNpdHkgPSB7fTtcclxuXHRcdFx0c3ZnLkFuaW1hdGlvbnMgPSBbXTtcclxuXHRcdFx0c3ZnLkltYWdlcyA9IFtdO1xyXG5cdFx0XHRzdmcuY3R4ID0gY3R4O1xyXG5cdFx0XHRzdmcuVmlld1BvcnQgPSBuZXcgKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR0aGlzLnZpZXdQb3J0cyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMuQ2xlYXIgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMgPSBbXTsgfVxyXG5cdFx0XHRcdHRoaXMuU2V0Q3VycmVudCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHsgdGhpcy52aWV3UG9ydHMucHVzaCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH1cclxuXHRcdFx0XHR0aGlzLlJlbW92ZUN1cnJlbnQgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMucG9wKCk7IH1cclxuXHRcdFx0XHR0aGlzLkN1cnJlbnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1BvcnRzW3RoaXMudmlld1BvcnRzLmxlbmd0aCAtIDFdOyB9XHJcblx0XHRcdFx0dGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkud2lkdGg7IH1cclxuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkuaGVpZ2h0OyB9XHJcblx0XHRcdFx0dGhpcy5Db21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGlmIChkICE9IG51bGwgJiYgdHlwZW9mIGQgPT0gJ251bWJlcicpIHJldHVybiBkO1xyXG5cdFx0XHRcdFx0aWYgKGQgPT0gJ3gnKSByZXR1cm4gdGhpcy53aWR0aCgpO1xyXG5cdFx0XHRcdFx0aWYgKGQgPT0gJ3knKSByZXR1cm4gdGhpcy5oZWlnaHQoKTtcclxuXHRcdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCgpLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0KCksIDIpKSAvIE1hdGguc3FydCgyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLmluaXQoKTtcclxuXHJcblx0XHQvLyBpbWFnZXMgbG9hZGVkXHJcblx0XHRzdmcuSW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxzdmcuSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKCFzdmcuSW1hZ2VzW2ldLmxvYWRlZCkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRyaW1cclxuXHRcdHN2Zy50cmltID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IH1cclxuXHJcblx0XHQvLyBjb21wcmVzcyBzcGFjZXNcclxuXHRcdHN2Zy5jb21wcmVzc1NwYWNlcyA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW1xcc1xcclxcdFxcbl0rL2dtLCcgJyk7IH1cclxuXHJcblx0XHQvLyBhamF4XHJcblx0XHRzdmcuYWpheCA9IGZ1bmN0aW9uKHVybCkge1xyXG5cdFx0XHR2YXIgQUpBWDtcclxuXHRcdFx0aWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXtBSkFYPW5ldyBYTUxIdHRwUmVxdWVzdCgpO31cclxuXHRcdFx0ZWxzZXtBSkFYPW5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO31cclxuXHRcdFx0aWYoQUpBWCl7XHJcblx0XHRcdCAgIEFKQVgub3BlbignR0VUJyx1cmwsZmFsc2UpO1xyXG5cdFx0XHQgICBBSkFYLnNlbmQobnVsbCk7XHJcblx0XHRcdCAgIHJldHVybiBBSkFYLnJlc3BvbnNlVGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXJzZSB4bWxcclxuXHRcdHN2Zy5wYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIFdpbmRvd3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdpbmRvd3MuRGF0YSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV2luZG93cy5EYXRhLlhtbCAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdHZhciB4bWxEb2MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sRG9jdW1lbnQoKTtcclxuXHRcdFx0XHR2YXIgc2V0dGluZ3MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sTG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0c2V0dGluZ3MucHJvaGliaXREdGQgPSBmYWxzZTtcclxuXHRcdFx0XHR4bWxEb2MubG9hZFhtbCh4bWwsIHNldHRpbmdzKTtcclxuXHRcdFx0XHRyZXR1cm4geG1sRG9jO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHdpbmRvdy5ET01QYXJzZXIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xyXG5cdFx0XHRcdHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0eG1sID0geG1sLnJlcGxhY2UoLzwhRE9DVFlQRSBzdmdbXj5dKj4vLCAnJyk7XHJcblx0XHRcdFx0dmFyIHhtbERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XHJcblx0XHRcdFx0eG1sRG9jLmFzeW5jID0gJ2ZhbHNlJztcclxuXHRcdFx0XHR4bWxEb2MubG9hZFhNTCh4bWwpO1xyXG5cdFx0XHRcdHJldHVybiB4bWxEb2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdmcuUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0XHR9XHJcblx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHRoaXMudmFsdWUgIT09ICcnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmV0dXJuIHRoZSBudW1lcmljYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5XHJcblx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUubnVtVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XHJcblxyXG5cdFx0XHRcdHZhciBuID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcclxuXHRcdFx0XHRpZiAoKHRoaXMudmFsdWUgKyAnJykubWF0Y2goLyUkLykpIHtcclxuXHRcdFx0XHRcdG4gPSBuIC8gMTAwLjA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLnZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24oZGVmKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIHRoaXMudmFsdWU7XHJcblx0XHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZU9yRGVmYXVsdCA9IGZ1bmN0aW9uKGRlZikge1xyXG5cdFx0XHRcdGlmICh0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XHJcblx0XHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY29sb3IgZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGF1Z21lbnQgdGhlIGN1cnJlbnQgY29sb3IgdmFsdWUgd2l0aCB0aGUgb3BhY2l0eVxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuYWRkT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHlQcm9wKSB7XHJcblx0XHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYgKG9wYWNpdHlQcm9wLnZhbHVlICE9IG51bGwgJiYgb3BhY2l0eVByb3AudmFsdWUgIT0gJycgJiYgdHlwZW9mIHRoaXMudmFsdWUgPT0gJ3N0cmluZycpIHsgLy8gY2FuIG9ubHkgYWRkIG9wYWNpdHkgdG8gY29sb3JzLCBub3QgcGF0dGVybnNcclxuXHRcdFx0XHRcdFx0dmFyIGNvbG9yID0gbmV3IFJHQkNvbG9yKHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRpZiAoY29sb3Iub2spIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdWYWx1ZSA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywgJyArIGNvbG9yLmcgKyAnLCAnICsgY29sb3IuYiArICcsICcgKyBvcGFjaXR5UHJvcC5udW1WYWx1ZSgpICsgJyknO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Qcm9wZXJ0eSh0aGlzLm5hbWUsIG5ld1ZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkZWZpbml0aW9uIGV4dGVuc2lvbnNcclxuXHRcdFx0XHQvLyBnZXQgdGhlIGRlZmluaXRpb24gZnJvbSB0aGUgZGVmaW5pdGlvbnMgdGFibGVcclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBuYW1lID0gdGhpcy52YWx1ZS5tYXRjaCgvIyhbXlxcKSdcIl0rKS8pO1xyXG5cdFx0XHRcdFx0aWYgKG5hbWUpIHsgbmFtZSA9IG5hbWVbMV07IH1cclxuXHRcdFx0XHRcdGlmICghbmFtZSkgeyBuYW1lID0gdGhpcy52YWx1ZTsgfVxyXG5cdFx0XHRcdFx0cmV0dXJuIHN2Zy5EZWZpbml0aW9uc1tuYW1lXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuaXNVcmxEZWZpbml0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZS5pbmRleE9mKCd1cmwoJykgPT0gMFxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24oZSwgb3BhY2l0eVByb3ApIHtcclxuXHRcdFx0XHRcdHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcclxuXHJcblx0XHRcdFx0XHQvLyBncmFkaWVudFxyXG5cdFx0XHRcdFx0aWYgKGRlZiAhPSBudWxsICYmIGRlZi5jcmVhdGVHcmFkaWVudCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHN2Zy5jdHgsIGUsIG9wYWNpdHlQcm9wKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBwYXR0ZXJuXHJcblx0XHRcdFx0XHRpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZVBhdHRlcm4pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwdCA9IGRlZi5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKTtcclxuXHRcdFx0XHRcdFx0XHRkZWYgPSBkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocHQuaGFzVmFsdWUoKSkgeyBkZWYuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJywgdHJ1ZSkudmFsdWUgPSBwdC52YWx1ZTsgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybiBkZWYuY3JlYXRlUGF0dGVybihzdmcuY3R4LCBlKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsZW5ndGggZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RFBJID0gZnVuY3Rpb24odmlld1BvcnQpIHtcclxuXHRcdFx0XHRcdHJldHVybiA5Ni4wOyAvLyBUT0RPOiBjb21wdXRlP1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRFTSA9IGZ1bmN0aW9uKHZpZXdQb3J0KSB7XHJcblx0XHRcdFx0XHR2YXIgZW0gPSAxMjtcclxuXHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0aWYgKGZvbnRTaXplLmhhc1ZhbHVlKCkpIGVtID0gZm9udFNpemUudG9QaXhlbHModmlld1BvcnQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBlbTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VW5pdHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBzID0gdGhpcy52YWx1ZSsnJztcclxuXHRcdFx0XHRcdHJldHVybiBzLnJlcGxhY2UoL1swLTlcXC5cXC1dL2csJycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSBsZW5ndGggYXMgcGl4ZWxzXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b1BpeGVscyA9IGZ1bmN0aW9uKHZpZXdQb3J0LCBwcm9jZXNzUGVyY2VudCkge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2VtJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXRFTSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvZXgkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KSAvIDIuMDtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9weCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9wdCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RFBJKHZpZXdQb3J0KSAqICgxLjAgLyA3Mi4wKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9wYyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDE1O1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2NtJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpIC8gMi41NDtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9tbSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RFBJKHZpZXdQb3J0KSAvIDI1LjQ7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvaW4kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvJSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHR2YXIgbiA9IHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHRcdGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSByZXR1cm4gbiAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gbjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aW1lIGV4dGVuc2lvbnNcclxuXHRcdFx0XHQvLyBnZXQgdGhlIHRpbWUgYXMgbWlsbGlzZWNvbmRzXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b01pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL3MkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAxMDAwO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL21zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhbmdsZSBleHRlbnNpb25zXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSBhbmdsZSBhcyByYWRpYW5zXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b1JhZGlhbnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcclxuXHRcdFx0XHRcdHZhciBzID0gdGhpcy52YWx1ZSsnJztcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9kZWckLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9ncmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAyMDAuMCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvcmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRleHQgZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGdldCB0aGUgdGV4dCBiYXNlbGluZVxyXG5cdFx0XHRcdHZhciB0ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xyXG5cdFx0XHRcdFx0J2Jhc2VsaW5lJzogJ2FscGhhYmV0aWMnLFxyXG5cdFx0XHRcdFx0J2JlZm9yZS1lZGdlJzogJ3RvcCcsXHJcblx0XHRcdFx0XHQndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxyXG5cdFx0XHRcdFx0J21pZGRsZSc6ICdtaWRkbGUnLFxyXG5cdFx0XHRcdFx0J2NlbnRyYWwnOiAnbWlkZGxlJyxcclxuXHRcdFx0XHRcdCdhZnRlci1lZGdlJzogJ2JvdHRvbScsXHJcblx0XHRcdFx0XHQndGV4dC1hZnRlci1lZGdlJzogJ2JvdHRvbScsXHJcblx0XHRcdFx0XHQnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxyXG5cdFx0XHRcdFx0J2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXHJcblx0XHRcdFx0XHQnaGFuZ2luZyc6ICdoYW5naW5nJyxcclxuXHRcdFx0XHRcdCdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9UZXh0QmFzZWxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLnZhbHVlXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0Ly8gZm9udHNcclxuXHRcdHN2Zy5Gb250ID0gbmV3IChmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5TdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xyXG5cdFx0XHR0aGlzLlZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xyXG5cdFx0XHR0aGlzLldlaWdodHMgPSAnbm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDB8aW5oZXJpdCc7XHJcblxyXG5cdFx0XHR0aGlzLkNyZWF0ZUZvbnQgPSBmdW5jdGlvbihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xyXG5cdFx0XHRcdHZhciBmID0gaW5oZXJpdCAhPSBudWxsID8gdGhpcy5QYXJzZShpbmhlcml0KSA6IHRoaXMuQ3JlYXRlRm9udCgnJywgJycsICcnLCAnJywgJycsIHN2Zy5jdHguZm9udCk7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgZi5mb250RmFtaWx5LFxyXG5cdFx0XHRcdFx0Zm9udFNpemU6IGZvbnRTaXplIHx8IGYuZm9udFNpemUsXHJcblx0XHRcdFx0XHRmb250U3R5bGU6IGZvbnRTdHlsZSB8fCBmLmZvbnRTdHlsZSxcclxuXHRcdFx0XHRcdGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfHwgZi5mb250V2VpZ2h0LFxyXG5cdFx0XHRcdFx0Zm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50IHx8IGYuZm9udFZhcmlhbnQsXHJcblx0XHRcdFx0XHR0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3RoaXMuZm9udFN0eWxlLCB0aGlzLmZvbnRWYXJpYW50LCB0aGlzLmZvbnRXZWlnaHQsIHRoaXMuZm9udFNpemUsIHRoaXMuZm9udEZhbWlseV0uam9pbignICcpIH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0dGhpcy5QYXJzZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR2YXIgZiA9IHt9O1xyXG5cdFx0XHRcdHZhciBkID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKHMgfHwgJycpKS5zcGxpdCgnICcpO1xyXG5cdFx0XHRcdHZhciBzZXQgPSB7IGZvbnRTaXplOiBmYWxzZSwgZm9udFN0eWxlOiBmYWxzZSwgZm9udFdlaWdodDogZmFsc2UsIGZvbnRWYXJpYW50OiBmYWxzZSB9XHJcblx0XHRcdFx0dmFyIGZmID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPGQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICghc2V0LmZvbnRTdHlsZSAmJiB0aGF0LlN0eWxlcy5pbmRleE9mKGRbaV0pICE9IC0xKSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250U3R5bGUgPSBkW2ldOyBzZXQuZm9udFN0eWxlID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIXNldC5mb250VmFyaWFudCAmJiB0aGF0LlZhcmlhbnRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRWYXJpYW50ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHRydWU7XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICghc2V0LmZvbnRXZWlnaHQgJiYgdGhhdC5XZWlnaHRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHtcdGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250V2VpZ2h0ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHNldC5mb250V2VpZ2h0ID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIXNldC5mb250U2l6ZSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFNpemUgPSBkW2ldLnNwbGl0KCcvJylbMF07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHNldC5mb250U2l6ZSA9IHRydWU7IH1cclxuXHRcdFx0XHRcdGVsc2UgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGZmICs9IGRbaV07IH1cclxuXHRcdFx0XHR9IGlmIChmZiAhPSAnJykgZi5mb250RmFtaWx5ID0gZmY7XHJcblx0XHRcdFx0cmV0dXJuIGY7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHBvaW50cyBhbmQgcGF0aHNcclxuXHRcdHN2Zy5Ub051bWJlckFycmF5ID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcygocyB8fCAnJykucmVwbGFjZSgvLC9nLCAnICcpKSkuc3BsaXQoJyAnKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRhW2ldID0gcGFyc2VGbG9hdChhW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH1cclxuXHRcdHN2Zy5Qb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0dGhpcy54ID0geDtcclxuXHRcdFx0dGhpcy55ID0geTtcclxuXHRcdH1cclxuXHRcdFx0c3ZnLlBvaW50LnByb3RvdHlwZS5hbmdsZVRvID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdHJldHVybiBNYXRoLmF0YW4yKHAueSAtIHRoaXMueSwgcC54IC0gdGhpcy54KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlBvaW50LnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0XHR2YXIgeHAgPSB0aGlzLnggKiB2WzBdICsgdGhpcy55ICogdlsyXSArIHZbNF07XHJcblx0XHRcdFx0dmFyIHlwID0gdGhpcy54ICogdlsxXSArIHRoaXMueSAqIHZbM10gKyB2WzVdO1xyXG5cdFx0XHRcdHRoaXMueCA9IHhwO1xyXG5cdFx0XHRcdHRoaXMueSA9IHlwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0c3ZnLkNyZWF0ZVBvaW50ID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IHN2Zy5Qb2ludChhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHN2Zy5DcmVhdGVQYXRoID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHR2YXIgcGF0aCA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHtcclxuXHRcdFx0XHRwYXRoLnB1c2gobmV3IHN2Zy5Qb2ludChhW2ldLCBhW2krMV0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBib3VuZGluZyBib3hcclxuXHRcdHN2Zy5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7IC8vIHBhc3MgaW4gaW5pdGlhbCBwb2ludHMgaWYgeW91IHdhbnRcclxuXHRcdFx0dGhpcy54MSA9IE51bWJlci5OYU47XHJcblx0XHRcdHRoaXMueTEgPSBOdW1iZXIuTmFOO1xyXG5cdFx0XHR0aGlzLngyID0gTnVtYmVyLk5hTjtcclxuXHRcdFx0dGhpcy55MiA9IE51bWJlci5OYU47XHJcblxyXG5cdFx0XHR0aGlzLnggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDE7IH1cclxuXHRcdFx0dGhpcy55ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkxOyB9XHJcblx0XHRcdHRoaXMud2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxOyB9XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTsgfVxyXG5cclxuXHRcdFx0dGhpcy5hZGRQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRpZiAoeCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy54MSA9IHg7XHJcblx0XHRcdFx0XHRcdHRoaXMueDIgPSB4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcclxuXHRcdFx0XHRcdGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoeSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy55MSA9IHk7XHJcblx0XHRcdFx0XHRcdHRoaXMueTIgPSB5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcclxuXHRcdFx0XHRcdGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuYWRkWCA9IGZ1bmN0aW9uKHgpIHsgdGhpcy5hZGRQb2ludCh4LCBudWxsKTsgfVxyXG5cdFx0XHR0aGlzLmFkZFkgPSBmdW5jdGlvbih5KSB7IHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7IH1cclxuXHJcblx0XHRcdHRoaXMuYWRkQm91bmRpbmdCb3ggPSBmdW5jdGlvbihiYikge1xyXG5cdFx0XHRcdHRoaXMuYWRkUG9pbnQoYmIueDEsIGJiLnkxKTtcclxuXHRcdFx0XHR0aGlzLmFkZFBvaW50KGJiLngyLCBiYi55Mik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XHJcblx0XHRcdFx0dmFyIGNwMXggPSBwMHggKyAyLzMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcclxuXHRcdFx0XHR2YXIgY3AxeSA9IHAweSArIDIvMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxyXG5cdFx0XHRcdHZhciBjcDJ4ID0gY3AxeCArIDEvMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxyXG5cdFx0XHRcdHZhciBjcDJ5ID0gY3AxeSArIDEvMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxyXG5cdFx0XHRcdHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksXHRjcDJ5LCBwMngsIHAyeSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xyXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXHJcblx0XHRcdFx0dmFyIHAwID0gW3AweCwgcDB5XSwgcDEgPSBbcDF4LCBwMXldLCBwMiA9IFtwMngsIHAyeV0sIHAzID0gW3AzeCwgcDN5XTtcclxuXHRcdFx0XHR0aGlzLmFkZFBvaW50KHAwWzBdLCBwMFsxXSk7XHJcblx0XHRcdFx0dGhpcy5hZGRQb2ludChwM1swXSwgcDNbMV0pO1xyXG5cclxuXHRcdFx0XHRmb3IgKGk9MDsgaTw9MTsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZiA9IGZ1bmN0aW9uKHQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGgucG93KDEtdCwgMykgKiBwMFtpXVxyXG5cdFx0XHRcdFx0XHQrIDMgKiBNYXRoLnBvdygxLXQsIDIpICogdCAqIHAxW2ldXHJcblx0XHRcdFx0XHRcdCsgMyAqICgxLXQpICogTWF0aC5wb3codCwgMikgKiBwMltpXVxyXG5cdFx0XHRcdFx0XHQrIE1hdGgucG93KHQsIDMpICogcDNbaV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XHJcblxyXG5cdFx0XHRcdFx0aWYgKGEgPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoYiA9PSAwKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0dmFyIHQgPSAtYyAvIGI7XHJcblx0XHRcdFx0XHRcdGlmICgwIDwgdCAmJiB0IDwgMSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQpKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0KSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcclxuXHRcdFx0XHRcdGlmIChiMmFjIDwgMCkgY29udGludWU7XHJcblx0XHRcdFx0XHR2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuXHRcdFx0XHRcdGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQxKSk7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQxKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuXHRcdFx0XHRcdGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQyKSk7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQyKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlzUG9pbnRJbkJveCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gKHRoaXMueDEgPD0geCAmJiB4IDw9IHRoaXMueDIgJiYgdGhpcy55MSA8PSB5ICYmIHkgPD0gdGhpcy55Mik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcclxuXHRcdFx0dGhpcy5hZGRQb2ludCh4MiwgeTIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRyYW5zZm9ybXNcclxuXHRcdHN2Zy5UcmFuc2Zvcm0gPSBmdW5jdGlvbih2KSB7XHJcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0dGhpcy5UeXBlID0ge31cclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZVxyXG5cdFx0XHR0aGlzLlR5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMucCA9IHN2Zy5DcmVhdGVQb2ludChzKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKC0xLjAgKiB0aGlzLnAueCB8fCAwLjAsIC0xLjAgKiB0aGlzLnAueSB8fCAwLjApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByb3RhdGVcclxuXHRcdFx0dGhpcy5UeXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHRcdHRoaXMuYW5nbGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdhbmdsZScsIGFbMF0pO1xyXG5cdFx0XHRcdHRoaXMuY3ggPSBhWzFdIHx8IDA7XHJcblx0XHRcdFx0dGhpcy5jeSA9IGFbMl0gfHwgMDtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSh0aGlzLmFuZ2xlLnRvUmFkaWFucygpKTtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXRoaXMuY3gsIC10aGlzLmN5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtMS4wICogdGhpcy5hbmdsZS50b1JhZGlhbnMoKSk7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKC10aGlzLmN4LCAtdGhpcy5jeSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLmFuZ2xlLnRvUmFkaWFucygpO1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgdGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjBdKTtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKGEpLCBNYXRoLnNpbihhKSwgLU1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwgMCwgMF0pO1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLXRoaXMucC54IHx8IDAuMCwgLXRoaXMucC55IHx8IDAuMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5UeXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMucCA9IHN2Zy5DcmVhdGVQb2ludChzKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHguc2NhbGUodGhpcy5wLnggfHwgMS4wLCB0aGlzLnAueSB8fCB0aGlzLnAueCB8fCAxLjApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC5zY2FsZSgxLjAgLyB0aGlzLnAueCB8fCAxLjAsIDEuMCAvIHRoaXMucC55IHx8IHRoaXMucC54IHx8IDEuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbdGhpcy5wLnggfHwgMC4wLCAwLCAwLCB0aGlzLnAueSB8fCAwLjAsIDAsIDBdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuVHlwZS5tYXRyaXggPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5tID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XHJcblx0XHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zZm9ybSh0aGlzLm1bMF0sIHRoaXMubVsxXSwgdGhpcy5tWzJdLCB0aGlzLm1bM10sIHRoaXMubVs0XSwgdGhpcy5tWzVdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMubVswXTtcclxuXHRcdFx0XHRcdHZhciBiID0gdGhpcy5tWzJdO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSB0aGlzLm1bNF07XHJcblx0XHRcdFx0XHR2YXIgZCA9IHRoaXMubVsxXTtcclxuXHRcdFx0XHRcdHZhciBlID0gdGhpcy5tWzNdO1xyXG5cdFx0XHRcdFx0dmFyIGYgPSB0aGlzLm1bNV07XHJcblx0XHRcdFx0XHR2YXIgZyA9IDAuMDtcclxuXHRcdFx0XHRcdHZhciBoID0gMC4wO1xyXG5cdFx0XHRcdFx0dmFyIGkgPSAxLjA7XHJcblx0XHRcdFx0XHR2YXIgZGV0ID0gMSAvIChhKihlKmktZipoKS1iKihkKmktZipnKStjKihkKmgtZSpnKSk7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNmb3JtKFxyXG5cdFx0XHRcdFx0XHRkZXQqKGUqaS1mKmgpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGYqZy1kKmkpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGMqaC1iKmkpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGEqaS1jKmcpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGIqZi1jKmUpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGMqZC1hKmYpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0odGhpcy5tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuVHlwZS5Ta2V3QmFzZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2UgPSB0aGF0LlR5cGUubWF0cml4O1xyXG5cdFx0XHRcdHRoaXMuYmFzZShzKTtcclxuXHRcdFx0XHR0aGlzLmFuZ2xlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnYW5nbGUnLCBzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLlR5cGUuU2tld0Jhc2UucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5tYXRyaXg7XHJcblxyXG5cdFx0XHR0aGlzLlR5cGUuc2tld1ggPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlID0gdGhhdC5UeXBlLlNrZXdCYXNlO1xyXG5cdFx0XHRcdHRoaXMuYmFzZShzKTtcclxuXHRcdFx0XHR0aGlzLm0gPSBbMSwgMCwgTWF0aC50YW4odGhpcy5hbmdsZS50b1JhZGlhbnMoKSksIDEsIDAsIDBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuVHlwZS5za2V3WC5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xyXG5cclxuXHRcdFx0dGhpcy5UeXBlLnNrZXdZID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5Ta2V3QmFzZTtcclxuXHRcdFx0XHR0aGlzLmJhc2Uocyk7XHJcblx0XHRcdFx0dGhpcy5tID0gWzEsIE1hdGgudGFuKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLlR5cGUuc2tld1kucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5Ta2V3QmFzZTtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT10aGlzLnRyYW5zZm9ybXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xyXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zW2ldLnVuYXBwbHkoY3R4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseVRvUG9pbnQocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcyh2KSkucmVwbGFjZSgvXFwpKFthLXpBLVpdKS9nLCAnKSAkMScpLnJlcGxhY2UoL1xcKShcXHM/LFxccz8pL2csJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciB0eXBlID0gc3ZnLnRyaW0oZGF0YVtpXS5zcGxpdCgnKCcpWzBdKTtcclxuXHRcdFx0XHR2YXIgcyA9IGRhdGFbaV0uc3BsaXQoJygnKVsxXS5yZXBsYWNlKCcpJywnJyk7XHJcblx0XHRcdFx0dmFyIHRyYW5zZm9ybVR5cGUgPSB0aGlzLlR5cGVbdHlwZV07XHJcblx0XHRcdFx0aWYgKHR5cGVvZiB0cmFuc2Zvcm1UeXBlICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gbmV3IHRyYW5zZm9ybVR5cGUocyk7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0udHlwZSA9IHR5cGU7XHJcblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFzcGVjdCByYXRpb1xyXG5cdFx0c3ZnLkFzcGVjdFJhdGlvID0gZnVuY3Rpb24oY3R4LCBhc3BlY3RSYXRpbywgd2lkdGgsIGRlc2lyZWRXaWR0aCwgaGVpZ2h0LCBkZXNpcmVkSGVpZ2h0LCBtaW5YLCBtaW5ZLCByZWZYLCByZWZZKSB7XHJcblx0XHRcdC8vIGFzcGVjdCByYXRpbyAtIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlXHJcblx0XHRcdGFzcGVjdFJhdGlvID0gc3ZnLmNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKTtcclxuXHRcdFx0YXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpby5yZXBsYWNlKC9eZGVmZXJcXHMvLCcnKTsgLy8gaWdub3JlIGRlZmVyXHJcblx0XHRcdHZhciBhbGlnbiA9IGFzcGVjdFJhdGlvLnNwbGl0KCcgJylbMF0gfHwgJ3hNaWRZTWlkJztcclxuXHRcdFx0dmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVsxXSB8fCAnbWVldCc7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgc2NhbGVcclxuXHRcdFx0dmFyIHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xyXG5cdFx0XHR2YXIgc2NhbGVZID0gaGVpZ2h0IC8gZGVzaXJlZEhlaWdodDtcclxuXHRcdFx0dmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xyXG5cdFx0XHR2YXIgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XHJcblx0XHRcdGlmIChtZWV0T3JTbGljZSA9PSAnbWVldCcpIHsgZGVzaXJlZFdpZHRoICo9IHNjYWxlTWluOyBkZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluOyB9XHJcblx0XHRcdGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSB7IGRlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDsgZGVzaXJlZEhlaWdodCAqPSBzY2FsZU1heDsgfVxyXG5cclxuXHRcdFx0cmVmWCA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCByZWZYKTtcclxuXHRcdFx0cmVmWSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlknLCByZWZZKTtcclxuXHRcdFx0aWYgKHJlZlguaGFzVmFsdWUoKSAmJiByZWZZLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlgudG9QaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWS50b1BpeGVscygneScpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBhbGlnblxyXG5cdFx0XHRcdGlmIChhbGlnbi5tYXRjaCgvXnhNaWQvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVkpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWSkpKSBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZGVzaXJlZFdpZHRoIC8gMi4wLCAwKTtcclxuXHRcdFx0XHRpZiAoYWxpZ24ubWF0Y2goL1lNaWQkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBkZXNpcmVkSGVpZ2h0IC8gMi4wKTtcclxuXHRcdFx0XHRpZiAoYWxpZ24ubWF0Y2goL154TWF4LykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVZKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVkpKSkgY3R4LnRyYW5zbGF0ZSh3aWR0aCAtIGRlc2lyZWRXaWR0aCwgMCk7XHJcblx0XHRcdFx0aWYgKGFsaWduLm1hdGNoKC9ZTWF4JC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWCkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVYKSkpIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC0gZGVzaXJlZEhlaWdodCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNjYWxlXHJcblx0XHRcdGlmIChhbGlnbiA9PSAnbm9uZScpIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XHJcblx0XHRcdGVsc2UgaWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7XHJcblx0XHRcdGVsc2UgaWYgKG1lZXRPclNsaWNlID09ICdzbGljZScpIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNsYXRlXHJcblx0XHRcdGN0eC50cmFuc2xhdGUobWluWCA9PSBudWxsID8gMCA6IC1taW5YLCBtaW5ZID09IG51bGwgPyAwIDogLW1pblkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVsZW1lbnRzXHJcblx0XHRzdmcuRWxlbWVudCA9IHt9XHJcblxyXG5cdFx0c3ZnLkVtcHR5UHJvcGVydHkgPSBuZXcgc3ZnLlByb3BlcnR5KCdFTVBUWScsICcnKTtcclxuXHJcblx0XHRzdmcuRWxlbWVudC5FbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblx0XHRcdHRoaXMuc3R5bGVzID0ge307XHJcblx0XHRcdHRoaXMuc3R5bGVzU3BlY2lmaWNpdHkgPSB7fTtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHRcdFx0Ly8gZ2V0IG9yIGNyZWF0ZSBhdHRyaWJ1dGVcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVJZk5vdEV4aXN0cykge1xyXG5cdFx0XHRcdHZhciBhID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xyXG5cdFx0XHRcdGlmIChhICE9IG51bGwpIHJldHVybiBhO1xyXG5cclxuXHRcdFx0XHRpZiAoY3JlYXRlSWZOb3RFeGlzdHMgPT0gdHJ1ZSkgeyBhID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCAnJyk7IHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGE7IH1cclxuXHRcdFx0XHRyZXR1cm4gYSB8fCBzdmcuRW1wdHlQcm9wZXJ0eTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRIcmVmQXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgYSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcclxuXHRcdFx0XHRcdGlmIChhID09ICdocmVmJyB8fCBhLm1hdGNoKC86aHJlZiQvKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2FdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gc3ZnLkVtcHR5UHJvcGVydHk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGdldCBvciBjcmVhdGUgc3R5bGUsIGNyYXdscyB1cCBub2RlIHRyZWVcclxuXHRcdFx0dGhpcy5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzLCBza2lwQW5jZXN0b3JzKSB7XHJcblx0XHRcdFx0dmFyIHMgPSB0aGlzLnN0eWxlc1tuYW1lXTtcclxuXHRcdFx0XHRpZiAocyAhPSBudWxsKSByZXR1cm4gcztcclxuXHJcblx0XHRcdFx0dmFyIGEgPSB0aGlzLmF0dHJpYnV0ZShuYW1lKTtcclxuXHRcdFx0XHRpZiAoYSAhPSBudWxsICYmIGEuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdHlsZXNbbmFtZV0gPSBhOyAvLyBtb3ZlIHVwIHRvIG1lIHRvIGNhY2hlXHJcblx0XHRcdFx0XHRyZXR1cm4gYTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChza2lwQW5jZXN0b3JzICE9IHRydWUpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5wYXJlbnQ7XHJcblx0XHRcdFx0XHRpZiAocCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwcyA9IHAuc3R5bGUobmFtZSk7XHJcblx0XHRcdFx0XHRcdGlmIChwcyAhPSBudWxsICYmIHBzLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHM7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PSB0cnVlKSB7IHMgPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsICcnKTsgdGhpcy5zdHlsZXNbbmFtZV0gPSBzOyB9XHJcblx0XHRcdFx0cmV0dXJuIHMgfHwgc3ZnLkVtcHR5UHJvcGVydHk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJhc2UgcmVuZGVyXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gZG9uJ3QgcmVuZGVyIGRpc3BsYXk9bm9uZVxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT0gJ25vbmUnKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT0gJ2hpZGRlbicpIHJldHVybjtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHsgLy8gbWFza1xyXG5cdFx0XHRcdFx0dmFyIG1hc2sgPSB0aGlzLnN0eWxlKCdtYXNrJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0aWYgKG1hc2sgIT0gbnVsbCkgbWFzay5hcHBseShjdHgsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdmaWx0ZXInKS5oYXNWYWx1ZSgpKSB7IC8vIGZpbHRlclxyXG5cdFx0XHRcdFx0dmFyIGZpbHRlciA9IHRoaXMuc3R5bGUoJ2ZpbHRlcicpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdGlmIChmaWx0ZXIgIT0gbnVsbCkgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRDb250ZXh0KGN0eCk7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7XHJcblx0XHRcdFx0XHR0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiYXNlIHNldCBjb250ZXh0XHJcblx0XHRcdHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE9WRVJSSURFIE1FIVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiYXNlIGNsZWFyIGNvbnRleHRcclxuXHRcdFx0dGhpcy5jbGVhckNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBPVkVSUklERSBNRSFcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmFzZSByZW5kZXIgY2hpbGRyZW5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkTm9kZSwgY3JlYXRlKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGROb2RlO1xyXG5cdFx0XHRcdGlmIChjcmVhdGUpIGNoaWxkID0gc3ZnLkNyZWF0ZUVsZW1lbnQoY2hpbGROb2RlKTtcclxuXHRcdFx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRcdGlmIChjaGlsZC50eXBlICE9ICd0aXRsZScpIHsgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdC8vIGFkZCBzdHlsZXNcclxuXHRcdFx0XHRmb3IgKHZhciBzZWxlY3RvciBpbiBzdmcuU3R5bGVzKSB7XHJcblx0XHRcdFx0XHRpZiAoc2VsZWN0b3JbMF0gIT0gJ0AnICYmIG1hdGNoZXNTZWxlY3Rvcihub2RlLCBzZWxlY3RvcikpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHN0eWxlcyA9IHN2Zy5TdHlsZXNbc2VsZWN0b3JdO1xyXG5cdFx0XHRcdFx0XHR2YXIgc3BlY2lmaWNpdHkgPSBzdmcuU3R5bGVzU3BlY2lmaWNpdHlbc2VsZWN0b3JdO1xyXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0aW5nU3BlY2lmaWNpdHkgPSAnMDAwJztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzcGVjaWZpY2l0eSA+IGV4aXN0aW5nU3BlY2lmaWNpdHkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV0gPSBzcGVjaWZpY2l0eTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBNaWNyb3NvZnQgRWRnZSBmaXhcclxuXHRcdFx0dmFyIGFsbFVwcGVyY2FzZSA9IG5ldyBSZWdFeHAoXCJeW0EtWlxcLV0rJFwiKTtcclxuXHRcdFx0dmFyIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdGlmIChhbGxVcHBlcmNhc2UudGVzdChuYW1lKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG5hbWU7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAobm9kZSAhPSBudWxsICYmIG5vZGUubm9kZVR5cGUgPT0gMSkgeyAvL0VMRU1FTlRfTk9ERVxyXG5cdFx0XHRcdC8vIGFkZCBhdHRyaWJ1dGVzXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tpXTtcclxuXHRcdFx0XHRcdHZhciBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgc3ZnLlByb3BlcnR5KG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XHJcblxyXG5cdFx0XHRcdC8vIGFkZCBpbmxpbmUgc3R5bGVzXHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBzdHlsZXMgPSB0aGlzLmF0dHJpYnV0ZSgnc3R5bGUnKS52YWx1ZS5zcGxpdCgnOycpO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3ZnLnRyaW0oc3R5bGVzW2ldKSAhPSAnJykge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdHlsZSA9IHN0eWxlc1tpXS5zcGxpdCgnOicpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBuYW1lID0gc3ZnLnRyaW0oc3R5bGVbMF0pO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHN2Zy50cmltKHN0eWxlWzFdKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlc1tuYW1lXSA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgdmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBhZGQgaWRcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2lkJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0aWYgKHN2Zy5EZWZpbml0aW9uc1t0aGlzLmF0dHJpYnV0ZSgnaWQnKS52YWx1ZV0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRzdmcuRGVmaW5pdGlvbnNbdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdID0gdGhpcztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGFkZCBjaGlsZHJlblxyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2RlLmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09IDEpIHRoaXMuYWRkQ2hpbGQoY2hpbGROb2RlLCB0cnVlKTsgLy9FTEVNRU5UX05PREVcclxuXHRcdFx0XHRcdGlmICh0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PSA0KSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgdGV4dCA9IGNoaWxkTm9kZS52YWx1ZSB8fCBjaGlsZE5vZGUudGV4dCB8fCBjaGlsZE5vZGUudGV4dENvbnRlbnQgfHwgJyc7XHJcblx0XHRcdFx0XHRcdGlmIChzdmcuY29tcHJlc3NTcGFjZXModGV4dCkgIT0gJycpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZENoaWxkKG5ldyBzdmcuRWxlbWVudC50c3BhbihjaGlsZE5vZGUpLCBmYWxzZSk7IC8vIFRFWFRfTk9ERVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIGZpbGxcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHR2YXIgZnMgPSB0aGlzLnN0eWxlKCdmaWxsJykuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCB0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKSk7XHJcblx0XHRcdFx0XHRpZiAoZnMgIT0gbnVsbCkgY3R4LmZpbGxTdHlsZSA9IGZzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdmaWxsJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIGZpbGxTdHlsZSA9IHRoaXMuc3R5bGUoJ2ZpbGwnKTtcclxuXHRcdFx0XHRcdGlmIChmaWxsU3R5bGUudmFsdWUgPT0gJ2N1cnJlbnRDb2xvcicpIGZpbGxTdHlsZS52YWx1ZSA9IHRoaXMuc3R5bGUoJ2NvbG9yJykudmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoZmlsbFN0eWxlLnZhbHVlICE9ICdpbmhlcml0JykgY3R4LmZpbGxTdHlsZSA9IChmaWxsU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmaWxsJywgY3R4LmZpbGxTdHlsZSk7XHJcblx0XHRcdFx0XHRmaWxsU3R5bGUgPSBmaWxsU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKSk7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc3Ryb2tlXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZScpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHR2YXIgZnMgPSB0aGlzLnN0eWxlKCdzdHJva2UnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykpO1xyXG5cdFx0XHRcdFx0aWYgKGZzICE9IG51bGwpIGN0eC5zdHJva2VTdHlsZSA9IGZzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdzdHJva2UnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlKCdzdHJva2UnKTtcclxuXHRcdFx0XHRcdGlmIChzdHJva2VTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgc3Ryb2tlU3R5bGUudmFsdWUgPSB0aGlzLnN0eWxlKCdjb2xvcicpLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYgKHN0cm9rZVN0eWxlLnZhbHVlICE9ICdpbmhlcml0JykgY3R4LnN0cm9rZVN0eWxlID0gKHN0cm9rZVN0eWxlLnZhbHVlID09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IHN0cm9rZVN0eWxlLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0cm9rZVN0eWxlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnc3Ryb2tlJywgY3R4LnN0cm9rZVN0eWxlKTtcclxuXHRcdFx0XHRcdHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScpKTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLXdpZHRoJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIG5ld0xpbmVXaWR0aCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS13aWR0aCcpLnRvUGl4ZWxzKCk7XHJcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gbmV3TGluZVdpZHRoID09IDAgPyAwLjAwMSA6IG5ld0xpbmVXaWR0aDsgLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwXHJcblx0XHRcdCAgICB9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lY2FwJykuaGFzVmFsdWUoKSkgY3R4LmxpbmVDYXAgPSB0aGlzLnN0eWxlKCdzdHJva2UtbGluZWNhcCcpLnZhbHVlO1xyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nKS5oYXNWYWx1ZSgpKSBjdHgubGluZUpvaW4gPSB0aGlzLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nKS52YWx1ZTtcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKS5oYXNWYWx1ZSgpKSBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0JykudmFsdWU7XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKS5oYXNWYWx1ZSgpICYmIHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKS52YWx1ZSAhPSAnbm9uZScpIHtcclxuXHRcdFx0XHRcdHZhciBnYXBzID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9ICd1bmRlZmluZWQnKSB7IGN0eC5zZXRMaW5lRGFzaChnYXBzKTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaCAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzOyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aD09MSAmJiBnYXBzWzBdPT0wKSkgeyBjdHgubW96RGFzaCA9IGdhcHM7IH1cclxuXHJcblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKS5udW1WYWx1ZU9yRGVmYXVsdCgxKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3R4LmxpbmVEYXNoT2Zmc2V0ICE9ICd1bmRlZmluZWQnKSB7IGN0eC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7IH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBjdHgubW96RGFzaE9mZnNldCAhPSAndW5kZWZpbmVkJykgeyBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDsgfVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZm9udFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgY3R4LmZvbnQgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdGN0eC5mb250ID0gc3ZnLkZvbnQuQ3JlYXRlRm9udChcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC1zdHlsZScpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlKCdmb250LXZhcmlhbnQnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC13ZWlnaHQnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC1zaXplJykuaGFzVmFsdWUoKSA/IHRoaXMuc3R5bGUoJ2ZvbnQtc2l6ZScpLnRvUGl4ZWxzKCkgKyAncHgnIDogJycsXHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUoJ2ZvbnQtZmFtaWx5JykudmFsdWUpLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyB0cmFuc2Zvcm1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBuZXcgc3ZnLlRyYW5zZm9ybSh0aGlzLnN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSkudmFsdWUpO1xyXG5cdFx0XHRcdFx0dHJhbnNmb3JtLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjbGlwXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgY2xpcCA9IHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0XHRpZiAoY2xpcCAhPSBudWxsKSBjbGlwLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBvcGFjaXR5XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ29wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnN0eWxlKCdvcGFjaXR5JykubnVtVmFsdWUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHRoaXMucGF0aChjdHgpO1xyXG5cdFx0XHRcdHN2Zy5Nb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcclxuXHRcdFx0XHRpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlT3JEZWZhdWx0KCdpbmhlcml0JykgIT0gJ2luaGVyaXQnKSB7IGN0eC5maWxsKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlKTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSB7IGN0eC5maWxsKCk7IH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGN0eC5zdHJva2VTdHlsZSAhPSAnJykgY3R4LnN0cm9rZSgpO1xyXG5cclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xyXG5cdFx0XHRcdGlmIChtYXJrZXJzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdtYXJrZXItc3RhcnQnKS5pc1VybERlZmluaXRpb24oKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLXN0YXJ0JykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1swXVswXSwgbWFya2Vyc1swXVsxXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnbWFya2VyLW1pZCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpPTE7aTxtYXJrZXJzLmxlbmd0aC0xO2krKykge1xyXG5cdFx0XHRcdFx0XHRcdG1hcmtlci5yZW5kZXIoY3R4LCBtYXJrZXJzW2ldWzBdLCBtYXJrZXJzW2ldWzFdKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5pc1VybERlZmluaXRpb24oKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLWVuZCcpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdFx0bWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMF0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnBhdGgoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBzdmcgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuc3ZnID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VDbGVhckNvbnRleHQgPSB0aGlzLmNsZWFyQ29udGV4dDtcclxuXHRcdFx0dGhpcy5jbGVhckNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2VDbGVhckNvbnRleHQoY3R4KTtcclxuXHRcdFx0XHRzdmcuVmlld1BvcnQuUmVtb3ZlQ3VycmVudCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xyXG5cdFx0XHR0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcclxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XHJcblx0XHRcdFx0Y3R4LmxpbmVDYXAgPSAnYnV0dCc7XHJcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ21pdGVyJztcclxuXHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IDQ7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBjdHguZm9udCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3R4LmNhbnZhcykuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgneCcsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IDA7XHJcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XHJcblxyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHN2Zy5WaWV3UG9ydC53aWR0aCgpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSBzdmcuVmlld1BvcnQuaGVpZ2h0KCk7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gJzEwMCUnO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5yb290ID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHR3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgeCA9IDA7XHJcblx0XHRcdFx0XHR2YXIgeSA9IDA7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS5oYXNWYWx1ZSgpICYmIHRoaXMuYXR0cmlidXRlKCdyZWZZJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHR4ID0gLXRoaXMuYXR0cmlidXRlKCdyZWZYJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdFx0eSA9IC10aGlzLmF0dHJpYnV0ZSgncmVmWScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvdmVyZmxvdycpLnZhbHVlT3JEZWZhdWx0KCdoaWRkZW4nKSAhPSAndmlzaWJsZScpIHtcclxuXHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHdpZHRoLCB5KTtcclxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh4LCBoZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0XHRcdGN0eC5jbGlwKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN2Zy5WaWV3UG9ydC5TZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdFx0XHQvLyB2aWV3Ym94XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHZpZXdCb3ggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdHZhciBtaW5YID0gdmlld0JveFswXTtcclxuXHRcdFx0XHRcdHZhciBtaW5ZID0gdmlld0JveFsxXTtcclxuXHRcdFx0XHRcdHdpZHRoID0gdmlld0JveFsyXTtcclxuXHRcdFx0XHRcdGhlaWdodCA9IHZpZXdCb3hbM107XHJcblxyXG5cdFx0XHRcdFx0c3ZnLkFzcGVjdFJhdGlvKGN0eCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3ZnLlZpZXdQb3J0LndpZHRoKCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdmcuVmlld1BvcnQuaGVpZ2h0KCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWluWCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWluWSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0c3ZnLlZpZXdQb3J0LlJlbW92ZUN1cnJlbnQoKTtcclxuXHRcdFx0XHRcdHN2Zy5WaWV3UG9ydC5TZXRDdXJyZW50KHZpZXdCb3hbMl0sIHZpZXdCb3hbM10pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuc3ZnLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHJlY3QgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQucmVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgcnggPSB0aGlzLmF0dHJpYnV0ZSgncngnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciByeSA9IHRoaXMuYXR0cmlidXRlKCdyeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkpIHJ5ID0gcng7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkpIHJ4ID0gcnk7XHJcblx0XHRcdFx0cnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xyXG5cdFx0XHRcdHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHggKyByeCwgeSk7XHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcnkpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XHJcblx0XHRcdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHgsIHkgKyByeSk7XHJcblx0XHRcdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcngsIHkpXHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5yZWN0LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gY2lyY2xlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmNpcmNsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgY3ggPSB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBjeSA9IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIHIgPSB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCk7XHJcblxyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmNpcmNsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGVsbGlwc2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuZWxsaXBzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xyXG5cdFx0XHRcdHZhciByeCA9IHRoaXMuYXR0cmlidXRlKCdyeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHJ5ID0gdGhpcy5hdHRyaWJ1dGUoJ3J5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgY3ggPSB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBjeSA9IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjeCwgY3kgLSByeSk7XHJcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCArIChLQVBQQSAqIHJ4KSwgY3kgLSByeSwgIGN4ICsgcngsIGN5IC0gKEtBUFBBICogcnkpLCBjeCArIHJ4LCBjeSk7XHJcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggKyAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gKEtBUFBBICogcngpLCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggLSByeCwgY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSAoS0FQUEEgKiByeSksIGN4IC0gKEtBUFBBICogcngpLCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZWxsaXBzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGxpbmUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQubGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFBvaW50cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0XHRuZXcgc3ZnLlBvaW50KHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5MScpLnRvUGl4ZWxzKCd5JykpLFxyXG5cdFx0XHRcdFx0bmV3IHN2Zy5Qb2ludCh0aGlzLmF0dHJpYnV0ZSgneDInKS50b1BpeGVscygneCcpLCB0aGlzLmF0dHJpYnV0ZSgneTInKS50b1BpeGVscygneScpKV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xyXG5cclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSwgcG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XHJcblx0XHRcdFx0dmFyIGEgPSBwb2ludHNbMF0uYW5nbGVUbyhwb2ludHNbMV0pO1xyXG5cdFx0XHRcdHJldHVybiBbW3BvaW50c1swXSwgYV0sIFtwb2ludHNbMV0sIGFdXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQubGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHBvbHlsaW5lIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnBvbHlsaW5lID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucG9pbnRzID0gc3ZnLkNyZWF0ZVBhdGgodGhpcy5hdHRyaWJ1dGUoJ3BvaW50cycpLnZhbHVlKTtcclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAodmFyIGk9MTsgaTx0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0YmIuYWRkUG9pbnQodGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XHJcblx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8odGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0XHRcdFx0XHRtYXJrZXJzLnB1c2goW3RoaXMucG9pbnRzW2ldLCB0aGlzLnBvaW50c1tpXS5hbmdsZVRvKHRoaXMucG9pbnRzW2krMV0pXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdG1hcmtlcnMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoLTFdLCBtYXJrZXJzW21hcmtlcnMubGVuZ3RoLTFdWzFdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBtYXJrZXJzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5wb2x5bGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHBvbHlnb24gZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQucG9seWdvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucG9seWxpbmU7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYmFzZVBhdGggPSB0aGlzLnBhdGg7XHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBiYiA9IHRoaXMuYmFzZVBhdGgoY3R4KTtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQucG9seWdvbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucG9seWxpbmU7XHJcblxyXG5cdFx0Ly8gcGF0aCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5wYXRoID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBkID0gdGhpcy5hdHRyaWJ1dGUoJ2QnKS52YWx1ZTtcclxuXHRcdFx0Ly8gVE9ETzogY29udmVydCB0byByZWFsIGxleGVyIGJhc2VkIG9uIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhdGhzLmh0bWwjUGF0aERhdGFCTkZcclxuXHRcdFx0ZCA9IGQucmVwbGFjZSgvLC9nbSwnICcpOyAvLyBnZXQgcmlkIG9mIGFsbCBjb21tYXNcclxuXHRcdFx0Ly8gQXMgdGhlIGVuZCBvZiBhIG1hdGNoIGNhbiBhbHNvIGJlIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBtYXRjaCwgd2UgbmVlZCB0byBydW4gdGhpcyByZXBsYWNlIHR3aWNlLlxyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTwyOyBpKyspXHJcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSgvKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pKFteXFxzXSkvZ20sJyQxICQyJyk7IC8vIHN1ZmZpeCBjb21tYW5kcyB3aXRoIHNwYWNlc1xyXG5cdFx0XHRkID0gZC5yZXBsYWNlKC8oW15cXHNdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gcHJlZml4IGNvbW1hbmRzIHdpdGggc3BhY2VzXHJcblx0XHRcdGQgPSBkLnJlcGxhY2UoLyhbMC05XSkoWytcXC1dKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIG9uICstIHNpZ25zXHJcblx0XHRcdC8vIEFnYWluLCB3ZSBuZWVkIHRvIHJ1biB0aGlzIHR3aWNlIHRvIGZpbmQgYWxsIG9jY3VyYW5jZXNcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MjsgaSsrKVxyXG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoLyhcXC5bMC05XSopKFxcLikvZ20sJyQxICQyJyk7IC8vIHNlcGFyYXRlIGRpZ2l0cyB3aGVuIHRoZXkgc3RhcnQgd2l0aCBhIGNvbW1hXHJcblx0XHRcdGQgPSBkLnJlcGxhY2UoLyhbQWFdKFxccytbMC05XSspezN9KVxccysoWzAxXSlcXHMqKFswMV0pL2dtLCckMSAkMyAkNCAnKTsgLy8gc2hvcnRoYW5kIGVsbGlwdGljYWwgYXJjIHBhdGggc3ludGF4XHJcblx0XHRcdGQgPSBzdmcuY29tcHJlc3NTcGFjZXMoZCk7IC8vIGNvbXByZXNzIG11bHRpcGxlIHNwYWNlc1xyXG5cdFx0XHRkID0gc3ZnLnRyaW0oZCk7XHJcblx0XHRcdHRoaXMuUGF0aFBhcnNlciA9IG5ldyAoZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdHRoaXMudG9rZW5zID0gZC5zcGxpdCgnICcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0aGlzLmkgPSAtMTtcclxuXHRcdFx0XHRcdHRoaXMuY29tbWFuZCA9ICcnO1xyXG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQgPSAnJztcclxuXHRcdFx0XHRcdHRoaXMuc3RhcnQgPSBuZXcgc3ZnLlBvaW50KDAsIDApO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XHJcblx0XHRcdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0XHRcdFx0dGhpcy5hbmdsZXMgPSBbXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNFbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmkgPj0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNDb21tYW5kT3JFbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLmlzRW5kKCkpIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaSArIDFdLm1hdGNoKC9eW0EtWmEtel0kLykgIT0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNSZWxhdGl2ZUNvbW1hbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHN3aXRjaCh0aGlzLmNvbW1hbmQpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ20nOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdsJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnaCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3YnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdjJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3EnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3onOlxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pKys7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0U2NhbGFyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldFRva2VuKCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5uZXh0Q29tbWFuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XHJcblx0XHRcdFx0XHR0aGlzLmNvbW1hbmQgPSB0aGlzLmdldFRva2VuKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgcCA9IG5ldyBzdmcuUG9pbnQodGhpcy5nZXRTY2FsYXIoKSwgdGhpcy5nZXRTY2FsYXIoKSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldEFzQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgcCA9IHRoaXMuZ2V0UG9pbnQoKTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbCA9IHA7XHJcblx0XHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0QXNDdXJyZW50UG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5nZXRQb2ludCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gcDtcclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICdjJyAmJlxyXG5cdFx0XHRcdFx0ICAgIHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3MnICYmXHJcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3EnICYmXHJcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3QnICl7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVmbGVjdCBwb2ludFxyXG5cdFx0XHRcdFx0dmFyIHAgPSBuZXcgc3ZnLlBvaW50KDIgKiB0aGlzLmN1cnJlbnQueCAtIHRoaXMuY29udHJvbC54LCAyICogdGhpcy5jdXJyZW50LnkgLSB0aGlzLmNvbnRyb2wueSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubWFrZUFic29sdXRlID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNSZWxhdGl2ZUNvbW1hbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRwLnggKz0gdGhpcy5jdXJyZW50Lng7XHJcblx0XHRcdFx0XHRcdHAueSArPSB0aGlzLmN1cnJlbnQueTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRNYXJrZXIgPSBmdW5jdGlvbihwLCBmcm9tLCBwcmlvclRvKSB7XHJcblx0XHRcdFx0XHQvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cclxuXHRcdFx0XHRcdGlmIChwcmlvclRvICE9IG51bGwgJiYgdGhpcy5hbmdsZXMubGVuZ3RoID4gMCAmJiB0aGlzLmFuZ2xlc1t0aGlzLmFuZ2xlcy5sZW5ndGgtMV0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFuZ2xlc1t0aGlzLmFuZ2xlcy5sZW5ndGgtMV0gPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGgtMV0uYW5nbGVUbyhwcmlvclRvKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuYWRkTWFya2VyQW5nbGUocCwgZnJvbSA9PSBudWxsID8gbnVsbCA6IGZyb20uYW5nbGVUbyhwKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmFkZE1hcmtlckFuZ2xlID0gZnVuY3Rpb24ocCwgYSkge1xyXG5cdFx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHRcdHRoaXMuYW5nbGVzLnB1c2goYSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldE1hcmtlclBvaW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb2ludHM7IH1cclxuXHRcdFx0XHR0aGlzLmdldE1hcmtlckFuZ2xlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuYW5nbGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmFuZ2xlc1tpXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaj1pKzE7IGo8dGhpcy5hbmdsZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLmFuZ2xlc1tqXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYW5nbGVzW2ldID0gdGhpcy5hbmdsZXNbal07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYW5nbGVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkoZCk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgcHAgPSB0aGlzLlBhdGhQYXJzZXI7XHJcblx0XHRcdFx0cHAucmVzZXQoKTtcclxuXHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdHdoaWxlICghcHAuaXNFbmQoKSkge1xyXG5cdFx0XHRcdFx0cHAubmV4dENvbW1hbmQoKTtcclxuXHRcdFx0XHRcdHN3aXRjaCAocHAuY29tbWFuZCkge1xyXG5cdFx0XHRcdFx0Y2FzZSAnTSc6XHJcblx0XHRcdFx0XHRjYXNlICdtJzpcclxuXHRcdFx0XHRcdFx0dmFyIHAgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIocCk7XHJcblx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubW92ZVRvKHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0cHAuc3RhcnQgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKHAsIHBwLnN0YXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChwLngsIHAueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0wnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbCc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKHAsIGMpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnSCc6XHJcblx0XHRcdFx0XHRjYXNlICdoJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC54IDogMCkgKyBwcC5nZXRTY2FsYXIoKSwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuY3VycmVudCA9IG5ld1A7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdWJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3YnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbmV3UCA9IG5ldyBzdmcuUG9pbnQocHAuY3VycmVudC54LCAocHAuaXNSZWxhdGl2ZUNvbW1hbmQoKSA/IHBwLmN1cnJlbnQueSA6IDApICsgcHAuZ2V0U2NhbGFyKCkpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihuZXdQLCBwcC5jdXJyZW50KTtcclxuXHRcdFx0XHRcdFx0XHRwcC5jdXJyZW50ID0gbmV3UDtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0MnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcDEgPSBwcC5nZXRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBwMSk7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkQmV6aWVyQ3VydmUoY3Vyci54LCBjdXJyLnksIHAxLngsIHAxLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmJlemllckN1cnZlVG8ocDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdTJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3MnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHAxID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAncSc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY250cmwgPSBwcC5nZXRBc0NvbnRyb2xQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKGNwLCBjbnRybCwgY250cmwpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFF1YWRyYXRpY0N1cnZlKGN1cnIueCwgY3Vyci55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnVCc6XHJcblx0XHRcdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbnRybCA9IHBwLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmNvbnRyb2wgPSBjbnRybDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihjcCwgY250cmwsIGNudHJsKTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyLngsIGN1cnIueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgucXVhZHJhdGljQ3VydmVUbyhjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnYSc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHQgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciByeCA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciByeSA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB4QXhpc1JvdGF0aW9uID0gcHAuZ2V0U2NhbGFyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbGFyZ2VBcmNGbGFnID0gcHAuZ2V0U2NhbGFyKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN3ZWVwRmxhZyA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxyXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xyXG5cdFx0XHRcdFx0XHRcdC8vIHgxJywgeTEnXHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJwID0gbmV3IHN2Zy5Qb2ludChcclxuXHRcdFx0XHRcdFx0XHRcdE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnIueCAtIGNwLngpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci55IC0gY3AueSkgLyAyLjAsXHJcblx0XHRcdFx0XHRcdFx0XHQtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYWRqdXN0IHJhZGlpXHJcblx0XHRcdFx0XHRcdFx0dmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LDIpL01hdGgucG93KHJ4LDIpK01hdGgucG93KGN1cnJwLnksMikvTWF0aC5wb3cocnksMik7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGwgPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyeCAqPSBNYXRoLnNxcnQobCk7XHJcblx0XHRcdFx0XHRcdFx0XHRyeSAqPSBNYXRoLnNxcnQobCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdC8vIGN4JywgY3knXHJcblx0XHRcdFx0XHRcdFx0dmFyIHMgPSAobGFyZ2VBcmNGbGFnID09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoXHJcblx0XHRcdFx0XHRcdFx0XHQoKE1hdGgucG93KHJ4LDIpKk1hdGgucG93KHJ5LDIpKS0oTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKSktKE1hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpKSAvXHJcblx0XHRcdFx0XHRcdFx0XHQoTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKStNYXRoLnBvdyhyeSwyKSpNYXRoLnBvdyhjdXJycC54LDIpKVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHMpKSBzID0gMDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3BwID0gbmV3IHN2Zy5Qb2ludChzICogcnggKiBjdXJycC55IC8gcnksIHMgKiAtcnkgKiBjdXJycC54IC8gcngpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGN4LCBjeVxyXG5cdFx0XHRcdFx0XHRcdHZhciBjZW50cCA9IG5ldyBzdmcuUG9pbnQoXHJcblx0XHRcdFx0XHRcdFx0XHQoY3Vyci54ICsgY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC54IC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueSxcclxuXHRcdFx0XHRcdFx0XHRcdChjdXJyLnkgKyBjcC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHQvLyB2ZWN0b3IgbWFnbml0dWRlXHJcblx0XHRcdFx0XHRcdFx0dmFyIG0gPSBmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwyKSArIE1hdGgucG93KHZbMV0sMikpOyB9XHJcblx0XHRcdFx0XHRcdFx0Ly8gcmF0aW8gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG5cdFx0XHRcdFx0XHRcdHZhciByID0gZnVuY3Rpb24odSwgdikgeyByZXR1cm4gKHVbMF0qdlswXSt1WzFdKnZbMV0pIC8gKG0odSkqbSh2KSkgfVxyXG5cdFx0XHRcdFx0XHRcdC8vIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnNcclxuXHRcdFx0XHRcdFx0XHR2YXIgYSA9IGZ1bmN0aW9uKHUsIHYpIHsgcmV0dXJuICh1WzBdKnZbMV0gPCB1WzFdKnZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHIodSx2KSk7IH1cclxuXHRcdFx0XHRcdFx0XHQvLyBpbml0aWFsIGFuZ2xlXHJcblx0XHRcdFx0XHRcdFx0dmFyIGExID0gYShbMSwwXSwgWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBhbmdsZSBkZWx0YVxyXG5cdFx0XHRcdFx0XHRcdHZhciB1ID0gWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2ID0gWygtY3VycnAueC1jcHAueCkvcngsKC1jdXJycC55LWNwcC55KS9yeV07XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFkID0gYSh1LCB2KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocih1LHYpIDw9IC0xKSBhZCA9IE1hdGguUEk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHIodSx2KSA+PSAxKSBhZCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGZvciBtYXJrZXJzXHJcblx0XHRcdFx0XHRcdFx0dmFyIGRpciA9IDEgLSBzd2VlcEZsYWcgPyAxLjAgOiAtMS4wO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBhaCA9IGExICsgZGlyICogKGFkIC8gMi4wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaGFsZldheSA9IG5ldyBzdmcuUG9pbnQoXHJcblx0XHRcdFx0XHRcdFx0XHRjZW50cC54ICsgcnggKiBNYXRoLmNvcyhhaCksXHJcblx0XHRcdFx0XHRcdFx0XHRjZW50cC55ICsgcnkgKiBNYXRoLnNpbihhaClcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlckFuZ2xlKGNwLCBhaCAtIGRpciAqIE1hdGguUEkpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChjcC54LCBjcC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN4ID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN5ID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnNjYWxlKHN4LCBzeSk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCAxIC0gc3dlZXBGbGFnKTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5zY2FsZSgxL3N4LCAxL3N5KTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1onOlxyXG5cdFx0XHRcdFx0Y2FzZSAneic6XHJcblx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRwcC5jdXJyZW50ID0gcHAuc3RhcnQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYmI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLlBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XHJcblx0XHRcdFx0dmFyIGFuZ2xlcyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcclxuXHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRtYXJrZXJzLnB1c2goW3BvaW50c1tpXSwgYW5nbGVzW2ldXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBtYXJrZXJzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5wYXRoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcGF0dGVybiBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5wYXR0ZXJuID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jcmVhdGVQYXR0ZXJuID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnLCB0cnVlKTtcclxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5JywgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxyXG5cdFx0XHRcdHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4Jyk7XHJcblx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdGMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdFx0XHR2YXIgY2N0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpICYmIHRoaXMuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0Y2N0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcsIHRydWUpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JywgdHJ1ZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xyXG5cdFx0XHRcdGZvciAodmFyIHg9LTE7IHg8PTE7IHgrKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeT0tMTsgeTw9MTsgeSsrKSB7XHJcblx0XHRcdFx0XHRcdGNjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCB4ICogYy53aWR0aCk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIHkgKiBjLmhlaWdodCk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcucmVuZGVyKGNjdHgpO1xyXG5cdFx0XHRcdFx0XHRjY3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihjLCAncmVwZWF0Jyk7XHJcblx0XHRcdFx0cmV0dXJuIHBhdHRlcm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnBhdHRlcm4ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIG1hcmtlciBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5tYXJrZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VSZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIHBvaW50LCBhbmdsZSkge1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUocG9pbnQueCwgcG9pbnQueSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZShhbmdsZSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcclxuXHRcdFx0XHR2YXIgdGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ZpZXdCb3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ZpZXdCb3gnLCB0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCB0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlknXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlknLCB0aGlzLmF0dHJpYnV0ZSgncmVmWScpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHRoaXMuYXR0cmlidXRlKCdtYXJrZXJXaWR0aCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2ZpbGwnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCB0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdibGFjaycpKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3N0cm9rZSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnc3Ryb2tlJywgdGhpcy5hdHRyaWJ1dGUoJ3N0cm9rZScpLnZhbHVlT3JEZWZhdWx0KCdub25lJykpO1xyXG5cdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0XHRcdHRlbXBTdmcucmVuZGVyKGN0eCk7XHJcblxyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZSgxL2N0eC5saW5lV2lkdGgsIDEvY3R4LmxpbmVXaWR0aCk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZSgtYW5nbGUpO1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLXBvaW50LngsIC1wb2ludC55KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQubWFya2VyLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBkZWZpbml0aW9ucyBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5kZWZzID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBOT09QXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmRlZnMucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGJhc2UgZm9yIGdyYWRpZW50c1xyXG5cdFx0c3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5zdG9wcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0aWYgKGNoaWxkLnR5cGUgPT0gJ3N0b3AnKSB0aGlzLnN0b3BzLnB1c2goY2hpbGQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEdyYWRpZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUUhXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuZ3JhZGllbnRVbml0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS52YWx1ZU9yRGVmYXVsdCgnb2JqZWN0Qm91bmRpbmdCb3gnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gWydncmFkaWVudFVuaXRzJ107XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyID0gZnVuY3Rpb24gKHN0b3BzQ29udGFpbmVyKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZVRvSW5oZXJpdCA9IHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdFtpXTtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0LCB0cnVlKS52YWx1ZSA9IHN0b3BzQ29udGFpbmVyLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLnZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcclxuXHRcdFx0XHR2YXIgc3RvcHNDb250YWluZXIgPSB0aGlzO1xyXG5cdFx0XHRcdGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRzdG9wc0NvbnRhaW5lciA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGFkZFBhcmVudE9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuXHRcdFx0XHRcdGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnY29sb3InLCBjb2xvcik7XHJcblx0XHRcdFx0XHRcdHJldHVybiBwLmFkZE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3ApLnZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHZhciBnID0gdGhpcy5nZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpO1xyXG5cdFx0XHRcdGlmIChnID09IG51bGwpIHJldHVybiBhZGRQYXJlbnRPcGFjaXR5KHN0b3BzQ29udGFpbmVyLnN0b3BzW3N0b3BzQ29udGFpbmVyLnN0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8c3RvcHNDb250YWluZXIuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGcuYWRkQ29sb3JTdG9wKHN0b3BzQ29udGFpbmVyLnN0b3BzW2ldLm9mZnNldCwgYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tpXS5jb2xvcikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdC8vIHJlbmRlciBhcyB0cmFuc2Zvcm1lZCBwYXR0ZXJuIG9uIHRlbXBvcmFyeSBjYW52YXNcclxuXHRcdFx0XHRcdHZhciByb290VmlldyA9IHN2Zy5WaWV3UG9ydC52aWV3UG9ydHNbMF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgc3ZnLkVsZW1lbnQucmVjdCgpO1xyXG5cdFx0XHRcdFx0cmVjdC5hdHRyaWJ1dGVzWyd4J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd4JywgLXN2Zy5NQVhfVklSVFVBTF9QSVhFTFMvMy4wKTtcclxuXHRcdFx0XHRcdHJlY3QuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XHJcblx0XHRcdFx0XHRyZWN0LmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMpO1xyXG5cdFx0XHRcdFx0cmVjdC5hdHRyaWJ1dGVzWydoZWlnaHQnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ2hlaWdodCcsIHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XHJcblx0XHRcdFx0XHRncm91cC5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLnZhbHVlKTtcclxuXHRcdFx0XHRcdGdyb3VwLmNoaWxkcmVuID0gWyByZWN0IF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCAwKTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIDApO1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSBbIGdyb3VwIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHRcdFx0XHRcdGMud2lkdGggPSByb290Vmlldy53aWR0aDtcclxuXHRcdFx0XHRcdGMuaGVpZ2h0ID0gcm9vdFZpZXcuaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHR0ZW1wQ3R4LmZpbGxTdHlsZSA9IGc7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLnJlbmRlcih0ZW1wQ3R4KTtcclxuXHRcdFx0XHRcdHJldHVybiB0ZW1wQ3R4LmNyZWF0ZVBhdHRlcm4oYywgJ25vLXJlcGVhdCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbGluZWFyIGdyYWRpZW50IGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd4MScpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneTEnKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gyJyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd5MicpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xyXG5cdFx0XHRcdHZhciBiYiA9IHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KCkgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd4MScsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd5MScsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd4MicsIHRydWUpLnZhbHVlID0gMTtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd5MicsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHQgfVxyXG5cclxuXHRcdFx0XHR2YXIgeDEgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ3gxJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgneDEnKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR2YXIgeTEgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCd5MScpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSk7XHJcblx0XHRcdFx0dmFyIHgyID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCd4MicpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ3gyJykudG9QaXhlbHMoJ3gnKSk7XHJcblx0XHRcdFx0dmFyIHkyID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgneTInKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCd5MicpLnRvUGl4ZWxzKCd5JykpO1xyXG5cclxuXHRcdFx0XHRpZiAoeDEgPT0geDIgJiYgeTEgPT0geTIpIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5saW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xyXG5cclxuXHRcdC8vIHJhZGlhbCBncmFkaWVudCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3gnKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N5Jyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdyJyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdmeCcpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnZnknKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcclxuXHRcdFx0XHR2YXIgYmIgPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2N4JywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCdjeScpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdjeScsIHRydWUpLnZhbHVlID0gJzUwJSc7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdyJywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcclxuXHJcblx0XHRcdFx0dmFyIGN4ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCdjeCcpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ2N4JykudG9QaXhlbHMoJ3gnKSk7XHJcblx0XHRcdFx0dmFyIGN5ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgnY3knKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5JykpO1xyXG5cclxuXHRcdFx0XHR2YXIgZnggPSBjeDtcclxuXHRcdFx0XHR2YXIgZnkgPSBjeTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0ZnggPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ2Z4JykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgnZngnKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdmeScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGZ5ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgnZnknKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdmeScpLnRvUGl4ZWxzKCd5JykpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHIgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyAoYmIud2lkdGgoKSArIGJiLmhlaWdodCgpKSAvIDIuMCAqIHRoaXMuYXR0cmlidXRlKCdyJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCkpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgMCwgY3gsIGN5LCByKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQucmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcclxuXHJcblx0XHQvLyBncmFkaWVudCBzdG9wIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnN0b3AgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLm9mZnNldCA9IHRoaXMuYXR0cmlidXRlKCdvZmZzZXQnKS5udW1WYWx1ZSgpO1xyXG5cdFx0XHRpZiAodGhpcy5vZmZzZXQgPCAwKSB0aGlzLm9mZnNldCA9IDA7XHJcblx0XHRcdGlmICh0aGlzLm9mZnNldCA+IDEpIHRoaXMub2Zmc2V0ID0gMTtcclxuXHJcblx0XHRcdHZhciBzdG9wQ29sb3IgPSB0aGlzLnN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XHJcblx0XHRcdGlmIChzdG9wQ29sb3IudmFsdWUgPT09ICcnKSBzdG9wQ29sb3IudmFsdWUgPSAnIzAwMCc7XHJcblx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKSk7XHJcblx0XHRcdHRoaXMuY29sb3IgPSBzdG9wQ29sb3IudmFsdWU7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zdG9wLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRpb24gYmFzZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5BbmltYXRlQmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHN2Zy5BbmltYXRpb25zLnB1c2godGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gMC4wO1xyXG5cdFx0XHR0aGlzLmJlZ2luID0gdGhpcy5hdHRyaWJ1dGUoJ2JlZ2luJykudG9NaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0dGhpcy5tYXhEdXJhdGlvbiA9IHRoaXMuYmVnaW4gKyB0aGlzLmF0dHJpYnV0ZSgnZHVyJykudG9NaWxsaXNlY29uZHMoKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuYXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykudmFsdWU7XHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoYXR0cmlidXRlVHlwZSA9PSAnQ1NTJykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LnN0eWxlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuYXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5pbml0aWFsVmFsdWUgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xyXG5cdFx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUUhXHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XHJcblx0XHRcdFx0Ly8gc2V0IGluaXRpYWwgdmFsdWVcclxuXHRcdFx0XHRpZiAodGhpcy5pbml0aWFsVmFsdWUgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XHJcblx0XHRcdFx0XHR0aGlzLmluaXRpYWxVbml0cyA9IHRoaXMuZ2V0UHJvcGVydHkoKS5nZXRVbml0cygpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcclxuXHRcdFx0XHRpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLnZhbHVlID09ICdpbmRlZmluaXRlJ1xyXG5cdFx0XHRcdFx0IHx8IHRoaXMuYXR0cmlidXRlKCdyZXBlYXREdXInKS52YWx1ZSA9PSAnaW5kZWZpbml0ZScpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5kdXJhdGlvbiA9IDAuMFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5hdHRyaWJ1dGUoJ2ZpbGwnKS52YWx1ZU9yRGVmYXVsdCgncmVtb3ZlJykgPT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZSA9IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIGRlbHRhO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXHJcblx0XHRcdFx0dmFyIHVwZGF0ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRpZiAodGhpcy5iZWdpbiA8IHRoaXMuZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd0eXBlJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBmb3IgdHJhbnNmb3JtLCBldGMuXHJcblx0XHRcdFx0XHRcdHZhciB0eXBlID0gdGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS52YWx1ZTtcclxuXHRcdFx0XHRcdFx0bmV3VmFsdWUgPSB0eXBlICsgJygnICsgbmV3VmFsdWUgKyAnKSc7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gbmV3VmFsdWU7XHJcblx0XHRcdFx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB1cGRhdGVkO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZyb20gPSB0aGlzLmF0dHJpYnV0ZSgnZnJvbScpO1xyXG5cdFx0XHR0aGlzLnRvID0gdGhpcy5hdHRyaWJ1dGUoJ3RvJyk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gdGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpO1xyXG5cdFx0XHRpZiAodGhpcy52YWx1ZXMuaGFzVmFsdWUoKSkgdGhpcy52YWx1ZXMudmFsdWUgPSB0aGlzLnZhbHVlcy52YWx1ZS5zcGxpdCgnOycpO1xyXG5cclxuXHRcdFx0Ly8gZnJhY3Rpb24gb2YgZHVyYXRpb24gd2UndmUgY292ZXJlZFxyXG5cdFx0XHR0aGlzLnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHJldCA9IHsgcHJvZ3Jlc3M6ICh0aGlzLmR1cmF0aW9uIC0gdGhpcy5iZWdpbikgLyAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMuYmVnaW4pIH07XHJcblx0XHRcdFx0aWYgKHRoaXMudmFsdWVzLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gcmV0LnByb2dyZXNzICogKHRoaXMudmFsdWVzLnZhbHVlLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRcdFx0dmFyIGxiID0gTWF0aC5mbG9vcihwKSwgdWIgPSBNYXRoLmNlaWwocCk7XHJcblx0XHRcdFx0XHRyZXQuZnJvbSA9IG5ldyBzdmcuUHJvcGVydHkoJ2Zyb20nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW2xiXSkpO1xyXG5cdFx0XHRcdFx0cmV0LnRvID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndG8nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW3ViXSkpO1xyXG5cdFx0XHRcdFx0cmV0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0LmZyb20gPSB0aGlzLmZyb207XHJcblx0XHRcdFx0XHRyZXQudG8gPSB0aGlzLnRvO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5BbmltYXRlQmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcclxuXHJcblx0XHRcdFx0Ly8gdHdlZW4gdmFsdWUgbGluZWFybHlcclxuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSBwLmZyb20ubnVtVmFsdWUoKSArIChwLnRvLm51bVZhbHVlKCkgLSBwLmZyb20ubnVtVmFsdWUoKSkgKiBwLnByb2dyZXNzO1xyXG5cdFx0XHRcdHJldHVybiBuZXdWYWx1ZSArIHRoaXMuaW5pdGlhbFVuaXRzO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuYW5pbWF0ZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBjb2xvciBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlQ29sb3IgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcygpO1xyXG5cdFx0XHRcdHZhciBmcm9tID0gbmV3IFJHQkNvbG9yKHAuZnJvbS52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIHRvID0gbmV3IFJHQkNvbG9yKHAudG8udmFsdWUpO1xyXG5cclxuXHRcdFx0XHRpZiAoZnJvbS5vayAmJiB0by5vaykge1xyXG5cdFx0XHRcdFx0Ly8gdHdlZW4gY29sb3IgbGluZWFybHlcclxuXHRcdFx0XHRcdHZhciByID0gZnJvbS5yICsgKHRvLnIgLSBmcm9tLnIpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHZhciBnID0gZnJvbS5nICsgKHRvLmcgLSBmcm9tLmcpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHZhciBiID0gZnJvbS5iICsgKHRvLmIgLSBmcm9tLmIpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHJldHVybiAncmdiKCcrcGFyc2VJbnQociwxMCkrJywnK3BhcnNlSW50KGcsMTApKycsJytwYXJzZUludChiLDEwKSsnKSc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZSgnZnJvbScpLnZhbHVlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuYW5pbWF0ZUNvbG9yLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRlIHRyYW5zZm9ybSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcclxuXHJcblx0XHRcdFx0Ly8gdHdlZW4gdmFsdWUgbGluZWFybHlcclxuXHRcdFx0XHR2YXIgZnJvbSA9IHN2Zy5Ub051bWJlckFycmF5KHAuZnJvbS52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIHRvID0gc3ZnLlRvTnVtYmVyQXJyYXkocC50by52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIG5ld1ZhbHVlID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPGZyb20ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdG5ld1ZhbHVlICs9IGZyb21baV0gKyAodG9baV0gLSBmcm9tW2ldKSAqIHAucHJvZ3Jlc3MgKyAnICc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBuZXdWYWx1ZTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LmFuaW1hdGU7XHJcblxyXG5cdFx0Ly8gZm9udCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5mb250ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5ob3JpekFkdlggPSB0aGlzLmF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5udW1WYWx1ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5pc1JUTCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmlzQXJhYmljID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZm9udEZhY2UgPSBudWxsO1xyXG5cdFx0XHR0aGlzLm1pc3NpbmdHbHlwaCA9IG51bGw7XHJcblx0XHRcdHRoaXMuZ2x5cGhzID0gW107XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHRcdFx0XHRpZiAoY2hpbGQudHlwZSA9PSAnZm9udC1mYWNlJykge1xyXG5cdFx0XHRcdFx0dGhpcy5mb250RmFjZSA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLnN0eWxlKCdmb250LWZhbWlseScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0c3ZnLkRlZmluaXRpb25zW2NoaWxkLnN0eWxlKCdmb250LWZhbWlseScpLnZhbHVlXSA9IHRoaXM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGNoaWxkLnR5cGUgPT0gJ21pc3NpbmctZ2x5cGgnKSB0aGlzLm1pc3NpbmdHbHlwaCA9IGNoaWxkO1xyXG5cdFx0XHRcdGVsc2UgaWYgKGNoaWxkLnR5cGUgPT0gJ2dseXBoJykge1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmFyYWJpY0Zvcm0gIT0gJycpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5pc1JUTCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID09ICd1bmRlZmluZWQnKSB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXVtjaGlsZC5hcmFiaWNGb3JtXSA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID0gY2hpbGQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mb250LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBmb250LWZhY2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuZm9udGZhY2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFzY2VudCA9IHRoaXMuYXR0cmlidXRlKCdhc2NlbnQnKS52YWx1ZTtcclxuXHRcdFx0dGhpcy5kZXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2Rlc2NlbnQnKS52YWx1ZTtcclxuXHRcdFx0dGhpcy51bml0c1BlckVtID0gdGhpcy5hdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLm51bVZhbHVlKCk7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mb250ZmFjZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbWlzc2luZy1nbHlwaCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5taXNzaW5nZ2x5cGggPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBhdGg7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuaG9yaXpBZHZYID0gMDtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50Lm1pc3NpbmdnbHlwaC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucGF0aDtcclxuXHJcblx0XHQvLyBnbHlwaCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5nbHlwaCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5ob3JpekFkdlggPSB0aGlzLmF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5udW1WYWx1ZSgpO1xyXG5cdFx0XHR0aGlzLnVuaWNvZGUgPSB0aGlzLmF0dHJpYnV0ZSgndW5pY29kZScpLnZhbHVlO1xyXG5cdFx0XHR0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS52YWx1ZTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmdseXBoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wYXRoO1xyXG5cclxuXHRcdC8vIHRleHQgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQudGV4dCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4dEJhc2VsaW5lID0gdGhpcy5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnKS50b1RleHRCYXNlbGluZSgpO1xyXG5cdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgPT0gbnVsbCkgdGV4dEJhc2VsaW5lID0gdGhpcy5zdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykudG9UZXh0QmFzZWxpbmUoKTtcclxuXHRcdFx0XHRpZiAodGV4dEJhc2VsaW5lICE9IG51bGwpIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHgsIHkgLSBmb250U2l6ZSwgeCArIE1hdGguZmxvb3IoZm9udFNpemUgKiAyLjAgLyAzLjApICogdGhpcy5jaGlsZHJlblswXS5nZXRUZXh0KCkubGVuZ3RoLCB5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHRoaXMueCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR0aGlzLnkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSB0aGlzLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gdGhpcy5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR0aGlzLnggKz0gdGhpcy5nZXRBbmNob3JEZWx0YShjdHgsIHRoaXMsIDApO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEFuY2hvckRlbHRhID0gZnVuY3Rpb24gKGN0eCwgcGFyZW50LCBzdGFydEkpIHtcclxuXHRcdFx0XHR2YXIgdGV4dEFuY2hvciA9IHRoaXMuc3R5bGUoJ3RleHQtYW5jaG9yJykudmFsdWVPckRlZmF1bHQoJ3N0YXJ0Jyk7XHJcblx0XHRcdFx0aWYgKHRleHRBbmNob3IgIT0gJ3N0YXJ0Jykge1xyXG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gMDtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9c3RhcnRJOyBpPHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0XHRcdGlmIChpID4gc3RhcnRJICYmIGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGJyZWFrOyAvLyBuZXcgZ3JvdXBcclxuXHRcdFx0XHRcdFx0d2lkdGggKz0gY2hpbGQubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAtMSAqICh0ZXh0QW5jaG9yID09ICdlbmQnID8gd2lkdGggOiB3aWR0aCAvIDIuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkID0gZnVuY3Rpb24oY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGNoaWxkLnggPSBjaGlsZC5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpICsgdGV4dFBhcmVudC5nZXRBbmNob3JEZWx0YShjdHgsIHBhcmVudCwgaSk7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIGNoaWxkLnggKz0gY2hpbGQuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSB0ZXh0UGFyZW50LnggKz0gY2hpbGQuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRjaGlsZC54ID0gdGV4dFBhcmVudC54O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0ZXh0UGFyZW50LnggPSBjaGlsZC54ICsgY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcclxuXHJcblx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGNoaWxkLnkgPSBjaGlsZC5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSBjaGlsZC55ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgdGV4dFBhcmVudC55ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdFx0Y2hpbGQueSA9IHRleHRQYXJlbnQueTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGV4dFBhcmVudC55ID0gY2hpbGQueTtcclxuXHJcblx0XHRcdFx0Y2hpbGQucmVuZGVyKGN0eCk7XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGV4dFBhcmVudC5yZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnRleHQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdGV4dCBiYXNlXHJcblx0XHRzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0R2x5cGggPSBmdW5jdGlvbihmb250LCB0ZXh0LCBpKSB7XHJcblx0XHRcdFx0dmFyIGMgPSB0ZXh0W2ldO1xyXG5cdFx0XHRcdHZhciBnbHlwaCA9IG51bGw7XHJcblx0XHRcdFx0aWYgKGZvbnQuaXNBcmFiaWMpIHtcclxuXHRcdFx0XHRcdHZhciBhcmFiaWNGb3JtID0gJ2lzb2xhdGVkJztcclxuXHRcdFx0XHRcdGlmICgoaT09MCB8fCB0ZXh0W2ktMV09PScgJykgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJztcclxuXHRcdFx0XHRcdGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XHJcblx0XHRcdFx0XHRpZiAoaT4wICYmIHRleHRbaS0xXSE9JyAnICYmIChpID09IHRleHQubGVuZ3RoLTEgfHwgdGV4dFtpKzFdPT0nICcpKSBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBmb250LmdseXBoc1tjXSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdW2FyYWJpY0Zvcm1dO1xyXG5cdFx0XHRcdFx0XHRpZiAoZ2x5cGggPT0gbnVsbCAmJiBmb250LmdseXBoc1tjXS50eXBlID09ICdnbHlwaCcpIGdseXBoID0gZm9udC5nbHlwaHNbY107XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Z2x5cGggPSBmb250LmdseXBoc1tjXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGdseXBoID09IG51bGwpIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XHJcblx0XHRcdFx0cmV0dXJuIGdseXBoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTdHlsZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXN0eWxlJykudmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U3R5bGUpO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcclxuXHRcdFx0XHRcdGlmIChjdXN0b21Gb250LmlzUlRMKSB0ZXh0ID0gdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRleHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHNjYWxlID0gZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XHJcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xyXG5cdFx0XHRcdFx0XHRjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XHJcblx0XHRcdFx0XHRcdHZhciBsdyA9IGN0eC5saW5lV2lkdGg7XHJcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtIC8gZm9udFNpemU7XHJcblx0XHRcdFx0XHRcdGlmIChmb250U3R5bGUgPT0gJ2l0YWxpYycpIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xyXG5cdFx0XHRcdFx0XHRnbHlwaC5yZW5kZXIoY3R4KTtcclxuXHRcdFx0XHRcdFx0aWYgKGZvbnRTdHlsZSA9PSAnaXRhbGljJykgY3R4LnRyYW5zZm9ybSgxLCAwLCAtLjQsIDEsIDAsIDApO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gbHc7XHJcblx0XHRcdFx0XHRcdGN0eC5zY2FsZSgxL3NjYWxlLCAtMS9zY2FsZSk7XHJcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBkeFtpXSAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy54ICs9IGR4W2ldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykgY3R4LmZpbGxUZXh0KHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSksIHRoaXMueCwgdGhpcy55KTtcclxuXHRcdFx0XHRpZiAoY3R4LnN0cm9rZVN0eWxlICE9ICcnKSBjdHguc3Ryb2tlVGV4dChzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpLCB0aGlzLngsIHRoaXMueSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIE9WRVJSSURFIE1FXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWVhc3VyZVRleHRSZWN1cnNpdmUgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHdpZHRoICs9IHRoaXMuY2hpbGRyZW5baV0ubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIG1lYXN1cmUgPSAwO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcclxuXHRcdFx0XHRcdGlmIChjdXN0b21Gb250LmlzUlRMKSB0ZXh0ID0gdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcclxuXHRcdFx0XHRcdHZhciBkeCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMucGFyZW50LmF0dHJpYnV0ZSgnZHgnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xyXG5cdFx0XHRcdFx0XHRtZWFzdXJlICs9IChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpICogZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZHhbaV0gIT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xyXG5cdFx0XHRcdFx0XHRcdG1lYXN1cmUgKz0gZHhbaV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBtZWFzdXJlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHRleHRUb01lYXN1cmUgPSBzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpO1xyXG5cdFx0XHRcdGlmICghY3R4Lm1lYXN1cmVUZXh0KSByZXR1cm4gdGV4dFRvTWVhc3VyZS5sZW5ndGggKiAxMDtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHR0aGlzLnNldENvbnRleHQoY3R4KTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dFRvTWVhc3VyZSkud2lkdGg7XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRyZXR1cm4gd2lkdGg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyB0c3BhblxyXG5cdFx0c3ZnLkVsZW1lbnQudHNwYW4gPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IHRydWU7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0ID0gc3ZnLmNvbXByZXNzU3BhY2VzKG5vZGUudmFsdWUgfHwgbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xyXG5cdFx0XHR0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBpZiB0aGlzIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGVuIHRoZXkgb3duIHRoZSB0ZXh0XHJcblx0XHRcdFx0aWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkgeyByZXR1cm4gJyc7IH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC50c3Bhbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHRyZWZcclxuXHRcdHN2Zy5FbGVtZW50LnRyZWYgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW5bMF0uZ2V0VGV4dCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC50cmVmLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gYSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuaGFzVGV4dCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAzKSB0aGlzLmhhc1RleHQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGhpcyBtaWdodCBjb250YWluIHRleHRcclxuXHRcdFx0dGhpcy50ZXh0ID0gdGhpcy5oYXNUZXh0ID8gbm9kZS5jaGlsZE5vZGVzWzBdLnZhbHVlIDogJyc7XHJcblx0XHRcdHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYmFzZVJlbmRlckNoaWxkcmVuID0gdGhpcy5yZW5kZXJDaGlsZHJlbjtcclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGlmICh0aGlzLmhhc1RleHQpIHtcclxuXHRcdFx0XHRcdC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcclxuXHRcdFx0XHRcdHRoaXMuYmFzZVJlbmRlckNoaWxkcmVuKGN0eCk7XHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0c3ZnLk1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSAtIGZvbnRTaXplLnRvUGl4ZWxzKCd5JyksIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxyXG5cdFx0XHRcdFx0dmFyIGcgPSBuZXcgc3ZnLkVsZW1lbnQuZygpO1xyXG5cdFx0XHRcdFx0Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHRcdFx0XHRnLnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdFx0XHRnLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0d2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3ZnLmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5hLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gaW1hZ2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuaW1hZ2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWU7XHJcblx0XHRcdGlmIChocmVmID09ICcnKSB7IHJldHVybjsgfVxyXG5cdFx0XHR2YXIgaXNTdmcgPSBocmVmLm1hdGNoKC9cXC5zdmckLylcclxuXHJcblx0XHRcdHN2Zy5JbWFnZXMucHVzaCh0aGlzKTtcclxuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuXHRcdFx0aWYgKCFpc1N2Zykge1xyXG5cdFx0XHRcdHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWyd1c2VDT1JTJ10gPT0gdHJ1ZSkgeyB0aGlzLmltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnOyB9XHJcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdHRoaXMuaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cclxuXHRcdFx0XHR0aGlzLmltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IHN2Zy5sb2coJ0VSUk9SOiBpbWFnZSBcIicgKyBocmVmICsgJ1wiIG5vdCBmb3VuZCcpOyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cclxuXHRcdFx0XHR0aGlzLmltZy5zcmMgPSBocmVmO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuaW1nID0gc3ZnLmFqYXgoaHJlZik7XHJcblx0XHRcdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdGlmICh3aWR0aCA9PSAwIHx8IGhlaWdodCA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdFx0aWYgKGlzU3ZnKSB7XHJcblx0XHRcdFx0XHRjdHguZHJhd1N2Zyh0aGlzLmltZywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuXHRcdFx0XHRcdHN2Zy5Bc3BlY3RSYXRpbyhjdHgsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmltZy53aWR0aCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmltZy5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdDAsXHJcblx0XHRcdFx0XHRcdFx0XHRcdDApO1xyXG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5pbWFnZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBncm91cCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5nID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gYmI7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5nLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHN5bWJvbCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5zeW1ib2wgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zeW1ib2wucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gc3R5bGUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuc3R5bGUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHQvLyB0ZXh0LCBvciBzcGFjZXMgdGhlbiBDREFUQVxyXG5cdFx0XHR2YXIgY3NzID0gJydcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHQgIGNzcyArPSBub2RlLmNoaWxkTm9kZXNbaV0uZGF0YTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjc3MgPSBjc3MucmVwbGFjZSgvKFxcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKlxcL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKTsgLy8gcmVtb3ZlIGNvbW1lbnRzXHJcblx0XHRcdGNzcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyhjc3MpOyAvLyByZXBsYWNlIHdoaXRlc3BhY2VcclxuXHRcdFx0dmFyIGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGNzc0RlZnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoc3ZnLnRyaW0oY3NzRGVmc1tpXSkgIT0gJycpIHtcclxuXHRcdFx0XHRcdHZhciBjc3NEZWYgPSBjc3NEZWZzW2ldLnNwbGl0KCd7Jyk7XHJcblx0XHRcdFx0XHR2YXIgY3NzQ2xhc3NlcyA9IGNzc0RlZlswXS5zcGxpdCgnLCcpO1xyXG5cdFx0XHRcdFx0dmFyIGNzc1Byb3BzID0gY3NzRGVmWzFdLnNwbGl0KCc7Jyk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBqPTA7IGo8Y3NzQ2xhc3Nlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgY3NzQ2xhc3MgPSBzdmcudHJpbShjc3NDbGFzc2VzW2pdKTtcclxuXHRcdFx0XHRcdFx0aWYgKGNzc0NsYXNzICE9ICcnKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHByb3BzID0gc3ZnLlN0eWxlc1tjc3NDbGFzc10gfHwge307XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaz0wOyBrPGNzc1Byb3BzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcCA9IGNzc1Byb3BzW2tdLmluZGV4T2YoJzonKTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuYW1lID0gY3NzUHJvcHNba10uc3Vic3RyKDAsIHByb3ApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gY3NzUHJvcHNba10uc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wc1trXS5sZW5ndGggLSBwcm9wKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wc1tzdmcudHJpbShuYW1lKV0gPSBuZXcgc3ZnLlByb3BlcnR5KHN2Zy50cmltKG5hbWUpLCBzdmcudHJpbSh2YWx1ZSkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRzdmcuU3R5bGVzW2Nzc0NsYXNzXSA9IHByb3BzO1xyXG5cdFx0XHRcdFx0XHRcdHN2Zy5TdHlsZXNTcGVjaWZpY2l0eVtjc3NDbGFzc10gPSBnZXRTZWxlY3RvclNwZWNpZmljaXR5KGNzc0NsYXNzKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3NzQ2xhc3MgPT0gJ0Bmb250LWZhY2UnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLnZhbHVlLnJlcGxhY2UoL1wiL2csJycpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHNyY3MgPSBwcm9wc1snc3JjJ10udmFsdWUuc3BsaXQoJywnKTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIHM9MDsgczxzcmNzLmxlbmd0aDsgcysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChzcmNzW3NdLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB1cmxTdGFydCA9IHNyY3Nbc10uaW5kZXhPZigndXJsJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHVybEVuZCA9IHNyY3Nbc10uaW5kZXhPZignKScsIHVybFN0YXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gc3Jjc1tzXS5zdWJzdHIodXJsU3RhcnQgKyA1LCB1cmxFbmQgLSB1cmxTdGFydCAtIDYpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBkb2MgPSBzdmcucGFyc2VYbWwoc3ZnLmFqYXgodXJsKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZvbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgZj0wOyBmPGZvbnRzLmxlbmd0aDsgZisrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZm9udCA9IHN2Zy5DcmVhdGVFbGVtZW50KGZvbnRzW2ZdKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN2Zy5EZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zdHlsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdXNlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnVzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCAwKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSBjdHgudHJhbnNsYXRlKDAsIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkgZWxlbWVudC5wYXRoKGN0eCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBTdmcgPSBlbGVtZW50O1xyXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudHlwZSA9PSAnc3ltYm9sJykge1xyXG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcclxuXHRcdFx0XHRcdFx0dGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy50eXBlID0gJ3N2Zyc7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIGVsZW1lbnQuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBlbGVtZW50LmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWydvdmVyZmxvdyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnb3ZlcmZsb3cnLCBlbGVtZW50LmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRlbXBTdmcudHlwZSA9PSAnc3ZnJykge1xyXG5cdFx0XHRcdFx0XHQvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcclxuXHRcdFx0XHRcdHRlbXBTdmcucGFyZW50ID0gbnVsbDtcclxuXHRcdFx0XHRcdHRlbXBTdmcucmVuZGVyKGN0eCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnVzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBtYXNrIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50Lm1hc2sgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXAgc3ZnXHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdGlmICh3aWR0aCA9PSAwICYmIGhlaWdodCA9PSAwKSB7XHJcblx0XHRcdFx0XHR2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcclxuXHRcdFx0XHRcdHZhciB5ID0gTWF0aC5mbG9vcihiYi55MSk7XHJcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJiLndpZHRoKCkpO1xyXG5cdFx0XHRcdFx0dmFyXHRoZWlnaHQgPSBNYXRoLmZsb29yKGJiLmhlaWdodCgpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRlbXBvcmFyaWx5IHJlbW92ZSBtYXNrIHRvIGF2b2lkIHJlY3Vyc2lvblxyXG5cdFx0XHRcdHZhciBtYXNrID0gZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZTtcclxuXHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZSgnbWFzaycpLnZhbHVlID0gJyc7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0XHRjTWFzay53aWR0aCA9IHggKyB3aWR0aDtcclxuXHRcdFx0XHRcdGNNYXNrLmhlaWdodCA9IHkgKyBoZWlnaHQ7XHJcblx0XHRcdFx0XHR2YXIgbWFza0N0eCA9IGNNYXNrLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuKG1hc2tDdHgpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0XHRjLndpZHRoID0geCArIHdpZHRoO1xyXG5cdFx0XHRcdFx0Yy5oZWlnaHQgPSB5ICsgaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHRlbGVtZW50LnJlbmRlcih0ZW1wQ3R4KTtcclxuXHRcdFx0XHRcdHRlbXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcclxuXHRcdFx0XHRcdHRlbXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKGNNYXNrLCAnbm8tcmVwZWF0Jyk7XHJcblx0XHRcdFx0XHR0ZW1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcblxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0Ly8gcmVhc3NpZ24gbWFza1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWUgPSBtYXNrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE5PIFJFTkRFUlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5tYXNrLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBjbGlwIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmNsaXBQYXRoID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBvbGRCZWdpblBhdGggPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aDtcclxuXHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuXHJcblx0XHRcdFx0dmFyIG9sZENsb3NlUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoO1xyXG5cdFx0XHRcdENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG5cclxuXHRcdFx0XHRvbGRCZWdpblBhdGguY2FsbChjdHgpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjaGlsZC5wYXRoICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gbmV3IHN2Zy5UcmFuc2Zvcm0oY2hpbGQuc3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y2hpbGQucGF0aChjdHgpO1xyXG5cdFx0XHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcclxuXHRcdFx0XHRcdFx0aWYgKHRyYW5zZm9ybSkgeyB0cmFuc2Zvcm0udW5hcHBseShjdHgpOyB9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9sZENsb3NlUGF0aC5jYWxsKGN0eCk7XHJcblx0XHRcdFx0Y3R4LmNsaXAoKTtcclxuXHJcblx0XHRcdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGggPSBvbGRCZWdpblBhdGg7XHJcblx0XHRcdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGggPSBvbGRDbG9zZVBhdGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmNsaXBQYXRoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBmaWx0ZXJzXHJcblx0XHRzdmcuRWxlbWVudC5maWx0ZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXAgc3ZnXHJcblx0XHRcdFx0dmFyIGJiID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdHZhciB4ID0gTWF0aC5mbG9vcihiYi54MSk7XHJcblx0XHRcdFx0dmFyIHkgPSBNYXRoLmZsb29yKGJiLnkxKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJiLndpZHRoKCkpO1xyXG5cdFx0XHRcdHZhclx0aGVpZ2h0ID0gTWF0aC5mbG9vcihiYi5oZWlnaHQoKSk7XHJcblxyXG5cdFx0XHRcdC8vIHRlbXBvcmFyaWx5IHJlbW92ZSBmaWx0ZXIgdG8gYXZvaWQgcmVjdXJzaW9uXHJcblx0XHRcdFx0dmFyIGZpbHRlciA9IGVsZW1lbnQuc3R5bGUoJ2ZpbHRlcicpLnZhbHVlO1xyXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUoJ2ZpbHRlcicpLnZhbHVlID0gJyc7XHJcblxyXG5cdFx0XHRcdHZhciBweCA9IDAsIHB5ID0gMDtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGVmZCA9IHRoaXMuY2hpbGRyZW5baV0uZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xyXG5cdFx0XHRcdFx0cHggPSBNYXRoLm1heChweCwgZWZkKTtcclxuXHRcdFx0XHRcdHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdGMud2lkdGggPSB3aWR0aCArIDIqcHg7XHJcblx0XHRcdFx0Yy5oZWlnaHQgPSBoZWlnaHQgKyAyKnB5O1xyXG5cdFx0XHRcdHZhciB0ZW1wQ3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdFx0XHRcdHRlbXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xyXG5cdFx0XHRcdGVsZW1lbnQucmVuZGVyKHRlbXBDdHgpO1xyXG5cclxuXHRcdFx0XHQvLyBhcHBseSBmaWx0ZXJzXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbltpXS5hcHBseSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hpbGRyZW5baV0uYXBwbHkodGVtcEN0eCwgMCwgMCwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBvbiBtZVxyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoYywgMCwgMCwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5LCB4IC0gcHgsIHkgLSBweSwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5KTtcclxuXHJcblx0XHRcdFx0Ly8gcmVhc3NpZ24gZmlsdGVyXHJcblx0XHRcdFx0ZWxlbWVudC5zdHlsZSgnZmlsdGVyJywgdHJ1ZSkudmFsdWUgPSBmaWx0ZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZpbHRlci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVNb3JwaG9sb2d5ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50LmZlQ29tcG9zaXRlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZUNvbXBvc2l0ZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmFsdWVzJykudmFsdWUpO1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXMuYXR0cmlidXRlKCd0eXBlJykudmFsdWVPckRlZmF1bHQoJ21hdHJpeCcpKSB7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjZmVDb2xvck1hdHJpeEVsZW1lbnRcclxuXHRcdFx0XHRjYXNlICdzYXR1cmF0ZSc6XHJcblx0XHRcdFx0XHR2YXIgcyA9IG1hdHJpeFswXTtcclxuXHRcdFx0XHRcdG1hdHJpeCA9IFswLjIxMyswLjc4NypzLDAuNzE1LTAuNzE1KnMsMC4wNzItMC4wNzIqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjIxMy0wLjIxMypzLDAuNzE1KzAuMjg1KnMsMC4wNzItMC4wNzIqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjIxMy0wLjIxMypzLDAuNzE1LTAuNzE1KnMsMC4wNzIrMC45MjgqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwxLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwwLDFdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnaHVlUm90YXRlJzpcclxuXHRcdFx0XHRcdHZhciBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MC4wO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSBmdW5jdGlvbiAobTEsbTIsbTMpIHsgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkqbTIgKyBNYXRoLnNpbihhKSptMzsgfTtcclxuXHRcdFx0XHRcdG1hdHJpeCA9IFtjKDAuMjEzLDAuNzg3LC0wLjIxMyksYygwLjcxNSwtMC43MTUsLTAuNzE1KSxjKDAuMDcyLC0wLjA3MiwwLjkyOCksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgYygwLjIxMywtMC4yMTMsMC4xNDMpLGMoMC43MTUsMC4yODUsMC4xNDApLGMoMC4wNzIsLTAuMDcyLC0wLjI4MyksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgYygwLjIxMywtMC4yMTMsLTAuNzg3KSxjKDAuNzE1LC0wLjcxNSwwLjcxNSksYygwLjA3MiwwLjkyOCwwLjA3MiksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMSwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMCwxXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ2x1bWluYW5jZVRvQWxwaGEnOlxyXG5cdFx0XHRcdFx0bWF0cml4ID0gWzAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMjEyNSwwLjcxNTQsMC4wNzIxLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhKSB7XHJcblx0XHRcdFx0cmV0dXJuIGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhLCB2YWwpIHtcclxuXHRcdFx0XHRpbWdbeSp3aWR0aCo0ICsgeCo0ICsgcmdiYV0gPSB2YWw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIG0oaSwgdikge1xyXG5cdFx0XHRcdHZhciBtaSA9IG1hdHJpeFtpXTtcclxuXHRcdFx0XHRyZXR1cm4gbWkgKiAobWkgPCAwID8gdiAtIDI1NSA6IHYpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0Ly8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcclxuXHRcdFx0XHR2YXIgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcclxuXHRcdFx0XHRcdFx0dmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xyXG5cdFx0XHRcdFx0XHR2YXIgYiA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMik7XHJcblx0XHRcdFx0XHRcdHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBtKDAscikrbSgxLGcpK20oMixiKSttKDMsYSkrbSg0LDEpKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLCBtKDUscikrbSg2LGcpK20oNyxiKSttKDgsYSkrbSg5LDEpKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyLCBtKDEwLHIpK20oMTEsZykrbSgxMixiKSttKDEzLGEpK20oMTQsMSkpO1xyXG5cdFx0XHRcdFx0XHRpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG0oMTUscikrbSgxNixnKSttKDE3LGIpK20oMTgsYSkrbSgxOSwxKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0Y3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKHRoaXMuYXR0cmlidXRlKCdzdGREZXZpYXRpb24nKS5udW1WYWx1ZSgpKTtcclxuXHRcdFx0dGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc3RhY2tCbHVyLmNhbnZhc1JHQkEgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHN2Zy5sb2coJ0VSUk9SOiBTdGFja0JsdXIuanMgbXVzdCBiZSBpbmNsdWRlZCBmb3IgYmx1ciB0byB3b3JrJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XHJcblx0XHRcdFx0Y3R4LmNhbnZhcy5pZCA9IHN2Zy5VbmlxdWVJZCgpO1xyXG5cdFx0XHRcdGN0eC5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGN0eC5jYW52YXMpO1xyXG5cdFx0XHRcdHN0YWNrQmx1ci5jYW52YXNSR0JBKGN0eC5jYW52YXMuaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuYmx1clJhZGl1cyk7XHJcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjdHguY2FudmFzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHRpdGxlIGVsZW1lbnQsIGRvIG5vdGhpbmdcclxuXHRcdHN2Zy5FbGVtZW50LnRpdGxlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQudGl0bGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGRlc2MgZWxlbWVudCwgZG8gbm90aGluZ1xyXG5cdFx0c3ZnLkVsZW1lbnQuZGVzYyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmRlc2MucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50Lk1JU1NJTkcgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHN2Zy5sb2coJ0VSUk9SOiBFbGVtZW50IFxcJycgKyBub2RlLm5vZGVOYW1lICsgJ1xcJyBub3QgeWV0IGltcGxlbWVudGVkLicpO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuTUlTU0lORy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gZWxlbWVudCBmYWN0b3J5XHJcblx0XHRzdmcuQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sJycpOyAvLyByZW1vdmUgbmFtZXNwYWNlXHJcblx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKC9cXC0vZywnJyk7IC8vIHJlbW92ZSBkYXNoZXNcclxuXHRcdFx0dmFyIGUgPSBudWxsO1xyXG5cdFx0XHRpZiAodHlwZW9mIHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0gIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRlID0gbmV3IHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0obm9kZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZSA9IG5ldyBzdmcuRWxlbWVudC5NSVNTSU5HKG5vZGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlLnR5cGUgPSBub2RlLm5vZGVOYW1lO1xyXG5cdFx0XHRyZXR1cm4gZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBsb2FkIGZyb20gdXJsXHJcblx0XHRzdmcubG9hZCA9IGZ1bmN0aW9uKGN0eCwgdXJsKSB7XHJcblx0XHRcdHN2Zy5sb2FkWG1sKGN0eCwgc3ZnLmFqYXgodXJsKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbG9hZCBmcm9tIHhtbFxyXG5cdFx0c3ZnLmxvYWRYbWwgPSBmdW5jdGlvbihjdHgsIHhtbCkge1xyXG5cdFx0XHRzdmcubG9hZFhtbERvYyhjdHgsIHN2Zy5wYXJzZVhtbCh4bWwpKTtcclxuXHRcdH1cclxuXHJcblx0XHRzdmcubG9hZFhtbERvYyA9IGZ1bmN0aW9uKGN0eCwgZG9tKSB7XHJcblx0XHRcdHN2Zy5pbml0KGN0eCk7XHJcblxyXG5cdFx0XHR2YXIgbWFwWFkgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0dmFyIGUgPSBjdHguY2FudmFzO1xyXG5cdFx0XHRcdHdoaWxlIChlKSB7XHJcblx0XHRcdFx0XHRwLnggLT0gZS5vZmZzZXRMZWZ0O1xyXG5cdFx0XHRcdFx0cC55IC09IGUub2Zmc2V0VG9wO1xyXG5cdFx0XHRcdFx0ZSA9IGUub2Zmc2V0UGFyZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAod2luZG93LnNjcm9sbFgpIHAueCArPSB3aW5kb3cuc2Nyb2xsWDtcclxuXHRcdFx0XHRpZiAod2luZG93LnNjcm9sbFkpIHAueSArPSB3aW5kb3cuc2Nyb2xsWTtcclxuXHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmluZCBtb3VzZVxyXG5cdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZU1vdXNlJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGN0eC5jYW52YXMub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XHJcblx0XHRcdFx0XHRzdmcuTW91c2Uub25jbGljayhwLngsIHAueSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRjdHguY2FudmFzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSBtYXBYWShuZXcgc3ZnLlBvaW50KGUgIT0gbnVsbCA/IGUuY2xpZW50WCA6IGV2ZW50LmNsaWVudFgsIGUgIT0gbnVsbCA/IGUuY2xpZW50WSA6IGV2ZW50LmNsaWVudFkpKTtcclxuXHRcdFx0XHRcdHN2Zy5Nb3VzZS5vbm1vdXNlbW92ZShwLngsIHAueSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGUgPSBzdmcuQ3JlYXRlRWxlbWVudChkb20uZG9jdW1lbnRFbGVtZW50KTtcclxuXHRcdFx0ZS5yb290ID0gdHJ1ZTtcclxuXHRcdFx0ZS5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgbG9vcFxyXG5cdFx0XHR2YXIgaXNGaXJzdFJlbmRlciA9IHRydWU7XHJcblx0XHRcdHZhciBkcmF3ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3ZnLlZpZXdQb3J0LkNsZWFyKCk7XHJcblx0XHRcdFx0aWYgKGN0eC5jYW52YXMucGFyZW50Tm9kZSkgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY3R4LmNhbnZhcy5wYXJlbnROb2RlLmNsaWVudFdpZHRoLCBjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydpZ25vcmVEaW1lbnNpb25zJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Ly8gc2V0IGNhbnZhcyBzaXplXHJcblx0XHRcdFx0XHRpZiAoZS5zdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMud2lkdGggPSBlLnN0eWxlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBjdHguY2FudmFzLndpZHRoICsgJ3B4JztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChlLnN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMuaGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRcdFx0Y3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodCArICdweCc7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBjV2lkdGggPSBjdHguY2FudmFzLmNsaWVudFdpZHRoIHx8IGN0eC5jYW52YXMud2lkdGg7XHJcblx0XHRcdFx0dmFyIGNIZWlnaHQgPSBjdHguY2FudmFzLmNsaWVudEhlaWdodCB8fCBjdHguY2FudmFzLmhlaWdodDtcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZURpbWVuc2lvbnMnXSA9PSB0cnVlICYmIGUuc3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSAmJiBlLnN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRjV2lkdGggPSBlLnN0eWxlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRjSGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydvZmZzZXRYJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRYJ107XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydvZmZzZXRZJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRZJ107XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCB8fCBzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgeFJhdGlvID0gbnVsbCwgeVJhdGlvID0gbnVsbCwgdmlld0JveCA9IHN2Zy5Ub051bWJlckFycmF5KGUuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snc2NhbGVXaWR0aCddICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGUuYXR0cmlidXRlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHhSYXRpbyA9IGUuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4JykgLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmICghaXNOYU4odmlld0JveFsyXSkpIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGlmIChlLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgeVJhdGlvID0gZS5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5JykgLyBzdmcub3B0c1snc2NhbGVIZWlnaHQnXTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHhSYXRpbyA9PSBudWxsKSB7IHhSYXRpbyA9IHlSYXRpbzsgfVxyXG5cdFx0XHRcdFx0aWYgKHlSYXRpbyA9PSBudWxsKSB7IHlSYXRpbyA9IHhSYXRpbzsgfVxyXG5cclxuXHRcdFx0XHRcdGUuYXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXTtcclxuXHRcdFx0XHRcdGUuYXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xyXG5cdFx0XHRcdFx0ZS5zdHlsZSgndHJhbnNmb3JtJywgdHJ1ZSwgdHJ1ZSkudmFsdWUgKz0gJyBzY2FsZSgnKygxLjAveFJhdGlvKSsnLCcrKDEuMC95UmF0aW8pKycpJztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGNsZWFyIGFuZCByZW5kZXJcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZUNsZWFyJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdGlmIChpc0ZpcnN0UmVuZGVyKSB7XHJcblx0XHRcdFx0XHRpc0ZpcnN0UmVuZGVyID0gZmFsc2U7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddID09ICdmdW5jdGlvbicpIHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddKGRvbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgd2FpdGluZ0ZvckltYWdlcyA9IHRydWU7XHJcblx0XHRcdGlmIChzdmcuSW1hZ2VzTG9hZGVkKCkpIHtcclxuXHRcdFx0XHR3YWl0aW5nRm9ySW1hZ2VzID0gZmFsc2U7XHJcblx0XHRcdFx0ZHJhdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN2Zy5pbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIG5lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKHdhaXRpbmdGb3JJbWFnZXMgJiYgc3ZnLkltYWdlc0xvYWRlZCgpKSB7XHJcblx0XHRcdFx0XHR3YWl0aW5nRm9ySW1hZ2VzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRuZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdXBkYXRlIGZyb20gbW91c2UgZXZlbnRzP1xyXG5cdFx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlTW91c2UnXSAhPSB0cnVlKSB7XHJcblx0XHRcdFx0XHRuZWVkVXBkYXRlID0gbmVlZFVwZGF0ZSB8IHN2Zy5Nb3VzZS5oYXNFdmVudHMoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZUFuaW1hdGlvbiddICE9IHRydWUpIHtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaTxzdmcuQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRuZWVkVXBkYXRlID0gbmVlZFVwZGF0ZSB8IHN2Zy5BbmltYXRpb25zW2ldLnVwZGF0ZSgxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cclxuXHRcdFx0XHRpZiAodHlwZW9mIHN2Zy5vcHRzWydmb3JjZVJlZHJhdyddID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snZm9yY2VSZWRyYXcnXSgpID09IHRydWUpIG5lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIGlmIG5lZWRlZFxyXG5cdFx0XHRcdGlmIChuZWVkVXBkYXRlKSB7XHJcblx0XHRcdFx0XHRkcmF3KCk7XHJcblx0XHRcdFx0XHRzdmcuTW91c2UucnVuRXZlbnRzKCk7IC8vIHJ1biBhbmQgY2xlYXIgb3VyIGV2ZW50c1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTAwMCAvIHN2Zy5GUkFNRVJBVEUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN2Zy5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmIChzdmcuaW50ZXJ2YWxJRCkge1xyXG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwoc3ZnLmludGVydmFsSUQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnLk1vdXNlID0gbmV3IChmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5ldmVudHMgPSBbXTtcclxuXHRcdFx0dGhpcy5oYXNFdmVudHMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCAhPSAwOyB9XHJcblxyXG5cdFx0XHR0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5ldmVudHMucHVzaCh7IHR5cGU6ICdvbmNsaWNrJywgeDogeCwgeTogeSxcclxuXHRcdFx0XHRcdHJ1bjogZnVuY3Rpb24oZSkgeyBpZiAoZS5vbmNsaWNrKSBlLm9uY2xpY2soKTsgfVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLnB1c2goeyB0eXBlOiAnb25tb3VzZW1vdmUnLCB4OiB4LCB5OiB5LFxyXG5cdFx0XHRcdFx0cnVuOiBmdW5jdGlvbihlKSB7IGlmIChlLm9ubW91c2Vtb3ZlKSBlLm9ubW91c2Vtb3ZlKCk7IH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ldmVudEVsZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHR0aGlzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcclxuXHRcdFx0XHRcdGlmIChjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aChlLngsIGUueSkpIHRoaXMuZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNoZWNrQm91bmRpbmdCb3ggPSBmdW5jdGlvbihlbGVtZW50LCBiYikge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcclxuXHRcdFx0XHRcdGlmIChiYi5pc1BvaW50SW5Cb3goZS54LCBlLnkpKSB0aGlzLmV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ydW5FdmVudHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdmcuY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmV2ZW50RWxlbWVudHNbaV07XHJcblx0XHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xyXG5cdFx0XHRcdFx0XHRlLnJ1bihlbGVtZW50KTtcclxuXHRcdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZG9uZSBydW5uaW5nLCBjbGVhclxyXG5cdFx0XHRcdHRoaXMuZXZlbnRzID0gW107XHJcblx0XHRcdFx0dGhpcy5ldmVudEVsZW1lbnRzID0gW107XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBzdmc7XHJcblx0fTtcclxuXG5cdGlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kcmF3U3ZnID0gZnVuY3Rpb24ocywgZHgsIGR5LCBkdywgZGgsIG9wdHMpIHtcclxuXHRcdFx0dmFyIGNPcHRzID0ge1xuXHRcdFx0XHRpZ25vcmVNb3VzZTogdHJ1ZSxcclxuXHRcdFx0XHRpZ25vcmVBbmltYXRpb246IHRydWUsXHJcblx0XHRcdFx0aWdub3JlRGltZW5zaW9uczogdHJ1ZSxcclxuXHRcdFx0XHRpZ25vcmVDbGVhcjogdHJ1ZSxcclxuXHRcdFx0XHRvZmZzZXRYOiBkeCxcclxuXHRcdFx0XHRvZmZzZXRZOiBkeSxcclxuXHRcdFx0XHRzY2FsZVdpZHRoOiBkdyxcclxuXHRcdFx0XHRzY2FsZUhlaWdodDogZGhcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Zm9yKHZhciBwcm9wIGluIG9wdHMpIHtcclxuXHRcdFx0XHRpZihvcHRzLmhhc093blByb3BlcnR5KHByb3ApKXtcclxuXHRcdFx0XHRcdGNPcHRzW3Byb3BdID0gb3B0c1twcm9wXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FudmcodGhpcy5jYW52YXMsIHMsIGNPcHRzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBjYW52ZztcclxuXHJcbn0pKTtcclxuIiwiLypcblxuU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuVmVyc2lvbjogXHQwLjVcbkF1dGhvcjpcdFx0TWFyaW8gS2xpbmdlbWFublxuQ29udGFjdDogXHRtYXJpb0BxdWFzaW1vbmRvLmNvbVxuV2Vic2l0ZTpcdGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG5Ud2l0dGVyOlx0QHF1YXNpbW9uZG9cblxuSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG5JIGFtIG5vdCB0b3RhbGx5IHVuaGFwcHkgZm9yIGEgc21hbGwgZG9uYXRpb24gdG8gbXkgUGF5UGFsIGFjY291bnRcbm1hcmlvQHF1YXNpbW9uZG8uZGVcblxuT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6IFxuaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG5vYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG5yZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbmNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG5jb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbk9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5XSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbkZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1Jcbk9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBtdWxfdGFibGUgPSBbXG4gICAgICAgIDUxMiw1MTIsNDU2LDUxMiwzMjgsNDU2LDMzNSw1MTIsNDA1LDMyOCwyNzEsNDU2LDM4OCwzMzUsMjkyLDUxMixcbiAgICAgICAgNDU0LDQwNSwzNjQsMzI4LDI5OCwyNzEsNDk2LDQ1Niw0MjAsMzg4LDM2MCwzMzUsMzEyLDI5MiwyNzMsNTEyLFxuICAgICAgICA0ODIsNDU0LDQyOCw0MDUsMzgzLDM2NCwzNDUsMzI4LDMxMiwyOTgsMjg0LDI3MSwyNTksNDk2LDQ3NSw0NTYsXG4gICAgICAgIDQzNyw0MjAsNDA0LDM4OCwzNzQsMzYwLDM0NywzMzUsMzIzLDMxMiwzMDIsMjkyLDI4MiwyNzMsMjY1LDUxMixcbiAgICAgICAgNDk3LDQ4Miw0NjgsNDU0LDQ0MSw0MjgsNDE3LDQwNSwzOTQsMzgzLDM3MywzNjQsMzU0LDM0NSwzMzcsMzI4LFxuICAgICAgICAzMjAsMzEyLDMwNSwyOTgsMjkxLDI4NCwyNzgsMjcxLDI2NSwyNTksNTA3LDQ5Niw0ODUsNDc1LDQ2NSw0NTYsXG4gICAgICAgIDQ0Niw0MzcsNDI4LDQyMCw0MTIsNDA0LDM5NiwzODgsMzgxLDM3NCwzNjcsMzYwLDM1NCwzNDcsMzQxLDMzNSxcbiAgICAgICAgMzI5LDMyMywzMTgsMzEyLDMwNywzMDIsMjk3LDI5MiwyODcsMjgyLDI3OCwyNzMsMjY5LDI2NSwyNjEsNTEyLFxuICAgICAgICA1MDUsNDk3LDQ4OSw0ODIsNDc1LDQ2OCw0NjEsNDU0LDQ0Nyw0NDEsNDM1LDQyOCw0MjIsNDE3LDQxMSw0MDUsXG4gICAgICAgIDM5OSwzOTQsMzg5LDM4MywzNzgsMzczLDM2OCwzNjQsMzU5LDM1NCwzNTAsMzQ1LDM0MSwzMzcsMzMyLDMyOCxcbiAgICAgICAgMzI0LDMyMCwzMTYsMzEyLDMwOSwzMDUsMzAxLDI5OCwyOTQsMjkxLDI4NywyODQsMjgxLDI3OCwyNzQsMjcxLFxuICAgICAgICAyNjgsMjY1LDI2MiwyNTksMjU3LDUwNyw1MDEsNDk2LDQ5MSw0ODUsNDgwLDQ3NSw0NzAsNDY1LDQ2MCw0NTYsXG4gICAgICAgIDQ1MSw0NDYsNDQyLDQzNyw0MzMsNDI4LDQyNCw0MjAsNDE2LDQxMiw0MDgsNDA0LDQwMCwzOTYsMzkyLDM4OCxcbiAgICAgICAgMzg1LDM4MSwzNzcsMzc0LDM3MCwzNjcsMzYzLDM2MCwzNTcsMzU0LDM1MCwzNDcsMzQ0LDM0MSwzMzgsMzM1LFxuICAgICAgICAzMzIsMzI5LDMyNiwzMjMsMzIwLDMxOCwzMTUsMzEyLDMxMCwzMDcsMzA0LDMwMiwyOTksMjk3LDI5NCwyOTIsXG4gICAgICAgIDI4OSwyODcsMjg1LDI4MiwyODAsMjc4LDI3NSwyNzMsMjcxLDI2OSwyNjcsMjY1LDI2MywyNjEsMjU5XTtcbiAgICAgICAgXG4gICBcbnZhciBzaGdfdGFibGUgPSBbXG5cdCAgICAgOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNywgXG5cdFx0MTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIFxuXHRcdDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxuXHRcdDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIxLFxuXHRcdDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuXHRcdDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCBcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIFxuXHRcdDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCBcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0IF07XG5cbmZ1bmN0aW9uIGJsdXIoIHBpeGVscywgd2lkdGgsIGhlaWdodCwgcmFkaXVzIClcbntcblx0aWYgKCBpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEgKSByZXR1cm47XG5cdHJhZGl1cyB8PSAwO1xuXG5cdHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSwgXG5cdHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sIGFfb3V0X3N1bSxcblx0cl9pbl9zdW0sIGdfaW5fc3VtLCBiX2luX3N1bSwgYV9pbl9zdW0sIFxuXHRwciwgcGcsIHBiLCBwYSwgcmJzO1xuXHRcdFx0XG5cdHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxO1xuXHR2YXIgdzQgPSB3aWR0aCA8PCAyO1xuXHR2YXIgd2lkdGhNaW51czEgID0gd2lkdGggLSAxO1xuXHR2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcblx0dmFyIHJhZGl1c1BsdXMxICA9IHJhZGl1cyArIDE7XG5cdHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyO1xuXHRcblx0dmFyIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCk7XG5cdHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cdGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKVxuXHR7XG5cdFx0c3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuXHRcdGlmICggaSA9PSByYWRpdXNQbHVzMSApIHZhciBzdGFja0VuZCA9IHN0YWNrO1xuXHR9XG5cdHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXHR2YXIgc3RhY2tJbiA9IG51bGw7XG5cdHZhciBzdGFja091dCA9IG51bGw7XG5cdFxuXHR5dyA9IHlpID0gMDtcblx0XG5cdHZhciBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c107XG5cdHZhciBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG5cdFxuXHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcblx0e1xuXHRcdHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXHRcdFxuXHRcdHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwciA9IHBpeGVsc1t5aV0gKTtcblx0XHRnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0gKTtcblx0XHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0gKTtcblx0XHRhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkrM10gKTtcblx0XHRcblx0XHRyX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcblx0XHRnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcblx0XHRiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcblx0XHRhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblx0XHRcblx0XHRzdGFjayA9IHN0YWNrU3RhcnQ7XG5cdFx0XG5cdFx0Zm9yKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuXHRcdHtcblx0XHRcdHN0YWNrLnIgPSBwcjtcblx0XHRcdHN0YWNrLmcgPSBwZztcblx0XHRcdHN0YWNrLmIgPSBwYjtcblx0XHRcdHN0YWNrLmEgPSBwYTtcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuXHRcdHtcblx0XHRcdHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcblx0XHRcdHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbcF0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG5cdFx0XHRnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3ArMV0pKSAqIHJicztcblx0XHRcdGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbcCsyXSkpICogcmJzO1xuXHRcdFx0YV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1twKzNdKSkgKiByYnM7XG5cdFx0XHRcblx0XHRcdHJfaW5fc3VtICs9IHByO1xuXHRcdFx0Z19pbl9zdW0gKz0gcGc7XG5cdFx0XHRiX2luX3N1bSArPSBwYjtcblx0XHRcdGFfaW5fc3VtICs9IHBhO1xuXHRcdFx0XG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuXHRcdHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cdFx0Zm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcblx0XHR7XG5cdFx0XHRwaXhlbHNbeWkrM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRpZiAoIHBhICE9IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRwYSA9IDI1NSAvIHBhO1xuXHRcdFx0XHRwaXhlbHNbeWldICAgPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcblx0XHRcdFx0cGl4ZWxzW3lpKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG5cdFx0XHRcdHBpeGVsc1t5aSsyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSsxXSA9IHBpeGVsc1t5aSsyXSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJfc3VtIC09IHJfb3V0X3N1bTtcblx0XHRcdGdfc3VtIC09IGdfb3V0X3N1bTtcblx0XHRcdGJfc3VtIC09IGJfb3V0X3N1bTtcblx0XHRcdGFfc3VtIC09IGFfb3V0X3N1bTtcblx0XHRcdFxuXHRcdFx0cl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcblx0XHRcdGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG5cdFx0XHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuXHRcdFx0YV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblx0XHRcdFxuXHRcdFx0cCA9ICAoIHl3ICsgKCAoIHAgPSB4ICsgcmFkaXVzICsgMSApIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEgKSApIDw8IDI7XG5cdFx0XHRcblx0XHRcdHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcblx0XHRcdGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pO1xuXHRcdFx0Yl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSk7XG5cdFx0XHRhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKTtcblx0XHRcdFxuXHRcdFx0cl9zdW0gKz0gcl9pbl9zdW07XG5cdFx0XHRnX3N1bSArPSBnX2luX3N1bTtcblx0XHRcdGJfc3VtICs9IGJfaW5fc3VtO1xuXHRcdFx0YV9zdW0gKz0gYV9pbl9zdW07XG5cdFx0XHRcblx0XHRcdHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cdFx0XHRcblx0XHRcdHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuXHRcdFx0Z19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG5cdFx0XHRiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcblx0XHRcdGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXHRcdFx0XG5cdFx0XHRyX2luX3N1bSAtPSBwcjtcblx0XHRcdGdfaW5fc3VtIC09IHBnO1xuXHRcdFx0Yl9pbl9zdW0gLT0gcGI7XG5cdFx0XHRhX2luX3N1bSAtPSBwYTtcblx0XHRcdFxuXHRcdFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG5cdFx0XHR5aSArPSA0O1xuXHRcdH1cblx0XHR5dyArPSB3aWR0aDtcblx0fVxuXG5cdFxuXHRmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuXHR7XG5cdFx0Z19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cdFx0XG5cdFx0eWkgPSB4IDw8IDI7XG5cdFx0cl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSk7XG5cdFx0Z19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpKzFdKTtcblx0XHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0pO1xuXHRcdGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSk7XG5cdFx0XG5cdFx0cl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG5cdFx0Z19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG5cdFx0Yl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG5cdFx0YV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cdFx0XG5cdFx0c3RhY2sgPSBzdGFja1N0YXJ0O1xuXHRcdFxuXHRcdGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcblx0XHR7XG5cdFx0XHRzdGFjay5yID0gcHI7XG5cdFx0XHRzdGFjay5nID0gcGc7XG5cdFx0XHRzdGFjay5iID0gcGI7XG5cdFx0XHRzdGFjay5hID0gcGE7XG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXHRcdFxuXHRcdHlwID0gd2lkdGg7XG5cdFx0XG5cdFx0Zm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG5cdFx0e1xuXHRcdFx0eWkgPSAoIHlwICsgeCApIDw8IDI7XG5cdFx0XHRcblx0XHRcdHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuXHRcdFx0Z19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1t5aSsxXSkpICogcmJzO1xuXHRcdFx0Yl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1t5aSsyXSkpICogcmJzO1xuXHRcdFx0YV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1t5aSszXSkpICogcmJzO1xuXHRcdCAgIFxuXHRcdFx0cl9pbl9zdW0gKz0gcHI7XG5cdFx0XHRnX2luX3N1bSArPSBwZztcblx0XHRcdGJfaW5fc3VtICs9IHBiO1xuXHRcdFx0YV9pbl9zdW0gKz0gcGE7XG5cdFx0XHRcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHRcblx0XHRcdGlmKCBpIDwgaGVpZ2h0TWludXMxIClcblx0XHRcdHtcblx0XHRcdFx0eXAgKz0gd2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHlpID0geDtcblx0XHRzdGFja0luID0gc3RhY2tTdGFydDtcblx0XHRzdGFja091dCA9IHN0YWNrRW5kO1xuXHRcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuXHRcdHtcblx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0cGl4ZWxzW3ArM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdHBpeGVsc1twXSAgID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuXHRcdFx0XHRwaXhlbHNbcCsxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcblx0XHRcdFx0cGl4ZWxzW3ArMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaXhlbHNbcF0gPSBwaXhlbHNbcCsxXSA9IHBpeGVsc1twKzJdID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xuXHRcdFx0Z19zdW0gLT0gZ19vdXRfc3VtO1xuXHRcdFx0Yl9zdW0gLT0gYl9vdXRfc3VtO1xuXHRcdFx0YV9zdW0gLT0gYV9vdXRfc3VtO1xuXHRcdCAgIFxuXHRcdFx0cl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcblx0XHRcdGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG5cdFx0XHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuXHRcdFx0YV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblx0XHRcdFxuXHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxICkgKiB3aWR0aCApKSA8PCAyO1xuXHRcdFx0XG5cdFx0XHRyX3N1bSArPSAoIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKSk7XG5cdFx0XHRnX3N1bSArPSAoIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pKTtcblx0XHRcdGJfc3VtICs9ICggYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSkpO1xuXHRcdFx0YV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKSk7XG5cdFx0ICAgXG5cdFx0XHRzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXHRcdFx0XG5cdFx0XHRyX291dF9zdW0gKz0gKCBwciA9IHN0YWNrT3V0LnIgKTtcblx0XHRcdGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xuXHRcdFx0Yl9vdXRfc3VtICs9ICggcGIgPSBzdGFja091dC5iICk7XG5cdFx0XHRhX291dF9zdW0gKz0gKCBwYSA9IHN0YWNrT3V0LmEgKTtcblx0XHRcdFxuXHRcdFx0cl9pbl9zdW0gLT0gcHI7XG5cdFx0XHRnX2luX3N1bSAtPSBwZztcblx0XHRcdGJfaW5fc3VtIC09IHBiO1xuXHRcdFx0YV9pbl9zdW0gLT0gcGE7XG5cdFx0XHRcblx0XHRcdHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblx0XHRcdFxuXHRcdFx0eWkgKz0gd2lkdGg7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEJsdXJTdGFjaygpXG57XG5cdHRoaXMuciA9IDA7XG5cdHRoaXMuZyA9IDA7XG5cdHRoaXMuYiA9IDA7XG5cdHRoaXMuYSA9IDA7XG5cdHRoaXMubmV4dCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmx1cjsiLCIvKlxuXHRCYXNlZCBvbiByZ2Jjb2xvci5qcyBieSBTdG95YW4gU3RlZmFub3YgPHNzdG9vQGdtYWlsLmNvbT5cblx0aHR0cDovL3d3dy5waHBpZWQuY29tL3JnYi1jb2xvci1wYXJzZXItaW4tamF2YXNjcmlwdC9cbiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29sb3Jfc3RyaW5nKSB7XG4gICAgdGhpcy5vayA9IGZhbHNlO1xuICAgIHRoaXMuYWxwaGEgPSAxLjA7XG5cbiAgICAvLyBzdHJpcCBhbnkgbGVhZGluZyAjXG4gICAgaWYgKGNvbG9yX3N0cmluZy5jaGFyQXQoMCkgPT0gJyMnKSB7IC8vIHJlbW92ZSAjIGlmIGFueVxuICAgICAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcuc3Vic3RyKDEsNik7XG4gICAgfVxuXG4gICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnJlcGxhY2UoLyAvZywnJyk7XG4gICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBiZWZvcmUgZ2V0dGluZyBpbnRvIHJlZ2V4cHMsIHRyeSBzaW1wbGUgbWF0Y2hlc1xuICAgIC8vIGFuZCBvdmVyd3JpdGUgdGhlIGlucHV0XG4gICAgdmFyIHNpbXBsZV9jb2xvcnMgPSB7XG4gICAgICAgIGFsaWNlYmx1ZTogJ2YwZjhmZicsXG4gICAgICAgIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gICAgICAgIGFxdWE6ICcwMGZmZmYnLFxuICAgICAgICBhcXVhbWFyaW5lOiAnN2ZmZmQ0JyxcbiAgICAgICAgYXp1cmU6ICdmMGZmZmYnLFxuICAgICAgICBiZWlnZTogJ2Y1ZjVkYycsXG4gICAgICAgIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gICAgICAgIGJsYWNrOiAnMDAwMDAwJyxcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICdmZmViY2QnLFxuICAgICAgICBibHVlOiAnMDAwMGZmJyxcbiAgICAgICAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gICAgICAgIGJyb3duOiAnYTUyYTJhJyxcbiAgICAgICAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgICAgICAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgICAgICAgY2hhcnRyZXVzZTogJzdmZmYwMCcsXG4gICAgICAgIGNob2NvbGF0ZTogJ2QyNjkxZScsXG4gICAgICAgIGNvcmFsOiAnZmY3ZjUwJyxcbiAgICAgICAgY29ybmZsb3dlcmJsdWU6ICc2NDk1ZWQnLFxuICAgICAgICBjb3Juc2lsazogJ2ZmZjhkYycsXG4gICAgICAgIGNyaW1zb246ICdkYzE0M2MnLFxuICAgICAgICBjeWFuOiAnMDBmZmZmJyxcbiAgICAgICAgZGFya2JsdWU6ICcwMDAwOGInLFxuICAgICAgICBkYXJrY3lhbjogJzAwOGI4YicsXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICdiODg2MGInLFxuICAgICAgICBkYXJrZ3JheTogJ2E5YTlhOScsXG4gICAgICAgIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gICAgICAgIGRhcmtraGFraTogJ2JkYjc2YicsXG4gICAgICAgIGRhcmttYWdlbnRhOiAnOGIwMDhiJyxcbiAgICAgICAgZGFya29saXZlZ3JlZW46ICc1NTZiMmYnLFxuICAgICAgICBkYXJrb3JhbmdlOiAnZmY4YzAwJyxcbiAgICAgICAgZGFya29yY2hpZDogJzk5MzJjYycsXG4gICAgICAgIGRhcmtyZWQ6ICc4YjAwMDAnLFxuICAgICAgICBkYXJrc2FsbW9uOiAnZTk5NjdhJyxcbiAgICAgICAgZGFya3NlYWdyZWVuOiAnOGZiYzhmJyxcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJzQ4M2Q4YicsXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcyZjRmNGYnLFxuICAgICAgICBkYXJrdHVycXVvaXNlOiAnMDBjZWQxJyxcbiAgICAgICAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gICAgICAgIGRlZXBwaW5rOiAnZmYxNDkzJyxcbiAgICAgICAgZGVlcHNreWJsdWU6ICcwMGJmZmYnLFxuICAgICAgICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgICAgICAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gICAgICAgIGZlbGRzcGFyOiAnZDE5Mjc1JyxcbiAgICAgICAgZmlyZWJyaWNrOiAnYjIyMjIyJyxcbiAgICAgICAgZmxvcmFsd2hpdGU6ICdmZmZhZjAnLFxuICAgICAgICBmb3Jlc3RncmVlbjogJzIyOGIyMicsXG4gICAgICAgIGZ1Y2hzaWE6ICdmZjAwZmYnLFxuICAgICAgICBnYWluc2Jvcm86ICdkY2RjZGMnLFxuICAgICAgICBnaG9zdHdoaXRlOiAnZjhmOGZmJyxcbiAgICAgICAgZ29sZDogJ2ZmZDcwMCcsXG4gICAgICAgIGdvbGRlbnJvZDogJ2RhYTUyMCcsXG4gICAgICAgIGdyYXk6ICc4MDgwODAnLFxuICAgICAgICBncmVlbjogJzAwODAwMCcsXG4gICAgICAgIGdyZWVueWVsbG93OiAnYWRmZjJmJyxcbiAgICAgICAgaG9uZXlkZXc6ICdmMGZmZjAnLFxuICAgICAgICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgICAgICAgaW5kaWFucmVkIDogJ2NkNWM1YycsXG4gICAgICAgIGluZGlnbyA6ICc0YjAwODInLFxuICAgICAgICBpdm9yeTogJ2ZmZmZmMCcsXG4gICAgICAgIGtoYWtpOiAnZjBlNjhjJyxcbiAgICAgICAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgICAgICAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgICAgICAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgICAgICAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgICAgICAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gICAgICAgIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgICAgICAgbGlnaHRncmV5OiAnZDNkM2QzJyxcbiAgICAgICAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gICAgICAgIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gICAgICAgIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgICAgICAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gICAgICAgIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gICAgICAgIGxpZ2h0c2xhdGVibHVlOiAnODQ3MGZmJyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICc3Nzg4OTknLFxuICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gICAgICAgIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgICAgICAgbGltZTogJzAwZmYwMCcsXG4gICAgICAgIGxpbWVncmVlbjogJzMyY2QzMicsXG4gICAgICAgIGxpbmVuOiAnZmFmMGU2JyxcbiAgICAgICAgbWFnZW50YTogJ2ZmMDBmZicsXG4gICAgICAgIG1hcm9vbjogJzgwMDAwMCcsXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICAgICAgICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgICAgICAgbWVkaXVtcHVycGxlOiAnOTM3MGQ4JyxcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gICAgICAgIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gICAgICAgIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gICAgICAgIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gICAgICAgIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgICAgICAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICAgICAgICBuYXZ5OiAnMDAwMDgwJyxcbiAgICAgICAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gICAgICAgIG9saXZlOiAnODA4MDAwJyxcbiAgICAgICAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgICAgICAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgICAgICAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgICAgICAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gICAgICAgIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiAnZDg3MDkzJyxcbiAgICAgICAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gICAgICAgIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gICAgICAgIHBlcnU6ICdjZDg1M2YnLFxuICAgICAgICBwaW5rOiAnZmZjMGNiJyxcbiAgICAgICAgcGx1bTogJ2RkYTBkZCcsXG4gICAgICAgIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICAgICAgICBwdXJwbGU6ICc4MDAwODAnLFxuICAgICAgICByZWQ6ICdmZjAwMDAnLFxuICAgICAgICByb3N5YnJvd246ICdiYzhmOGYnLFxuICAgICAgICByb3lhbGJsdWU6ICc0MTY5ZTEnLFxuICAgICAgICBzYWRkbGVicm93bjogJzhiNDUxMycsXG4gICAgICAgIHNhbG1vbjogJ2ZhODA3MicsXG4gICAgICAgIHNhbmR5YnJvd246ICdmNGE0NjAnLFxuICAgICAgICBzZWFncmVlbjogJzJlOGI1NycsXG4gICAgICAgIHNlYXNoZWxsOiAnZmZmNWVlJyxcbiAgICAgICAgc2llbm5hOiAnYTA1MjJkJyxcbiAgICAgICAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgICAgICAgc2t5Ymx1ZTogJzg3Y2VlYicsXG4gICAgICAgIHNsYXRlYmx1ZTogJzZhNWFjZCcsXG4gICAgICAgIHNsYXRlZ3JheTogJzcwODA5MCcsXG4gICAgICAgIHNub3c6ICdmZmZhZmEnLFxuICAgICAgICBzcHJpbmdncmVlbjogJzAwZmY3ZicsXG4gICAgICAgIHN0ZWVsYmx1ZTogJzQ2ODJiNCcsXG4gICAgICAgIHRhbjogJ2QyYjQ4YycsXG4gICAgICAgIHRlYWw6ICcwMDgwODAnLFxuICAgICAgICB0aGlzdGxlOiAnZDhiZmQ4JyxcbiAgICAgICAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgICAgICAgdHVycXVvaXNlOiAnNDBlMGQwJyxcbiAgICAgICAgdmlvbGV0OiAnZWU4MmVlJyxcbiAgICAgICAgdmlvbGV0cmVkOiAnZDAyMDkwJyxcbiAgICAgICAgd2hlYXQ6ICdmNWRlYjMnLFxuICAgICAgICB3aGl0ZTogJ2ZmZmZmZicsXG4gICAgICAgIHdoaXRlc21va2U6ICdmNWY1ZjUnLFxuICAgICAgICB5ZWxsb3c6ICdmZmZmMDAnLFxuICAgICAgICB5ZWxsb3dncmVlbjogJzlhY2QzMidcbiAgICB9O1xuICAgIGNvbG9yX3N0cmluZyA9IHNpbXBsZV9jb2xvcnNbY29sb3Jfc3RyaW5nXSB8fCBjb2xvcl9zdHJpbmc7XG4gICAgLy8gZW1kIG9mIHNpbXBsZSB0eXBlLWluIGNvbG9yc1xuXG4gICAgLy8gYXJyYXkgb2YgY29sb3IgZGVmaW5pdGlvbiBvYmplY3RzXG4gICAgdmFyIGNvbG9yX2RlZnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXnJnYmFcXCgoXFxkezEsM30pLFxccyooXFxkezEsM30pLFxccyooXFxkezEsM30pLFxccyooKD86XFxkP1xcLik/XFxkKVxcKSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWydyZ2JhKDEyMywgMjM0LCA0NSwgMC44KScsICdyZ2JhKDI1NSwyMzQsMjQ1LDEuMCknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJpdHNbNF0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiXFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KVxcKSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWydyZ2IoMTIzLCAyMzQsIDQ1KScsICdyZ2IoMjU1LDIzNCwyNDUpJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihcXHd7Mn0pKFxcd3syfSkoXFx3ezJ9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjMDBmZjAwJywgJzMzNjY5OSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL14oXFx3ezF9KShcXHd7MX0pKFxcd3sxfSkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsnI2ZiMCcsICdmMGYnXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdICsgYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdICsgYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdICsgYml0c1szXSwgMTYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF07XG5cbiAgICAvLyBzZWFyY2ggdGhyb3VnaCB0aGUgZGVmaW5pdGlvbnMgdG8gZmluZCBhIG1hdGNoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcl9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZSA9IGNvbG9yX2RlZnNbaV0ucmU7XG4gICAgICAgIHZhciBwcm9jZXNzb3IgPSBjb2xvcl9kZWZzW2ldLnByb2Nlc3M7XG4gICAgICAgIHZhciBiaXRzID0gcmUuZXhlYyhjb2xvcl9zdHJpbmcpO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxzID0gcHJvY2Vzc29yKGJpdHMpO1xuICAgICAgICAgICAgdGhpcy5yID0gY2hhbm5lbHNbMF07XG4gICAgICAgICAgICB0aGlzLmcgPSBjaGFubmVsc1sxXTtcbiAgICAgICAgICAgIHRoaXMuYiA9IGNoYW5uZWxzWzJdO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhID0gY2hhbm5lbHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9rID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUvY2xlYW51cCB2YWx1ZXNcbiAgICB0aGlzLnIgPSAodGhpcy5yIDwgMCB8fCBpc05hTih0aGlzLnIpKSA/IDAgOiAoKHRoaXMuciA+IDI1NSkgPyAyNTUgOiB0aGlzLnIpO1xuICAgIHRoaXMuZyA9ICh0aGlzLmcgPCAwIHx8IGlzTmFOKHRoaXMuZykpID8gMCA6ICgodGhpcy5nID4gMjU1KSA/IDI1NSA6IHRoaXMuZyk7XG4gICAgdGhpcy5iID0gKHRoaXMuYiA8IDAgfHwgaXNOYU4odGhpcy5iKSkgPyAwIDogKCh0aGlzLmIgPiAyNTUpID8gMjU1IDogdGhpcy5iKTtcbiAgICB0aGlzLmFscGhhID0gKHRoaXMuYWxwaGEgPCAwKSA/IDAgOiAoKHRoaXMuYWxwaGEgPiAxLjAgfHwgaXNOYU4odGhpcy5hbHBoYSkpID8gMS4wIDogdGhpcy5hbHBoYSk7XG5cbiAgICAvLyBzb21lIGdldHRlcnNcbiAgICB0aGlzLnRvUkdCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnKSc7XG4gICAgfVxuICAgIHRoaXMudG9SR0JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMuciArICcsICcgKyB0aGlzLmcgKyAnLCAnICsgdGhpcy5iICsgJywgJyArIHRoaXMuYWxwaGEgKyAnKSc7XG4gICAgfVxuICAgIHRoaXMudG9IZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5yLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmcudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChyLmxlbmd0aCA9PSAxKSByID0gJzAnICsgcjtcbiAgICAgICAgaWYgKGcubGVuZ3RoID09IDEpIGcgPSAnMCcgKyBnO1xuICAgICAgICBpZiAoYi5sZW5ndGggPT0gMSkgYiA9ICcwJyArIGI7XG4gICAgICAgIHJldHVybiAnIycgKyByICsgZyArIGI7XG4gICAgfVxuXG4gICAgLy8gaGVscFxuICAgIHRoaXMuZ2V0SGVscFhNTCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgZXhhbXBsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgLy8gYWRkIHJlZ2V4cHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcl9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhhbXBsZSA9IGNvbG9yX2RlZnNbaV0uZXhhbXBsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXhhbXBsZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBleGFtcGxlW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0eXBlLWluIGNvbG9yc1xuICAgICAgICBmb3IgKHZhciBzYyBpbiBzaW1wbGVfY29sb3JzKSB7XG4gICAgICAgICAgICBleGFtcGxlc1tleGFtcGxlcy5sZW5ndGhdID0gc2M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgeG1sLnNldEF0dHJpYnV0ZSgnaWQnLCAncmdiY29sb3ItZXhhbXBsZXMnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdF9pdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdF9jb2xvciA9IG5ldyBSR0JDb2xvcihleGFtcGxlc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luOiAzcHg7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JvcmRlcjogMXB4IHNvbGlkIGJsYWNrOyAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdiYWNrZ3JvdW5kOicgKyBsaXN0X2NvbG9yLnRvSGV4KCkgKyAnOyAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdjb2xvcjonICsgbGlzdF9jb2xvci50b0hleCgpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGV4YW1wbGVfZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd0ZXN0JykpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW1fdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICAgICAgICAgICAgJyAnICsgZXhhbXBsZXNbaV0gKyAnIC0+ICcgKyBsaXN0X2NvbG9yLnRvUkdCKCkgKyAnIC0+ICcgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxpc3RfaXRlbS5hcHBlbmRDaGlsZChleGFtcGxlX2Rpdik7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGxpc3RfaXRlbV92YWx1ZSk7XG4gICAgICAgICAgICAgICAgeG1sLmFwcGVuZENoaWxkKGxpc3RfaXRlbSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4bWw7XG5cbiAgICB9XG5cbn1cbiIsIi8qKlxuXHRUaGUgbWlzc2luZyBTVkcudG9EYXRhVVJMIGxpYnJhcnkgZm9yIHlvdXIgU1ZHIGVsZW1lbnRzLlxuXG5cdFVzYWdlOiBTVkdFbGVtZW50LnRvRGF0YVVSTCggdHlwZSwgeyBvcHRpb25zIH0gKVxuXG5cdFJldHVybnM6IHRoZSBkYXRhIFVSTCwgZXhjZXB0IHdoZW4gdXNpbmcgbmF0aXZlIFBORyByZW5kZXJlciAobmVlZHMgY2FsbGJhY2spLlxuXG5cdHR5cGVcdE1JTUUgdHlwZSBvZiB0aGUgZXhwb3J0ZWQgZGF0YS5cblx0XHRcdERlZmF1bHQ6IGltYWdlL3N2Zyt4bWwuXG5cdFx0XHRNdXN0IHN1cHBvcnQ6IGltYWdlL3BuZy5cblx0XHRcdEFkZGl0aW9uYWw6IGltYWdlL2pwZWcuXG5cblx0b3B0aW9ucyBpcyBhIG1hcCBvZiBvcHRpb25zOiB7XG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGRhdGFVUkwpXG5cdFx0XHRDYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZGF0YSBVUkwgaXMgcmVhZHkuXG5cdFx0XHRUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IHdoZW4gdXNpbmcgbmF0aXZlIFBORyByZW5kZXJlci5cblx0XHRcdERlZmF1bHQ6IHVuZGVmaW5lZC5cblxuXHRcdFt0aGUgcmVzdCBvZiB0aGUgb3B0aW9ucyBvbmx5IGFwcGx5IHdoZW4gdHlwZT1cImltYWdlL3BuZ1wiIG9yIHR5cGU9XCJpbWFnZS9qcGVnXCJdXG5cblx0XHRyZW5kZXJlcjogXCJuYXRpdmVcInxcImNhbnZnXCJcblx0XHRcdFBORyByZW5kZXJlciB0byB1c2UuIE5hdGl2ZSByZW5kZXJlcsK5IG1pZ2h0IGNhdXNlIGEgc2VjdXJpdHkgZXhjZXB0aW9uLlxuXHRcdFx0RGVmYXVsdDogY2FudmcgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgbmF0aXZlLlxuXG5cdFx0a2VlcE5vblNhZmU6IHRydWV8ZmFsc2Vcblx0XHRcdEV4cG9ydCBub24tc2FmZSAoaW1hZ2UgYW5kIGZvcmVpZ25PYmplY3QpIGVsZW1lbnRzLlxuXHRcdFx0VGhpcyB3aWxsIHNldCB0aGUgQ2FudmFzIG9yaWdpbi1jbGVhbiBwcm9wZXJ0eSB0byBmYWxzZSwgaWYgdGhpcyBkYXRhIGlzIHRyYW5zZmVycmVkIHRvIENhbnZhcy5cblx0XHRcdERlZmF1bHQ6IGZhbHNlLCB0byBrZWVwIG9yaWdpbi1jbGVhbiB0cnVlLlxuXHRcdFx0Tk9URTogbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYW5kIGlzIGp1c3QgaWdub3JlZC5cblxuXHRcdGtlZXBPdXRzaWRlVmlld3BvcnQ6IHRydWV8ZmFsc2Vcblx0XHRcdEV4cG9ydCBhbGwgZHJhd24gY29udGVudCwgZXZlbiBpZiBub3QgdmlzaWJsZS5cblx0XHRcdERlZmF1bHQ6IGZhbHNlLCBleHBvcnQgb25seSB2aXNpYmxlIHZpZXdwb3J0LCBzaW1pbGFyIHRvIENhbnZhcyB0b0RhdGFVUkwoKS5cblx0XHRcdE5PVEU6IG9ubHkgc3VwcG9ydGVkIHdpdGggY2FudmcgcmVuZGVyZXIuXG5cdH1cblxuXHRTZWUgb3JpZ2luYWwgcGFwZXLCuSBmb3IgbW9yZSBpbmZvIG9uIFNWRyB0byBDYW52YXMgZXhwb3J0aW5nLlxuXG5cdMK5IGh0dHA6Ly9zdmdvcGVuLm9yZy8yMDEwL3BhcGVycy82Mi1Gcm9tX1NWR190b19DYW52YXNfYW5kX0JhY2svI3N2Z190b19jYW52YXNcbiovXG5cblNWR0VsZW1lbnQucHJvdG90eXBlLnRvRGF0YVVSTCA9IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMpIHtcblx0dmFyIF9zdmcgPSB0aGlzO1xuXG5cdGZ1bmN0aW9uIGRlYnVnKHMpIHtcblx0XHQvLyBXZSBjb3VsZCBmaW5kIHRvIGEgd2F5IHRvIG1ha2UgdGhpcyBkaXNwbGF5IGRlcGVuZGluZyBvbiBlbnZpcm9ubWVudCwgYnV0XG5cdFx0Ly8gZm9yIG5vdyBJIHRoaW5rIGl0J3Mgb2theSB0byBqdXN0IGRpc2FibGUuXG5cdFx0Ly8gY29uc29sZS5sb2coXCJTVkcudG9EYXRhVVJMOlwiLCBzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNWRygpIHtcblx0XHR2YXIgc3ZnX3htbCA9IFhNTFNlcmlhbGl6ZShfc3ZnKTtcblx0XHR2YXIgc3ZnX2RhdGF1cmwgPSBiYXNlNjRkYXRhVVJMZW5jb2RlKHN2Z194bWwpO1xuXHRcdGRlYnVnKHR5cGUgKyBcIiBsZW5ndGg6IFwiICsgc3ZnX2RhdGF1cmwubGVuZ3RoKTtcblxuXHRcdC8vIE5PVEUgZG91YmxlIGRhdGEgY2FycmllclxuXHRcdGlmIChvcHRpb25zLmNhbGxiYWNrKSBvcHRpb25zLmNhbGxiYWNrKHN2Z19kYXRhdXJsKTtcblx0XHRyZXR1cm4gc3ZnX2RhdGF1cmw7XG5cdH1cblxuXHRmdW5jdGlvbiBYTUxTZXJpYWxpemUoc3ZnKSB7XG5cblx0XHQvLyBxdWljay1uLXNlcmlhbGl6ZSBhbiBTVkcgZG9tLCBuZWVkZWQgZm9yIElFOSB3aGVyZSB0aGVyZSdzIG5vIFhNTFNlcmlhbGl6ZXIgbm9yIFNWRy54bWxcblx0XHQvLyBzOiBTVkcgZG9tLCB3aGljaCBpcyB0aGUgPHN2Zz4gZWxlbWVubnRcblx0XHRmdW5jdGlvbiBYTUxTZXJpYWxpemVyRm9ySUUocykge1xuXHRcdFx0dmFyIG91dCA9IFwiXCI7XG5cblx0XHRcdG91dCArPSBcIjxcIiArIHMubm9kZU5hbWU7XG5cdFx0XHRmb3IgKHZhciBuID0gMDsgbiA8IHMuYXR0cmlidXRlcy5sZW5ndGg7IG4rKykge1xuXHRcdFx0XHRvdXQgKz0gXCIgXCIgKyBzLmF0dHJpYnV0ZXNbbl0ubmFtZSArIFwiPVwiICsgXCInXCIgKyBzLmF0dHJpYnV0ZXNbbl0udmFsdWUgKyBcIidcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHMuaGFzQ2hpbGROb2RlcygpKSB7XG5cdFx0XHRcdG91dCArPSBcIj5cXG5cIjtcblxuXHRcdFx0XHRmb3IgKHZhciBuID0gMDsgbiA8IHMuY2hpbGROb2Rlcy5sZW5ndGg7IG4rKykge1xuXHRcdFx0XHRcdG91dCArPSBYTUxTZXJpYWxpemVyRm9ySUUocy5jaGlsZE5vZGVzW25dKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dCArPSBcIjwvXCIgKyBzLm5vZGVOYW1lICsgXCI+XCIgKyBcIlxcblwiO1xuXG5cdFx0XHR9IGVsc2Ugb3V0ICs9IFwiIC8+XFxuXCI7XG5cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXG5cblx0XHRpZiAod2luZG93LlhNTFNlcmlhbGl6ZXIpIHtcblx0XHRcdGRlYnVnKFwidXNpbmcgc3RhbmRhcmQgWE1MU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIChuZXcgWE1MU2VyaWFsaXplcigpKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWJ1ZyhcInVzaW5nIGN1c3RvbSBYTUxTZXJpYWxpemVyRm9ySUVcIilcblx0XHRcdHJldHVybiBYTUxTZXJpYWxpemVyRm9ySUUoc3ZnKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJhc2U2NGRhdGFVUkxlbmNvZGUocykge1xuXHRcdHZhciBiNjQgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCI7XG5cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LmJ0b2Fcblx0XHRpZiAod2luZG93LmJ0b2EpIHtcblx0XHRcdGRlYnVnKFwidXNpbmcgd2luZG93LmJ0b2EgZm9yIGJhc2U2NCBlbmNvZGluZ1wiKTtcblx0XHRcdGI2NCArPSBidG9hKHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWJ1ZyhcInVzaW5nIGN1c3RvbSBiYXNlNjQgZW5jb2RlclwiKTtcblx0XHRcdGI2NCArPSBCYXNlNjQuZW5jb2RlKHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBiNjQ7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRJbWFnZSh0eXBlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gVE9ETzogaWYgKG9wdGlvbnMua2VlcE91dHNpZGVWaWV3cG9ydCksIGRvIHNvbWUgdHJhbnNsYXRpb24gbWFnaWM/XG5cblx0XHR2YXIgc3ZnX2ltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdHZhciBzdmdfeG1sID0gWE1MU2VyaWFsaXplKF9zdmcpO1xuXHRcdHN2Z19pbWcuc3JjID0gYmFzZTY0ZGF0YVVSTGVuY29kZShzdmdfeG1sKTtcblxuXHRcdHN2Z19pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWJ1ZyhcImV4cG9ydGVkIGltYWdlIHNpemU6IFwiICsgW3N2Z19pbWcud2lkdGgsIHN2Z19pbWcuaGVpZ2h0XSlcblx0XHRcdGNhbnZhcy53aWR0aCA9IHN2Z19pbWcud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gc3ZnX2ltZy5oZWlnaHQ7XG5cdFx0XHRjdHguZHJhd0ltYWdlKHN2Z19pbWcsIDAsIDApO1xuXG5cdFx0XHQvLyBTRUNVUklUWV9FUlIgV0lMTCBIQVBQRU4gTk9XXG5cdFx0XHR2YXIgcG5nX2RhdGF1cmwgPSBjYW52YXMudG9EYXRhVVJMKHR5cGUpO1xuXHRcdFx0ZGVidWcodHlwZSArIFwiIGxlbmd0aDogXCIgKyBwbmdfZGF0YXVybC5sZW5ndGgpO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5jYWxsYmFjaykgb3B0aW9ucy5jYWxsYmFjayggcG5nX2RhdGF1cmwgKTtcblx0XHRcdGVsc2UgZGVidWcoXCJXQVJOSU5HOiBubyBjYWxsYmFjayBzZXQsIHNvIG5vdGhpbmcgaGFwcGVucy5cIik7XG5cdFx0fVxuXG5cdFx0c3ZnX2ltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XCJDYW4ndCBleHBvcnQhIE1heWJlIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgXCIgK1xuXHRcdFx0XHRcIlNWRyBpbiBpbWcgZWxlbWVudCBvciBTVkcgaW5wdXQgZm9yIENhbnZhcyBkcmF3SW1hZ2U/XFxuXCIgK1xuXHRcdFx0XHRcImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1ZHI05hdGl2ZV9zdXBwb3J0XCJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gTk9URTogd2lsbCBub3QgcmV0dXJuIGFueXRoaW5nXG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRJbWFnZUNhbnZnKHR5cGUpIHtcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dmFyIHN2Z194bWwgPSBYTUxTZXJpYWxpemUoX3N2Zyk7XG5cblx0XHQvLyBOT1RFOiBjYW52ZyBnZXRzIHRoZSBTVkcgZWxlbWVudCBkaW1lbnNpb25zIGluY29ycmVjdGx5IGlmIG5vdCBzcGVjaWZpZWQgYXMgYXR0cmlidXRlc1xuXHRcdC8vZGVidWcoXCJkZXRlY3RlZCBzdmcgZGltZW5zaW9ucyBcIiArIFtfc3ZnLmNsaWVudFdpZHRoLCBfc3ZnLmNsaWVudEhlaWdodF0pXG5cdFx0Ly9kZWJ1ZyhcImNhbnZhcyBkaW1lbnNpb25zIFwiICsgW2NhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF0pXG5cblx0XHR2YXIga2VlcEJCID0gb3B0aW9ucy5rZWVwT3V0c2lkZVZpZXdwb3J0O1xuXHRcdGlmIChrZWVwQkIpIHZhciBiYiA9IF9zdmcuZ2V0QkJveCgpO1xuXG5cdFx0Ly8gTk9URTogdGhpcyBjYW52ZyBjYWxsIGlzIHN5bmNocm9ub3VzIGFuZCBibG9ja3MgKG5vIGl0IGRvZXMgbm90KVxuXHRcdGNhbnZnKGNhbnZhcywgc3ZnX3htbCwge1xuXHRcdFx0aWdub3JlTW91c2U6IHRydWUsIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdG9mZnNldFg6IGtlZXBCQiA/IC1iYi54IDogdW5kZWZpbmVkLFxuXHRcdFx0b2Zmc2V0WToga2VlcEJCID8gLWJiLnkgOiB1bmRlZmluZWQsXG5cdFx0XHRzY2FsZVdpZHRoOiBrZWVwQkIgPyBiYi53aWR0aCtiYi54IDogdW5kZWZpbmVkLFxuXHRcdFx0c2NhbGVIZWlnaHQ6IGtlZXBCQiA/IGJiLmhlaWdodCtiYi55IDogdW5kZWZpbmVkLFxuXHRcdFx0cmVuZGVyQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWJ1ZyhcImV4cG9ydGVkIGltYWdlIGRpbWVuc2lvbnMgXCIgKyBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSk7XG5cdFx0XHRcdHZhciBwbmdfZGF0YXVybCA9IGNhbnZhcy50b0RhdGFVUkwodHlwZSk7XG5cdFx0XHRcdGRlYnVnKHR5cGUgKyBcIiBsZW5ndGg6IFwiICsgcG5nX2RhdGF1cmwubGVuZ3RoKTtcblxuXHRcdFx0XHRpZiAob3B0aW9ucy5jYWxsYmFjaykgb3B0aW9ucy5jYWxsYmFjayggcG5nX2RhdGF1cmwgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIE5PVEU6IHJldHVybiBpbiBhZGRpdGlvbiB0byBjYWxsYmFja1xuXHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKHR5cGUpO1xuXHR9XG5cblx0Ly8gQkVHSU4gTUFJTlxuXG5cdGlmICghdHlwZSkgdHlwZSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuXHRpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuXHRpZiAob3B0aW9ucy5rZWVwTm9uU2FmZSkgZGVidWcoXCJOT1RFOiBrZWVwTm9uU2FmZSBpcyBOT1Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQhXCIpO1xuXHRpZiAob3B0aW9ucy5rZWVwT3V0c2lkZVZpZXdwb3J0KSBkZWJ1ZyhcIk5PVEU6IGtlZXBPdXRzaWRlVmlld3BvcnQgaXMgb25seSBzdXBwb3J0ZWQgd2l0aCBjYW52ZyBleHBvcnRlci5cIik7XG5cblx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSBcImltYWdlL3N2Zyt4bWxcIjpcblx0XHRcdHJldHVybiBleHBvcnRTVkcoKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcImltYWdlL3BuZ1wiOlxuXHRcdGNhc2UgXCJpbWFnZS9qcGVnXCI6XG5cblx0XHRcdGlmICghb3B0aW9ucy5yZW5kZXJlcikge1xuXHRcdFx0XHRpZiAod2luZG93LmNhbnZnKSBvcHRpb25zLnJlbmRlcmVyID0gXCJjYW52Z1wiO1xuXHRcdFx0XHRlbHNlIG9wdGlvbnMucmVuZGVyZXI9XCJuYXRpdmVcIjtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChvcHRpb25zLnJlbmRlcmVyKSB7XG5cdFx0XHRcdGNhc2UgXCJjYW52Z1wiOlxuXHRcdFx0XHRcdGRlYnVnKFwidXNpbmcgY2FudmcgcmVuZGVyZXIgZm9yIHBuZyBleHBvcnRcIik7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cG9ydEltYWdlQ2FudmcodHlwZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm5hdGl2ZVwiOlxuXHRcdFx0XHRcdGRlYnVnKFwidXNpbmcgbmF0aXZlIHJlbmRlcmVyIGZvciBwbmcgZXhwb3J0LiBUSElTIE1JR0hUIEZBSUwuXCIpO1xuXHRcdFx0XHRcdHJldHVybiBleHBvcnRJbWFnZSh0eXBlKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGRlYnVnKFwidW5rbm93biBwbmcgcmVuZGVyZXIgZ2l2ZW4sIGRvaW5nIG5vdGluZyAoXCIgKyBvcHRpb25zLnJlbmRlcmVyICsgXCIpXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRkZWJ1ZyhcIlNvcnJ5ISBFeHBvcnRpbmcgYXMgJ1wiICsgdHlwZSArIFwiJyBpcyBub3Qgc3VwcG9ydGVkIVwiKVxuXHR9XG59XG4iLCIvKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9uYWwgYmxvY2tzXG4gKi9cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcblxudmFyIEFSSVRITUVUSUNfVElUTEVfRk9OVF9TSVpFID0gMjU7XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGluc3RhbGxQbHVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbE1pbnVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbFRpbWVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbERpdmlkZWRCeShibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxHcmVhdGVyVGhhbihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxMZXNzVGhhbihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxOdW1iZXJFcXVhbHMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsU3RyaW5nRXF1YWxzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbExvZ2ljYWxBbmQoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsTG9naWNhbE9yKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbExvZ2ljYWxOb3QoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pO1xuICBpbnN0YWxsQm9vbGVhbihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxNYXRoTnVtYmVyKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKTtcbiAgaW5zdGFsbFN0cmluZyhibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSk7XG4gIGluc3RhbGxDb25kKGJsb2NrbHksIGdlbmVyYXRvcik7XG4gIGluc3RhbGxTcXJ0KGJsb2NrbHksIGdlbmVyYXRvcik7XG4gIGluc3RhbGxQb3coYmxvY2tseSwgZ2VuZXJhdG9yKTtcbiAgaW5zdGFsbFNxdWFyZWQoYmxvY2tseSwgZ2VuZXJhdG9yKTtcbn07XG5cbmZ1bmN0aW9uIGluc3RhbGxQbHVzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfcGx1cyA9IHtcblxuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICcrJywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIsIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9XG4gICAgICBdLCB7IHRpdGxlRm9udFNpemU6IEFSSVRITUVUSUNfVElUTEVfRk9OVF9TSVpFfSk7XG5cblxuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9wbHVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuIFwiKFwiICsgYXJnMSArIFwiICsgXCIgKyBhcmcyICsgXCIpXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNaW51cyhibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX21pbnVzID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICctJywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIsIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9XG4gICAgICBdLCB7IHRpdGxlRm9udFNpemU6IEFSSVRITUVUSUNfVElUTEVfRk9OVF9TSVpFfSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX21pbnVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuIFwiKFwiICsgYXJnMSArIFwiIC0gXCIgKyBhcmcyICsgXCIpXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxUaW1lcyhibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX3RpbWVzID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICcqJywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIsIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9XG4gICAgICBdLCB7IHRpdGxlRm9udFNpemU6IEFSSVRITUVUSUNfVElUTEVfRk9OVF9TSVpFfSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3RpbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuIFwiKFwiICsgYXJnMSArIFwiICogXCIgKyBhcmcyICsgXCIpXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxEaXZpZGVkQnkoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9kaXZpZGVkYnkgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJy8nLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0sIHsgdGl0bGVGb250U2l6ZTogQVJJVEhNRVRJQ19USVRMRV9GT05UX1NJWkV9KTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfZGl2aWRlZGJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuIFwiKFwiICsgYXJnMSArIFwiIC8gXCIgKyBhcmcyICsgXCIpXCI7XG4gIH07XG59XG5cbi8vIEluc3RhbGwgY29tcGFyYXRvcnNcblxuZnVuY3Rpb24gaW5zdGFsbEdyZWF0ZXJUaGFuKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfZ3JlYXRlcl90aGFuID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICc+JywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUiB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2dyZWF0ZXJfdGhhbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAwO1xuICAgIHZhciBhcmcyID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMicsIGZhbHNlKSB8fCAwO1xuICAgIHJldHVybiAnKCcgKyBhcmcxICsgXCIgPiBcIiArIGFyZzIgKyAnKSc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxMZXNzVGhhbihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2xlc3NfdGhhbiA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnPCcsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9sZXNzX3RoYW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJygnICsgYXJnMSArIFwiIDwgXCIgKyBhcmcyICsgJyknO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsTnVtYmVyRXF1YWxzKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfbnVtYmVyX2VxdWFscyA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnPScsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIgfSxcbiAgICAgICAgeyBuYW1lOiAnQVJHMicsIHR5cGU6IGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSIH1cbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9udW1iZXJfZXF1YWxzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuICcoJyArIGFyZzEgKyBcIiA9PSBcIiArIGFyZzIgKyAnKSc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxTdHJpbmdFcXVhbHMoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9zdHJpbmdfZXF1YWxzID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsIG1zZy5zdHJpbmdFcXVhbHMoKSwgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLlNUUklORyB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5TVFJJTkcgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3N0cmluZ19lcXVhbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgJyc7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8ICcnO1xuICAgIHJldHVybiAnKCcgKyBhcmcxICsgXCIgPT0gXCIgKyBhcmcyICsgJyknO1xuICB9O1xufVxuXG4vLyBJbnN0YWxsIGJvb2xlYW4gb3BlcmF0b3JzXG5cbmZ1bmN0aW9uIGluc3RhbGxMb2dpY2FsQW5kKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfbG9naWNhbF9hbmQgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJ2FuZCcsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4gfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2xvZ2ljYWxfYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgdmFyIGFyZzIgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcyJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuICcoJyArIGFyZzEgKyBcIiAmJiBcIiArIGFyZzIgKyAnKSc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxMb2dpY2FsT3IoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9sb2dpY2FsX29yID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgYmxvY2tseS5GdW5jdGlvbmFsQmxvY2tVdGlscy5pbml0VGl0bGVkRnVuY3Rpb25hbEJsb2NrKHRoaXMsICdvcicsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTiwgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOIH0sXG4gICAgICAgIHsgbmFtZTogJ0FSRzInLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4gfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2xvZ2ljYWxfb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICB2YXIgYXJnMiA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzInLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJygnICsgYXJnMSArIFwiIHx8IFwiICsgYXJnMiArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbExvZ2ljYWxOb3QoYmxvY2tseSwgZ2VuZXJhdG9yLCBnZW5zeW0pIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9sb2dpY2FsX25vdCA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnbm90JywgYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4gfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX2xvZ2ljYWxfbm90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuICchKCcgKyBhcmcxICsgJyknO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsQm9vbGVhbihibG9ja2x5LCBnZW5lcmF0b3IsIGdlbnN5bSkge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2Jvb2xlYW4gPSB7XG4gICAgLy8gQm9vbGVhbiB2YWx1ZS5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbCh0cnVlLCB7XG4gICAgICAgIGhlYWRlckhlaWdodDogMCxcbiAgICAgICAgcm93QnVmZmVyOiAzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0SFNWLmFwcGx5KHRoaXMsIGJsb2NrbHkuRnVuY3Rpb25hbFR5cGVDb2xvcnNbYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOXSk7XG4gICAgICB2YXIgdmFsdWVzID0gYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9ib29sZWFuLlZBTFVFUztcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkRHJvcGRvd24odmFsdWVzKSwgJ1ZBTCcpXG4gICAgICAgICAgLnNldEFsaWduKEJsb2NrbHkuQUxJR05fQ0VOVFJFKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbE91dHB1dCh0cnVlLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4pO1xuICAgIH1cbiAgfTtcblxuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX2Jvb2xlYW4uVkFMVUVTID0gW1xuICAgICAgICBbbXNnLmJvb2xlYW5UcnVlKCksICd0cnVlJ10sXG4gICAgICAgIFttc2cuYm9vbGVhbkZhbHNlKCksICdmYWxzZSddXTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9ib29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGVWYWx1ZSgnVkFMJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNYXRoTnVtYmVyKGJsb2NrbHksIGdlbmVyYXRvciwgZ2Vuc3ltKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfbWF0aF9udW1iZXIgPSB7XG4gICAgLy8gTnVtZXJpYyB2YWx1ZS5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbCh0cnVlLCB7XG4gICAgICAgIGhlYWRlckhlaWdodDogMCxcbiAgICAgICAgcm93QnVmZmVyOiAzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0SFNWLmFwcGx5KHRoaXMsIGJsb2NrbHkuRnVuY3Rpb25hbFR5cGVDb2xvcnNbYmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVJdKTtcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBCbG9ja2x5LkZpZWxkVGV4dElucHV0KCcwJyxcbiAgICAgICAgICAgIEJsb2NrbHkuRmllbGRUZXh0SW5wdXQubnVtYmVyVmFsaWRhdG9yKSwgJ05VTScpXG4gICAgICAgICAgLnNldEFsaWduKEJsb2NrbHkuQUxJR05fQ0VOVFJFKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbE91dHB1dCh0cnVlLCBibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUik7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX21hdGhfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGVWYWx1ZSgnTlVNJyk7XG4gIH07XG5cbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9tYXRoX251bWJlcl9kcm9wZG93biA9IHtcbiAgICAvLyBOdW1lcmljIHZhbHVlLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsKHRydWUsIHtcbiAgICAgICAgaGVhZGVySGVpZ2h0OiAwLFxuICAgICAgICByb3dCdWZmZXI6IDNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRIU1YuYXBwbHkodGhpcywgYmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1tibG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5VTUJFUl0pO1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGREcm9wZG93bigpLCAnTlVNJylcbiAgICAgICAgICAuc2V0QWxpZ24oQmxvY2tseS5BTElHTl9DRU5UUkUpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsT3V0cHV0KHRydWUsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfbWF0aF9udW1iZXJfZHJvcGRvd24gPSBnZW5lcmF0b3IuZnVuY3Rpb25hbF9tYXRoX251bWJlcjtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFN0cmluZyhibG9ja2x5LCBnZW5lcmF0b3IpIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9zdHJpbmcgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uYWwodHJ1ZSwge1xuICAgICAgICBoZWFkZXJIZWlnaHQ6IDAsXG4gICAgICAgIHJvd0J1ZmZlcjogM1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEhTVi5hcHBseSh0aGlzLCBibG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW2Jsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuU1RSSU5HXSk7XG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGRMYWJlbCgnXCInKSlcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBCbG9ja2x5LkZpZWxkVGV4dElucHV0KCcnKSwgJ1ZBTCcpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgQmxvY2tseS5GaWVsZExhYmVsKCdcIicpKVxuICAgICAgICAuc2V0QWxpZ24oQmxvY2tseS5BTElHTl9DRU5UUkUpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbmFsT3V0cHV0KHRydWUsIGJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuU1RSSU5HKTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdG9yLmZ1bmN0aW9uYWxfc3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJsb2NrbHkuSmF2YVNjcmlwdC5xdW90ZV8odGhpcy5nZXRUaXRsZVZhbHVlKCdWQUwnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxTcXJ0KGJsb2NrbHksIGdlbmVyYXRvcikge1xuICBibG9ja2x5LkJsb2Nrcy5mdW5jdGlvbmFsX3NxcnQgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJ3NxcnQnLCAnTnVtYmVyJywgW1xuICAgICAgICB7IG5hbWU6ICdBUkcxJywgdHlwZTogJ051bWJlcicgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3NxcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJnMSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0FSRzEnLCBmYWxzZSkgfHwgMDtcbiAgICByZXR1cm4gJ01hdGguc3FydCgnICsgYXJnMSArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFBvdyhibG9ja2x5LCBnZW5lcmF0b3IpIHtcbiAgYmxvY2tseS5CbG9ja3MuZnVuY3Rpb25hbF9wb3cgPSB7XG4gICAgaGVscFVybDogJycsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBibG9ja2x5LkZ1bmN0aW9uYWxCbG9ja1V0aWxzLmluaXRUaXRsZWRGdW5jdGlvbmFsQmxvY2sodGhpcywgJ3BvdycsICdOdW1iZXInLCBbXG4gICAgICAgIHsgbmFtZTogJ0FSRzEnLCB0eXBlOiAnTnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdBUkcyJywgdHlwZTogJ051bWJlcicgfVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGdlbmVyYXRvci5mdW5jdGlvbmFsX3BvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmcxID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMScsIGZhbHNlKSB8fCAwO1xuICAgIHZhciBhcmcyID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQVJHMicsIGZhbHNlKSB8fCAwO1xuICAgIHJldHVybiAnTWF0aC5wb3coJyArIGFyZzEgKyAnLCAnICsgYXJnMiArICcpJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFNxdWFyZWQoYmxvY2tseSwgZ2VuZXJhdG9yKSB7XG4gIGJsb2NrbHkuQmxvY2tzLmZ1bmN0aW9uYWxfc3F1YXJlZCA9IHtcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGJsb2NrbHkuRnVuY3Rpb25hbEJsb2NrVXRpbHMuaW5pdFRpdGxlZEZ1bmN0aW9uYWxCbG9jayh0aGlzLCAnc3FyJywgJ051bWJlcicsIFtcbiAgICAgICAgeyBuYW1lOiAnQVJHMScsIHR5cGU6ICdOdW1iZXInIH1cbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3IuZnVuY3Rpb25hbF9zcXVhcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZzEgPSBCbG9ja2x5LkphdmFTY3JpcHQuc3RhdGVtZW50VG9Db2RlKHRoaXMsICdBUkcxJywgZmFsc2UpIHx8IDA7XG4gICAgcmV0dXJuIGFyZzEgKyAnICogJyArIGFyZzE7XG4gIH07XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgY29uZCBibG9jay4gbnVtUGFpcnMgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mXG4gKiBjb25kaXRpb24tdmFsdWUgcGFpcnMgYmVmb3JlIHRoZSBkZWZhdWx0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBpbnN0YWxsQ29uZChibG9ja2x5LCBnZW5lcmF0b3IpIHtcbiAgLy8gVE9ETyhicmVudCkgLSBydGxcbiAgdmFyIHR5cGVzID0gW0Jsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTk9ORSwgQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5OVU1CRVIsXG4gICAgQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5TVFJJTkcsIEJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuSU1BR0UsXG4gICAgQmxvY2tseS5CbG9ja1ZhbHVlVHlwZS5CT09MRUFOXTtcblxuICAvLyBHZW5lcmF0ZXMgdGhlIGZvbGxvd2luZyBibG9ja3M6XG4gIC8vIGZ1bmN0aW9uYWxfY29uZCAoZGVwcmVjYXRlZClcbiAgLy8gZnVuY3Rpb25hbF9jb25kX251bWJlclxuICAvLyBmdW5jdGlvbmFsX2NvbmRfc3RyaW5nXG4gIC8vIGZ1bmN0aW9uYWxfY29uZF9ib29sZWFuXG4gIC8vIGZ1bmN0aW9uYWxfY29uZF9pbWFnZVxuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaW5zdGFsbENvbmRGb3JUeXBlKGJsb2NrbHksIGdlbmVyYXRvciwgdHlwZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29uZEZvclR5cGUoYmxvY2tseSwgZ2VuZXJhdG9yLCB0eXBlKSB7XG4gIHZhciBibG9ja05hbWUgPSAnZnVuY3Rpb25hbF9jb25kJztcbiAgaWYgKHR5cGUgIT09IEJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTk9ORSkge1xuICAgIGJsb2NrTmFtZSArPSAnXycgKyB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBibG9ja2x5LkJsb2Nrc1tibG9ja05hbWVdID0ge1xuICAgIGhlbHBVcmw6ICcnLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYWlyc18gPSBbXTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbCh0cnVlLCB7XG4gICAgICAgIGhlYWRlckhlaWdodDogMzBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZml4ZWRTaXplOiB7IGhlaWdodDogMzUgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5zZXRIU1YuYXBwbHkodGhpcywgQmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1t0eXBlXSk7XG5cbiAgICAgIHZhciBwbHVzRmllbGQgPSBuZXcgQmxvY2tseS5GaWVsZEljb24oJysnKTtcbiAgICAgIEJsb2NrbHkuYmluZEV2ZW50XyhwbHVzRmllbGQuZ2V0Um9vdEVsZW1lbnQoKSwgJ21vdXNlZG93bicsXG4gICAgICAgIHRoaXMsIHRoaXMuYWRkQ29uZGl0aW9uYWxSb3cpO1xuXG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGRMYWJlbCgnY29uZCcsIG9wdGlvbnMpKVxuICAgICAgICAuc2V0QWxpZ24oQmxvY2tseS5BTElHTl9DRU5UUkUpO1xuXG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoJ0VMU0UnKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IEJsb2NrbHkuRmllbGRMYWJlbCgnZWxzZScsIG9wdGlvbnMpKTtcbiAgICAgIHZhciBkZWZhdWx0SW5wdXQgPSB0aGlzLmFwcGVuZEZ1bmN0aW9uYWxJbnB1dCgnREVGQVVMVCcpXG4gICAgICAgIC5zZXRJbmxpbmUodHJ1ZSk7XG4gICAgICBkZWZhdWx0SW5wdXQuc2V0SFNWLmFwcGx5KGRlZmF1bHRJbnB1dCwgQmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1t0eXBlXSk7XG5cbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgnUExVUycpXG4gICAgICAgIC5hcHBlbmRUaXRsZShwbHVzRmllbGQpXG4gICAgICAgIC5zZXRJbmxpbmUodHJ1ZSk7XG5cbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25hbE91dHB1dCh0cnVlLCB0eXBlID09PSBCbG9ja2x5LkJsb2NrVmFsdWVUeXBlLk5PTkUgP1xuICAgICAgICB1bmRlZmluZWQgOiB0eXBlKTtcblxuICAgICAgdGhpcy5hZGRDb25kaXRpb25hbFJvdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW5vdGhlciBjb25kaXRpb24vdmFsdWUgcGFpciB0byB0aGUgZW5kLlxuICAgICAqL1xuICAgIGFkZENvbmRpdGlvbmFsUm93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZCBpcyBlaXRoZXIgdGhlIGxhc3QgdmFsdWUgcGx1cyAxLCBvciBpZiB3ZSBoYXZlIG5vIHZhbHVlcyB5ZXQgMFxuICAgICAgLy8gd2UgY2FuJ3QganVzdCBoYXZlIHBhaXJzXy5sZW5ndGgsIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGdhcHNcbiAgICAgIHZhciBpZCA9IHRoaXMucGFpcnNfLmxlbmd0aCA+IDAgPyBfKHRoaXMucGFpcnNfKS5sYXN0KCkgKiAxICsgMSA6IDA7XG4gICAgICB0aGlzLnBhaXJzXy5wdXNoKGlkKTtcblxuICAgICAgdmFyIGNvbmQgPSB0aGlzLmFwcGVuZEZ1bmN0aW9uYWxJbnB1dCgnQ09ORCcgKyBpZCk7XG4gICAgICBjb25kLnNldEhTVi5hcHBseShjb25kLCBibG9ja2x5LkZ1bmN0aW9uYWxUeXBlQ29sb3JzW2Jsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuQk9PTEVBTl0pO1xuICAgICAgY29uZC5zZXRDaGVjayhibG9ja2x5LkJsb2NrVmFsdWVUeXBlLkJPT0xFQU4pO1xuICAgICAgdGhpcy5tb3ZlSW5wdXRCZWZvcmUoJ0NPTkQnICsgaWQsICdFTFNFJyk7XG5cbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuYXBwZW5kRnVuY3Rpb25hbElucHV0KCdWQUxVRScgKyBpZClcbiAgICAgICAgLnNldElubGluZSh0cnVlKTtcbiAgICAgIGlucHV0LnNldEhTVi5hcHBseShpbnB1dCwgQmxvY2tseS5GdW5jdGlvbmFsVHlwZUNvbG9yc1t0eXBlXSk7XG4gICAgICB0aGlzLm1vdmVJbnB1dEJlZm9yZSgnVkFMVUUnICsgaWQsICdFTFNFJyk7XG5cbiAgICAgIHZhciBtaW51c0lucHV0ID0gdGhpcy5hcHBlbmREdW1teUlucHV0KCdNSU5VUycgKyBpZClcbiAgICAgICAgLnNldElubGluZSh0cnVlKTtcblxuICAgICAgaWYgKHRoaXMucGFpcnNfLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIG1pbnVzRmllbGQgPSBuZXcgQmxvY2tseS5GaWVsZEljb24oJy0nKTtcbiAgICAgICAgQmxvY2tseS5iaW5kRXZlbnRfKG1pbnVzRmllbGQuZ2V0Um9vdEVsZW1lbnQoKSwgJ21vdXNlZG93bicsXG4gICAgICAgICAgdGhpcywgXy5iaW5kKHRoaXMucmVtb3ZlQ29uZGl0aW9uYWxSb3csIHRoaXMsIGlkKSk7XG4gICAgICAgIG1pbnVzSW5wdXQuYXBwZW5kVGl0bGUobWludXNGaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW92ZUlucHV0QmVmb3JlKCdNSU5VUycgKyBpZCwgJ0VMU0UnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBjb25kaXRpb24vdmFsdWUgcGFpciB3aXRoIHRoZSBnaXZlbiBpZC4gTm8tb3AgaWYgbm8gcm93IHdpdGhcbiAgICAgKiB0aGF0IGlkLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbmRpdGlvbmFsUm93OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMucGFpcnNfLmluZGV4T2YoaWQpO1xuICAgICAgaWYgKCFfKHRoaXMucGFpcnNfKS5jb250YWlucyhpZCkgfHwgdGhpcy5wYWlyc18ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFpcnNfLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIHZhciBjb25kID0gdGhpcy5nZXRJbnB1dCgnQ09ORCcgKyBpZCk7XG4gICAgICB2YXIgY2hpbGQgPSBjb25kLmNvbm5lY3Rpb24udGFyZ2V0QmxvY2soKTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUlucHV0KCdDT05EJyArIGlkKTtcblxuICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0SW5wdXQoJ1ZBTFVFJyArIGlkKTtcbiAgICAgIGNoaWxkID0gdmFsLmNvbm5lY3Rpb24udGFyZ2V0QmxvY2soKTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUlucHV0KCdWQUxVRScgKyBpZCk7XG5cbiAgICAgIHRoaXMucmVtb3ZlSW5wdXQoJ01JTlVTJyArIGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHBhaXJzIHNvIHRoYXQgd2UgY2FuIGRlc2VyaWFsaXplIHdpdGggdGhlIHNhbWUgaWRzXG4gICAgICovXG4gICAgbXV0YXRpb25Ub0RvbTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYWlyc18ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbXV0YXRpb24nKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BhaXJzJywgdGhpcy5wYWlyc18uam9pbignLCcpKTtcbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGFuZCBjYXVzZSBvdXIgYmxvY2sgdG8gaGF2ZSBzYW1lIGlkc1xuICAgICAqL1xuICAgIGRvbVRvTXV0YXRpb246IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBwYWlycyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYWlycycpO1xuICAgICAgaWYgKCFwYWlycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhaXJzID0gcGFpcnMuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGl0ZW0sIDEwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPdXIgcGFpcnMsIHdoaWNoIGFyZSB1c2VkIHRvIG5hbWUgcm93cywgYXJlIG5vdCBuZWNlc3NhcmlseSBjb250aWd1b3VzLlxuICAgICAgLy8gV2UgZW5zdXJlIHRoYXQgd2UgZW5kIHVwIHdpdGggdGhlIHNhbWUgc2V0IG9mIHBhaXJzIGJ5IGFkZGluZyBsb3RzXG4gICAgICAvLyBvZiByb3dzLCBhbmQgdGhlbiBkZWxldGluZyB0aGUgdW5uZWVkZWQgb25lcyAoc2ltdWxhdGluZyB3aGF0IGhhcHBlbmVkXG4gICAgICAvLyB0byBvcmlnaW5hbGx5IGNyZWF0ZSB0aGlzIGJsb2NrKVxuICAgICAgdmFyIGxhc3RSb3cgPSBfKHBhaXJzKS5sYXN0KCk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGxhc3RSb3c7IGkrKykge1xuICAgICAgICB0aGlzLmFkZENvbmRpdGlvbmFsUm93KCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXN0Um93OyBpKyspIHtcbiAgICAgICAgaWYgKCFfKHBhaXJzKS5jb250YWlucyhpKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ29uZGl0aW9uYWxSb3coaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIC8vIGdlbmVyYXRlcyBjb2RlIGxpa2U6XG4gICAqIGZ1bmN0aW9uKCkge1xuICAgKiAgIGlmIChjb25kMSkgeyByZXR1cm4gdmFsdWUxOyB9XG4gICAqICAgZWxzZSBpZiAoY29uZDIpIHtyZXR1cm4gdmFsdWUyOyB9XG4gICAqICAgLi4uXG4gICAqICAgZWxzZSB7IHJldHVybiBkZWZhdWx0OyB9XG4gICAqIH0oKVxuICAgKi9cbiAgZ2VuZXJhdG9yW2Jsb2NrTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29uZCwgdmFsdWUsIGRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgY29kZSA9ICcoZnVuY3Rpb24gKCkge1xcbiAgJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFpcnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgY29kZSArPSAnZWxzZSAnO1xuICAgICAgfVxuICAgICAgdmFyIGlkID0gdGhpcy5wYWlyc19baV07XG4gICAgICBjb25kID0gQmxvY2tseS5KYXZhU2NyaXB0LnN0YXRlbWVudFRvQ29kZSh0aGlzLCAnQ09ORCcgKyBpZCwgZmFsc2UpIHx8XG4gICAgICAgICAgZmFsc2U7XG4gICAgICB2YWx1ZSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ1ZBTFVFJyArIGlkLCBmYWxzZSkgfHxcbiAgICAgICAgICAnJztcbiAgICAgIGNvZGUgKz0gJ2lmICgnICsgY29uZCArICcpIHsgcmV0dXJuICcgKyB2YWx1ZSArICc7IH1cXG4gICc7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSA9IEJsb2NrbHkuSmF2YVNjcmlwdC5zdGF0ZW1lbnRUb0NvZGUodGhpcywgJ0RFRkFVTFQnLCBmYWxzZSkgfHxcbiAgICAgICAgJyc7XG4gICAgY29kZSArPSAnZWxzZSB7IHJldHVybiAnICsgZGVmYXVsdFZhbHVlICsgJzsgfVxcbic7XG4gICAgY29kZSArPSAnfSkoKSc7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm90ZWN0ZWRTdGF0ZWZ1bERpdiA9IHJlcXVpcmUoJy4vUHJvdGVjdGVkU3RhdGVmdWxEaXYuanN4Jyk7XG52YXIgU3R1ZGlvQXBwV3JhcHBlciA9IHJlcXVpcmUoJy4vU3R1ZGlvQXBwV3JhcHBlci5qc3gnKTtcblxuLyoqXG4gKiBUb3AtbGV2ZWwgUmVhY3Qgd3JhcHBlciBmb3Igb3VyIHN0YW5kYXJkIGJsb2NrbHkgYXBwcy5cbiAqL1xudmFyIEFwcFZpZXcgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIGFzc2V0VXJsOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGlzRW1iZWRWaWV3OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIGlzU2hhcmVWaWV3OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIHJlbmRlckNvZGVXb3Jrc3BhY2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgcmVuZGVyVmlzdWFsaXphdGlvbkNvbHVtbjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbk1vdW50OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByb3BzLm9uTW91bnQoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFN0dWRpb0FwcFdyYXBwZXJcbiAgICAgICAgICBhc3NldFVybD17dGhpcy5wcm9wcy5hc3NldFVybH1cbiAgICAgICAgICBpc0VtYmVkVmlldz17dGhpcy5wcm9wcy5pc0VtYmVkVmlld31cbiAgICAgICAgICBpc1NoYXJlVmlldz17dGhpcy5wcm9wcy5pc1NoYXJlVmlld30+XG4gICAgICAgIDxQcm90ZWN0ZWRTdGF0ZWZ1bERpdlxuICAgICAgICAgICAgaWQ9XCJ2aXN1YWxpemF0aW9uQ29sdW1uXCJcbiAgICAgICAgICAgIHJlbmRlckNvbnRlbnRzPXt0aGlzLnByb3BzLnJlbmRlclZpc3VhbGl6YXRpb25Db2x1bW59IC8+XG4gICAgICAgIDxQcm90ZWN0ZWRTdGF0ZWZ1bERpdiBpZD1cInZpc3VhbGl6YXRpb25SZXNpemVCYXJcIiBjbGFzc05hbWU9XCJmYSBmYS1lbGxpcHNpcy12XCIgLz5cbiAgICAgICAgPFByb3RlY3RlZFN0YXRlZnVsRGl2XG4gICAgICAgICAgICBpZD1cImNvZGVXb3Jrc3BhY2VcIlxuICAgICAgICAgICAgcmVuZGVyQ29udGVudHM9e3RoaXMucHJvcHMucmVuZGVyQ29kZVdvcmtzcGFjZX0gLz5cbiAgICAgIDwvU3R1ZGlvQXBwV3JhcHBlcj5cbiAgICApO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQXBwVmlldztcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbnZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTtcbnZhciBoaWRlUnVuQnV0dG9uID0gbG9jYWxzLmhpZGVSdW5CdXR0b24gfHwgZmFsc2U7XG47IGJ1Zi5wdXNoKCdcXG5cXG4nKTs2OyB2YXIgZ2FtZUJ1dHRvbnMgPSBmdW5jdGlvbigpIHs7IGJ1Zi5wdXNoKCc8ZGl2IGlkPVwiZ2FtZUJ1dHRvbnNcIj5cXG4gIDxidXR0b24gaWQ9XCJydW5CdXR0b25cIiBjbGFzcz1cImxhdW5jaCBibG9ja2x5TGF1bmNoICcsIGVzY2FwZSgoNywgIGhpZGVSdW5CdXR0b24gPyAnaW52aXNpYmxlJyA6ICcnKSksICdcIj5cXG4gICAgPGRpdj4nLCBlc2NhcGUoKDgsICBtc2cucnVuUHJvZ3JhbSgpICkpLCAnPC9kaXY+XFxuICAgIDxpbWcgc3JjPVwiJywgZXNjYXBlKCg5LCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwicnVuMjZcIi8+XFxuICA8L2J1dHRvbj5cXG4gIDxidXR0b24gaWQ9XCJyZXNldEJ1dHRvblwiIGNsYXNzPVwibGF1bmNoIGJsb2NrbHlMYXVuY2hcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj5cXG4gICAgPGRpdj4nLCBlc2NhcGUoKDEyLCAgbXNnLnJlc2V0UHJvZ3JhbSgpICkpLCAnPC9kaXY+XFxuICAgIDxpbWcgc3JjPVwiJywgZXNjYXBlKCgxMywgIGFzc2V0VXJsKCdtZWRpYS8xeDEuZ2lmJykgKSksICdcIiBjbGFzcz1cInJlc2V0MjZcIi8+XFxuICA8L2J1dHRvbj5cXG4gICcpOzE1OyBpZiAoZGF0YS5jb250cm9scykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgJywgKDE2LCAgZGF0YS5jb250cm9scyApLCAnXFxuICAnKTsxNzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICcpOzE4OyBpZiAoIWRhdGEucGluV29ya3NwYWNlVG9Cb3R0b20gJiYgZGF0YS5leHRyYUNvbnRyb2xSb3dzKSB7IDsgYnVmLnB1c2goJ1xcbiAgICAnLCAoMTksICBkYXRhLmV4dHJhQ29udHJvbFJvd3MgKSwgJ1xcbiAgJyk7MjA7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7MjI7IH07OyBidWYucHVzaCgnXFxuPGRpdiBpZD1cInZpc3VhbGl6YXRpb25cIj5cXG4gICcsICgyNCwgIGRhdGEudmlzdWFsaXphdGlvbiApLCAnXFxuPC9kaXY+XFxuXFxuJyk7Mjc7IGdhbWVCdXR0b25zKCkgOyBidWYucHVzaCgnXFxuXFxuPGRpdiBpZD1cImJlbG93VmlzdWFsaXphdGlvblwiPlxcblxcbiAgPGRpdiBpZD1cImJ1YmJsZVwiIGNsYXNzPVwiY2xlYXJmaXhcIj5cXG4gICAgPHRhYmxlIGlkPVwicHJvbXB0LXRhYmxlXCI+XFxuICAgICAgPHRyPlxcbiAgICAgICAgPHRkIGlkPVwicHJvbXB0LWljb24tY2VsbFwiIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiPlxcbiAgICAgICAgICA8aW1nIGlkPVwicHJvbXB0LWljb25cIi8+XFxuICAgICAgICA8L3RkPlxcbiAgICAgICAgPHRkIGlkPVwicHJvbXB0LWNlbGxcIj5cXG4gICAgICAgICAgPHAgaWQ9XCJwcm9tcHRcIj5cXG4gICAgICAgICAgPHAgaWQ9XCJwcm9tcHQyXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj5cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgPC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICA8L3RhYmxlPlxcbiAgICAnKTs0NDsgaWYgKGRhdGEuaW5wdXRPdXRwdXRUYWJsZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8ZGl2IGlkPVwiaW5wdXQtdGFibGVcIj5cXG4gICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aD5JbnB1dDwvdGg+XFxuICAgICAgICAgICAgPHRoPk91dHB1dDwvdGg+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICcpOzUxOyBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuaW5wdXRPdXRwdXRUYWJsZS5sZW5ndGg7IGkrKykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0ZD4nLCAoNTMsICBkYXRhLmlucHV0T3V0cHV0VGFibGVbaV1bMF0gKSwgJzwvdGQ+XFxuICAgICAgICAgICAgPHRkPicsICg1NCwgIGRhdGEuaW5wdXRPdXRwdXRUYWJsZVtpXVsxXSApLCAnPC90ZD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgICAgJyk7NTY7IH0gOyBidWYucHVzaCgnXFxuICAgICAgICA8L3RhYmxlPlxcbiAgICAgIDwvZGl2PlxcbiAgICAnKTs1OTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBpZD1cImFuaS1naWYtcHJldmlldy13cmFwcGVyXCI+XFxuICAgICAgPGRpdiBpZD1cImFuaS1naWYtcHJldmlld1wiPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnJyk7MTtcbnZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTtcbjsgYnVmLnB1c2goJ1xcblxcbjxkaXYgaWQ9XCJjb2RlV29ya3NwYWNlV3JhcHBlclwiPlxcbiAgPGRpdiBpZD1cImhlYWRlcnNcIiBkaXI9XCInLCBlc2NhcGUoKDYsICBkYXRhLmxvY2FsZURpcmVjdGlvbiApKSwgJ1wiPlxcbiAgICA8ZGl2IGlkPVwiY29kZU1vZGVIZWFkZXJzXCI+XFxuICAgICAgPGRpdiBpZD1cInRvb2xib3gtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyXCI+XFxuICAgICAgICA8aSBpZD1cImhpZGUtdG9vbGJveC1pY29uXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCIgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1yaWdodFwiPjwvaT5cXG4gICAgICAgIDxzcGFuPicsIGVzY2FwZSgoMTAsICBkYXRhLmVkaXRDb2RlID8gbXNnLnRvb2xib3hIZWFkZXJEcm9wbGV0KCkgOiBtc2cudG9vbGJveEhlYWRlcigpICkpLCAnPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgaWQ9XCJzaG93LXRvb2xib3gtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+XFxuICAgICAgICA8aSBpZD1cInNob3ctdG9vbGJveC1pY29uXCIgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1yaWdodFwiPjwvaT5cXG4gICAgICAgIDxzcGFuPicsIGVzY2FwZSgoMTQsICBtc2cuc2hvd1Rvb2xib3goKSApKSwgJzwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVwic2hvdy1jb2RlLWhlYWRlclwiIGNsYXNzPVwid29ya3NwYWNlLWhlYWRlciB3b3Jrc3BhY2UtaGVhZGVyLWJ1dHRvblwiPjxzcGFuPjxpbWcgc3JjPVwiJywgZXNjYXBlKCgxNiwgIGFzc2V0VXJsKCdtZWRpYS9hcHBsYWIvYmxvY2tzX2dseXBoLmdpZicpICkpLCAnXCIgY2xhc3M9XCJibG9ja3MtZ2x5cGhcIiAvPjxpIGNsYXNzPVwiZmEgZmEtY29kZVwiPjwvaT4nLCBlc2NhcGUoKDE2LCAgbXNnLnNob3dDb2RlSGVhZGVyKCkgKSksICc8L3NwYW4+PC9kaXY+XFxuICAgICAgJyk7MTc7IGlmICghZGF0YS5yZWFkb25seVdvcmtzcGFjZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICAgIDxkaXYgaWQ9XCJjbGVhci1wdXp6bGUtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyIHdvcmtzcGFjZS1oZWFkZXItYnV0dG9uXCI+PHNwYW4+PGkgY2xhc3M9XCJmYSBmYS11bmRvXCI+PC9pPicsIGVzY2FwZSgoMTgsICBtc2cuY2xlYXJQdXp6bGUoKSApKSwgJzwvc3Bhbj48L2Rpdj5cXG4gICAgICAnKTsxOTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8ZGl2IGlkPVwidmVyc2lvbnMtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyIHdvcmtzcGFjZS1oZWFkZXItYnV0dG9uXCI+PHNwYW4+PGkgY2xhc3M9XCJmYSBmYS1jbG9jay1vXCI+PC9pPicsIGVzY2FwZSgoMjAsICBtc2cuc2hvd1ZlcnNpb25zSGVhZGVyKCkgKSksICc8L3NwYW4+PC9kaXY+XFxuICAgICAgPGRpdiBpZD1cIndvcmtzcGFjZS1oZWFkZXJcIiBjbGFzcz1cIndvcmtzcGFjZS1oZWFkZXJcIj5cXG4gICAgICAgIDxzcGFuIGlkPVwid29ya3NwYWNlLWhlYWRlci1zcGFuXCI+XFxuICAgICAgICAgICcsIGVzY2FwZSgoMjMsICBkYXRhLnJlYWRvbmx5V29ya3NwYWNlID8gbXNnLnJlYWRvbmx5V29ya3NwYWNlSGVhZGVyKCkgOiBtc2cud29ya3NwYWNlSGVhZGVyU2hvcnQoKSApKSwgJ1xcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPGRpdiBpZD1cImJsb2NrQ291bnRlclwiPlxcbiAgICAgICAgICA8ZGl2IGlkPVwiYmxvY2tVc2VkXCIgY2xhc3M9JywgZXNjYXBlKCgyNiwgIGRhdGEuYmxvY2tDb3VudGVyQ2xhc3MgKSksICc+XFxuICAgICAgICAgICAgJywgZXNjYXBlKCgyNywgIGRhdGEuYmxvY2tVc2VkICkpLCAnXFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8c3Bhbj4vPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBpZD1cImlkZWFsQmxvY2tOdW1iZXJcIj4nLCBlc2NhcGUoKDMwLCAgZGF0YS5pZGVhbEJsb2NrTnVtYmVyICkpLCAnPC9zcGFuPlxcbiAgICAgICAgICA8c3Bhbj4gJywgZXNjYXBlKCgzMSwgIG1zZy5ibG9ja3MoKSApKSwgJzwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgJyk7MzY7IGlmIChkYXRhLmVkaXRDb2RlKSB7IDsgYnVmLnB1c2goJ1xcbiAgICA8ZGl2IGlkPVwiY29kZVRleHRib3hcIj48L2Rpdj5cXG4gICcpOzM4OyB9IDsgYnVmLnB1c2goJ1xcbiAgJyk7Mzk7IGlmIChkYXRhLnBpbldvcmtzcGFjZVRvQm90dG9tICYmIGRhdGEuZXh0cmFDb250cm9sUm93cykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgJywgKDQwLCAgZGF0YS5leHRyYUNvbnRyb2xSb3dzICksICdcXG4gICcpOzQxOyB9IDsgYnVmLnB1c2goJ1xcbjwvZGl2PlxcbicpOzQzOyBpZiAoZGF0YS5oYXNEZXNpZ25Nb2RlKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBpZD1cImRlc2lnbldvcmtzcGFjZVwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPlxcbjwvZGl2PlxcbicpOzQ2OyB9IDsgYnVmLnB1c2goJ1xcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8vIGF2YXRhcjogQSAxMDI5eDUxIHNldCBvZiAyMSBhdmF0YXIgaW1hZ2VzLlxuXG5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbihhc3NldFVybCwgaWQpIHtcbiAgdmFyIHNraW5VcmwgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFzc2V0VXJsKCdtZWRpYS9za2lucy8nICsgaWQgKyAnLycgKyBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBza2luID0ge1xuICAgIGlkOiBpZCxcbiAgICBhc3NldFVybDogc2tpblVybCxcbiAgICAvLyBJbWFnZXNcbiAgICBhdmF0YXI6IHNraW5VcmwoJ2F2YXRhci5wbmcnKSxcbiAgICBhdmF0YXJfMng6IHNraW5VcmwoJ2F2YXRhcl8yeC5wbmcnKSxcbiAgICBnb2FsOiBza2luVXJsKCdnb2FsLnBuZycpLFxuICAgIG9ic3RhY2xlOiBza2luVXJsKCdvYnN0YWNsZS5wbmcnKSxcbiAgICBzbWFsbFN0YXRpY0F2YXRhcjogc2tpblVybCgnc21hbGxfc3RhdGljX2F2YXRhci5wbmcnKSxcbiAgICBzdGF0aWNBdmF0YXI6IHNraW5VcmwoJ3N0YXRpY19hdmF0YXIucG5nJyksXG4gICAgd2luQXZhdGFyOiBza2luVXJsKCd3aW5fYXZhdGFyLnBuZycpLFxuICAgIGZhaWx1cmVBdmF0YXI6IHNraW5VcmwoJ2ZhaWx1cmVfYXZhdGFyLnBuZycpLFxuICAgIGRlY29yYXRpb25BbmltYXRpb246IHNraW5VcmwoJ2RlY29yYXRpb25fYW5pbWF0aW9uLnBuZycpLFxuICAgIGRlY29yYXRpb25BbmltYXRpb25fMng6IHNraW5VcmwoJ2RlY29yYXRpb25fYW5pbWF0aW9uXzJ4LnBuZycpLFxuICAgIHJlcGVhdEltYWdlOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9yZXBlYXQtYXJyb3dzLnBuZycpLFxuICAgIGxlZnRBcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvbW92ZWxlZnQucG5nJyksXG4gICAgZG93bkFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZlZG93bi5wbmcnKSxcbiAgICB1cEFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9tb3ZldXAucG5nJyksXG4gICAgcmlnaHRBcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvbW92ZXJpZ2h0LnBuZycpLFxuICAgIGxlZnRKdW1wQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2p1bXBsZWZ0LnBuZycpLFxuICAgIGRvd25KdW1wQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2p1bXBkb3duLnBuZycpLFxuICAgIHVwSnVtcEFycm93OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9qdW1wdXAucG5nJyksXG4gICAgcmlnaHRKdW1wQXJyb3c6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2p1bXByaWdodC5wbmcnKSxcbiAgICBub3J0aExpbmVEcmF3OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9kcmF3LW5vcnRoLnBuZycpLFxuICAgIHNvdXRoTGluZURyYXc6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctc291dGgucG5nJyksXG4gICAgZWFzdExpbmVEcmF3OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9kcmF3LWVhc3QucG5nJyksXG4gICAgd2VzdExpbmVEcmF3OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9kcmF3LXdlc3QucG5nJyksXG4gICAgc2hvcnRMaW5lRHJhdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvZHJhdy1zaG9ydC5wbmcnKSxcbiAgICBsb25nTGluZURyYXc6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctbG9uZy5wbmcnKSxcbiAgICBzaG9ydExpbmVEcmF3UmlnaHQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctc2hvcnQtcmlnaHQucG5nJyksXG4gICAgbG9uZ0xpbmVEcmF3UmlnaHQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2RyYXctbG9uZy1yaWdodC5wbmcnKSxcbiAgICBsb25nTGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvbW92ZS1sb25nLnBuZycpLFxuICAgIHNob3J0TGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvbW92ZS1zaG9ydC5wbmcnKSxcbiAgICBzb3VuZEljb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3BsYXktc291bmQucG5nJyksXG4gICAgY2xpY2tJY29uOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy93aGVuLWNsaWNrLWhhbmQucG5nJyksXG4gICAgc3RhcnRJY29uOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy93aGVuLXJ1bi5wbmcnKSxcbiAgICBydW5BcnJvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcnVuLWFycm93LnBuZycpLFxuICAgIGVuZEljb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2VuZC1pY29uLnBuZycpLFxuICAgIHNwZWVkRmFzdDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3BlZWQtZmFzdC5wbmcnKSxcbiAgICBzcGVlZE1lZGl1bTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3BlZWQtbWVkaXVtLnBuZycpLFxuICAgIHNwZWVkU2xvdzogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3BlZWQtc2xvdy5wbmcnKSxcbiAgICBzY29yZUNhcmQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL2luY3JlbWVudC1zY29yZS03NXBlcmNlbnQucG5nJyksXG4gICAgcmFpbmJvd01lbnU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3JhaW5ib3ctbWVudWljb24ucG5nJyksXG4gICAgcm9wZU1lbnU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3JvcGUtbWVudWljb24ucG5nJyksXG4gICAgc3F1aWdnbHlNZW51OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zcXVpZ2dseS1tZW51aWNvbi5wbmcnKSxcbiAgICBzd2lybHlNZW51OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zd2lybHlsaW5lLW1lbnVpY29uLnBuZycpLFxuICAgIHBhdHRlcm5EZWZhdWx0OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9kZWZhdWx0bGluZS1tZW51aWNvbi5wbmcnKSxcbiAgICByYWluYm93TGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcmFpbmJvdy5wbmcnKSxcbiAgICByb3BlTGluZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcm9wZS5wbmcnKSxcbiAgICBzcXVpZ2dseUxpbmU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3NxdWlnZ2x5LnBuZycpLFxuICAgIHN3aXJseUxpbmU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N3aXJseWxpbmUucG5nJyksXG4gICAgcmFuZG9tUHVycGxlSWNvbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvcmFuZG9tLXB1cnBsZS5wbmcnKSxcblxuICAgIC8vIFNvdW5kc1xuICAgIHN0YXJ0U291bmQ6IFtza2luVXJsKCdzdGFydC5tcDMnKSwgc2tpblVybCgnc3RhcnQub2dnJyldLFxuICAgIHdpblNvdW5kOiBbc2tpblVybCgnd2luLm1wMycpLCBza2luVXJsKCd3aW4ub2dnJyldLFxuICAgIGZhaWx1cmVTb3VuZDogW3NraW5VcmwoJ2ZhaWx1cmUubXAzJyksIHNraW5VcmwoJ2ZhaWx1cmUub2dnJyldLFxuXG4gICAgLy8gU3RpY2tlcnNcbiAgICBzdGlja2Vyczoge1xuICAgICAgZWxlcGhhbnQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2VsZXBoYW50LnBuZycpLFxuICAgICAgZHJhZ29uOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9kcmFnb24ucG5nJyksXG4gICAgICB0cmljZXJhdG9wczogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvdHJpY2VyYXRvcHMucG5nJyksXG4gICAgICBtb25rZXk6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL21vbmtleS5wbmcnKSxcbiAgICAgIGNhdDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvY2F0LnBuZycpLFxuICAgICAgdHVydGxlOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy90dXJ0bGUucG5nJyksXG4gICAgICBnb2F0OiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9nb2F0LnBuZycpLFxuICAgICAgemVicmE6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL3plYnJhLnBuZycpLFxuICAgICAgaGlwcG86IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2hpcHBvLnBuZycpLFxuICAgICAgYnVubnk6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2J1bm55LnBuZycpLFxuICAgICAgcGVhY29jazogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvcGVhY29jay5wbmcnKSxcbiAgICAgIGxsYW1hOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9sbGFtYS5wbmcnKSxcbiAgICAgIGdpcmFmZmU6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2dpcmFmZmUucG5nJyksXG4gICAgICBtb3VzZTogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvbW91c2UucG5nJyksXG4gICAgICBiZWF2ZXI6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2JlYXZlci5wbmcnKSxcbiAgICAgIGJhdDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvYmF0LnBuZycpLFxuICAgICAgZ3Jhc3Nob3BwZXI6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2dyYXNzaG9wcGVyLnBuZycpLFxuICAgICAgY2hpY2tlbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvY2hpY2tlbi5wbmcnKSxcbiAgICAgIG1vb3NlOiBhc3NldFVybCgnbWVkaWEvY29tbW9uX2ltYWdlcy9zdGlja2Vycy9tb29zZS5wbmcnKSxcbiAgICAgIG93bDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvb3dsLnBuZycpLFxuICAgICAgcGVuZ3VpbjogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvcGVuZ3Vpbi5wbmcnKSxcbiAgICAgIGxpb246IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL2xpb24ucG5nJyksXG4gICAgICByb2JvdDogYXNzZXRVcmwoJ21lZGlhL2NvbW1vbl9pbWFnZXMvc3RpY2tlcnMvcm9ib3QucG5nJyksXG4gICAgICByb2NrZXQ6IGFzc2V0VXJsKCdtZWRpYS9jb21tb25faW1hZ2VzL3N0aWNrZXJzL3JvY2tldC5wbmcnKSxcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNraW47XG59O1xuIiwiLyogZ2xvYmFsIERpYWxvZywgZGFzaGJvYXJkLCBBcHBsYWIgKi9cbi8vIFRPRE8gKGpvc2gpIC0gZG9uJ3QgcGFzcyBgRGlhbG9nYCBpbnRvIGBjcmVhdGVNb2RhbERpYWxvZ2AuXG5cbnZhciBhc3NldExpc3RTdG9yZSA9IHJlcXVpcmUoJy4vYXNzZXRMaXN0U3RvcmUnKTtcbnZhciBzaG93QXNzZXRNYW5hZ2VyID0gcmVxdWlyZSgnLi9zaG93Jyk7XG52YXIgY29tbW9uTXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG9wdGlvbnMgKG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgdHlwZSkgZm9yIGNvZGUtbW9kZVxuICogYXNzZXQgZHJvcGRvd25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0eXBlRmlsdGVyKSB7XG4gIHZhciBvcHRpb25zID0gYXNzZXRMaXN0U3RvcmUubGlzdCh0eXBlRmlsdGVyKS5tYXAoZnVuY3Rpb24gKGFzc2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHV0aWxzLnF1b3RlKGFzc2V0LmZpbGVuYW1lKSxcbiAgICAgIGRpc3BsYXk6IHV0aWxzLnF1b3RlKGFzc2V0LmZpbGVuYW1lKVxuICAgIH07XG4gIH0pO1xuICB2YXIgaGFuZGxlQ2hvb3NlQ2xpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBzaG93QXNzZXRNYW5hZ2VyKGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgY2FsbGJhY2sodXRpbHMucXVvdGUoZmlsZW5hbWUpKTtcbiAgICB9LCB0eXBlRmlsdGVyKTtcbiAgfTtcbiAgb3B0aW9ucy5wdXNoKHtcbiAgICB0ZXh0OiBjb21tb25Nc2cuY2hvb3NlUHJlZml4KCksXG4gICAgZGlzcGxheTogJzxzcGFuIGNsYXNzPVwiY2hvb3NlQXNzZXREcm9wZG93bk9wdGlvblwiPicgKyBjb21tb25Nc2cuY2hvb3NlUHJlZml4KCkgKyAnPC9hPicsXG4gICAgY2xpY2s6IGhhbmRsZUNob29zZUNsaWNrXG4gIH0pO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG4iLCJ2YXIgdGltZW91dExpc3QgPSBbXTtcblxuLyoqXG4gKiBjYWxsIHNldFRpbWVvdXQgYW5kIHRyYWNrIHRoZSByZXR1cm5lZCBpZFxuICovXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcbiAgdmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dC5hcHBseSh3aW5kb3csIGFyZ3VtZW50cyk7XG4gIHRpbWVvdXRMaXN0LnB1c2godGltZW91dCk7XG4gIHJldHVybiB0aW1lb3V0O1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIHRpbWVvdXRzIGluIG91ciB0aW1lb3V0TGlzdCBhbmQgcmVzZXRzIHRoZSB0aW1lb3V0TGlzdFxuICovXG5leHBvcnRzLmNsZWFyVGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRpbWVvdXRMaXN0LmZvckVhY2god2luZG93LmNsZWFyVGltZW91dCwgd2luZG93KTtcbiAgdGltZW91dExpc3QgPSBbXTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGEgdGltZW91dCBhbmQgcmVtb3ZlcyB0aGUgaXRlbSBmcm9tIHRoZSB0aW1lb3V0TGlzdFxuICovXG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChpZCkge1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgLy8gTGlzdCByZW1vdmFsIHJlcXVpcmVzIElFOStcbiAgdmFyIGluZGV4ID0gdGltZW91dExpc3QuaW5kZXhPZihpZCk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgdGltZW91dExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxudmFyIGludGVydmFsTGlzdCA9IFtdO1xuXG4vKipcbiAqIGNhbGwgc2V0SW50ZXJ2YWwgYW5kIHRyYWNrIHRoZSByZXR1cm5lZCBpZFxuICovXG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24gKGZuLCB0aW1lKSB7XG4gIHZhciBpbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbC5hcHBseSh3aW5kb3csIGFyZ3VtZW50cyk7XG4gIGludGVydmFsTGlzdC5wdXNoKGludGVydmFsKTtcbiAgcmV0dXJuIGludGVydmFsO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGludGVydmFsIHRpbWVvdXRzIGluIG91ciBpbnRlcnZhbExpc3QgYW5kIHJlc2V0cyB0aGUgaW50ZXJ2YWxMaXN0XG4gKi9cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbHMgPSBmdW5jdGlvbiAoKSB7XG4gIGludGVydmFsTGlzdC5mb3JFYWNoKHdpbmRvdy5jbGVhckludGVydmFsLCB3aW5kb3cpO1xuICBpbnRlcnZhbExpc3QgPSBbXTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGEgdGltZW91dCBhbmQgcmVtb3ZlcyB0aGUgaXRlbSBmcm9tIHRoZSBpbnRlcnZhbExpc3RcbiAqL1xuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGlkKSB7XG4gIHdpbmRvdy5jbGVhckludGVydmFsKGlkKTtcbiAgLy8gTGlzdCByZW1vdmFsIHJlcXVpcmVzIElFOStcbiAgdmFyIGluZGV4ID0gaW50ZXJ2YWxMaXN0LmluZGV4T2YoaWQpO1xuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIGludGVydmFsTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtbyAuL2Rpc3QvbG9kYXNoLmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYGlzUGxhaW5PYmplY3RgIHdoaWNoIGNoZWNrcyBpZiBhIGdpdmVuIHZhbHVlXG4gICAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLCBhc3N1bWluZyBvYmplY3RzIGNyZWF0ZWRcbiAgICAgKiBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IgaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCB0aGF0XG4gICAgICogdGhlcmUgYXJlIG5vIGBPYmplY3QucHJvdG90eXBlYCBleHRlbnNpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIC8vIGF2b2lkIG5vbiBPYmplY3Qgb2JqZWN0cywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIERPTSBlbGVtZW50c1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8XG4gICAgICAgICAgKGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgaXNGdW5jdGlvbihjdG9yKSAmJiAhKGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBmb3JJbih2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgdW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcyB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2hpbUtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghKG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3RdKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzOlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBgPmAgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2UgYD5gIGFuZCBgL2BcbiAgICAgKiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nIHVubGVzcyB0aGV5J3JlIHBhcnRcbiAgICAgKiBvZiBhIHRhZyBvciBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMgKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpXG4gICAgICovXG4gICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmIzM5OydcbiAgICB9O1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgaHRtbFVuZXNjYXBlcyA9IGludmVydChodG1sRXNjYXBlcyk7XG5cbiAgICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IFJlZ0V4cCgnKCcgKyBrZXlzKGh0bWxVbmVzY2FwZXMpLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICAgICAgcmVVbmVzY2FwZWRIdG1sID0gUmVnRXhwKCdbJyArIGtleXMoaHRtbEVzY2FwZXMpLmpvaW4oJycpICsgJ10nLCAnZycpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgICAqIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZVxuICAgICAqIGFzc2lnbmVkIHZhbHVlcy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnbmFtZSc6ICdmcmVkJyB9LCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgaWYgKGFyZ3NMZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tYXJnc0xlbmd0aCAtIDFdLCBhcmdzW2FyZ3NMZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzTGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1hcmdzTGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2socmVzdWx0W2luZGV4XSwgaXRlcmFibGVbaW5kZXhdKSA6IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgd2lsbCBhbHNvXG4gICAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUoY2hhcmFjdGVycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUoY2hhcmFjdGVycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2xvbmUnOiBfLnBhcnRpYWxSaWdodChfLmNsb25lLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiAgIH0pXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lKGRvY3VtZW50LmJvZHkpO1xuICAgICAqIGNsb25lLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGBcbiAgICAgIC8vIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzIGZvciBgaXNEZWVwYCBhbmQgYGNhbGxiYWNrYFxuICAgICAgaWYgKHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzRGVlcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmVcbiAgICAgKiBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAgICogb2JqZWN0cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChjaGFyYWN0ZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdub2RlJzogZWxlbWVudFxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lRGVlcCh2aWV3LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZSh0cnVlKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNsb25lLm5vZGUgPT0gdmlldy5ub2RlO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCB3aXRob3V0IHVzaW5nIGl0c1xuICAgICAqICBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdiYXJuZXknIH07XG4gICAgICogXy5kZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaW5kZXhdID09ICd1bmRlZmluZWQnKSByZXN1bHRbaW5kZXhdID0gaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgLCBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zIGBiYXJuZXlgXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd25SaWdodChvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsXG4gICAgICogZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9ySW4gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbW92ZScsICd5JywgYW5kICd4JyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuXG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcGFpcnMucHVzaChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhwYWlyc1tsZW5ndGgtLV0sIHBhaXJzW2xlbmd0aF0sIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCwgZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodCh7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdsZW5ndGgnLCAnMScsIGFuZCAnMCcgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF07XG4gICAgICAgIGlmIChjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzb3J0ZWQgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyxcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAgICogLy8gPT4gWydhbGwnLCAnYW55JywgJ2JpbmQnLCAnYmluZEFsbCcsICdjbG9uZScsICdjb21wYWN0JywgJ2NvbXBvc2UnLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZSBleGlzdHMgYXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAsXG4gICAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBrZXkgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oYXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sICdiJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludmVydCh7ICdmaXJzdCc6ICdmcmVkJywgJ3NlY29uZCc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAnZmlyc3QnLCAnYmFybmV5JzogJ3NlY29uZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W29iamVjdFtrZXldXSA9IGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBkYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBkYXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEFycmF5cywgc3RyaW5ncywgb3IgYGFyZ3VtZW50c2Agb2JqZWN0cyB3aXRoIGFcbiAgICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgICAqIFwiZW1wdHlcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KCcnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAoKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzIHx8IGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gYXJnc0NsYXNzICkgfHxcbiAgICAgICAgICAoY2xhc3NOYW1lID09IG9iamVjdENsYXNzICYmIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvck93bih2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChhLCBiKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBjb3B5ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IGNvcHk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIGNvcHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB3b3JkcyA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlcldvcmRzID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwod29yZHMsIG90aGVyV29yZHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHZhciByZUdyZWV0ID0gL14oPzpoZWxsb3xoaSkkL2ksXG4gICAgICogICAgICAgYUdyZWV0ID0gXy5pc1N0cmluZyhhKSAmJiByZUdyZWV0LnRlc3QoYSksXG4gICAgICogICAgICAgYkdyZWV0ID0gXy5pc1N0cmluZyhiKSAmJiByZUdyZWV0LnRlc3QoYik7XG4gICAgICpcbiAgICAgKiAgIHJldHVybiAoYUdyZWV0IHx8IGJHcmVldCkgPyAoYUdyZWV0ID09IGJHcmVldCkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhLCBiLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcywgb3IgY2FuIGJlIGNvZXJjZWQgdG8sIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNGaW5pdGVgIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZmluaXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgTmFOYCBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3g4LjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU2hhcGUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZixcbiAgICAgICAgICBvYmpQcm90byA9IGlzTmF0aXZlKHZhbHVlT2YpICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2ZyZWQvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB2YWx1ZXMgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzfSAsIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyhjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBhbmQgc291cmNlIHByb3BlcnRpZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBuYW1lcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICduYW1lJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ2FnZSc6IDM2IH0sXG4gICAgICogICAgIHsgJ2FnZSc6IDQwIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShuYW1lcywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnY2hhcmFjdGVycyc6IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXJGb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShmb29kLCBvdGhlckZvb2QsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzQXJyYXkoYSkgPyBhLmNvbmNhdChiKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3RdIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShvYmplY3QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IDI7XG5cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdICE9ICdudW1iZXInKSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWxlbmd0aCAtIDFdLCBhcmdzW2xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbbGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZShhcmd1bWVudHMsIDEsIGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBzdGFja0EgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIHN0YWNrQiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZXNbaW5kZXhdLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgZXhjbHVkaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgcHJvcGVydGllcyB0byBvbWl0IG9yIHRoZVxuICAgICAqICBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRob3V0IHRoZSBvbWl0dGVkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcHJvcHMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMgPSBiYXNlRGlmZmVyZW5jZShwcm9wcywgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgYW4gb2JqZWN0J3Mga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFpcnMoeyAnYmFybmV5JzogMzYsICdmcmVkJzogNDAgfSk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGNvbXBvc2VkIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2hcbiAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBwaWNraW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sICduYW1lJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLnBpY2soeyAnbmFtZSc6ICdmcmVkJywgJ191c2VyaWQnOiAnZnJlZDEnIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkuY2hhckF0KDApICE9ICdfJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgICBsZW5ndGggPSBpc09iamVjdChvYmplY3QpID8gcHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYCB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyB0aHJvdWdoIGEgY2FsbGJhY2ssIHdpdGggZWFjaCBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNxdWFyZXMgPSBfLnRyYW5zZm9ybShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLCBmdW5jdGlvbihyZXN1bHQsIG51bSkge1xuICAgICAqICAgbnVtICo9IG51bTtcbiAgICAgKiAgIGlmIChudW0gJSAyKSB7XG4gICAgICogICAgIHJldHVybiByZXN1bHQucHVzaChudW0pIDwgMztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgOSwgMjVdXG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgIHByb3RvID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleGVzLCBvciBrZXlzLCBvZiB0aGVcbiAgICAgKiBgY29sbGVjdGlvbmAuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW2luZGV4XSBUaGUgaW5kZXhlcyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiAgIHRvIHJldHJpZXZlLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXQoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3MsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJnc1syXSAmJiBhcmdzWzJdW2FyZ3NbMV1dID09PSBjb2xsZWN0aW9uKSA/IDEgOiBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoKytpbmRleCA+PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IHZhbHVlID09PSB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJucyB0cnVleSB2YWx1ZSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSAhIWNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGV2ZW5zID0gXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXRcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0LCBmaW5kV2hlcmVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICAgKiBlbGVtZW50LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2goZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zICcxLDIsMydcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaFJpZ2h0KGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgJzMsMiwxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25bbGVuZ3RoXSwgbGVuZ3RoLCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGtleSA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogcmVzdWx0W2tleV0gPSBbXSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgZ2l2ZW4gY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleXMgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShjaGFyYWN0ZXJzLCBmdW5jdGlvbihrZXkpIHsgdGhpcy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYFxuICAgICAqIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXRcbiAgICAgKiB3aWxsIGJlIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gKGlzRnVuYyA/IG1ldGhvZE5hbWUgOiB2YWx1ZVttZXRob2ROYW1lXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGFsbCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIHZhciBwbHVjayA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYSBjb2xsZWN0aW9uIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBjYWxsYmFjayBleGVjdXRpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZXhlY3V0aW9uLiBJZlxuICAgICAqIGBhY2N1bXVsYXRvcmAgaXMgbm90IHByb3ZpZGVkIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBpbml0aWFsIGBhY2N1bXVsYXRvcmAgdmFsdWUuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobm9hY2N1bSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY29sbGVjdGlvblsrK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbGlzdCA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKiB2YXIgZmxhdCA9IF8ucmVkdWNlUmlnaHQobGlzdCwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uIHRoYXQgdGhlIGNhbGxiYWNrIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1ZXkgZm9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGBcbiAgICAgKiAgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50cyBhcyBgbmAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNodWZmbGUoY29sbGVjdGlvbik7XG4gICAgICByZXN1bHQubGVuZ3RoID0gbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlIEZpc2hlci1ZYXRlc1xuICAgICAqIHNodWZmbGUuIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHNodWZmbGVkIGNvbGxlY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgICAqIC8vID0+IFs0LCAxLCA2LCAzLCA1LCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKDAsICsraW5kZXgpO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgICByZXN1bHRbcmFuZF0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yIGFycmF5c1xuICAgICAqIGFuZCBhcnJheS1saWtlIG9iamVjdHMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgY29sbGVjdGlvbi5sZW5ndGhgIG9yIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDJdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydWV5IHZhbHVlIGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24uIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYSBwYXNzaW5nIHZhbHVlIGFuZFxuICAgICAqIGRvZXMgbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCB3aWxsIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyXG4gICAgICogb2YgZXF1YWwgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB3aWxsIGJlIHNvcnRlZCBieSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNvcnRlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguc2luKG51bSk7IH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuc2luKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDI2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogMzAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCAnYWdlJyksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAyNl0sIFsnZnJlZCcsIDMwXSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIC8vIHNvcnRpbmcgYnkgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsIFsnbmFtZScsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9ID4gW1snYmFybmV5JywgMjZdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoY2FsbGJhY2spLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0WysraW5kZXhdID0gZ2V0T2JqZWN0KCk7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIG9iamVjdC5jcml0ZXJpYSA9IG1hcChjYWxsYmFjaywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAob2JqZWN0LmNyaXRlcmlhID0gZ2V0QXJyYXkoKSlbMF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QuaW5kZXggPSBpbmRleDtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgIHJlc3VsdC5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBvYmplY3QudmFsdWU7XG4gICAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgICByZWxlYXNlQXJyYXkob2JqZWN0LmNyaXRlcmlhKTtcbiAgICAgICAgfVxuICAgICAgICByZWxlYXNlT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBgY29sbGVjdGlvbmAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpOyB9KSgxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc2xpY2UoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIG9mIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9XVxuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdwZXRzJzogWydkaW5vJ10gfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfV1cbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBmaWx0ZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgYWxsIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgMywgNCwgNV0sIFs1LCAyLCAxMF0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgMjA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlID4gMzA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvciBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZ1xuICAgICAqIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWQsIHRha2VcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpcnN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlyc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSAodGhlIG5lc3RpbmcgY2FuIGJlIHRvIGFueSBkZXB0aCkuIElmIGBpc1NoYWxsb3dgXG4gICAgICogaXMgdHJ1ZXksIHRoZSBhcnJheSB3aWxsIG9ubHkgYmUgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlXG4gICAgICogZmxhdHRlbmluZy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDMwLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5mbGF0dGVuKGNoYXJhY3RlcnMsICdwZXRzJyk7XG4gICAgICogLy8gPT4gWydob3BweScsICdiYWJ5IHB1c3MnLCAnZGlubyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Jvb2xlYW4nICYmIGlzU2hhbGxvdyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU2hhbGxvdyAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NoYWxsb3ddID09PSBhcnJheSkgPyBudWxsIDogaXNTaGFsbG93O1xuICAgICAgICBpc1NoYWxsb3cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5ID0gbWFwKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBhbHJlYWR5IHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHdpbGwgcnVuIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tIG9yIGB0cnVlYFxuICAgICAqICB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDIsIDMsIDNdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCB8fCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpbmRleF0gPT09IHZhbHVlID8gaW5kZXggOiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGFcbiAgICAgKiBjYWxsYmFjayBpcyBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbVxuICAgICAqIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5pbml0aWFsKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5pbml0aWFsKGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBjYWxsYmFjayB8fCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgdHJ1c3RJbmRleE9mID0gaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2FyZ3NJbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGNhY2hlcy5wdXNoKHRydXN0SW5kZXhPZiAmJiB2YWx1ZS5sZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiZcbiAgICAgICAgICAgIGNyZWF0ZUNhY2hlKGFyZ3NJbmRleCA/IGFyZ3NbYXJnc0luZGV4XSA6IHNlZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gYXJnc1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbMF07XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2Yoc2VlbiwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICBhcmdzSW5kZXggPSBhcmdzTGVuZ3RoO1xuICAgICAgICAgIChjYWNoZSB8fCBzZWVuKS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB3aGlsZSAoLS1hcmdzSW5kZXgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFyZ3NbYXJnc0luZGV4XSwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzTGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShjYWNoZXMpO1xuICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb3IgbGFzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgcmV0dXJuZWQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudChzKSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ubGFzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubGFzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkXG4gICAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBpbmRleCArIGZyb21JbmRleCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4LCBpbmRleCAtIDEpKSArIDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsKGFycmF5KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgLiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgc3RvcGAgYVxuICAgICAqIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IHJhbmdlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gdHlwZW9mIHN0ZXAgPT0gJ251bWJlcicgPyBzdGVwIDogKCtzdGVwIHx8IDEpO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzXG4gICAgICAvLyBodHRwOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXNcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heCgwLCBjZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSkpLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSB0aGF0IHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNCwgNSwgNl07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uaW5pdGlhbGAgdGhpcyBtZXRob2QgZ2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9yXG4gICAgICogZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGVsZW1lbnRzXG4gICAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZHJvcCwgdGFpbFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBuYXRpdmVNYXgoMCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoIGEgdmFsdWVcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBhIGdpdmVuIHNvcnRlZCBhcnJheSBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgc29ydFxuICAgICAqIG9yZGVyIG9mIHRoZSBhcnJheS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvclxuICAgICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICAgKiBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMjAsIDMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMjAgfSwgeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7XG4gICAgICogICAnd29yZFRvTnVtYmVyJzogeyAndHdlbnR5JzogMjAsICd0aGlydHknOiAzMCwgJ2ZvdXJ0eSc6IDQwLCAnZmlmdHknOiA1MCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgaW5saW5pbmcgaW4gRmlyZWZveFxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkgOiBpZGVudGl0eTtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAoY2FsbGJhY2soYXJyYXlbbWlkXSkgPCB2YWx1ZSlcbiAgICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgICA6IGhpZ2ggPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDUsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgc29ydGVkLCBwcm92aWRpbmdcbiAgICAgKiBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgd2lsbCB1c2UgYSBmYXN0ZXIgYWxnb3JpdGhtLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZSB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBgYXJyYXlgIGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIsIDEsIDMsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMSwgMiwgMiwgM10sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsnQScsICdiJywgJ0MnLCAnYScsICdCJywgJ2MnXSwgZnVuY3Rpb24obGV0dGVyKSB7IHJldHVybiBsZXR0ZXIudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICogLy8gPT4gWydBJywgJ2InLCAnQyddXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIuNSwgMywgMS41LCAyLCAzLjVdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzEsIDIuNSwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJyAmJiBpc1NvcnRlZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSAodHlwZW9mIGlzU29ydGVkICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU29ydGVkXSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDAsIDMsIDEsIDRdLCAwLCAxKTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAgICAgKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSk7XG4gICAgICogLy8gPT4gWzMsIDUsIDRdXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMiwgNV0sIFsyLCAzLCA1XSwgWzMsIDQsIDVdKTtcbiAgICAgKiAvLyA9PiBbMSwgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheSkgfHwgaXNBcmd1bWVudHMoYXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgPyBiYXNlVW5pcShiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KS5jb25jYXQoYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW56aXBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzIDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBtYXgocGx1Y2soYXJyYXksICdsZW5ndGgnKSkgOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzIG9mIGBrZXlzYCBhbmQgYHZhbHVlc2AuIFByb3ZpZGVcbiAgICAgKiBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LCBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWBcbiAgICAgKiBvciB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmICghdmFsdWVzICYmIGxlbmd0aCAmJiAhaXNBcnJheShrZXlzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGBmdW5jYCwgd2l0aCAgdGhlIGB0aGlzYCBiaW5kaW5nIGFuZFxuICAgICAqIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgb25seSBhZnRlciBiZWluZyBjYWxsZWQgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGJlZm9yZVxuICAgICAqICBgZnVuY2AgaXMgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdEb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ0RvbmUgc2F2aW5nIScsIGFmdGVyIGFsbCBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYyA9IF8uYmluZChmdW5jLCB7ICduYW1lJzogJ2ZyZWQnIH0sICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoZnVuYywgMTcsIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIHRoaXNBcmcpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIHRoZSBmdW5jdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAgd2lsbCBiZSBib3VuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbbWV0aG9kTmFtZV0gVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG9cbiAgICAgKiAgYmluZCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgbWV0aG9kIG5hbWVzIG9yIGFycmF5cyBvZiBtZXRob2QgbmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnb25DbGljayc6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7IH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGxvZ3MgJ2NsaWNrZWQgZG9jcycsIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEFsbChvYmplY3QpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCBmYWxzZSwgMSkgOiBmdW5jdGlvbnMob2JqZWN0KSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBjcmVhdGVXcmFwcGVyKG9iamVjdFtrZXldLCAxLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kXG4gICAgICogZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG9cbiAgICAgKiByZWZlcmVuY2UgbWV0aG9kcyB0aGF0IHdpbGwgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgaHR0cDovL21pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICduYW1lJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMubmFtZSArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRLZXkob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoa2V5LCAxOSwgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgb2JqZWN0KVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoa2V5LCAzLCBudWxsLCBudWxsLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zLFxuICAgICAqIHdoZXJlIGVhY2ggZnVuY3Rpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICAgICAqIEZvciBleGFtcGxlLCBjb21wb3NpbmcgdGhlIGZ1bmN0aW9ucyBgZigpYCwgYGcoKWAsIGFuZCBgaCgpYCBwcm9kdWNlcyBgZihnKGgoKSkpYC5cbiAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY10gRnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFsTmFtZU1hcCA9IHtcbiAgICAgKiAgICdwZWJibGVzJzogJ3BlbmVsb3BlJ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZm9ybWF0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAqICAgbmFtZSA9IHJlYWxOYW1lTWFwW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbmFtZTtcbiAgICAgKiAgIHJldHVybiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihmb3JtYXR0ZWQpIHtcbiAgICAgKiAgIHJldHVybiAnSGl5YSAnICsgZm9ybWF0dGVkICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgd2VsY29tZSA9IF8uY29tcG9zZShncmVldCwgZm9ybWF0KTtcbiAgICAgKiB3ZWxjb21lKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0hpeWEgUGVuZWxvcGUhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmNzW2xlbmd0aF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzID0gW2Z1bmNzW2xlbmd0aF0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGludm9rZWQgZWl0aGVyIGV4ZWN1dGVzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhhICsgYiArIGMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5KSB7XG4gICAgICBhcml0eSA9IHR5cGVvZiBhcml0eSA9PSAnbnVtYmVyJyA/IGFyaXR5IDogKCthcml0eSB8fCBmdW5jLmxlbmd0aCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCA0LCBudWxsLCBudWxsLCBudWxsLCBhcml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGBmdW5jYCB1bnRpbCBhZnRlclxuICAgICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuXG4gICAgICogUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvblxuICAgICAqIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxsc1xuICAgICAqIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiB2YXIgbGF6eUxheW91dCA9IF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGV4ZWN1dGVkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAgICogICAnbWF4V2FpdCc6IDEwMDBcbiAgICAgKiB9LCBmYWxzZSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB3YWl0ID0gbmF0aXZlTWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAobmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgZXhlY3V0aW5nIHRoZSBgZnVuY2AgZnVuY3Rpb24gdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICAgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZlcihmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnVuY2AgZnVuY3Rpb24gYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgZXhlY3V0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdFxuICAgICAqIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIFRoZSByZXN1bHQgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gQSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmaWJvbmFjY2kgPSBfLm1lbW9pemUoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAyID8gbiA6IGZpYm9uYWNjaShuIC0gMSkgKyBmaWJvbmFjY2kobiAtIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmlib25hY2NpKDkpXG4gICAgICogLy8gPT4gMzRcbiAgICAgKlxuICAgICAqIHZhciBkYXRhID0ge1xuICAgICAqICAgJ2ZyZWQnOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHZhciBnZXQgPSBfLm1lbW9pemUoZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZGF0YVtuYW1lXTsgfSwgXy5pZGVudGl0eSk7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqXG4gICAgICogZ2V0LmNhY2hlLnBlYmJsZXMubmFtZSA9ICdwZW5lbG9wZSc7XG4gICAgICogZ2V0KCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdwZW5lbG9wZScsICdhZ2UnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBtZW1vaXplZC5jYWNoZSxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleVByZWZpeCArIGFyZ3VtZW50c1swXTtcblxuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KVxuICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGV4ZWN1dGUgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxscyB0b1xuICAgICAqIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgZXhlY3V0ZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICB2YXIgcmFuLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyYW4pIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgYGZ1bmNgIHZhcmlhYmxlIHNvIHRoZSBmdW5jdGlvbiBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCBhbnkgYWRkaXRpb25hbFxuICAgICAqIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXNcbiAgICAgKiBtZXRob2QgaXMgc2ltaWxhciB0byBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkgeyByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lOyB9O1xuICAgICAqIHZhciBoaSA9IF8ucGFydGlhbChncmVldCwgJ2hpJyk7XG4gICAgICogaGkoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE2LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IGBwYXJ0aWFsYCBhcmd1bWVudHMgYXJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHNEZWVwID0gXy5wYXJ0aWFsUmlnaHQoXy5tZXJnZSwgXy5kZWZhdWx0cyk7XG4gICAgICpcbiAgICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICd2YXJpYWJsZSc6ICdkYXRhJyxcbiAgICAgKiAgICdpbXBvcnRzJzogeyAnanEnOiAkIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZGVmYXVsdHNEZWVwKG9wdGlvbnMsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG4gICAgICpcbiAgICAgKiBvcHRpb25zLnZhcmlhYmxlXG4gICAgICogLy8gPT4gJ2RhdGEnXG4gICAgICpcbiAgICAgKiBvcHRpb25zLmltcG9ydHNcbiAgICAgKiAvLyA9PiB7ICdfJzogXywgJ2pxJzogJCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbFJpZ2h0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDMyLCBudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBleGVjdXRlZCwgd2lsbCBvbmx5IGNhbGwgdGhlIGBmdW5jYCBmdW5jdGlvblxuICAgICAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0b1xuICAgICAqIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlXG4gICAgICogb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbFxuICAgICAqIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmdcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIGV4ZWN1dGUgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlc1xuICAgICAqIGpRdWVyeSgnLmludGVyYWN0aXZlJykub24oJ2NsaWNrJywgXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHtcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMubWF4V2FpdCA9IHdhaXQ7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBpcyBleGVjdXRlZCB3aXRoXG4gICAgICogdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPkZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCAxNiwgW3ZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjYWxsYmFjayBib3VuZCB0byBhbiBvcHRpb25hbCBgdGhpc0FyZ2AuIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5XG4gICAgICogbmFtZSB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBJZiBgZnVuY2AgaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGNhbGxiYWNrKTtcbiAgICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYWdlX19ndDM4Jyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgXCJfLnBsdWNrXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5KGZ1bmMpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0ga2V5cyhmdW5jKSxcbiAgICAgICAgICBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgICBhID0gZnVuY1trZXldO1xuXG4gICAgICAvLyBoYW5kbGUgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PSAxICYmIGEgPT09IGEgJiYgIWlzT2JqZWN0KGEpKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCB0aGUgY29tbW9uIGNhc2Ugb2YgcHJvdmlkaW5nIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAgICAgIC8vIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBwcmltaXRpdmUgdmFsdWVcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHZhciBiID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGIgJiYgKGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChvYmplY3RbcHJvcHNbbGVuZ3RoXV0sIGZ1bmNbcHJvcHNbbGVuZ3RoXV0sIG51bGwsIHRydWUpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIGAmYCwgYDxgLCBgPmAsIGBcImAsIGFuZCBgJ2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gbWV0aG9kcyB3aWxsIGJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWQgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0pO1xuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGFpbiA9IHRydWUsXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBzb3VyY2UgJiYgZnVuY3Rpb25zKHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlIHx8ICghb3B0aW9ucyAmJiAhbWV0aG9kTmFtZXMubGVuZ3RoKSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gbG9kYXNoV3JhcHBlcjtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSBsb2Rhc2g7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gZnVuY3Rpb25zKHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yID0gb2JqZWN0LFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24oY3Rvcik7XG5cbiAgICAgIGZvckVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBvYmplY3RbbWV0aG9kTmFtZV0gPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdmFsdWVdO1xuXG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0ICYmIGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgY3RvcihyZXN1bHQpO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlICdfJyB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBjb250ZXh0Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdGFtcCA9IF8ubm93KCk7XG4gICAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGlzTmF0aXZlKG5vdyA9IERhdGUubm93KSAmJiBub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBJZiBgcmFkaXhgIGlzIGB1bmRlZmluZWRgIG9yIGAwYCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyB0aGVcbiAgICAgKiBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGF2b2lkcyBkaWZmZXJlbmNlcyBpbiBuYXRpdmUgRVMzIGFuZCBFUzUgYHBhcnNlSW50YFxuICAgICAqIGltcGxlbWVudGF0aW9ucy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyNFLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBuZXcgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICovXG4gICAgdmFyIHBhcnNlSW50ID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZSArICcwOCcpID09IDggPyBuYXRpdmVQYXJzZUludCA6IGZ1bmN0aW9uKHZhbHVlLCByYWRpeCkge1xuICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyB0aGUgRVMzIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZUxlYWRpbmdTcGFjZXNBbmRaZXJvcywgJycpIDogdmFsdWUsIHJhZGl4IHx8IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgXCJfLnBsdWNrXCIgc3R5bGUgZnVuY3Rpb24sIHdoaWNoIHJldHVybnMgdGhlIGBrZXlgIHZhbHVlIG9mIGFcbiAgICAgKiBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCduYW1lJyk7XG4gICAgICpcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgdHJ1ZXkgb3IgZWl0aGVyIGBtaW5gIG9yIGBtYXhgIGFyZSBmbG9hdHMgYVxuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlciB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZz1mYWxzZV0gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdGluZykge1xuICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG4gICAgICAgICAgbm9NYXggPSBtYXggPT0gbnVsbDtcblxuICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT0gJ2Jvb2xlYW4nICYmIG5vTWF4KSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtaW47XG4gICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbm9NYXggJiYgdHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsnJykubGVuZ3RoIC0gMSkpKSksIG1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGBrZXlgIG9uIGBvYmplY3RgLiBJZiBga2V5YCBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBvYmplY3RgIGFuZCBpdHMgcmVzdWx0IHJldHVybmVkLFxuICAgICAqIGVsc2UgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJldHVybmVkLiBJZiBgb2JqZWN0YCBpcyBmYWxzZXkgdGhlbiBgdW5kZWZpbmVkYFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2NoZWVzZSc6ICdjcnVtcGV0cycsXG4gICAgICogICAnc3R1ZmYnOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuICdub25zZW5zZSc7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2NoZWVzZScpO1xuICAgICAqIC8vID0+ICdjcnVtcGV0cydcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3N0dWZmJyk7XG4gICAgICogLy8gPT4gJ25vbnNlbnNlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W2tleV0oKSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbWljcm8tdGVtcGxhdGluZyBtZXRob2QgdGhhdCBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXNcbiAgICAgKiB3aGl0ZXNwYWNlLCBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCwgYF8udGVtcGxhdGVgIHV0aWxpemVzIHNvdXJjZVVSTHMgZm9yIGVhc2llclxuICAgICAqIGRlYnVnZ2luZy4gU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlOlxuICAgICAqIGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjInO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9mbHVzaCkpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHRzLndyaXRlY2h1bmspICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc1N0cmluZyhjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IHV0aWwuaXNOdWxsKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAoIXV0aWwuaXNOdW1iZXIobikgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAodXRpbC5pc051bGwocmV0KSkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB9XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdW1lXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHN0cmVhbVtpXSkgJiYgdXRpbC5pc1VuZGVmaW5lZCh0aGlzW2ldKSkge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyogZ2xvYmFsIERpYWxvZywgZGFzaGJvYXJkLCBBcHBsYWIgKi9cbi8vIFRPRE8gKGpvc2gpIC0gZG9uJ3QgcGFzcyBgRGlhbG9nYCBpbnRvIGBjcmVhdGVNb2RhbERpYWxvZ2AuXG5cbnZhciBBc3NldE1hbmFnZXIgPSByZXF1aXJlKCcuL0Fzc2V0TWFuYWdlci5qc3gnKTtcbnZhciBzdHVkaW9BcHAgPSByZXF1aXJlKCcuLi9TdHVkaW9BcHAnKS5zaW5nbGV0b247XG5cbi8qKlxuICogRGlzcGxheSB0aGUgXCJNYW5hZ2UgQXNzZXRzXCIgbW9kYWwuXG4gKiBAcGFyYW0gYXNzZXRDaG9zZW4ge0Z1bmN0aW9ufSBDYWxsZWQgd2hlbiB0aGUgdXNlciBjaG9vc2VzIGFuIGFzc2V0LiBUaGVcbiAqICAgXCJDaG9vc2VcIiBidXR0b24gaW4gdGhlIFVJIG9ubHkgYXBwZWFycyBpZiB0aGlzIG9wdGlvbmFsIHBhcmFtIGlzIHByb3ZpZGVkLlxuICogQHBhcmFtIHR5cGVGaWx0ZXIge1N0cmluZ30gVGhlIHR5cGUgb2YgYXNzZXRzIHRvIHNob3cgYW5kIGFsbG93IHRvIGJlXG4gKiAgIHVwbG9hZGVkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFzc2V0Q2hvc2VuLCB0eXBlRmlsdGVyKSB7XG4gIHZhciBjb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzaG93Q2hvc2VJbWFnZUJ1dHRvbiA9IGFzc2V0Q2hvc2VuICYmIHR5cGVvZiBhc3NldENob3NlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIGRpYWxvZyA9IHN0dWRpb0FwcC5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgY29udGVudERpdjogY29kZURpdixcbiAgICBkZWZhdWx0QnRuU2VsZWN0b3I6ICdhZ2Fpbi1idXR0b24nLFxuICAgIGlkOiAnbWFuYWdlQXNzZXRzTW9kYWwnXG4gIH0pO1xuICBSZWFjdC5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChBc3NldE1hbmFnZXIsIHtcbiAgICB0eXBlRmlsdGVyOiB0eXBlRmlsdGVyLFxuICAgIGNoYW5uZWxJZDogZGFzaGJvYXJkLnByb2plY3QuZ2V0Q3VycmVudElkKCksXG4gICAgdXBsb2Fkc0VuYWJsZWQ6ICFkYXNoYm9hcmQucHJvamVjdC5leGNlZWRzQWJ1c2VUaHJlc2hvbGQoKSxcbiAgICBhc3NldENob3Nlbjogc2hvd0Nob3NlSW1hZ2VCdXR0b24gPyBmdW5jdGlvbiAoZmlsZVdpdGhQYXRoKSB7XG4gICAgICBkaWFsb2cuaGlkZSgpO1xuICAgICAgYXNzZXRDaG9zZW4oZmlsZVdpdGhQYXRoKTtcbiAgICB9IDogbnVsbFxuICB9KSwgY29kZURpdik7XG5cbiAgZGlhbG9nLnNob3coKTtcbn07XG4iLCJ2YXIgYXNzZXRzQXBpID0gcmVxdWlyZSgnLi4vY2xpZW50QXBpJykuYXNzZXRzO1xudmFyIEFzc2V0Um93ID0gcmVxdWlyZSgnLi9Bc3NldFJvdy5qc3gnKTtcbnZhciBBc3NldFVwbG9hZGVyID0gcmVxdWlyZSgnLi9Bc3NldFVwbG9hZGVyLmpzeCcpO1xudmFyIGFzc2V0TGlzdFN0b3JlID0gcmVxdWlyZSgnLi9hc3NldExpc3RTdG9yZScpO1xuXG52YXIgZXJyb3JNZXNzYWdlcyA9IHtcbiAgNDAzOiAnUXVvdGEgZXhjZWVkZWQuIFBsZWFzZSBkZWxldGUgc29tZSBmaWxlcyBhbmQgdHJ5IGFnYWluLicsXG4gIDQxMzogJ1RoZSBmaWxlIGlzIHRvbyBsYXJnZS4nLFxuICA0MTU6ICdUaGlzIHR5cGUgb2YgZmlsZSBpcyBub3Qgc3VwcG9ydGVkLicsXG4gIDUwMDogJ1RoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IuJyxcbiAgdW5rbm93bjogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuJ1xufTtcblxudmFyIGVycm9yVXBsb2FkRGlzYWJsZWQgPSBcIlRoaXMgcHJvamVjdCBoYXMgYmVlbiByZXBvcnRlZCBmb3IgYWJ1c2l2ZSBjb250ZW50LCBcIiArXG4gIFwic28gdXBsb2FkaW5nIG5ldyBhc3NldHMgaXMgZGlzYWJsZWQuXCI7XG5cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShzdGF0dXMpIHtcbiAgcmV0dXJuIGVycm9yTWVzc2FnZXNbc3RhdHVzXSB8fCBlcnJvck1lc3NhZ2VzLnVua25vd247XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgZm9yIG1hbmFnaW5nIGhvc3RlZCBhc3NldHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBhc3NldENob3NlbjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdHlwZUZpbHRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGFubmVsSWQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB1cGxvYWRzRW5hYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhc3NldHM6IG51bGwsXG4gICAgICBzdGF0dXNNZXNzYWdlOiB0aGlzLnByb3BzLnVwbG9hZHNFbmFibGVkID8gJycgOiBlcnJvclVwbG9hZERpc2FibGVkXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBVc2UgRGF2ZSdzIGNsaWVudCBhcGkgd2hlbiBpdCdzIGZpbmlzaGVkLlxuICAgIGFzc2V0c0FwaS5hamF4KCdHRVQnLCAnJywgdGhpcy5vbkFzc2V0TGlzdFJlY2VpdmVkLCB0aGlzLm9uQXNzZXRMaXN0RmFpbHVyZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cywgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgbGlzdCBvZiBhc3NldHMuXG4gICAqIEBwYXJhbSB4aHJcbiAgICovXG4gIG9uQXNzZXRMaXN0UmVjZWl2ZWQ6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICBhc3NldExpc3RTdG9yZS5yZXNldChKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICB0aGlzLnNldFN0YXRlKHthc3NldHM6IGFzc2V0TGlzdFN0b3JlLmxpc3QodGhpcy5wcm9wcy50eXBlRmlsdGVyKX0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMsIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCBhbiBlcnJvclxuICAgKiB3aGVuIGxvYWRpbmcgdGhlIGN1cnJlbnQgbGlzdCBvZiBhc3NldHMuXG4gICAqIEBwYXJhbSB4aHJcbiAgICovXG4gIG9uQXNzZXRMaXN0RmFpbHVyZTogZnVuY3Rpb24gKHhocikge1xuICAgIHRoaXMuc2V0U3RhdGUoe3N0YXR1c01lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIGFzc2V0IGxpc3Q6ICcgK1xuICAgICAgZ2V0RXJyb3JNZXNzYWdlKHhoci5zdGF0dXMpfSk7XG4gIH0sXG5cbiAgb25VcGxvYWRTdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe3N0YXR1c01lc3NhZ2U6ICdVcGxvYWRpbmcuLi4nfSk7XG4gIH0sXG5cbiAgb25VcGxvYWREb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgYXNzZXRMaXN0U3RvcmUuYWRkKHJlc3VsdCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhc3NldHM6IGFzc2V0TGlzdFN0b3JlLmxpc3QodGhpcy5wcm9wcy50eXBlRmlsdGVyKSxcbiAgICAgIHN0YXR1c01lc3NhZ2U6ICdGaWxlIFwiJyArIHJlc3VsdC5maWxlbmFtZSArICdcIiBzdWNjZXNzZnVsbHkgdXBsb2FkZWQhJ1xuICAgIH0pO1xuICB9LFxuXG4gIG9uVXBsb2FkRXJyb3I6IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtzdGF0dXNNZXNzYWdlOiAnRXJyb3IgdXBsb2FkaW5nIGZpbGU6ICcgK1xuICAgICAgZ2V0RXJyb3JNZXNzYWdlKHN0YXR1cyl9KTtcbiAgfSxcblxuICBkZWxldGVBc3NldFJvdzogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFzc2V0czogYXNzZXRMaXN0U3RvcmUucmVtb3ZlKG5hbWUpLFxuICAgICAgc3RhdHVzTWVzc2FnZTogJ0ZpbGUgXCInICsgbmFtZSArICdcIiBzdWNjZXNzZnVsbHkgZGVsZXRlZCEnXG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVwbG9hZEJ1dHRvbiA9IDxkaXY+XG4gICAgICA8QXNzZXRVcGxvYWRlclxuICAgICAgICB1cGxvYWRzRW5hYmxlZD17dGhpcy5wcm9wcy51cGxvYWRzRW5hYmxlZH1cbiAgICAgICAgdHlwZUZpbHRlcj17dGhpcy5wcm9wcy50eXBlRmlsdGVyfVxuICAgICAgICBjaGFubmVsSWQ9e3RoaXMucHJvcHMuY2hhbm5lbElkfVxuICAgICAgICBvblVwbG9hZFN0YXJ0PXt0aGlzLm9uVXBsb2FkU3RhcnR9XG4gICAgICAgIG9uVXBsb2FkRG9uZT17dGhpcy5vblVwbG9hZERvbmV9XG4gICAgICAgIG9uVXBsb2FkRXJyb3I9e3RoaXMub25VcGxvYWRFcnJvcn0vPlxuICAgICAgPHNwYW4gc3R5bGU9e3ttYXJnaW46ICcwIDEwcHgnfX0gaWQ9XCJtYW5hZ2UtYXNzZXQtc3RhdHVzXCI+XG4gICAgICAgIHt0aGlzLnN0YXRlLnN0YXR1c01lc3NhZ2V9XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+O1xuXG4gICAgdmFyIGFzc2V0TGlzdDtcbiAgICAvLyBJZiBgdGhpcy5zdGF0ZS5hc3NldHNgIGlzIG51bGwsIHRoZSBhc3NldCBsaXN0IGlzIHN0aWxsIGxvYWRpbmcuIElmIGl0J3NcbiAgICAvLyBlbXB0eSwgdGhlIGFzc2V0IGxpc3QgaGFzIGxvYWRlZCBhbmQgdGhlcmUgYXJlIG5vIGFzc2V0cyBpbiB0aGUgY3VycmVudFxuICAgIC8vIGNoYW5uZWwgKG1hdGNoaW5nIHRoZSBgdHlwZUZpbHRlcmAsIGlmIG9uZSB3YXMgcHJvdmlkZWQpLlxuICAgIGlmICh0aGlzLnN0YXRlLmFzc2V0cyA9PT0gbnVsbCkge1xuICAgICAgYXNzZXRMaXN0ID0gKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7bWFyZ2luOiAnMWVtIDAnLCB0ZXh0QWxpZ246ICdjZW50ZXInfX0+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgc3R5bGU9e3tmb250U2l6ZTogJzMycHgnfX0+PC9pPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmFzc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFzc2V0TGlzdCA9IChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWFyZ2luOiAnMWVtIDAnfX0+XG4gICAgICAgICAgICBZb3VyIGFzc2V0cyB3aWxsIGFwcGVhciBoZXJlLiBDbGljayBcIlVwbG9hZCBGaWxlXCIgdG8gYWRkIGEgbmV3IGFzc2V0XG4gICAgICAgICAgICBmb3IgdGhpcyBwcm9qZWN0LlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt1cGxvYWRCdXR0b259XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLnN0YXRlLmFzc2V0cy5tYXAoZnVuY3Rpb24gKGFzc2V0KSB7XG4gICAgICAgIHZhciBjaG9vc2UgPSB0aGlzLnByb3BzLmFzc2V0Q2hvc2VuICYmIHRoaXMucHJvcHMuYXNzZXRDaG9zZW4uYmluZCh0aGlzLFxuICAgICAgICAgICAgYXNzZXQuZmlsZW5hbWUpO1xuXG4gICAgICAgIHJldHVybiA8QXNzZXRSb3dcbiAgICAgICAgICAgIGtleT17YXNzZXQuZmlsZW5hbWV9XG4gICAgICAgICAgICBuYW1lPXthc3NldC5maWxlbmFtZX1cbiAgICAgICAgICAgIHR5cGU9e2Fzc2V0LmNhdGVnb3J5fVxuICAgICAgICAgICAgc2l6ZT17YXNzZXQuc2l6ZX1cbiAgICAgICAgICAgIG9uQ2hvb3NlPXtjaG9vc2V9XG4gICAgICAgICAgICBvbkRlbGV0ZT17dGhpcy5kZWxldGVBc3NldFJvdy5iaW5kKHRoaXMsIGFzc2V0LmZpbGVuYW1lKX0gLz47XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICBhc3NldExpc3QgPSAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGRpdiBzdHlsZT17e21heEhlaWdodDogJzMzMHB4Jywgb3ZlcmZsb3dZOiAnc2Nyb2xsJywgbWFyZ2luOiAnMWVtIDAnLCBwYWRkaW5nUmlnaHQ6ICcxNXB4J319PlxuICAgICAgICAgICAgPHRhYmxlIHN0eWxlPXt7d2lkdGg6ICcxMDAlJ319PlxuICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt1cGxvYWRCdXR0b259XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdGl0bGUgPSB0aGlzLnByb3BzLmFzc2V0Q2hvc2VuID9cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwiZGlhbG9nLXRpdGxlXCI+Q2hvb3NlIEFzc2V0czwvcD4gOlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJkaWFsb2ctdGl0bGVcIj5NYW5hZ2UgQXNzZXRzPC9wPjtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIiBzdHlsZT17e21hcmdpbjogMH19PlxuICAgICAgICB7dGl0bGV9XG4gICAgICAgIHthc3NldExpc3R9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbiIsIlxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgbWFuYWdpbmcgaG9zdGVkIGFzc2V0cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIG9uVXBsb2FkU3RhcnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb25VcGxvYWREb25lOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGNoYW5uZWxJZDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHR5cGVGaWx0ZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdXBsb2Fkc0VuYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAkKFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmcy51cGxvYWRlcikpLmZpbGV1cGxvYWQoe1xuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIHVybDogJy92My9hc3NldHMvJyArIHByb3BzLmNoYW5uZWxJZCArICcvJyxcbiAgICAgIC8vIHByZXZlbnQgZmlsZXVwbG9hZCBmcm9tIHJlcGxhY2luZyB0aGUgaW5wdXQgRE9NIGVsZW1lbnQsIHdoaWNoXG4gICAgICAvLyBSZWFjdCBkb2VzIG5vdCBsaWtlXG4gICAgICByZXBsYWNlRmlsZUlucHV0OiBmYWxzZSxcbiAgICAgIGFkZDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgcHJvcHMub25VcGxvYWRTdGFydCgpO1xuICAgICAgICBkYXRhLnN1Ym1pdCgpO1xuICAgICAgfSxcbiAgICAgIGRvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIHByb3BzLm9uVXBsb2FkRG9uZShkYXRhLnJlc3VsdCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgIHByb3BzLm9uVXBsb2FkRXJyb3IoZS5zdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgJChSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnMudXBsb2FkZXIpKS5maWxldXBsb2FkKCdkZXN0cm95Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlJ3ZlIGhpZGRlbiB0aGUgPGlucHV0IHR5cGU9XCJmaWxlXCIvPiBhbmQgcmVwbGFjZWQgaXQgd2l0aCBhIGJpZyBidXR0b24uXG4gICAqIEZvcndhcmQgY2xpY2tzIG9uIHRoZSBidXR0b24gdG8gdGhlIGhpZGRlbiBmaWxlIGlucHV0LlxuICAgKi9cbiAgZmlsZVVwbG9hZENsaWNrZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXBsb2FkZXIgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnMudXBsb2FkZXIpO1xuICAgIHVwbG9hZGVyLmNsaWNrKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTk9URTogSUU5IHdpbGwgaWdub3JlIGFjY2VwdCwgd2hpY2ggbWVhbnMgb24gdGhpcyBicm93c2VyIHdlIGNhbiBlbmRcbiAgICAvLyB1cCB1cGxvYWRpbmcgZmlsZXMgdGhhdCBkb250IG1hdGNoIHR5cGVGaWx0ZXJcbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgcmVmPVwidXBsb2FkZXJcIlxuICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgc3R5bGU9e3tkaXNwbGF5OiAnbm9uZSd9fVxuICAgICAgICAgICAgYWNjZXB0PXsodGhpcy5wcm9wcy50eXBlRmlsdGVyIHx8ICcqJykgKyAnLyonfS8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuZmlsZVVwbG9hZENsaWNrZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJzaGFyZVwiXG4gICAgICAgICAgICBpZD1cInVwbG9hZC1hc3NldFwiXG4gICAgICAgICAgICBkaXNhYmxlZD17IXRoaXMucHJvcHMudXBsb2Fkc0VuYWJsZWR9PlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAmbmJzcDtVcGxvYWQgRmlsZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG59KTtcbiIsInZhciBhc3NldHNBcGkgPSByZXF1aXJlKCcuLi9jbGllbnRBcGknKS5hc3NldHM7XG52YXIgQXNzZXRUaHVtYm5haWwgPSByZXF1aXJlKCcuL0Fzc2V0VGh1bWJuYWlsLmpzeCcpO1xuXG4vKipcbiAqIEEgc2luZ2xlIHJvdyBpbiB0aGUgQXNzZXRNYW5hZ2VyLCBkZXNjcmliaW5nIG9uZSBhc3NldC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0eXBlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoWydpbWFnZScsICdhdWRpbycsICd2aWRlbyddKS5pc1JlcXVpcmVkLFxuICAgIHNpemU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgb25DaG9vc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVsZXRlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogJ25vcm1hbCcsXG4gICAgICBhY3Rpb25UZXh0OiAnJ1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbmZpcm0gdGhlIHVzZXIgYWN0dWFsbHkgd2FudHMgdG8gZGVsZXRlIHRoaXMgYXNzZXQuXG4gICAqL1xuICBjb25maXJtRGVsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7YWN0aW9uOiAnY29uZmlybWluZyBkZWxldGUnLCBhY3Rpb25UZXh0OiAnJ30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIHVzZXIgZGlkbid0IHdhbnQgdG8gZGVsZXRlIHRoaXMgYXNzZXQuXG4gICAqL1xuICBjYW5jZWxEZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHthY3Rpb246ICdub3JtYWwnLCBhY3Rpb25UZXh0OiAnJ30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhpcyBhc3NldCBhbmQgbm90aWZ5IHRoZSBwYXJlbnQgdG8gcmVtb3ZlIHRoaXMgcm93LiBJZiB0aGUgZGVsZXRlXG4gICAqIGZhaWxzLCBmbGlwIGJhY2sgdG8gJ2NvbmZpcm1pbmcgZGVsZXRlJyBhbmQgZGlzcGxheSBhIG1lc3NhZ2UuXG4gICAqL1xuICBoYW5kbGVEZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHthY3Rpb246ICdkZWxldGluZycsIGFjdGlvblRleHQ6ICcnfSk7XG5cbiAgICAvLyBUT0RPOiBVc2UgRGF2ZSdzIGNsaWVudCBhcGkgd2hlbiBpdCdzIGZpbmlzaGVkLlxuICAgIGFzc2V0c0FwaS5hamF4KCdERUxFVEUnLCB0aGlzLnByb3BzLm5hbWUsIHRoaXMucHJvcHMub25EZWxldGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2FjdGlvbjogJ2NvbmZpcm1pbmcgZGVsZXRlJyxcbiAgICAgICAgICBhY3Rpb25UZXh0OiAnRXJyb3IgZGVsZXRpbmcgZmlsZS4nfSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9ucywgZmxleDtcbiAgICAvLyBgZmxleGAgaXMgdGhlIFwiQ2hvb3NlXCIgYnV0dG9uIGluIGZpbGUtY2hvb3NlIG1vZGUsIG9yIHRoZSBmaWxlc2l6ZS5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNob29zZSkge1xuICAgICAgZmxleCA9IDxidXR0b24gb25DbGljaz17dGhpcy5wcm9wcy5vbkNob29zZX0+Q2hvb3NlPC9idXR0b24+O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9ICh0aGlzLnByb3BzLnNpemUgLyAxMDAwKS50b0ZpeGVkKDIpO1xuICAgICAgZmxleCA9IHNpemUgKyAnIGtiJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuYWN0aW9uKSB7XG4gICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICB2YXIgc3JjID0gYXNzZXRzQXBpLmJhc2VQYXRoKHRoaXMucHJvcHMubmFtZSk7XG4gICAgICAgIGFjdGlvbnMgPSAoXG4gICAgICAgICAgPHRkIHdpZHRoPVwiMjUwXCIgc3R5bGU9e3t0ZXh0QWxpZ246ICdyaWdodCd9fT5cbiAgICAgICAgICAgIHtmbGV4fVxuICAgICAgICAgICAgPGEgaHJlZj17c3JjfVxuICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCd9fT5cbiAgICAgICAgICAgICAgPGJ1dHRvbj48aSBjbGFzc05hbWU9XCJmYSBmYS1leWVcIj48L2k+PC9idXR0b24+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0bi1kYW5nZXJcIiBvbkNsaWNrPXt0aGlzLmNvbmZpcm1EZWxldGV9PlxuICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS10cmFzaC1vXCI+PC9pPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5hY3Rpb25UZXh0fVxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29uZmlybWluZyBkZWxldGUnOlxuICAgICAgICBhY3Rpb25zID0gKFxuICAgICAgICAgIDx0ZCB3aWR0aD1cIjI1MFwiIHN0eWxlPXt7dGV4dEFsaWduOiAncmlnaHQnfX0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0bi1kYW5nZXJcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZURlbGV0ZX0+XG4gICAgICAgICAgICAgIERlbGV0ZSBGaWxlXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17dGhpcy5jYW5jZWxEZWxldGV9PkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICAgICAge3RoaXMuc3RhdGUuYWN0aW9uVGV4dH1cbiAgICAgICAgICA8L3RkPlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbGV0aW5nJzpcbiAgICAgICAgYWN0aW9ucyA9IChcbiAgICAgICAgICA8dGQgd2lkdGg9XCIyNTBcIiBzdHlsZT17e3RleHRBbGlnbjogJ3JpZ2h0J319PlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZm9udFNpemU6ICczMnB4JyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcxNXB4J1xuICAgICAgICAgICAgfX0+PC9pPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8dHIgY2xhc3NOYW1lPVwiYXNzZXRSb3dcIiBvbkRvdWJsZUNsaWNrPXt0aGlzLnByb3BzLm9uQ2hvb3NlfT5cbiAgICAgICAgPEFzc2V0VGh1bWJuYWlsIHR5cGU9e3RoaXMucHJvcHMudHlwZX0gbmFtZT17dGhpcy5wcm9wcy5uYW1lfS8+XG4gICAgICAgIDx0ZD57dGhpcy5wcm9wcy5uYW1lfTwvdGQ+XG4gICAgICAgIHthY3Rpb25zfVxuICAgICAgPC90cj5cbiAgICApO1xuICB9XG59KTtcbiIsInZhciBhc3NldHNBcGkgPSByZXF1aXJlKCcuLi9jbGllbnRBcGknKS5hc3NldHM7XG5cbnZhciBkZWZhdWx0SWNvbnMgPSB7XG4gIGltYWdlOiAnZmEgZmEtcGljdHVyZS1vJyxcbiAgYXVkaW86ICdmYSBmYS1tdXNpYycsXG4gIHZpZGVvOiAnZmEgZmEtdmlkZW8tY2FtZXJhJyxcbiAgdW5rbm93bjogJ2ZhIGZhLXF1ZXN0aW9uJ1xufTtcblxudmFyIGFzc2V0VGh1bWJuYWlsU3R5bGUgPSB7XG4gIHdpZHRoOiAnYXV0bycsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJ2F1dG8nLFxuICBtYXhIZWlnaHQ6ICcxMDAlJyxcbiAgbWFyZ2luVG9wOiAnNTAlJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKScsXG4gIG1zVHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKScsXG4gIFdlYmtpdFRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwJSknXG59O1xuXG52YXIgYXNzZXRJY29uU3R5bGUgPSB7XG4gIG1hcmdpbjogJzE1cHggMCcsXG4gIGZvbnRTaXplOiAnMzJweCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdHlwZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsnaW1hZ2UnLCAnYXVkaW8nLCAndmlkZW8nXSkuaXNSZXF1aXJlZCxcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcblxuICAgIHJldHVybiAoXG4gICAgICA8dGQgd2lkdGg9XCI4MFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFzc2V0VGh1bWJuYWlsXCIgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogJzYwcHgnLFxuICAgICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICAgIG1hcmdpbjogJzEwcHggYXV0bycsXG4gICAgICAgICAgYmFja2dyb3VuZDogJyNlZWUnLFxuICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICAgIH19PlxuICAgICAgICAgIHt0eXBlID09PSAnaW1hZ2UnID9cbiAgICAgICAgICAgICA8aW1nIHNyYz17YXNzZXRzQXBpLmJhc2VQYXRoKG5hbWUpfSBzdHlsZT17YXNzZXRUaHVtYm5haWxTdHlsZX0gLz4gOlxuICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT17ZGVmYXVsdEljb25zW3R5cGVdIHx8IGRlZmF1bHRJY29ucy51bmtub3dufSBzdHlsZT17YXNzZXRJY29uU3R5bGV9PjwvaT5cbiAgICAgICAgICAgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGQ+XG4gICAgKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSb3RhdGVDb250YWluZXIgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvUm90YXRlQ29udGFpbmVyLmpzeCcpO1xuXG4vKipcbiAqIFdyYXBwZXIgY29tcG9uZW50IGZvciBhbGwgQ29kZSBTdHVkaW8gYXBwIHR5cGVzLCB3aGljaCBwcm92aWRlcyByb3RhdGVcbiAqIGNvbnRhaW5lciBhbmQgY2xlYXItZGl2IGJ1dCBvdGhlcndpc2UganVzdCByZW5kZXJzIGNoaWxkcmVuLlxuICovXG52YXIgU3R1ZGlvQXBwV3JhcHBlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgYXNzZXRVcmw6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNFbWJlZFZpZXc6IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgaXNTaGFyZVZpZXc6IFJlYWN0LlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbiAgfSxcblxuICByZXF1aXJlc0xhbmRzY2FwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhKHRoaXMucHJvcHMuaXNFbWJlZFZpZXcgfHwgdGhpcy5wcm9wcy5pc1NoYXJlVmlldyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHt0aGlzLnJlcXVpcmVzTGFuZHNjYXBlKCkgJiYgPFJvdGF0ZUNvbnRhaW5lciBhc3NldFVybD17dGhpcy5wcm9wcy5hc3NldFVybH0gLz59XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNsZWFyXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gU3R1ZGlvQXBwV3JhcHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xuXG4vKipcbiAqIFwiUm90YXRlIHlvdXIgZGV2aWNlXCIgb3ZlcmxheS5cbiAqL1xudmFyIFJvdGF0ZUNvbnRhaW5lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgYXNzZXRVcmw6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cInJvdGF0ZUNvbnRhaW5lclwiIHN0eWxlPXt0aGlzLmdldFN0eWxlKCl9PlxuICAgICAgICA8ZGl2IGlkPVwicm90YXRlVGV4dFwiPlxuICAgICAgICAgIDxwPnttc2cucm90YXRlVGV4dCgpfTxiciAvPnttc2cub3JpZW50YXRpb25Mb2NrKCl9PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0sXG5cbiAgZ2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKCcgKyB0aGlzLnByb3BzLmFzc2V0VXJsKCdtZWRpYS90dXJucGhvbmVfaG9yaXpvbnRhbC5wbmcnKSArICcpJ1xuICAgIH07XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVDb250YWluZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBkaXYgRE9NIGVsZW1lbnQgdGhhdCB3aWxsIG5ldmVyIHVwZGF0ZSBpdHMgY29udGVudHMgYW5kIHdpbGwgdGhyb3cgYW5cbiAqIGV4Y2VwdGlvbiBpZiBpdCBpcyBldmVyIHVubW91bnRlZCwgZW5mb3JjaW5nIHRoYXQgaXQgbXVzdCBhbHdheXMgYmUgcmVuZGVyZWRcbiAqIGJlY2F1c2UgaXRzIGNvbnRlbnRzIG1heSBjb250YWluIHN0YXRlIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGlzIGRlcGVuZGluZyBvbi5cbiAqXG4gKiBVc2VmdWwgd2hlbiBSZWFjdCBpcyB3cmFwcGluZyBleHRlcm5hbCBsaWJyYXJpZXMgb3IgcGFydHMgb2Ygb3VyIFVJIHRoYXQgYXJlXG4gKiBub3QgeWV0IGRyaXZlbiBieSBSZWFjdC5cbiAqL1xudmFyIFByb3RlY3RlZFN0YXRlZnVsRGl2ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICByZW5kZXJDb250ZW50czogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMucmVuZGVyQ29udGVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmVmcy5yb290LmdldERPTU5vZGUoKS5pbm5lckhUTUwgPSB0aGlzLnByb3BzLnJlbmRlckNvbnRlbnRzKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5tb3VudGluZyBhIFByb3RlY3RlZFN0YXRlZnVsRGl2IGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gPGRpdiB7Li4udGhpcy5wcm9wc30gcmVmPVwicm9vdFwiPjwvZGl2PjtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFByb3RlY3RlZFN0YXRlZnVsRGl2O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcbnZhciByZXF1aXJlZEJsb2NrVXRpbHMgPSByZXF1aXJlKCcuL3JlcXVpcmVkX2Jsb2NrX3V0aWxzJyk7XG52YXIgc3R1ZGlvQXBwID0gcmVxdWlyZSgnLi9TdHVkaW9BcHAnKS5zaW5nbGV0b247XG52YXIgYXV0aG9yZWRIaW50VXRpbHMgPSByZXF1aXJlKCcuL2F1dGhvcmVkSGludFV0aWxzJyk7XG5cbi8vIFRPRE8gKGJyLXBhaXIpIDogVGhpcyBpcyB0byBleHBvc2UgbWV0aG9kcyB3ZSBuZWVkIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4vLyBmb3IgdGVzdGluZyBwdXJwb3NlLiBXb3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzIGV2ZW50dWFsbHkuXG53aW5kb3cuX19UZXN0SW50ZXJmYWNlID0ge1xuICBsb2FkQmxvY2tzOiBfLmJpbmQoc3R1ZGlvQXBwLmxvYWRCbG9ja3MsIHN0dWRpb0FwcCksXG4gIGFycmFuZ2VCbG9ja1Bvc2l0aW9uOiBfLmJpbmQoc3R1ZGlvQXBwLmFycmFuZ2VCbG9ja1Bvc2l0aW9uLCBzdHVkaW9BcHApLFxuICBnZXREcm9wbGV0Q29udGVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXy5iaW5kKHN0dWRpb0FwcC5lZGl0b3IuZ2V0VmFsdWUsIHN0dWRpb0FwcC5lZGl0b3IpKCk7XG4gIH0sXG4gIGdldERyb3BsZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3R1ZGlvQXBwLmVkaXRvcjtcbiAgfSxcbiAgLy8gU2V0IHRvIHRydWUgdG8gaWdub3JlIG9uQmVmb3JlVW5sb2FkIGV2ZW50c1xuICBpZ25vcmVPbkJlZm9yZVVubG9hZDogZmFsc2Vcbn07XG5cbnZhciBhZGRSZWFkeUxpc3RlbmVyID0gcmVxdWlyZSgnLi9kb20nKS5hZGRSZWFkeUxpc3RlbmVyO1xudmFyIGJsb2Nrc0NvbW1vbiA9IHJlcXVpcmUoJy4vYmxvY2tzQ29tbW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwLCBsZXZlbHMsIG9wdGlvbnMpIHtcblxuICAvLyBJZiBhIGxldmVsSWQgaXMgbm90IHByb3ZpZGVkLCB0aGVuIG9wdGlvbnMubGV2ZWwgaXMgc3BlY2lmaWVkIGluIGZ1bGwuXG4gIC8vIE90aGVyd2lzZSwgb3B0aW9ucy5sZXZlbCBvdmVycmlkZXMgcmVzb2x2ZWQgbGV2ZWwgb24gYSBwZXItcHJvcGVydHkgYmFzaXMuXG4gIGlmIChvcHRpb25zLmxldmVsSWQpIHtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbb3B0aW9ucy5sZXZlbElkXTtcbiAgICBvcHRpb25zLmxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCB7fTtcbiAgICBvcHRpb25zLmxldmVsLmlkID0gb3B0aW9ucy5sZXZlbElkO1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucy5sZXZlbCkge1xuICAgICAgbGV2ZWxbcHJvcF0gPSBvcHRpb25zLmxldmVsW3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxldmVsLmxldmVsQnVpbGRlclJlcXVpcmVkQmxvY2tzKSB7XG4gICAgICBsZXZlbC5yZXF1aXJlZEJsb2NrcyA9IHJlcXVpcmVkQmxvY2tVdGlscy5tYWtlVGVzdHNGcm9tQnVpbGRlclJlcXVpcmVkQmxvY2tzKFxuICAgICAgICAgIG9wdGlvbnMubGV2ZWwubGV2ZWxCdWlsZGVyUmVxdWlyZWRCbG9ja3MpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZXZlbC5sZXZlbEJ1aWxkZXJSZWNvbW1lbmRlZEJsb2Nrcykge1xuICAgICAgbGV2ZWwucmVjb21tZW5kZWRCbG9ja3MgPSByZXF1aXJlZEJsb2NrVXRpbHMubWFrZVRlc3RzRnJvbUJ1aWxkZXJSZXF1aXJlZEJsb2NrcyhcbiAgICAgICAgICBvcHRpb25zLmxldmVsLmxldmVsQnVpbGRlclJlY29tbWVuZGVkQmxvY2tzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sZXZlbC5hdXRob3JlZEhpbnRzKSB7XG4gICAgICBsZXZlbC5hdXRob3JlZEhpbnRzID0gYXV0aG9yZWRIaW50VXRpbHMuZ2VuZXJhdGVBdXRob3JlZEhpbnRzKG9wdGlvbnMubGV2ZWwuYXV0aG9yZWRIaW50cyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgc3R1ZGlvQXBwLmNvbmZpZ3VyZShvcHRpb25zKTtcblxuICBvcHRpb25zLnNraW4gPSBvcHRpb25zLnNraW5zTW9kdWxlLmxvYWQoc3R1ZGlvQXBwLmFzc2V0VXJsLCBvcHRpb25zLnNraW5JZCk7XG5cbiAgaWYgKHN0dWRpb0FwcC5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgdmFyIGJsb2NrSW5zdGFsbE9wdGlvbnMgPSB7XG4gICAgICBza2luOiBvcHRpb25zLnNraW4sXG4gICAgICBpc0sxOiBvcHRpb25zLmxldmVsICYmIG9wdGlvbnMubGV2ZWwuaXNLMSxcbiAgICAgIGxldmVsOiBvcHRpb25zLmxldmVsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmxldmVsICYmIG9wdGlvbnMubGV2ZWwuZWRpdF9ibG9ja3MpIHtcbiAgICAgIHV0aWxzLndyYXBOdW1iZXJWYWxpZGF0b3JzRm9yTGV2ZWxCdWlsZGVyKCk7XG4gICAgfVxuXG4gICAgYmxvY2tzQ29tbW9uLmluc3RhbGwoQmxvY2tseSwgYmxvY2tJbnN0YWxsT3B0aW9ucyk7XG4gICAgb3B0aW9ucy5ibG9ja3NNb2R1bGUuaW5zdGFsbChCbG9ja2x5LCBibG9ja0luc3RhbGxPcHRpb25zKTtcbiAgfVxuXG4gIGFkZFJlYWR5TGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZG9ubHkpIHtcbiAgICAgIGlmIChhcHAuaW5pdFJlYWRvbmx5KSB7XG4gICAgICAgIGFwcC5pbml0UmVhZG9ubHkob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHVkaW9BcHAuaW5pdFJlYWRvbmx5KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcHAuaW5pdChvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm9uSW5pdGlhbGl6ZSkge1xuICAgICAgICBvcHRpb25zLm9uSW5pdGlhbGl6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwiLyogZ2xvYmFsIFRleHQgKi9cblxudmFyIHhtbCA9IHJlcXVpcmUoJy4veG1sJyk7XG52YXIgYmxvY2tVdGlscyA9IHJlcXVpcmUoJy4vYmxvY2tfdXRpbHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHRleHR1YWwgWE1MIGZvciBhIG1hdGhfbnVtYmVyIGJsb2NrLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgVGhlIG51bWVyaWMgYW1vdW50LCBleHByZXNzZWQgYXMgYVxuICogICAgIG51bWJlciBvciBzdHJpbmcuICBOb24tbnVtZXJpYyBzdHJpbmdzIG1heSBhbHNvIGJlIHNwZWNpZmllZCxcbiAqICAgICBzdWNoIGFzICc/Pz8nLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBhIG1hdGhfbnVtYmVyIGJsb2NrLlxuICovXG5leHBvcnRzLm1ha2VNYXRoTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gIHJldHVybiAnPGJsb2NrIHR5cGU9XCJtYXRoX251bWJlclwiPjx0aXRsZSBuYW1lPVwiTlVNXCI+JyArXG4gICAgbnVtYmVyICsgJzwvdGl0bGU+PC9ibG9jaz4nO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGZvciBhIHNpbXBsZSBibG9jayB0aGF0IGRvZXMgbm90XG4gKiBoYXZlIGFueSBwYXJhbWV0ZXJzIG9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja190eXBlIFRoZSBibG9jayB0eXBlLlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMuc2ltcGxlQmxvY2sgPSBmdW5jdGlvbihibG9ja190eXBlKSB7XG4gIHJldHVybiB7dGVzdDogZnVuY3Rpb24oYmxvY2spIHtyZXR1cm4gYmxvY2sudHlwZSA9PSBibG9ja190eXBlOyB9LFxuICAgIHR5cGU6IGJsb2NrX3R5cGV9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGZvciBhIHJlcGVhdCBsb29wLiAgVGhpcyBkb2VzIG5vdFxuICogdGVzdCBmb3IgdGhlIHNwZWNpZmllZCByZXBlYXQgY291bnQgYnV0IGluY2x1ZGVzIGl0IGluIHRoZSBzdWdnZXN0ZWQgYmxvY2suXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvdW50IFRoZSBzdWdnZXN0ZWQgcmVwZWF0IGNvdW50LlxuICogQHJldHVybiB7T2JqZWN0fSBBIHJlcXVpcmVkIGJsb2NrcyBkaWN0aW9uYXJ5IGFibGUgdG8gY2hlY2sgZm9yIGFuZFxuICogICAgIGdlbmVyYXRlIHRoZSBzcGVjaWZpZWQgYmxvY2suXG4gKi9cbmV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVGhpcyBjaGVja3MgZm9yIGEgY29udHJvbHNfcmVwZWF0IGJsb2NrIHJhdGhlciB0aGFuIGxvb2tpbmcgZm9yICdmb3InLFxuICAvLyBzaW5jZSB0aGUgbGF0dGVyIG1heSBiZSBnZW5lcmF0ZWQgYnkgVHVydGxlIDIncyBkcmF3X2Ffc3F1YXJlLlxuICByZXR1cm4ge3Rlc3Q6IGZ1bmN0aW9uKGJsb2NrKSB7cmV0dXJuIGJsb2NrLnR5cGUgPT0gJ2NvbnRyb2xzX3JlcGVhdCc7fSxcbiAgICB0eXBlOiAnY29udHJvbHNfcmVwZWF0JywgdGl0bGVzOiB7J1RJTUVTJzogY291bnR9fTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByZXF1aXJlZCBibG9ja3MgZGljdGlvbmFyeSBmb3IgYSBzaW1wbGUgcmVwZWF0IGxvb3AuICBUaGlzIGRvZXMgbm90XG4gKiB0ZXN0IGZvciB0aGUgc3BlY2lmaWVkIHJlcGVhdCBjb3VudCBidXQgaW5jbHVkZXMgaXQgaW4gdGhlIHN1Z2dlc3RlZCBibG9jay5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gY291bnQgVGhlIHN1Z2dlc3RlZCByZXBlYXQgY291bnQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVxdWlyZWQgYmxvY2tzIGRpY3Rpb25hcnkgYWJsZSB0byBjaGVjayBmb3IgYW5kXG4gKiAgICAgZ2VuZXJhdGUgdGhlIHNwZWNpZmllZCBibG9jay5cbiAqL1xuZXhwb3J0cy5yZXBlYXRTaW1wbGVCbG9jayA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHJldHVybiB7dGVzdDogZnVuY3Rpb24oYmxvY2spIHtyZXR1cm4gYmxvY2sudHlwZSA9PSAnY29udHJvbHNfcmVwZWF0X3NpbXBsaWZpZWQnO30sXG4gICAgdHlwZTogJ2NvbnRyb2xzX3JlcGVhdF9zaW1wbGlmaWVkJywgdGl0bGVzOiB7J1RJTUVTJzogY291bnR9fTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlZCBibG9ja3MgYnkgY29tcGFyaW5nIGEgbGlzdCBvZiBibG9ja3Mgd2l0aFxuICogYSBsaXN0IG9mIGFwcCBzcGVjaWZpYyBibG9jayB0ZXN0cyAoZGVmaW5lZCBpbiA8YXBwPi9yZXF1aXJlZEJsb2Nrcy5qcylcbiAqL1xuZXhwb3J0cy5tYWtlVGVzdHNGcm9tQnVpbGRlclJlcXVpcmVkQmxvY2tzID0gZnVuY3Rpb24gKGN1c3RvbVJlcXVpcmVkQmxvY2tzKSB7XG4gIHZhciBibG9ja3NYbWwgPSB4bWwucGFyc2VFbGVtZW50KGN1c3RvbVJlcXVpcmVkQmxvY2tzKTtcblxuICB2YXIgcmVxdWlyZWRCbG9ja3NUZXN0cyA9IFtdO1xuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGJsb2Nrc1htbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAvLyBPbmx5IGxvb2sgYXQgZWxlbWVudCBub2Rlc1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykpIHtcbiAgICAgIGNhc2UgJ3BpY2tfb25lJzpcbiAgICAgICAgcmVxdWlyZWRCbG9ja3NUZXN0cy5wdXNoKHRlc3RzRnJvbVBpY2tPbmUoY2hpbGROb2RlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHJvY2VkdXJlc19kZWZub3JldHVybic6XG4gICAgICBjYXNlICdwcm9jZWR1cmVzX2RlZnJldHVybic6XG4gICAgICAgIHJlcXVpcmVkQmxvY2tzVGVzdHMucHVzaCh0ZXN0c0Zyb21Qcm9jZWR1cmUoY2hpbGROb2RlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb25hbF9kZWZpbml0aW9uJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdW5jdGlvbmFsX2NhbGwnOlxuICAgICAgICByZXF1aXJlZEJsb2Nrc1Rlc3RzLnB1c2godGVzdHNGcm9tRnVuY3Rpb25hbENhbGwoY2hpbGROb2RlLCBibG9ja3NYbWwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXF1aXJlZEJsb2Nrc1Rlc3RzLnB1c2goW3Rlc3RGcm9tQmxvY2soY2hpbGROb2RlKV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlcXVpcmVkQmxvY2tzVGVzdHM7XG59O1xuXG4vKipcbiAqIEdpdmVuIHhtbCBmb3IgYSBzaW5nbGUgYmxvY2sgZ2VuZXJhdGVzIGEgYmxvY2sgdGVzdFxuICovXG5mdW5jdGlvbiB0ZXN0RnJvbUJsb2NrIChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgdGVzdDogZnVuY3Rpb24odXNlckJsb2NrKSB7XG4gICAgICAvLyBFbmNvZGUgdXNlckJsb2NrIHdoaWxlIGlnbm9yaW5nIGNoaWxkIHN0YXRlbWVudHNcbiAgICAgIHZhciB1c2VyRWxlbWVudCA9IEJsb2NrbHkuWG1sLmJsb2NrVG9Eb20odXNlckJsb2NrLCB0cnVlKTtcbiAgICAgIHJldHVybiBlbGVtZW50c0VxdWl2YWxlbnQobm9kZSwgdXNlckVsZW1lbnQpO1xuICAgIH0sXG4gICAgYmxvY2tEaXNwbGF5WE1MOiB4bWwuc2VyaWFsaXplKG5vZGUpXG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4geG1sIGZvciBhIHBpY2tfb25lIGJsb2NrLCBnZW5lcmF0ZXMgYSB0ZXN0IHRoYXQgY2hlY2tzIHRoYXQgYXQgbGVhc3RcbiAqIG9uZSBvZiB0aGUgY2hpbGQgYmxvY2tzIGlzIHVzZWQuICBJZiBub25lIGFyZSB1c2VkLCB0aGUgZmlyc3Qgb3B0aW9uIHdpbGwgYmVcbiAqIGRpc3BsYXllZCBhcyBmZWVkYmFja1xuICovXG5mdW5jdGlvbiB0ZXN0c0Zyb21QaWNrT25lKG5vZGUpIHtcbiAgdmFyIHRlc3RzID0gW107XG4gIC8vIGNoaWxkIG9mIHBpY2tfb25lIGlzIGEgc3RhdGVtZW50IGJsb2NrLiAgd2Ugd2FudCBmaXJzdCBjaGlsZCBvZiB0aGF0XG4gIHZhciBzdGF0ZW1lbnQgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdGF0ZW1lbnQnKVswXTtcbiAgdmFyIGJsb2NrID0gc3RhdGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdibG9jaycpWzBdO1xuICB2YXIgbmV4dDtcbiAgZG8ge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBuZXh0IGJsb2NrLCB3ZSB3YW50IHRvIGdlbmVyYXRlIG91ciB0ZXN0IHdpdGhvdXQgdGhhdFxuICAgIG5leHQgPSBibG9jay5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbmV4dCcpWzBdO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICBibG9jay5yZW1vdmVDaGlsZChuZXh0KTtcbiAgICB9XG4gICAgdGVzdHMucHVzaCh0ZXN0RnJvbUJsb2NrKGJsb2NrKSk7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGJsb2NrID0gbmV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmxvY2snKVswXTtcbiAgICB9XG4gIH0gd2hpbGUgKG5leHQpO1xuICByZXR1cm4gdGVzdHM7XG59XG5cbi8qKlxuICogR2l2ZW4geG1sIGZvciBhIHByb2NlZHVyZSBibG9jaywgZ2VuZXJhdGVzIHRlc3RzIHRoYXQgY2hlY2sgZm9yIHJlcXVpcmVkXG4gKiBudW1iZXIgb2YgcGFyYW1zIG5vdCBkZWNsYXJlZFxuICovXG5mdW5jdGlvbiB0ZXN0c0Zyb21Qcm9jZWR1cmUobm9kZSkge1xuICB2YXIgcGFyYW1Db3VudCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnbXV0YXRpb24gPiBhcmcnKS5sZW5ndGg7XG4gIHZhciBlbXB0eUJsb2NrID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gIGVtcHR5QmxvY2sucmVtb3ZlQ2hpbGQoZW1wdHlCbG9jay5sYXN0Q2hpbGQpO1xuICByZXR1cm4gW3tcbiAgICAvLyBFbnN1cmUgdGhhdCBhbGwgcmVxdWlyZWQgYmxvY2tzIG1hdGNoIGEgYmxvY2sgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2ZcbiAgICAvLyBwYXJhbXMuIFRoZXJlJ3Mgbm8gZ3VhcmFudGVlIHVzZXJzIHdpbGwgbmFtZSB0aGVpciBmdW5jdGlvbiB0aGUgc2FtZSBhc1xuICAgIC8vIHRoZSByZXF1aXJlZCBibG9jaywgc28gb25seSBtYXRjaCBvbiBudW1iZXIgb2YgcGFyYW1zLlxuICAgIHRlc3Q6IGZ1bmN0aW9uKHVzZXJCbG9jaykge1xuICAgICAgaWYgKHVzZXJCbG9jay50eXBlID09PSBub2RlLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICAgIHJldHVybiBwYXJhbUNvdW50ID09PSB1c2VyQmxvY2sucGFyYW1ldGVyTmFtZXNfLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIC8vIEJsb2NrIGlzbid0IHRoZSBzYW1lIHR5cGUsIHJldHVybiBmYWxzZSB0byBrZWVwIHNlYXJjaGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG1lc3NhZ2U6IG1zZy5lcnJvclJlcXVpcmVkUGFyYW1zTWlzc2luZygpLFxuICAgIGJsb2NrRGlzcGxheVhNTDogJzx4bWw+PC94bWw+J1xuICB9XTtcbn1cblxuZnVuY3Rpb24gdGVzdHNGcm9tRnVuY3Rpb25hbENhbGwobm9kZSwgYmxvY2tzWG1sKSB7XG4gIHZhciBuYW1lID0gbm9kZS5xdWVyeVNlbGVjdG9yKCdtdXRhdGlvbicpLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICB2YXIgYXJnRWxlbWVudHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2FyZycpO1xuICB2YXIgdHlwZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHR5cGVzLnB1c2goYXJnRWxlbWVudHNbaV0uZ2V0QXR0cmlidXRlKCd0eXBlJykpO1xuICB9XG5cbiAgdmFyIGRlZmluaXRpb24gPSBfLmZpbmQoYmxvY2tzWG1sLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgaWYgKHNpYmxpbmcuZ2V0QXR0cmlidXRlKCd0eXBlJykgIT09ICdmdW5jdGlvbmFsX2RlZmluaXRpb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBuYW1lRWxlbWVudCA9IHNpYmxpbmcucXVlcnlTZWxlY3RvcigndGl0bGVbbmFtZT1cIk5BTUVcIl0nKTtcbiAgICBpZiAoIW5hbWVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuYW1lRWxlbWVudC50ZXh0Q29udGVudCA9PT0gbmFtZTtcbiAgfSk7XG5cbiAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtYXRjaGluZyBkZWZpbml0aW9uIGZvciBmdW5jdGlvbmFsX2NhbGwnKTtcbiAgfVxuXG4gIHJldHVybiBbe1xuICAgIHRlc3Q6IGZ1bmN0aW9uICh1c2VyQmxvY2spIHtcbiAgICAgIGlmICh1c2VyQmxvY2sudHlwZSAhPT0gJ2Z1bmN0aW9uYWxfY2FsbCcgfHxcbiAgICAgICAgICB1c2VyQmxvY2suZ2V0Q2FsbE5hbWUoKSAhPT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdXNlclR5cGVzID0gdXNlckJsb2NrLmdldFBhcmFtVHlwZXMoKTtcbiAgICAgIHJldHVybiBfLmlzRXF1YWwodXNlclR5cGVzLCB0eXBlcyk7XG4gICAgfSxcbiAgICBibG9ja0Rpc3BsYXlYTUw6IHhtbC5zZXJpYWxpemUoZGVmaW5pdGlvbikgKyB4bWwuc2VyaWFsaXplKG5vZGUpXG4gIH1dO1xuXG59XG5cbi8qKlxuICogQ2hlY2tzIHR3byBET00gZWxlbWVudHMgdG8gc2VlIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGVxdWl2YWxlbnRcbiAqIFdlIGNvbnNpZGVyIHRoZW0gZXF1aXZhbGVudCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdGFnTmFtZSwgYXR0cmlidXRlcyxcbiAqIGFuZCBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBlbGVtZW50c0VxdWl2YWxlbnQoZXhwZWN0ZWQsIGdpdmVuKSB7XG4gIGlmICghKGV4cGVjdGVkIGluc3RhbmNlb2YgRWxlbWVudCAmJiBnaXZlbiBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgLy8gaWYgd2UgZXhwZWN0ID8/PywgYWxsb3cgbWF0Y2ggd2l0aCBhbnl0aGluZ1xuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFRleHQgJiYgZXhwZWN0ZWQudGV4dENvbnRlbnQgPT09ICc/Pz8nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdGVkLmlzRXF1YWxOb2RlKGdpdmVuKTtcbiAgfVxuICAvLyBOb3QgZnVsbHkgY2xlYXIgdG8gbWUgd2h5LCBidXQgYmxvY2tUb0RvbSBzZWVtcyB0byByZXR1cm4gdXMgYW4gZWxlbWVudFxuICAvLyB3aXRoIGEgdGFnTmFtZSBpbiBhbGwgY2Fwc1xuICBpZiAoZXhwZWN0ZWQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBnaXZlbi50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWF0dHJpYnV0ZXNFcXVpdmFsZW50KGV4cGVjdGVkLCBnaXZlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNoaWxkcmVuRXF1aXZhbGVudChleHBlY3RlZCwgZ2l2ZW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGF0dHJpYnV0ZXMgd2Ugd2FudCB0byBpZ25vcmUgd2hlbiBjb21wYXJpbmcgYXR0cmlidXRlcywgYW5kIGFcbiAqIGZ1bmN0aW9uIGZvciBlYXNpbHkgZGV0ZXJtaW5pbmcgd2hldGhlciBhbiBhdHRyaWJ1dGUgaXMgaW4gdGhlIGxpc3QuXG4gKi9cbnZhciBpZ25vcmFibGVBdHRyaWJ1dGVzID0gW1xuICAnZGVsZXRhYmxlJyxcbiAgJ21vdmFibGUnLFxuICAnZWRpdGFibGUnLFxuICAnaW5saW5lJyxcbiAgJ3VzZXJ2aXNpYmxlJyxcbiAgJ3VzZXJjcmVhdGVkJyxcbiAgJ2lkJ1xuXTtcblxuaWdub3JhYmxlQXR0cmlidXRlcy5jb250YWlucyA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gIHJldHVybiBpZ25vcmFibGVBdHRyaWJ1dGVzLmluZGV4T2YoYXR0ci5uYW1lKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBhdHRyaWJ1dGVzIGZvciB0d28gZGlmZmVyZW50IGVsZW1lbnRzIGFyZSBlcXVpdmFsZW50XG4gKi9cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNFcXVpdmFsZW50KGV4cGVjdGVkLCBnaXZlbikge1xuICB2YXIgYXR0cmlidXRlczEgPSBfLnJlamVjdChleHBlY3RlZC5hdHRyaWJ1dGVzLCBpZ25vcmFibGVBdHRyaWJ1dGVzLmNvbnRhaW5zKTtcbiAgdmFyIGF0dHJpYnV0ZXMyID0gXy5yZWplY3QoZ2l2ZW4uYXR0cmlidXRlcywgaWdub3JhYmxlQXR0cmlidXRlcy5jb250YWlucyk7XG4gIGlmIChhdHRyaWJ1dGVzMS5sZW5ndGggIT09IGF0dHJpYnV0ZXMyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIxID0gYXR0cmlidXRlczFbaV07XG4gICAgdmFyIGF0dHIyID0gYXR0cmlidXRlczJbaV07XG4gICAgaWYgKGF0dHIxLm5hbWUgIT09IGF0dHIyLm5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGF0dHIxLnZhbHVlICE9PSBhdHRyMi52YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY2hpbGRyZW4gb2YgdHdvIGRpZmZlcmVudCBlbGVtZW50cyBhcmUgZXF1aXZhbGVudFxuICovXG5mdW5jdGlvbiBjaGlsZHJlbkVxdWl2YWxlbnQoZXhwZWN0ZWQsIGdpdmVuKSB7XG4gIHZhciBjaGlsZHJlbjEgPSBleHBlY3RlZC5jaGlsZE5vZGVzO1xuICB2YXIgY2hpbGRyZW4yID0gZ2l2ZW4uY2hpbGROb2RlcztcbiAgaWYgKGNoaWxkcmVuMS5sZW5ndGggIT09IGNoaWxkcmVuMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbjEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWVsZW1lbnRzRXF1aXZhbGVudChjaGlsZHJlbjFbaV0sIGNoaWxkcmVuMltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBibG9ja3MgYXJlIFwiZXF1aXZhbGVudFwiXG4gKiBDdXJyZW50bHkgbWVhbnMgdGhlaXIgdHlwZSBhbmQgYWxsIG9mIHRoZWlyIHRpdGxlcyBtYXRjaCBleGFjdGx5XG4gKiBAcGFyYW0gYmxvY2tBXG4gKiBAcGFyYW0gYmxvY2tCXG4gKi9cbmV4cG9ydHMuYmxvY2tzTWF0Y2ggPSBmdW5jdGlvbihibG9ja0EsIGJsb2NrQikge1xuICB2YXIgdHlwZXNNYXRjaCA9IGJsb2NrQS50eXBlID09PSBibG9ja0IudHlwZTtcbiAgdmFyIHRpdGxlc01hdGNoID0gZXhwb3J0cy5ibG9ja1RpdGxlc01hdGNoKGJsb2NrQSwgYmxvY2tCKTtcbiAgcmV0dXJuIHR5cGVzTWF0Y2ggJiYgdGl0bGVzTWF0Y2g7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBibG9ja3MnIHRpdGxlcywgcmV0dXJucyB0cnVlIGlmIHRoZXkgYWxsIG1hdGNoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwYXJhbSBibG9ja0FcbiAqIEBwYXJhbSBibG9ja0JcbiAqL1xuZXhwb3J0cy5ibG9ja1RpdGxlc01hdGNoID0gZnVuY3Rpb24oYmxvY2tBLCBibG9ja0IpIHtcbiAgdmFyIGJsb2NrQVRpdGxlcyA9IGJsb2NrQS5nZXRUaXRsZXMoKTtcbiAgdmFyIGJsb2NrQlRpdGxlcyA9IGJsb2NrQi5nZXRUaXRsZXMoKTtcblxuICB2YXIgbmFtZUNvbXBhcmUgPSBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEubmFtZSA8IGIubmFtZTsgfTtcbiAgYmxvY2tBVGl0bGVzLnNvcnQobmFtZUNvbXBhcmUpO1xuICBibG9ja0JUaXRsZXMuc29ydChuYW1lQ29tcGFyZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja0FUaXRsZXMubGVuZ3RoIHx8IGkgPCBibG9ja0JUaXRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmxvY2tBVGl0bGUgPSBibG9ja0FUaXRsZXNbaV07XG4gICAgdmFyIGJsb2NrQlRpdGxlID0gYmxvY2tCVGl0bGVzW2ldO1xuICAgIGlmICghYmxvY2tBVGl0bGUgfHwgIWJsb2NrQlRpdGxlIHx8XG4gICAgICAhdGl0bGVzTWF0Y2goYmxvY2tBVGl0bGUsIGJsb2NrQlRpdGxlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB0aXRsZXNNYXRjaCA9IGZ1bmN0aW9uKHRpdGxlQSwgdGl0bGVCKSB7XG4gIHJldHVybiB0aXRsZUIubmFtZSA9PT0gdGl0bGVBLm5hbWUgJiZcbiAgICB0aXRsZUIuZ2V0VmFsdWUoKSA9PT0gdGl0bGVBLmdldFZhbHVlKCk7XG59O1xuIiwiLyoqXG4gKiBEZWZpbmVzIGJsb2NrcyB1c2VmdWwgaW4gbXVsdGlwbGUgYmxvY2tseSBhcHBzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbk1zZyA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG5cbi8qKlxuICogSW5zdGFsbCBleHRlbnNpb25zIHRvIEJsb2NrbHkncyBsYW5ndWFnZSBhbmQgSmF2YVNjcmlwdCBnZW5lcmF0b3JcbiAqIEBwYXJhbSBibG9ja2x5IGluc3RhbmNlIG9mIEJsb2NrbHlcbiAqL1xuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24oYmxvY2tseSwgYmxvY2tJbnN0YWxsT3B0aW9ucykge1xuICB2YXIgc2tpbiA9IGJsb2NrSW5zdGFsbE9wdGlvbnMuc2tpbjtcbiAgdmFyIGlzSzEgPSBibG9ja0luc3RhbGxPcHRpb25zLmlzSzE7XG5cbiAgaW5zdGFsbENvbnRyb2xzUmVwZWF0U2ltcGxpZmllZChibG9ja2x5LCBza2luKTtcbiAgaW5zdGFsbENvbnRyb2xzUmVwZWF0RHJvcGRvd24oYmxvY2tseSk7XG4gIGluc3RhbGxOdW1iZXJEcm9wZG93bihibG9ja2x5KTtcbiAgaW5zdGFsbFBpY2tPbmUoYmxvY2tseSk7XG4gIGluc3RhbGxDYXRlZ29yeShibG9ja2x5KTtcbiAgaW5zdGFsbFdoZW5SdW4oYmxvY2tseSwgc2tpbiwgaXNLMSk7XG59O1xuXG5mdW5jdGlvbiBpbnN0YWxsQ29udHJvbHNSZXBlYXRTaW1wbGlmaWVkKGJsb2NrbHksIHNraW4pIHtcbiAgLy8gUmUtdXNlcyB0aGUgcmVwZWF0IGJsb2NrIGdlbmVyYXRvciBmcm9tIGNvcmVcbiAgYmxvY2tseS5KYXZhU2NyaXB0LmNvbnRyb2xzX3JlcGVhdF9zaW1wbGlmaWVkID0gYmxvY2tseS5KYXZhU2NyaXB0LmNvbnRyb2xzX3JlcGVhdDtcbiAgYmxvY2tseS5KYXZhU2NyaXB0LmNvbnRyb2xzX3JlcGVhdF9zaW1wbGlmaWVkX2Ryb3Bkb3duID0gYmxvY2tseS5KYXZhU2NyaXB0LmNvbnRyb2xzX3JlcGVhdDtcblxuICBibG9ja2x5LkJsb2Nrcy5jb250cm9sc19yZXBlYXRfc2ltcGxpZmllZCA9IHtcbiAgICAvLyBSZXBlYXQgbiB0aW1lcyAoaW50ZXJuYWwgbnVtYmVyKSB3aXRoIHNpbXBsaWZpZWQgVUlcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNldEhlbHBVcmwoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX0hFTFBVUkwpO1xuICAgICAgdGhpcy5zZXRIU1YoMzIyLCAwLjkwLCAwLjk1KTtcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZShibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVElUTEVfUkVQRUFUKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGRUZXh0SW5wdXQoJzEwJywgYmxvY2tseS5GaWVsZFRleHRJbnB1dC5ub25uZWdhdGl2ZUludGVnZXJWYWxpZGF0b3IpLCAnVElNRVMnKTtcbiAgICAgIHRoaXMuYXBwZW5kU3RhdGVtZW50SW5wdXQoJ0RPJylcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkSW1hZ2Uoc2tpbi5yZXBlYXRJbWFnZSkpO1xuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0TmV4dFN0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0VG9vbHRpcChibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVE9PTFRJUCk7XG4gICAgfVxuICB9O1xuXG4gIGJsb2NrbHkuQmxvY2tzLmNvbnRyb2xzX3JlcGVhdF9zaW1wbGlmaWVkX2Ryb3Bkb3duID0ge1xuICAgIC8vIFJlcGVhdCBuIHRpbWVzIChpbnRlcm5hbCBudW1iZXIpIHdpdGggc2ltcGxpZmllZCBVSVxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2V0SGVscFVybChibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfSEVMUFVSTCk7XG4gICAgICB0aGlzLnNldEhTVigzMjIsIDAuOTAsIDAuOTUpO1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgLmFwcGVuZFRpdGxlKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9USVRMRV9SRVBFQVQpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgYmxvY2tseS5GaWVsZERyb3Bkb3duKCksICdUSU1FUycpO1xuICAgICAgdGhpcy5hcHBlbmRTdGF0ZW1lbnRJbnB1dCgnRE8nKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGRJbWFnZShza2luLnJlcGVhdEltYWdlKSk7XG4gICAgICB0aGlzLnNldFByZXZpb3VzU3RhdGVtZW50KHRydWUpO1xuICAgICAgdGhpcy5zZXROZXh0U3RhdGVtZW50KHRydWUpO1xuICAgICAgdGhpcy5zZXRUb29sdGlwKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9UT09MVElQKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb250cm9sc1JlcGVhdERyb3Bkb3duKGJsb2NrbHkpIHtcbiAgYmxvY2tseS5KYXZhU2NyaXB0LmNvbnRyb2xzX3JlcGVhdF9kcm9wZG93biA9IGJsb2NrbHkuSmF2YVNjcmlwdC5jb250cm9sc19yZXBlYXQ7XG5cbiAgYmxvY2tseS5CbG9ja3MuY29udHJvbHNfcmVwZWF0X2Ryb3Bkb3duID0ge1xuICAgIC8vIFJlcGVhdCBuIHRpbWVzIChpbnRlcm5hbCBudW1iZXIpIHdpdGggYSBjdXN0b21pemFibGUgZHJvcGRvd24gb2YgIyBjaG9pY2VzLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIZWxwVXJsKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9IRUxQVVJMKTtcbiAgICAgIHRoaXMuc2V0SFNWKDMyMiwgMC45MCwgMC45NSk7XG4gICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAuYXBwZW5kVGl0bGUoYmxvY2tseS5Nc2cuQ09OVFJPTFNfUkVQRUFUX1RJVExFX1JFUEVBVClcbiAgICAgICAgLmFwcGVuZFRpdGxlKG5ldyBibG9ja2x5LkZpZWxkRHJvcGRvd24oKSwgJ1RJTUVTJylcbiAgICAgICAgLmFwcGVuZFRpdGxlKGJsb2NrbHkuTXNnLkNPTlRST0xTX1JFUEVBVF9USVRMRV9USU1FUyk7XG4gICAgICB0aGlzLmFwcGVuZFN0YXRlbWVudElucHV0KCdETycpXG4gICAgICAgIC5hcHBlbmRUaXRsZShibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfSU5QVVRfRE8pO1xuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0TmV4dFN0YXRlbWVudCh0cnVlKTtcbiAgICAgIHRoaXMuc2V0VG9vbHRpcChibG9ja2x5Lk1zZy5DT05UUk9MU19SRVBFQVRfVE9PTFRJUCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsTnVtYmVyRHJvcGRvd24oYmxvY2tseSkge1xuICBibG9ja2x5LkphdmFTY3JpcHQubWF0aF9udW1iZXJfZHJvcGRvd24gPSBibG9ja2x5LkphdmFTY3JpcHQubWF0aF9udW1iZXI7XG5cbiAgYmxvY2tseS5CbG9ja3MubWF0aF9udW1iZXJfZHJvcGRvd24gPSB7XG4gICAgLy8gTnVtZXJpYyB2YWx1ZSB3aXRoIGEgY3VzdG9taXphYmxlIGRyb3Bkb3duLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIZWxwVXJsKGJsb2NrbHkuTXNnLk1BVEhfTlVNQkVSX0hFTFBVUkwpO1xuICAgICAgdGhpcy5zZXRIU1YoMjU4LCAwLjM1LCAwLjYyKTtcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZShuZXcgYmxvY2tseS5GaWVsZERyb3Bkb3duKCksICdOVU0nKTtcbiAgICAgIHRoaXMuc2V0T3V0cHV0KHRydWUsIEJsb2NrbHkuQmxvY2tWYWx1ZVR5cGUuTlVNQkVSKTtcbiAgICAgIHRoaXMuc2V0VG9vbHRpcChibG9ja2x5Lk1zZy5NQVRIX05VTUJFUl9UT09MVElQKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIEEgXCJQaWNrIDFcIiBibG9jayBmb3IgbGV2ZWwgZWRpdGluZywgd2hlcmUgeW91IHdhbnQgdG8gcmVxdWlyZSB0aGF0IG9uZSBvZiBhXG4vLyBzZXQgb2YgYmxvY2tzIGlzIHVzZWQuXG5mdW5jdGlvbiBpbnN0YWxsUGlja09uZShibG9ja2x5KSB7XG4gIGJsb2NrbHkuQmxvY2tzLnBpY2tfb25lID0ge1xuICAgIC8vIFJlcGVhdCBuIHRpbWVzIChpbnRlcm5hbCBudW1iZXIpLlxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIU1YoMzIyLCAwLjkwLCAwLjk1KTtcblxuICAgICAgLy8gTm90IGxvY2FsaXplZCBhcyB0aGlzIGlzIG9ubHkgdXNlZCBieSBsZXZlbCBidWlsZGVyc1xuICAgICAgdGhpcy5hcHBlbmREdW1teUlucHV0KClcbiAgICAgICAgICAuYXBwZW5kVGl0bGUoJ1BpY2sgb25lIChVc2Ugb25seSBpbiByZXF1aXJlZCBibG9ja3MpJyk7XG4gICAgICB0aGlzLmFwcGVuZFN0YXRlbWVudElucHV0KCdQSUNLJyk7XG4gICAgfVxuICB9O1xuXG4gIGJsb2NrbHkuSmF2YVNjcmlwdC5waWNrX29uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1xcbic7XG4gIH07XG59XG5cbi8vIEEgXCJDYXRlZ29yeVwiIGJsb2NrIGZvciBsZXZlbCBlZGl0aW5nLCBmb3IgZGVsaW5lYXRpbmcgY2F0ZWdvcnkgZ3JvdXBzLlxuZnVuY3Rpb24gaW5zdGFsbENhdGVnb3J5KGJsb2NrbHkpIHtcbiAgYmxvY2tseS5CbG9ja3MuY2F0ZWdvcnkgPSB7XG4gICAgLy8gUmVwZWF0IG4gdGltZXMgKGludGVybmFsIG51bWJlcikuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEhTVigzMjIsIDAuOTAsIDAuOTUpO1xuICAgICAgdGhpcy5zZXRJbnB1dHNJbmxpbmUodHJ1ZSk7XG5cbiAgICAgIC8vIE5vdCBsb2NhbGl6ZWQgYXMgdGhpcyBpcyBvbmx5IHVzZWQgYnkgbGV2ZWwgYnVpbGRlcnNcbiAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpXG4gICAgICAgIC5hcHBlbmRUaXRsZSgnQ2F0ZWdvcnknKVxuICAgICAgICAuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGRUZXh0SW5wdXQoJ05hbWUnKSwgJ0NBVEVHT1JZJyk7XG4gICAgICB0aGlzLnNldFByZXZpb3VzU3RhdGVtZW50KGZhbHNlKTtcbiAgICAgIHRoaXMuc2V0TmV4dFN0YXRlbWVudChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGJsb2NrbHkuSmF2YVNjcmlwdC5jYXRlZ29yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1xcbic7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxXaGVuUnVuKGJsb2NrbHksIHNraW4sIGlzSzEpIHtcbiAgYmxvY2tseS5CbG9ja3Mud2hlbl9ydW4gPSB7XG4gICAgLy8gQmxvY2sgdG8gaGFuZGxlIGV2ZW50IHdoZXJlIG1vdXNlIGlzIGNsaWNrZWRcbiAgICBoZWxwVXJsOiAnJyxcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNldEhTVigzOSwgMS4wMCwgMC45OSk7XG4gICAgICBpZiAoaXNLMSkge1xuICAgICAgICB0aGlzLmFwcGVuZER1bW15SW5wdXQoKVxuICAgICAgICAgIC5hcHBlbmRUaXRsZShjb21tb25Nc2cud2hlblJ1bigpKVxuICAgICAgICAgIC5hcHBlbmRUaXRsZShuZXcgYmxvY2tseS5GaWVsZEltYWdlKHNraW4ucnVuQXJyb3cpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kRHVtbXlJbnB1dCgpLmFwcGVuZFRpdGxlKGNvbW1vbk1zZy53aGVuUnVuKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQcmV2aW91c1N0YXRlbWVudChmYWxzZSk7XG4gICAgICB0aGlzLnNldE5leHRTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgfSxcbiAgICBzaG91bGRCZUdyYXllZE91dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBibG9ja2x5LkphdmFTY3JpcHQud2hlbl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gR2VuZXJhdGUgSmF2YVNjcmlwdCBmb3IgaGFuZGxpbmcgY2xpY2sgZXZlbnQuXG4gICAgcmV0dXJuICdcXG4nO1xuICB9O1xufVxuIiwiLyogZ2xvYmFsIEJsb2NrbHksIGFjZTp0cnVlLCBkcm9wbGV0LCBtYXJrZWQsIGRhc2hib2FyZCwgYWRkVG9Ib21lICovXG5cbnZhciBhY2VNb2RlID0gcmVxdWlyZSgnLi9hY2Vtb2RlL21vZGUtamF2YXNjcmlwdF9jb2Rlb3JnJyk7XG52YXIgcGFyc2VYbWxFbGVtZW50ID0gcmVxdWlyZSgnLi94bWwnKS5wYXJzZUVsZW1lbnQ7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZHJvcGxldFV0aWxzID0gcmVxdWlyZSgnLi9kcm9wbGV0VXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpO1xudmFyIG1zZyA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgYmxvY2tVdGlscyA9IHJlcXVpcmUoJy4vYmxvY2tfdXRpbHMnKTtcbnZhciBEcm9wbGV0VG9vbHRpcE1hbmFnZXIgPSByZXF1aXJlKCcuL2Jsb2NrVG9vbHRpcHMvRHJvcGxldFRvb2x0aXBNYW5hZ2VyJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgRmVlZGJhY2tVdGlscyA9IHJlcXVpcmUoJy4vZmVlZGJhY2snKTtcbnZhciBWZXJzaW9uSGlzdG9yeSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL1ZlcnNpb25IaXN0b3J5LmpzeCcpO1xudmFyIEFsZXJ0ID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvYWxlcnQuanN4Jyk7XG52YXIgY29kZWdlbiA9IHJlcXVpcmUoJy4vY29kZWdlbicpO1xudmFyIHB1enpsZVJhdGluZ1V0aWxzID0gcmVxdWlyZSgnLi9wdXp6bGVSYXRpbmdVdGlscycpO1xudmFyIGxvZ1RvQ2xvdWQgPSByZXF1aXJlKCcuL2xvZ1RvQ2xvdWQnKTtcbnZhciBBdXRob3JlZEhpbnRzID0gcmVxdWlyZSgnLi9hdXRob3JlZEhpbnRzJyk7XG52YXIgSW5zdHJ1Y3Rpb25zID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvSW5zdHJ1Y3Rpb25zLmpzeCcpO1xudmFyIFdpcmVmcmFtZVNlbmRUb1Bob25lID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvV2lyZWZyYW1lU2VuZFRvUGhvbmUuanN4Jyk7XG52YXIgYXNzZXRzQXBpID0gcmVxdWlyZSgnLi9jbGllbnRBcGknKS5hc3NldHM7XG52YXIgYXNzZXRQcmVmaXggPSByZXF1aXJlKCcuL2Fzc2V0TWFuYWdlbWVudC9hc3NldFByZWZpeCcpO1xudmFyIGFzc2V0TGlzdFN0b3JlID0gcmVxdWlyZSgnLi9hc3NldE1hbmFnZW1lbnQvYXNzZXRMaXN0U3RvcmUnKTtcbnZhciBjb3B5cmlnaHRTdHJpbmdzO1xuXG4vKipcbiogVGhlIG1pbmltdW0gd2lkdGggb2YgYSBwbGF5YWJsZSB3aG9sZSBibG9ja2x5IGdhbWUuXG4qL1xudmFyIE1JTl9XSURUSCA9IDkwMDtcbnZhciBERUZBVUxUX01PQklMRV9OT19QQURESU5HX1NIQVJFX1dJRFRIID0gMzIwO1xudmFyIE1BWF9WSVNVQUxJWkFUSU9OX1dJRFRIID0gNDAwO1xudmFyIE1JTl9WSVNVQUxJWkFUSU9OX1dJRFRIID0gMjAwO1xuXG52YXIgRU5HTElTSF9MT0NBTEUgPSAnZW5fdXMnO1xuXG4vKipcbiAqIFRyZWF0IG1vYmlsZSBkZXZpY2VzIHdpdGggc2NyZWVuLndpZHRoIGxlc3MgdGhhbiB0aGUgdmFsdWUgYmVsb3cgYXMgcGhvbmVzLlxuICovXG52YXIgTUFYX1BIT05FX1dJRFRIID0gNTAwO1xuXG52YXIgU3R1ZGlvQXBwID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZlZWRiYWNrXyA9IG5ldyBGZWVkYmFja1V0aWxzKHRoaXMpO1xuICB0aGlzLmF1dGhvcmVkSGludHNDb250cm9sbGVyXyA9IG5ldyBBdXRob3JlZEhpbnRzKHRoaXMpO1xuXG4gIC8qKlxuICAqIFRoZSBwYXJlbnQgZGlyZWN0b3J5IG9mIHRoZSBhcHBzLiBDb250YWlucyBjb21tb24uanMuXG4gICovXG4gIHRoaXMuQkFTRV9VUkwgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICogVGhlIGN1cnJlbnQgbG9jYWxlIGNvZGUuXG4gICovXG4gIHRoaXMuTE9DQUxFID0gRU5HTElTSF9MT0NBTEU7XG5cbiAgdGhpcy5lbmFibGVTaG93Q29kZSA9IHRydWU7XG4gIHRoaXMuZWRpdENvZGUgPSBmYWxzZTtcbiAgdGhpcy51c2luZ0Jsb2NrbHlfID0gdHJ1ZTtcblxuICAvKipcbiAgICogQHR5cGUge0F1ZGlvUGxheWVyfVxuICAgKi9cbiAgdGhpcy5jZG9Tb3VuZHMgPSBudWxsO1xuICB0aGlzLkRpYWxvZyA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7P0Ryb3BsZXQuRWRpdG9yfVxuICAgKi9cbiAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUgez9Ecm9wbGV0VG9vbHRpcE1hbmFnZXJ9XG4gICAqL1xuICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlciA9IG51bGw7XG5cbiAgLy8gQHR5cGUge3N0cmluZ30gZm9yIGFsbCBvZiB0aGVzZVxuICB0aGlzLmljb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuc21hbGxJY29uID0gdW5kZWZpbmVkO1xuICB0aGlzLndpbkljb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuZmFpbHVyZUljb24gPSB1bmRlZmluZWQ7XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGdldCB0aGVpciBub24tZGVmYXVsdCB2YWx1ZXMgc2V0IGJ5IHRoZSBhcHBsaWNhdGlvbi5cblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGVydCB1c2VyIHRvIGVtcHR5IGJsb2Nrcywgc2hvcnQtY2lyY3VpdGluZyBhbGwgb3RoZXIgdGVzdHMuXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmNoZWNrRm9yRW1wdHlCbG9ja3NfID0gZmFsc2U7XG5cbiAgLyoqXG4gICogVGhlIGlkZWFsIG51bWJlciBvZiBibG9ja3MgdG8gc29sdmUgdGhpcyBsZXZlbC4gIFVzZXJzIG9ubHkgZ2V0IDJcbiAgKiBzdGFycyBpZiB0aGV5IHVzZSBtb3JlIHRoYW4gdGhpcyBudW1iZXIuXG4gICogQHR5cGUge251bWJlcn1cbiAgKi9cbiAgdGhpcy5JREVBTF9CTE9DS19OVU0gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFRlc3RhYmxlQmxvY2tcbiAgICogQHByb3BlcnR5IHtzdHJpbmd8ZnVuY3Rpb259IHRlc3QgLSBBIHRlc3Qgd2hldGhlciB0aGUgYmxvY2sgaXNcbiAgICogICAgICAgICAgIHByZXNlbnQsIGVpdGhlcjpcbiAgICogICAgICAgICAgIC0gQSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgdGhlIHN0cmluZyBpcyBzZWFyY2hlZCBmb3IgaW5cbiAgICogICAgICAgICAgICAgdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiAgICAgICAgICAgLSBBIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCB1c2VyLWFkZGVkXG4gICAqICAgICAgICAgICAgIGJsb2NrIGluZGl2aWR1YWxseS4gIElmIGFueSBjYWxsIHJldHVybnMgdHJ1ZSwgdGhlIGJsb2NrXG4gICAqICAgICAgICAgICAgIGlzIGRlZW1lZCBwcmVzZW50LiAgXCJVc2VyLWFkZGVkXCIgYmxvY2tzIGFyZSBvbmVzIHRoYXQgYXJlXG4gICAqICAgICAgICAgICAgIG5laXRoZXIgZGlzYWJsZWQgb3IgdW5kZWxldGFibGUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYmxvY2sgdG8gYmUgcHJvZHVjZWQgZm9yXG4gICAqICAgICAgICAgICBkaXNwbGF5IHRvIHRoZSB1c2VyIGlmIHRoZSB0ZXN0IGZhaWxlZC5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0aXRsZXNdIC0gQSBkaWN0aW9uYXJ5LCB3aGVyZSwgZm9yIGVhY2hcbiAgICogICAgICAgICAgIEtFWS1WQUxVRSBwYWlyLCB0aGlzIGlzIGFkZGVkIHRvIHRoZSBibG9jayBkZWZpbml0aW9uOlxuICAgKiAgICAgICAgICAgPHRpdGxlIG5hbWU9XCJLRVlcIj5WQUxVRTwvdGl0bGU+LlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW3ZhbHVlXSAtIEEgZGljdGlvbmFyeSwgd2hlcmUsIGZvciBlYWNoXG4gICAqICAgICAgICAgICBLRVktVkFMVUUgcGFpciwgdGhpcyBpcyBhZGRlZCB0byB0aGUgYmxvY2sgZGVmaW5pdGlvbjpcbiAgICogICAgICAgICAgIDx2YWx1ZSBuYW1lPVwiS0VZXCI+VkFMVUU8L3ZhbHVlPlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2V4dHJhXSAtIEEgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIGJsYWNrZWRcbiAgICogICAgICAgICAgIGJldHdlZW4gdGhlIFwiYmxvY2tcIiBzdGFydCBhbmQgZW5kIHRhZ3MuXG4gICAqL1xuXG4gIC8qKlxuICAqIEB0eXBlIHshVGVzdGFibGVCbG9ja1tdfVxuICAqL1xuICB0aGlzLnJlcXVpcmVkQmxvY2tzXyA9IFtdO1xuXG4gIC8qKlxuICAqIFRoZSBudW1iZXIgb2YgcmVxdWlyZWQgYmxvY2tzIHRvIGdpdmUgaGludHMgYWJvdXQgYXQgYW55IG9uZSB0aW1lLlxuICAqIFNldCB0aGlzIHRvIEluZmluaXR5IHRvIHNob3cgYWxsLlxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICovXG4gIHRoaXMubWF4UmVxdWlyZWRCbG9ja3NUb0ZsYWdfID0gMTtcblxuICAvKipcbiAgKiBAdHlwZSB7IVRlc3RhYmxlQmxvY2tbXX1cbiAgKi9cbiAgdGhpcy5yZWNvbW1lbmRlZEJsb2Nrc18gPSBbXTtcblxuICAvKipcbiAgKiBUaGUgbnVtYmVyIG9mIHJlY29tbWVuZGVkIGJsb2NrcyB0byBnaXZlIGhpbnRzIGFib3V0IGF0IGFueSBvbmUgdGltZS5cbiAgKiBTZXQgdGhpcyB0byBJbmZpbml0eSB0byBzaG93IGFsbC5cbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqL1xuICB0aGlzLm1heFJlY29tbWVuZGVkQmxvY2tzVG9GbGFnXyA9IDE7XG5cbiAgLyoqXG4gICogVGhlIG51bWJlciBvZiBhdHRlbXB0cyAoaG93IG1hbnkgdGltZXMgdGhlIHJ1biBidXR0b24gaGFzIGJlZW4gcHJlc3NlZClcbiAgKiBAdHlwZSB7P251bWJlcn1cbiAgKi9cbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cbiAgLyoqXG4gICogU3RvcmVzIHRoZSB0aW1lIGF0IGluaXQuIFRoZSBkZWx0YSB0byBjdXJyZW50IHRpbWUgaXMgdXNlZCBmb3IgbG9nZ2luZ1xuICAqIGFuZCByZXBvcnRpbmcgdG8gY2FwdHVyZSBob3cgbG9uZyBpdCB0b29rIHRvIGFycml2ZSBhdCBhbiBhdHRlbXB0LlxuICAqIEB0eXBlIHs/bnVtYmVyfVxuICAqL1xuICB0aGlzLmluaXRUaW1lID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAqIEVudW1lcmF0aW9uIG9mIHVzZXIgcHJvZ3JhbSBleGVjdXRpb24gb3V0Y29tZXMuXG4gICovXG4gIHRoaXMuUmVzdWx0VHlwZSA9IGNvbnN0YW50cy5SZXN1bHRUeXBlO1xuXG4gIC8qKlxuICAqIEVudW1lcmF0aW9uIG9mIHRlc3QgcmVzdWx0cy5cbiAgKi9cbiAgdGhpcy5UZXN0UmVzdWx0cyA9IGNvbnN0YW50cy5UZXN0UmVzdWx0cztcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgd2UgZG9uJ3Qgc2hvdyBibG9ja3NwYWNlLiBVc2VkIHdoZW4gdmlld2luZyBzaGFyZWQgbGV2ZWxzXG4gICAqL1xuICB0aGlzLmhpZGVTb3VyY2UgPSBmYWxzZTtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgd2UncmUgdmlld2luZyBhIHNoYXJlZCBsZXZlbC5cbiAgICovXG4gIHRoaXMuc2hhcmUgPSBmYWxzZTtcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgd2UgY2VudGVyIG91ciBlbWJlZGRlZCBsZXZlbHMuIENhbiBiZSBvdmVycmlkZW4gYnkgYXBwcy5cbiAgICovXG4gIHRoaXMuY2VudGVyRW1iZWRkZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgd2UgdXNlIG91ciB3aXJlZnJhbWUgc2hhcmUgKG9yIGNocm9tZWxlc3Mgc2hhcmUgb24gbW9iaWxlKVxuICAgKi9cbiAgdGhpcy53aXJlZnJhbWVTaGFyZSA9IGZhbHNlO1xuXG4gIHRoaXMub25BdHRlbXB0ID0gdW5kZWZpbmVkO1xuICB0aGlzLm9uQ29udGludWUgPSB1bmRlZmluZWQ7XG4gIHRoaXMub25SZXNldFByZXNzZWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuYmFja1RvUHJldmlvdXNMZXZlbCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5zZW5kVG9QaG9uZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5lbmFibGVTaG93QmxvY2tDb3VudCA9IHRydWU7XG5cbiAgdGhpcy5kaXNhYmxlU29jaWFsU2hhcmUgPSBmYWxzZTtcbiAgdGhpcy5ub1BhZGRpbmcgPSBmYWxzZTtcblxuICB0aGlzLk1JTl9XT1JLU1BBQ0VfSEVJR0hUID0gdW5kZWZpbmVkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU3R1ZGlvQXBwO1xuU3R1ZGlvQXBwLnNpbmdsZXRvbiA9IG5ldyBTdHVkaW9BcHAoKTtcblxuLyoqXG4gKiBDb25maWd1cmUgU3R1ZGlvQXBwIG9wdGlvbnNcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLkJBU0VfVVJMID0gb3B0aW9ucy5iYXNlVXJsO1xuICB0aGlzLkxPQ0FMRSA9IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuTE9DQUxFO1xuICAvLyBOT1RFOiBlZGl0Q29kZSAod2hpY2ggY3VycmVudGx5IGltcGxpZXMgZHJvcGxldCkgYW5kIHVzaW5nQmxvY2tseV8gYXJlXG4gIC8vIGN1cnJlbnRseSBtdXR1YWxseSBleGNsdXNpdmUuXG4gIHRoaXMuZWRpdENvZGUgPSBvcHRpb25zLmxldmVsICYmIG9wdGlvbnMubGV2ZWwuZWRpdENvZGU7XG4gIHRoaXMudXNpbmdCbG9ja2x5XyA9ICF0aGlzLmVkaXRDb2RlO1xuXG4gIC8vIFRPRE8gKGJidWNoYW5hbikgOiBSZXBsYWNlIHRoaXMgZWRpdG9ybGVzcy1oYWNrIHdpdGggc2V0dGluZyBhbiBlZGl0b3IgZW51bVxuICAvLyBvciAoZXZlbiBiZXR0ZXIpIGluamVjdCBhbiBhcHByb3ByaWF0ZSBlZGl0b3ItYWRhcHRvci5cbiAgaWYgKG9wdGlvbnMuaXNFZGl0b3JsZXNzKSB7XG4gICAgdGhpcy5lZGl0Q29kZSA9IGZhbHNlO1xuICAgIHRoaXMudXNpbmdCbG9ja2x5XyA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5jZG9Tb3VuZHMgPSBvcHRpb25zLmNkb1NvdW5kcztcbiAgdGhpcy5EaWFsb2cgPSBvcHRpb25zLkRpYWxvZztcblxuICAvLyBCaW5kIGFzc2V0VXJsIHRvIHRoZSBpbnN0YW5jZSBzbyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gZGVwZW5kIG9uIGNhbGxlcnNcbiAgLy8gYmluZGluZyBjb3JyZWN0bHkgYXMgdGhleSBwYXNzIHRoaXMgZnVuY3Rpb24gYXJvdW5kLlxuICB0aGlzLmFzc2V0VXJsID0gXy5iaW5kKHRoaXMuYXNzZXRVcmxfLCB0aGlzKTtcblxuICB0aGlzLm1heFZpc3VhbGl6YXRpb25XaWR0aCA9IG9wdGlvbnMubWF4VmlzdWFsaXphdGlvbldpZHRoIHx8IE1BWF9WSVNVQUxJWkFUSU9OX1dJRFRIO1xuICB0aGlzLm1pblZpc3VhbGl6YXRpb25XaWR0aCA9IG9wdGlvbnMubWluVmlzdWFsaXphdGlvbldpZHRoIHx8IE1JTl9WSVNVQUxJWkFUSU9OX1dJRFRIO1xufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYXNJbnN0cnVjdGlvbnNUb1Nob3cgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiAhIShjb25maWcubGV2ZWwuaW5zdHJ1Y3Rpb25zIHx8IGNvbmZpZy5sZXZlbC5hbmlHaWZVUkwpO1xufTtcblxuLyoqXG4gKiBDb21tb24gc3RhcnR1cCB0YXNrcyBmb3IgYWxsIGFwcHMuIEhhcHBlbnMgYWZ0ZXIgY29uZmlndXJlLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIGNvbmZpZy5nZXRDb2RlID0gdGhpcy5nZXRDb2RlLmJpbmQodGhpcyk7XG4gIGNvcHlyaWdodFN0cmluZ3MgPSBjb25maWcuY29weXJpZ2h0U3RyaW5ncztcblxuICBpZiAoY29uZmlnLmlzTGVnYWN5U2hhcmUgJiYgY29uZmlnLmhpZGVTb3VyY2UpIHtcbiAgICAkKFwiYm9keVwiKS5hZGRDbGFzcyhcImxlZ2FjeS1zaGFyZS12aWV3XCIpO1xuICAgIGlmIChkb20uaXNNb2JpbGUoKSkge1xuICAgICAgJCgnI21haW4tbG9nbycpLmhpZGUoKTtcbiAgICB9XG4gICAgaWYgKGRvbS5pc0lPUygpICYmICF3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUpIHtcbiAgICAgIGFkZFRvSG9tZS5zaG93KHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2V0Q29uZmlnVmFsdWVzXyhjb25maWcpO1xuXG4gIHRoaXMuY29uZmlndXJlRG9tKGNvbmZpZyk7XG5cbiAgaWYgKGNvbmZpZy51c2VzQXNzZXRzKSB7XG4gICAgYXNzZXRQcmVmaXguaW5pdChjb25maWcpO1xuXG4gICAgLy8gUHJlLXBvcHVsYXRlIGFzc2V0IGxpc3RcbiAgICBhc3NldHNBcGkuYWpheCgnR0VUJywgJycsIGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgIGFzc2V0TGlzdFN0b3JlLnJlc2V0KEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFVuYWJsZSB0byBsb2FkIGFzc2V0IGxpc3RcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjb25maWcuaGlkZVNvdXJjZSkge1xuICAgIHRoaXMuaGFuZGxlSGlkZVNvdXJjZV8oe1xuICAgICAgY29udGFpbmVySWQ6IGNvbmZpZy5jb250YWluZXJJZCxcbiAgICAgIGVtYmVkOiBjb25maWcuZW1iZWQsXG4gICAgICBsZXZlbDogY29uZmlnLmxldmVsLFxuICAgICAgbGV2ZWxfc291cmNlX2lkOiBjb25maWcubGV2ZWxfc291cmNlX2lkLFxuICAgICAgcGhvbmVfc2hhcmVfdXJsOiBjb25maWcuc2VuZF90b19waG9uZV91cmwsXG4gICAgICBzZW5kVG9QaG9uZTogY29uZmlnLnNlbmRUb1Bob25lLFxuICAgICAgdHdpdHRlcjogY29uZmlnLnR3aXR0ZXIsXG4gICAgICBhcHA6IGNvbmZpZy5hcHAsXG4gICAgICBpc0xlZ2FjeVNoYXJlOiBjb25maWcuaXNMZWdhY3lTaGFyZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaGFyZSkge1xuICAgIHRoaXMuaGFuZGxlU2hhcmluZ18oe1xuICAgICAgbWFrZVVybDogY29uZmlnLm1ha2VVcmwsXG4gICAgICBtYWtlU3RyaW5nOiBjb25maWcubWFrZVN0cmluZyxcbiAgICAgIG1ha2VJbWFnZTogY29uZmlnLm1ha2VJbWFnZSxcbiAgICAgIG1ha2VZb3VyT3duOiBjb25maWcubWFrZVlvdXJPd25cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLmluaXQoY29uZmlnLmxldmVsLmF1dGhvcmVkSGludHMsIGNvbmZpZy5zY3JpcHRJZCwgY29uZmlnLnNlcnZlckxldmVsSWQpO1xuICBpZiAoY29uZmlnLmF1dGhvcmVkSGludFZpZXdSZXF1ZXN0c1VybCkge1xuICAgIHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLnN1Ym1pdEhpbnRzKGNvbmZpZy5hdXRob3JlZEhpbnRWaWV3UmVxdWVzdHNVcmwpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5wdXp6bGVSYXRpbmdzVXJsKSB7XG4gICAgcHV6emxlUmF0aW5nVXRpbHMuc3VibWl0Q2FjaGVkUHV6emxlUmF0aW5ncyhjb25maWcucHV6emxlUmF0aW5nc1VybCk7XG4gIH1cblxuICAvLyBSZWNvcmQgdGltZSBhdCBpbml0aWFsaXphdGlvbi5cbiAgdGhpcy5pbml0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIEZpeGVzIHZpZXdwb3J0IGZvciBzbWFsbCBzY3JlZW5zLlxuICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ2aWV3cG9ydFwiXScpO1xuICBpZiAodmlld3BvcnQpIHtcbiAgICB0aGlzLmZpeFZpZXdwb3J0Rm9yU21hbGxTY3JlZW5zXyh2aWV3cG9ydCwgY29uZmlnKTtcbiAgfVxuXG4gIHZhciBzaG93Q29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWNvZGUtaGVhZGVyJyk7XG4gIGlmIChzaG93Q29kZSAmJiB0aGlzLmVuYWJsZVNob3dDb2RlKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzaG93Q29kZSwgXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZWRpdENvZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIG5vbkRyb3BsZXRFcnJvciA9IGZhbHNlO1xuICAgICAgICAvLyBhcmUgd2UgdHJ5aW5nIHRvIHRvZ2dsZSBmcm9tIGJsb2NrcyB0byB0ZXh0IChvciB0aGUgb3Bwb3NpdGUpXG4gICAgICAgIHZhciBmcm9tQmxvY2tzID0gdGhpcy5lZGl0b3IuY3VycmVudGx5VXNpbmdCbG9ja3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5lZGl0b3IudG9nZ2xlQmxvY2tzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIG5vbkRyb3BsZXRFcnJvciA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0ge2Vycm9yOiBlcnJ9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgbG9nVG9DbG91ZC5hZGRQYWdlQWN0aW9uKGxvZ1RvQ2xvdWQuUGFnZUFjdGlvbi5Ecm9wbGV0VHJhbnNpdGlvbkVycm9yLCB7XG4gICAgICAgICAgICBkcm9wbGV0RXJyb3I6ICFub25Ecm9wbGV0RXJyb3IsXG4gICAgICAgICAgICBmcm9tQmxvY2tzOiBmcm9tQmxvY2tzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5mZWVkYmFja18uc2hvd1RvZ2dsZUJsb2Nrc0Vycm9yKHRoaXMuRGlhbG9nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRHJvcGxldFRvZ2dsZV8oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tfLnNob3dHZW5lcmF0ZWRDb2RlKHRoaXMuRGlhbG9nLCBjb25maWcuYXBwU3RyaW5ncyk7XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgdmFyIGJsb2NrQ291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxvY2tDb3VudGVyJyk7XG4gIGlmIChibG9ja0NvdW50ICYmICF0aGlzLmVuYWJsZVNob3dCbG9ja0NvdW50KSB7XG4gICAgYmxvY2tDb3VudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgdGhpcy5zZXRJY29uc0Zyb21Ta2luKGNvbmZpZy5za2luKTtcblxuICBpZiAoY29uZmlnLmxldmVsLmluc3RydWN0aW9uc0ljb24pIHtcbiAgICB0aGlzLmljb24gPSBjb25maWcuc2tpbltjb25maWcubGV2ZWwuaW5zdHJ1Y3Rpb25zSWNvbl07XG4gICAgdGhpcy53aW5JY29uID0gY29uZmlnLnNraW5bY29uZmlnLmxldmVsLmluc3RydWN0aW9uc0ljb25dO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaG93SW5zdHJ1Y3Rpb25zV3JhcHBlcikge1xuICAgIGNvbmZpZy5zaG93SW5zdHJ1Y3Rpb25zV3JhcHBlcihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNob3VsZEF1dG9DbG9zZSA9ICEhY29uZmlnLmxldmVsLmFuaUdpZlVSTDtcbiAgICAgIHRoaXMuc2hvd0luc3RydWN0aW9uc18oY29uZmlnLmxldmVsLCBzaG91bGRBdXRvQ2xvc2UsIGZhbHNlKTtcbiAgICB9LCB0aGlzKSk7XG4gIH1cblxuICAvLyBJbiBlbWJlZCBtb2RlLCB0aGUgZGlzcGxheSBzY2FsZXMgZG93biB3aGVuIHRoZSB3aWR0aCBvZiB0aGVcbiAgLy8gdmlzdWFsaXphdGlvbkNvbHVtbiBnb2VzIGJlbG93IHRoZSBtaW4gd2lkdGhcbiAgaWYoY29uZmlnLmVtYmVkICYmIGNvbmZpZy5jZW50ZXJFbWJlZGRlZCkge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgdmFyIHJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpekNvbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uQ29sdW1uJyk7XG4gICAgICB2YXIgd2lkdGggPSB2aXpDb2wub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdml6Q29sLm9mZnNldEhlaWdodDtcbiAgICAgIHZhciBkaXNwbGF5V2lkdGggPSBERUZBVUxUX01PQklMRV9OT19QQURESU5HX1NIQVJFX1dJRFRIO1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4od2lkdGggLyBkaXNwbGF5V2lkdGgsIGhlaWdodCAvIGRpc3BsYXlXaWR0aCk7XG4gICAgICB2YXIgdml6ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb24nKTtcbiAgICAgIHZpei5zdHlsZVsndHJhbnNmb3JtLW9yaWdpbiddID0gJ2xlZnQgdG9wJztcbiAgICAgIHZpei5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnKSc7XG4gICAgICB2aXouc3R5bGVbJ21heC1oZWlnaHQnXSA9IChkaXNwbGF5V2lkdGggKiBzY2FsZSkgKyAncHgnO1xuICAgICAgdml6LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdml6Q29sLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICB2aXpDb2wuc3R5bGUubWF4V2lkdGggPSBkaXNwbGF5V2lkdGggKyAncHgnO1xuICAgICAgLy8gTmVlZHMgdG8gcnVuIHR3aWNlIG9uIGluaXRpYWxpemF0aW9uXG4gICAgICBpZighcmVzaXplZCkge1xuICAgICAgICByZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgcmVzaXplKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBEZXBlbmRzIG9uIFJlc2l6ZVNlbnNvci5qc1xuICAgIHZhciBSZXNpemVTZW5zb3IgPSByZXF1aXJlKCcuL1Jlc2l6ZVNlbnNvcicpO1xuICAgIFJlc2l6ZVNlbnNvcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpLCByZXNpemUpO1xuICB9XG5cbiAgdmFyIG9yaWVudGF0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTsgIC8vIEJyb3dzZXJzIGxpa2UgdG8gbWVzcyB3aXRoIHNjcm9sbCBvbiByb3RhdGUuXG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uSGFuZGxlcik7XG4gIG9yaWVudGF0aW9uSGFuZGxlcigpO1xuXG4gIGlmIChjb25maWcubG9hZEF1ZGlvKSB7XG4gICAgY29uZmlnLmxvYWRBdWRpbygpO1xuICB9XG5cbiAgdmFyIHByb21wdERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9tcHQnKTtcbiAgdmFyIHByb21wdDJEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvbXB0MicpO1xuICBpZiAoY29uZmlnLmxldmVsLmluc3RydWN0aW9ucykge1xuICAgIHZhciBpbnN0cnVjdGlvbnNIdG1sID0gdGhpcy5zdWJzdGl0dXRlSW5zdHJ1Y3Rpb25JbWFnZXMoY29uZmlnLmxldmVsLmluc3RydWN0aW9ucyk7XG4gICAgJChwcm9tcHREaXYpLmh0bWwoaW5zdHJ1Y3Rpb25zSHRtbCk7XG4gIH1cbiAgaWYgKGNvbmZpZy5sZXZlbC5pbnN0cnVjdGlvbnMyKSB7XG4gICAgdmFyIGluc3RydWN0aW9uczJIdG1sID0gdGhpcy5zdWJzdGl0dXRlSW5zdHJ1Y3Rpb25JbWFnZXMoY29uZmlnLmxldmVsLmluc3RydWN0aW9uczIpO1xuICAgICQocHJvbXB0MkRpdikuaHRtbChpbnN0cnVjdGlvbnMySHRtbCk7XG4gICAgJChwcm9tcHQyRGl2KS5zaG93KCk7XG4gIH1cblxuICBpZiAodGhpcy5oYXNJbnN0cnVjdGlvbnNUb1Nob3coY29uZmlnKSkge1xuICAgIHZhciBwcm9tcHRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb21wdC1pY29uJyk7XG4gICAgaWYgKHRoaXMuc21hbGxJY29uKSB7XG4gICAgICBwcm9tcHRJY29uLnNyYyA9IHRoaXMuc21hbGxJY29uO1xuICAgICAgJCgnI3Byb21wdC1pY29uLWNlbGwnKS5zaG93KCk7XG4gICAgfVxuXG4gICAgdmFyIGJ1YmJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidWJibGUnKTtcblxuICAgIHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLmRpc3BsYXkocHJvbXB0SWNvbiwgYnViYmxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNob3dJbnN0cnVjdGlvbnNfKGNvbmZpZy5sZXZlbCwgZmFsc2UsIHRydWUpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICB2YXIgYW5pR2lmUHJldmlldyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbmktZ2lmLXByZXZpZXcnKTtcbiAgaWYgKGNvbmZpZy5sZXZlbC5hbmlHaWZVUkwpIHtcbiAgICBhbmlHaWZQcmV2aWV3LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKCdcIiArIGNvbmZpZy5sZXZlbC5hbmlHaWZVUkwgKyBcIicpXCI7XG4gICAgdmFyIHByb21wdFRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb21wdC10YWJsZScpO1xuICAgIHByb21wdFRhYmxlLmNsYXNzTmFtZSArPSBcIiB3aXRoLWFuaS1naWZcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbmktZ2lmLXByZXZpZXctd3JhcHBlcicpO1xuICAgIHdyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIGlmICh0aGlzLmVkaXRDb2RlKSB7XG4gICAgdGhpcy5oYW5kbGVFZGl0Q29kZV8oY29uZmlnKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICB0aGlzLmhhbmRsZVVzaW5nQmxvY2tseV8oY29uZmlnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGVVc2luZ0Jsb2NrbHlfIGFscmVhZHkgZG9lcyBhbiBvblJlc2l6ZS4gV2Ugc3RpbGwgd2FudCB0aGF0IGdvb2RuZXNzXG4gICAgLy8gaWYgd2UncmUgbm90IGJsb2NrbHlcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH1cblxuICB2YXIgdml6UmVzaXplQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25SZXNpemVCYXInKTtcbiAgaWYgKHZpelJlc2l6ZUJhcikge1xuICAgIGRvbS5hZGRNb3VzZURvd25Ub3VjaEV2ZW50KHZpelJlc2l6ZUJhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5vbk1vdXNlRG93blZpelJlc2l6ZUJhciwgdGhpcykpO1xuXG4gICAgLy8gQ2FuJ3QgdXNlIGRvbS5hZGRNb3VzZVVwVG91Y2hFdmVudCgpIGJlY2F1c2UgaXQgd2lsbCBwcmV2ZW50RGVmYXVsdCBvblxuICAgIC8vIGFsbCB0b3VjaGVuZCBldmVudHMgb24gdGhlIHBhZ2UsIGJyZWFraW5nIGNsaWNrIGV2ZW50cy4uLlxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLm9uTW91c2VVcFZpelJlc2l6ZUJhciwgdGhpcykpO1xuICAgIHZhciBtb3VzZVVwVG91Y2hFdmVudE5hbWUgPSBkb20uZ2V0VG91Y2hFdmVudE5hbWUoJ21vdXNldXAnKTtcbiAgICBpZiAobW91c2VVcFRvdWNoRXZlbnROYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIobW91c2VVcFRvdWNoRXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLm9uTW91c2VVcFZpelJlc2l6ZUJhciwgdGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfLmJpbmQodGhpcy5vblJlc2l6ZSwgdGhpcykpO1xuXG4gIHRoaXMucmVzZXQodHJ1ZSk7XG5cbiAgLy8gQWRkIGRpc3BsYXkgb2YgYmxvY2tzIHVzZWQuXG4gIHRoaXMuc2V0SWRlYWxCbG9ja051bWJlcl8oKTtcblxuICAvLyBUT0RPIChjcGlyaWNoKTogaW1wbGVtZW50IGJsb2NrIGNvdW50IGZvciBkcm9wbGV0IChmb3Igbm93LCBibG9ja2x5IG9ubHkpXG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlRWRpdG9yLmFkZENoYW5nZUxpc3RlbmVyKF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudXBkYXRlQmxvY2tDb3VudCgpO1xuICAgIH0sIHRoaXMpKTtcblxuICAgIGlmIChjb25maWcubGV2ZWwub3BlbkZ1bmN0aW9uRGVmaW5pdGlvbikge1xuICAgICAgdGhpcy5vcGVuRnVuY3Rpb25EZWZpbml0aW9uXyhjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJpbmQgbGlzdGVuZXIgdG8gJ0NsZWFyIFB1enpsZScgYnV0dG9uXG4gIHZhciBoaWRlSWNvbiA9IHV0aWxzLnZhbHVlT3IoY29uZmlnLnNraW4uaGlkZUljb25JbkNsZWFyUHV6emxlLCBmYWxzZSk7XG4gIHZhciBjbGVhclB1enpsZUhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGVhci1wdXp6bGUtaGVhZGVyJyk7XG4gIGlmIChjbGVhclB1enpsZUhlYWRlcikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoY2xlYXJQdXp6bGVIZWFkZXIsIChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmVlZGJhY2tfLnNob3dDbGVhclB1enpsZUNvbmZpcm1hdGlvbih0aGlzLkRpYWxvZywgaGlkZUljb24sIChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGVhclB1enpsZShjb25maWcpO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvLyBCaW5kIGxpc3RlbmVyIHRvICdWZXJzaW9uIEhpc3RvcnknIGJ1dHRvblxuICB2YXIgdmVyc2lvbnNIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmVyc2lvbnMtaGVhZGVyJyk7XG4gIGlmICh2ZXJzaW9uc0hlYWRlcikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQodmVyc2lvbnNIZWFkZXIsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgICAgIERpYWxvZzogdGhpcy5EaWFsb2csXG4gICAgICAgIGNvbnRlbnREaXY6IGNvZGVEaXYsXG4gICAgICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJ2FnYWluLWJ1dHRvbicsXG4gICAgICAgIGlkOiAnc2hvd1ZlcnNpb25zTW9kYWwnXG4gICAgICB9KTtcbiAgICAgIFJlYWN0LnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KFZlcnNpb25IaXN0b3J5LCB7XG4gICAgICAgIGhhbmRsZUNsZWFyUHV6emxlOiB0aGlzLmhhbmRsZUNsZWFyUHV6emxlLmJpbmQodGhpcywgY29uZmlnKVxuICAgICAgfSksIGNvZGVEaXYpO1xuXG4gICAgICBkaWFsb2cuc2hvdygpO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNVc2luZ0Jsb2NrbHkoKSAmJiBCbG9ja2x5LmNvbnRyYWN0RWRpdG9yKSB7XG4gICAgQmxvY2tseS5jb250cmFjdEVkaXRvci5yZWdpc3RlclRlc3RzRmFpbGVkT25DbG9zZUhhbmRsZXIoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5mZWVkYmFja18uc2hvd1NpbXBsZURpYWxvZyh0aGlzLkRpYWxvZywge1xuICAgICAgICBoZWFkZXJUZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGJvZHlUZXh0OiBtc2cuZXhhbXBsZXNGYWlsZWRPbkNsb3NlKCksXG4gICAgICAgIGNhbmNlbFRleHQ6IG1zZy5pZ25vcmUoKSxcbiAgICAgICAgY29uZmlybVRleHQ6IG1zZy50cnlBZ2FpbigpLFxuICAgICAgICBvbkNvbmZpcm06IG51bGwsXG4gICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgQmxvY2tseS5jb250cmFjdEVkaXRvci5oaWRlSWZPcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyByZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSB0byBibG9ja2x5LWNvcmUgdGhhdCB3ZSdsbCBvd24gY2xvc2luZyB0aGVcbiAgICAgIC8vIGNvbnRyYWN0IGVkaXRvclxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGlmIChjb25maWcuaXNMZWdhY3lTaGFyZSAmJiBjb25maWcuaGlkZVNvdXJjZSkge1xuICAgIHRoaXMuc2V0dXBMZWdhY3lTaGFyZVZpZXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwaG9uZSBmcmFtZSBhbmQgY29udGFpbmVyLiBTY2FsZSBzaGFyZWQgY29udGVudCAoZXZlcnl0aGluZyBjdXJyZW50bHkgaW5zaWRlIHRoZSB2aXN1YWxpemF0aW9uIGNvbHVtbilcbiAqIHRvIGNvbnRhaW5lciB3aWR0aCwgZml0IGNvbnRhaW5lciB0byB0aGUgcGhvbmUgZnJhbWUgYW5kIGFkZCBzaGFyZSBmb290ZXIuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuc2V0dXBMZWdhY3lTaGFyZVZpZXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZpekNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2aXpDb250YWluZXIuaWQgPSAndmlzdWFsaXphdGlvbkNvbnRhaW5lcic7XG4gIHZhciB2aXpDb2x1bW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpO1xuICBpZiAoZG9tLmlzTW9iaWxlKCkpIHtcbiAgICAkKHZpekNvbnRhaW5lcikud2lkdGgoJCh2aXpDb2x1bW4pLndpZHRoKCkpO1xuICB9XG4gICQodml6Q29udGFpbmVyKS5hcHBlbmQodml6Q29sdW1uLmNoaWxkcmVuKTtcblxuICB2YXIgcGhvbmVGcmFtZVNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwaG9uZUZyYW1lU2NyZWVuLmlkID0gJ3Bob25lRnJhbWVTY3JlZW4nO1xuICAkKHBob25lRnJhbWVTY3JlZW4pLmFwcGVuZCh2aXpDb250YWluZXIpO1xuICAkKHZpekNvbHVtbikuYXBwZW5kKHBob25lRnJhbWVTY3JlZW4pO1xuXG4gIHRoaXMucmVuZGVyU2hhcmVGb290ZXJfKHBob25lRnJhbWVTY3JlZW4pO1xuICBpZiAoZG9tLmlzTW9iaWxlKSB7XG4gICAgLy8gcmUtc2NhbGUgb24gcmVzaXplIGV2ZW50cyB0byBhZGp1c3QgdG8gb3JpZW50YXRpb24gYW5kIG5hdmJhciBjaGFuZ2VzXG4gICAgJCh3aW5kb3cpLnJlc2l6ZSh0aGlzLnNjYWxlTGVnYWN5U2hhcmUpO1xuICB9XG4gIHRoaXMuc2NhbGVMZWdhY3lTaGFyZSgpO1xufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5zY2FsZUxlZ2FjeVNoYXJlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2aXpDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbnRhaW5lcicpO1xuICB2YXIgdml6Q29sdW1uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25Db2x1bW4nKTtcbiAgdmFyIHBob25lRnJhbWVTY3JlZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGhvbmVGcmFtZVNjcmVlbicpO1xuICB2YXIgdml6V2lkdGggPSAkKHZpekNvbnRhaW5lcikud2lkdGgoKTtcblxuICAvLyBPbiBtb2JpbGUsIHNjYWxlIHBob25lIGZyYW1lIHRvIGZ1bGwgc2NyZWVuIChwb3J0cmFpdCkuIE90aGVyd2lzZSB1c2UgZ2l2ZW4gZGltZW5zaW9ucyBmcm9tIGNzcy5cbiAgaWYgKGRvbS5pc01vYmlsZSgpKSB7XG4gICAgdmFyIHNjcmVlbldpZHRoID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdmFyIHNjcmVlbkhlaWdodCA9IE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICQocGhvbmVGcmFtZVNjcmVlbikud2lkdGgoc2NyZWVuV2lkdGgpO1xuICAgICQocGhvbmVGcmFtZVNjcmVlbikuaGVpZ2h0KHNjcmVlbkhlaWdodCk7XG4gICAgJCh2aXpDb2x1bW4pLndpZHRoKHNjcmVlbldpZHRoKTtcbiAgfVxuXG4gIHZhciBmcmFtZVdpZHRoID0gJChwaG9uZUZyYW1lU2NyZWVuKS53aWR0aCgpO1xuICB2YXIgc2NhbGUgPSBmcmFtZVdpZHRoIC8gdml6V2lkdGg7XG4gIGFwcGx5VHJhbnNmb3JtT3JpZ2luKHZpekNvbnRhaW5lciwgJ2xlZnQgdG9wJyk7XG4gIGFwcGx5VHJhbnNmb3JtU2NhbGUodml6Q29udGFpbmVyLCAnc2NhbGUoJyArIHNjYWxlICsgJyknKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuc3Vic3RpdHV0ZUluc3RydWN0aW9uSW1hZ2VzID0gZnVuY3Rpb24oaHRtbFRleHQpIHtcbiAgaWYgKGh0bWxUZXh0KSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnNraW4uaW5zdHJ1Y3Rpb25zMkltYWdlU3Vic3RpdHV0aW9ucykge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5za2luLmluc3RydWN0aW9uczJJbWFnZVN1YnN0aXR1dGlvbnNbcHJvcF07XG4gICAgICB2YXIgc3Vic3RpdHV0aW9uSHRtbCA9ICc8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uc0ltYWdlQ29udGFpbmVyXCI+PGltZyBzcmM9XCInICsgdmFsdWUgKyAnXCIgY2xhc3M9XCJpbnN0cnVjdGlvbnNJbWFnZVwiLz48L3NwYW4+JztcbiAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxbJyArIHByb3AgKyAnXFxcXF0nLCAnZycpO1xuICAgICAgaHRtbFRleHQgPSBodG1sVGV4dC5yZXBsYWNlKHJlLCBzdWJzdGl0dXRpb25IdG1sKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbFRleHQ7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5lZGl0Q29kZSkge1xuICAgIHRocm93IFwiZ2V0Q29kZSgpIHJlcXVpcmVzIGVkaXRDb2RlXCI7XG4gIH1cbiAgaWYgKHRoaXMuaGlkZVNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0QmxvY2tzXztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgfVxufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5zZXRJY29uc0Zyb21Ta2luID0gZnVuY3Rpb24gKHNraW4pIHtcbiAgdGhpcy5pY29uID0gc2tpbi5zdGF0aWNBdmF0YXI7XG4gIHRoaXMuc21hbGxJY29uID0gc2tpbi5zbWFsbFN0YXRpY0F2YXRhcjtcbiAgdGhpcy53aW5JY29uID0gc2tpbi53aW5BdmF0YXI7XG4gIHRoaXMuZmFpbHVyZUljb24gPSBza2luLmZhaWx1cmVBdmF0YXI7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBwdXp6bGUgYmFjayB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAqIFNlYXJjaCBhbGlhc2VzOiBcIlN0YXJ0IE92ZXJcIiwgc3RhcnRPdmVyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gc2FtZSBjb25maWcgb2JqZWN0IHBhc3NlZCB0byBzdHVkaW9BcHAuaW5pdCgpLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhbmRsZUNsZWFyUHV6emxlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgaWYgKEJsb2NrbHkuZnVuY3Rpb25FZGl0b3IpIHtcbiAgICAgIEJsb2NrbHkuZnVuY3Rpb25FZGl0b3IuaGlkZUlmT3BlbigpO1xuICAgIH1cbiAgICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmNsZWFyKCk7XG4gICAgdGhpcy5zZXRTdGFydEJsb2Nrc18oY29uZmlnLCBmYWxzZSk7XG4gICAgaWYgKGNvbmZpZy5sZXZlbC5vcGVuRnVuY3Rpb25EZWZpbml0aW9uKSB7XG4gICAgICB0aGlzLm9wZW5GdW5jdGlvbkRlZmluaXRpb25fKGNvbmZpZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciByZXNldFZhbHVlID0gJyc7XG4gICAgaWYgKGNvbmZpZy5sZXZlbC5zdGFydEJsb2Nrcykge1xuICAgICAgLy8gRG9uJ3QgcGFzcyBDUkxGIHBhaXJzIHRvIGRyb3BsZXQgdW50aWwgdGhleSBmaXggQ1IgaGFuZGxpbmc6XG4gICAgICByZXNldFZhbHVlID0gY29uZmlnLmxldmVsLnN0YXJ0QmxvY2tzLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgfVxuICAgIC8vIFRPRE8gKGJidWNoYW5hbik6IFRoaXMgZ2V0VmFsdWUoKSBjYWxsIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBEcm9wbGV0IGJ1ZyxcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Ryb3BsZXQtZWRpdG9yL2Ryb3BsZXQvaXNzdWVzLzEzN1xuICAgIC8vIENhbGxpbmcgZ2V0VmFsdWUoKSB1cGRhdGVzIHRoZSBjYWNoZWQgYWNlIGVkaXRvciB2YWx1ZSwgd2hpY2ggY2FuIGJlXG4gICAgLy8gb3V0LW9mLWRhdGUgaW4gZHJvcGxldCBhbmQgY2F1c2UgYW4gaW5jb3JyZWN0IGVhcmx5LW91dC5cbiAgICAvLyBSZW1vdmUgdGhpcyBsaW5lIG9uY2UgdGhhdCBidWcgaXMgZml4ZWQgYW5kIG91ciBEcm9wbGV0IGxpYiBpcyB1cGRhdGVkLlxuICAgIHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUocmVzZXRWYWx1ZSk7XG4gIH1cbiAgaWYgKGNvbmZpZy5hZnRlckNsZWFyUHV6emxlKSB7XG4gICAgY29uZmlnLmFmdGVyQ2xlYXJQdXp6bGUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUUlVFIGlmIHRoZSBjdXJyZW50IGFwcCB1c2VzIGJsb2NrbHkgKGFzIG9wcG9zZWQgdG8gZWRpdENvZGUgb3IgYW5vdGhlclxuICogZWRpdG9yKVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5pc1VzaW5nQmxvY2tseSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudXNpbmdCbG9ja2x5Xztcbn07XG5cbi8qKlxuICpcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYW5kbGVTaGFyaW5nXyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIDEuIE1vdmUgdGhlIGJ1dHRvbnMsIDIuIEhpZGUgdGhlIHNsaWRlciBpbiB0aGUgc2hhcmUgcGFnZSBmb3IgbW9iaWxlLlxuICB2YXIgYmVsb3dWaXN1YWxpemF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JlbG93VmlzdWFsaXphdGlvbicpO1xuICBpZiAoZG9tLmlzTW9iaWxlKCkpIHtcbiAgICB2YXIgc2xpZGVyQ2VsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbGlkZXItY2VsbCcpO1xuICAgIGlmIChzbGlkZXJDZWxsKSB7XG4gICAgICBzbGlkZXJDZWxsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIGlmIChiZWxvd1Zpc3VhbGl6YXRpb24pIHtcbiAgICAgIHZhciB2aXN1YWxpemF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb24nKTtcbiAgICAgIGJlbG93VmlzdWFsaXphdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdmlzdWFsaXphdGlvbi5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMHB4JztcbiAgICB9XG4gIH1cblxuICAvLyBTaG93IGZsYXBweSB1cHNhbGUgb24gZGVza3RvcCBhbmQgbW9iaWxlLiAgU2hvdyBsZWFybiB1cHNhbGUgb25seSBvbiBkZXNrdG9wXG4gIHZhciB1cFNhbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaWYgKG9wdGlvbnMubWFrZVlvdXJPd24pIHtcbiAgICB1cFNhbGUuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvbWFrZVlvdXJPd24uaHRtbC5lanMnKSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1ha2VVcmw6IG9wdGlvbnMubWFrZVVybCxcbiAgICAgICAgbWFrZVN0cmluZzogb3B0aW9ucy5tYWtlU3RyaW5nLFxuICAgICAgICBtYWtlSW1hZ2U6IG9wdGlvbnMubWFrZUltYWdlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubm9QYWRkaW5nKSB7XG4gICAgICB1cFNhbGUuc3R5bGUubWFyZ2luTGVmdCA9ICcxMHB4JztcbiAgICB9XG4gICAgYmVsb3dWaXN1YWxpemF0aW9uLmFwcGVuZENoaWxkKHVwU2FsZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubWFrZVlvdXJPd24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdXBTYWxlLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2xlYXJuLmh0bWwuZWpzJykoe1xuICAgICAgYXNzZXRVcmw6IHRoaXMuYXNzZXRVcmxcbiAgICB9KTtcbiAgICBiZWxvd1Zpc3VhbGl6YXRpb24uYXBwZW5kQ2hpbGQodXBTYWxlKTtcbiAgfVxufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZW5kZXJTaGFyZUZvb3Rlcl8gPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgdmFyIGZvb3RlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmb290ZXJEaXYuc2V0QXR0cmlidXRlKCdpZCcsICdmb290ZXJEaXYnKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZvb3RlckRpdik7XG5cbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgaTE4bkRyb3Bkb3duOiAnJyxcbiAgICBjb3B5cmlnaHRJbkJhc2U6IGZhbHNlLFxuICAgIGNvcHlyaWdodFN0cmluZ3M6IGNvcHlyaWdodFN0cmluZ3MsXG4gICAgYmFzZU1vcmVNZW51U3RyaW5nOiB3aW5kb3cuZGFzaGJvYXJkLmkxOG4udCgnZm9vdGVyLmJ1aWx0X29uX2NvZGVfc3R1ZGlvJyksXG4gICAgYmFzZVN0eWxlOiB7XG4gICAgICBwYWRkaW5nTGVmdDogMCxcbiAgICAgIHdpZHRoOiAkKFwiI3Zpc3VhbGl6YXRpb25cIikud2lkdGgoKVxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiAnZGFyaycsXG4gICAgbWVudUl0ZW1zOiBbXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdmb290ZXIudHJ5X2hvdXJfb2ZfY29kZScpLFxuICAgICAgICBsaW5rOiAnaHR0cHM6Ly9jb2RlLm9yZy9sZWFybicsXG4gICAgICAgIG5ld1dpbmRvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGV4dDogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ2Zvb3Rlci5ob3dfaXRfd29ya3MnKSxcbiAgICAgICAgbGluazogbG9jYXRpb24uaHJlZiArIFwiL2VkaXRcIixcbiAgICAgICAgbmV3V2luZG93OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGV4dDogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ2Zvb3Rlci5jb3B5cmlnaHQnKSxcbiAgICAgICAgbGluazogJyMnLFxuICAgICAgICBjb3B5cmlnaHQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHdpbmRvdy5kYXNoYm9hcmQuaTE4bi50KCdmb290ZXIudG9zJyksXG4gICAgICAgIGxpbms6IFwiaHR0cHM6Ly9jb2RlLm9yZy90b3NcIixcbiAgICAgICAgbmV3V2luZG93OiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0ZXh0OiB3aW5kb3cuZGFzaGJvYXJkLmkxOG4udCgnZm9vdGVyLnByaXZhY3knKSxcbiAgICAgICAgbGluazogXCJodHRwczovL2NvZGUub3JnL3ByaXZhY3lcIixcbiAgICAgICAgbmV3V2luZG93OiB0cnVlXG4gICAgICB9XG4gICAgXSxcbiAgICBwaG9uZUZvb3RlcjogdHJ1ZVxuICB9O1xuXG4gIFJlYWN0LnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KHdpbmRvdy5kYXNoYm9hcmQuU21hbGxGb290ZXIsIHJlYWN0UHJvcHMpLFxuICAgIGZvb3RlckRpdik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdXJsIG9mIHBhdGggYXBwZW5kZWQgdG8gQkFTRV9VUkxcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5hc3NldFVybF8gPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodGhpcy5CQVNFX1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkaW9BcHAgQkFTRV9VUkwgaGFzIG5vdCBiZWVuIHNldC4gJyArXG4gICAgICAnQ2FsbCBjb25maWd1cmUoKSBmaXJzdCcpO1xuICB9XG4gIHJldHVybiB0aGlzLkJBU0VfVVJMICsgcGF0aDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHBsYXlpbmcgZmllbGQgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uIGFuZCBraWxsIGFueSBwZW5kaW5nXG4gKiBhbmltYXRpb24gdGFza3MuICBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIHJlcGxhY2VkIGJ5IGFuIGFwcGxpY2F0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRQbGF5T3BlbmluZ0FuaW1hdGlvbiBUcnVlIGlmIGFuIG9wZW5pbmcgYW5pbWF0aW9uIGlzXG4gKiAgIHRvIGJlIHBsYXllZC5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChzaG91bGRQbGF5T3BlbmluZ0FuaW1hdGlvbikge1xuICAvLyBUT0RPIChiYnVjaGFuYW4pOiBMb29rIGZvciBjb21vbiByZXNldCBsb2dpYyB3ZSBjYW4gcHVsbCBoZXJlXG4gIC8vIE92ZXJyaWRlIGluIGFwcCBzdWJjbGFzc1xufTtcblxuXG4vKipcbiAqIE92ZXJyaWRlIHRvIGNoYW5nZSBydW4gYmVoYXZpb3IuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUucnVuQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIFRvZ2dsZSB3aGV0aGVyIHJ1biBidXR0b24gb3IgcmVzZXQgYnV0dG9uIGlzIHNob3duXG4gKiBAcGFyYW0ge3N0cmluZ30gYnV0dG9uIEJ1dHRvbiB0byBzaG93LCBlaXRoZXIgXCJydW5cIiBvciBcInJlc2V0XCJcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS50b2dnbGVSdW5SZXNldCA9IGZ1bmN0aW9uKGJ1dHRvbikge1xuICB2YXIgc2hvd1J1biA9IChidXR0b24gPT09ICdydW4nKTtcbiAgaWYgKGJ1dHRvbiAhPT0gJ3J1bicgJiYgYnV0dG9uICE9PSAncmVzZXQnKSB7XG4gICAgdGhyb3cgXCJVbmV4cGVjdGVkIGlucHV0XCI7XG4gIH1cblxuICB2YXIgcnVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3J1bkJ1dHRvbicpO1xuICB2YXIgcmVzZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXRCdXR0b24nKTtcbiAgcnVuLnN0eWxlLmRpc3BsYXkgPSBzaG93UnVuID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZSc7XG4gIHJ1bi5kaXNhYmxlZCA9ICFzaG93UnVuO1xuICByZXNldC5zdHlsZS5kaXNwbGF5ID0gIXNob3dSdW4gPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJztcbiAgcmVzZXQuZGlzYWJsZWQgPSBzaG93UnVuO1xuXG4gIC8vIFRvZ2dsZSBzb2Z0LWJ1dHRvbnMgKGFsbCBoYXZlIHRoZSAnYXJyb3cnIGNsYXNzIHNldCk6XG4gICQoJy5hcnJvdycpLnByb3AoXCJkaXNhYmxlZFwiLCBzaG93UnVuKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gYXNzb2NpYXRlIGEgc2V0IG9mIGF1ZGlvIGZpbGVzIHRvIGEgZ2l2ZW4gbmFtZVxuICogSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBjZG9Tb3VuZHMgZG9lcyBub3QgZXhpc3QsIGUuZy4gaW4gdGVzdHNcbiAqIGFuZCBncnVudCBkZXYgcHJldmlldyBtb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgc291bmQgY29uZmlndXJhdGlvblxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJlZ2lzdGVyQXVkaW8gPSBmdW5jdGlvbihhdWRpb0NvbmZpZykge1xuICBpZiAoIXRoaXMuY2RvU291bmRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jZG9Tb3VuZHMucmVnaXN0ZXIoYXVkaW9Db25maWcpO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBhc3NvY2lhdGUgYSBzZXQgb2YgYXVkaW8gZmlsZXMgdG8gYSBnaXZlbiBuYW1lXG4gKiBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGNkb1NvdW5kcyBkb2VzIG5vdCBleGlzdCwgZS5nLiBpbiB0ZXN0c1xuICogYW5kIGdydW50IGRldiBwcmV2aWV3IG1vZGVcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGZpbGVuYW1lcyBmaWxlIHBhdGhzIGZvciBzb3VuZHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIElEIHRvIGFzc29jaWF0ZSBzb3VuZCBlZmZlY3Qgd2l0aFxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmxvYWRBdWRpbyA9IGZ1bmN0aW9uKGZpbGVuYW1lcywgbmFtZSkge1xuICBpZiAoIXRoaXMuY2RvU291bmRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jZG9Tb3VuZHMucmVnaXN0ZXJCeUZpbGVuYW1lc0FuZElEKGZpbGVuYW1lcywgbmFtZSk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHBsYXkgYSBzb3VuZCBlZmZlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHNvdW5kIElEXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBmb3Igc291bmQgcGxheWJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnZvbHVtZSB2YWx1ZSBiZXR3ZWVuIDAuMCBhbmQgMS4wIHNwZWNpZnlpbmcgdm9sdW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5vbkVuZGVkXVxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnBsYXlBdWRpbyA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLmNkb1NvdW5kcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7dm9sdW1lOiAwLjV9O1xuICB2YXIgbmV3T3B0aW9ucyA9IHV0aWxzLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gIHRoaXMuY2RvU291bmRzLnBsYXkobmFtZSwgbmV3T3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN0b3BzIGxvb3BpbmcgYSBnaXZlbiBzb3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSUQgb2Ygc291bmRcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5zdG9wTG9vcGluZ0F1ZGlvID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuY2RvU291bmRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jZG9Tb3VuZHMuc3RvcExvb3BpbmdBdWRpbyhuYW1lKTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIEJsb2NrbHkuIFBhcmFtZXRlcnMgYXJlXG4qIG9wdGlvbmFsIGFuZCBpbmNsdWRlOlxuKiAgLSB7c3RyaW5nfSBwYXRoIFRoZSByb290IHBhdGggdG8gdGhlIC9hcHBzIGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gdGhlXG4qICAgIHRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggdGhpcyBzY3JpcHQgaXMgbG9jYXRlZC5cbiogIC0ge2Jvb2xlYW59IHJ0bCBUcnVlIGlmIHRoZSBjdXJyZW50IGxhbmd1YWdlIHJpZ2h0IHRvIGxlZnQuXG4qICAtIHtEb21FbGVtZW50fSB0b29sYm94IFRoZSBlbGVtZW50IGluIHdoaWNoIHRvIGluc2VydCB0aGUgdG9vbGJveCxcbiogICAgZGVmYXVsdHMgdG8gdGhlIGVsZW1lbnQgd2l0aCAndG9vbGJveCcuXG4qICAtIHtib29sZWFufSB0cmFzaGNhbiBUcnVlIGlmIHRoZSB0cmFzaGNhbiBzaG91bGQgYmUgZGlzcGxheWVkLCBkZWZhdWx0cyB0b1xuKiAgICB0cnVlLlxuKiBAcGFyYW0ge0VsZW1lbnR9IGRpdiBUaGUgcGFyZW50IGRpdiBpbiB3aGljaCB0byBpbnNlcnQgQmxvY2tseS5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGRpdiwgb3B0aW9ucykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYXNzZXRVcmw6IHRoaXMuYXNzZXRVcmwsXG4gICAgcnRsOiB0aGlzLmlzUnRsKCksXG4gICAgdG9vbGJveDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2xib3gnKSxcbiAgICB0cmFzaGNhbjogdHJ1ZSxcbiAgICBjdXN0b21TaW1wbGVEaWFsb2c6IHRoaXMuZmVlZGJhY2tfLnNob3dTaW1wbGVEaWFsb2cuYmluZCh0aGlzLmZlZWRiYWNrXyxcbiAgICAgICAgdGhpcy5EaWFsb2cpXG4gIH07XG4gIEJsb2NrbHkuaW5qZWN0KGRpdiwgdXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKSwgdGhpcy5jZG9Tb3VuZHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgSFRNTCBwYWdlIGlzIGluIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UgbW9kZS5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5pc1J0bCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGlmIChoZWFkICYmIGhlYWQucGFyZW50RWxlbWVudCkge1xuICAgIHZhciBkaXIgPSBoZWFkLnBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKTtcbiAgICByZXR1cm4gKGRpciAmJiBkaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IExvY2FsZSBkaXJlY3Rpb24gc3RyaW5nIGJhc2VkIG9uIGFwcCBkaXJlY3Rpb24uXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUubG9jYWxlRGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5pc1J0bCgpID8gJ3J0bCcgOiAnbHRyJyk7XG59O1xuXG4vKipcbiogSW5pdGlhbGl6ZSBCbG9ja2x5IGZvciBhIHJlYWRvbmx5IGlmcmFtZS4gIENhbGxlZCBvbiBwYWdlIGxvYWQuIE5vIHNvdW5kcy5cbiogWE1MIGFyZ3VtZW50IG1heSBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgY29uc29sZSB3aXRoOlxuKiBCbG9ja2x5LlhtbC5kb21Ub1RleHQoQmxvY2tseS5YbWwuYmxvY2tTcGFjZVRvRG9tKEJsb2NrbHkubWFpbkJsb2NrU3BhY2UpKS5zbGljZSg1LCAtNilcbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmluaXRSZWFkb25seSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQmxvY2tseS5pbmplY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVXb3Jrc3BhY2UnKSwge1xuICAgIGFzc2V0VXJsOiB0aGlzLmFzc2V0VXJsLFxuICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgIHJ0bDogdGhpcy5pc1J0bCgpLFxuICAgIHNjcm9sbGJhcnM6IGZhbHNlXG4gIH0pO1xuICB0aGlzLmxvYWRCbG9ja3Mob3B0aW9ucy5ibG9ja3MpO1xufTtcblxuLyoqXG4qIExvYWQgdGhlIGVkaXRvciB3aXRoIGJsb2Nrcy5cbiogQHBhcmFtIHtzdHJpbmd9IGJsb2Nrc1htbCBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIGJsb2Nrcy5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLmxvYWRCbG9ja3MgPSBmdW5jdGlvbihibG9ja3NYbWwpIHtcbiAgdmFyIHhtbCA9IHBhcnNlWG1sRWxlbWVudChibG9ja3NYbWwpO1xuICBCbG9ja2x5LlhtbC5kb21Ub0Jsb2NrU3BhY2UoQmxvY2tseS5tYWluQmxvY2tTcGFjZSwgeG1sKTtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBzcGVjaWZpZWQgYXJyYW5nZW1lbnQgdG8gdG9wIHN0YXJ0QmxvY2tzLiBJZiBhbnlcbiogaW5kaXZpZHVhbCBibG9ja3MgaGF2ZSB4IG9yIHkgcHJvcGVydGllcyBzZXQgaW4gdGhlIFhNTCwgdGhvc2UgdmFsdWVzXG4qIHRha2UgcHJpb3JpdHkuIElmIG5vIGFycmFuZ2VtZW50IGZvciBhIHBhcnRpY3VsYXIgYmxvY2sgdHlwZSBpc1xuKiBzcGVjaWZpZWQsIGJsb2NrcyBhcmUgYXV0b21hdGljYWxseSBwb3NpdGlvbmVkIGJ5IEJsb2NrbHkuXG4qXG4qIE5vdGUgdGhhdCwgY3VycmVudGx5LCBvbmx5IGJvdW5jZSBhbmQgZmxhcHB5IHVzZSBhcnJhbmdlbWVudHMuXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBzdGFydEJsb2NrcyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc3RhcnQgYmxvY2tzIHhtbC5cbiogQHBhcmFtIHtPYmplY3QuPE9iamVjdD59IGFycmFuZ2VtZW50IEEgbWFwIGZyb20gYmxvY2sgdHlwZSB0byBwb3NpdGlvbi5cbiogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc3RhcnQgYmxvY2tzIHhtbCwgaW5jbHVkaW5nXG4qICAgIGJsb2NrIHBvc2l0aW9uLlxuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuYXJyYW5nZUJsb2NrUG9zaXRpb24gPSBmdW5jdGlvbihzdGFydEJsb2NrcywgYXJyYW5nZW1lbnQpIHtcblxuICB2YXIgdHlwZSwgeG1sQ2hpbGQ7XG5cbiAgdmFyIHhtbCA9IHBhcnNlWG1sRWxlbWVudChzdGFydEJsb2Nrcyk7XG5cbiAgdmFyIHhtbENoaWxkTm9kZXMgPSB4bWwuY2hpbGROb2RlcyB8fCBbXTtcbiAgYXJyYW5nZW1lbnQgPSBhcnJhbmdlbWVudCB8fCB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHhtbENoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB4bWxDaGlsZCA9IHhtbENoaWxkTm9kZXNbaV07XG5cbiAgICAvLyBPbmx5IGxvb2sgYXQgZWxlbWVudCBub2Rlc1xuICAgIGlmICh4bWxDaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gbG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIHByZWRlZmluZWQgYXJyYW5nZW1lbnQgZm9yIHRoaXMgdHlwZVxuICAgICAgdHlwZSA9IHhtbENoaWxkLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgaWYgKGFycmFuZ2VtZW50W3R5cGVdKSB7XG4gICAgICAgIGlmIChhcnJhbmdlbWVudFt0eXBlXS54ICYmICF4bWxDaGlsZC5oYXNBdHRyaWJ1dGUoJ3gnKSkge1xuICAgICAgICAgIHhtbENoaWxkLnNldEF0dHJpYnV0ZSgneCcsIGFycmFuZ2VtZW50W3R5cGVdLngpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJhbmdlbWVudFt0eXBlXS55ICYmICF4bWxDaGlsZC5oYXNBdHRyaWJ1dGUoJ3knKSkge1xuICAgICAgICAgIHhtbENoaWxkLnNldEF0dHJpYnV0ZSgneScsIGFycmFuZ2VtZW50W3R5cGVdLnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBCbG9ja2x5LlhtbC5kb21Ub1RleHQoeG1sKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuY3JlYXRlTW9kYWxEaWFsb2cgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMuRGlhbG9nID0gdXRpbHMudmFsdWVPcihvcHRpb25zLkRpYWxvZywgdGhpcy5EaWFsb2cpO1xuICByZXR1cm4gdGhpcy5mZWVkYmFja18uY3JlYXRlTW9kYWxEaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNpbXBsZSBwYXNzdGhyb3VnaCB0byBBdXRob3JlZEhpbnRzLmRpc3BsYXlNaXNzaW5nQmxvY2tIaW50c1xuICogQHBhcmFtIHtTdHJpbmdbXX0gYmxvY2tzIEFuIGFycmF5IG9mIFhNTCBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICAgICBtaXNzaW5nIHJlY29tbWVuZGVkIEJsb2NrbHkgQmxvY2tzIGZvciB3aGljaCB3ZSB3YW50IHRvXG4gKiAgICAgICAgZGlzcGxheSBoaW50cy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5kaXNwbGF5TWlzc2luZ0Jsb2NrSGludHMgPSBmdW5jdGlvbiAoYmxvY2tzKSB7XG4gIHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLmRpc3BsYXlNaXNzaW5nQmxvY2tIaW50cyhibG9ja3MpO1xufTtcblxuU3R1ZGlvQXBwLnByb3RvdHlwZS5vblJlcG9ydENvbXBsZXRlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHRoaXMuYXV0aG9yZWRIaW50c0NvbnRyb2xsZXJfLmZpbmlzaEhpbnRzKHJlc3BvbnNlKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUuc2hvd0luc3RydWN0aW9uc18gPSBmdW5jdGlvbihsZXZlbCwgYXV0b0Nsb3NlLCBzaG93SGludHMpIHtcbiAgdmFyIGluc3RydWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgcmVuZGVyZWRNYXJrZG93bjtcbiAgdmFyIGhlYWRlckVsZW1lbnQ7XG5cbiAgdmFyIHB1enpsZVRpdGxlID0gbXNnLnB1enpsZVRpdGxlKHtcbiAgICBzdGFnZV90b3RhbDogbGV2ZWwuc3RhZ2VfdG90YWwsXG4gICAgcHV6emxlX251bWJlcjogbGV2ZWwucHV6emxlX251bWJlclxuICB9KTtcblxuICB2YXIgbWFya2Rvd25Nb2RlID0gd2luZG93Lm1hcmtlZCAmJiBsZXZlbC5tYXJrZG93bkluc3RydWN0aW9ucyAmJiB0aGlzLkxPQ0FMRSA9PT0gRU5HTElTSF9MT0NBTEU7XG5cbiAgaWYgKG1hcmtkb3duTW9kZSkge1xuICAgIHZhciBtYXJrZG93bldpdGhJbWFnZXMgPSB0aGlzLnN1YnN0aXR1dGVJbnN0cnVjdGlvbkltYWdlcyhsZXZlbC5tYXJrZG93bkluc3RydWN0aW9ucyk7XG4gICAgcmVuZGVyZWRNYXJrZG93biA9IG1hcmtlZChtYXJrZG93bldpdGhJbWFnZXMpO1xuICAgIGluc3RydWN0aW9uc0Rpdi5jbGFzc05hbWUgKz0gJyBtYXJrZG93bi1pbnN0cnVjdGlvbnMtY29udGFpbmVyJztcbiAgICBoZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcbiAgICBoZWFkZXJFbGVtZW50LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1sZXZlbC1oZWFkZXItdGV4dCBkaWFsb2ctdGl0bGUnO1xuICAgIGhlYWRlckVsZW1lbnQuaW5uZXJIVE1MID0gcHV6emxlVGl0bGU7XG4gICAgaWYgKCF0aGlzLmljb24pIHtcbiAgICAgIGhlYWRlckVsZW1lbnQuY2xhc3NOYW1lICs9ICcgbm8tbW9kYWwtaWNvbic7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dGhvcmVkSGludHM7XG4gIGlmIChzaG93SGludHMpIHtcbiAgICBhdXRob3JlZEhpbnRzID0gdGhpcy5hdXRob3JlZEhpbnRzQ29udHJvbGxlcl8uZ2V0SGludHNEaXNwbGF5KCk7XG4gIH1cblxuICB2YXIgaW5zdHJ1Y3Rpb25zQ29udGVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5zdHJ1Y3Rpb25zLCB7XG4gICAgcHV6emxlVGl0bGU6IHB1enpsZVRpdGxlLFxuICAgIGluc3RydWN0aW9uczogdGhpcy5zdWJzdGl0dXRlSW5zdHJ1Y3Rpb25JbWFnZXMobGV2ZWwuaW5zdHJ1Y3Rpb25zKSxcbiAgICBpbnN0cnVjdGlvbnMyOiB0aGlzLnN1YnN0aXR1dGVJbnN0cnVjdGlvbkltYWdlcyhsZXZlbC5pbnN0cnVjdGlvbnMyKSxcbiAgICByZW5kZXJlZE1hcmtkb3duOiByZW5kZXJlZE1hcmtkb3duLFxuICAgIG1hcmtkb3duQ2xhc3NpY01hcmdpbnM6IGxldmVsLm1hcmtkb3duSW5zdHJ1Y3Rpb25zV2l0aENsYXNzaWNNYXJnaW5zLFxuICAgIGFuaUdpZlVSTDogbGV2ZWwuYW5pR2lmVVJMLFxuICAgIGF1dGhvcmVkSGludHM6IGF1dGhvcmVkSGludHNcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGEgZGl2IHRvIGV2ZW50dWFsbHkgaG9sZCB0aGlzIGNvbnRlbnQsIGFuZCBhZGQgaXQgdG8gdGhlXG4gIC8vIG92ZXJhbGwgY29udGFpbmVyLiBXZSBkb24ndCB3YW50IHRvIHJlbmRlciBkaXJlY3RseSBpbnRvIHRoZVxuICAvLyBjb250YWluZXIganVzdCB5ZXQsIGJlY2F1c2Ugb3VyIFJlYWN0IGNvbXBvbmVudCBjb3VsZCBjb250YWluIHNvbWVcbiAgLy8gZWxlbWVudHMgdGhhdCBkb24ndCB3YW50IHRvIGJlIHJlbmRlcmVkIHVudGlsIHRoZXkgYXJlIGluIHRoZSBET01cbiAgdmFyIGluc3RydWN0aW9uc1JlYWN0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGluc3RydWN0aW9uc1JlYWN0Q29udGFpbmVyLmNsYXNzTmFtZT0naW5zdHJ1Y3Rpb25zLWNvbnRhaW5lcic7XG4gIGluc3RydWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChpbnN0cnVjdGlvbnNSZWFjdENvbnRhaW5lcik7XG5cbiAgdmFyIGJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9ucy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b25zLmh0bWwuZWpzJykoe1xuICAgIGRhdGE6IHtcbiAgICAgIG9rOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpbnN0cnVjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG5cbiAgLy8gSWYgdGhlcmUgaXMgYW4gaW5zdHJ1Y3Rpb25zIGJsb2NrIG9uIHRoZSBzY3JlZW4sIHdlIHdhbnQgdGhlIGluc3RydWN0aW9ucyBkaWFsb2cgdG9cbiAgLy8gc2hyaW5rIGRvd24gdG8gdGhhdCBpbnN0cnVjdGlvbnMgYmxvY2sgd2hlbiBpdCdzIGRpc21pc3NlZC5cbiAgLy8gV2UgdGhlbiB3YW50IHRvIGZsYXNoIHRoZSBpbnN0cnVjdGlvbnMgYmxvY2suXG4gIHZhciBoaWRlT3B0aW9ucyA9IG51bGw7XG4gIHZhciBlbmRUYXJnZXRTZWxlY3RvciA9IFwiI2J1YmJsZVwiO1xuXG4gIGlmICgkKGVuZFRhcmdldFNlbGVjdG9yKS5sZW5ndGgpIHtcbiAgICBoaWRlT3B0aW9ucyA9IHt9O1xuICAgIGhpZGVPcHRpb25zLmVuZFRhcmdldCA9IGVuZFRhcmdldFNlbGVjdG9yO1xuICB9XG5cbiAgdmFyIGhpZGVGbiA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAvLyBNb21lbnRhcmlseSBmbGFzaCB0aGUgaW5zdHJ1Y3Rpb24gYmxvY2sgd2hpdGUgdGhlbiBiYWNrIHRvIHJlZ3VsYXIuXG4gICAgaWYgKCQoZW5kVGFyZ2V0U2VsZWN0b3IpLmxlbmd0aCkge1xuICAgICAgJChlbmRUYXJnZXRTZWxlY3RvcikuY3NzKHtcImJhY2tncm91bmQtY29sb3JcIjpcInJnYmEoMjU1LDI1NSwyNTUsMSlcIn0pXG4gICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgIC5hbmltYXRlKHtcImJhY2tncm91bmQtY29sb3JcIjpcInJnYmEoMCwwLDAsMClcIn0sMTAwMCk7XG4gICAgfVxuICAgIC8vIFNldCBmb2N1cyB0byBhY2UgZWRpdG9yIHdoZW4gaW5zdHJ1Y3Rpb25zIGNsb3NlOlxuICAgIGlmICh0aGlzLmVkaXRDb2RlICYmIHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5jdXJyZW50bHlVc2luZ0Jsb2Nrcykge1xuICAgICAgdGhpcy5lZGl0b3IuYWNlRWRpdG9yLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLy8gRmlyZSBhIGN1c3RvbSBldmVudCBvbiB0aGUgZG9jdW1lbnQgc28gdGhhdCBvdGhlciBjb2RlIGNhbiByZXNwb25kXG4gICAgLy8gdG8gaW5zdHJ1Y3Rpb25zIGJlaW5nIGNsb3NlZC5cbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2luc3RydWN0aW9uc0hpZGRlbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLmluc3RydWN0aW9uc0RpYWxvZyA9IHRoaXMuY3JlYXRlTW9kYWxEaWFsb2coe1xuICAgIG1hcmtkb3duTW9kZTogbWFya2Rvd25Nb2RlLFxuICAgIGNvbnRlbnREaXY6IGluc3RydWN0aW9uc0RpdixcbiAgICBpY29uOiB0aGlzLmljb24sXG4gICAgZGVmYXVsdEJ0blNlbGVjdG9yOiAnI29rLWJ1dHRvbicsXG4gICAgb25IaWRkZW46IGhpZGVGbixcbiAgICBzY3JvbGxDb250ZW50OiB0cnVlLFxuICAgIHNjcm9sbGFibGVTZWxlY3RvcjogXCIuaW5zdHJ1Y3Rpb25zLWNvbnRhaW5lclwiLFxuICAgIGhlYWRlcjogaGVhZGVyRWxlbWVudFxuICB9KTtcblxuICAvLyBOb3cgdGhhdCBvdXIgZWxlbWVudHMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIERPTSwgd2UgY2FuXG4gIC8vIHJlbmRlciBpbiBvdXIgcmVhY3QgY29tcG9uZW50c1xuICAkKHRoaXMuaW5zdHJ1Y3Rpb25zRGlhbG9nLmRpdikub24oJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3QucmVuZGVyKGluc3RydWN0aW9uc0NvbnRlbnQsIGluc3RydWN0aW9uc1JlYWN0Q29udGFpbmVyKTtcbiAgfSk7XG5cbiAgaWYgKGF1dG9DbG9zZSkge1xuICAgIHNldFRpbWVvdXQoXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnNEaWFsb2cuaGlkZSgpO1xuICAgIH0sIHRoaXMpLCAzMjAwMCk7XG4gIH1cblxuICB2YXIgb2theUJ1dHRvbiA9IGJ1dHRvbnMucXVlcnlTZWxlY3RvcignI29rLWJ1dHRvbicpO1xuICBpZiAob2theUJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQob2theUJ1dHRvbiwgXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zRGlhbG9nKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zRGlhbG9nLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG4gIH1cblxuICB0aGlzLmluc3RydWN0aW9uc0RpYWxvZy5zaG93KHtoaWRlT3B0aW9uczogaGlkZU9wdGlvbnN9KTtcblxuICBpZiAocmVuZGVyZWRNYXJrZG93bikge1xuICAgIC8vIHByb2Nlc3MgPGRldGFpbHM+IHRhZ3Mgd2l0aCBwb2x5ZmlsbCBqUXVlcnkgcGx1Z2luXG4gICAgJCgnZGV0YWlscycpLmRldGFpbHMoKTtcbiAgfVxuXG4gIC8vIEZpcmUgYSBjdXN0b20gZXZlbnQgb24gdGhlIGRvY3VtZW50IHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gcmVzcG9uZFxuICAvLyB0byBpbnN0cnVjdGlvbnMgYmVpbmcgc2hvd24uXG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICBldmVudC5pbml0RXZlbnQoJ2luc3RydWN0aW9uc1Nob3duJywgdHJ1ZSwgdHJ1ZSk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblxuLyoqXG4qICBSZXNpemVzIHRoZSBibG9ja2x5IHdvcmtzcGFjZS5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3Jrc3BhY2VXaWR0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlV29ya3NwYWNlJykuY2xpZW50V2lkdGg7XG5cbiAgLy8gS2VlcCBibG9ja3Mgc3RhdGljIHJlbGF0aXZlIHRvIHRoZSByaWdodCBlZGdlIGluIFJUTCBtb2RlXG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkgJiYgQmxvY2tseS5SVEwpIHtcbiAgICBpZiAodGhpcy5sYXN0V29ya3NwYWNlV2lkdGggJiYgKHRoaXMubGFzdFdvcmtzcGFjZVdpZHRoICE9PSB3b3Jrc3BhY2VXaWR0aCkpIHtcbiAgICAgIHZhciBibG9ja09mZnNldCA9IHdvcmtzcGFjZVdpZHRoIC0gdGhpcy5sYXN0V29ya3NwYWNlV2lkdGg7XG4gICAgICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldFRvcEJsb2NrcygpLmZvckVhY2goZnVuY3Rpb24gKHRvcEJsb2NrKSB7XG4gICAgICAgIHRvcEJsb2NrLm1vdmVCeShibG9ja09mZnNldCwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5sYXN0V29ya3NwYWNlV2lkdGggPSB3b3Jrc3BhY2VXaWR0aDtcblxuICAvLyBEcm9wbGV0IHRvb2xib3ggd2lkdGggdmFyaWVzIGFzIHRoZSB3aW5kb3cgc2l6ZSBjaGFuZ2VzLCBzbyByZWZyZXNoOlxuICB0aGlzLnJlc2l6ZVRvb2xib3hIZWFkZXIoKTtcblxuICAvLyBDb250ZW50IGJlbG93IHZpc3VhbGl6YXRpb24gaXMgYSByZXNpemluZyBzY3JvbGwgYXJlYSBpbiBwaW5uZWQgbW9kZVxuICBvblJlc2l6ZVNtYWxsRm9vdGVyKCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGNvbnRlbnQgYXJlYSBiZWxvdyB0aGUgdmlzdWFsaXphdGlvbiBpbiBwaW5uZWQgKHZpZXdwb3J0IGhlaWdodClcbiAqIHZpZXcgbW9kZS5cbiAqL1xuZnVuY3Rpb24gcmVzaXplUGlubmVkQmVsb3dWaXN1YWxpemF0aW9uQXJlYSgpIHtcbiAgdmFyIHBpbm5lZEJlbG93VmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAnI3Zpc3VhbGl6YXRpb25Db2x1bW4ucGluX2JvdHRvbSAjYmVsb3dWaXN1YWxpemF0aW9uJyk7XG4gIGlmICghcGlubmVkQmVsb3dWaXN1YWxpemF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBsYXlTcGFjZUhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGF5U3BhY2VIZWFkZXInKTtcbiAgdmFyIHZpc3VhbGl6YXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbicpO1xuICB2YXIgZ2FtZUJ1dHRvbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZUJ1dHRvbnMnKTtcbiAgdmFyIHNtYWxsRm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BhZ2Utc21hbGwtZm9vdGVyIC5zbWFsbC1mb290ZXItYmFzZScpO1xuXG4gIHZhciB0b3AgPSAwO1xuICBpZiAocGxheVNwYWNlSGVhZGVyKSB7XG4gICAgdG9wICs9ICQocGxheVNwYWNlSGVhZGVyKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgfVxuXG4gIGlmICh2aXN1YWxpemF0aW9uKSB7XG4gICAgdG9wICs9ICQodmlzdWFsaXphdGlvbikub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gIH1cblxuICBpZiAoZ2FtZUJ1dHRvbnMpIHtcbiAgICB0b3AgKz0gJChnYW1lQnV0dG9ucykub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gIH1cblxuICB2YXIgYm90dG9tID0gMDtcbiAgaWYgKHNtYWxsRm9vdGVyKSB7XG4gICAgdmFyIGNvZGVBcHAgPSAkKCcjY29kZUFwcCcpO1xuICAgIGJvdHRvbSArPSAkKHNtYWxsRm9vdGVyKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAvLyBGb290ZXIgaXMgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LCBub3QgY29kZUFwcCwgc28gd2UgbmVlZCB0b1xuICAgIC8vIHJlbW92ZSB0aGUgY29kZUFwcCBib3R0b20gb2Zmc2V0IHRvIGdldCB0aGUgY29ycmVjdCBtYXJnaW4uXG4gICAgYm90dG9tIC09IHBhcnNlSW50KGNvZGVBcHAuY3NzKCdib3R0b20nKSwgMTApO1xuICB9XG5cbiAgcGlubmVkQmVsb3dWaXN1YWxpemF0aW9uLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gIHBpbm5lZEJlbG93VmlzdWFsaXphdGlvbi5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xufVxuXG4vKipcbiAqIERlYm91bmNlZCBvblJlc2l6ZSBvcGVyYXRpb25zIHRoYXQgdXBkYXRlIHRoZSBsYXlvdXQgdG8gc3VwcG9ydCBzaXppbmdcbiAqIHRvIHZpZXdwb3J0IGhlaWdodCBhbmQgdXNpbmcgdGhlIHNtYWxsIGZvb3Rlci5cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIG9uUmVzaXplU21hbGxGb290ZXIgPSBfLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgcmVzaXplUGlubmVkQmVsb3dWaXN1YWxpemF0aW9uQXJlYSgpO1xufSwgMTApO1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLm9uTW91c2VEb3duVml6UmVzaXplQmFyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIFdoZW4gd2Ugc2VlIGEgbW91c2UgZG93biBpbiB0aGUgcmVzaXplIGJhciwgc3RhcnQgdHJhY2tpbmcgbW91c2UgbW92ZXM6XG5cbiAgaWYgKCF0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKSB7XG4gICAgdGhpcy5vbk1vdXNlTW92ZUJvdW5kSGFuZGxlciA9IF8uYmluZCh0aGlzLm9uTW91c2VNb3ZlVml6UmVzaXplQmFyLCB0aGlzKTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVCb3VuZEhhbmRsZXIpO1xuICAgIHRoaXMubW91c2VNb3ZlVG91Y2hFdmVudE5hbWUgPSBkb20uZ2V0VG91Y2hFdmVudE5hbWUoJ21vdXNlbW92ZScpO1xuICAgIGlmICh0aGlzLm1vdXNlTW92ZVRvdWNoRXZlbnROYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5tb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybVNjYWxlVG9DaGlsZHJlbihlbGVtZW50LCBzY2FsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBseVRyYW5zZm9ybVNjYWxlKGVsZW1lbnQuY2hpbGRyZW5baV0sIHNjYWxlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1TY2FsZShlbGVtZW50LCBzY2FsZSkge1xuICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHNjYWxlO1xuICBlbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtID0gc2NhbGU7XG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc2NhbGU7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybU9yaWdpbihlbGVtZW50LCBvcmlnaW4pIHtcbiAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gIGVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xufVxuXG4vKipcbiogIEhhbmRsZSBtb3VzZSBtb3ZlcyB3aGlsZSBkcmFnZ2luZyB0aGUgdmlzdWFsaXphdGlvbiByZXNpemUgYmFyLiBXZSBzZXRcbiogIHN0eWxlcyBvbiBlYWNoIG9mIHRoZSBlbGVtZW50cyBkaXJlY3RseSwgb3ZlcnJpZGluZyB0aGUgbm9ybWFsIHJlc3BvbnNpdmVcbiogIGNsYXNzZXMgdGhhdCB3b3VsZCB0eXBpY2FsbHkgYWRqdXN0IHdpZHRoIGFuZCBzY2FsZS5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLm9uTW91c2VNb3ZlVml6UmVzaXplQmFyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciB2aXN1YWxpemF0aW9uUmVzaXplQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25SZXNpemVCYXInKTtcblxuICB2YXIgcmVjdCA9IHZpc3VhbGl6YXRpb25SZXNpemVCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBvZmZzZXQ7XG4gIHZhciBuZXdWaXpXaWR0aDtcbiAgaWYgKHRoaXMuaXNSdGwoKSkge1xuICAgIG9mZnNldCA9IHdpbmRvdy5pbm5lcldpZHRoIC1cbiAgICAgICh3aW5kb3cucGFnZVhPZmZzZXQgKyByZWN0LmxlZnQgKyAocmVjdC53aWR0aCAvIDIpKSAtXG4gICAgICBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh2aXN1YWxpemF0aW9uUmVzaXplQmFyKS5yaWdodCwgMTApO1xuICAgIG5ld1ZpeldpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gZXZlbnQucGFnZVgpIC0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHdpbmRvdy5wYWdlWE9mZnNldCArIHJlY3QubGVmdCArIChyZWN0LndpZHRoIC8gMikgLVxuICAgICAgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodmlzdWFsaXphdGlvblJlc2l6ZUJhcikubGVmdCwgMTApO1xuICAgIG5ld1ZpeldpZHRoID0gZXZlbnQucGFnZVggLSBvZmZzZXQ7XG4gIH1cbiAgdGhpcy5yZXNpemVWaXN1YWxpemF0aW9uKG5ld1ZpeldpZHRoKTtcbn07XG5cbi8qKlxuICogUmVzaXplIHRoZSB2aXN1YWxpemF0aW9uIHRvIHRoZSBnaXZlbiB3aWR0aFxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJlc2l6ZVZpc3VhbGl6YXRpb24gPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdmFyIGNvZGVXb3Jrc3BhY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVdvcmtzcGFjZScpO1xuICB2YXIgdmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uJyk7XG4gIHZhciB2aXN1YWxpemF0aW9uUmVzaXplQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25SZXNpemVCYXInKTtcbiAgdmFyIHZpc3VhbGl6YXRpb25Db2x1bW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXphdGlvbkNvbHVtbicpO1xuICB2YXIgdmlzdWFsaXphdGlvbkVkaXRvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uRWRpdG9yJyk7XG5cbiAgdmFyIG9sZFZpeldpZHRoID0gJCh2aXN1YWxpemF0aW9uQ29sdW1uKS53aWR0aCgpO1xuICB2YXIgbmV3Vml6V2lkdGggPSBNYXRoLm1heCh0aGlzLm1pblZpc3VhbGl6YXRpb25XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLm1heFZpc3VhbGl6YXRpb25XaWR0aCwgd2lkdGgpKTtcbiAgdmFyIG5ld1ZpeldpZHRoU3RyaW5nID0gbmV3Vml6V2lkdGggKyAncHgnO1xuICB2YXIgbmV3Vml6SGVpZ2h0U3RyaW5nID0gKG5ld1ZpeldpZHRoIC8gdGhpcy52aXpBc3BlY3RSYXRpbykgKyAncHgnO1xuICB2YXIgdml6U2lkZUJvcmRlcldpZHRoID0gdmlzdWFsaXphdGlvbi5vZmZzZXRXaWR0aCAtIHZpc3VhbGl6YXRpb24uY2xpZW50V2lkdGg7XG5cbiAgaWYgKHRoaXMuaXNSdGwoKSkge1xuICAgIHZpc3VhbGl6YXRpb25SZXNpemVCYXIuc3R5bGUucmlnaHQgPSBuZXdWaXpXaWR0aFN0cmluZztcbiAgICBjb2RlV29ya3NwYWNlLnN0eWxlLnJpZ2h0ID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gIH0gZWxzZSB7XG4gICAgdmlzdWFsaXphdGlvblJlc2l6ZUJhci5zdHlsZS5sZWZ0ID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gICAgY29kZVdvcmtzcGFjZS5zdHlsZS5sZWZ0ID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gIH1cbiAgdmlzdWFsaXphdGlvblJlc2l6ZUJhci5zdHlsZS5saW5lSGVpZ2h0ID0gbmV3Vml6SGVpZ2h0U3RyaW5nO1xuICAvLyBBZGQgZXh0cmEgd2lkdGggdG8gdmlzdWFsaXphdGlvbkNvbHVtbiBpZiB2aXN1YWxpemF0aW9uIGhhcyBhIGJvcmRlcjpcbiAgdmlzdWFsaXphdGlvbkNvbHVtbi5zdHlsZS5tYXhXaWR0aCA9IChuZXdWaXpXaWR0aCArIHZpelNpZGVCb3JkZXJXaWR0aCkgKyAncHgnO1xuICB2aXN1YWxpemF0aW9uLnN0eWxlLm1heFdpZHRoID0gbmV3Vml6V2lkdGhTdHJpbmc7XG4gIHZpc3VhbGl6YXRpb24uc3R5bGUubWF4SGVpZ2h0ID0gbmV3Vml6SGVpZ2h0U3RyaW5nO1xuXG4gIC8vIFdlIGRvbid0IGdldCB0aGUgYmVuZWZpdHMgb2Ygb3VyIHJlc3BvbnNpdmUgc3R5bGluZywgc28gc2V0IGhlaWdodFxuICAvLyBleHBsaWNpdGx5XG4gIGlmICghdXRpbHMuYnJvd3NlclN1cHBvcnRzQ3NzTWVkaWEoKSkge1xuICAgIHZpc3VhbGl6YXRpb24uc3R5bGUuaGVpZ2h0ID0gbmV3Vml6SGVpZ2h0U3RyaW5nO1xuICAgIHZpc3VhbGl6YXRpb24uc3R5bGUud2lkdGggPSBuZXdWaXpXaWR0aFN0cmluZztcbiAgfVxuICB2YXIgc2NhbGUgPSAobmV3Vml6V2lkdGggLyB0aGlzLm5hdGl2ZVZpeldpZHRoKTtcblxuICBhcHBseVRyYW5zZm9ybVNjYWxlVG9DaGlsZHJlbih2aXN1YWxpemF0aW9uLCAnc2NhbGUoJyArIHNjYWxlICsgJyknKTtcbiAgaWYgKHZpc3VhbGl6YXRpb25FZGl0b3IpIHtcbiAgICB2aXN1YWxpemF0aW9uRWRpdG9yLnN0eWxlLm1hcmdpbkxlZnQgPSBuZXdWaXpXaWR0aFN0cmluZztcbiAgfVxuXG4gIGlmIChvbGRWaXpXaWR0aCA8IDIzMCAmJiBuZXdWaXpXaWR0aCA+PSAyMzApIHtcbiAgICAkKCcjc29mdC1idXR0b25zJykucmVtb3ZlQ2xhc3MoJ3NvZnQtYnV0dG9ucy1jb21wYWN0Jyk7XG4gIH0gZWxzZSBpZiAob2xkVml6V2lkdGggPiAyMzAgJiYgbmV3Vml6V2lkdGggPD0gMjMwKSB7XG4gICAgJCgnI3NvZnQtYnV0dG9ucycpLmFkZENsYXNzKCdzb2Z0LWJ1dHRvbnMtY29tcGFjdCcpO1xuICB9XG5cbiAgdmFyIHNtYWxsRm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BhZ2Utc21hbGwtZm9vdGVyIC5zbWFsbC1mb290ZXItYmFzZScpO1xuICBpZiAoc21hbGxGb290ZXIpIHtcbiAgICBzbWFsbEZvb3Rlci5zdHlsZS5tYXhXaWR0aCA9IG5ld1ZpeldpZHRoU3RyaW5nO1xuXG4gICAgLy8gSWYgdGhlIHNtYWxsIHByaW50IGFuZCBsYW5ndWFnZSBzZWxlY3RvciBhcmUgb24gdGhlIHNhbWUgbGluZSxcbiAgICAvLyB0aGUgc21hbGwgcHJpbnQgc2hvdWxkIGZsb2F0IHJpZ2h0LiAgT3RoZXJ3aXNlLCBpdCBzaG91bGQgZmxvYXQgbGVmdC5cbiAgICB2YXIgbGFuZ3VhZ2VTZWxlY3RvciA9IHNtYWxsRm9vdGVyLnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0nKTtcbiAgICB2YXIgc21hbGxQcmludCA9IHNtYWxsRm9vdGVyLnF1ZXJ5U2VsZWN0b3IoJ3NtYWxsJyk7XG4gICAgaWYgKGxhbmd1YWdlU2VsZWN0b3IgJiYgc21hbGxQcmludC5vZmZzZXRUb3AgPT09IGxhbmd1YWdlU2VsZWN0b3Iub2Zmc2V0VG9wKSB7XG4gICAgICBzbWFsbFByaW50LnN0eWxlLmZsb2F0ID0gJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc21hbGxQcmludC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICB9XG4gIH1cblxuICAvLyBGaXJlIHJlc2l6ZSBzbyBibG9ja2x5IGFuZCBkcm9wbGV0IGhhbmRsZSB0aGlzIHR5cGUgb2YgcmVzaXplIHByb3Blcmx5OlxuICB1dGlscy5maXJlUmVzaXplRXZlbnQoKTtcbn07XG5cblN0dWRpb0FwcC5wcm90b3R5cGUub25Nb3VzZVVwVml6UmVzaXplQmFyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIElmIHdlIGhhdmUgYmVlbiB0cmFja2luZyBtb3VzZSBtb3ZlcywgcmVtb3ZlIHRoZSBoYW5kbGVyIG5vdzpcbiAgaWYgKHRoaXMub25Nb3VzZU1vdmVCb3VuZEhhbmRsZXIpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVCb3VuZEhhbmRsZXIpO1xuICAgIGlmICh0aGlzLm1vdXNlTW92ZVRvdWNoRXZlbnROYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5tb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlQm91bmRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5vbk1vdXNlTW92ZUJvdW5kSGFuZGxlciA9IG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4qICBVcGRhdGVzIHRoZSB3aWR0aCBvZiB0aGUgdG9vbGJveC1oZWFkZXIgdG8gbWF0Y2ggdGhlIHdpZHRoIG9mIHRoZSB0b29sYm94XG4qICBvciBwYWxldHRlIGluIHRoZSB3b3Jrc3BhY2UgYmVsb3cgdGhlIGhlYWRlci5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJlc2l6ZVRvb2xib3hIZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRvb2xib3hXaWR0aCA9IDA7XG4gIGlmICh0aGlzLmVkaXRDb2RlICYmIHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLnBhbGV0dGVFbmFibGVkKSB7XG4gICAgLy8gSWYgaW4gdGhlIGRyb3BsZXQgZWRpdG9yLCBzZXQgdG9vbGJveFdpZHRoIGJhc2VkIG9uIHRoZSBibG9jayBwYWxldHRlIHdpZHRoOlxuICAgIHZhciBjYXRlZ29yaWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRyb3BsZXQtcGFsZXR0ZS13cmFwcGVyJyk7XG4gICAgdG9vbGJveFdpZHRoID0gY2F0ZWdvcmllcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICB0b29sYm94V2lkdGggPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlRWRpdG9yLmdldFRvb2xib3hXaWR0aCgpO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b29sYm94LWhlYWRlcicpLnN0eWxlLndpZHRoID0gdG9vbGJveFdpZHRoICsgJ3B4Jztcbn07XG5cbi8qKlxuKiBIaWdobGlnaHQgdGhlIGJsb2NrIChvciBjbGVhciBoaWdobGlnaHRpbmcpLlxuKiBAcGFyYW0gez9zdHJpbmd9IGlkIElEIG9mIGJsb2NrIHRoYXQgdHJpZ2dlcmVkIHRoaXMgYWN0aW9uLlxuKiBAcGFyYW0ge2Jvb2xlYW59IHNwb3RsaWdodCBPcHRpb25hbC4gIEhpZ2hsaWdodCBlbnRpcmUgYmxvY2sgaWYgdHJ1ZVxuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGlnaGxpZ2h0ID0gZnVuY3Rpb24oaWQsIHNwb3RsaWdodCkge1xuICBpZiAodGhpcy5pc1VzaW5nQmxvY2tseSgpKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICB2YXIgbSA9IGlkLm1hdGNoKC9eYmxvY2tfaWRfKFxcZCspJC8pO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgaWQgPSBtWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuaGlnaGxpZ2h0QmxvY2soaWQsIHNwb3RsaWdodCk7XG4gIH1cbn07XG5cbi8qKlxuKiBSZW1vdmUgaGlnaGxpZ2h0aW5nIGZyb20gYWxsIGJsb2Nrc1xuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuY2xlYXJIaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICB0aGlzLmhpZ2hsaWdodChudWxsKTtcbiAgfSBlbHNlIGlmICh0aGlzLmVkaXRDb2RlICYmIHRoaXMuZWRpdG9yKSB7XG4gICAgLy8gQ2xlYXIgZXZlcnl0aGluZyAoc3RlcCBoaWdobGlnaHRpbmcsIGVycm9ycywgZXRjLilcbiAgICBjb2RlZ2VuLmNsZWFyRHJvcGxldEFjZUhpZ2hsaWdodGluZyh0aGlzLmVkaXRvciwgdHJ1ZSk7XG4gIH1cbn07XG5cbi8qKlxuKiBEaXNwbGF5IGZlZWRiYWNrIGJhc2VkIG9uIHRlc3QgcmVzdWx0cy4gIFRoZSB0ZXN0IHJlc3VsdHMgbXVzdCBiZVxuKiBleHBsaWNpdGx5IHByb3ZpZGVkLlxuKiBAcGFyYW0ge3tmZWVkYmFja1R5cGU6IG51bWJlcn19IFRlc3QgcmVzdWx0cyAoYSBjb25zdGFudCBwcm9wZXJ0eSBvZlxuKiAgICAgdGhpcy5UZXN0UmVzdWx0cykuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5kaXNwbGF5RmVlZGJhY2sgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMuRGlhbG9nID0gdGhpcy5EaWFsb2c7XG4gIG9wdGlvbnMub25Db250aW51ZSA9IHRoaXMub25Db250aW51ZTtcbiAgb3B0aW9ucy5iYWNrVG9QcmV2aW91c0xldmVsID0gdGhpcy5iYWNrVG9QcmV2aW91c0xldmVsO1xuICBvcHRpb25zLnNlbmRUb1Bob25lID0gdGhpcy5zZW5kVG9QaG9uZTtcblxuICAvLyBTcGVjaWFsIHRlc3QgY29kZSBmb3IgZWRpdCBibG9ja3MuXG4gIGlmIChvcHRpb25zLmxldmVsLmVkaXRfYmxvY2tzKSB7XG4gICAgb3B0aW9ucy5mZWVkYmFja1R5cGUgPSB0aGlzLlRlc3RSZXN1bHRzLkVESVRfQkxPQ0tTO1xuICB9XG5cbiAgdGhpcy5mZWVkYmFja18uZGlzcGxheUZlZWRiYWNrKG9wdGlvbnMsIHRoaXMucmVxdWlyZWRCbG9ja3NfLFxuICAgICAgdGhpcy5tYXhSZXF1aXJlZEJsb2Nrc1RvRmxhZ18sIHRoaXMucmVjb21tZW5kZWRCbG9ja3NfLFxuICAgICAgdGhpcy5tYXhSZWNvbW1lbmRlZEJsb2Nrc1RvRmxhZ18pO1xufTtcblxuLyoqXG4gKiBSdW5zIHRoZSB0ZXN0cyBhbmQgcmV0dXJucyByZXN1bHRzLlxuICogQHBhcmFtIHtib29sZWFufSBsZXZlbENvbXBsZXRlIFdhcyB0aGUgbGV2ZWwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseT9cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcHByb3ByaWF0ZSBwcm9wZXJ0eSBvZiBUZXN0UmVzdWx0cy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRUZXN0UmVzdWx0cyA9IGZ1bmN0aW9uKGxldmVsQ29tcGxldGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuZmVlZGJhY2tfLmdldFRlc3RSZXN1bHRzKGxldmVsQ29tcGxldGUsXG4gICAgICB0aGlzLnJlcXVpcmVkQmxvY2tzXywgdGhpcy5yZWNvbW1lbmRlZEJsb2Nrc18sIHRoaXMuY2hlY2tGb3JFbXB0eUJsb2Nrc18sIG9wdGlvbnMpO1xufTtcblxuLy8gQnVpbGRzIHRoZSBkb20gdG8gZ2V0IG1vcmUgaW5mbyBmcm9tIHRoZSB1c2VyLiBBZnRlciB1c2VyIGVudGVycyBpbmZvXG4vLyBhbmQgY2xpY2sgXCJjcmVhdGUgbGV2ZWxcIiBvbkF0dGVtcHRDYWxsYmFjayBpcyBjYWxsZWQgdG8gZGVsaXZlciB0aGUgaW5mb1xuLy8gdG8gdGhlIHNlcnZlci5cblN0dWRpb0FwcC5wcm90b3R5cGUuYnVpbGRlckZvcm1fID0gZnVuY3Rpb24ob25BdHRlbXB0Q2FsbGJhY2spIHtcbiAgdmFyIGJ1aWxkZXJEZXRhaWxzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1aWxkZXJEZXRhaWxzLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2J1aWxkZXIuaHRtbC5lanMnKSgpO1xuICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgY29udGVudERpdjogYnVpbGRlckRldGFpbHMsXG4gICAgaWNvbjogdGhpcy5pY29uXG4gIH0pO1xuICB2YXIgY3JlYXRlTGV2ZWxCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3JlYXRlLWxldmVsLWJ1dHRvbicpO1xuICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNyZWF0ZUxldmVsQnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gYnVpbGRlckRldGFpbHMucXVlcnlTZWxlY3RvcignW25hbWU9XCJpbnN0cnVjdGlvbnNcIl0nKS52YWx1ZTtcbiAgICB2YXIgbmFtZSA9IGJ1aWxkZXJEZXRhaWxzLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwibGV2ZWxfbmFtZVwiXScpLnZhbHVlO1xuICAgIHZhciBxdWVyeSA9IHVybC5wYXJzZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgdHJ1ZSkucXVlcnk7XG4gICAgb25BdHRlbXB0Q2FsbGJhY2sodXRpbHMuZXh0ZW5kKHtcbiAgICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IGluc3RydWN0aW9ucyxcbiAgICAgIFwibmFtZVwiOiBuYW1lXG4gICAgfSwgcXVlcnkpKTtcbiAgfSk7XG5cbiAgZGlhbG9nLnNob3coeyBiYWNrZHJvcDogJ3N0YXRpYycgfSk7XG59O1xuXG4vKipcbiogUmVwb3J0IGJhY2sgdG8gdGhlIHNlcnZlciwgaWYgYXZhaWxhYmxlLlxuKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHBhcmFtZXRlciBibG9jayB3aGljaCBpbmNsdWRlczpcbioge3N0cmluZ30gYXBwIFRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbi5cbioge251bWJlcn0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBnZW5lcmF0ZWQgd2hlbiB0aGUgcGFnZSB3YXMgbG9hZGVkLlxuKiB7c3RyaW5nfSBsZXZlbCBUaGUgSUQgb2YgdGhlIGN1cnJlbnQgbGV2ZWwuXG4qIHtudW1iZXJ9IHJlc3VsdCBBbiBpbmRpY2F0b3Igb2YgdGhlIHN1Y2Nlc3Mgb2YgdGhlIGNvZGUuXG4qIHtudW1iZXJ9IHRlc3RSZXN1bHQgTW9yZSBzcGVjaWZpYyBkYXRhIG9uIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBvZiBjb2RlLlxuKiB7Ym9vbGVhbn0gc3VibWl0dGVkIFdoZXRoZXIgdGhlIChzdWJtaXR0YWJsZSkgbGV2ZWwgaXMgYmVpbmcgc3VibWl0dGVkLlxuKiB7c3RyaW5nfSBwcm9ncmFtIFRoZSB1c2VyIHByb2dyYW0sIHdoaWNoIHdpbGwgZ2V0IFVSTC1lbmNvZGVkLlxuKiB7ZnVuY3Rpb259IG9uQ29tcGxldGUgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVwb24gY29tcGxldGlvbi5cbiovXG5TdHVkaW9BcHAucHJvdG90eXBlLnJlcG9ydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLy8gY29weSBmcm9tIG9wdGlvbnM6IGFwcCwgbGV2ZWwsIHJlc3VsdCwgdGVzdFJlc3VsdCwgcHJvZ3JhbSwgb25Db21wbGV0ZVxuICB2YXIgcmVwb3J0ID0gJC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICBwYXNzOiB0aGlzLmZlZWRiYWNrXy5jYW5Db250aW51ZVRvTmV4dExldmVsKG9wdGlvbnMudGVzdFJlc3VsdCksXG4gICAgdGltZTogKChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLmluaXRUaW1lKSxcbiAgICBhdHRlbXB0OiB0aGlzLmF0dGVtcHRzLFxuICAgIGxpbmVzOiB0aGlzLmZlZWRiYWNrXy5nZXROdW1CbG9ja3NVc2VkKCksXG4gIH0pO1xuXG4gIHRoaXMubGFzdFRlc3RSZXN1bHQgPSBvcHRpb25zLnRlc3RSZXN1bHQ7XG5cblxuICAvLyBJZiBoaWRlU291cmNlIGlzIGVuYWJsZWQsIHRoZSB1c2VyIGlzIGxvb2tpbmcgYXQgYSBzaGFyZWQgbGV2ZWwgdGhhdFxuICAvLyB0aGV5IGNhbm5vdCBoYXZlIG1vZGlmaWVkLiBJbiB0aGF0IGNhc2UsIGRvbid0IHJlcG9ydCBpdCB0byB0aGUgc2VydmljZVxuICAvLyBvciBjYWxsIHRoZSBvbkNvbXBsZXRlKCkgY2FsbGJhY2sgZXhwZWN0ZWQuIFRoZSBhcHAgd2lsbCBqdXN0IHNpdFxuICAvLyB0aGVyZSB3aXRoIHRoZSBSZXNldCBidXR0b24gYXMgdGhlIG9ubHkgb3B0aW9uLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghKHRoaXMuaGlkZVNvdXJjZSAmJiB0aGlzLnNoYXJlKSkge1xuICAgIHZhciBvbkF0dGVtcHRDYWxsYmFjayA9IChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihidWlsZGVyRGV0YWlscykge1xuICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gYnVpbGRlckRldGFpbHMpIHtcbiAgICAgICAgICByZXBvcnRbb3B0aW9uXSA9IGJ1aWxkZXJEZXRhaWxzW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vbkF0dGVtcHQocmVwb3J0KTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGxldmVsIGJ1aWxkZXIsIGdvIHRvIGJ1aWxkZXJGb3JtIHRvIGdldCBtb3JlIGluZm8gZnJvbVxuICAgIC8vIHRoZSBsZXZlbCBidWlsZGVyLlxuICAgIGlmIChvcHRpb25zLmJ1aWxkZXIpIHtcbiAgICAgIHRoaXMuYnVpbGRlckZvcm1fKG9uQXR0ZW1wdENhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25BdHRlbXB0Q2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuKiBDbGljayB0aGUgcmVzZXQgYnV0dG9uLiAgUmVzZXQgdGhlIGFwcGxpY2F0aW9uLlxuKi9cblN0dWRpb0FwcC5wcm90b3R5cGUucmVzZXRCdXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9uUmVzZXRQcmVzc2VkKCk7XG4gIHRoaXMudG9nZ2xlUnVuUmVzZXQoJ3J1bicpO1xuICB0aGlzLmNsZWFySGlnaGxpZ2h0aW5nKCk7XG4gIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlRWRpdG9yLnNldEVuYWJsZVRvb2xib3godHJ1ZSk7XG4gICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZS50cmFjZU9uKGZhbHNlKTtcbiAgfVxuICB0aGlzLnJlc2V0KGZhbHNlKTtcbn07XG5cbi8qKlxuKiBBZGQgY291bnQgb2YgYmxvY2tzIHVzZWQuXG4qL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS51cGRhdGVCbG9ja0NvdW50ID0gZnVuY3Rpb24oKSB7XG4gIC8vIElmIHRoZSBudW1iZXIgb2YgYmxvY2sgdXNlZCBpcyBiaWdnZXIgdGhhbiB0aGUgaWRlYWwgbnVtYmVyIG9mIGJsb2NrcyxcbiAgLy8gc2V0IGl0IHRvIGJlIHllbGxvdywgb3RoZXJ3aXNlLCBrZWVwIGl0IGFzIGJsYWNrLlxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdibG9ja1VzZWQnKTtcbiAgaWYgKHRoaXMuSURFQUxfQkxPQ0tfTlVNIDwgdGhpcy5mZWVkYmFja18uZ2V0TnVtQ291bnRhYmxlQmxvY2tzKCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiYmxvY2stY291bnRlci1vdmVyZmxvd1wiO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJibG9jay1jb3VudGVyLWRlZmF1bHRcIjtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBudW1iZXIgb2YgYmxvY2tzIHVzZWQuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJzsgIC8vIFJlbW92ZSBleGlzdGluZyBjaGlsZHJlbiBvciB0ZXh0LlxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICB0aGlzLmZlZWRiYWNrXy5nZXROdW1Db3VudGFibGVCbG9ja3MoKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaWRlYWwgTnVtYmVyIG9mIGJsb2Nrcy5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5zZXRJZGVhbEJsb2NrTnVtYmVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZGVhbEJsb2NrTnVtYmVyJyk7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZGVhbEJsb2NrTnVtYmVyTXNnID0gdGhpcy5JREVBTF9CTE9DS19OVU0gPT09IEluZmluaXR5ID9cbiAgICBtc2cuaW5maW5pdHkoKSA6IHRoaXMuSURFQUxfQkxPQ0tfTlVNO1xuICBlbGVtZW50LmlubmVySFRNTCA9ICcnOyAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNoaWxkcmVuIG9yIHRleHQuXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgaWRlYWxCbG9ja051bWJlck1zZykpO1xufTtcblxuXG4vKipcbiAqXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZml4Vmlld3BvcnRGb3JTbWFsbFNjcmVlbnNfID0gZnVuY3Rpb24gKHZpZXdwb3J0LCBjb25maWcpIHtcbiAgdmFyIGRldmljZVdpZHRoO1xuICB2YXIgZGVzaXJlZFdpZHRoO1xuICB2YXIgbWluV2lkdGg7XG4gIGlmICh0aGlzLnNoYXJlICYmIGRvbS5pc01vYmlsZSgpKSB7XG4gICAgdmFyIG1vYmlsZU5vUGFkZGluZ1NoYXJlV2lkdGggPVxuICAgICAgY29uZmlnLm1vYmlsZU5vUGFkZGluZ1NoYXJlV2lkdGggfHwgREVGQVVMVF9NT0JJTEVfTk9fUEFERElOR19TSEFSRV9XSURUSDtcbiAgICAvLyBmb3IgbW9iaWxlIHNoYXJpbmcsIGZhdm9yIHBvcnRyYWl0IG1vZGUsIHNvIHdpZHRoIGlzIHRoZSBzaG9ydGVyIG9mIHRoZSB0d29cbiAgICBkZXZpY2VXaWR0aCA9IGRlc2lyZWRXaWR0aCA9IE1hdGgubWluKHNjcmVlbi53aWR0aCwgc2NyZWVuLmhlaWdodCk7XG4gICAgaWYgKHRoaXMubm9QYWRkaW5nICYmIGRldmljZVdpZHRoIDwgTUFYX1BIT05FX1dJRFRIKSB7XG4gICAgICBkZXNpcmVkV2lkdGggPSBNYXRoLm1pbihkZXNpcmVkV2lkdGgsIG1vYmlsZU5vUGFkZGluZ1NoYXJlV2lkdGgpO1xuICAgIH1cbiAgICBtaW5XaWR0aCA9IG1vYmlsZU5vUGFkZGluZ1NoYXJlV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gYXNzdW1lIHdlIGFyZSBpbiBsYW5kc2NhcGUgbW9kZSwgc28gd2lkdGggaXMgdGhlIGxvbmdlciBvZiB0aGUgdHdvXG4gICAgZGV2aWNlV2lkdGggPSBkZXNpcmVkV2lkdGggPSBNYXRoLm1heChzY3JlZW4ud2lkdGgsIHNjcmVlbi5oZWlnaHQpO1xuICAgIG1pbldpZHRoID0gTUlOX1dJRFRIO1xuICB9XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KG1pbldpZHRoLCBkZXNpcmVkV2lkdGgpO1xuICB2YXIgc2NhbGUgPSBkZXZpY2VXaWR0aCAvIHdpZHRoO1xuICB2YXIgY29udGVudCA9IFsnd2lkdGg9JyArIHdpZHRoLFxuICAgICdtaW5pbWFsLXVpJyxcbiAgICAnaW5pdGlhbC1zY2FsZT0nICsgc2NhbGUsXG4gICAgJ21heGltdW0tc2NhbGU9JyArIHNjYWxlLFxuICAgICdtaW5pbXVtLXNjYWxlPScgKyBzY2FsZSxcbiAgICAndGFyZ2V0LWRlbnNpdHlEcGk9ZGV2aWNlLWRwaScsXG4gICAgJ3VzZXItc2NhbGFibGU9bm8nXTtcbiAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgY29udGVudC5qb2luKCcsICcpKTtcbn07XG5cbi8qKlxuICpcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5zZXRDb25maWdWYWx1ZXNfID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB0aGlzLnNoYXJlID0gY29uZmlnLnNoYXJlO1xuICB0aGlzLmNlbnRlckVtYmVkZGVkID0gdXRpbHMudmFsdWVPcihjb25maWcuY2VudGVyRW1iZWRkZWQsIHRoaXMuY2VudGVyRW1iZWRkZWQpO1xuICB0aGlzLndpcmVmcmFtZVNoYXJlID0gdXRpbHMudmFsdWVPcihjb25maWcud2lyZWZyYW1lU2hhcmUsIHRoaXMud2lyZWZyYW1lU2hhcmUpO1xuXG4gIC8vIGlmIHRydWUsIGRvbnQgcHJvdmlkZSBsaW5rcyB0byBzaGFyZSBvbiBmYi90d2l0dGVyXG4gIHRoaXMuZGlzYWJsZVNvY2lhbFNoYXJlID0gY29uZmlnLmRpc2FibGVTb2NpYWxTaGFyZTtcbiAgdGhpcy5zZW5kVG9QaG9uZSA9IGNvbmZpZy5zZW5kVG9QaG9uZTtcbiAgdGhpcy5ub1BhZGRpbmcgPSBjb25maWcubm9QYWRkaW5nO1xuXG4gIC8vIGNvbnRyYWN0IGVkaXRvciByZXF1aXJlcyBtb3JlIHZlcnRpY2FsIHNwYWNlLiBzZXQgaGVpZ2h0IHRvIDEyNTAgdW5sZXNzXG4gIC8vIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gIGlmIChjb25maWcubGV2ZWwudXNlQ29udHJhY3RFZGl0b3IpIHtcbiAgICBjb25maWcubGV2ZWwubWluV29ya3NwYWNlSGVpZ2h0ID0gY29uZmlnLmxldmVsLm1pbldvcmtzcGFjZUhlaWdodCB8fCAxMjUwO1xuICB9XG5cbiAgdGhpcy5hcHBNc2cgPSBjb25maWcuYXBwTXNnO1xuICB0aGlzLklERUFMX0JMT0NLX05VTSA9IGNvbmZpZy5sZXZlbC5pZGVhbCB8fCBJbmZpbml0eTtcbiAgdGhpcy5NSU5fV09SS1NQQUNFX0hFSUdIVCA9IGNvbmZpZy5sZXZlbC5taW5Xb3Jrc3BhY2VIZWlnaHQgfHwgODAwO1xuICB0aGlzLnJlcXVpcmVkQmxvY2tzXyA9IGNvbmZpZy5sZXZlbC5yZXF1aXJlZEJsb2NrcyB8fCBbXTtcbiAgdGhpcy5yZWNvbW1lbmRlZEJsb2Nrc18gPSBjb25maWcubGV2ZWwucmVjb21tZW5kZWRCbG9ja3MgfHwgW107XG4gIHRoaXMuc3RhcnRCbG9ja3NfID0gY29uZmlnLmxldmVsLmxhc3RBdHRlbXB0IHx8IGNvbmZpZy5sZXZlbC5zdGFydEJsb2NrcyB8fCAnJztcbiAgdGhpcy52aXpBc3BlY3RSYXRpbyA9IGNvbmZpZy52aXpBc3BlY3RSYXRpbyB8fCAxLjA7XG4gIHRoaXMubmF0aXZlVml6V2lkdGggPSBjb25maWcubmF0aXZlVml6V2lkdGggfHwgdGhpcy5tYXhWaXN1YWxpemF0aW9uV2lkdGg7XG5cbiAgLy8gZW5hYmxlU2hvd0NvZGUgZGVmYXVsdHMgdG8gdHJ1ZSBpZiBub3QgZGVmaW5lZFxuICB0aGlzLmVuYWJsZVNob3dDb2RlID0gKGNvbmZpZy5lbmFibGVTaG93Q29kZSAhPT0gZmFsc2UpO1xuICB0aGlzLmVuYWJsZVNob3dMaW5lc0NvdW50ID0gKGNvbmZpZy5lbmFibGVTaG93TGluZXNDb3VudCAhPT0gZmFsc2UpO1xuXG4gIC8vIElmIHRoZSBsZXZlbCBoYXMgbm8gaWRlYWwgYmxvY2sgY291bnQsIGRvbid0IHNob3cgYSBibG9jayBjb3VudC4gSWYgaXQgZG9lc1xuICAvLyBoYXZlIGFuIGlkZWFsLCBzaG93IGJsb2NrIGNvdW50IHVubGVzcyBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgbm90IHRvLlxuICBpZiAoY29uZmlnLmxldmVsICYmIChjb25maWcubGV2ZWwuaWRlYWwgPT09IHVuZGVmaW5lZCB8fCBjb25maWcubGV2ZWwuaWRlYWwgPT09IEluZmluaXR5KSkge1xuICAgIHRoaXMuZW5hYmxlU2hvd0Jsb2NrQ291bnQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVuYWJsZVNob3dCbG9ja0NvdW50ID0gY29uZmlnLmVuYWJsZVNob3dCbG9ja0NvdW50ICE9PSBmYWxzZTtcbiAgfVxuXG4gIC8vIFN0b3JlIGNvbmZpZ3VyYXRpb24uXG4gIHRoaXMub25BdHRlbXB0ID0gY29uZmlnLm9uQXR0ZW1wdCB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5vbkNvbnRpbnVlID0gY29uZmlnLm9uQ29udGludWUgfHwgZnVuY3Rpb24gKCkge307XG4gIHRoaXMub25Jbml0aWFsaXplID0gY29uZmlnLm9uSW5pdGlhbGl6ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcub25Jbml0aWFsaXplLmJpbmQoY29uZmlnKSA6IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLm9uUmVzZXRQcmVzc2VkID0gY29uZmlnLm9uUmVzZXRQcmVzc2VkIHx8IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLmJhY2tUb1ByZXZpb3VzTGV2ZWwgPSBjb25maWcuYmFja1RvUHJldmlvdXNMZXZlbCB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5za2luID0gY29uZmlnLnNraW47XG4gIHRoaXMuc2hvd0luc3RydWN0aW9ucyA9IHRoaXMuc2hvd0luc3RydWN0aW9uc18uYmluZCh0aGlzLCBjb25maWcubGV2ZWwsIGZhbHNlKTtcbiAgdGhpcy5wb2xpc2hDb2RlSG9vayA9IGNvbmZpZy5wb2xpc2hDb2RlSG9vaztcbn07XG5cbi8vIE92ZXJ3cml0dGVuIGJ5IGFwcGxhYi5cblN0dWRpb0FwcC5wcm90b3R5cGUucnVuQnV0dG9uQ2xpY2tXcmFwcGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGlmICh3aW5kb3cuJCkge1xuICAgICQod2luZG93KS50cmlnZ2VyKCdydW5fYnV0dG9uX3ByZXNzZWQnKTtcbiAgICAkKHdpbmRvdykudHJpZ2dlcignYXBwTW9kZUNoYW5nZWQnKTtcbiAgfVxuICBjYWxsYmFjaygpO1xufTtcblxuLyoqXG4gKiBCZWdpbiBtb2RpZnlpbmcgdGhlIERPTSBiYXNlZCBvbiBjb25maWcuXG4gKiBOb3RlOiBIYXMgc2lkZSBlZmZlY3RzIG9uIGNvbmZpZ1xuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmNvbmZpZ3VyZURvbSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmZpZy5jb250YWluZXJJZCk7XG4gIGlmICghdGhpcy5lbmFibGVTaG93Q29kZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWNvZGUtaGVhZGVyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuICB2YXIgY29kZVdvcmtzcGFjZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjY29kZVdvcmtzcGFjZScpO1xuXG4gIHZhciBydW5CdXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignI3J1bkJ1dHRvbicpO1xuICB2YXIgcmVzZXRCdXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignI3Jlc2V0QnV0dG9uJyk7XG4gIHZhciBydW5DbGljayA9IHRoaXMucnVuQnV0dG9uQ2xpY2suYmluZCh0aGlzKTtcbiAgdmFyIHRocm90dGxlZFJ1bkNsaWNrID0gXy5kZWJvdW5jZSh0aGlzLnJ1bkJ1dHRvbkNsaWNrV3JhcHBlci5iaW5kKHRoaXMsIHJ1bkNsaWNrKSwgMjUwLCB0cnVlKTtcbiAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChydW5CdXR0b24sIF8uYmluZCh0aHJvdHRsZWRSdW5DbGljaywgdGhpcykpO1xuICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHJlc2V0QnV0dG9uLCBfLmJpbmQodGhpcy5yZXNldEJ1dHRvbkNsaWNrLCB0aGlzKSk7XG5cbiAgLy8gVE9ETyAoY3BpcmljaCk6IG1ha2UgY29uZGl0aW9uYWwgZm9yIGFwcGxhYlxuICB2YXIgYmVsb3dWaXogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmVsb3dWaXN1YWxpemF0aW9uJyk7XG4gIHZhciByZWZlcmVuY2VBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZmVyZW5jZV9hcmVhJyk7XG4gIGlmIChyZWZlcmVuY2VBcmVhKSB7XG4gICAgYmVsb3dWaXouYXBwZW5kQ2hpbGQocmVmZXJlbmNlQXJlYSk7XG4gIH1cblxuICB2YXIgdmlzdWFsaXphdGlvbkNvbHVtbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uQ29sdW1uJyk7XG4gIHZhciB2aXN1YWxpemF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb24nKTtcblxuICBpZiAoIWNvbmZpZy5oaWRlU291cmNlIHx8IGNvbmZpZy5lbWJlZCkge1xuICAgIHZhciB2aXpIZWlnaHQgPSB0aGlzLk1JTl9XT1JLU1BBQ0VfSEVJR0hUO1xuICAgIGlmICh0aGlzLmlzVXNpbmdCbG9ja2x5KCkgJiYgY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzKSB7XG4gICAgICAvLyBTZXQgYSBjbGFzcyBvbiB0aGUgbWFpbiBibG9ja2x5IGRpdiBzbyBDU1MgY2FuIHN0eWxlIGJsb2NrcyBkaWZmZXJlbnRseVxuICAgICAgJChjb2RlV29ya3NwYWNlKS5hZGRDbGFzcygnZWRpdCcpO1xuICAgICAgLy8gSWYgaW4gbGV2ZWwgYnVpbGRlciBlZGl0aW5nIGJsb2NrcywgbWFrZSB3b3Jrc3BhY2UgZXh0cmEgdGFsbFxuICAgICAgdml6SGVpZ2h0ID0gMzAwMDtcbiAgICAgIC8vIE1vZGlmeSB0aGUgYXJyYW5nZW1lbnQgb2YgdG9vbGJveCBibG9ja3Mgc28gY2F0ZWdvcmllcyBhbGlnbiBsZWZ0XG4gICAgICBpZiAoY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzID09IFwidG9vbGJveF9ibG9ja3NcIikge1xuICAgICAgICB0aGlzLmJsb2NrWUNvb3JkaW5hdGVJbnRlcnZhbCA9IDgwO1xuICAgICAgICBjb25maWcuYmxvY2tBcnJhbmdlbWVudCA9IHsgY2F0ZWdvcnkgOiB7IHg6IDIwIH0gfTtcbiAgICAgIH1cbiAgICAgIC8vIEVuYWJsZSBwYXJhbSAmIHZhciBlZGl0aW5nIGluIGxldmVsYnVpbGRlciwgcmVnYXJkbGVzcyBvZiBsZXZlbCBzZXR0aW5nXG4gICAgICBjb25maWcubGV2ZWwuZGlzYWJsZVBhcmFtRWRpdGluZyA9IGZhbHNlO1xuICAgICAgY29uZmlnLmxldmVsLmRpc2FibGVWYXJpYWJsZUVkaXRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnBpbldvcmtzcGFjZVRvQm90dG9tKSB7XG4gICAgICB2YXIgYm9keUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgYm9keUVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgYm9keUVsZW1lbnQuY2xhc3NOYW1lID0gYm9keUVsZW1lbnQuY2xhc3NOYW1lICsgXCIgcGluX2JvdHRvbVwiO1xuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNvbnRhaW5lci5jbGFzc05hbWUgKyBcIiBwaW5fYm90dG9tXCI7XG4gICAgICB2aXN1YWxpemF0aW9uQ29sdW1uLmNsYXNzTmFtZSA9IHZpc3VhbGl6YXRpb25Db2x1bW4uY2xhc3NOYW1lICsgXCIgcGluX2JvdHRvbVwiO1xuICAgICAgY29kZVdvcmtzcGFjZS5jbGFzc05hbWUgPSBjb2RlV29ya3NwYWNlLmNsYXNzTmFtZSArIFwiIHBpbl9ib3R0b21cIjtcbiAgICAgIGlmICh0aGlzLmVkaXRDb2RlKSB7XG4gICAgICAgIHZhciBjb2RlVGV4dGJveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb2RlVGV4dGJveCcpO1xuICAgICAgICBjb2RlVGV4dGJveC5jbGFzc05hbWUgPSBjb2RlVGV4dGJveC5jbGFzc05hbWUgKyBcIiBwaW5fYm90dG9tXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc3VhbGl6YXRpb25Db2x1bW4uc3R5bGUubWluSGVpZ2h0ID0gdml6SGVpZ2h0ICsgJ3B4JztcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5taW5IZWlnaHQgPSB2aXpIZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcucmVhZG9ubHlXb3Jrc3BhY2UpIHtcbiAgICAkKGNvZGVXb3Jrc3BhY2UpLmFkZENsYXNzKCdyZWFkb25seScpO1xuICB9XG5cbiAgLy8gTk9URTogQ2FuIGVuZCB1cCB3aXRoIGVtYmVkIHRydWUgYW5kIGhpZGVTb3VyY2UgZmFsc2UgaW4gbGV2ZWwgYnVpbGRlclxuICAvLyBzY2VuYXJpb3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY29kZS1kb3Qtb3JnL2NvZGUtZG90LW9yZy9wdWxsLzE3NDRcbiAgaWYgKGNvbmZpZy5lbWJlZCAmJiBjb25maWcuaGlkZVNvdXJjZSAmJiB0aGlzLmNlbnRlckVtYmVkZGVkKSB7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNvbnRhaW5lci5jbGFzc05hbWUgKyBcIiBjZW50ZXJlZF9lbWJlZFwiO1xuICAgIHZpc3VhbGl6YXRpb25Db2x1bW4uY2xhc3NOYW1lID0gdmlzdWFsaXphdGlvbkNvbHVtbi5jbGFzc05hbWUgKyBcIiBjZW50ZXJlZF9lbWJlZFwiO1xuICB9XG5cbiAgaWYgKCFjb25maWcuZW1iZWQgJiYgIWNvbmZpZy5oaWRlU291cmNlKSB7XG4gICAgLy8gTWFrZSB0aGUgdmlzdWFsaXphdGlvbiByZXNwb25zaXZlIHRvIHNjcmVlbiBzaXplLCBleGNlcHQgb24gc2hhcmUgcGFnZS5cbiAgICB2aXN1YWxpemF0aW9uLmNsYXNzTmFtZSArPSBcIiByZXNwb25zaXZlXCI7XG4gICAgdmlzdWFsaXphdGlvbkNvbHVtbi5jbGFzc05hbWUgKz0gXCIgcmVzcG9uc2l2ZVwiO1xuICAgIHZhciBzbWFsbEZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlLXNtYWxsLWZvb3RlciAuc21hbGwtZm9vdGVyLWJhc2UnKTtcbiAgICBpZiAoc21hbGxGb290ZXIpIHtcbiAgICAgIHNtYWxsRm9vdGVyLmNsYXNzTmFtZSArPSBcIiByZXNwb25zaXZlXCI7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFuZGxlSGlkZVNvdXJjZV8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jb250YWluZXJJZCk7XG4gIHRoaXMuaGlkZVNvdXJjZSA9IHRydWU7XG4gIHZhciB3b3Jrc3BhY2VEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVdvcmtzcGFjZScpO1xuICBpZiAoIW9wdGlvbnMuZW1iZWQgfHwgb3B0aW9ucy5sZXZlbC5za2lwSW5zdHJ1Y3Rpb25zUG9wdXApIHtcbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ2hpZGUtc291cmNlJztcbiAgfVxuICB3b3Jrc3BhY2VEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGl6YXRpb25SZXNpemVCYXInKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gIC8vIENocm9tZS1sZXNzIHNoYXJlIHBhZ2UuXG4gIGlmICh0aGlzLnNoYXJlKSB7XG4gICAgaWYgKG9wdGlvbnMuaXNMZWdhY3lTaGFyZSB8fCB0aGlzLndpcmVmcmFtZVNoYXJlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjMjAyQjM0JztcblxuICAgICAgJCgnLmhlYWRlci13cmFwcGVyJykuaGlkZSgpO1xuICAgICAgdmFyIHZpekNvbHVtbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uQ29sdW1uJyk7XG4gICAgICBpZiAoZG9tLmlzTW9iaWxlKCkgJiYgKG9wdGlvbnMuaXNMZWdhY3lTaGFyZSB8fCAhZG9tLmlzSVBhZCgpKSkge1xuICAgICAgICAkKHZpekNvbHVtbikuYWRkQ2xhc3MoJ2Nocm9tZWxlc3NTaGFyZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh2aXpDb2x1bW4pLmFkZENsYXNzKCd3aXJlZnJhbWVTaGFyZScpO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBSZWFjdC5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChXaXJlZnJhbWVTZW5kVG9QaG9uZSwge1xuICAgICAgICAgIGNoYW5uZWxJZDogZGFzaGJvYXJkLnByb2plY3QuZ2V0Q3VycmVudElkKCksXG4gICAgICAgICAgYXBwVHlwZTogZGFzaGJvYXJkLnByb2plY3QuZ2V0U3RhbmRhbG9uZUFwcCgpXG4gICAgICAgIH0pLCBkaXYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuZW1iZWQpIHtcbiAgICAgICAgdmFyIHJ1bkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdydW5CdXR0b24nKTtcbiAgICAgICAgdmFyIGJ1dHRvblJvdyA9IHJ1bkJ1dHRvbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgb3BlbldvcmtzcGFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBvcGVuV29ya3NwYWNlLnNldEF0dHJpYnV0ZSgnaWQnLCAnb3Blbi13b3Jrc3BhY2UnKTtcbiAgICAgICAgb3BlbldvcmtzcGFjZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtc2cub3BlbldvcmtzcGFjZSgpKSk7XG5cbiAgICAgICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChvcGVuV29ya3NwYWNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gL2MvIFVSTHMgZ28gdG8gL2VkaXQgd2hlbiB3ZSBjbGljayBvcGVuIHdvcmtzcGFjZS5cbiAgICAgICAgICAvLyAvcHJvamVjdC8gVVJMcyB3ZSB3YW50IHRvIGdvIHRvIC92aWV3ICh3aGljaCBkb2VzbnQgcmVxdWlyZSBsb2dpbilcbiAgICAgICAgICBpZiAoL15cXC9jXFwvLy50ZXN0KGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgbG9jYXRpb24uaHJlZiArPSAnL2VkaXQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5ocmVmICs9ICcvdmlldyc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBidXR0b25Sb3cuYXBwZW5kQ2hpbGQob3BlbldvcmtzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhbmRsZUVkaXRDb2RlXyA9IGZ1bmN0aW9uIChjb25maWcpIHtcblxuICBpZiAodGhpcy5oaWRlU291cmNlKSB7XG4gICAgLy8gSW4gaGlkZSBzb3VyY2UgbW9kZSwganVzdCBjYWxsIGFmdGVySW5qZWN0IGFuZCBleGl0IGltbWVkaWF0ZWx5XG4gICAgaWYgKGNvbmZpZy5hZnRlckluamVjdCkge1xuICAgICAgY29uZmlnLmFmdGVySW5qZWN0KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXNwbGF5TWVzc2FnZSwgZXhhbXBsZVByb2dyYW1zLCBtZXNzYWdlRWxlbWVudCwgb25DaGFuZ2UsIHN0YXJ0aW5nVGV4dDtcblxuICAvLyBFbnN1cmUgZ2xvYmFsIGFjZSB2YXJpYWJsZSBpcyB0aGUgc2FtZSBhcyB3aW5kb3cuYWNlXG4gIC8vIChpbXBvcnRhbnQgYmVjYXVzZSB0aGV5IGNhbiBiZSBkaWZmZXJlbnQgaW4gb3VyIHRlc3QgZW52aXJvbm1lbnQpXG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBhY2UgPSB3aW5kb3cuYWNlO1xuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIHZhciBmdWxsRHJvcGxldFBhbGV0dGUgPSBkcm9wbGV0VXRpbHMuZ2VuZXJhdGVEcm9wbGV0UGFsZXR0ZShcbiAgICBjb25maWcubGV2ZWwuY29kZUZ1bmN0aW9ucywgY29uZmlnLmRyb3BsZXRDb25maWcpO1xuICB0aGlzLmVkaXRvciA9IG5ldyBkcm9wbGV0LkVkaXRvcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVRleHRib3gnKSwge1xuICAgIG1vZGU6ICdqYXZhc2NyaXB0JyxcbiAgICBtb2RlT3B0aW9uczogZHJvcGxldFV0aWxzLmdlbmVyYXRlRHJvcGxldE1vZGVPcHRpb25zKGNvbmZpZyksXG4gICAgcGFsZXR0ZTogZnVsbERyb3BsZXRQYWxldHRlLFxuICAgIHNob3dQYWxldHRlSW5UZXh0TW9kZTogdHJ1ZSxcbiAgICBzaG93RHJvcGRvd25JblBhbGV0dGU6IGNvbmZpZy5zaG93RHJvcGRvd25JblBhbGV0dGUsXG4gICAgYWxsb3dGbG9hdGluZ0Jsb2NrczogZmFsc2UsXG4gICAgZHJvcEludG9BY2VBdExpbmVTdGFydDogY29uZmlnLmRyb3BJbnRvQWNlQXRMaW5lU3RhcnQsXG4gICAgZW5hYmxlUGFsZXR0ZUF0U3RhcnQ6ICFjb25maWcucmVhZG9ubHlXb3Jrc3BhY2UsXG4gICAgdGV4dE1vZGVBdFN0YXJ0OiBjb25maWcubGV2ZWwudGV4dE1vZGVBdFN0YXJ0XG4gIH0pO1xuXG4gIHRoaXMuZWRpdG9yLmFjZUVkaXRvci5zZXRTaG93UHJpbnRNYXJnaW4oZmFsc2UpO1xuXG4gIC8vIEluaXQgYW5kIGRlZmluZSBvdXIgY3VzdG9tIGFjZSBtb2RlOlxuICBhY2VNb2RlLmRlZmluZUZvckFjZShjb25maWcuZHJvcGxldENvbmZpZywgY29uZmlnLnVudXNlZENvbmZpZywgdGhpcy5lZGl0b3IpO1xuICAvLyBOb3cgc2V0IHRoZSBlZGl0b3IgdG8gdGhhdCBtb2RlOlxuICB2YXIgYWNlRWRpdG9yID0gdGhpcy5lZGl0b3IuYWNlRWRpdG9yO1xuICBhY2VFZGl0b3Iuc2Vzc2lvbi5zZXRNb2RlKCdhY2UvbW9kZS9qYXZhc2NyaXB0X2NvZGVvcmcnKTtcblxuICAvLyBFeHRlbmQgdGhlIGNvbW1hbmQgbGlzdCBvbiB0aGUgYWNlIEF1dG9jb21wbGV0ZSBvYmplY3QgdG8gaW5jbHVkZSB0aGUgcGVyaW9kOlxuICB2YXIgQXV0b2NvbXBsZXRlID0gd2luZG93LmFjZS5yZXF1aXJlKFwiYWNlL2F1dG9jb21wbGV0ZVwiKS5BdXRvY29tcGxldGU7XG4gIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY29tbWFuZHNbJy4nXSA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIC8vIEZpcnN0LCBpbnNlcnQgdGhlIHBlcmlvZCBhbmQgdXBkYXRlIHRoZSBjb21wbGV0aW9uczpcbiAgICBlZGl0b3IuaW5zZXJ0KFwiLlwiKTtcbiAgICBlZGl0b3IuY29tcGxldGVyLnVwZGF0ZUNvbXBsZXRpb25zKHRydWUpO1xuICAgIHZhciBmaWx0ZXJlZCA9IGVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMgJiZcbiAgICAgICAgZWRpdG9yLmNvbXBsZXRlci5jb21wbGV0aW9ucy5maWx0ZXJlZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChmaWx0ZXJlZCAmJiBmaWx0ZXJlZC5sZW5ndGgpOyBpKyspIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYW55IGV4YWN0IG1hY2hlcyBpbiBvdXIgZmlsdGVyZWQgY29tcGxldGlvbnMgdGhhdCBpbmNsdWRlXG4gICAgICAvLyB0aGlzIHBlcmlvZCwgYWxsb3cgdGhlIGNvbXBsZXRlciB0byBzdGF5IGFjdGl2ZTpcbiAgICAgIGlmIChmaWx0ZXJlZFtpXS5leGFjdE1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBkZXRhY2ggdGhlIGNvbXBsZXRlcjpcbiAgICBlZGl0b3IuY29tcGxldGVyLmRldGFjaCgpO1xuICB9O1xuXG4gIHZhciBsYW5nVG9vbHMgPSB3aW5kb3cuYWNlLnJlcXVpcmUoXCJhY2UvZXh0L2xhbmd1YWdlX3Rvb2xzXCIpO1xuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSB0aGUgdGV4dENvbXBsZXRlci4gbGFuZ1Rvb2xzIGRvZXNuJ3QgZ2l2ZSB1cyBhIHdheVxuICAvLyB0byByZW1vdmUgYmFzZSBjb21wbGV0ZXJzIChub3RlOiBpdCBkb2VzIGluIG5ld2VyIHZlcnNpb25zIG9mIGFjZSksIHNvXG4gIC8vIHdlIHNldCBhY2VFZGl0b3IuY29tcGxldGVycyBtYW51YWxseVxuICBhY2VFZGl0b3IuY29tcGxldGVycyA9IFtsYW5nVG9vbHMuc25pcHBldENvbXBsZXRlciwgbGFuZ1Rvb2xzLmtleVdvcmRDb21wbGV0ZXJdO1xuICAvLyBtYWtlIHNldENvbXBsZXRlcnMgZmFpbCBzbyB0aGF0IGF0dGVtcHRzIHRvIHVzZSBpdCByZXN1bHQgaW4gY2xlYXIgZmFpbHVyZVxuICAvLyBpbnN0ZWFkIG9mIGp1c3Qgc2lsZW50bHkgbm90IHdvcmtpbmdcbiAgbGFuZ1Rvb2xzLnNldENvbXBsZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRDb21wbGV0ZXJzIGRpc2FibGVkLiBzZXQgYWNlRWRpdG9yLmNvbXBsZXRlcnMgZGlyZWN0bHknKTtcbiAgfTtcblxuICAvLyBBZGQgYW4gYWNlIGNvbXBsZXRlciBmb3IgdGhlIEFQSSBmdW5jdGlvbnMgZXhwb3NlZCBmb3IgdGhpcyBsZXZlbFxuICBpZiAoY29uZmlnLmRyb3BsZXRDb25maWcpIHtcbiAgICB2YXIgZnVuY3Rpb25zRmlsdGVyID0gbnVsbDtcbiAgICBpZiAoY29uZmlnLmxldmVsLmF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSkge1xuICAgICAgIGZ1bmN0aW9uc0ZpbHRlciA9IGNvbmZpZy5sZXZlbC5jb2RlRnVuY3Rpb25zO1xuICAgIH1cblxuICAgIGFjZUVkaXRvci5jb21wbGV0ZXJzLnB1c2goXG4gICAgICBkcm9wbGV0VXRpbHMuZ2VuZXJhdGVBY2VBcGlDb21wbGV0ZXIoZnVuY3Rpb25zRmlsdGVyLCBjb25maWcuZHJvcGxldENvbmZpZykpO1xuICB9XG5cbiAgdGhpcy5lZGl0b3IuYWNlRWRpdG9yLnNldE9wdGlvbnMoe1xuICAgIGVuYWJsZUJhc2ljQXV0b2NvbXBsZXRpb246IHRydWUsXG4gICAgZW5hYmxlTGl2ZUF1dG9jb21wbGV0aW9uOiB0cnVlXG4gIH0pO1xuXG4gIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyID0gbmV3IERyb3BsZXRUb29sdGlwTWFuYWdlcihcbiAgICB0aGlzLmFwcE1zZyxcbiAgICBjb25maWcuZHJvcGxldENvbmZpZyxcbiAgICBjb25maWcubGV2ZWwuY29kZUZ1bmN0aW9ucyxcbiAgICBjb25maWcubGV2ZWwuYXV0b2NvbXBsZXRlUGFsZXR0ZUFwaXNPbmx5KTtcbiAgaWYgKGNvbmZpZy5sZXZlbC5kcm9wbGV0VG9vbHRpcHNEaXNhYmxlZCkge1xuICAgIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLnNldFRvb2x0aXBzRW5hYmxlZChmYWxzZSk7XG4gIH1cbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIucmVnaXN0ZXJCbG9ja3MoKTtcblxuICAvLyBCaW5kIGxpc3RlbmVyIHRvIHBhbGV0dGUvdG9vbGJveCAnSGlkZScgYW5kICdTaG93JyBsaW5rc1xuICB2YXIgaGlkZVRvb2xib3hIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9vbGJveC1oZWFkZXInKTtcbiAgdmFyIGhpZGVUb29sYm94SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoaWRlLXRvb2xib3gtaWNvbicpO1xuICB2YXIgc2hvd1Rvb2xib3hIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy10b29sYm94LWhlYWRlcicpO1xuICBpZiAoaGlkZVRvb2xib3hIZWFkZXIgJiYgaGlkZVRvb2xib3hJY29uICYmIHNob3dUb29sYm94SGVhZGVyKSB7XG4gICAgaGlkZVRvb2xib3hIZWFkZXIuY2xhc3NOYW1lICs9ICcgdG9nZ2xlYWJsZSc7XG4gICAgaGlkZVRvb2xib3hJY29uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB2YXIgaGFuZGxlVG9nZ2xlUGFsZXR0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvci5lbmFibGVQYWxldHRlKCF0aGlzLmVkaXRvci5wYWxldHRlRW5hYmxlZCk7XG4gICAgICAgIHNob3dUb29sYm94SGVhZGVyLnN0eWxlLmRpc3BsYXkgPVxuICAgICAgICAgICAgdGhpcy5lZGl0b3IucGFsZXR0ZUVuYWJsZWQgPyAnbm9uZScgOiAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgaGlkZVRvb2xib3hJY29uLnN0eWxlLmRpc3BsYXkgPVxuICAgICAgICAgICAgIXRoaXMuZWRpdG9yLnBhbGV0dGVFbmFibGVkID8gJ25vbmUnIDogJ2lubGluZS1ibG9jayc7XG4gICAgICAgIHRoaXMucmVzaXplVG9vbGJveEhlYWRlcigpO1xuICAgICAgfVxuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChoaWRlVG9vbGJveEhlYWRlciwgaGFuZGxlVG9nZ2xlUGFsZXR0ZSk7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzaG93VG9vbGJveEhlYWRlciwgaGFuZGxlVG9nZ2xlUGFsZXR0ZSk7XG4gIH1cblxuICB0aGlzLnJlc2l6ZVRvb2xib3hIZWFkZXIoKTtcblxuICB2YXIgc3RhcnRCbG9ja3MgPSBjb25maWcubGV2ZWwubGFzdEF0dGVtcHQgfHwgY29uZmlnLmxldmVsLnN0YXJ0QmxvY2tzO1xuICBpZiAoc3RhcnRCbG9ja3MpIHtcblxuICAgIHRyeSB7XG4gICAgICAvLyBEb24ndCBwYXNzIENSTEYgcGFpcnMgdG8gZHJvcGxldCB1bnRpbCB0aGV5IGZpeCBDUiBoYW5kbGluZzpcbiAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHN0YXJ0QmxvY2tzLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gY2F0Y2ggZXJyb3JzIHdpdGhvdXQgYmxvd2luZyB1cCBlbnRpcmVseS4gd2UgbWF5IHN0aWxsIG5vdCBiZSBpbiBhXG4gICAgICAvLyBncmVhdCBzdGF0ZVxuICAgICAgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFJlc2V0IGRyb3BsZXQgVW5kbyBzdGFjazpcbiAgICB0aGlzLmVkaXRvci5jbGVhclVuZG9TdGFjaygpO1xuICAgIC8vIFJlc2V0IGFjZSBVbmRvIHN0YWNrOlxuICAgIHZhciBVbmRvTWFuYWdlciA9IHdpbmRvdy5hY2UucmVxdWlyZShcImFjZS91bmRvbWFuYWdlclwiKS5VbmRvTWFuYWdlcjtcbiAgICB0aGlzLmVkaXRvci5hY2VFZGl0b3IuZ2V0U2Vzc2lvbigpLnNldFVuZG9NYW5hZ2VyKG5ldyBVbmRvTWFuYWdlcigpKTtcbiAgfVxuXG4gIGlmIChjb25maWcucmVhZG9ubHlXb3Jrc3BhY2UpIHtcbiAgICAvLyBXaGVuIGluIHJlYWRPbmx5IG1vZGUsIHNob3cgc291cmNlLCBidXQgZG8gbm90IGFsbG93IGVkaXRpbmcsXG4gICAgLy8gZGlzYWJsZSB0aGUgcGFsZXR0ZSwgYW5kIGhpZGUgdGhlIFVJIHRvIHNob3cgdGhlIHBhbGV0dGU6XG4gICAgdGhpcy5lZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgc2hvd1Rvb2xib3hIZWFkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIC8vIGRyb3BsZXQgbWF5IG5vdyBiZSBpbiBjb2RlIG1vZGUgaWYgaXQgY291bGRuJ3QgcGFyc2UgdGhlIGNvZGUgaW50b1xuICAvLyBibG9ja3MsIHNvIHVwZGF0ZSB0aGUgVUkgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgKGRvbid0IGF1dG9mb2N1c1xuICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgY3JlYXRlZCBhbiBpbnN0cnVjdGlvbnNEaWFsb2cgYXQgdGhpcyBzdGFnZSBvZiBpbml0KVxuICB0aGlzLm9uRHJvcGxldFRvZ2dsZV8oIXRoaXMuaW5zdHJ1Y3Rpb25zRGlhbG9nKTtcblxuICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5yZWdpc3RlckRyb3BsZXRCbG9ja01vZGVIYW5kbGVycyh0aGlzLmVkaXRvcik7XG5cbiAgdGhpcy5lZGl0b3Iub24oJ3BhbGV0dGV0b2dnbGVkb25lJywgZnVuY3Rpb24oZSkge1xuICAgIC8vIFJlcG9zaXRpb24gY2FsbG91dHMgYWZ0ZXIgYmxvY2svdGV4dCB0b2dnbGUgKGluIGNhc2UgdGhleSBuZWVkIHRvIG1vdmUpXG4gICAgJCgnLmNkby1xdGlwcycpLnF0aXAoJ3JlcG9zaXRpb24nLCBudWxsLCBmYWxzZSk7XG4gIH0pO1xuXG4gIGlmICh0aGlzLmluc3RydWN0aW9uc0RpYWxvZykge1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZHJvcGxldCBlZGl0b3IgaW4gdGV4dCBtb2RlIChhY2UpIGNhbiBzdGVhbCB0aGUgZm9jdXNcbiAgICAvLyBmcm9tIG91ciB2aXNpYmxlIGluc3RydWN0aW9ucyBkaWFsb2cuIFJlc3RvcmUgZm9jdXMgd2hlcmUgaXQgYmVsb25nczpcbiAgICB0aGlzLmluc3RydWN0aW9uc0RpYWxvZy5mb2N1cygpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5hZnRlckVkaXRvclJlYWR5KSB7XG4gICAgY29uZmlnLmFmdGVyRWRpdG9yUmVhZHkoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuYWZ0ZXJJbmplY3QpIHtcbiAgICBjb25maWcuYWZ0ZXJJbmplY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgYWRkaW5nL3JlbW92aW5nIGJyZWFrcG9pbnRzIGJ5IGNsaWNraW5nIGluIHRoZSBndXR0ZXIgb2YgdGhlIGVkaXRvci5cbiAqIFByZXJlcXVpc2l0ZXM6IERyb3BsZXQgZWRpdG9yIG11c3QgYmUgaW4gdXNlIGFuZCBpbml0aWFsaXplZCAoZS5nLiB5b3UgaGF2ZVxuICogdG8gY2FsbCBoYW5kbGVFZGl0Q29kZV8gZmlyc3QpLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmVuYWJsZUJyZWFrcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEcm9wbGV0IGVkaXRvciBtdXN0IGJlIGluIHVzZSB0byBlbmFibGUgYnJlYWtwb2ludHMuJyk7XG4gIH1cblxuICAvLyBTZXQgdXAgYW4gZXZlbnQgaGFuZGxlciB0byBjcmVhdGUgYnJlYWtwb2ludHMgd2hlbiBjbGlja2luZyBpbiB0aGUgZ3V0dGVyOlxuICB0aGlzLmVkaXRvci5vbignZ3V0dGVybW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBicHMgPSB0aGlzLmVkaXRvci5nZXRCcmVha3BvaW50cygpO1xuICAgIGlmIChicHNbZS5saW5lXSkge1xuICAgICAgdGhpcy5lZGl0b3IuY2xlYXJCcmVha3BvaW50KGUubGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWRpdG9yLnNldEJyZWFrcG9pbnQoZS5saW5lKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFNldCB3aGV0aGVyIHRvIGFsZXJ0IHVzZXIgdG8gZW1wdHkgYmxvY2tzLCBzaG9ydC1jaXJjdWl0aW5nIGFsbCBvdGhlciB0ZXN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tCbG9ja3MgV2hldGhlciB0byBjaGVjayBmb3IgZW1wdHkgYmxvY2tzLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnNldENoZWNrRm9yRW1wdHlCbG9ja3MgPSBmdW5jdGlvbiAoY2hlY2tCbG9ja3MpIHtcbiAgdGhpcy5jaGVja0ZvckVtcHR5QmxvY2tzXyA9IGNoZWNrQmxvY2tzO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHN0YXJ0aW5nIGJsb2NrKHMpLiAgRG9uJ3QgbG9hZCBsYXN0QXR0ZW1wdCBmb3IgSmlnc2F3IGxldmVscyBvciB0aGVcbiAqIGxldmVsIHdpbGwgYWR2YW5jZSBhcyBzb29uIGFzIGl0J3MgbG9hZGVkLlxuICogQHBhcmFtIGxvYWRMYXN0QXR0ZW1wdCBJZiB0cnVlLCB0cnkgdG8gbG9hZCBjb25maWcubGFzdEF0dGVtcHQuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuc2V0U3RhcnRCbG9ja3NfID0gZnVuY3Rpb24gKGNvbmZpZywgbG9hZExhc3RBdHRlbXB0KSB7XG4gIGlmIChjb25maWcubGV2ZWwuZWRpdF9ibG9ja3MpIHtcbiAgICBsb2FkTGFzdEF0dGVtcHQgPSBmYWxzZTtcbiAgfVxuICB2YXIgc3RhcnRCbG9ja3MgPSBjb25maWcubGV2ZWwuc3RhcnRCbG9ja3MgfHwgJyc7XG4gIGlmIChsb2FkTGFzdEF0dGVtcHQgJiYgY29uZmlnLmxldmVsR2FtZU5hbWUgIT09ICdKaWdzYXcnKSB7XG4gICAgc3RhcnRCbG9ja3MgPSBjb25maWcubGV2ZWwubGFzdEF0dGVtcHQgfHwgc3RhcnRCbG9ja3M7XG4gIH1cbiAgaWYgKGNvbmZpZy5mb3JjZUluc2VydFRvcEJsb2NrKSB7XG4gICAgc3RhcnRCbG9ja3MgPSBibG9ja1V0aWxzLmZvcmNlSW5zZXJ0VG9wQmxvY2soc3RhcnRCbG9ja3MsXG4gICAgICAgIGNvbmZpZy5mb3JjZUluc2VydFRvcEJsb2NrKTtcbiAgfVxuICBzdGFydEJsb2NrcyA9IHRoaXMuYXJyYW5nZUJsb2NrUG9zaXRpb24oc3RhcnRCbG9ja3MsIGNvbmZpZy5ibG9ja0FycmFuZ2VtZW50KTtcbiAgdHJ5IHtcbiAgICB0aGlzLmxvYWRCbG9ja3Moc3RhcnRCbG9ja3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGxvYWRMYXN0QXR0ZW1wdCkge1xuICAgICAgQmxvY2tseS5tYWluQmxvY2tTcGFjZS5jbGVhcigpO1xuICAgICAgLy8gVHJ5IGxvYWRpbmcgdGhlIGRlZmF1bHQgc3RhcnQgYmxvY2tzIGluc3RlYWQuXG4gICAgICB0aGlzLnNldFN0YXJ0QmxvY2tzXyhjb25maWcsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyB0aGUgY29uZmlndXJlZCBzdGFydGluZyBmdW5jdGlvbiBkZWZpbml0aW9uLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLm9wZW5GdW5jdGlvbkRlZmluaXRpb25fID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGlmIChCbG9ja2x5LmNvbnRyYWN0RWRpdG9yKSB7XG4gICAgQmxvY2tseS5jb250cmFjdEVkaXRvci5hdXRvT3BlbldpdGhMZXZlbENvbmZpZ3VyYXRpb24oe1xuICAgICAgYXV0b09wZW5GdW5jdGlvbjogY29uZmlnLmxldmVsLm9wZW5GdW5jdGlvbkRlZmluaXRpb24sXG4gICAgICBjb250cmFjdENvbGxhcHNlOiBjb25maWcubGV2ZWwuY29udHJhY3RDb2xsYXBzZSxcbiAgICAgIGNvbnRyYWN0SGlnaGxpZ2h0OiBjb25maWcubGV2ZWwuY29udHJhY3RIaWdobGlnaHQsXG4gICAgICBleGFtcGxlc0NvbGxhcHNlOiBjb25maWcubGV2ZWwuZXhhbXBsZXNDb2xsYXBzZSxcbiAgICAgIGV4YW1wbGVzSGlnaGxpZ2h0OiBjb25maWcubGV2ZWwuZXhhbXBsZXNIaWdobGlnaHQsXG4gICAgICBkZWZpbml0aW9uQ29sbGFwc2U6IGNvbmZpZy5sZXZlbC5kZWZpbml0aW9uQ29sbGFwc2UsXG4gICAgICBkZWZpbml0aW9uSGlnaGxpZ2h0OiBjb25maWcubGV2ZWwuZGVmaW5pdGlvbkhpZ2hsaWdodFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIEJsb2NrbHkuZnVuY3Rpb25FZGl0b3IuYXV0b09wZW5GdW5jdGlvbihjb25maWcubGV2ZWwub3BlbkZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYW5kbGVVc2luZ0Jsb2NrbHlfID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAvLyBBbGxvdyBlbXB0eSBibG9ja3MgaWYgZWRpdGluZyBibG9ja3MuXG4gIGlmIChjb25maWcubGV2ZWwuZWRpdF9ibG9ja3MpIHtcbiAgICB0aGlzLmNoZWNrRm9yRW1wdHlCbG9ja3NfID0gZmFsc2U7XG4gICAgaWYgKGNvbmZpZy5sZXZlbC5lZGl0X2Jsb2NrcyA9PT0gJ3JlcXVpcmVkX2Jsb2NrcycgfHxcbiAgICAgICAgY29uZmlnLmxldmVsLmVkaXRfYmxvY2tzID09PSAndG9vbGJveF9ibG9ja3MnIHx8XG4gICAgICAgIGNvbmZpZy5sZXZlbC5lZGl0X2Jsb2NrcyA9PT0gJ3JlY29tbWVuZGVkX2Jsb2NrcycpIHtcbiAgICAgIC8vIERvbid0IHNob3cgd2hlbiBydW4gYmxvY2sgZm9yIHRvb2xib3gvcmVxdWlyZWQvcmVjb21tZW5kZWQgYmxvY2sgZWRpdGluZ1xuICAgICAgY29uZmlnLmZvcmNlSW5zZXJ0VG9wQmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGxldmVsYnVpbGRlciBwcm92aWRlcyBhbiBlbXB0eSB0b29sYm94LCBzb21lIGFwcHMgKGxpa2UgYXJ0aXN0KVxuICAvLyByZXBsYWNlIGl0IHdpdGggYSBmdWxsIHRvb2xib3guIEkgdGhpbmsgc29tZSBsZXZlbHMgbWF5IGRlcGVuZCBvbiB0aGlzXG4gIC8vIGJlaGF2aW9yLiBXZSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgbm8gdG9vbGJveCwgd2hpY2ggaXMgPHhtbD48L3htbD5cbiAgaWYgKGNvbmZpZy5sZXZlbC50b29sYm94KSB7XG4gICAgdmFyIHRvb2xib3hXaXRob3V0V2hpdGVzcGFjZSA9IGNvbmZpZy5sZXZlbC50b29sYm94LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgaWYgKHRvb2xib3hXaXRob3V0V2hpdGVzcGFjZSA9PT0gJzx4bWw+PC94bWw+JyB8fFxuICAgICAgICB0b29sYm94V2l0aG91dFdoaXRlc3BhY2UgPT09ICc8eG1sLz4nKSB7XG4gICAgICBjb25maWcubGV2ZWwudG9vbGJveCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICB2YXIgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVXb3Jrc3BhY2UnKTtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgdG9vbGJveDogY29uZmlnLmxldmVsLnRvb2xib3gsXG4gICAgZGlzYWJsZVBhcmFtRWRpdGluZzogdXRpbHMudmFsdWVPcihjb25maWcubGV2ZWwuZGlzYWJsZVBhcmFtRWRpdGluZywgdHJ1ZSksXG4gICAgZGlzYWJsZVZhcmlhYmxlRWRpdGluZzogdXRpbHMudmFsdWVPcihjb25maWcubGV2ZWwuZGlzYWJsZVZhcmlhYmxlRWRpdGluZywgZmFsc2UpLFxuICAgIHVzZU1vZGFsRnVuY3Rpb25FZGl0b3I6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLnVzZU1vZGFsRnVuY3Rpb25FZGl0b3IsIGZhbHNlKSxcbiAgICB1c2VDb250cmFjdEVkaXRvcjogdXRpbHMudmFsdWVPcihjb25maWcubGV2ZWwudXNlQ29udHJhY3RFZGl0b3IsIGZhbHNlKSxcbiAgICBkaXNhYmxlRXhhbXBsZXM6IHV0aWxzLnZhbHVlT3IoY29uZmlnLmxldmVsLmRpc2FibGVFeGFtcGxlcywgZmFsc2UpLFxuICAgIGRlZmF1bHROdW1FeGFtcGxlQmxvY2tzOiB1dGlscy52YWx1ZU9yKGNvbmZpZy5sZXZlbC5kZWZhdWx0TnVtRXhhbXBsZUJsb2NrcywgMiksXG4gICAgc2Nyb2xsYmFyczogY29uZmlnLmxldmVsLnNjcm9sbGJhcnMsXG4gICAgaGFzVmVydGljYWxTY3JvbGxiYXJzOiBjb25maWcuaGFzVmVydGljYWxTY3JvbGxiYXJzLFxuICAgIGhhc0hvcml6b250YWxTY3JvbGxiYXJzOiBjb25maWcuaGFzSG9yaXpvbnRhbFNjcm9sbGJhcnMsXG4gICAgZWRpdEJsb2NrczogdXRpbHMudmFsdWVPcihjb25maWcubGV2ZWwuZWRpdF9ibG9ja3MsIGZhbHNlKSxcbiAgICByZWFkT25seTogdXRpbHMudmFsdWVPcihjb25maWcucmVhZG9ubHlXb3Jrc3BhY2UsIGZhbHNlKSxcbiAgICBzaG93RXhhbXBsZVRlc3RCdXR0b25zOiB1dGlscy52YWx1ZU9yKGNvbmZpZy5zaG93RXhhbXBsZVRlc3RCdXR0b25zLCBmYWxzZSlcbiAgfTtcbiAgWyd0cmFzaGNhbicsICd2YXJzSW5HbG9iYWxzJywgJ2dyYXlPdXRVbmRlbGV0YWJsZUJsb2NrcycsXG4gICAgJ2Rpc2FibGVQYXJhbUVkaXRpbmcnXS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBpZiAoY29uZmlnW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IGNvbmZpZ1twcm9wXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgdGhpcy5pbmplY3QoZGl2LCBvcHRpb25zKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuXG4gIGlmIChjb25maWcuYWZ0ZXJJbmplY3QpIHtcbiAgICBjb25maWcuYWZ0ZXJJbmplY3QoKTtcbiAgfVxuICB0aGlzLnNldFN0YXJ0QmxvY2tzXyhjb25maWcsIHRydWUpO1xufTtcblxuLyoqXG4gKiBNb2RpZnkgdGhlIHdvcmtzcGFjZSBoZWFkZXIgYWZ0ZXIgYSBkcm9wbGV0IGJsb2Nrcy9jb2RlIG9yIHBhbGV0dGUgdG9nZ2xlXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUudXBkYXRlSGVhZGVyc0FmdGVyRHJvcGxldFRvZ2dsZV8gPSBmdW5jdGlvbiAodXNpbmdCbG9ja3MpIHtcbiAgLy8gVXBkYXRlIGhlYWRlciB0aXRsZXM6XG4gIHZhciBzaG93Q29kZUhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWNvZGUtaGVhZGVyJyk7XG4gIHZhciBjb250ZW50U3BhbiA9IHNob3dDb2RlSGVhZGVyLmZpcnN0Q2hpbGQ7XG4gIHZhciBmb250QXdlc29tZUdseXBoID0gXy5maW5kKGNvbnRlbnRTcGFuLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIC9cXGJmYVxcYi8udGVzdChub2RlLmNsYXNzTmFtZSk7XG4gIH0pO1xuICB2YXIgaW1nQmxvY2tzR2x5cGggPSBfLmZpbmQoY29udGVudFNwYW4uY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gL1xcYmJsb2Nrcy1nbHlwaFxcYi8udGVzdChub2RlLmNsYXNzTmFtZSk7XG4gIH0pO1xuXG4gIC8vIENoYW5nZSBnbHlwaFxuICBpZiAodXNpbmdCbG9ja3MpIHtcbiAgICBpZiAoZm9udEF3ZXNvbWVHbHlwaCAmJiBpbWdCbG9ja3NHbHlwaCkge1xuICAgICAgZm9udEF3ZXNvbWVHbHlwaC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICBpbWdCbG9ja3NHbHlwaC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBjb250ZW50U3Bhbi5sYXN0Q2hpbGQudGV4dENvbnRlbnQgPSBtc2cuc2hvd1RleHRIZWFkZXIoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZm9udEF3ZXNvbWVHbHlwaCAmJiBpbWdCbG9ja3NHbHlwaCkge1xuICAgICAgZm9udEF3ZXNvbWVHbHlwaC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgaW1nQmxvY2tzR2x5cGguc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIH1cbiAgICBjb250ZW50U3Bhbi5sYXN0Q2hpbGQudGV4dENvbnRlbnQgPSBtc2cuc2hvd0Jsb2Nrc0hlYWRlcigpO1xuICB9XG5cbiAgdmFyIGJsb2NrQ291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxvY2tDb3VudGVyJyk7XG4gIGlmIChibG9ja0NvdW50KSB7XG4gICAgYmxvY2tDb3VudC5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICh1c2luZ0Jsb2NrcyAmJiB0aGlzLmVuYWJsZVNob3dCbG9ja0NvdW50KSA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSB1cGRhdGVzIGFmdGVyIGEgZHJvcGxldCB0b2dnbGUgYmV0d2VlbiBibG9ja3MvY29kZSBoYXMgdGFrZW4gcGxhY2VcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5vbkRyb3BsZXRUb2dnbGVfID0gZnVuY3Rpb24gKGF1dG9Gb2N1cykge1xuICBhdXRvRm9jdXMgPSB1dGlscy52YWx1ZU9yKGF1dG9Gb2N1cywgdHJ1ZSk7XG4gIHRoaXMudXBkYXRlSGVhZGVyc0FmdGVyRHJvcGxldFRvZ2dsZV8odGhpcy5lZGl0b3IuY3VycmVudGx5VXNpbmdCbG9ja3MpO1xuICBpZiAoIXRoaXMuZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzKSB7XG4gICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgdGhpcy5lZGl0b3IuYWNlRWRpdG9yLmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLnJlZ2lzdGVyRHJvcGxldFRleHRNb2RlSGFuZGxlcnModGhpcy5lZGl0b3IpO1xuICB9XG59O1xuXG4vKipcbiAqIERvIHdlIGhhdmUgYW55IGZsb2F0aW5nIGJsb2NrcyBub3QgYXR0YWNoZWQgdG8gYW4gZXZlbnQgYmxvY2sgb3IgZnVuY3Rpb24gYmxvY2s/XG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFzRXh0cmFUb3BCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZlZWRiYWNrXy5oYXNFeHRyYVRvcEJsb2NrcygpO1xufTtcblxuLyoqXG4gKlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhc1F1ZXN0aW9uTWFya3NJbk51bWJlckZpZWxkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5mZWVkYmFja18uaGFzUXVlc3Rpb25NYXJrc0luTnVtYmVyRmllbGQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgbm9uLWV4YW1wbGUgYmxvY2sgaW4gdGhlIHdvcmtzcGFjZSBoYXMgYW4gdW5maWxsZWQgaW5wdXRcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5oYXNVbmZpbGxlZEZ1bmN0aW9uYWxCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5nZXRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9jaygpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QmxvY2t9IFRoZSBmaXJzdCBibG9jayB0aGF0IGhhcyBhbiB1bmZpbGxlZCBpbnB1dCwgb3IgdW5kZWZpbmVkXG4gKiAgIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9ja18oZnVuY3Rpb24gKHJvb3RCbG9jaykge1xuICAgIHJldHVybiByb290QmxvY2sudHlwZSAhPT0gJ2Z1bmN0aW9uYWxfZXhhbXBsZSc7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QmxvY2t9IFRoZSBmaXJzdCBleGFtcGxlIGJsb2NrIHRoYXQgaGFzIGFuIHVuZmlsbGVkIGlucHV0LCBvclxuICogICB1bmRlZmluZWQgaWYgdGhlcmUgaXNuJ3Qgb25lLiBJZ25vcmVzIGV4YW1wbGUgYmxvY2tzIHRoYXQgZG9uJ3QgaGF2ZSBhXG4gKiAgIGNhbGwgcG9ydGlvbiwgYXMgdGhlc2UgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRVbmZpbGxlZEZ1bmN0aW9uYWxFeGFtcGxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJlZFVuZmlsbGVkRnVuY3Rpb25hbEJsb2NrXyhmdW5jdGlvbiAocm9vdEJsb2NrKSB7XG4gICAgaWYgKHJvb3RCbG9jay50eXBlICE9PSAnZnVuY3Rpb25hbF9leGFtcGxlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYWN0dWFsID0gcm9vdEJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soJ0FDVFVBTCcpO1xuICAgIHJldHVybiBhY3R1YWwgJiYgYWN0dWFsLmdldFRpdGxlVmFsdWUoJ05BTUUnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZpbHRlciBSdW4gYWdhaW5zdCByb290IGJsb2NrIGluIGNoYWluLiBSZXR1cm5zIHRydWUgaWZcbiAqICAgdGhpcyBpcyBhIGJsb2NrIHdlIGNhcmUgYWJvdXRcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRGaWx0ZXJlZFVuZmlsbGVkRnVuY3Rpb25hbEJsb2NrXyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIHVuZmlsbGVkQmxvY2s7XG4gIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCkuc29tZShmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAvLyBHZXQgdGhlIHJvb3QgYmxvY2sgaW4gdGhlIGNoYWluXG4gICAgdmFyIHJvb3RCbG9jayA9IGJsb2NrLmdldFJvb3RCbG9jaygpO1xuICAgIGlmICghZmlsdGVyKHJvb3RCbG9jaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2suaGFzVW5maWxsZWRGdW5jdGlvbmFsSW5wdXQoKSkge1xuICAgICAgdW5maWxsZWRCbG9jayA9IGJsb2NrO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdW5maWxsZWRCbG9jaztcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgZXhhbXBsZXMsIG9yXG4gKiAgIHVuZGVmaW5lZCBpZiBhbGwgaGF2ZSBhdCBsZWFzdCBvbmUuXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZ2V0RnVuY3Rpb25XaXRob3V0VHdvRXhhbXBsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZpbml0aW9uTmFtZXMgPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldFRvcEJsb2NrcygpLmZpbHRlcihmdW5jdGlvbiAoYmxvY2spIHtcbiAgICByZXR1cm4gYmxvY2sudHlwZSA9PT0gJ2Z1bmN0aW9uYWxfZGVmaW5pdGlvbicgJiYgIWJsb2NrLmlzVmFyaWFibGUoKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChkZWZpbml0aW9uQmxvY2spIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbkJsb2NrLmdldFByb2NlZHVyZUluZm8oKS5uYW1lO1xuICB9KTtcblxuICB2YXIgZXhhbXBsZU5hbWVzID0gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRUb3BCbG9ja3MoKS5maWx0ZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrLnR5cGUgIT09ICdmdW5jdGlvbmFsX2V4YW1wbGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT25seSBjYXJlIGFib3V0IGZ1bmN0aW9uYWxfZXhhbXBsZXMgdGhhdCBoYXZlIGFuIEFDVFVBTCBpbnB1dCAoaS5lLiBpdCdzXG4gICAgLy8gY2xlYXIgd2hpY2ggZnVuY3Rpb24gdGhleSdyZSBmb3JcbiAgICB2YXIgYWN0dWFsID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jaygnQUNUVUFMJyk7XG4gICAgcmV0dXJuIGFjdHVhbCAmJiBhY3R1YWwuZ2V0VGl0bGVWYWx1ZSgnTkFNRScpO1xuICB9KS5tYXAoZnVuY3Rpb24gKGV4YW1wbGVCbG9jaykge1xuICAgIHJldHVybiBleGFtcGxlQmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jaygnQUNUVUFMJykuZ2V0VGl0bGVWYWx1ZSgnTkFNRScpO1xuICB9KTtcblxuICB2YXIgZGVmaW5pdGlvbldpdGhMZXNzVGhhblR3b0V4YW1wbGVzO1xuICBkZWZpbml0aW9uTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgdmFyIGRlZmluaXRpb25FeGFtcGxlcyA9IGV4YW1wbGVOYW1lcy5maWx0ZXIoZnVuY3Rpb24oZXhhbXBsZSkge1xuICAgICAgcmV0dXJuIGRlZiA9PT0gZXhhbXBsZTtcbiAgICB9KTtcblxuICAgIGlmIChkZWZpbml0aW9uRXhhbXBsZXMubGVuZ3RoIDwgMikge1xuICAgICAgZGVmaW5pdGlvbldpdGhMZXNzVGhhblR3b0V4YW1wbGVzID0gZGVmO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZWZpbml0aW9uV2l0aExlc3NUaGFuVHdvRXhhbXBsZXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSB3aGVuIHdlIGhhdmUgYW4gdW5maWxsZWQgYmxvY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgVGhlIGJsb2NrLnR5cGUgRm9yIG91ciBleHBlY3RlZCB0b3AgbGV2ZWwgYmxvY2tcbiAqL1xuU3R1ZGlvQXBwLnByb3RvdHlwZS5nZXRVbmZpbGxlZEZ1bmN0aW9uYWxCbG9ja0Vycm9yID0gZnVuY3Rpb24gKHRvcExldmVsVHlwZSkge1xuICB2YXIgdW5maWxsZWQgPSB0aGlzLmdldFVuZmlsbGVkRnVuY3Rpb25hbEJsb2NrKCk7XG5cbiAgaWYgKCF1bmZpbGxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHRvcFBhcmVudCA9IHVuZmlsbGVkO1xuICB3aGlsZSAodG9wUGFyZW50LmdldFBhcmVudCgpKSB7XG4gICAgdG9wUGFyZW50ID0gdG9wUGFyZW50LmdldFBhcmVudCgpO1xuICB9XG5cbiAgaWYgKHVuZmlsbGVkLnR5cGUgPT09IHRvcExldmVsVHlwZSkge1xuICAgIHJldHVybiBtc2cuZW1wdHlUb3BMZXZlbEJsb2NrKHt0b3BMZXZlbEJsb2NrTmFtZTogdW5maWxsZWQuZ2V0VGl0bGVWYWx1ZSgpfSk7XG4gIH1cblxuICBpZiAodG9wUGFyZW50LnR5cGUgIT09ICdmdW5jdGlvbmFsX2RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIG1zZy5lbXB0eUZ1bmN0aW9uYWxCbG9jaygpO1xuICB9XG5cbiAgdmFyIHByb2NlZHVyZUluZm8gPSB0b3BQYXJlbnQuZ2V0UHJvY2VkdXJlSW5mbygpO1xuICBpZiAodG9wUGFyZW50LmlzVmFyaWFibGUoKSkge1xuICAgIHJldHVybiBtc2cuZW1wdHlCbG9ja0luVmFyaWFibGUoe25hbWU6IHByb2NlZHVyZUluZm8ubmFtZX0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtc2cuZW1wdHlCbG9ja0luRnVuY3Rpb24oe25hbWU6IHByb2NlZHVyZUluZm8ubmFtZX0pO1xuICB9XG59O1xuXG4vKipcbiAqIExvb2tzIGZvciBmYWlsaW5nIGV4YW1wbGVzLCBhbmQgdXBkYXRlcyB0aGUgcmVzdWx0IHRleHQgZm9yIHRoZW0gaWYgdGhleSdyZVxuICogb3BlbiBpbiB0aGUgY29udHJhY3QgZWRpdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsdXJlQ2hlY2tlciBBcHBzIGV4YW1wbGUgdGVzdGVyIHRoYXQgdGFrZXMgaW4gYW4gZXhhbXBsZVxuICogICBibG9jaywgYW5kIG91dHB1dHMgYSBmYWlsdXJlIHN0cmluZyAob3IgbnVsbCBpZiBzdWNjZXNzKVxuICogQHJldHVybnMge3N0cmluZ30gTmFtZSBvZiBibG9jayBjb250YWluaW5nIGZpcnN0IGZhaWxpbmcgZXhhbXBsZSB3ZSBmb3VuZCwgb3JcbiAqICAgZW1wdHkgc3RyaW5nIGlmIG5vIGZhaWx1cmVzLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmNoZWNrRm9yRmFpbGluZ0V4YW1wbGVzID0gZnVuY3Rpb24gKGZhaWx1cmVDaGVja2VyKSB7XG4gIHZhciBmYWlsaW5nQmxvY2tOYW1lID0gJyc7XG4gIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZmluZEZ1bmN0aW9uRXhhbXBsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChleGFtcGxlQmxvY2spIHtcbiAgICB2YXIgZmFpbHVyZSA9IGZhaWx1cmVDaGVja2VyKGV4YW1wbGVCbG9jaywgZmFsc2UpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBleGFtcGxlIHJlc3VsdC4gTm8tb3AgaWYgd2UncmUgbm90IGN1cnJlbnRseSBlZGl0aW5nIHRoaXNcbiAgICAvLyBmdW5jdGlvbi5cbiAgICBCbG9ja2x5LmNvbnRyYWN0RWRpdG9yLnVwZGF0ZUV4YW1wbGVSZXN1bHQoZXhhbXBsZUJsb2NrLCBmYWlsdXJlKTtcblxuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICBmYWlsaW5nQmxvY2tOYW1lID0gZXhhbXBsZUJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soJ0FDVFVBTCcpXG4gICAgICAgIC5nZXRUaXRsZVZhbHVlKCdOQU1FJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZhaWxpbmdCbG9ja05hbWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdlIGhhdmUgYSBmdW5jdGlvbiBvciB2YXJpYWJsZSBuYW1lZCBcIlwiIChlbXB0eSBzdHJpbmcpXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuaGFzRW1wdHlGdW5jdGlvbk9yVmFyaWFibGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRUb3BCbG9ja3MoKS5zb21lKGZ1bmN0aW9uIChibG9jaykge1xuICAgIGlmIChibG9jay50eXBlICE9PSAnZnVuY3Rpb25hbF9kZWZpbml0aW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhKGJsb2NrLmdldFByb2NlZHVyZUluZm8oKS5uYW1lKTtcbiAgfSk7XG59O1xuXG5TdHVkaW9BcHAucHJvdG90eXBlLmNyZWF0ZUNvb3JkaW5hdGVHcmlkQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzdmdOYW1lID0gb3B0aW9ucy5zdmc7XG4gIHZhciBvcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgdmFyIGZpcnN0TGFiZWwgPSBvcHRpb25zLmZpcnN0TGFiZWw7XG4gIHZhciBsYXN0TGFiZWwgPSBvcHRpb25zLmxhc3RMYWJlbDtcbiAgdmFyIGluY3JlbWVudCA9IG9wdGlvbnMuaW5jcmVtZW50O1xuXG4gIHZhciBDQU5WQVNfSEVJR0hUID0gNDAwO1xuICB2YXIgQ0FOVkFTX1dJRFRIID0gNDAwO1xuXG4gIHZhciBzdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdmdOYW1lKTtcblxuICB2YXIgYmJveCwgdGV4dCwgcmVjdDtcbiAgZm9yICh2YXIgbGFiZWwgPSBmaXJzdExhYmVsOyBsYWJlbCA8PSBsYXN0TGFiZWw7IGxhYmVsICs9IGluY3JlbWVudCkge1xuICAgIC8vIGNyZWF0ZSB4IGF4aXMgbGFiZWxzXG4gICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpO1xuICAgIHRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwpKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCd4JywgbGFiZWwgLSBvcmlnaW4gLSBiYm94LndpZHRoIC8gMik7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3knLCBDQU5WQVNfSEVJR0hUKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCAnYm9sZCcpO1xuICAgIHJlY3QgPSByZWN0RnJvbUVsZW1lbnRCb3VuZGluZ0JveCh0ZXh0KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICd3aGl0ZScpO1xuICAgIHN2Zy5pbnNlcnRCZWZvcmUocmVjdCwgdGV4dCk7XG5cbiAgICAvLyBjcmVhdGUgeSBheGlzIGxhYmVsc1xuICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RleHQnKTtcbiAgICB0ZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsKSk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKHRleHQpO1xuICAgIGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCd5JywgQ0FOVkFTX0hFSUdIVCAtIChsYWJlbCAtIG9yaWdpbikpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCdkb21pbmFudC1iYXNlbGluZScsICdjZW50cmFsJyk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKTtcbiAgICByZWN0ID0gcmVjdEZyb21FbGVtZW50Qm91bmRpbmdCb3godGV4dCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnd2hpdGUnKTtcbiAgICBzdmcuaW5zZXJ0QmVmb3JlKHJlY3QsIHRleHQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWN0RnJvbUVsZW1lbnRCb3VuZGluZ0JveChlbGVtZW50KSB7XG4gIHZhciBiYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gIHZhciByZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdyZWN0Jyk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCd4JywgYmJveC54KTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCBiYm94LnkpO1xuICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBiYm94LndpZHRoKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJib3guaGVpZ2h0KTtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qKlxuICogRGlzcGxheXMgYSBzbWFsbCBhbGVydCBib3ggaW5zaWRlIERPTSBlbGVtZW50IGF0IHBhcmVudFNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFNlbGVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgQSBzZXQgb2YgUmVhY3QgcHJvcGVydGllcyBwYXNzZWQgdG8gdGhlIEFidXNlRXJyb3JcbiAqICAgY29tcG9uZW50XG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuZGlzcGxheUFsZXJ0ID0gZnVuY3Rpb24gKHBhcmVudFNlbGVjdG9yLCBwcm9wcykge1xuICAvLyBFYWNoIHBhcmVudCBpcyBhc3N1bWVkIHRvIGhhdmUgYXQgbW9zdCBhIHNpbmdsZSBhbGVydC4gVGhpcyBhc3N1bXB0aW9uXG4gIC8vIGNvdWxkIGJlIGNoYW5nZWQsIGJ1dCB3ZSB3b3VsZCB0aGVuIHdhbnQgdG8gY2xlYW4gdXAgb3VyIERPTSBlbGVtZW50IG9uXG4gIC8vIGNsb3NlXG4gIHZhciBwYXJlbnQgPSAkKHBhcmVudFNlbGVjdG9yKTtcbiAgdmFyIGNvbnRhaW5lciA9IHBhcmVudC5jaGlsZHJlbignLnJlYWN0LWFsZXJ0Jyk7XG4gIGlmIChjb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgY29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3JlYWN0LWFsZXJ0Jy8+XCIpO1xuICAgIHBhcmVudC5hcHBlbmQoY29udGFpbmVyKTtcbiAgfVxuXG4gIHZhciByZWFjdFByb3BzID0gJC5leHRlbmQoe30sIHtcbiAgICBjbGFzc05hbWU6ICdhbGVydC1lcnJvcicsXG4gICAgb25DbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3QudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXJbMF0pO1xuICAgIH1cbiAgfSwgcHJvcHMpO1xuXG4gIHZhciBlbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChBbGVydCwgcmVhY3RQcm9wcyk7XG4gIFJlYWN0LnJlbmRlcihlbGVtZW50LCBjb250YWluZXJbMF0pO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgY3VycmVudCBwcm9qZWN0IGlzIGNvbnNpZGVyZWQgYWJ1c2l2ZSwgZGlzcGxheSBhIHNtYWxsIGFsZXJ0IGJveFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFNlbGVjdG9yIFRoZSBzZWxlY3RvciBmb3IgdGhlIERPTSBlbGVtZW50IHBhcmVudCB3ZVxuICogICBzaG91bGQgZGlzcGxheSB0aGUgZXJyb3IgaW4uXG4gKi9cblN0dWRpb0FwcC5wcm90b3R5cGUuYWxlcnRJZkFidXNpdmVQcm9qZWN0ID0gZnVuY3Rpb24gKHBhcmVudFNlbGVjdG9yKSB7XG4gIGlmICh3aW5kb3cuZGFzaGJvYXJkICYmIGRhc2hib2FyZC5wcm9qZWN0LmV4Y2VlZHNBYnVzZVRocmVzaG9sZCgpKSB7XG4gICAgdGhpcy5kaXNwbGF5QWxlcnQocGFyZW50U2VsZWN0b3IsIHtcbiAgICAgIGJvZHk6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoZGFzaGJvYXJkLkFidXNlRXJyb3IsIHtcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIHRvczogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ3Byb2plY3QuYWJ1c2UudG9zJyksXG4gICAgICAgICAgY29udGFjdF91czogd2luZG93LmRhc2hib2FyZC5pMThuLnQoJ3Byb2plY3QuYWJ1c2UuY29udGFjdF91cycpXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG9wOiA0NSxcbiAgICAgICAgbGVmdDogMzUwLFxuICAgICAgICByaWdodDogNTBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgY2FzZXMgd2hlcmUgd2UgaGF2ZSB0d28gKG9yIG1vcmUpIG5lc3RlZCBmb3IgbG9vcHMgaW4gd2hpY2hcbiAqIGJvdGggbG9vcHMgdXNlIHRoZSBzYW1lIHZhcmlhYmxlLiBUaGlzIGNhbiBjYXVzZSBpbmZpbml0ZSBsb29wcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdlIGRldGVjdCBhbiBpbnN0YW5jZSBvZiB0aGlzLlxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmhhc0R1cGxpY2F0ZVZhcmlhYmxlc0luRm9yTG9vcHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVkaXRDb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUodGhpcy5mb3JMb29wSGFzRHVwbGljYXRlZE5lc3RlZFZhcmlhYmxlc18pO1xufTtcblxuLyoqXG4gKiBMb29rcyB0byBzZWUgaWYgYSBwYXJ0aWN1bGFyIGJsb2NrIGlzIChhKSBhIGZvciBsb29wIGFuZCAoYikgaGFzIGEgZGVzY2VuZGFudFxuICogZm9yIGxvb3AgdXNpbmcgdGhlIHNhbWUgdmFyaWFibGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGF0IGlzIHRydWUgb2YgdGhpcyBibG9ja1xuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLmZvckxvb3BIYXNEdXBsaWNhdGVkTmVzdGVkVmFyaWFibGVzXyA9IGZ1bmN0aW9uIChibG9jaykge1xuICBpZiAoIWJsb2NrIHx8IGJsb2NrLnR5cGUgIT09ICdjb250cm9sc19mb3InICYmXG4gICAgICBibG9jay50eXBlICE9PSAnY29udHJvbHNfZm9yX2NvdW50ZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlubmVyQmxvY2sgPSBibG9jay5nZXRJbnB1dCgnRE8nKS5jb25uZWN0aW9uLnRhcmdldEJsb2NrKCk7XG5cbiAgLy8gTm90IHRoZSBtb3N0IGVmZmljaWVudCBvZiBhbGdvJ3MsIGJ1dCB3ZSBzaG91bGRuJ3QgaGF2ZSBlbm91Z2ggYmxvY2tzIGZvclxuICAvLyBpdCB0byBtYXR0ZXIuXG4gIHJldHVybiBibG9jay5nZXRWYXJzKCkuc29tZShmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgIHJldHVybiBpbm5lckJsb2NrLmdldERlc2NlbmRhbnRzKCkuc29tZShmdW5jdGlvbiAoZGVzY2VuZGFudCkge1xuICAgICAgaWYgKGRlc2NlbmRhbnQudHlwZSAhPT0gJ2NvbnRyb2xzX2ZvcicgJiZcbiAgICAgICAgICBkZXNjZW5kYW50LnR5cGUgIT09ICdjb250cm9sc19mb3JfY291bnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NlbmRhbnQuZ2V0VmFycygpLmluZGV4T2YodmFyTmFtZSkgIT09IC0xO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUG9saXNoZXMgdGhlIGdlbmVyYXRlZCBjb2RlIHN0cmluZyBiZWZvcmUgZGlzcGxheWluZyBpdCB0byB0aGUgdXNlci4gSWYgdGhlXG4gKiBhcHAgcHJvdmlkZWQgYSBwb2xpc2hDb2RlSG9vayBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb2RlIHN0cmluZyB0aGF0IG1heS9tYXkgbm90IGhhdmUgYmVlbiBtb2RpZmllZFxuICovXG5TdHVkaW9BcHAucHJvdG90eXBlLnBvbGlzaEdlbmVyYXRlZENvZGVTdHJpbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICBpZiAodGhpcy5wb2xpc2hDb2RlSG9vaykge1xuICAgIHJldHVybiB0aGlzLnBvbGlzaENvZGVIb29rKGNvZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb2RlO1xuICB9XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJykgOyBidWYucHVzaCgnXFxuXFxuPGRpdiBpZD1cIm1ha2UteW91ci1vd25cIj5cXG5cXG4gIDxoMT48YSBocmVmPScsIGVzY2FwZSgoNSwgIGRhdGEubWFrZVVybCApKSwgJz4nLCBlc2NhcGUoKDUsICBkYXRhLm1ha2VTdHJpbmcgKSksICc8L2E+PC9oMT5cXG4gIDxhIGhyZWY9JywgZXNjYXBlKCg2LCAgZGF0YS5tYWtlVXJsICkpLCAnPjxpbWcgc3JjPScsIGVzY2FwZSgoNiwgIGRhdGEubWFrZUltYWdlICkpLCAnPjwvYT5cXG5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7IHZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKSA7IGJ1Zi5wdXNoKCdcXG5cXG4nKTszOyB2YXIgcm9vdCA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QucmVwbGFjZSgnbGVhcm5cXC4nLCAnJykucmVwbGFjZSgnc3R1ZGlvXFwuJywgJycpOyBcbjsgYnVmLnB1c2goJ1xcblxcbjxkaXYgaWQ9XCJsZWFyblwiPlxcblxcbiAgPGgxPjxhIGhyZWY9XCInLCBlc2NhcGUoKDcsICByb290ICkpLCAnXCI+JywgZXNjYXBlKCg3LCAgbXNnLndhbnRUb0xlYXJuKCkgKSksICc8L2E+PC9oMT5cXG4gIDxhIGhyZWY9XCInLCBlc2NhcGUoKDgsICByb290ICkpLCAnXCI+PGltZyBpZD1cImxlYXJuLXRvLWNvZGVcIiBzcmM9XCInLCBlc2NhcGUoKDgsICBhc3NldFVybCgnbWVkaWEvcHJvbW8ucG5nJykgKSksICdcIj48L2E+XFxuICA8YSBocmVmPVwiJywgZXNjYXBlKCg5LCAgcm9vdCApKSwgJ1wiPicsIGVzY2FwZSgoOSwgIG1zZy53YXRjaFZpZGVvKCkgKSksICc8L2E+XFxuICA8YSBocmVmPVwiJywgZXNjYXBlKCgxMCwgIHJvb3QgKSksICdcIj4nLCBlc2NhcGUoKDEwLCAgbXNnLnRyeUhPQygpICkpLCAnPC9hPlxcbiAgPGEgaHJlZj1cIicsIGVzY2FwZSgoMTEsICBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0IFxuKSksICdcIj4nLCBlc2NhcGUoKDExLCAgbXNnLnNpZ251cCgpICkpLCAnPC9hPlxcblxcbjwvZGl2PlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdj48c3Bhbj5JbnN0cnVjdGlvbnM6IDwvc3Bhbj48dGV4dGFyZWEgdHlwZT1cInRleHRcIiBuYW1lPVwiaW5zdHJ1Y3Rpb25zXCI+PC90ZXh0YXJlYT48L2Rpdj5cXG48ZGl2PjxzcGFuPkxldmVsIE5hbWU6IDwvc3Bhbj48dGV4dGFyZWEgdHlwZT1cInRleHRcIiBuYW1lPVwibGV2ZWxfbmFtZVwiPjwvdGV4dGFyZWE+PC9kaXY+XFxuPGJ1dHRvbiBpZD1cImNyZWF0ZS1sZXZlbC1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiPlxcbiAgQ3JlYXRlIExldmVsXFxuPC9idXR0b24+XFxuPGRpdiBpZD1cImJ1aWxkZXItZXJyb3JcIj48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCIvKiBnbG9iYWwgJCAqL1xuXG5cbi8qKlxuICogU2ltcGxlIGJvb3Qtc3RyYXBwZWQgc3R5bGUgYWxlcnQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBib2R5OiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudFxuICAgIF0pLmlzUmVxdWlyZWQsXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHN0eWxlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB6SW5kZXg6IDEwMDBcbiAgICB9LCB0aGlzLnByb3BzLnN0eWxlKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtcImFsZXJ0IGZhZGUgaW4gXCIgKyAodGhpcy5wcm9wcy5jbGFzc05hbWUgfHwgJycpfT5cbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWxlcnQtYnV0dG9uIGNsb3NlXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IG1hcmdpbjogMCB9fT5cbiAgICAgICAgICAgIDxzcGFuIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbG9zZX0+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5ib2R5fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0pO1xuIiwiLyogZ2xvYmFscyAkLCBkYXNoYm9hcmQgKi9cblxudmFyIFNlbmRUb1Bob25lID0gd2luZG93LmRhc2hib2FyZCA/IHdpbmRvdy5kYXNoYm9hcmQuU2VuZFRvUGhvbmUgOiB1bmRlZmluZWQ7XG5cbnZhciBzdHlsZXMgPSB7XG4gIG1haW46IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBib3R0b206IDEwLFxuICAgIHJpZ2h0OiAxMCxcbiAgICB0ZXh0QWxpZ246ICdyaWdodCcsXG4gICAgdGV4dFNoYWRvdzogJyMwMDAgLTFweCAtMXB4IDAnLFxuICAgIGZvbnQ6ICcxMnB0IFwiR290aGFtIDVyXCIsIHNhbnMtc2VyaWYnLFxuICAgIGNvbG9yOiAnIzhGOTQ5OSdcbiAgfSxcbiAgaWNvbjoge1xuICAgIGZvbnRTaXplOiAnMS41ZW0nXG4gIH0sXG4gIHNlbmRUb1Bob25lOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIGZvbnQ6ICcxMnB0IFwiR290aGFtIDVyXCIsIHNhbnMtc2VyaWYnLFxuICAgICAgY29sb3I6ICcjOEY5NDk5J1xuICAgIH0sXG4gICAgZGl2OiB7XG4gICAgICBtYXJnaW46IDBcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaG93cyBhIHByb21wdCBmb3IgU2VuZFRvUGhvbmUuIE9uIGNsaWNrLCByZXBsYWNlcyBwcm9tcHQgd2l0aCBvdXJcbiAqIFNlbmRUb1Bob25lIGNvbXBvbmVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIGNoYW5uZWxJZDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFwcFR5cGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGlja2VkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtjbGlja2VkOiAhdGhpcy5zdGF0ZS5jbGlja2VkfSk7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBzbyB0aGUgIyBsaW5rIGRvZXNuJ3QgZ28gYW55d2hlcmUuXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5tYWlufT5cbiAgICAgICAge3RoaXMucmVuZGVyU2VuZFRvUGhvbmUoKX1cbiAgICAgICAgPGEgY2xhc3NOYW1lPVwiV2lyZWZyYW1lU2VuZFRvUGhvbmVfc2VuZC10by1waG9uZS1saW5rXCIgaHJlZj1cIiNcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAgICAgICAgICA8aSBzdHlsZT17c3R5bGVzLmljb259IGNsYXNzTmFtZT1cImZhIGZhLW1vYmlsZVwiLz4gU2VlIHRoaXMgYXBwIG9uIHlvdXIgcGhvbmVcbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfSxcblxuICByZW5kZXJTZW5kVG9QaG9uZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY2xpY2tlZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFNlbmRUb1Bob25lXG4gICAgICAgICAgc3R5bGVzPXtzdHlsZXMuc2VuZFRvUGhvbmV9XG4gICAgICAgICAgY2hhbm5lbElkPXt0aGlzLnByb3BzLmNoYW5uZWxJZH1cbiAgICAgICAgICBhcHBUeXBlPXt0aGlzLnByb3BzLmFwcFR5cGV9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvKiBnbG9iYWwgZGFzaGJvYXJkICovXG52YXIgVmVyc2lvblJvdyA9IHJlcXVpcmUoJy4vVmVyc2lvblJvdy5qc3gnKTtcbnZhciBzb3VyY2VzQXBpID0gcmVxdWlyZSgnLi4vY2xpZW50QXBpJykuc291cmNlcztcblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3Igdmlld2luZyBwcm9qZWN0IHZlcnNpb24gaGlzdG9yeS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHByb3BUeXBlczoge1xuICAgIGhhbmRsZUNsZWFyUHV6emxlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt7c3RhdHVzTWVzc2FnZTogc3RyaW5nLCB2ZXJzaW9uczogKG51bGx8e1xuICAgKiAgIGxhc3RNb2RpZmllZDogRGF0ZSxcbiAgICogICBpc0xhdGVzdDogYm9vbGVhbixcbiAgICogICB2ZXJzaW9uSWQ6IHN0cmluZ1xuICAgKiB9W10pfX1cbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogbnVsbCxcbiAgICAgIHN0YXR1c01lc3NhZ2U6ICcnLFxuICAgICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgICBjb25maXJtaW5nQ2xlYXJQdXp6bGU6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBVc2UgRGF2ZSdzIGNsaWVudCBhcGkgd2hlbiBpdCdzIGZpbmlzaGVkLlxuICAgIHNvdXJjZXNBcGkuYWpheCgnR0VUJywgJ21haW4uanNvbi92ZXJzaW9ucycsIHRoaXMub25WZXJzaW9uTGlzdFJlY2VpdmVkLCB0aGlzLm9uQWpheEZhaWx1cmUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMsIHdoZW4gdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIHRoZVxuICAgKiBjdXJyZW50IGxpc3Qgb2YgdmVyc2lvbnMuXG4gICAqIEBwYXJhbSB4aHJcbiAgICovXG4gIG9uVmVyc2lvbkxpc3RSZWNlaXZlZDogZnVuY3Rpb24gKHhocikge1xuICAgIHRoaXMuc2V0U3RhdGUoe3ZlcnNpb25zOiBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpLCBzaG93U3Bpbm5lcjogZmFsc2V9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCBhbiBlcnJvciB3aGVuIGxvYWRpbmcgYW4gQVBJIHJlcXVlc3QuXG4gICAqL1xuICBvbkFqYXhGYWlsdXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7c3RhdHVzTWVzc2FnZTogJ0FuIGVycm9yIG9jY3VycmVkLid9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHNlcnZlciByZXNwb25kcyB0byBhIHJlcXVlc3QgdG8gcmVzdG9yZSBhIHByZXZpb3VzIHZlcnNpb24uXG4gICAqL1xuICBvblJlc3RvcmVTdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIGNob29zZXMgYSBwcmV2aW91cyB2ZXJzaW9uIHRvIHJlc3RvcmUuXG4gICAqIEBwYXJhbSB2ZXJzaW9uSWRcbiAgICovXG4gIG9uQ2hvb3NlVmVyc2lvbjogZnVuY3Rpb24gKHZlcnNpb25JZCkge1xuICAgIC8vIFRPRE86IFVzZSBEYXZlJ3MgY2xpZW50IGFwaSB3aGVuIGl0J3MgZmluaXNoZWQuXG4gICAgc291cmNlc0FwaS5hamF4KCdQVVQnLCAnbWFpbi5qc29uL3Jlc3RvcmU/dmVyc2lvbj0nICsgdmVyc2lvbklkLCB0aGlzLm9uUmVzdG9yZVN1Y2Nlc3MsIHRoaXMub25BamF4RmFpbHVyZSk7XG5cbiAgICAvLyBTaG93IHRoZSBzcGlubmVyLlxuICAgIHRoaXMuc2V0U3RhdGUoe3Nob3dTcGlubmVyOiB0cnVlfSk7XG4gIH0sXG5cbiAgb25Db25maXJtQ2xlYXJQdXp6bGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtjb25maXJtaW5nQ2xlYXJQdXp6bGU6IHRydWV9KTtcbiAgfSxcblxuICBvbkNhbmNlbENsZWFyUHV6emxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7Y29uZmlybWluZ0NsZWFyUHV6emxlOiBmYWxzZX0pO1xuICB9LFxuXG4gIG9uQ2xlYXJQdXp6bGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtzaG93U3Bpbm5lcjogdHJ1ZX0pO1xuICAgIHRoaXMucHJvcHMuaGFuZGxlQ2xlYXJQdXp6bGUoKTtcbiAgICBkYXNoYm9hcmQucHJvamVjdC5zYXZlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0sIHRydWUpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5O1xuICAgIGlmICh0aGlzLnN0YXRlLnNob3dTcGlubmVyKSB7XG4gICAgICBib2R5ID0gKFxuICAgICAgICAgIDxkaXYgc3R5bGU9e3ttYXJnaW46ICcxZW0gMCcsIHRleHRBbGlnbjogJ2NlbnRlcid9fT5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLXNwaW5uZXIgZmEtc3BpblwiIHN0eWxlPXt7Zm9udFNpemU6ICczMnB4J319PjwvaT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmNvbmZpcm1pbmdDbGVhclB1enpsZSkge1xuICAgICAgYm9keSA9IChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8cD5BcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2xlYXIgYWxsIHByb2dyZXNzIGZvciB0aGlzIGxldmVsJiM2Mzs8L3A+XG4gICAgICAgICAgPGJ1dHRvbiBpZD1cImNvbmZpcm0tYnV0dG9uXCIgc3R5bGU9e3tmbG9hdDogJ3JpZ2h0J319IG9uQ2xpY2s9e3RoaXMub25DbGVhclB1enpsZX0+U3RhcnQgT3ZlcjwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gaWQ9XCJhZ2Fpbi1idXR0b25cIiBvbkNsaWNrPXt0aGlzLm9uQ2FuY2VsQ2xlYXJQdXp6bGV9PkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByb3dzID0gdGhpcy5zdGF0ZS52ZXJzaW9ucy5tYXAoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDxWZXJzaW9uUm93XG4gICAgICAgICAgbGFzdE1vZGlmaWVkPXtuZXcgRGF0ZSh2ZXJzaW9uLmxhc3RNb2RpZmllZCl9XG4gICAgICAgICAgaXNMYXRlc3Q9e3ZlcnNpb24uaXNMYXRlc3R9XG4gICAgICAgICAgb25DaG9vc2U9e3RoaXMub25DaG9vc2VWZXJzaW9uLmJpbmQodGhpcywgdmVyc2lvbi52ZXJzaW9uSWQpfSAvPjtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIGJvZHkgPSAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGRpdiBzdHlsZT17e21heEhlaWdodDogJzMzMHB4Jywgb3ZlcmZsb3dYOiAnc2Nyb2xsJywgbWFyZ2luOiAnMWVtIDAnfX0+XG4gICAgICAgICAgICA8dGFibGUgc3R5bGU9e3t3aWR0aDogJzEwMCUnfX0+XG4gICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICB7cm93c31cbiAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPXt7bWFyZ2luOiAwfX0+SW5pdGlhbCB2ZXJzaW9uPC9wPlxuICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgIDx0ZCB3aWR0aD1cIjI1MFwiIHN0eWxlPXt7dGV4dEFsaWduOiAncmlnaHQnfX0+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0bi1kYW5nZXJcIiBvbkNsaWNrPXt0aGlzLm9uQ29uZmlybUNsZWFyUHV6emxlfSBzdHlsZT17e2Zsb2F0OiAncmlnaHQnfX0+XG4gICAgICAgICAgICAgICAgICAgIERlbGV0ZSBQcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtY29udGVudFwiIHN0eWxlPXt7bWFyZ2luOiAwfX0+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cImRpYWxvZy10aXRsZVwiPlZlcnNpb24gSGlzdG9yeTwvcD5cbiAgICAgICAge2JvZHl9XG4gICAgICAgIHt0aGlzLnN0YXRlLnN0YXR1c01lc3NhZ2V9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbiIsIi8qIGdsb2JhbHMgJCAqL1xuXG5cbi8qKlxuICogQSBzaW5nbGUgcm93IGluIHRoZSBWZXJzaW9uSGlzdG9yeSBkaWFsb2csIGRlc2NyaWJpbmcgb25lIHZlcnNpb24gb2YgYSBwcm9qZWN0LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcHJvcFR5cGVzOiB7XG4gICAgbGFzdE1vZGlmaWVkOiBSZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKSxcbiAgICBpc0xhdGVzdDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaG9vc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0TGFzdE1vZGlmaWVkVGltZXN0YW1wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRoaXMucHJvcHMubGFzdE1vZGlmaWVkO1xuICAgIGlmICh0aW1lc3RhbXAudG9Mb2NhbGVTdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXAudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcC50b1N0cmluZygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBidXR0b247XG4gICAgaWYgKHRoaXMucHJvcHMuaXNMYXRlc3QpIHtcbiAgICAgIGJ1dHRvbiA9IDxidXR0b24gY2xhc3NOYW1lPVwiYnRuLWRlZmF1bHRcIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgc3R5bGU9e3tjdXJzb3I6IFwiZGVmYXVsdFwifX0+Q3VycmVudCBWZXJzaW9uPC9idXR0b24+O1xuICAgIH0gZWxzZSB7XG4gICAgICBidXR0b24gPSA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0bi1pbmZvXCIgb25DbGljaz17dGhpcy5wcm9wcy5vbkNob29zZX0+XG4gICAgICAgIFJlc3RvcmUgdGhpcyBWZXJzaW9uXG4gICAgICA8L2J1dHRvbj47XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciBjbGFzc05hbWU9XCJ2ZXJzaW9uUm93XCI+XG4gICAgICAgIDx0ZD5cbiAgICAgICAgICA8cD5TYXZlZCA8dGltZSBjbGFzc05hbWU9XCJ2ZXJzaW9uVGltZXN0YW1wXCIgZGF0ZVRpbWU9e3RoaXMucHJvcHMubGFzdE1vZGlmaWVkLnRvSVNPU3RyaW5nKCl9Pnt0aGlzLmdldExhc3RNb2RpZmllZFRpbWVzdGFtcCgpfTwvdGltZT48L3A+XG4gICAgICAgICAge3RoaXMuZ2V0TGFzdE1vZGlmaWVkVGltZXN0YW1wKCl9XG4gICAgICAgIDwvdGQ+XG4gICAgICAgIDx0ZCB3aWR0aD1cIjI1MFwiIHN0eWxlPXt7dGV4dEFsaWduOiAncmlnaHQnfX0+XG4gICAgICAgICAge2J1dHRvbn1cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgICQoJy52ZXJzaW9uVGltZXN0YW1wJykudGltZWFnbygpO1xuICB9XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIHByb3BUeXBlczoge1xuICAgIHB1enpsZVRpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGluc3RydWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpbnN0cnVjdGlvbnMyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHJlbmRlcmVkTWFya2Rvd246IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbWFya2Rvd25DbGFzc2ljTWFyZ2luczogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYW5pR2lmVVJMOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGF1dGhvcmVkSGludHM6IFJlYWN0LlByb3BUeXBlcy5lbGVtZW50XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBCb2R5IGxvZ2ljIGlzIGFzIGZvbGxvd3M6XG4gICAgLy9cbiAgICAvLyBJZiB3ZSBoYXZlIGJlZW4gZ2l2ZW4gcmVuZGVyZWQgbWFya2Rvd24sIHJlbmRlciBhIGRpdiBjb250YWluaW5nXG4gICAgLy8gdGhhdCwgb3B0aW9uYWxseSB3aXRoIGlubGluZS1zdHlsZWQgbWFyZ2lucy4gV2UgZG9uJ3QgbmVlZCB0b1xuICAgIC8vIHdvcnJ5IGFib3V0IHRoZSB0aXRsZSBpbiB0aGlzIGNhc2UsIGFzIGl0IGlzIHJlbmRlcmVkIGJ5IHRoZVxuICAgIC8vIERpYWxvZyBoZWFkZXJcbiAgICAvL1xuICAgIC8vIE90aGVyd2lzZSwgcmVuZGVyIHRoZSB0aXRsZSBhbmQgdXAgdG8gdHdvIHNldHMgb2YgaW5zdHJ1Y3Rpb25zLlxuICAgIC8vIFRoZXNlIGluc3RydWN0aW9ucyBtYXkgY29udGFpbiBzcGFucyBhbmQgaW1hZ2VzIGFzIGRldGVybWluZWQgYnlcbiAgICAvLyBTdHVkaW9BcHAuc3Vic3RpdHV0ZUluc3RydWN0aW9uSW1hZ2VzXG4gICAgdmFyIGJvZHk7XG4gICAgaWYgKHRoaXMucHJvcHMucmVuZGVyZWRNYXJrZG93bikge1xuICAgICAgLy8gT3B0aW9uYWxseSBnaXZlIG1hcmtkb3duIGRpYWxvZyB3aWRlIGxlZnQgbWFyZ2luIHNvIGl0IGxvb2tzIG1vcmUgbGlrZSBhXG4gICAgICAvLyBub24tbWFya2Rvd24gaW5zdHJ1Y3Rpb25zIGRpYWxvZyAodXNlZnVsIGlmIG1peGluZyBtYXJrZG93biBpbnN0cnVjdGlvbnNcbiAgICAgIC8vIHdpdGggbm9uLW1hcmtkb3duIGluc3RydWN0aW9ucyBpbiBvbmUgdHV0b3JpYWwpLlxuICAgICAgdmFyIGJvZHlTdHlsZSA9ICh0aGlzLnByb3BzLm1hcmtkb3duQ2xhc3NpY01hcmdpbnMpID8ge1xuICAgICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgICBtYXJnaW5MZWZ0OiAnOTBweCdcbiAgICAgIH0gOiB7fTtcblxuICAgICAgYm9keSA9ICg8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9J2luc3RydWN0aW9ucy1tYXJrZG93bidcbiAgICAgICAgc3R5bGU9eyBib2R5U3R5bGUgfVxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHRoaXMucHJvcHMucmVuZGVyZWRNYXJrZG93biB9fVxuICAgICAgLz4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gWzxwIGNsYXNzTmFtZT0nZGlhbG9nLXRpdGxlJz57IHRoaXMucHJvcHMucHV6emxlVGl0bGUgfTwvcD5dO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgYm9keS5wdXNoKDxwIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogdGhpcy5wcm9wcy5pbnN0cnVjdGlvbnMgfX0vPik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluc3RydWN0aW9uczIpIHtcbiAgICAgICAgYm9keS5wdXNoKDxwIGNsYXNzTmFtZT0naW5zdHJ1Y3Rpb25zMicgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB0aGlzLnByb3BzLmluc3RydWN0aW9uczIgfX0vPik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFuaUdpZjtcbiAgICBpZiAodGhpcy5wcm9wcy5hbmlHaWZVUkwpIHtcbiAgICAgIGFuaUdpZiA9IDxpbWcgY2xhc3NOYW1lPVwiYW5pR2lmIGV4YW1wbGUtaW1hZ2VcIiBzcmM9eyB0aGlzLnByb3BzLmFuaUdpZlVSTCB9Lz47XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHtib2R5fVxuICAgICAgICB7YW5pR2lmfVxuICAgICAgICB7dGhpcy5wcm9wcy5hdXRob3JlZEhpbnRzfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSk7XG4iLCJ2YXIgUGFnZUFjdGlvbiA9IHtcbiAgRHJvcGxldFRyYW5zaXRpb25FcnJvcjogJ0Ryb3BsZXRUcmFuc2l0aW9uRXJyb3InLFxuICBTYW5pdGl6ZWRMZXZlbEh0bWw6ICdTYW5pdGl6ZWRMZXZlbEh0bWwnLFxuICBVc2VySmF2YVNjcmlwdEVycm9yOiAnVXNlckphdmFTY3JpcHRFcnJvcidcbn07XG5cbnZhciBNQVhfRklFTERfTEVOR1RIID0gNDA5NTtcblxuLyoqXG4gKiBTaGltcyB3aW5kb3cubmV3cmVsaWMsIHdoaWNoIGlzIG9ubHkgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi4gVGhpcyBjYXVzZXMgdXNcbiAqIHRvIG5vLW9wIGluIG90aGVyIGVudmlyb25tZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBhZ2VBY3Rpb246IFBhZ2VBY3Rpb24sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25OYW1lIC0gTXVzdCBiZSBvbmUgb2YgdGhlIGtleXMgZnJvbSBQYWdlQWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIE9iamVjdCBsaXRlcmFsIHJlcHJlc2VudGluZyBjb2x1bW5zIHdlIHdhbnQgdG9cbiAgICogICBhZGQgZm9yIHRoaXMgYWN0aW9uXG4gICAqL1xuICBhZGRQYWdlQWN0aW9uOiBmdW5jdGlvbiAoYWN0aW9uTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIXdpbmRvdy5uZXdyZWxpYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUGFnZUFjdGlvblthY3Rpb25OYW1lXSkge1xuICAgICAgY29uc29sZS5sb2coJ1Vua25vd24gYWN0aW9uTmFtZTogJyArIGFjdGlvbk5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zb2xlLmxvZygnRXhwZWN0ZWQgdmFsdWUgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWVbcHJvcF0gPSB2YWx1ZVtwcm9wXS5zdWJzdHJpbmcoMCwgTUFYX0ZJRUxEX0xFTkdUSCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93Lm5ld3JlbGljLmFkZFBhZ2VBY3Rpb24oYWN0aW9uTmFtZSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgb24gYW55IHN1YnNlcXVlbnQgZ2VuZXJhdGVkIGV2ZW50c1xuICAgKi9cbiAgc2V0Q3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghd2luZG93Lm5ld3JlbGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93Lm5ld3JlbGljLnNldEN1c3RvbUF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufTtcbiIsIi8qIGdsb2JhbCB0cmFja0V2ZW50LCBhcHBPcHRpb25zICovXG5cbi8vIE5PVEU6IFRoZXNlIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggYWN0aXZpdHlfaGludC5yYiBpbiBkYXNoYm9hcmQuXG52YXIgSElOVF9SRVFVRVNUX1BMQUNFTUVOVCA9IHtcbiAgTk9ORTogMCwgIC8vIFRoaXMgdmFsdWUgbXVzdCBub3QgYmUgY2hhbmdlZC5cbiAgTEVGVDogMSwgIC8vIEhpbnQgcmVxdWVzdCBidXR0b24gaXMgb24gbGVmdC5cbiAgUklHSFQ6IDIgIC8vIEhpbnQgcmVxdWVzdCBidXR0b24gaXMgb24gcmlnaHQuXG59O1xuXG4vKipcbiAqIEJhZyBvZiB1dGlsaXR5IGZ1bmN0aW9ucyByZWxhdGVkIHRvIGJ1aWxkaW5nIGFuZCBkaXNwbGF5aW5nIGZlZWRiYWNrXG4gKiB0byBzdHVkZW50cy5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtTdHVkaW9BcHB9IHN0dWRpb0FwcCBBIHN0dWRpb0FwcCBpbnN0YW5jZSB1c2VkIHRvIHB1bGxcbiAqICAgY29uZmlndXJhdGlvbiBhbmQgcGVyZm9ybSBvcGVyYXRpb25zLlxuICovXG52YXIgRmVlZGJhY2tVdGlscyA9IGZ1bmN0aW9uIChzdHVkaW9BcHApIHtcbiAgdGhpcy5zdHVkaW9BcHBfID0gc3R1ZGlvQXBwO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRmVlZGJhY2tVdGlscztcblxuLy8gR2xvYmFscyB1c2VkIGluIHRoaXMgZmlsZTpcbi8vICAgQmxvY2tseVxuXG52YXIgdHJvcGh5ID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvdHJvcGh5Lmh0bWwuZWpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgXyA9IHV0aWxzLmdldExvZGFzaCgpO1xudmFyIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbnZhciBtc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgeG1sID0gcmVxdWlyZSgnLi94bWwnKTtcbnZhciBGZWVkYmFja0Jsb2NrcyA9IHJlcXVpcmUoJy4vZmVlZGJhY2tCbG9ja3MnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIFRlc3RSZXN1bHRzID0gY29uc3RhbnRzLlRlc3RSZXN1bHRzO1xudmFyIEtleUNvZGVzID0gY29uc3RhbnRzLktleUNvZGVzO1xudmFyIHB1enpsZVJhdGluZ1V0aWxzID0gcmVxdWlyZSgnLi9wdXp6bGVSYXRpbmdVdGlscycpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlc3RhYmxlQmxvY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZXN0IC0gQSB0ZXN0IHdoZXRoZXIgdGhlIGJsb2NrIGlzXG4gKiAgICAgICAgICAgcHJlc2VudCwgZWl0aGVyOlxuICogICAgICAgICAgIC0gQSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgdGhlIHN0cmluZyBpcyBzZWFyY2hlZCBmb3IgaW5cbiAqICAgICAgICAgICAgIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAqICAgICAgICAgICAtIEEgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHVzZXItYWRkZWRcbiAqICAgICAgICAgICAgIGJsb2NrIGluZGl2aWR1YWxseS4gIElmIGFueSBjYWxsIHJldHVybnMgdHJ1ZSwgdGhlIGJsb2NrXG4gKiAgICAgICAgICAgICBpcyBkZWVtZWQgcHJlc2VudC4gIFwiVXNlci1hZGRlZFwiIGJsb2NrcyBhcmUgb25lcyB0aGF0IGFyZVxuICogICAgICAgICAgICAgbmVpdGhlciBkaXNhYmxlZCBvciB1bmRlbGV0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYmxvY2sgdG8gYmUgcHJvZHVjZWQgZm9yXG4gKiAgICAgICAgICAgZGlzcGxheSB0byB0aGUgdXNlciBpZiB0aGUgdGVzdCBmYWlsZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3RpdGxlc10gLSBBIGRpY3Rpb25hcnksIHdoZXJlLCBmb3IgZWFjaFxuICogICAgICAgICAgIEtFWS1WQUxVRSBwYWlyLCB0aGlzIGlzIGFkZGVkIHRvIHRoZSBibG9jayBkZWZpbml0aW9uOlxuICogICAgICAgICAgIDx0aXRsZSBuYW1lPVwiS0VZXCI+VkFMVUU8L3RpdGxlPi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdmFsdWVdIC0gQSBkaWN0aW9uYXJ5LCB3aGVyZSwgZm9yIGVhY2hcbiAqICAgICAgICAgICBLRVktVkFMVUUgcGFpciwgdGhpcyBpcyBhZGRlZCB0byB0aGUgYmxvY2sgZGVmaW5pdGlvbjpcbiAqICAgICAgICAgICA8dmFsdWUgbmFtZT1cIktFWVwiPlZBTFVFPC92YWx1ZT5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXh0cmFdIC0gQSBzdHJpbmcgdGhhdCBzaG91bGQgYmUgYmxhY2tlZFxuICogICAgICAgICAgIGJldHdlZW4gdGhlIFwiYmxvY2tcIiBzdGFydCBhbmQgZW5kIHRhZ3MuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHshVGVzdGFibGVCbG9ja1tdfSByZXF1aXJlZEJsb2NrcyBUaGUgYmxvY2tzIHRoYXQgYXJlIHJlcXVpcmVkIHRvIGJlIHVzZWQgaW5cbiAqICAgdGhlIHNvbHV0aW9uIHRvIHRoaXMgbGV2ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmVxdWlyZWRCbG9ja3NUb0ZsYWcgVGhlIG51bWJlciBvZiByZXF1aXJlZCBibG9ja3MgdG9cbiAqICAgZ2l2ZSBoaW50cyBhYm91dCBhdCBhbnkgb25lIHRpbWUuICBTZXQgdGhpcyB0byBJbmZpbml0eSB0byBzaG93IGFsbC5cbiAqIEBwYXJhbSB7IVRlc3RhYmxlQmxvY2tbXX0gcmVjb21tZW5kZWRCbG9ja3MgVGhlIGJsb2NrcyB0aGF0IGFyZSByZWNvbW1lbmRlZCB0byBiZSB1c2VkIGluXG4gKiAgIHRoZSBzb2x1dGlvbiB0byB0aGlzIGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlY29tbWVuZGVkQmxvY2tzVG9GbGFnIFRoZSBudW1iZXIgb2YgcmVjb21tZW5kZWQgYmxvY2tzIHRvXG4gKiAgIGdpdmUgaGludHMgYWJvdXQgYXQgYW55IG9uZSB0aW1lLiAgU2V0IHRoaXMgdG8gSW5maW5pdHkgdG8gc2hvdyBhbGwuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmRpc3BsYXlGZWVkYmFjayA9IGZ1bmN0aW9uKG9wdGlvbnMsIHJlcXVpcmVkQmxvY2tzLFxuICAgIG1heFJlcXVpcmVkQmxvY2tzVG9GbGFnLCByZWNvbW1lbmRlZEJsb2NrcywgbWF4UmVjb21tZW5kZWRCbG9ja3NUb0ZsYWcpIHtcblxuICBvcHRpb25zLmxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCB7fTtcbiAgb3B0aW9ucy5udW1Ucm9waGllcyA9IHRoaXMubnVtVHJvcGhpZXNFYXJuZWRfKG9wdGlvbnMpO1xuXG4gIC8vIFRyYWNraW5nIGV2ZW50IGZvciBsZXZlbCBuZXdseSBjb21wbGV0ZWRcbiAgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5uZXdfbGV2ZWxfY29tcGxldGVkKSB7XG4gICAgdHJhY2tFdmVudCgnUHV6emxlJywgJ0NvbXBsZXRlZCcsIG9wdGlvbnMucmVzcG9uc2UubGV2ZWxfcGF0aCwgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9hdHRlbXB0cyk7XG4gIH1cblxuICB2YXIgaGFkU2hhcmVGYWlsdXJlID0gKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5zaGFyZV9mYWlsdXJlKTtcbiAgLy8gb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2UgaXMgdGhlIHVybCB0aGF0IHdlIGFyZSBzaGFyaW5nOyBjYW4ndFxuICAvLyBzaGFyZSB3aXRob3V0IGl0XG4gIHZhciBjYW5TaGFyZSA9IG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2U7XG4gIHZhciBzaG93aW5nU2hhcmluZyA9IG9wdGlvbnMuc2hvd2luZ1NoYXJpbmcgJiYgIWhhZFNoYXJlRmFpbHVyZSAmJiBjYW5TaGFyZTtcblxuICB2YXIgY2FuQ29udGludWUgPSB0aGlzLmNhbkNvbnRpbnVlVG9OZXh0TGV2ZWwob3B0aW9ucy5mZWVkYmFja1R5cGUpO1xuICB2YXIgZGlzcGxheVNob3dDb2RlID0gdGhpcy5zdHVkaW9BcHBfLmVuYWJsZVNob3dDb2RlICYmIHRoaXMuc3R1ZGlvQXBwXy5lbmFibGVTaG93TGluZXNDb3VudCAmJiBjYW5Db250aW51ZSAmJiAhc2hvd2luZ1NoYXJpbmc7XG4gIHZhciBmZWVkYmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgc2hhcmluZ0RpdiA9IChjYW5Db250aW51ZSAmJiBzaG93aW5nU2hhcmluZykgPyB0aGlzLmNyZWF0ZVNoYXJpbmdEaXYob3B0aW9ucykgOiBudWxsO1xuICB2YXIgc2hvd0NvZGUgPSBkaXNwbGF5U2hvd0NvZGUgPyB0aGlzLmdldFNob3dDb2RlRWxlbWVudF8ob3B0aW9ucykgOiBudWxsO1xuICB2YXIgc2hhcmVGYWlsdXJlRGl2ID0gaGFkU2hhcmVGYWlsdXJlID8gdGhpcy5nZXRTaGFyZUZhaWx1cmVfKG9wdGlvbnMpIDogbnVsbDtcbiAgaWYgKGhhZFNoYXJlRmFpbHVyZSkge1xuICAgIHRyYWNrRXZlbnQoJ1NoYXJlJywgJ0ZhaWx1cmUnLCBvcHRpb25zLnJlc3BvbnNlLnNoYXJlX2ZhaWx1cmUudHlwZSk7XG4gIH1cbiAgdmFyIGZlZWRiYWNrQmxvY2tzO1xuICBpZiAodGhpcy5zdHVkaW9BcHBfLmlzVXNpbmdCbG9ja2x5KCkpIHtcbiAgICBmZWVkYmFja0Jsb2NrcyA9IG5ldyBGZWVkYmFja0Jsb2NrcyhcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGhpcy5nZXRNaXNzaW5nQmxvY2tzXyhyZXF1aXJlZEJsb2NrcywgbWF4UmVxdWlyZWRCbG9ja3NUb0ZsYWcpLFxuICAgICAgICB0aGlzLmdldE1pc3NpbmdCbG9ja3NfKHJlY29tbWVuZGVkQmxvY2tzLCBtYXhSZWNvbW1lbmRlZEJsb2Nrc1RvRmxhZyksXG4gICAgICAgIHRoaXMuc3R1ZGlvQXBwXyk7XG4gIH1cbiAgLy8gZmVlZGJhY2tNZXNzYWdlIG11c3QgYmUgaW5pdGlhbGl6ZWQgYWZ0ZXIgZmVlZGJhY2tCbG9ja3NcbiAgLy8gYmVjYXVzZSBGZWVkYmFja0Jsb2NrcyBjYW4gbXV0YXRlIG9wdGlvbnMucmVzcG9uc2UuaGludC5cbiAgdmFyIGZlZWRiYWNrTWVzc2FnZSA9IHRoaXMuZ2V0RmVlZGJhY2tNZXNzYWdlXyhvcHRpb25zKTtcblxuICBpZiAoZmVlZGJhY2tNZXNzYWdlKSB7XG4gICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQoZmVlZGJhY2tNZXNzYWdlKTtcbiAgfVxuICBpZiAob3B0aW9ucy5udW1Ucm9waGllcykge1xuICAgIC8vIFRyYWNraW5nIGV2ZW50IGZvciBuZXcgdHJvcGh5IGVhcm5lZFxuICAgIGlmIChvcHRpb25zLm51bVRyb3BoaWVzID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm51bVRyb3BoaWVzOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbmNlcHRfbmFtZSA9IG9wdGlvbnMucmVzcG9uc2UudHJvcGh5X3VwZGF0ZXNbaV1bMF07XG4gICAgICAgIHZhciB0cm9waHlfbmFtZSA9IG9wdGlvbnMucmVzcG9uc2UudHJvcGh5X3VwZGF0ZXNbaV1bMV07XG4gICAgICAgIHRyYWNrRXZlbnQoJ1Ryb3BoeScsIGNvbmNlcHRfbmFtZSwgdHJvcGh5X25hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHJvcGhpZXMgPSB0aGlzLmdldFRyb3BoaWVzRWxlbWVudF8ob3B0aW9ucyk7XG4gICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQodHJvcGhpZXMpO1xuICB9XG4gIGlmIChmZWVkYmFja0Jsb2NrcyAmJiBmZWVkYmFja0Jsb2Nrcy5kaXYpIHtcbiAgICBpZiAoZmVlZGJhY2tNZXNzYWdlICYmIHRoaXMudXNlU3BlY2lhbEZlZWRiYWNrRGVzaWduXyhvcHRpb25zKSkge1xuICAgICAgLy8gcHV0IHRoZSBibG9ja3MgaWZyYW1lIGluc2lkZSB0aGUgZmVlZGJhY2tNZXNzYWdlIGZvciB0aGlzIHNwZWNpYWwgY2FzZTpcbiAgICAgIGZlZWRiYWNrTWVzc2FnZS5hcHBlbmRDaGlsZChmZWVkYmFja0Jsb2Nrcy5kaXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChmZWVkYmFja0Jsb2Nrcy5kaXYpO1xuICAgIH1cbiAgfVxuICBpZiAoc2hhcmluZ0Rpdikge1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKHNoYXJpbmdEaXYpO1xuICB9XG4gIGlmIChzaG93aW5nU2hhcmluZykge1xuICAgIHZhciBzaGFyZUNvZGVTcGFjZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzaGFyZUNvZGVTcGFjZXIuY2xhc3NOYW1lID0gXCJzaGFyZS1jb2RlLXNwYWNlclwiO1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKHNoYXJlQ29kZVNwYWNlcik7XG4gIH1cbiAgaWYgKHNoYXJlRmFpbHVyZURpdikge1xuICAgIGZlZWRiYWNrLmFwcGVuZENoaWxkKHNoYXJlRmFpbHVyZURpdik7XG4gIH1cbiAgaWYgKHNob3dDb2RlKSB7XG4gICAgZmVlZGJhY2suYXBwZW5kQ2hpbGQoc2hvd0NvZGUpO1xuICB9XG4gIGlmIChvcHRpb25zLmxldmVsLmlzSzEpIHtcbiAgICBmZWVkYmFjay5jbGFzc05hbWUgKz0gXCIgazFcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5hcHBEaXYpIHtcbiAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChvcHRpb25zLmFwcERpdik7XG4gIH1cblxuICBmZWVkYmFjay5jbGFzc05hbWUgKz0gY2FuQ29udGludWUgPyBcIiB3aW4tZmVlZGJhY2tcIiA6IFwiIGZhaWx1cmUtZmVlZGJhY2tcIjtcblxuICB2YXIgZmluYWxMZXZlbCA9IChvcHRpb25zLnJlc3BvbnNlICYmXG4gICAgKG9wdGlvbnMucmVzcG9uc2UubWVzc2FnZSA9PT0gXCJubyBtb3JlIGxldmVsc1wiKSk7XG5cbiAgZmVlZGJhY2suYXBwZW5kQ2hpbGQoXG4gICAgdGhpcy5nZXRGZWVkYmFja0J1dHRvbnNfKHtcbiAgICAgIGZlZWRiYWNrVHlwZTogb3B0aW9ucy5mZWVkYmFja1R5cGUsXG4gICAgICB0cnlBZ2FpblRleHQ6IG9wdGlvbnMudHJ5QWdhaW5UZXh0LFxuICAgICAga2VlcFBsYXlpbmdUZXh0OiBvcHRpb25zLmtlZXBQbGF5aW5nVGV4dCxcbiAgICAgIGNvbnRpbnVlVGV4dDogb3B0aW9ucy5jb250aW51ZVRleHQsXG4gICAgICBzaG93UHJldmlvdXNCdXR0b246IG9wdGlvbnMubGV2ZWwuc2hvd1ByZXZpb3VzTGV2ZWxCdXR0b24sXG4gICAgICBpc0sxOiBvcHRpb25zLmxldmVsLmlzSzEsXG4gICAgICBmcmVlUGxheTogb3B0aW9ucy5sZXZlbC5mcmVlUGxheSxcbiAgICAgIGZpbmFsTGV2ZWw6IGZpbmFsTGV2ZWxcbiAgICB9KVxuICApO1xuXG4gIHZhciBhZ2FpbkJ1dHRvbiA9IGZlZWRiYWNrLnF1ZXJ5U2VsZWN0b3IoJyNhZ2Fpbi1idXR0b24nKTtcbiAgdmFyIGhpbnRSZXF1ZXN0QnV0dG9uID0gZmVlZGJhY2sucXVlcnlTZWxlY3RvcignI2hpbnQtcmVxdWVzdC1idXR0b24nKTtcbiAgdmFyIHByZXZpb3VzTGV2ZWxCdXR0b24gPSBmZWVkYmFjay5xdWVyeVNlbGVjdG9yKCcjYmFjay1idXR0b24nKTtcbiAgdmFyIGNvbnRpbnVlQnV0dG9uID0gZmVlZGJhY2sucXVlcnlTZWxlY3RvcignI2NvbnRpbnVlLWJ1dHRvbicpO1xuXG4gIHZhciBvbmx5Q29udGludWUgPSBjb250aW51ZUJ1dHRvbiAmJiAhYWdhaW5CdXR0b24gJiYgIXByZXZpb3VzTGV2ZWxCdXR0b247XG5cbiAgLy8gZ2V0IHRoZSB0b3Btb3N0IG1pc3NpbmcgcmVjb21tZW5kZWQgYmxvY2ssIGlmIGl0IGV4aXN0cywgdG8gYmVcbiAgLy8gYWRkZWQgdG8gdGhlIHF1ZXVlIG9mIGNvbnRleHR1YWwgaGludHMuIElmIHRoZSB1c2VyIHZpZXdzIHRoZSBibG9ja1xuICAvLyBpbiB0aGUgZGlhbG9nLCBtYXJrIGl0IGFzIHNlZW4gYW5kIGFkZCBpdCB0byB0aGUgbGlzdCBhcyBzdWNoLlxuICB2YXIgbWlzc2luZ1JlY29tbWVuZGVkQmxvY2tIaW50cyA9IHRoaXMuZ2V0TWlzc2luZ0Jsb2Nrc18ocmVjb21tZW5kZWRCbG9ja3MsIDEpXG4gICAgLmJsb2Nrc1RvRGlzcGxheVxuICAgIC5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICBibG9jay5hbHJlYWR5U2VlbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH0pO1xuICB2YXIgbWFya0NvbnRleHR1YWxIaW50c0FzU2VlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBtaXNzaW5nUmVjb21tZW5kZWRCbG9ja0hpbnRzLmZpbHRlcihmdW5jdGlvbiAoaGludCkge1xuICAgICAgcmV0dXJuIGZlZWRiYWNrQmxvY2tzICYmIGZlZWRiYWNrQmxvY2tzLnhtbCAmJiBmZWVkYmFja0Jsb2Nrcy54bWwuaW5kZXhPZihoaW50LmJsb2NrRGlzcGxheVhNTCkgPiAtMTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICBoaW50LmFscmVhZHlTZWVuID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb25IaWRkZW4gPSBvbmx5Q29udGludWUgPyBvcHRpb25zLm9uQ29udGludWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdHVkaW9BcHBfLmRpc3BsYXlNaXNzaW5nQmxvY2tIaW50cyhtaXNzaW5nUmVjb21tZW5kZWRCbG9ja0hpbnRzKTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHZhciBpY29uO1xuICBpZiAoIW9wdGlvbnMuaGlkZUljb24pIHtcbiAgICBpY29uID0gY2FuQ29udGludWUgPyB0aGlzLnN0dWRpb0FwcF8ud2luSWNvbiA6IHRoaXMuc3R1ZGlvQXBwXy5mYWlsdXJlSWNvbjtcbiAgfVxuICB2YXIgZGVmYXVsdEJ0blNlbGVjdG9yID0gb25seUNvbnRpbnVlID8gJyNjb250aW51ZS1idXR0b24nIDogJyNhZ2Fpbi1idXR0b24nO1xuXG4gIHZhciBmZWVkYmFja0RpYWxvZyA9IHRoaXMuY3JlYXRlTW9kYWxEaWFsb2coe1xuICAgIERpYWxvZzogb3B0aW9ucy5EaWFsb2csXG4gICAgY29udGVudERpdjogZmVlZGJhY2ssXG4gICAgaWNvbjogaWNvbixcbiAgICBkZWZhdWx0QnRuU2VsZWN0b3I6IGRlZmF1bHRCdG5TZWxlY3RvcixcbiAgICBvbkhpZGRlbjogb25IaWRkZW4sXG4gICAgaWQ6ICdmZWVkYmFjay1kaWFsb2cnXG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiBpdCBpcyBzZXQgdG8gYmUgaW4gc3BlY2lhbCBkZXNpZ24uXG4gIGlmICh0aGlzLnVzZVNwZWNpYWxGZWVkYmFja0Rlc2lnbl8ob3B0aW9ucykpIHtcbiAgICBpZiAob3B0aW9ucy5yZXNwb25zZS5kZXNpZ24gPT0gXCJ3aGl0ZV9iYWNrZ3JvdW5kXCIpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmZWVkYmFjay1kaWFsb2cnKVxuICAgICAgICAgIC5jbGFzc05hbWUgKz0gXCIgd2hpdGUtYmFja2dyb3VuZFwiO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZlZWRiYWNrLWNvbnRlbnQnKVxuICAgICAgICAgIC5jbGFzc05hbWUgKz0gXCIgbGlnaHQteWVsbG93LWJhY2tncm91bmRcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoYWdhaW5CdXR0b24pIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGFnYWluQnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGZlZWRiYWNrRGlhbG9nLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcmV2aW91c0xldmVsQnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChwcmV2aW91c0xldmVsQnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGZlZWRiYWNrRGlhbG9nLmhpZGUoKTtcbiAgICAgIG9wdGlvbnMuYmFja1RvUHJldmlvdXNMZXZlbCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYSBoaW50IHJlcXVlc3QgYnV0dG9uLCBoaWRlIHRoZSBoaW50IHRoYXQgd291bGQgb3JkaW5hcmlseVxuICAvLyBiZSBzaG93biAoaW5jbHVkaW5nIGFueSBmZWVkYmFjayBibG9ja3MpLCBhbmQgYWRkIGNvZGUgdG8gcmVzdG9yZSB0aGVcbiAgLy8gaGludCBpZiB0aGUgYnV0dG9uIGdldHMgcHJlc3NlZC5cbiAgaWYgKGhpbnRSZXF1ZXN0QnV0dG9uKSB7XG5cbiAgICB2YXIgYWxyZWFkeVNlZW4gPSBvcHRpb25zLnJlc3BvbnNlICYmXG4gICAgICAgIG9wdGlvbnMucmVzcG9uc2UuaGludF92aWV3X3JlcXVlc3RzICYmXG4gICAgICAgIG9wdGlvbnMucmVzcG9uc2UuaGludF92aWV3X3JlcXVlc3RzLnNvbWUoZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdE1hdGNoZXNGZWVkYmFjayA9IHJlcXVlc3QuZmVlZGJhY2tfdHlwZSA9PT0gb3B0aW9ucy5mZWVkYmFja1R5cGU7XG4gICAgICAgICAgaWYgKGZlZWRiYWNrQmxvY2tzICYmIGZlZWRiYWNrQmxvY2tzLnhtbCkge1xuICAgICAgICAgICAgcmVxdWVzdE1hdGNoZXNGZWVkYmFjayA9IHJlcXVlc3RNYXRjaGVzRmVlZGJhY2sgJiYgcmVxdWVzdC5mZWVkYmFja194bWwgPT09IGZlZWRiYWNrQmxvY2tzLnhtbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3RNYXRjaGVzRmVlZGJhY2s7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKGFscmVhZHlTZWVuKSB7XG4gICAgICAvLyBSZW1vdmUgXCJTaG93IGhpbnRcIiBidXR0b24uICBNYWtpbmcgaXQgaW52aXNpYmxlIGlzbid0IGVub3VnaCxcbiAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBzdGlsbCB0YWtlIHVwIHNwYWNlLlxuICAgICAgaGludFJlcXVlc3RCdXR0b24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaW50UmVxdWVzdEJ1dHRvbik7XG5cbiAgICAgIC8vIG1hcmsgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2sgaGludCBhcyBzZWVuXG4gICAgICBtYXJrQ29udGV4dHVhbEhpbnRzQXNTZWVuKCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gR2VuZXJhdGUgYSBnZW5lcmljIGZlZWRiYWNrIG1lc3NhZ2UgdG8gZGlzcGxheSB3aGVuIHdlIHNob3cgdGhlXG4gICAgICAvLyBmZWVkYmFjayBibG9ja1xuICAgICAgdmFyIGdlbmVyaWNGZWVkYmFjayA9IHRoaXMuZ2V0RmVlZGJhY2tNZXNzYWdlXyh7bWVzc2FnZTogbXNnLnRyeUJsb2Nrc0JlbG93RmVlZGJhY2soKX0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgZmVlZGJhY2sgYmxvY2tzLCB0ZW1wb3JhcmlseSBoaWRlIHRoZW0uXG4gICAgICBpZiAoZmVlZGJhY2tCbG9ja3MgJiYgZmVlZGJhY2tCbG9ja3MuZGl2KSB7XG4gICAgICAgIGZlZWRiYWNrQmxvY2tzLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHVzZXIgcmVxdWVzdHMgdGhlIGhpbnQuLi5cbiAgICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoaGludFJlcXVlc3RCdXR0b24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbWFyayB0aGUgY29ycmVzcG9uZGluZyBibG9jayBoaW50IGFzIHNlZW5cbiAgICAgICAgbWFya0NvbnRleHR1YWxIaW50c0FzU2VlbigpO1xuXG4gICAgICAgIC8vIFN3YXAgb3V0IHRoZSBzcGVjaWZpYyBmZWVkYmFjayBtZXNzYWdlIHdpdGggYSBnZW5lcmljIG9uZS5cbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBmZWVkYmFja01lc3NhZ2UucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZ2VuZXJpY0ZlZWRiYWNrLCBmZWVkYmFja01lc3NhZ2UpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBcIlNob3cgaGludFwiIGJ1dHRvbi4gIE1ha2luZyBpdCBpbnZpc2libGUgaXNuJ3QgZW5vdWdoLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgc3RpbGwgdGFrZSB1cCBzcGFjZS5cbiAgICAgICAgaGludFJlcXVlc3RCdXR0b24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaW50UmVxdWVzdEJ1dHRvbik7XG5cbiAgICAgICAgLy8gUmVzdG9yZSBmZWVkYmFjayBibG9ja3MsIGlmIHByZXNlbnQuXG4gICAgICAgIGlmIChmZWVkYmFja0Jsb2NrcyAmJiBmZWVkYmFja0Jsb2Nrcy5kaXYpIHtcbiAgICAgICAgICBmZWVkYmFja0Jsb2Nrcy5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBvcnQgaGludCByZXF1ZXN0IHRvIHNlcnZlci5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UuaGludF92aWV3X3JlcXVlc3RfdXJsKSB7XG4gICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy5yZXNwb25zZS5oaW50X3ZpZXdfcmVxdWVzdF91cmwsXG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNjcmlwdF9pZDogb3B0aW9ucy5yZXNwb25zZS5zY3JpcHRfaWQsXG4gICAgICAgICAgICAgIGxldmVsX2lkOiBvcHRpb25zLnJlc3BvbnNlLmxldmVsX2lkLFxuICAgICAgICAgICAgICBmZWVkYmFja190eXBlOiBvcHRpb25zLmZlZWRiYWNrVHlwZSxcbiAgICAgICAgICAgICAgZmVlZGJhY2tfeG1sOiBmZWVkYmFja0Jsb2NrcyA/IGZlZWRiYWNrQmxvY2tzLnhtbCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmIChjb250aW51ZUJ1dHRvbikge1xuXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5wdXp6bGVfcmF0aW5nc19lbmFibGVkKSB7XG4gICAgICBmZWVkYmFjay5hcHBlbmRDaGlsZChwdXp6bGVSYXRpbmdVdGlscy5idWlsZFB1enpsZVJhdGluZ0J1dHRvbnMoKSk7XG4gICAgfVxuXG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChjb250aW51ZUJ1dHRvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgZmVlZGJhY2tEaWFsb2cuaGlkZSgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLnB1enpsZV9yYXRpbmdzX2VuYWJsZWQpIHtcbiAgICAgICAgcHV6emxlUmF0aW5nVXRpbHMuY2FjaGVQdXp6bGVSYXRpbmcoZmVlZGJhY2ssIHtcbiAgICAgICAgICBzY3JpcHRfaWQ6IG9wdGlvbnMucmVzcG9uc2Uuc2NyaXB0X2lkLFxuICAgICAgICAgIGxldmVsX2lkOiBvcHRpb25zLnJlc3BvbnNlLmxldmVsX2lkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvbkNvbnRpbnVlIHdpbGwgZmlyZSBhbHJlYWR5IGlmIHRoZXJlIHdhcyBvbmx5IGEgY29udGludWUgYnV0dG9uXG4gICAgICBpZiAoIW9ubHlDb250aW51ZSkge1xuICAgICAgICBvcHRpb25zLm9uQ29udGludWUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0aGUgU2F2ZSBUbyBHYWxsZXJ5IGJ1dHRvbiBpZiBuZWNlc3NhcnlcbiAgdmFyIHNhdmVUb0dhbGxlcnlCdXR0b24gPSBmZWVkYmFjay5xdWVyeVNlbGVjdG9yKCcjc2F2ZS10by1nYWxsZXJ5LWJ1dHRvbicpO1xuICBpZiAoc2F2ZVRvR2FsbGVyeUJ1dHRvbiAmJiBvcHRpb25zLnJlc3BvbnNlICYmIG9wdGlvbnMucmVzcG9uc2Uuc2F2ZV90b19nYWxsZXJ5X3VybCkge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2F2ZVRvR2FsbGVyeUJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAkLnBvc3Qob3B0aW9ucy5yZXNwb25zZS5zYXZlX3RvX2dhbGxlcnlfdXJsLFxuICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyAkKCcjc2F2ZS10by1nYWxsZXJ5LWJ1dHRvbicpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkudGV4dChcIlNhdmVkIVwiKTsgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIaWRkZW5QcmludFdpbmRvdyhzcmMpIHtcbiAgICB2YXIgaWZyYW1lID0gJCgnPGlmcmFtZSBpZD1cInByaW50X2ZyYW1lXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+PC9pZnJhbWU+Jyk7IC8vIENyZWF0ZWQgYSBoaWRkZW4gaWZyYW1lIHdpdGgganVzdCB0aGUgZGVzaXJlZCBpbWFnZSBhcyBpdHMgY29udGVudHNcbiAgICBpZnJhbWUuYXBwZW5kVG8oXCJib2R5XCIpO1xuICAgIGlmcmFtZVswXS5jb250ZW50V2luZG93LmRvY3VtZW50LndyaXRlKFwiPGltZyBzcmM9J1wiICsgc3JjICsgXCInLz5cIik7XG4gICAgaWZyYW1lWzBdLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoXCI8c2NyaXB0PmlmIChkb2N1bWVudC5leGVjQ29tbWFuZCgncHJpbnQnLCBmYWxzZSwgbnVsbCkpIHsgIH0gZWxzZSB7IHdpbmRvdy5wcmludCgpOyAgfSA8L3NjcmlwdD5cIik7XG4gICAgJChcIiNwcmludF9mcmFtZVwiKS5yZW1vdmUoKTsgLy8gUmVtb3ZlIHRoZSBpZnJhbWUgd2hlbiB0aGUgcHJpbnQgZGlhbG9ndWUgaGFzIGJlZW4gbGF1bmNoZWRcbiAgfVxuXG4gIHZhciBwcmludEJ1dHRvbiA9IGZlZWRiYWNrLnF1ZXJ5U2VsZWN0b3IoJyNwcmludC1idXR0b24nKTtcbiAgaWYgKHByaW50QnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChwcmludEJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBjcmVhdGVIaWRkZW5QcmludFdpbmRvdyhvcHRpb25zLmZlZWRiYWNrSW1hZ2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZmVlZGJhY2tEaWFsb2cuc2hvdyh7XG4gICAgYmFja2Ryb3A6IChvcHRpb25zLmFwcCA9PT0gJ2ZsYXBweScgPyAnc3RhdGljJyA6IHRydWUpXG4gIH0pO1xuXG4gIGlmIChmZWVkYmFja0Jsb2NrcyAmJiBmZWVkYmFja0Jsb2Nrcy5kaXYpIHtcbiAgICBmZWVkYmFja0Jsb2Nrcy5yZW5kZXIoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb3VudHMgdGhlIG51bWJlciBvZiBibG9ja3MgdXNlZC4gIEJsb2NrcyBhcmUgb25seSBjb3VudGVkIGlmIHRoZXkgYXJlXG4gKiBub3QgZGlzYWJsZWQsIGFyZSBkZWxldGFibGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBibG9ja3MgdXNlZC5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0TnVtQmxvY2tzVXNlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaTtcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5lZGl0Q29kZSkge1xuICAgIHZhciBjb2RlTGluZXMgPSAwO1xuICAgIC8vIHF1aWNrIGFuZCBkaXJ0eSBtZXRob2QgdG8gY291bnQgbm9uLWJsYW5rIGxpbmVzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCAvL1xuICAgIHZhciBsaW5lcyA9IHRoaXMuZ2V0R2VuZXJhdGVkQ29kZVN0cmluZ18oKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgobGluZXNbaV0ubGVuZ3RoID4gMSkgJiYgKGxpbmVzW2ldWzBdICE9ICcvJyB8fCBsaW5lc1tpXVsxXSAhPSAnLycpKSB7XG4gICAgICAgIGNvZGVMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZUxpbmVzO1xuICB9XG4gIHJldHVybiB0aGlzLmdldFVzZXJCbG9ja3NfKCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb3VudHMgdGhlIHRvdGFsIG51bWJlciBvZiBibG9ja3MuIEJsb2NrcyBhcmUgb25seSBjb3VudGVkIGlmIHRoZXkgYXJlXG4gKiBub3QgZGlzYWJsZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRvdGFsIG51bWJlciBvZiBibG9ja3MuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldE51bUNvdW50YWJsZUJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaTtcbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5lZGl0Q29kZSkge1xuICAgIHZhciBjb2RlTGluZXMgPSAwO1xuICAgIC8vIHF1aWNrIGFuZCBkaXJ0eSBtZXRob2QgdG8gY291bnQgbm9uLWJsYW5rIGxpbmVzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCAvL1xuICAgIHZhciBsaW5lcyA9IHRoaXMuZ2V0R2VuZXJhdGVkQ29kZVN0cmluZ18oKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgobGluZXNbaV0ubGVuZ3RoID4gMSkgJiYgKGxpbmVzW2ldWzBdICE9ICcvJyB8fCBsaW5lc1tpXVsxXSAhPSAnLycpKSB7XG4gICAgICAgIGNvZGVMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZUxpbmVzO1xuICB9XG4gIHJldHVybiB0aGlzLmdldENvdW50YWJsZUJsb2Nrc18oKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldEZlZWRiYWNrQnV0dG9uc18gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbnMuaWQgPSAnZmVlZGJhY2tCdXR0b25zJztcblxuICB2YXIgdHJ5QWdhaW5UZXh0ID0gJyc7XG4gIGlmIChvcHRpb25zLmZlZWRiYWNrVHlwZSAhPT0gVGVzdFJlc3VsdHMuQUxMX1BBU1MpIHtcbiAgICB0cnlBZ2FpblRleHQgPSB1dGlscy52YWx1ZU9yKG9wdGlvbnMudHJ5QWdhaW5UZXh0LCBtc2cudHJ5QWdhaW4oKSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMua2VlcFBsYXlpbmdUZXh0KSB7XG4gICAgdHJ5QWdhaW5UZXh0ID0gb3B0aW9ucy5rZWVwUGxheWluZ1RleHQ7XG4gIH1cblxuICBidXR0b25zLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2J1dHRvbnMuaHRtbC5lanMnKSh7XG4gICAgZGF0YToge1xuICAgICAgcHJldmlvdXNMZXZlbDpcbiAgICAgICAgIXRoaXMuY2FuQ29udGludWVUb05leHRMZXZlbChvcHRpb25zLmZlZWRiYWNrVHlwZSkgJiZcbiAgICAgICAgb3B0aW9ucy5zaG93UHJldmlvdXNCdXR0b24sXG4gICAgICB0cnlBZ2FpbjogdHJ5QWdhaW5UZXh0LFxuICAgICAgY29udGludWVUZXh0OiBvcHRpb25zLmNvbnRpbnVlVGV4dCB8fCAob3B0aW9ucy5maW5hbExldmVsID8gbXNnLmZpbmlzaCgpIDogbXNnLmNvbnRpbnVlKCkpLFxuICAgICAgbmV4dExldmVsOiB0aGlzLmNhbkNvbnRpbnVlVG9OZXh0TGV2ZWwob3B0aW9ucy5mZWVkYmFja1R5cGUpLFxuICAgICAgc2hvdWxkUHJvbXB0Rm9ySGludDogdGhpcy5zaG91bGRQcm9tcHRGb3JIaW50KG9wdGlvbnMuZmVlZGJhY2tUeXBlKSxcbiAgICAgIGlzSzE6IG9wdGlvbnMuaXNLMSxcbiAgICAgIGFzc2V0VXJsOiB0aGlzLnN0dWRpb0FwcF8uYXNzZXRVcmwsXG4gICAgICBmcmVlUGxheTogb3B0aW9ucy5mcmVlUGxheVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJ1dHRvbnM7XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldFNoYXJlRmFpbHVyZV8gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBzaGFyZUZhaWx1cmUgPSBvcHRpb25zLnJlc3BvbnNlLnNoYXJlX2ZhaWx1cmU7XG4gIHZhciBzaGFyZUZhaWx1cmVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2hhcmVGYWlsdXJlRGl2LmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3NoYXJlRmFpbHVyZS5odG1sLmVqcycpKHtzaGFyZUZhaWx1cmU6IHNoYXJlRmFpbHVyZX0pO1xuICByZXR1cm4gc2hhcmVGYWlsdXJlRGl2O1xufTtcblxuLyoqXG4gKlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS51c2VTcGVjaWFsRmVlZGJhY2tEZXNpZ25fID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiByZXR1cm4gb3B0aW9ucy5yZXNwb25zZSAmJlxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlLmRlc2lnbiAmJlxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlLmhpbnQ7XG59O1xuXG4vLyBUaGlzIHJldHVybnMgYSBkb2N1bWVudCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGZlZWRiYWNrIG1lc3NhZ2UuXG4vLyBUaGUgbWVzc2FnZSB3aWxsIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nLCBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHByZWNlZGVuY2U6XG4vLyAwLiBGYWlsdXJlIG92ZXJyaWRlIG1lc3NhZ2Ugc3BlY2lmaWVkIG9uIGxldmVsIChvcHRpb25zLmxldmVsLmZhaWx1cmVNZXNzYWdlT3ZlcnJpZGUpXG4vLyAxLiBNZXNzYWdlIHBhc3NlZCBpbiBieSBjYWxsZXIgKG9wdGlvbnMubWVzc2FnZSkuXG4vLyAyLiBNZXNzYWdlIGZyb20gZGFzaGJvYXJkIGRhdGFiYXNlIChvcHRpb25zLnJlc3BvbnNlLmhpbnQpLlxuLy8gMy4gSGVhZGVyIG1lc3NhZ2UgZHVlIHRvIGRhc2hib2FyZCB0ZXh0IGNoZWNrIGZhaWwgKG9wdGlvbnMucmVzcG9uc2Uuc2hhcmVfZmFpbHVyZSkuXG4vLyA0LiBMZXZlbC1zcGVjaWZpYyBtZXNzYWdlIChlLmcuLCBvcHRpb25zLmxldmVsLmVtcHR5QmxvY2tzRXJyb3JNc2cpIGZvclxuLy8gICAgc3BlY2lmaWMgcmVzdWx0IHR5cGUgKGUuZy4sIFRlc3RSZXN1bHRzLkVNUFRZX0JMT0NLX0ZBSUwpLlxuLy8gNS4gU3lzdGVtLXdpZGUgbWVzc2FnZSAoZS5nLiwgbXNnLmVtcHR5QmxvY2tzRXJyb3JNc2coKSkgZm9yIHNwZWNpZmljXG4vLyAgICByZXN1bHQgdHlwZSAoZS5nLiwgVGVzdFJlc3VsdHMuRU1QVFlfQkxPQ0tfRkFJTCkuXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRGZWVkYmFja01lc3NhZ2VfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgZmVlZGJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gIGZlZWRiYWNrLmNsYXNzTmFtZSA9ICdjb25ncmF0cyc7XG4gIHZhciBtZXNzYWdlO1xuXG4gIC8vIElmIGEgbWVzc2FnZSB3YXMgZXhwbGljaXRseSBwYXNzZWQgaW4sIHVzZSB0aGF0LlxuICBpZiAob3B0aW9ucy5mZWVkYmFja1R5cGUgIT09IFRlc3RSZXN1bHRzLkFMTF9QQVNTICYmXG4gICAgICBvcHRpb25zLmxldmVsICYmIG9wdGlvbnMubGV2ZWwuZmFpbHVyZU1lc3NhZ2VPdmVycmlkZSkge1xuICAgIG1lc3NhZ2UgPSBvcHRpb25zLmxldmVsLmZhaWx1cmVNZXNzYWdlT3ZlcnJpZGU7XG4gIH0gZWxzZSAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLnNoYXJlX2ZhaWx1cmUpIHtcbiAgICBtZXNzYWdlID0gbXNnLnNoYXJlRmFpbHVyZSgpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5oaW50KSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSdzIGEgZGFzaGJvYXJkIGRhdGFiYXNlIGhpbnQsIHVzZSB0aGF0LlxuICAgIG1lc3NhZ2UgPSBvcHRpb25zLnJlc3BvbnNlLmhpbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB0aGUgbWVzc2FnZSB3aWxsIGRlcGVuZCBvbiB0aGUgdGVzdCByZXN1bHQuXG4gICAgc3dpdGNoIChvcHRpb25zLmZlZWRiYWNrVHlwZSkge1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5SVU5USU1FX0VSUk9SX0ZBSUw6XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cucnVudGltZUVycm9yTXNnKHsgbGluZU51bWJlcjogb3B0aW9ucy5leGVjdXRpb25FcnJvci5saW5lTnVtYmVyIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuU1lOVEFYX0VSUk9SX0ZBSUw6XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cuc3ludGF4RXJyb3JNc2coeyBsaW5lTnVtYmVyOiBvcHRpb25zLmV4ZWN1dGlvbkVycm9yLmxpbmVOdW1iZXIgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5FTVBUWV9CTE9DS19GQUlMOlxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5lbXB0eUJsb2Nrc0Vycm9yTXNnIHx8XG4gICAgICAgICAgICBtc2cuZW1wdHlCbG9ja3NFcnJvck1zZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuRU1QVFlfRlVOQ1RJT05fQkxPQ0tfRkFJTDpcbiAgICAgICAgaWYgKG9wdGlvbnMubGV2ZWwuZW1wdHlGdW5jdGlvbkJsb2Nrc0Vycm9yTXNnKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwuZW1wdHlGdW5jdGlvbkJsb2Nrc0Vycm9yTXNnO1xuICAgICAgICB9IGVsc2UgaWYgKEJsb2NrbHkudXNlQ29udHJhY3RFZGl0b3IgfHwgQmxvY2tseS51c2VNb2RhbEZ1bmN0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1zZy5lcnJvckVtcHR5RnVuY3Rpb25CbG9ja01vZGFsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1zZy5lbXB0eUZ1bmN0aW9uQmxvY2tzRXJyb3JNc2coKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuVE9PX0ZFV19CTE9DS1NfRkFJTDpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwudG9vRmV3QmxvY2tzTXNnIHx8IG1zZy50b29GZXdCbG9ja3NNc2coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkxFVkVMX0lOQ09NUExFVEVfRkFJTDpcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnMubGV2ZWwubGV2ZWxJbmNvbXBsZXRlRXJyb3IgfHxcbiAgICAgICAgICAgIG1zZy5sZXZlbEluY29tcGxldGVFcnJvcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuRVhUUkFfVE9QX0JMT0NLU19GQUlMOlxuICAgICAgICB2YXIgaGFzV2hlblJ1biA9IEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0VG9wQmxvY2tzKCkuc29tZShmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gYmxvY2sudHlwZSA9PT0gJ3doZW5fcnVuJyAmJiBibG9jay5pc1VzZXJWaXNpYmxlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TWVzc2FnZSA9IGhhc1doZW5SdW4gP1xuICAgICAgICAgIG1zZy5leHRyYVRvcEJsb2Nrc1doZW5SdW4oKSA6IG1zZy5leHRyYVRvcEJsb2NrcygpO1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5leHRyYVRvcEJsb2NrcyB8fCBkZWZhdWx0TWVzc2FnZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkFQUF9TUEVDSUZJQ19GQUlMOlxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5hcHBTcGVjaWZpY0ZhaWxFcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlVOVVNFRF9QQVJBTTpcbiAgICAgICAgbWVzc2FnZSA9IG1zZy5lcnJvclVudXNlZFBhcmFtKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5VTlVTRURfRlVOQ1RJT046XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cuZXJyb3JVbnVzZWRGdW5jdGlvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuUEFSQU1fSU5QVVRfVU5BVFRBQ0hFRDpcbiAgICAgICAgbWVzc2FnZSA9IG1zZy5lcnJvclBhcmFtSW5wdXRVbmF0dGFjaGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5JTkNPTVBMRVRFX0JMT0NLX0lOX0ZVTkNUSU9OOlxuICAgICAgICBtZXNzYWdlID0gbXNnLmVycm9ySW5jb21wbGV0ZUJsb2NrSW5GdW5jdGlvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuUVVFU1RJT05fTUFSS1NfSU5fTlVNQkVSX0ZJRUxEOlxuICAgICAgICBtZXNzYWdlID0gbXNnLmVycm9yUXVlc3Rpb25NYXJrc0luTnVtYmVyRmllbGQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLlRPT19NQU5ZX0JMT0NLU19GQUlMOlxuICAgICAgICAgIC8vIEFsbG93IGFwcHMgdG8gb3ZlcnJpZGUgdGhlIFwidG9vIG1hbnkgYmxvY2tzXCIgZmFpbHVyZSBtZXNzYWdlXG4gICAgICAgICAgLy8gUGFzc2VkIGFzIGEgbXNnIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCBpbi5cbiAgICAgICAgdmFyIG1lc3NhZ2VGdW5jdGlvbiA9IChvcHRpb25zLmFwcFN0cmluZ3MgJiYgb3B0aW9ucy5hcHBTdHJpbmdzLnRvb01hbnlCbG9ja3NGYWlsTXNnRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBtc2cubnVtQmxvY2tzTmVlZGVkO1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZUZ1bmN0aW9uKHtcbiAgICAgICAgICBudW1CbG9ja3M6IHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0sXG4gICAgICAgICAgcHV6emxlTnVtYmVyOiBvcHRpb25zLmxldmVsLnB1enpsZV9udW1iZXIgfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkFQUF9TUEVDSUZJQ19BQ0NFUFRBQkxFX0ZBSUw6XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLmxldmVsLmFwcFNwZWNpZmljQWNjZXB0YWJsZUZhaWxFcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkVESVRfQkxPQ0tTOlxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5lZGl0X2Jsb2Nrc19zdWNjZXNzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19VTkZJTklTSEVEOlxuICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5NSVNTSU5HX0JMT0NLX0ZJTklTSEVEOlxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5sZXZlbC5taXNzaW5nUmVxdWlyZWRCbG9ja3NFcnJvck1zZyB8fFxuICAgICAgICAgICAgbXNnLm1pc3NpbmdSZXF1aXJlZEJsb2Nrc0Vycm9yTXNnKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5NSVNTSU5HX1JFQ09NTUVOREVEX0JMT0NLX1VORklOSVNIRUQ6XG4gICAgICAgIG1lc3NhZ2UgPSBtc2cubWlzc2luZ1JlY29tbWVuZGVkQmxvY2tzRXJyb3JNc2coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQ6XG4gICAgICAgIHZhciBudW1FbmFibGVkQmxvY2tzID0gdGhpcy5nZXROdW1Db3VudGFibGVCbG9ja3MoKTtcbiAgICAgICAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0gJiYgbnVtRW5hYmxlZEJsb2NrcyA+IHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0pIHtcbiAgICAgICAgICBtZXNzYWdlID0gbXNnLm51bUJsb2Nrc05lZWRlZCh7XG4gICAgICAgICAgICBudW1CbG9ja3M6IHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0sXG4gICAgICAgICAgICBwdXp6bGVOdW1iZXI6IG9wdGlvbnMubGV2ZWwucHV6emxlX251bWJlciB8fCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1zZy5jb21wbGV0ZWRXaXRob3V0UmVjb21tZW5kZWRCbG9jayh7XG4gICAgICAgICAgICBwdXp6bGVOdW1iZXI6IG9wdGlvbnMubGV2ZWwucHV6emxlX251bWJlciB8fCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLk5FU1RFRF9GT1JfU0FNRV9WQVJJQUJMRTpcbiAgICAgICAgbWVzc2FnZSA9IG1zZy5uZXN0ZWRGb3JTYW1lVmFyaWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFN1Y2Nlc3MuXG4gICAgICBjYXNlIFRlc3RSZXN1bHRzLkFMTF9QQVNTOlxuICAgICAgY2FzZSBUZXN0UmVzdWx0cy5GUkVFX1BMQVk6XG4gICAgICAgIHZhciBmaW5hbExldmVsID0gKG9wdGlvbnMucmVzcG9uc2UgJiZcbiAgICAgICAgICAob3B0aW9ucy5yZXNwb25zZS5tZXNzYWdlID09PSBcIm5vIG1vcmUgbGV2ZWxzXCIpKTtcbiAgICAgICAgdmFyIHN0YWdlQ29tcGxldGVkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UgJiYgb3B0aW9ucy5yZXNwb25zZS5zdGFnZV9jaGFuZ2luZykge1xuICAgICAgICAgIHN0YWdlQ29tcGxldGVkID0gb3B0aW9ucy5yZXNwb25zZS5zdGFnZV9jaGFuZ2luZy5wcmV2aW91cy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgbnVtVHJvcGhpZXM6IG9wdGlvbnMubnVtVHJvcGhpZXMsXG4gICAgICAgICAgc3RhZ2VOdW1iZXI6IDAsIC8vIFRPRE86IHJlbW92ZSBvbmNlIGxvY2FsaXplZCBzdHJpbmdzIGhhdmUgYmVlbiBmaXhlZFxuICAgICAgICAgIHN0YWdlTmFtZTogc3RhZ2VDb21wbGV0ZWQsXG4gICAgICAgICAgcHV6emxlTnVtYmVyOiBvcHRpb25zLmxldmVsLnB1enpsZV9udW1iZXIgfHwgMFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5mZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLkZSRUVfUExBWSAmJiAhb3B0aW9ucy5sZXZlbC5kaXNhYmxlU2hhcmluZykge1xuICAgICAgICAgIHZhciByZWluZkZlZWRiYWNrTXNnID0gKG9wdGlvbnMuYXBwU3RyaW5ncyAmJlxuICAgICAgICAgICAgICBvcHRpb25zLmFwcFN0cmluZ3MucmVpbmZGZWVkYmFja01zZykgfHwgJyc7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5sZXZlbC5kaXNhYmxlRmluYWxTdGFnZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSByZWluZkZlZWRiYWNrTXNnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmluYWxMZXZlbCA/IChtc2cuZmluYWxTdGFnZShtc2dQYXJhbXMpICsgJyAnKSA6ICcnO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyByZWluZkZlZWRiYWNrTXNnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm51bVRyb3BoaWVzID4gMCkge1xuICAgICAgICAgIG1lc3NhZ2UgPSBmaW5hbExldmVsID8gbXNnLmZpbmFsU3RhZ2VUcm9waGllcyhtc2dQYXJhbXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlQ29tcGxldGVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5uZXh0U3RhZ2VUcm9waGllcyhtc2dQYXJhbXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5uZXh0TGV2ZWxUcm9waGllcyhtc2dQYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWxNc2cgPSAob3B0aW9ucy5hcHBTdHJpbmdzICYmIG9wdGlvbnMuYXBwU3RyaW5ncy5uZXh0TGV2ZWxNc2cpIHx8XG4gICAgICAgICAgICAgIG1zZy5uZXh0TGV2ZWwobXNnUGFyYW1zKTtcbiAgICAgICAgICBtZXNzYWdlID0gZmluYWxMZXZlbCA/IG1zZy5maW5hbFN0YWdlKG1zZ1BhcmFtcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2VDb21wbGV0ZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5uZXh0U3RhZ2UobXNnUGFyYW1zKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExldmVsTXNnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gICQoZmVlZGJhY2spLnRleHQobWVzc2FnZSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBmZWVkYmFjayBib3ggZGVzaWduLCBpZiB0aGUgaGludCBtZXNzYWdlIGNhbWUgZnJvbSBzZXJ2ZXIuXG4gIGlmICh0aGlzLnVzZVNwZWNpYWxGZWVkYmFja0Rlc2lnbl8ob3B0aW9ucykpIHtcbiAgICAvLyBTZXR1cCBhIG5ldyBkaXZcbiAgICB2YXIgZmVlZGJhY2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmZWVkYmFja0Rpdi5jbGFzc05hbWUgPSAnZmVlZGJhY2stY2FsbG91dCc7XG4gICAgZmVlZGJhY2tEaXYuaWQgPSAnZmVlZGJhY2stY29udGVudCc7XG5cbiAgICAvLyBJbnNlcnQgYW4gaW1hZ2VcbiAgICB2YXIgaW1hZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWFnZURpdi5jbGFzc05hbWUgPSBcImhpbnQtaW1hZ2VcIjtcbiAgICBpbWFnZURpdi5zcmMgPSB0aGlzLnN0dWRpb0FwcF8uYXNzZXRVcmwoXG4gICAgICAnbWVkaWEvbGlnaHRidWxiX2Zvcl8nICsgb3B0aW9ucy5yZXNwb25zZS5kZXNpZ24gKyAnLnBuZycpO1xuICAgIGZlZWRiYWNrRGl2LmFwcGVuZENoaWxkKGltYWdlRGl2KTtcbiAgICAvLyBBZGQgbmV3IHRleHRcbiAgICB2YXIgaGludEhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAkKGhpbnRIZWFkZXIpLnRleHQobXNnLmhpbnRIZWFkZXIoKSk7XG4gICAgZmVlZGJhY2tEaXYuYXBwZW5kQ2hpbGQoaGludEhlYWRlcik7XG4gICAgaGludEhlYWRlci5jbGFzc05hbWUgPSAnaGludC1oZWFkZXInO1xuICAgIC8vIEFwcGVuZCB0aGUgb3JpZ2luYWwgdGV4dFxuICAgIGZlZWRiYWNrRGl2LmFwcGVuZENoaWxkKGZlZWRiYWNrKTtcbiAgICByZXR1cm4gZmVlZGJhY2tEaXY7XG4gIH1cbiAgcmV0dXJuIGZlZWRiYWNrO1xufTtcblxuLyoqXG4gKlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5jcmVhdGVTaGFyaW5nRGl2ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBUT0RPOiB0aGlzIGJ5cGFzc2VzIHRoZSBjb25maWcgZW5jYXBzdWxhdGlvbiB0byBlbnN1cmUgd2UgaGF2ZSB0aGUgbW9zdCB1cC10by1kYXRlIHZhbHVlLlxuICBpZiAodGhpcy5zdHVkaW9BcHBfLmRpc2FibGVTb2NpYWxTaGFyZSB8fCB3aW5kb3cuYXBwT3B0aW9ucy5kaXNhYmxlU29jaWFsU2hhcmUpIHtcbiAgICAvLyBDbGVhciBvdXQgb3VyIHVybHMgc28gdGhhdCB3ZSBkb24ndCBkaXNwbGF5IGFueSBvZiBvdXIgc29jaWFsIHNoYXJlIGxpbmtzXG4gICAgb3B0aW9ucy50d2l0dGVyVXJsID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMuZmFjZWJvb2tVcmwgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucy5zZW5kVG9QaG9uZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gc2V0IHVwIHRoZSB0d2l0dGVyIHNoYXJlIHVybFxuICAgIHZhciB0d2l0dGVyVXJsID0gXCJodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD91cmw9XCIgK1xuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZS5sZXZlbF9zb3VyY2U7XG5cbiAgICBpZiAob3B0aW9ucy50d2l0dGVyICYmIG9wdGlvbnMudHdpdHRlci50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHR3aXR0ZXJVcmwgKz0gXCImdGV4dD1cIiArIGVuY29kZVVSSShvcHRpb25zLnR3aXR0ZXIudGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdHdpdHRlclVybCArPSBcIiZ0ZXh0PVwiICsgZW5jb2RlVVJJKG1zZy5kZWZhdWx0VHdpdHRlclRleHQoKSArIFwiIEBjb2Rlb3JnXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnR3aXR0ZXIgICYmIG9wdGlvbnMudHdpdHRlci5oYXNodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHR3aXR0ZXJVcmwgKz0gXCImaGFzaHRhZ3M9XCIgKyBvcHRpb25zLnR3aXR0ZXIuaGFzaHRhZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0d2l0dGVyVXJsICs9IFwiJmhhc2h0YWdzPVwiICsgJ0hvdXJPZkNvZGUnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnR3aXR0ZXIgJiYgb3B0aW9ucy50d2l0dGVyLnJlbGF0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHdpdHRlclVybCArPSBcIiZyZWxhdGVkPVwiICsgb3B0aW9ucy50d2l0dGVyLnJlbGF0ZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdHdpdHRlclVybCArPSBcIiZyZWxhdGVkPWNvZGVvcmdcIjtcbiAgICB9XG5cbiAgICBvcHRpb25zLnR3aXR0ZXJVcmwgPSB0d2l0dGVyVXJsO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBmYWNlYm9vayBzaGFyZSB1cmxcbiAgICB2YXIgZmFjZWJvb2tVcmwgPSBcImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9zaGFyZXIvc2hhcmVyLnBocD91PVwiICtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlc3BvbnNlLmxldmVsX3NvdXJjZTtcbiAgICBvcHRpb25zLmZhY2Vib29rVXJsID0gZmFjZWJvb2tVcmw7XG4gIH1cblxuICBvcHRpb25zLmFzc2V0VXJsID0gdGhpcy5zdHVkaW9BcHBfLmFzc2V0VXJsO1xuXG4gIHZhciBzaGFyaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNoYXJpbmdEaXYuc2V0QXR0cmlidXRlKCdpZCcsICdzaGFyaW5nJyk7XG4gIHNoYXJpbmdEaXYuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvc2hhcmluZy5odG1sLmVqcycpKHtcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH0pO1xuXG4gIC8vIE5vdGU6IFdlIGhhdmUgYSBkZXBlbmRlbmN5IG9uIGRhc2hib2FyZCBoZXJlLiBUaGlzIGRlcGVuZGVuY3kgaGFzIGFsd2F5c1xuICAvLyBiZWVuIGhlcmUgKHdlIHVzZWQgdG8gbXlzdGVyaW91c2x5IGp1c3QgYWx3YXlzIGJ1YmJsZSBjbGlja3Mgb24gYm9keSB0b1xuICAvLyBhLnBvcHVwLXdpbmRvdyBpZiBpdCBleGlzdGVkKSwgYnV0IGl0IGlzIG5vdyBtb3JlIGV4cGxpY2l0XG4gIGlmICh3aW5kb3cuZGFzaGJvYXJkICYmIHdpbmRvdy5kYXNoYm9hcmQucG9wdXBXaW5kb3cpIHtcbiAgICAkKHNoYXJpbmdEaXYpLmZpbmQoJ2EucG9wdXAtd2luZG93JykuY2xpY2sod2luZG93LmRhc2hib2FyZC5wb3B1cFdpbmRvdyk7XG4gIH1cblxuICB2YXIgc2hhcmluZ0lucHV0ID0gc2hhcmluZ0Rpdi5xdWVyeVNlbGVjdG9yKCcjc2hhcmluZy1pbnB1dCcpO1xuICBpZiAoc2hhcmluZ0lucHV0KSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzaGFyaW5nSW5wdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgc2hhcmluZ0lucHV0LmZvY3VzKCk7XG4gICAgICBzaGFyaW5nSW5wdXQuc2VsZWN0KCk7XG4gICAgICBzaGFyaW5nSW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgOTk5OSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyAgU01TLXRvLXBob25lIGZlYXR1cmVcbiAgdmFyIHNoYXJpbmdQaG9uZSA9IHNoYXJpbmdEaXYucXVlcnlTZWxlY3RvcignI3NoYXJpbmctcGhvbmUnKTtcbiAgaWYgKHNoYXJpbmdQaG9uZSAmJiBvcHRpb25zLnNlbmRUb1Bob25lKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChzaGFyaW5nUGhvbmUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbmRUb1Bob25lID0gc2hhcmluZ0Rpdi5xdWVyeVNlbGVjdG9yKCcjc2VuZC10by1waG9uZScpO1xuICAgICAgaWYgKCQoc2VuZFRvUGhvbmUpLmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgJChzZW5kVG9QaG9uZSkuc2hvdygpO1xuICAgICAgICB2YXIgcGhvbmUgPSAkKHNoYXJpbmdEaXYucXVlcnlTZWxlY3RvcihcIiNwaG9uZVwiKSk7XG4gICAgICAgIHZhciBzdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN1Ym1pdEJ1dHRvbiA9IHNoYXJpbmdEaXYucXVlcnlTZWxlY3RvcignI3Bob25lLXN1Ym1pdCcpO1xuICAgICAgICBzdWJtaXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBwaG9uZS5tYXNrKCcoMDAwKSAwMDAtMDAwMCcsIHtcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgaWYgKCFzdWJtaXR0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHN1Ym1pdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBwaG9uZS5mb2N1cygpO1xuICAgICAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHN1Ym1pdEJ1dHRvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBob25lID0gJChzaGFyaW5nRGl2LnF1ZXJ5U2VsZWN0b3IoXCIjcGhvbmVcIikpO1xuICAgICAgICAgIHZhciBwYXJhbXMgPSBqUXVlcnkucGFyYW0oe1xuICAgICAgICAgICAgbGV2ZWxfc291cmNlOiBvcHRpb25zLnJlc3BvbnNlLmxldmVsX3NvdXJjZV9pZCxcbiAgICAgICAgICAgIHBob25lOiBwaG9uZS52YWwoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgICQoc3VibWl0QnV0dG9uKS52YWwoXCJTZW5kaW5nLi5cIik7XG4gICAgICAgICAgcGhvbmUucHJvcCgncmVhZG9ubHknLCB0cnVlKTtcbiAgICAgICAgICBzdWJtaXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHN1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgalF1ZXJ5LnBvc3Qob3B0aW9ucy5yZXNwb25zZS5waG9uZV9zaGFyZV91cmwsIHBhcmFtcylcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAkKHN1Ym1pdEJ1dHRvbikudGV4dChcIlNlbnQhXCIpO1xuICAgICAgICAgICAgICB0cmFja0V2ZW50KFwiU2VuZFRvUGhvbmVcIiwgXCJzdWNjZXNzXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgICAgJChzdWJtaXRCdXR0b24pLnRleHQoXCJFcnJvciFcIik7XG4gICAgICAgICAgICAgIHRyYWNrRXZlbnQoXCJTZW5kVG9QaG9uZVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHsgLy8gbm90IGhpZGRlbiwgaGlkZVxuICAgICAgICAkKHNlbmRUb1Bob25lKS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2hhcmluZ0Rpdjtcbn07XG5cbi8qKlxuICpcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUubnVtVHJvcGhpZXNFYXJuZWRfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMucmVzcG9uc2UudHJvcGh5X3VwZGF0ZXMubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldFRyb3BoaWVzRWxlbWVudF8gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBodG1sID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm51bVRyb3BoaWVzOyBpKyspIHtcbiAgICBodG1sICs9IHRyb3BoeSh7XG4gICAgICBpbWdfdXJsOiBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzW2ldWzJdLFxuICAgICAgY29uY2VwdF9uYW1lOiBvcHRpb25zLnJlc3BvbnNlLnRyb3BoeV91cGRhdGVzW2ldWzBdXG4gICAgfSk7XG4gIH1cbiAgdmFyIHRyb3BoaWVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRyb3BoaWVzLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiB0cm9waGllcztcbn07XG5cbi8qKlxuICpcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0U2hvd0NvZGVFbGVtZW50XyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHNob3dDb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNob3dDb2RlRGl2LnNldEF0dHJpYnV0ZSgnaWQnLCAnc2hvdy1jb2RlJyk7XG5cbiAgdmFyIG51bUxpbmVzV3JpdHRlbiA9IHRoaXMuZ2V0TnVtQmxvY2tzVXNlZCgpO1xuICB2YXIgc2hvdWxkU2hvd1RvdGFsTGluZXMgPVxuICAgIChvcHRpb25zLnJlc3BvbnNlICYmXG4gICAgICBvcHRpb25zLnJlc3BvbnNlLnRvdGFsX2xpbmVzICYmXG4gICAgICAob3B0aW9ucy5yZXNwb25zZS50b3RhbF9saW5lcyAhPT0gbnVtTGluZXNXcml0dGVuKSk7XG4gIHZhciB0b3RhbE51bUxpbmVzV3JpdHRlbiA9IHNob3VsZFNob3dUb3RhbExpbmVzID8gb3B0aW9ucy5yZXNwb25zZS50b3RhbF9saW5lcyA6IDA7XG5cbiAgc2hvd0NvZGVEaXYuaW5uZXJIVE1MID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvc2hvd0NvZGUuaHRtbC5lanMnKSh7XG4gICAgbnVtTGluZXNXcml0dGVuOiBudW1MaW5lc1dyaXR0ZW4sXG4gICAgdG90YWxOdW1MaW5lc1dyaXR0ZW46IHRvdGFsTnVtTGluZXNXcml0dGVuXG4gIH0pO1xuXG4gIHZhciBzaG93Q29kZUJ1dHRvbiA9IHNob3dDb2RlRGl2LnF1ZXJ5U2VsZWN0b3IoJyNzaG93LWNvZGUtYnV0dG9uJyk7XG4gIHNob3dDb2RlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuZXJhdGVkQ29kZUVsZW1lbnQgPSB0aGlzLmdldEdlbmVyYXRlZENvZGVFbGVtZW50Xyh7XG4gICAgICBnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb246IG9wdGlvbnMuYXBwU3RyaW5ncyAmJiBvcHRpb25zLmFwcFN0cmluZ3MuZ2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uXG4gICAgfSk7XG4gICAgc2hvd0NvZGVEaXYuYXBwZW5kQ2hpbGQoZ2VuZXJhdGVkQ29kZUVsZW1lbnQpO1xuICAgIHNob3dDb2RlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0sIHRoaXMpKTtcblxuICByZXR1cm4gc2hvd0NvZGVEaXY7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgdXNlciBjYW4gcHJvY2VlZCB0byB0aGUgbmV4dCBsZXZlbCwgYmFzZWQgb24gdGhlIGxldmVsIGZlZWRiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gZmVlZGJhY2tUeXBlIEEgY29uc3RhbnQgcHJvcGVydHkgb2YgVGVzdFJlc3VsdHMsXG4gKiAgICAgdHlwaWNhbGx5IHByb2R1Y2VkIGJ5IFN0dWRpb0FwcC5nZXRUZXN0UmVzdWx0cygpLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5jYW5Db250aW51ZVRvTmV4dExldmVsID0gZnVuY3Rpb24oZmVlZGJhY2tUeXBlKSB7XG4gIHJldHVybiAoZmVlZGJhY2tUeXBlID09PSBUZXN0UmVzdWx0cy5BTExfUEFTUyB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gVGVzdFJlc3VsdHMuVE9PX01BTllfQkxPQ0tTX0ZBSUwgfHxcbiAgICBmZWVkYmFja1R5cGUgPT09ICBUZXN0UmVzdWx0cy5BUFBfU1BFQ0lGSUNfQUNDRVBUQUJMRV9GQUlMIHx8XG4gICAgZmVlZGJhY2tUeXBlID09PSAgVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19GSU5JU0hFRCB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gIFRlc3RSZXN1bHRzLkZSRUVfUExBWSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgcHJvbXB0IHRoZSB1c2VyIHRvIHNob3cgdGhlIGdpdmVuXG4gKiBmZWVkYmFjaywgcmF0aGVyIHRoYW4gc2hvd2luZyBpdCB0byB0aGVtIGF1dG9tYXRpY2FsbHkuIEN1cnJlbnRseVxuICogb25seSB1c2VkIGZvciBtaXNzaW5nIGJsb2NrIGZlZWRiYWNrOyBtYXkgZXhwYW5kIGluIHRoZSBmdXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWVkYmFja1R5cGUgQSBjb25zdGFudCBwcm9wZXJ0eSBvZiBUZXN0UmVzdWx0cyxcbiAqICAgICB0eXBpY2FsbHkgcHJvZHVjZWQgYnkgU3R1ZGlvQXBwLmdldFRlc3RSZXN1bHRzKCkuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnNob3VsZFByb21wdEZvckhpbnQgPSBmdW5jdGlvbihmZWVkYmFja1R5cGUpIHtcbiAgcmV0dXJuIChmZWVkYmFja1R5cGUgPT09IFRlc3RSZXN1bHRzLk1JU1NJTkdfQkxPQ0tfVU5GSU5JU0hFRCB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19GSU5JU0hFRCB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19GSU5JU0hFRCB8fFxuICAgIGZlZWRiYWNrVHlwZSA9PT0gVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19VTkZJTklTSEVEKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgdXNlcidzIGdlbmVyYXRlZCBKYXZhc2NyaXB0IGNvZGUuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldEdlbmVyYXRlZENvZGVTdHJpbmdfID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN0dWRpb0FwcF8uZWRpdENvZGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdHVkaW9BcHBfLmVkaXRvciA/IHRoaXMuc3R1ZGlvQXBwXy5lZGl0b3IuZ2V0VmFsdWUoKSA6ICcnO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBjb2RlZ2VuLndvcmtzcGFjZUNvZGUoQmxvY2tseSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgXCJzaG93IGNvZGVcIiBkaXYgd2l0aCBhIGRlc2NyaXB0aW9uIG9mIHdoYXQgY29kZSBpcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25hbFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbl0gLSBvcHRpb25hbCBkZXNjcmlwdGlvblxuICogICAgICAgIG9mIGNvZGUgdG8gcHV0IGluIHBsYWNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fVxuICogQHByaXZhdGVcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0R2VuZXJhdGVkQ29kZUVsZW1lbnRfID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY29kZUluZm9Nc2dQYXJhbXMgPSB7XG4gICAgYmVya2VsZXlMaW5rOiBcIjxhIGhyZWY9J2h0dHA6Ly9iamMuYmVya2VsZXkuZWR1LycgdGFyZ2V0PSdfYmxhbmsnPkJlcmtlbGV5PC9hPlwiLFxuICAgIGhhcnZhcmRMaW5rOiBcIjxhIGhyZWY9J2h0dHBzOi8vY3M1MC5oYXJ2YXJkLmVkdS8nIHRhcmdldD0nX2JsYW5rJz5IYXJ2YXJkPC9hPlwiXG4gIH07XG5cbiAgdmFyIGluZm9NZXNzYWdlID0gdGhpcy5nZXRHZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb24oY29kZUluZm9Nc2dQYXJhbXMsXG4gICAgICBvcHRpb25zLmdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbik7XG4gIHZhciBjb2RlID0gdGhpcy5zdHVkaW9BcHBfLnBvbGlzaEdlbmVyYXRlZENvZGVTdHJpbmcodGhpcy5nZXRHZW5lcmF0ZWRDb2RlU3RyaW5nXygpKTtcblxuICB2YXIgY29kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb2RlRGl2LmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2NvZGUuaHRtbC5lanMnKSh7XG4gICAgbWVzc2FnZTogaW5mb01lc3NhZ2UsXG4gICAgY29kZTogY29kZVxuICB9KTtcblxuICByZXR1cm4gY29kZURpdjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGV4cGxhbmF0aW9uIG9mIHdoYXQgY29kZSBpcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2RlSW5mb01zZ1BhcmFtcyAtIHBhcmFtcyBmb3IgZ2VuZXJhdGVkQ29kZUluZm8gbXNnIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2dlbmVyYXRlZENvZGVEZXNjcmlwdGlvbl0gLSBvcHRpb25hbCBkZXNjcmlwdGlvbiB0byB1c2VcbiAqICAgICAgICBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoY29kZUluZm9Nc2dQYXJhbXMsIGdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbikge1xuICBpZiAodGhpcy5zdHVkaW9BcHBfLmVkaXRDb2RlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBnZW5lcmF0ZWRDb2RlRGVzY3JpcHRpb247XG4gIH1cblxuICByZXR1cm4gbXNnLmdlbmVyYXRlZENvZGVJbmZvKGNvZGVJbmZvTXNnUGFyYW1zKTtcbn07XG5cbi8qKlxuICogRGlzcGxheSB0aGUgJ1Nob3cgQ29kZScgbW9kYWwgZGlhbG9nLlxuICogQHBhcmFtIHtEaWFsb2d9IERpYWxvZ1xuICogQHBhcmFtIHtPYmplY3R9IFthcHBTdHJpbmdzXSAtIG9wdGlvbmFsIGFwcCBzdHJpbmdzIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FwcFN0cmluZ3MuZ2VuZXJhdGVkQ29kZURlc2NyaXB0aW9uXSAtIHN0cmluZ1xuICogICAgICAgIHRvIGRpc3BsYXkgaW5zdGVhZCBvZiB0aGUgdXN1YWwgc2hvdyBjb2RlIGRlc2NyaXB0aW9uXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnNob3dHZW5lcmF0ZWRDb2RlID0gZnVuY3Rpb24oRGlhbG9nLCBhcHBTdHJpbmdzKSB7XG4gIHZhciBjb2RlRGl2ID0gdGhpcy5nZXRHZW5lcmF0ZWRDb2RlRWxlbWVudF8oe1xuICAgIGdlbmVyYXRlZENvZGVEZXNjcmlwdGlvbjogYXBwU3RyaW5ncyAmJiBhcHBTdHJpbmdzLmdlbmVyYXRlZENvZGVEZXNjcmlwdGlvblxuICB9KTtcblxuICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidXR0b25zLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2J1dHRvbnMuaHRtbC5lanMnKSh7XG4gICAgZGF0YToge1xuICAgICAgb2s6IHRydWVcbiAgICB9XG4gIH0pO1xuICBjb2RlRGl2LmFwcGVuZENoaWxkKGJ1dHRvbnMpO1xuXG4gIHZhciBkaWFsb2cgPSB0aGlzLmNyZWF0ZU1vZGFsRGlhbG9nKHtcbiAgICAgIERpYWxvZzogRGlhbG9nLFxuICAgICAgY29udGVudERpdjogY29kZURpdixcbiAgICAgIGljb246IHRoaXMuc3R1ZGlvQXBwXy5pY29uLFxuICAgICAgZGVmYXVsdEJ0blNlbGVjdG9yOiAnI29rLWJ1dHRvbidcbiAgICAgIH0pO1xuXG4gIHZhciBva2F5QnV0dG9uID0gYnV0dG9ucy5xdWVyeVNlbGVjdG9yKCcjb2stYnV0dG9uJyk7XG4gIGlmIChva2F5QnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChva2F5QnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBkaWFsb2cuc2hvdygpO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBcIkNsZWFyIFB1enpsZVwiIGNvbmZpcm1hdGlvbiBkaWFsb2cuICBUYWtlcyBhIHBhcmFtZXRlciB0byBoaWRlXG4gKiB0aGUgaWNvbi4gIENhbGxzIGBjYWxsYmFja2AgaWYgdGhlIHVzZXIgY29uZmlybXMgdGhleSB3YW50IHRvIGNsZWFyIHRoZSBwdXp6bGUuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnNob3dDbGVhclB1enpsZUNvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uKERpYWxvZywgaGlkZUljb24sIGNhbGxiYWNrKSB7XG4gIHRoaXMuc2hvd1NpbXBsZURpYWxvZyhEaWFsb2csIHtcbiAgICBoZWFkZXJUZXh0OiBtc2cuY2xlYXJQdXp6bGVDb25maXJtSGVhZGVyKCksXG4gICAgYm9keVRleHQ6IG1zZy5jbGVhclB1enpsZUNvbmZpcm0oKSxcbiAgICBjb25maXJtVGV4dDogbXNnLmNsZWFyUHV6emxlKCksXG4gICAgY2FuY2VsVGV4dDogbXNnLmRpYWxvZ0NhbmNlbCgpLFxuICAgIG9uQ29uZmlybTogY2FsbGJhY2ssXG4gICAgb25DYW5jZWw6IG51bGwsXG4gICAgaGlkZUljb246IGhpZGVJY29uXG4gIH0pO1xufTtcblxuLyoqXG4gKiBTaG93cyBhIHNpbXBsZSBkaWFsb2cgdGhhdCBoYXMgYSBoZWFkZXIsIGJvZHksIGNvbnRpbnVlIGJ1dHRvbiwgYW5kIGNhbmNlbFxuICogYnV0dG9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBDb25maWd1cmFibGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJUZXh0IFRleHQgZm9yIGhlYWRlciBwb3J0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9keVRleHQgVGV4dCBmb3IgYm9keSBwb3J0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FuY2VsVGV4dCBUZXh0IGZvciBjYW5jZWwgYnV0dG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlybVRleHQgVGV4dCBmb3IgY29uZmlybSBidXR0b25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZUljb24gV2hldGhlciB0byBoaWRlIHRoZSBpY29uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb25Db25maXJtXSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY2xpY2tpbmcgY29uZmlybVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29uQ2FuY2VsXSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY2xpY2tpbmcgY2FuY2VsXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnNob3dTaW1wbGVEaWFsb2cgPSBmdW5jdGlvbiAoRGlhbG9nLCBvcHRpb25zKSB7XG4gIHZhciBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gJyc7XG4gIGlmIChvcHRpb25zLmhlYWRlclRleHQpIHtcbiAgICBjb250ZW50RGl2LmlubmVySFRNTCArPSAnPHAgY2xhc3M9XCJkaWFsb2ctdGl0bGVcIj4nICsgb3B0aW9ucy5oZWFkZXJUZXh0ICsgJzwvcD4nO1xuICB9XG4gIGlmIChvcHRpb25zLmJvZHlUZXh0KSB7XG4gICAgY29udGVudERpdi5pbm5lckhUTUwgKz0gJzxwPicgKyBvcHRpb25zLmJvZHlUZXh0ICsgJzwvcD4nO1xuICB9XG5cbiAgdmFyIGJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9ucy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b25zLmh0bWwuZWpzJykoe1xuICAgIGRhdGE6IHtcbiAgICAgIGNvbmZpcm1UZXh0OiBvcHRpb25zLmNvbmZpcm1UZXh0LFxuICAgICAgY2FuY2VsVGV4dDogb3B0aW9ucy5jYW5jZWxUZXh0LFxuICAgICAgY2FuY2VsQnV0dG9uQ2xhc3M6IG9wdGlvbnMuY2FuY2VsQnV0dG9uQ2xhc3NcbiAgICB9XG4gIH0pO1xuICBjb250ZW50RGl2LmFwcGVuZENoaWxkKGJ1dHRvbnMpO1xuXG4gIHZhciBkaWFsb2cgPSB0aGlzLmNyZWF0ZU1vZGFsRGlhbG9nKHtcbiAgICBEaWFsb2c6IERpYWxvZyxcbiAgICBjb250ZW50RGl2OiBjb250ZW50RGl2LFxuICAgIGljb246IG9wdGlvbnMuaGlkZUljb24gPyBudWxsIDogdGhpcy5zdHVkaW9BcHBfLmljb24sXG4gICAgZGVmYXVsdEJ0blNlbGVjdG9yOiAnI2FnYWluLWJ1dHRvbidcbiAgfSk7XG5cbiAgdmFyIGNhbmNlbEJ1dHRvbiA9IGJ1dHRvbnMucXVlcnlTZWxlY3RvcignI2FnYWluLWJ1dHRvbicpO1xuICBpZiAoY2FuY2VsQnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChjYW5jZWxCdXR0b24sIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG9wdGlvbnMub25DYW5jZWwpIHtcbiAgICAgICAgb3B0aW9ucy5vbkNhbmNlbCgpO1xuICAgICAgfVxuICAgICAgZGlhbG9nLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjb25maXJtQnV0dG9uID0gYnV0dG9ucy5xdWVyeVNlbGVjdG9yKCcjY29uZmlybS1idXR0b24nKTtcbiAgaWYgKGNvbmZpcm1CdXR0b24pIHtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNvbmZpcm1CdXR0b24sIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG9wdGlvbnMub25Db25maXJtKSB7XG4gICAgICAgIG9wdGlvbnMub25Db25maXJtKCk7XG4gICAgICB9XG4gICAgICBkaWFsb2cuaGlkZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlhbG9nLnNob3coKTtcbn07XG5cbi8qKlxuICpcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuc2hvd1RvZ2dsZUJsb2Nrc0Vycm9yID0gZnVuY3Rpb24oRGlhbG9nKSB7XG4gIHZhciBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gbXNnLnRvZ2dsZUJsb2Nrc0Vycm9yTXNnKCk7XG5cbiAgdmFyIGJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9ucy5pbm5lckhUTUwgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b25zLmh0bWwuZWpzJykoe1xuICAgIGRhdGE6IHtcbiAgICAgIG9rOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgY29udGVudERpdi5hcHBlbmRDaGlsZChidXR0b25zKTtcblxuICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVNb2RhbERpYWxvZyh7XG4gICAgICBEaWFsb2c6IERpYWxvZyxcbiAgICAgIGNvbnRlbnREaXY6IGNvbnRlbnREaXYsXG4gICAgICBpY29uOiB0aGlzLnN0dWRpb0FwcF8uaWNvbixcbiAgICAgIGRlZmF1bHRCdG5TZWxlY3RvcjogJyNvay1idXR0b24nXG4gIH0pO1xuXG4gIHZhciBva2F5QnV0dG9uID0gYnV0dG9ucy5xdWVyeVNlbGVjdG9yKCcjb2stYnV0dG9uJyk7XG4gIGlmIChva2F5QnV0dG9uKSB7XG4gICAgZG9tLmFkZENsaWNrVG91Y2hFdmVudChva2F5QnV0dG9uLCBmdW5jdGlvbigpIHtcbiAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBkaWFsb2cuc2hvdygpO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gZW1wdHkgY29udGFpbmVyIGJsb2NrLCBpZiBhbnkgYXJlIHByZXNlbnQuXG4gKiBAcmV0dXJuIHtCbG9ja2x5LkJsb2NrfSBhbiBlbXB0eSBjb250YWluZXIgYmxvY2ssIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0RW1wdHlDb250YWluZXJCbG9ja18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJsb2NrcyA9IEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCk7XG4gIHJldHVybiBCbG9ja2x5LmZpbmRFbXB0eUNvbnRhaW5lckJsb2NrKGJsb2Nrcyk7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciBlbXB0eSBjb250YWluZXIgYmxvY2tzLCBhbmQgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIGZhaWx1cmVcbiAqIGNvZGUgaWYgYW55IGFyZSBmb3VuZC5cbiAqIEByZXR1cm4ge1Rlc3RSZXN1bHRzfSBBTExfUEFTUyBpZiBubyBlbXB0eSBibG9ja3MgYXJlIHByZXNlbnQsIG9yXG4gKiAgIEVNUFRZX0JMT0NLX0ZBSUwgb3IgRU1QVFlfRlVOQ1RJT05fQkxPQ0tfRkFJTCBpZiBlbXB0eSBibG9ja3NcbiAqICAgYXJlIGZvdW5kLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5jaGVja0ZvckVtcHR5Q29udGFpbmVyQmxvY2tGYWlsdXJlXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW1wdHlCbG9jayA9IHRoaXMuZ2V0RW1wdHlDb250YWluZXJCbG9ja18oKTtcbiAgaWYgKCFlbXB0eUJsb2NrKSB7XG4gICAgcmV0dXJuIFRlc3RSZXN1bHRzLkFMTF9QQVNTO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbXB0eUJsb2NrLnR5cGU7XG4gIGlmICh0eXBlID09PSAncHJvY2VkdXJlc19kZWZub3JldHVybicgfHwgdHlwZSA9PT0gJ3Byb2NlZHVyZXNfZGVmcmV0dXJuJykge1xuICAgIHJldHVybiBUZXN0UmVzdWx0cy5FTVBUWV9GVU5DVElPTl9CTE9DS19GQUlMO1xuICB9XG5cbiAgLy8gQmxvY2sgaXMgYXNzdW1lZCB0byBiZSBcImlmXCIgb3IgXCJyZXBlYXRcIiBpZiB3ZSByZWFjaCBoZXJlLlxuICAvLyBUaGlzIGlzIHdoZXJlIHRvIGFkZCBjaGVja3MgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgVGVzdFJlc3VsdFxuICAvLyBmb3IgXCJjb250cm9sc19mb3JfY291bnRlclwiIGJsb2NrcywgZm9yIGV4YW1wbGUuXG4gIHJldHVybiBUZXN0UmVzdWx0cy5FTVBUWV9CTE9DS19GQUlMO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgZXJyb3JzIHdpdGggZGVzY3JpcHRpdmUgbWVzc2FnZXMgd2hlbiBleGFtcGxlIGNhbGwgb3IgcmVzdWx0IGJsb2Nrc1xuICogZG9uJ3QgZXhpc3Qgb3IgaGF2ZSB1bmZpbGxlZCBmdW5jdGlvbmFsIGlucHV0cy5cbiAqIEBwYXJhbSB7QmxvY2tseS5CbG9ja30gY2FsbEJsb2NrXG4gKiBAcGFyYW0ge0Jsb2NrbHkuQmxvY2t9IHJlc3VsdEJsb2NrXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLnRocm93T25JbnZhbGlkRXhhbXBsZUJsb2NrcyA9IGZ1bmN0aW9uIChjYWxsQmxvY2ssXG4gICAgcmVzdWx0QmxvY2spIHtcbiAgaWYgKCFjYWxsQmxvY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ2FsbCBCbG9jaycpO1xuICB9XG5cbiAgaWYgKCFyZXN1bHRCbG9jaykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSZXN1bHQgQmxvY2snKTtcbiAgfVxuXG4gIGlmIChyZXN1bHRCbG9jay5oYXNVbmZpbGxlZEZ1bmN0aW9uYWxJbnB1dCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bHQgaGFzIHVuZmlsbGVkIGlucHV0cycpO1xuICB9XG5cbiAgaWYgKGNhbGxCbG9jay5oYXNVbmZpbGxlZEZ1bmN0aW9uYWxJbnB1dCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGhhcyB1bmZpbGxlZCBpbnB1dHMnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGNvZGUgaGFzIGFsbCB0aGUgZ2l2ZW4gYmxvY2tzXG4gKiBAcGFyYW0geyFUZXN0YWJsZUJsb2NrW119IGJsb2Nrc1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbGwgYmxvY2tzIGFyZSBwcmVzZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc0FsbEJsb2Nrc18gPSBmdW5jdGlvbihibG9ja3MpIHtcbiAgLy8gSXQncyBva2F5IChtYXliZSBmYXN0ZXIpIHRvIHBhc3MgMSBmb3IgbWF4QmxvY2tzVG9GbGFnLCBzaW5jZSBpbiB0aGUgZW5kXG4gIC8vIHdlIHdhbnQgdG8gY2hlY2sgdGhhdCB0aGVyZSBhcmUgemVybyBibG9ja3MgbWlzc2luZy5cbiAgdmFyIG1heEJsb2Nrc1RvRmxhZyA9IDE7XG4gIHJldHVybiB0aGlzLmdldE1pc3NpbmdCbG9ja3NfKGJsb2NrcywgbWF4QmxvY2tzVG9GbGFnKS5ibG9ja3NUb0Rpc3BsYXkubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBHZXQgYmxvY2tzIHRoYXQgdGhlIHVzZXIgaW50ZW5kcyBpbiB0aGUgcHJvZ3JhbS4gVGhlc2UgYXJlIHRoZSBibG9ja3NcbiAqIHRoYXQgYXJlIHVzZWQgd2hlbiBjaGVja2luZyBmb3IgcmVxdWlyZWQgYW5kIHJlY29tbWVuZGVkIGJsb2NrcyBhbmRcbiAqIHdoZW4gZGV0ZXJtaW5pbmcgbGluZXMgb2YgY29kZSB3cml0dGVuLlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gVGhlIGJsb2Nrcy5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0VXNlckJsb2Nrc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFsbEJsb2NrcyA9IEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCk7XG4gIHZhciBibG9ja3MgPSBhbGxCbG9ja3MuZmlsdGVyKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIGJsb2NrVmFsaWQgPSAhYmxvY2suZGlzYWJsZWQgJiYgYmxvY2sudHlwZSAhPT0gJ3doZW5fcnVuJztcbiAgICAvLyBJZiBCbG9ja2x5IGlzIGluIHJlYWRPbmx5IG1vZGUsIHRoZW4gYWxsIGJsb2NrcyBhcmUgdW5lZGl0YWJsZVxuICAgIC8vIHNvIHRoaXMgZmlsdGVyIHdvdWxkIGJlIHVzZWxlc3MuIElnbm9yZSB1bmVkaXRhYmxlIGJsb2NrcyBvbmx5IGlmXG4gICAgLy8gQmxvY2tseSBpcyBpbiBlZGl0IG1vZGUuXG4gICAgaWYgKCFCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmlzUmVhZE9ubHkoKSkge1xuICAgICAgYmxvY2tWYWxpZCA9IGJsb2NrVmFsaWQgJiYgYmxvY2suaXNFZGl0YWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tWYWxpZDtcbiAgfSk7XG4gIHJldHVybiBibG9ja3M7XG59O1xuXG4vKipcbiAqIEdldCBjb3VudGFibGUgYmxvY2tzIGluIHRoZSBwcm9ncmFtLCBuYW1lbHkgYW55IHRoYXQgYXJlIG5vdCBkaXNhYmxlZC5cbiAqIFRoZXNlIGFyZSB1c2VkIHdoZW4gZGV0ZXJtaW5lZCB0aGUgbnVtYmVyIG9mIGJsb2NrcyByZWxhdGl2ZSB0byB0aGUgaWRlYWxcbiAqIGJsb2NrIGNvdW50LlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gVGhlIGJsb2Nrcy5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0Q291bnRhYmxlQmxvY2tzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYWxsQmxvY2tzID0gQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRBbGxCbG9ja3MoKTtcbiAgdmFyIGJsb2NrcyA9IGFsbEJsb2Nrcy5maWx0ZXIoZnVuY3Rpb24oYmxvY2spIHtcbiAgICByZXR1cm4gIWJsb2NrLmRpc2FibGVkO1xuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcztcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSB1c2VyJ3MgY29kZSBjb250YWlucyB0aGUgZ2l2ZW4gYmxvY2tzIGZvciBhIGxldmVsLlxuICogQHBhcmFtIHshVGVzdGFibGVCbG9ja1tdfSBibG9ja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhCbG9ja3NUb0ZsYWcgVGhlIG1heGltdW0gbnVtYmVyIG9mIGJsb2NrcyB0b1xuICogICByZXR1cm4uIFdlIG1vc3Qgb2Z0ZW4gb25seSBjYXJlIGFib3V0IGEgc2luZ2xlIGJsb2NrIGF0IGEgdGltZVxuICogQHJldHVybiB7e2Jsb2Nrc1RvRGlzcGxheTohQXJyYXksIG1lc3NhZ2U6P3N0cmluZ319ICdtaXNzaW5nQmxvY2tzJyBpcyBhblxuICogICBhcnJheSBvZiBhcnJheSBvZiBzdHJpbmdzIHdoZXJlIGVhY2ggYXJyYXkgb2Ygc3RyaW5ncyBpcyBhIHNldCBvZiBibG9ja3NcbiAqICAgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBzaG91bGQgYmUgdXNlZC4gRWFjaCBibG9jayBpcyByZXByZXNlbnRlZCBhcyB0aGVcbiAqICAgcHJlZml4IG9mIGFuIGlkIGluIHRoZSBjb3JyZXNwb25kaW5nIHRlbXBsYXRlLnNveS4gJ21lc3NhZ2UnIGlzIGFuXG4gKiAgIG9wdGlvbmFsIG1lc3NhZ2UgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgZXJyb3IgdGV4dC5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuZ2V0TWlzc2luZ0Jsb2Nrc18gPSBmdW5jdGlvbiAoYmxvY2tzLCBtYXhCbG9ja3NUb0ZsYWcpIHtcbiAgdmFyIG1pc3NpbmdCbG9ja3MgPSBbXTtcbiAgdmFyIGN1c3RvbU1lc3NhZ2UgPSBudWxsO1xuICB2YXIgY29kZSA9IG51bGw7ICAvLyBKYXZhU2NyaXB0IGNvZGUsIHdoaWNoIGlzIGluaXRpYWxpemVkIGxhemlseS5cbiAgaWYgKGJsb2NrcyAmJiBibG9ja3MubGVuZ3RoKSB7XG4gICAgdmFyIHVzZXJCbG9ja3MgPSB0aGlzLmdldFVzZXJCbG9ja3NfKCk7XG4gICAgLy8gRm9yIGVhY2ggbGlzdCBvZiBibG9ja3NcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgdGhlIG1pc3NpbmcgYmxvY2sgbGlzdHMuIEl0IHNob3VsZCBub3QgYmVcbiAgICAvLyBiaWdnZXIgdGhhbiB0aGUgbWF4QmxvY2tzVG9GbGFnIHBhcmFtLlxuICAgIHZhciBtaXNzaW5nQmxvY2tOdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwO1xuICAgICAgICAgaSA8IGJsb2Nrcy5sZW5ndGggJiZcbiAgICAgICAgICAgICBtaXNzaW5nQmxvY2tOdW0gPCBtYXhCbG9ja3NUb0ZsYWc7XG4gICAgICAgICBpKyspIHtcbiAgICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgIC8vIEZvciBlYWNoIG9mIHRoZSB0ZXN0XG4gICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRlc3RzIHN1Y2NlZWRlZCwgd2UgY29uc2lkZXIgdGhlIGJsb2NrXG4gICAgICAvLyBpcyB1c2VkXG4gICAgICB2YXIgdXNlZEJsb2NrID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciB0ZXN0SWQgPSAwOyB0ZXN0SWQgPCBibG9jay5sZW5ndGg7IHRlc3RJZCsrKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gYmxvY2tbdGVzdElkXS50ZXN0O1xuICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29kZSA9IGNvZGUgfHwgQmxvY2tseS5HZW5lcmF0b3IuYmxvY2tTcGFjZVRvQ29kZSgnSmF2YVNjcmlwdCcpO1xuICAgICAgICAgIGlmIChjb2RlLmluZGV4T2YodGVzdCkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTdWNjZWVkZWQsIG1vdmluZyB0byB0aGUgbmV4dCBsaXN0IG9mIHRlc3RzXG4gICAgICAgICAgICB1c2VkQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHVzZXJCbG9ja3Muc29tZSh0ZXN0KSkge1xuICAgICAgICAgICAgLy8gU3VjY2VlZGVkLCBtb3ZpbmcgdG8gdGhlIG5leHQgbGlzdCBvZiB0ZXN0c1xuICAgICAgICAgICAgdXNlZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXN0b21NZXNzYWdlID0gYmxvY2tbdGVzdElkXS5tZXNzYWdlIHx8IGN1c3RvbU1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHRlc3Q6ICcgKyB0ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1c2VkQmxvY2spIHtcbiAgICAgICAgbWlzc2luZ0Jsb2NrTnVtKys7XG4gICAgICAgIG1pc3NpbmdCbG9ja3MgPSBtaXNzaW5nQmxvY2tzLmNvbmNhdChibG9ja3NbaV1bMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGJsb2Nrc1RvRGlzcGxheTogbWlzc2luZ0Jsb2NrcyxcbiAgICBtZXNzYWdlOiBjdXN0b21NZXNzYWdlXG4gIH07XG59O1xuXG4vKipcbiAqIERvIHdlIGhhdmUgYW55IGZsb2F0aW5nIGJsb2NrcyBub3QgYXR0YWNoZWQgdG8gYW4gZXZlbnQgYmxvY2sgb3IgZnVuY3Rpb24gYmxvY2s/XG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc0V4dHJhVG9wQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdHVkaW9BcHBfLmVkaXRDb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0b3BCbG9ja3MgPSBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldFRvcEJsb2NrcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvcEJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGlnbm9yZSBkaXNhYmxlZCB0b3AgYmxvY2tzLiB3ZSBoYXZlIGEgbGV2ZWwgdHVydGxlOjJfNyB0aGF0IGRlcGVuZHMgb25cbiAgICAvLyBoYXZpbmcgZGlzYWJsZWQgdG9wIGxldmVsIGJsb2Nrc1xuICAgIGlmICh0b3BCbG9ja3NbaV0uZGlzYWJsZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgdG9wIGJsb2NrcyB3aGljaCBhcmUgZnVuY3Rpb25hbCBkZWZpbml0aW9ucy5cbiAgICBpZiAodG9wQmxvY2tzW2ldLnR5cGUgPT09ICdmdW5jdGlvbmFsX2RlZmluaXRpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gTm9uZSBvZiBvdXIgdG9wIGxldmVsIGJsb2NrcyBzaG91bGQgaGF2ZSBhIHByZXZpb3VzIG9yIG91dHB1dCBjb25uZWN0aW9uXG4gICAgLy8gKHRoZXkgc2hvdWxkIG9ubHkgaGF2ZSBhIG5leHQpXG4gICAgaWYgKHRvcEJsb2Nrc1tpXS5wcmV2aW91c0Nvbm5lY3Rpb24gfHwgdG9wQmxvY2tzW2ldLm91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJ1bnMgdGhlIHRlc3RzIGFuZCByZXR1cm5zIHJlc3VsdHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxldmVsQ29tcGxldGUgRGlkIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZSB0aGUgbGV2ZWw/XG4gKiBAcGFyYW0geyFUZXN0YWJsZUJsb2NrW119IHJlcXVpcmVkQmxvY2tzIFRoZSBibG9ja3MgdGhhdCBhcmUgcmVxdWlyZWRcbiAqICAgdG8gYmUgdXNlZCBpbiB0aGUgc29sdXRpb24gdG8gdGhpcyBsZXZlbC5cbiAqIEBwYXJhbSB7IVRlc3RhYmxlQmxvY2tbXX0gcmVjb21tZW5kZWRCbG9ja3MgVGhlIGJsb2NrcyB0aGF0IGFyZVxuICogICByZWNvbW1lbmRlZCB0byBiZSB1c2VkIGluIHRoZSBzb2x1dGlvbiB0byB0aGlzIGxldmVsLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRDaGVja0ZvckVtcHR5QmxvY2tzIFdoZXRoZXIgZW1wdHkgYmxvY2tzIHNob3VsZCBjYXVzZVxuICogICBhIHRlc3QgZmFpbCByZXN1bHQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXBwcm9wcmlhdGUgcHJvcGVydHkgb2YgVGVzdFJlc3VsdHMuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmdldFRlc3RSZXN1bHRzID0gZnVuY3Rpb24obGV2ZWxDb21wbGV0ZSwgcmVxdWlyZWRCbG9ja3MsXG4gICAgcmVjb21tZW5kZWRCbG9ja3MsIHNob3VsZENoZWNrRm9yRW1wdHlCbG9ja3MsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICh0aGlzLnN0dWRpb0FwcF8uZWRpdENvZGUpIHtcbiAgICBpZiAobGV2ZWxDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R1ZGlvQXBwXy5UZXN0UmVzdWx0cy5BTExfUEFTUztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXhlY3V0aW9uRXJyb3IgJiYgb3B0aW9ucy5leGVjdXRpb25FcnJvci5lcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuc3R1ZGlvQXBwXy5UZXN0UmVzdWx0cy5TWU5UQVhfRVJST1JfRkFJTDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXhlY3V0aW9uRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0dWRpb0FwcF8uVGVzdFJlc3VsdHMuUlVOVElNRV9FUlJPUl9GQUlMO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHVkaW9BcHBfLlRlc3RSZXN1bHRzLlRPT19GRVdfQkxPQ0tTX0ZBSUw7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRDaGVja0ZvckVtcHR5QmxvY2tzKSB7XG4gICAgdmFyIGVtcHR5QmxvY2tGYWlsdXJlID0gdGhpcy5jaGVja0ZvckVtcHR5Q29udGFpbmVyQmxvY2tGYWlsdXJlXygpO1xuICAgIGlmIChlbXB0eUJsb2NrRmFpbHVyZSAhPT0gVGVzdFJlc3VsdHMuQUxMX1BBU1MpIHtcbiAgICAgIHJldHVybiBlbXB0eUJsb2NrRmFpbHVyZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRpb25zLmFsbG93VG9wQmxvY2tzICYmIHRoaXMuaGFzRXh0cmFUb3BCbG9ja3MoKSkge1xuICAgIHJldHVybiBUZXN0UmVzdWx0cy5FWFRSQV9UT1BfQkxPQ0tTX0ZBSUw7XG4gIH1cbiAgaWYgKHRoaXMuc3R1ZGlvQXBwXy5oYXNEdXBsaWNhdGVWYXJpYWJsZXNJbkZvckxvb3BzKCkpIHtcbiAgICByZXR1cm4gVGVzdFJlc3VsdHMuTkVTVEVEX0ZPUl9TQU1FX1ZBUklBQkxFO1xuICB9XG4gIGlmIChCbG9ja2x5LnVzZUNvbnRyYWN0RWRpdG9yIHx8IEJsb2NrbHkudXNlTW9kYWxGdW5jdGlvbkVkaXRvcikge1xuICAgIGlmICh0aGlzLmhhc1VudXNlZFBhcmFtXygpKSB7XG4gICAgICByZXR1cm4gVGVzdFJlc3VsdHMuVU5VU0VEX1BBUkFNO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNVbnVzZWRGdW5jdGlvbl8oKSkge1xuICAgICAgcmV0dXJuIFRlc3RSZXN1bHRzLlVOVVNFRF9GVU5DVElPTjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzUGFyYW1JbnB1dFVuYXR0YWNoZWRfKCkpIHtcbiAgICAgIHJldHVybiBUZXN0UmVzdWx0cy5QQVJBTV9JTlBVVF9VTkFUVEFDSEVEO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNJbmNvbXBsZXRlQmxvY2tJbkZ1bmN0aW9uXygpKSB7XG4gICAgICByZXR1cm4gVGVzdFJlc3VsdHMuSU5DT01QTEVURV9CTE9DS19JTl9GVU5DVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuaGFzUXVlc3Rpb25NYXJrc0luTnVtYmVyRmllbGQoKSkge1xuICAgIHJldHVybiBUZXN0UmVzdWx0cy5RVUVTVElPTl9NQVJLU19JTl9OVU1CRVJfRklFTEQ7XG4gIH1cbiAgaWYgKCF0aGlzLmhhc0FsbEJsb2Nrc18ocmVxdWlyZWRCbG9ja3MpKSB7XG4gICAgcmV0dXJuIGxldmVsQ29tcGxldGUgP1xuICAgICAgICBUZXN0UmVzdWx0cy5NSVNTSU5HX0JMT0NLX0ZJTklTSEVEIDpcbiAgICAgICAgVGVzdFJlc3VsdHMuTUlTU0lOR19CTE9DS19VTkZJTklTSEVEO1xuICB9XG4gIGlmICghdGhpcy5oYXNBbGxCbG9ja3NfKHJlY29tbWVuZGVkQmxvY2tzKSkge1xuICAgIHJldHVybiBsZXZlbENvbXBsZXRlID9cbiAgICAgICAgVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19GSU5JU0hFRCA6XG4gICAgICAgIFRlc3RSZXN1bHRzLk1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfVU5GSU5JU0hFRDtcbiAgfVxuICB2YXIgbnVtRW5hYmxlZEJsb2NrcyA9IHRoaXMuZ2V0TnVtQ291bnRhYmxlQmxvY2tzKCk7XG4gIGlmICghbGV2ZWxDb21wbGV0ZSkge1xuICAgIGlmICh0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNICYmXG4gICAgICAgIHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0gIT09IEluZmluaXR5ICYmXG4gICAgICAgIG51bUVuYWJsZWRCbG9ja3MgPCB0aGlzLnN0dWRpb0FwcF8uSURFQUxfQkxPQ0tfTlVNKSB7XG4gICAgICByZXR1cm4gVGVzdFJlc3VsdHMuVE9PX0ZFV19CTE9DS1NfRkFJTDtcbiAgICB9XG4gICAgcmV0dXJuIFRlc3RSZXN1bHRzLkxFVkVMX0lOQ09NUExFVEVfRkFJTDtcbiAgfVxuICBpZiAodGhpcy5zdHVkaW9BcHBfLklERUFMX0JMT0NLX05VTSAmJlxuICAgICAgbnVtRW5hYmxlZEJsb2NrcyA+IHRoaXMuc3R1ZGlvQXBwXy5JREVBTF9CTE9DS19OVU0pIHtcbiAgICByZXR1cm4gVGVzdFJlc3VsdHMuVE9PX01BTllfQkxPQ0tTX0ZBSUw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRlc3RSZXN1bHRzLkFMTF9QQVNTO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgYSBtb2RhbCBkaWFsb2cgd2l0aG91dCBhbiBpY29uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RGlhbG9nfSBvcHRpb25zLkRpYWxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWNvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5jb250ZW50RGl2XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kZWZhdWx0QnRuU2VsZWN0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5tYXJrZG93bk1vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zY3JvbGxDb250ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2Nyb2xsYWJsZVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm9uSGlkZGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5oZWFkZXJcbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuY3JlYXRlTW9kYWxEaWFsb2cgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBtb2RhbEJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaWYgKG9wdGlvbnMuaWNvbikge1xuICAgIHZhciBpbWFnZURpdjtcbiAgICBpbWFnZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltYWdlRGl2LmNsYXNzTmFtZSA9IFwibW9kYWwtaW1hZ2VcIjtcbiAgICBpbWFnZURpdi5zcmMgPSBvcHRpb25zLmljb247XG4gICAgbW9kYWxCb2R5LmFwcGVuZENoaWxkKGltYWdlRGl2KTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmNvbnRlbnREaXYuY2xhc3NOYW1lICs9ICcgbm8tbW9kYWwtaWNvbic7XG4gIH1cblxuICBpZiAob3B0aW9ucy5tYXJrZG93bk1vZGUpIHtcbiAgICBtb2RhbEJvZHkuY2xhc3NOYW1lICs9ICcgbWFya2Rvd24nO1xuICB9XG5cbiAgb3B0aW9ucy5jb250ZW50RGl2LmNsYXNzTmFtZSArPSAnIG1vZGFsLWNvbnRlbnQnO1xuICBtb2RhbEJvZHkuYXBwZW5kQ2hpbGQob3B0aW9ucy5jb250ZW50RGl2KTtcblxuICB2YXIgYnRuID0gb3B0aW9ucy5jb250ZW50RGl2LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5kZWZhdWx0QnRuU2VsZWN0b3IpO1xuICB2YXIga2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSBLZXlDb2Rlcy5FTlRFUiB8fCBlLmtleUNvZGUgPT0gS2V5Q29kZXMuU1BBQ0UpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGEgJ2NsaWNrJzpcbiAgICAgIHZhciBldmVudCA9IG5ldyBNb3VzZUV2ZW50KCdjbGljaycsIHtcbiAgICAgICAgICAndmlldyc6IHdpbmRvdyxcbiAgICAgICAgICAnYnViYmxlcyc6IHRydWUsXG4gICAgICAgICAgJ2NhbmNlbGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ0bi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNjcm9sbGFibGVTZWxlY3RvciA9IG9wdGlvbnMuc2Nyb2xsYWJsZVNlbGVjdG9yIHx8ICcubW9kYWwtY29udGVudCc7XG4gIHZhciBlbGVtZW50VG9TY3JvbGwgPSBvcHRpb25zLnNjcm9sbENvbnRlbnQgPyBzY3JvbGxhYmxlU2VsZWN0b3IgOiBudWxsO1xuICByZXR1cm4gbmV3IG9wdGlvbnMuRGlhbG9nKHtcbiAgICBib2R5OiBtb2RhbEJvZHksXG4gICAgb25IaWRkZW46IG9wdGlvbnMub25IaWRkZW4sXG4gICAgb25LZXlkb3duOiBidG4gPyBrZXlkb3duSGFuZGxlciA6IHVuZGVmaW5lZCxcbiAgICBhdXRvUmVzaXplU2Nyb2xsYWJsZUVsZW1lbnQ6IGVsZW1lbnRUb1Njcm9sbCxcbiAgICBpZDogb3B0aW9ucy5pZCxcbiAgICBoZWFkZXI6IG9wdGlvbnMuaGVhZGVyXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgJz8/PycgaW5zdGVhZCBvZiBhIHZhbHVlIGluIGJsb2NrIGZpZWxkcy5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuaGFzUXVlc3Rpb25NYXJrc0luTnVtYmVyRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUoZnVuY3Rpb24oYmxvY2spIHtcbiAgICByZXR1cm4gYmxvY2suZ2V0VGl0bGVzKCkuc29tZShmdW5jdGlvbih0aXRsZSkge1xuICAgICAgcmV0dXJuIHRpdGxlLnZhbHVlXyA9PT0gJz8/PycgfHwgdGl0bGUudGV4dF8gPT09ICc/Pz8nO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYWxsIHByb2NlZHVyZSBkZWZpbml0aW9ucyBhY3R1YWxseSB1c2UgdGhlIHBhcmFtZXRlcnMgdGhleSBkZWZpbmVcbiAqIGluc2lkZSB0aGUgcHJvY2VkdXJlLlxuICovXG5GZWVkYmFja1V0aWxzLnByb3RvdHlwZS5oYXNVbnVzZWRQYXJhbV8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCkuc29tZShmdW5jdGlvbih1c2VyQmxvY2spIHtcbiAgICB2YXIgcGFyYW1zID0gdXNlckJsb2NrLnBhcmFtZXRlck5hbWVzXztcbiAgICAvLyBPbmx5IHNlYXJjaCBwcm9jZWR1cmUgZGVmaW5pdGlvbnNcbiAgICByZXR1cm4gcGFyYW1zICYmIHBhcmFtcy5zb21lKGZ1bmN0aW9uKHBhcmFtTmFtZSkge1xuICAgICAgLy8gVW51c2VkIHBhcmFtIGlmIHRoZXJlJ3Mgbm8gcGFyYW1ldGVyc19nZXQgZGVzY2VuZGFudCB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgIHJldHVybiAhc2VsZi5oYXNNYXRjaGluZ0Rlc2NlbmRhbnRfKHVzZXJCbG9jaywgZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIChibG9jay50eXBlID09PSAncGFyYW1ldGVyc19nZXQnIHx8XG4gICAgICAgICAgICBibG9jay50eXBlID09PSAnZnVuY3Rpb25hbF9wYXJhbWV0ZXJzX2dldCcgfHxcbiAgICAgICAgICAgIGJsb2NrLnR5cGUgPT09ICd2YXJpYWJsZXNfZ2V0JykgJiZcbiAgICAgICAgICAgIGJsb2NrLmdldFRpdGxlVmFsdWUoJ1ZBUicpID09PSBwYXJhbU5hbWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFsbCBwcm9jZWR1cmUgY2FsbHMgaGF2ZSBlYWNoIHBhcmFtZXRlciBpbnB1dCBjb25uZWN0ZWQuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc1BhcmFtSW5wdXRVbmF0dGFjaGVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEJsb2NrbHkubWFpbkJsb2NrU3BhY2UuZ2V0QWxsQmxvY2tzKCkuc29tZShmdW5jdGlvbih1c2VyQmxvY2spIHtcbiAgICAvLyBPbmx5IGNoZWNrIHByb2NlZHVyZV9jYWxsKiBibG9ja3NcbiAgICBpZiAoIS9ecHJvY2VkdXJlc19jYWxsLy50ZXN0KHVzZXJCbG9jay50eXBlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdXNlckJsb2NrLmlucHV0TGlzdC5maWx0ZXIoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiAoL15BUkcvLnRlc3QoaW5wdXQubmFtZSkpO1xuICAgIH0pLnNvbWUoZnVuY3Rpb24oYXJnSW5wdXQpIHtcbiAgICAgIC8vIFVuYXR0YWNoZWQgcGFyYW0gaW5wdXQgaWYgYW55IEFSRyogY29ubmVjdGlvbiB0YXJnZXQgaXMgbnVsbFxuICAgICAgcmV0dXJuICFhcmdJbnB1dC5jb25uZWN0aW9uLnRhcmdldENvbm5lY3Rpb247XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbGwgdXNlci1kZWNsYXJlZCBwcm9jZWR1cmVzIGhhdmUgYXNzb2NpYXRlZCBjYWxsIGJsb2Nrcy5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuaGFzVW51c2VkRnVuY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXNlckRlZnMgPSBbXTtcbiAgdmFyIGNhbGxCbG9ja3MgPSB7fTtcbiAgQmxvY2tseS5tYWluQmxvY2tTcGFjZS5nZXRBbGxCbG9ja3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHZhciBuYW1lID0gYmxvY2suZ2V0VGl0bGVWYWx1ZSgnTkFNRScpO1xuICAgIGlmICgvXnByb2NlZHVyZXNfZGVmLy50ZXN0KGJsb2NrLnR5cGUpICYmIGJsb2NrLnVzZXJDcmVhdGVkKSB7XG4gICAgICB1c2VyRGVmcy5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoL15wcm9jZWR1cmVzX2NhbGwvLnRlc3QoYmxvY2sudHlwZSkpIHtcbiAgICAgIGNhbGxCbG9ja3NbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIC8vIFVudXNlZCBmdW5jdGlvbiBpZiBzb21lIHVzZXIgZGVmIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNhbGxcbiAgcmV0dXJuIHVzZXJEZWZzLnNvbWUoZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gIWNhbGxCbG9ja3NbbmFtZV07IH0pO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgdGhlcmUgYXJlIG5vIGluY29tcGxldGUgYmxvY2tzIGluc2lkZSBhbnkgZnVuY3Rpb24gZGVmaW5pdGlvbnMuXG4gKi9cbkZlZWRiYWNrVXRpbHMucHJvdG90eXBlLmhhc0luY29tcGxldGVCbG9ja0luRnVuY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBCbG9ja2x5Lm1haW5CbG9ja1NwYWNlLmdldEFsbEJsb2NrcygpLnNvbWUoZnVuY3Rpb24odXNlckJsb2NrKSB7XG4gICAgLy8gT25seSBzZWFyY2ggcHJvY2VkdXJlIGRlZmluaXRpb25zXG4gICAgaWYgKCF1c2VyQmxvY2sucGFyYW1ldGVyTmFtZXNfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLmhhc01hdGNoaW5nRGVzY2VuZGFudF8odXNlckJsb2NrLCBmdW5jdGlvbihibG9jaykge1xuICAgICAgLy8gSW5jb21wbGV0ZSBibG9jayBpZiBhbnkgaW5wdXQgY29ubmVjdGlvbiB0YXJnZXQgaXMgbnVsbFxuICAgICAgcmV0dXJuIGJsb2NrLmlucHV0TGlzdC5zb21lKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC50eXBlID09PSBCbG9ja2x5LklOUFVUX1ZBTFVFICYmXG4gICAgICAgICAgICAhaW5wdXQuY29ubmVjdGlvbi50YXJnZXRDb25uZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW55IGRlc2NlbmRhbnQgKGluY2x1c2l2ZSkgb2YgdGhlIGdpdmVuIG5vZGUgbWF0Y2hlcyB0aGVcbiAqIGdpdmVuIGZpbHRlci5cbiAqL1xuRmVlZGJhY2tVdGlscy5wcm90b3R5cGUuaGFzTWF0Y2hpbmdEZXNjZW5kYW50XyA9IGZ1bmN0aW9uIChub2RlLCBmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlcihub2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIG5vZGUuY2hpbGRCbG9ja3NfLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIHNlbGYuaGFzTWF0Y2hpbmdEZXNjZW5kYW50XyhjaGlsZCwgZmlsdGVyKTtcbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVxcJ3Ryb3BoeVxcJz48aW1nIGNsYXNzPVxcJ3Ryb3BoeWltZ1xcJyBzcmM9XFwnJywgZXNjYXBlKCgxLCAgaW1nX3VybCApKSwgJ1xcJz48YnI+JywgZXNjYXBlKCgxLCAgY29uY2VwdF9uYW1lICkpLCAnPC9kaXY+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7IDsgYnVmLnB1c2goJ1xcblxcbjxwIGlkPVwibnVtLWxpbmVzLW9mLWNvZGVcIiBjbGFzcz1cImxpbmVzLW9mLWNvZGUtbWVzc2FnZVwiPlxcbiAgJywgZXNjYXBlKCg0LCAgbXNnLm51bUxpbmVzT2ZDb2RlV3JpdHRlbih7IG51bUxpbmVzOiBudW1MaW5lc1dyaXR0ZW4gfSkgKSksICdcXG4gIDxidXR0b24gaWQ9XCJzaG93LWNvZGUtYnV0dG9uXCIgaHJlZj1cIiNcIj5cXG4gICAgJywgZXNjYXBlKCg2LCAgbXNnLnNob3dHZW5lcmF0ZWRDb2RlKCkgKSksICdcXG4gIDwvYnV0dG9uPlxcbjwvcD5cXG5cXG4nKTsxMDsgaWYgKHRvdGFsTnVtTGluZXNXcml0dGVuICE9PSAwKSB7IDsgYnVmLnB1c2goJ1xcbiAgPHAgaWQ9XCJ0b3RhbC1udW0tbGluZXMtb2YtY29kZVwiIGNsYXNzPVwibGluZXMtb2YtY29kZS1tZXNzYWdlXCI+XFxuICAgICcsIGVzY2FwZSgoMTIsICBtc2cudG90YWxOdW1MaW5lc09mQ29kZVdyaXR0ZW4oeyBudW1MaW5lczogdG90YWxOdW1MaW5lc1dyaXR0ZW4gfSkgKSksICdcXG4gIDwvcD5cXG4nKTsxNDsgfSA7IGJ1Zi5wdXNoKCdcXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7IHZhciBtc2cgPSByZXF1aXJlKCcuLi9sb2NhbGUnKTsgOyBidWYucHVzaCgnXFxuJyk7MjsgaWYgKG9wdGlvbnMuZmVlZGJhY2tJbWFnZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxpbWcgY2xhc3M9XCJmZWVkYmFjay1pbWFnZVwiIHNyYz1cIicsIGVzY2FwZSgoMywgIG9wdGlvbnMuZmVlZGJhY2tJbWFnZSApKSwgJ1wiLz5cXG4gIDxkaXYgY2xhc3M9XCJzaGFyaW5nLWNvbnRlbnRcIj5cXG4nKTs1OyB9IGVsc2UgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgY2xhc3M9XCJzaGFyaW5nLWNvbnRlbnQgbm8taW1hZ2VcIj5cXG4nKTs3OyB9IDsgYnVmLnB1c2goJ1xcblxcblxcbicpOzEwOyBpZiAob3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLmxldmVsX3NvdXJjZSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICcpOzExOyBpZiAob3B0aW9ucy5hcHBTdHJpbmdzICYmIG9wdGlvbnMuYXBwU3RyaW5ncy5zaGFyaW5nVGV4dCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdj4nLCBlc2NhcGUoKDEyLCAgb3B0aW9ucy5hcHBTdHJpbmdzLnNoYXJpbmdUZXh0ICkpLCAnPC9kaXY+XFxuICAnKTsxMzsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG4gIDxkaXY+XFxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwic2hhcmluZy1pbnB1dFwiIHZhbHVlPScsIGVzY2FwZSgoMTYsICBvcHRpb25zLnJlc3BvbnNlLmxldmVsX3NvdXJjZSApKSwgJyByZWFkb25seT5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXCdzb2NpYWwtYnV0dG9uc1xcJz5cXG4gICAgJyk7MTk7IGlmIChvcHRpb25zLmZhY2Vib29rVXJsKSB7OyBidWYucHVzaCgnICAgICAgPGEgaHJlZj1cXCcnLCBlc2NhcGUoKDE5LCAgb3B0aW9ucy5mYWNlYm9va1VybCApKSwgJ1xcJyB0YXJnZXQ9XCJfYmxhbmtcIiBjbGFzcz1cInBvcHVwLXdpbmRvd1wiPlxcbiAgICAgICAgPGJ1dHRvbj5cXG4gICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1mYWNlYm9vayBmYS1sZ1wiPjwvaT5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvYT5cXG4gICAgJyk7MjQ7IH07IGJ1Zi5wdXNoKCcgICAgJyk7MjQ7IGlmIChvcHRpb25zLnR3aXR0ZXJVcmwpIHs7IGJ1Zi5wdXNoKCcgICAgICA8YSBocmVmPVxcJycsIGVzY2FwZSgoMjQsICBvcHRpb25zLnR3aXR0ZXJVcmwgKSksICdcXCcgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJwb3B1cC13aW5kb3dcIj5cXG4gICAgICAgIDxidXR0b24+XFxuICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtdHdpdHRlciBmYS1sZ1wiPjwvaT5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvYT5cXG4gICAgJyk7Mjk7IH07IGJ1Zi5wdXNoKCcgICAgJyk7Mjk7IGlmICghb3B0aW9ucy5vbk1haW5QYWdlICYmICFvcHRpb25zLmRpc2FibGVQcmludGluZykgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8YnV0dG9uIGlkPVwicHJpbnQtYnV0dG9uXCI+XFxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXByaW50IGZhLWxnXCI+PC9pPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAnKTszMzsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7MzQ7IGlmIChvcHRpb25zLmFscmVhZHlTYXZlZCkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8YnV0dG9uIGNsYXNzPVwic2F2ZWQtdG8tZ2FsbGVyeVwiIGRpc2FibGVkPlxcbiAgICAgICAgJywgZXNjYXBlKCgzNiwgIG1zZy5zYXZlZFRvR2FsbGVyeSgpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICcpOzM4OyB9IGVsc2UgaWYgKG9wdGlvbnMuc2F2ZVRvR2FsbGVyeVVybCAmJiAhb3B0aW9ucy5kaXNhYmxlU2F2ZVRvR2FsbGVyeSkgeyA7IGJ1Zi5wdXNoKCdcXG4gICAgICA8YnV0dG9uIGlkPVwic2F2ZS10by1nYWxsZXJ5LWJ1dHRvblwiIGNsYXNzPVwibGF1bmNoXCI+XFxuICAgICAgICAnLCBlc2NhcGUoKDQwLCAgbXNnLnNhdmVUb0dhbGxlcnkoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAnKTs0MjsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgJyk7NDM7IGlmIChvcHRpb25zLnNlbmRUb1Bob25lKSB7OyBidWYucHVzaCgnICAgICAgPGJ1dHRvbiBpZD1cInNoYXJpbmctcGhvbmVcIj5cXG4gICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbW9iaWxlIGZhLWxnXCI+PC9pPlxcbiAgICAgICAgJywgZXNjYXBlKCg0NSwgIG1zZy5zZW5kVG9QaG9uZSgpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICcpOzQ3OyB9OyBidWYucHVzaCgnXFxuICA8L2Rpdj5cXG4gIDxkaXYgaWQ9XCJzZW5kLXRvLXBob25lXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XFxuICAgIDxsYWJlbCBmb3I9XCJwaG9uZVwiPkVudGVyIGEgVVMgcGhvbmUgbnVtYmVyOjwvbGFiZWw+XFxuICAgIDxpbnB1dCB0eXBlPVwidGVsXCIgaWQ9XCJwaG9uZVwiIG5hbWU9XCJwaG9uZVwiIC8+XFxuICAgIDxidXR0b24gaWQ9XCJwaG9uZS1zdWJtaXRcIiBvbkNsaWNrPVwicmV0dXJuIGZhbHNlO1wiPlNlbmQ8L2J1dHRvbj5cXG4gICAgPGRpdiBpZD1cInBob25lLWNoYXJnZXNcIj5BIHRleHQgbWVzc2FnZSB3aWxsIGJlIHNlbnQgdmlhIDxhIGhyZWY9XCJodHRwOi8vdHdpbGlvLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlR3aWxpbzwvYT4uIENoYXJnZXMgbWF5IGFwcGx5IHRvIHRoZSByZWNpcGllbnQuPC9kaXY+XFxuICA8L2Rpdj5cXG4nKTs1NTsgfSA7IGJ1Zi5wdXNoKCdcXG5cXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxwIGlkPVwic2hhcmUtZmFpbC1leHBsYW5hdGlvblwiPicsIGVzY2FwZSgoMSwgIHNoYXJlRmFpbHVyZS5tZXNzYWdlICkpLCAnPC9wPlxcblxcbicpOzM7IGlmIChzaGFyZUZhaWx1cmUuY29udGVudHMpIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGNsYXNzPVwic2hhcmUtZmFpbC1leGNlcnB0XCI+XFxuICAgIDxwcmUgY2xhc3M9XCJnZW5lcmF0ZWRDb2RlXCI+JywgZXNjYXBlKCg1LCAgc2hhcmVGYWlsdXJlLmNvbnRlbnRzICkpLCAnPC9wcmU+XFxuICA8L2Rpdj5cXG4nKTs3OyB9IDsgYnVmLnB1c2goJ1xcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGRpdiBjbGFzcz1cImdlbmVyYXRlZC1jb2RlLWNvbnRhaW5lclwiPlxcbiAgPHAgY2xhc3M9XCJnZW5lcmF0ZWRDb2RlTWVzc2FnZVwiPicsICgyLCAgbWVzc2FnZSApLCAnPC9wPlxcbiAgPHByZSBjbGFzcz1cImdlbmVyYXRlZENvZGVcIj4nLCBlc2NhcGUoKDMsICBjb2RlICkpLCAnPC9wcmU+XFxuPC9kaXY+XFxuXFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCcnKTsxOyB2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7IDsgYnVmLnB1c2goJ1xcblxcbicpOzM7IGlmIChkYXRhLm9rKSB7OyBidWYucHVzaCgnICA8ZGl2IGNsYXNzPVwiZmFyU2lkZVwiIHN0eWxlPVwicGFkZGluZzogMWV4IDNleCAwXCI+XFxuICAgIDxidXR0b24gaWQ9XCJvay1idXR0b25cIiBjbGFzcz1cInNlY29uZGFyeVwiPlxcbiAgICAgICcsIGVzY2FwZSgoNSwgIG1zZy5kaWFsb2dPSygpICkpLCAnXFxuICAgIDwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuJyk7ODsgfTsgYnVmLnB1c2goJ1xcbicpOzk7IGlmIChkYXRhLmNhbmNlbFRleHQpIHs7IGJ1Zi5wdXNoKCc8YnV0dG9uIGlkPVwiYWdhaW4tYnV0dG9uXCIgY2xhc3M9XCInLCBlc2NhcGUoKDksICBkYXRhLmNhbmNlbEJ1dHRvbkNsYXNzIHx8ICcnICkpLCAnXCI+XFxuICAgICcsIGVzY2FwZSgoMTAsICBkYXRhLmNhbmNlbFRleHQgKSksICdcXG48L2J1dHRvbj5cXG4nKTsxMjsgfTsgYnVmLnB1c2goJ1xcbicpOzEzOyBpZiAoZGF0YS5jb25maXJtVGV4dCkgezsgYnVmLnB1c2goJzxidXR0b24gaWQ9XCJjb25maXJtLWJ1dHRvblwiIGNsYXNzPVwibGF1bmNoXCIgc3R5bGU9XCJmbG9hdDogcmlnaHRcIj5cXG4gICAgJywgZXNjYXBlKCgxNCwgIGRhdGEuY29uZmlybVRleHQgKSksICdcXG48L2J1dHRvbj5cXG4nKTsxNjsgfTsgYnVmLnB1c2goJ1xcbicpOzE3OyBpZiAoZGF0YS5wcmV2aW91c0xldmVsKSB7OyBidWYucHVzaCgnICA8YnV0dG9uIGlkPVwiYmFjay1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiPlxcbiAgICAnLCBlc2NhcGUoKDE4LCAgbXNnLmJhY2tUb1ByZXZpb3VzTGV2ZWwoKSApKSwgJ1xcbiAgPC9idXR0b24+XFxuJyk7MjA7IH07IGJ1Zi5wdXNoKCdcXG4nKTsyMTsgaWYgKGRhdGEudHJ5QWdhaW4pIHs7IGJ1Zi5wdXNoKCcgICcpOzIxOyBpZiAoZGF0YS5pc0sxICYmICFkYXRhLmZyZWVQbGF5KSB7OyBidWYucHVzaCgnICAgIDxkaXYgaWQ9XCJhZ2Fpbi1idXR0b25cIiBjbGFzcz1cImxhdW5jaCBhcnJvdy1jb250YWluZXIgYXJyb3ctbGVmdFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XCJhcnJvdy1oZWFkXCI+PGltZyBzcmM9XCInLCBlc2NhcGUoKDIyLCAgZGF0YS5hc3NldFVybCgnbWVkaWEvdHJ5YWdhaW4tYXJyb3ctaGVhZC5wbmcnKSApKSwgJ1wiIGFsdD1cIkFycm93aGVhZFwiIHdpZHRoPVwiNjdcIiBoZWlnaHQ9XCIxMzBcIi8+PC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cImFycm93LXRleHRcIj4nLCBlc2NhcGUoKDIzLCAgZGF0YS50cnlBZ2FpbiApKSwgJzwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICcpOzI1OyB9IGVsc2UgezsgYnVmLnB1c2goJyAgICAnKTsyNTsgaWYgKGRhdGEuc2hvdWxkUHJvbXB0Rm9ySGludCkgezsgYnVmLnB1c2goJyAgICAgIDxidXR0b24gaWQ9XCJoaW50LXJlcXVlc3QtYnV0dG9uXCIgY2xhc3M9XCJsaWdodGJ1bGItYnV0dG9uXCI+XFxuICAgICAgICA8c3Bhbj4nICsgKGZ1bmN0aW9uKCl7dmFyIGJ1ZiA9IFtdO1xuIGJ1Zi5wdXNoKCc8c3ZnIHZlcnNpb249XCIxLjFcIlxcblx0IGlkPVwic3ZnMzAxM1wiIHhtbG5zOnNvZGlwb2RpPVwiaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGRcIiB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnJkZj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIiB4bWxuczppbmtzY2FwZT1cImh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGVcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCIgeG1sbnM6Y2M9XCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcIiBzb2RpcG9kaTpkb2NuYW1lPVwibGlnaHRfYnVsYl9mb250X2F3ZXNvbWUuc3ZnXCIgaW5rc2NhcGU6dmVyc2lvbj1cIjAuNDguMy4xIHI5ODg2XCJcXG5cdCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjQwcHhcIiBoZWlnaHQ9XCI0MHB4XCJcXG5cdCB2aWV3Qm94PVwiMCAwIDYxMiA3OTJcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNjEyIDc5MlwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XFxuPGcgaWQ9XCJidWxiXCI+XFxuICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNNDUzLjc3NSwzNTMuMTU2YzAsMjQuMDEyLTU3LjE4OSwxMjguOTQyLTYxLjQxNCwxMzIuMjY1Yy0xMi4zODQsOS43NDEtNDguNTE0LDE1LjMxOC04Mi44NjksMTYuNTE4XFxuICAgIGMtOC4zNjIsMC4yOTItMTYuNjE5LDAuMzI1LTI0LjQwMywwLjA5NmMtMjAuNzE2LTAuNjExLTM4LjA4MS0zLjA3OS00NS4xNTUtNy40NjRjLTYuODk2LTQuMjc0LTc0LjQ3Ny0xMTkuMjQtNzQuNDc3LTE0MS40MTVcXG4gICAgYzAtODkuMTk1LDY0LjU0Mi0xNjEuNTAyLDE0NC4xNTktMTYxLjUwMlM0NTMuNzc1LDI2My45NjEsNDUzLjc3NSwzNTMuMTU2elwiLz5cXG4gIDxnIGlkPVwiZzMwMTVcIiB0cmFuc2Zvcm09XCJtYXRyaXgoMSwwLDAsLTEsMzc5LjY2MTAyLDEyOTMuMDE2OSlcIj5cXG4gICAgPHBhdGggaWQ9XCJwYXRoMzAxN1wiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XCIwXCIgZmlsbD1cIiM1RDVENURcIiBkPVwiTTcuMzU3LDk4MC44NTdjMC0yLjk2LTEuMDgxLTUuNTIxLTMuMjQ0LTcuNjg0XFxuICAgICAgcy00LjcyNC0zLjI0NC03LjY4NC0zLjI0NHMtNS41MjEsMS4wODEtNy42ODQsMy4yNDRzLTMuMjQ0LDQuNzI0LTMuMjQ0LDcuNjg0YzAsMTAuNDczLTYuMTQ3LDE4LjU1Ni0xOC40NDIsMjQuMjQ4XFxuICAgICAgYy0xMi4yOTUsNS42OTItMjQuMzYyLDguNTM4LTM2LjIwMSw4LjUzOGMtMi45NiwwLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NFxcbiAgICAgIGMwLDIuOTYsMS4wODEsNS41MjEsMy4yNDQsNy42ODRzNC43MjQsMy4yNDQsNy42ODQsMy4yNDRjMTEuMzg0LDAsMjIuNzExLTEuODIxLDMzLjk4MS01LjQ2NHMyMS4xNzQtOS43OSwyOS43MTItMTguNDQyXFxuICAgICAgUzcuMzU3LDk5Mi42OTYsNy4zNTcsOTgwLjg1N3ogTTYyLDk4MC44NTdjMCwxNi4zOTMtMy45MjcsMzEuNjQ3LTExLjc4Miw0NS43NjNzLTE4LjEsMjUuNjcxLTMwLjczNywzNC42NjRcXG4gICAgICBzLTI2LjYzOCwxNi4wNTEtNDIuMDA3LDIxLjE3NHMtMzAuOTA3LDcuNjg0LTQ2LjYxNyw3LjY4NHMtMzEuMjQ5LTIuNTYxLTQ2LjYxNy03LjY4NHMtMjkuMzcxLTEyLjE4MS00Mi4wMDctMjEuMTc0XFxuICAgICAgYy0xMi42MzYtOC45OTMtMjIuODgyLTIwLjU0OC0zMC43MzctMzQuNjY0Yy03Ljg1NS0xNC4xMTYtMTEuNzgyLTI5LjM3MS0xMS43ODItNDUuNzYzYzAtMjIuOTk2LDcuNzQxLTQzLjQ4NywyMy4yMjMtNjEuNDczXFxuICAgICAgYzIuMjc3LTIuNTA0LDUuNzQ5LTYuMjYxLDEwLjQxNi0xMS4yN2M0LjY2Ny01LjAwOSw4LjE0LTguNzY2LDEwLjQxNi0xMS4yN2MyOS4xNDMtMzQuODM1LDQ1LjE5NC02OC43NTksNDguMTU0LTEwMS43NzJoNzcuODY2XFxuICAgICAgYzIuOTYsMzMuMDEzLDE5LjAxMSw2Ni45MzgsNDguMTU0LDEwMS43NzJjMi4yNzcsMi41MDQsNS43NDksNi4yNjEsMTAuNDE2LDExLjI3czguMTQsOC43NjYsMTAuNDE2LDExLjI3XFxuICAgICAgQzU0LjI1OSw5MzcuMzcsNjIsOTU3Ljg2Miw2Miw5ODAuODU3eiBNMTA1LjcxNCw5ODAuODU3YzAtMzUuMjktMTEuNzI1LTY1Ljc5OS0zNS4xNzYtOTEuNTI3XFxuICAgICAgYy0xMC4yNDYtMTEuMTU2LTE4LjcyNy0yMS4wNi0yNS40NDMtMjkuNzEycy0xMy40OS0xOS41MjMtMjAuMzItMzIuNjE1Yy02LjgzLTEzLjA5Mi0xMC43MDEtMjUuMzI5LTExLjYxMi0zNi43MTNcXG4gICAgICBjMTAuNzAxLTYuMzc1LDE2LjA1MS0xNS43MSwxNi4wNTEtMjguMDA0YzAtOC40MjQtMi44NDYtMTUuNzEtOC41MzgtMjEuODU3YzUuNjkyLTYuMTQ3LDguNTM4LTEzLjQzMyw4LjUzOC0yMS44NTdcXG4gICAgICBjMC0xMS44MzktNS4xMjMtMjEuMDYtMTUuMzY4LTI3LjY2M2MyLjk2LTUuMjM3LDQuNDQtMTAuNTg3LDQuNDQtMTYuMDUxYzAtMTAuNDczLTMuNTg2LTE4LjU1Ni0xMC43NTgtMjQuMjQ4XFxuICAgICAgcy0xNS45OTQtOC41MzgtMjYuNDY4LTguNTM4Yy00LjU1NC0xMC4wMTgtMTEuMzg0LTE3Ljk4Ny0yMC40OTEtMjMuOTA2Yy05LjEwNy01LjkyLTE5LjAxMS04Ljg3OS0yOS43MTItOC44NzlcXG4gICAgICBjLTEwLjcwMSwwLTIwLjYwNSwyLjk2LTI5LjcxMiw4Ljg3OWMtOS4xMDcsNS45Mi0xNS45MzgsMTMuODg4LTIwLjQ5MSwyMy45MDZjLTEwLjQ3MywwLTE5LjI5NiwyLjg0Ni0yNi40NjgsOC41MzhcXG4gICAgICBzLTEwLjc1OCwxMy43NzUtMTAuNzU4LDI0LjI0OGMwLDUuNDY0LDEuNDgsMTAuODE1LDQuNDQsMTYuMDUxYy0xMC4yNDYsNi42MDMtMTUuMzY4LDE1LjgyNC0xNS4zNjgsMjcuNjYzXFxuICAgICAgYzAsOC40MjQsMi44NDYsMTUuNzEsOC41MzgsMjEuODU3Yy01LjY5Miw2LjE0Ny04LjUzOCwxMy40MzMtOC41MzgsMjEuODU3YzAsMTIuMjk1LDUuMzUsMjEuNjI5LDE2LjA1MSwyOC4wMDRcXG4gICAgICBjLTAuOTExLDExLjM4NC00Ljc4MSwyMy42MjItMTEuNjEyLDM2LjcxM2MtNi44MywxMy4wOTEtMTMuNjA0LDIzLjk2My0yMC4zMiwzMi42MTVzLTE1LjE5OCwxOC41NTYtMjUuNDQzLDI5LjcxMlxcbiAgICAgIEMtMjMyLjI3NSw5MTUuMDU4LTI0NCw5NDUuNTY3LTI0NCw5ODAuODU3YzAsMjIuNTQsNS4wNjYsNDMuNTQ0LDE1LjE5OCw2My4wMWMxMC4xMzIsMTkuNDY3LDIzLjQ1MSwzNS42MzIsMzkuOTU4LDQ4LjQ5NlxcbiAgICAgIGMxNi41MDcsMTIuODY0LDM1LjE3NiwyMi45OTUsNTYuMDA5LDMwLjM5NXM0Mi4wNjQsMTEuMDk5LDYzLjY5MywxMS4wOTlzNDIuODYtMy43LDYzLjY5My0xMS4wOTlzMzkuNTAyLTE3LjUzMSw1Ni4wMDktMzAuMzk1XFxuICAgICAgYzE2LjUwNy0xMi44NjQsMjkuODI2LTI5LjAyOSwzOS45NTgtNDguNDk2QzEwMC42NDgsMTAyNC40MDEsMTA1LjcxNCwxMDAzLjM5NywxMDUuNzE0LDk4MC44NTd6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCI0NzMuNTgyXCIgeTE9XCIyMDguMVwiIHgyPVwiNTYwLjU3OFwiIHkyPVwiMTU5LjE2XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNNDczLjE0MSwyMDcuMzE1YzAsMCwxLjIyNS0xLjAwMywzLjM5Ni0yLjcxMWMxLjA4LTAuODY0LDIuNDAyLTEuODk0LDMuOTI1LTMuMDYzXFxuICAgICAgYzEuNTI1LTEuMTY3LDMuMjI3LTIuNTE0LDUuMTE3LTMuOTI3YzEuODg3LTEuNDE4LDMuOTMxLTIuOTU0LDYuMDkyLTQuNTc4YzIuMTU4LTEuNjMyLDQuNDYyLTMuMyw2LjgzMS01LjA1NVxcbiAgICAgIGMyLjM4Ni0xLjcyMyw0Ljg0My0zLjUxOSw3LjM3Mi01LjI4NWMyLjUxNS0xLjc5MSw1LjEwNC0zLjU1Miw3LjY3Ny01LjM0MWMyLjU3OC0xLjc3OCw1LjA2NS0zLjcyMSw3LjUwMy01LjY0OFxcbiAgICAgIGMxLjIyOC0wLjk0OCwyLjQzNi0xLjkwNywzLjY2NS0yLjc5MmMxLjIzMS0wLjg4MSwyLjQ3OC0xLjY5NSwzLjczNi0yLjQ0MmMyLjUyNy0xLjQ3Miw1LjEyLTIuNjI5LDcuNjU2LTMuNTg3XFxuICAgICAgYzIuNTI5LTAuOTcxLDQuOTk4LTEuNzUxLDcuMzMxLTIuMzc3YzQuNjU1LTEuMjY4LDguNzk3LTEuODU4LDExLjgxLTIuMDY5YzEuNTA0LTAuMTA5LDIuNzE4LTAuMTM4LDMuNTcyLTAuMTExXFxuICAgICAgYzAuODQzLDAuMDA3LDEuMzEzLDAuMDQ3LDEuMzEzLDAuMDQ3bDAuODgzLDEuNTY5YzAsMC0wLjIxLDAuNDIyLTAuNjQxLDEuMTQ2Yy0wLjQyLDAuNzQ0LTEuMDc1LDEuNzY2LTEuOTUsMi45OTVcXG4gICAgICBjLTEuNzQ1LDIuNDY1LTQuNCw1LjY5OC03LjksOS4wMTljLTEuNzQ2LDEuNjY5LTMuNjk0LDMuMzc0LTUuODM4LDUuMDMxYy0yLjEzNiwxLjY3MS00LjQ3MSwzLjI4NS03LjA0MSw0LjY4MVxcbiAgICAgIGMtMS4yOTEsMC42ODctMi42MzUsMS4zMzEtNC4wMjcsMS45MjVjLTEuMzk0LDAuNTkxLTIuODQxLDEuMTI2LTQuMjg5LDEuNjgzYy0yLjkxNCwxLjA4My01Ljg2NSwyLjItOC43MjMsMy40OFxcbiAgICAgIGMtMi44NjUsMS4yNy01LjcxMywyLjU2OC04LjU1LDMuNzg4Yy0yLjgyMywxLjI0NS01LjYzMywyLjQxMi04LjM0NSwzLjU1NmMtMi43MjksMS4xMTMtNS4zNTIsMi4yMTctNy44NjcsMy4yMTNcXG4gICAgICBjLTIuNTExLDEuMDA0LTQuODg1LDEuOTUzLTcuMDc2LDIuODNjLTIuMTg5LDAuODgxLTQuMjI0LDEuNjM3LTYuMDEzLDIuMzM0Yy0xLjc5LDAuNjk1LTMuMzU3LDEuMjktNC42NTYsMS43NjRcXG4gICAgICBjLTIuNTg3LDAuOTY4LTQuMDgsMS40OTQtNC4wOCwxLjQ5NEw0NzMuMTQxLDIwNy4zMTV6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCI0OTIuMzQ4XCIgeTE9XCI0MTAuMDA4XCIgeDI9XCI1ODkuNTA5XCIgeTI9XCI0MzIuODgzXCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNNDkyLjU1NSw0MDkuMTMyYzAsMCwxLjU4MSwwLjA5MSw0LjMzNSwwLjMwM2MxLjM4LDAuMDk1LDMuMDUsMC4yMzIsNC45NjIsMC40MDNcXG4gICAgICBjMS45MTIsMC4xNzMsNC4wNzcsMC4zMzQsNi40MjQsMC41NzRjMi4zNDgsMC4yMzQsNC44OTIsMC40ODcsNy41ODMsMC43NTVjMi42OTMsMC4yNTksNS41MTksMC41OTIsOC40NSwwLjkwNFxcbiAgICAgIGMyLjkyMywwLjM0Nyw1Ljk0NywwLjY4OCw5LjAwNCwxLjEwMWMzLjA2NCwwLjM4NCw2LjE2MSwwLjg0MSw5LjI2NiwxLjI2NmMzLjEwMiwwLjQzNyw2LjI0NywwLjY5MSw5LjM0NiwwLjkyMlxcbiAgICAgIGMxLjU0NiwwLjEzMywzLjA4NCwwLjI0Niw0LjU4OCwwLjQyNmMxLjUwMiwwLjE4NSwyLjk3MiwwLjQzLDQuNDAzLDAuNzMyYzIuODU3LDAuNjI4LDUuNTQ4LDEuNTMxLDguMDY0LDIuNTQzXFxuICAgICAgYzIuNTE5LDAuOTk4LDQuODY0LDIuMDk1LDcuMDA0LDMuMjEzYzQuMjg1LDIuMjE5LDcuNzMyLDQuNTg4LDEwLjA5Myw2LjQ3MmMxLjE4MSwwLjkzOCwyLjA5NCwxLjczOCwyLjcwNCwyLjMzN1xcbiAgICAgIGMwLjYxNSwwLjU3NiwwLjkzNCwwLjkyMywwLjkzNCwwLjkyM2wtMC40MTIsMS43NTJjMCwwLTAuNDQsMC4xNjktMS4yNDgsMC40MWMtMC44MTMsMC4yNjMtMS45ODcsMC41NzItMy40NjMsMC44ODVcXG4gICAgICBjLTIuOTUzLDAuNjMzLTcuMDk2LDEuMjE2LTExLjkyLDEuMjljLTIuNDE0LDAuMDQ2LTUuMDAzLTAuMDE4LTcuNzAyLTAuMjQ5Yy0yLjcwMy0wLjIxNi01LjUxNS0wLjYwOS04LjM1MS0xLjMyMlxcbiAgICAgIGMtMS40MTUtMC4zNjgtMi44NC0wLjgwNC00LjI2Ny0xLjMwOWMtMS40MjYtMC41MDktMi44NTMtMS4wOTUtNC4yOTYtMS42NjVjLTIuODc4LTEuMTc2LTUuODA1LTIuMzUxLTguNzc2LTMuMzQ0XFxuICAgICAgYy0yLjk2OC0xLjAwNC01Ljk0NC0xLjk3Ny04Ljg1Ny0zYy0yLjkyLTAuOTk1LTUuNzc5LTIuMDM4LTguNTQ5LTMuMDMyYy0yLjc2Mi0xLjAyOS01LjQ0LTEuOTkyLTcuOTY1LTIuOTYxXFxuICAgICAgYy0yLjUyOC0wLjk2MS00LjkxOC0xLjg2OS03LjEyNC0yLjcwOGMtMi4yMDctMC44MzMtNC4yMTctMS42NTUtNi4wMDUtMi4zNTNjLTEuNzg4LTAuNy0zLjM0NC0xLjMyMy00LjYyMS0xLjg1NFxcbiAgICAgIGMtMi41NTktMS4wMzktNC4wMTUtMS42NjMtNC4wMTUtMS42NjNMNDkyLjU1NSw0MDkuMTMyelwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiNTAyLjU1OVwiIHkxPVwiMzAxLjdcIiB4Mj1cIjYwMi4zN1wiIHkyPVwiMzAwLjY4NVwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTUwMi41NSwzMDAuOGMwLDAsMS41NTctMC4yODksNC4yODItMC43NDJjMS4zNjItMC4yMzcsMy4wMTctMC41MDQsNC45MTUtMC43OTVcXG4gICAgICBjMS44OTgtMC4yODksNC4wMzktMC42NSw2LjM3NS0wLjk3OWMyLjMzNi0wLjMzNCw0Ljg2Ny0wLjY5Nyw3LjU0NC0xLjA4YzIuNjc3LTAuMzkyLDUuNS0wLjc0NCw4LjQyMS0xLjE0MlxcbiAgICAgIGMyLjkyMS0wLjM2Miw1LjkzOS0wLjc1Myw5LjAwNi0xLjA4NGMzLjA2Ny0wLjM1OSw2LjE4My0wLjY1Niw5LjMtMC45ODVjMy4xMTYtMC4zMTcsNi4yMy0wLjgyMyw5LjI5Ni0xLjMzOVxcbiAgICAgIGMxLjUzMy0wLjI0LDMuMDUzLTAuNDk5LDQuNTU2LTAuNjgzYzEuNTAzLTAuMTgsMi45ODktMC4yOTMsNC40NS0wLjM0MmMyLjkyNC0wLjA3Myw1Ljc1MywwLjE2LDguNDM4LDAuNTQyXFxuICAgICAgYzIuNjg1LDAuMzY2LDUuMjI0LDAuODcxLDcuNTcsMS40NDZjNC42OTEsMS4xMyw4LjYwNSwyLjYwNywxMS4zNDcsMy44NzJjMS4zNzEsMC42MjksMi40NDksMS4xODcsMy4xODUsMS42MjJcXG4gICAgICBjMC43MzUsMC40MTIsMS4xMjgsMC42NzMsMS4xMjgsMC42NzNsMC4wMTgsMS44YzAsMC0wLjM4NywwLjI2OS0xLjExNCwwLjY5NmMtMC43MjcsMC40NS0xLjc5MywxLjAzMS0zLjE1MSwxLjY4N1xcbiAgICAgIGMtMi43MTYsMS4zMjEtNi42LDIuODc3LTExLjI2Niw0LjEwMmMtMi4zMzMsMC42MjItNC44NjIsMS4xNzktNy41MzksMS41OTljLTIuNjc2LDAuNDM2LTUuNSwwLjcyNy04LjQyNSwwLjcxM1xcbiAgICAgIGMtMS40NjItMC4wMTktMi45NS0wLjEwMi00LjQ1Ni0wLjI1MWMtMS41MDYtMC4xNTMtMy4wMzItMC4zODEtNC41NjktMC41OWMtMy4wNzUtMC40NTQtNi4xOTktMC44OTUtOS4zMjEtMS4xNDlcXG4gICAgICBjLTMuMTIyLTAuMjY2LTYuMjQ0LTAuNDk5LTkuMzE4LTAuNzk2Yy0zLjA3My0wLjI2OC02LjA5OS0wLjU5OC05LjAyNi0wLjljLTIuOTI4LTAuMzM4LTUuNzU4LTAuNjM0LTguNDQyLTAuOTcxXFxuICAgICAgYy0yLjY4NC0wLjMyOS01LjIyMi0wLjYzOS03LjU2NC0wLjkyNmMtMi4zNDItMC4yODEtNC40OS0wLjU5OS02LjM5NC0wLjg0OWMtMS45MDMtMC4yNTMtMy41NjMtMC40ODYtNC45My0wLjY5NVxcbiAgICAgIGMtMi43MzQtMC4zOTctNC4yOTYtMC42NTUtNC4yOTYtMC42NTVMNTAyLjU1LDMwMC44elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTM1LjY2MVwiIHkxPVwiMjEyLjc2NFwiIHgyPVwiNDguNjY1XCIgeTI9XCIxNjMuODI0XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTM1LjIyLDIxMy41NDhjMCwwLTEuNDkzLTAuNTI2LTQuMDgtMS40OTRjLTEuMjk5LTAuNDc0LTIuODY2LTEuMDY5LTQuNjU2LTEuNzY0XFxuICAgICAgYy0xLjc4OS0wLjY5Ny0zLjgyNC0xLjQ1My02LjAxMy0yLjMzNGMtMi4xOTEtMC44NzYtNC41NjUtMS44MjYtNy4wNzYtMi44M2MtMi41MTUtMC45OTYtNS4xMzgtMi4xLTcuODY3LTMuMjEzXFxuICAgICAgYy0yLjcxMi0xLjE0NC01LjUyMi0yLjMxMi04LjM0NS0zLjU1NmMtMi44MzctMS4yMi01LjY4Ni0yLjUxOC04LjU1LTMuNzg4Yy0yLjg1OS0xLjI4LTUuODEtMi4zOTctOC43MjMtMy40OFxcbiAgICAgIGMtMS40NDgtMC41NTctMi44OTUtMS4wOTItNC4yODktMS42ODNjLTEuMzkyLTAuNTk0LTIuNzM2LTEuMjM4LTQuMDI3LTEuOTI1Yy0yLjU3LTEuMzk2LTQuOTA1LTMuMDEtNy4wNDEtNC42ODFcXG4gICAgICBjLTIuMTQzLTEuNjU3LTQuMDkyLTMuMzYzLTUuODM4LTUuMDMxYy0zLjUtMy4zMi02LjE1NS02LjU1NC03LjktOS4wMTljLTAuODc0LTEuMjI5LTEuNTMtMi4yNTEtMS45NS0yLjk5NVxcbiAgICAgIGMtMC40MzEtMC43MjQtMC42NDEtMS4xNDYtMC42NDEtMS4xNDZsMC44ODMtMS41NjljMCwwLDAuNDctMC4wNCwxLjMxMy0wLjA0N2MwLjg1NC0wLjAyNywyLjA2OCwwLjAwMiwzLjU3MiwwLjExMVxcbiAgICAgIGMzLjAxMywwLjIxMSw3LjE1NSwwLjgwMSwxMS44MSwyLjA2OWMyLjMzMiwwLjYyNSw0LjgwMSwxLjQwNiw3LjMzMSwyLjM3N2MyLjUzNywwLjk1OCw1LjEyOSwyLjExNSw3LjY1NiwzLjU4N1xcbiAgICAgIGMxLjI1OCwwLjc0NiwyLjUwNSwxLjU2MSwzLjczNiwyLjQ0MmMxLjIyOSwwLjg4NSwyLjQzNywxLjg0NCwzLjY2NSwyLjc5MmMyLjQzOCwxLjkyOCw0LjkyNSwzLjg3LDcuNTAzLDUuNjQ4XFxuICAgICAgYzIuNTczLDEuNzg5LDUuMTYxLDMuNTQ5LDcuNjc3LDUuMzQxYzIuNTI5LDEuNzY2LDQuOTg2LDMuNTYyLDcuMzcyLDUuMjg1YzIuMzY4LDEuNzU1LDQuNjczLDMuNDIzLDYuODMxLDUuMDU1XFxuICAgICAgYzIuMTYyLDEuNjI1LDQuMjA2LDMuMTYsNi4wOTIsNC41NzhjMS44ODksMS40MTMsMy41OTIsMi43Niw1LjExNywzLjkyN2MxLjUyMywxLjE2OSwyLjg0NSwyLjE5OSwzLjkyNSwzLjA2M1xcbiAgICAgIGMyLjE3LDEuNzA4LDMuMzk2LDIuNzExLDMuMzk2LDIuNzExTDEzNS4yMiwyMTMuNTQ4elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTIwLjg5NVwiIHkxPVwiNDExLjY3MlwiIHgyPVwiMjMuNzM0XCIgeTI9XCI0MzQuNTQ3XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTIxLjEwMSw0MTIuNTQ4YzAsMC0xLjQ1NiwwLjYyMy00LjAxNSwxLjY2M2MtMS4yNzcsMC41My0yLjgzMywxLjE1My00LjYyMSwxLjg1NFxcbiAgICAgIGMtMS43ODgsMC42OTgtMy43OTgsMS41Mi02LjAwNSwyLjM1M2MtMi4yMDYsMC44MzgtNC41OTYsMS43NDctNy4xMjQsMi43MDhjLTIuNTI2LDAuOTY5LTUuMjAzLDEuOTMyLTcuOTY1LDIuOTYxXFxuICAgICAgYy0yLjc3LDAuOTkzLTUuNjI5LDIuMDM3LTguNTQ5LDMuMDMyYy0yLjkxNCwxLjAyMy01Ljg4OSwxLjk5Ni04Ljg1NywzYy0yLjk3MSwwLjk5My01Ljg5OSwyLjE2OS04Ljc3NiwzLjM0NFxcbiAgICAgIGMtMS40NDMsMC41Ny0yLjg3LDEuMTU2LTQuMjk2LDEuNjY1Yy0xLjQyNywwLjUwNS0yLjg1MiwwLjk0MS00LjI2NywxLjMwOWMtMi44MzYsMC43MTMtNS42NDgsMS4xMDUtOC4zNTEsMS4zMjFcXG4gICAgICBjLTIuNjk5LDAuMjMxLTUuMjg4LDAuMjk1LTcuNzAyLDAuMjQ5Yy00LjgyNC0wLjA3NC04Ljk2Ny0wLjY1Ny0xMS45Mi0xLjI5Yy0xLjQ3Ni0wLjMxMy0yLjY1LTAuNjIxLTMuNDYzLTAuODg1XFxuICAgICAgYy0wLjgwOC0wLjI0MS0xLjI0OC0wLjQxLTEuMjQ4LTAuNDFsLTAuNDEzLTEuNzUyYzAsMCwwLjMxOS0wLjM0NywwLjkzNC0wLjkyM2MwLjYxLTAuNTk4LDEuNTIzLTEuMzk5LDIuNzA0LTIuMzM3XFxuICAgICAgYzIuMzYtMS44ODQsNS44MDgtNC4yNTQsMTAuMDkzLTYuNDcyYzIuMTQtMS4xMTksNC40ODUtMi4yMTYsNy4wMDQtMy4yMTNjMi41MTYtMS4wMTIsNS4yMDctMS45MTUsOC4wNjQtMi41NDNcXG4gICAgICBjMS40MzEtMC4zMDIsMi45LTAuNTQ3LDQuNDAzLTAuNzMyYzEuNTAzLTAuMTgxLDMuMDQyLTAuMjkzLDQuNTg4LTAuNDI2YzMuMS0wLjIzMiw2LjI0NS0wLjQ4Niw5LjM0Ni0wLjkyMlxcbiAgICAgIGMzLjEwNC0wLjQyNSw2LjIwMS0wLjg4Miw5LjI2NS0xLjI2NmMzLjA1Ny0wLjQxMiw2LjA4MS0wLjc1NCw5LjAwNC0xLjEwMWMyLjkzMS0wLjMxMiw1Ljc1Ny0wLjY0NCw4LjQ1LTAuOTA0XFxuICAgICAgYzIuNjkxLTAuMjY4LDUuMjM1LTAuNTIxLDcuNTgzLTAuNzU1YzIuMzQ3LTAuMjM5LDQuNTEyLTAuNCw2LjQyNC0wLjU3NGMxLjkxMy0wLjE3MSwzLjU4My0wLjMwOCw0Ljk2Mi0wLjQwM1xcbiAgICAgIGMyLjc1NC0wLjIxMiw0LjMzNS0wLjMwMyw0LjMzNS0wLjMwM0wxMjEuMTAxLDQxMi41NDh6XCIvPlxcbiAgPC9nPlxcbiAgPGc+XFxuICAgIDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMTIuNjg0XCIgeTE9XCIzMDYuMzY0XCIgeDI9XCIxMi44NzNcIiB5Mj1cIjMwNS4zNDlcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMTIuNjc1LDMwNy4yNjRjMCwwLTEuNTYyLDAuMjU3LTQuMjk2LDAuNjU1Yy0xLjM2NywwLjIxLTMuMDI2LDAuNDQzLTQuOTMsMC42OTVcXG4gICAgICBjLTEuOTA0LDAuMjUtNC4wNTEsMC41NjgtNi4zOTQsMC44NDljLTIuMzQzLDAuMjg3LTQuODgsMC41OTgtNy41NjQsMC45MjZjLTIuNjg0LDAuMzM3LTUuNTE0LDAuNjMzLTguNDQyLDAuOTcxXFxuICAgICAgYy0yLjkyOCwwLjMwMi01Ljk1MywwLjYzMi05LjAyNiwwLjljLTMuMDc0LDAuMjk3LTYuMTk1LDAuNTMtOS4zMTgsMC43OTZjLTMuMTIyLDAuMjU0LTYuMjQ2LDAuNjk2LTkuMzIxLDEuMTQ5XFxuICAgICAgYy0xLjUzNywwLjIwOS0zLjA2MywwLjQzNy00LjU2OSwwLjU5Yy0xLjUwNiwwLjE0OS0yLjk5NCwwLjIzMi00LjQ1NiwwLjI1MWMtMi45MjUsMC4wMTQtNS43NDktMC4yNzctOC40MjUtMC43MTNcXG4gICAgICBjLTIuNjc2LTAuNDIxLTUuMjA1LTAuOTc3LTcuNTM5LTEuNTk5Yy00LjY2Ny0xLjIyNS04LjU1LTIuNzgxLTExLjI2Ni00LjEwMmMtMS4zNTgtMC42NTYtMi40MjQtMS4yMzctMy4xNTEtMS42ODdcXG4gICAgICBjLTAuNzI3LTAuNDI3LTEuMTE0LTAuNjk2LTEuMTE0LTAuNjk2bDAuMDE4LTEuOGMwLDAsMC4zOTMtMC4yNjEsMS4xMjgtMC42NzNjMC43MzYtMC40MzUsMS44MTQtMC45OTQsMy4xODUtMS42MjJcXG4gICAgICBjMi43NDItMS4yNjUsNi42NTctMi43NDIsMTEuMzQ3LTMuODcyYzIuMzQ1LTAuNTc1LDQuODg1LTEuMDc5LDcuNTctMS40NDZjMi42ODUtMC4zODIsNS41MTQtMC42MTUsOC40MzgtMC41NDJcXG4gICAgICBjMS40NjIsMC4wNDksMi45NDcsMC4xNjIsNC40NSwwLjM0MmMxLjUwMywwLjE4NCwzLjAyNCwwLjQ0Myw0LjU1NiwwLjY4M2MzLjA2NSwwLjUxNiw2LjE4LDEuMDIxLDkuMjk2LDEuMzM5XFxuICAgICAgYzMuMTE2LDAuMzI5LDYuMjMyLDAuNjI2LDkuMjk5LDAuOTg1YzMuMDY3LDAuMzMsNi4wODUsMC43MjIsOS4wMDYsMS4wODRjMi45MiwwLjM5OCw1Ljc0NCwwLjc1LDguNDIxLDEuMTQyXFxuICAgICAgYzIuNjc3LDAuMzgzLDUuMjA4LDAuNzQ1LDcuNTQ0LDEuMDhjMi4zMzYsMC4zMjksNC40NzcsMC42OSw2LjM3NSwwLjk3OWMxLjg5OCwwLjI5MSwzLjU1MiwwLjU1OCw0LjkxNSwwLjc5NVxcbiAgICAgIGMyLjcyNSwwLjQ1Myw0LjI4MiwwLjc0Miw0LjI4MiwwLjc0MkwxMTIuNjc1LDMwNy4yNjR6XCIvPlxcbiAgPC9nPlxcbjwvZz5cXG48ZyBpZD1cImNvdW50XCI+XFxuICA8dGV4dCB4PVwiNDAwXCIgeT1cIjcwMFwiIGlkPVwiaGludENvdW50XCI+PC90ZXh0PlxcbjwvZz5cXG48L3N2Zz5cXG4nKTtcbnJldHVybiBidWYuam9pbignJyk7fSkoKSArICc8L3NwYW4+XFxuICAgICAgICAnLCBlc2NhcGUoKDI3LCAgbXNnLmhpbnRSZXF1ZXN0KCkgKSksICdcXG4gICAgICA8L2J1dHRvbj5cXG4gICAgJyk7Mjk7IH0gOyBidWYucHVzaCgnXFxuICAgIDxidXR0b24gaWQ9XCJhZ2Fpbi1idXR0b25cIiBjbGFzcz1cImxhdW5jaFwiPlxcbiAgICAgICcsIGVzY2FwZSgoMzEsICBkYXRhLnRyeUFnYWluICkpLCAnXFxuICAgIDwvYnV0dG9uPlxcbiAgJyk7MzM7IH07IGJ1Zi5wdXNoKCcnKTszMzsgfTsgYnVmLnB1c2goJ1xcbicpOzM0OyBpZiAoZGF0YS5uZXh0TGV2ZWwpIHs7IGJ1Zi5wdXNoKCcgICcpOzM0OyBpZiAoZGF0YS5pc0sxICYmICFkYXRhLmZyZWVQbGF5KSB7OyBidWYucHVzaCgnICAgIDxkaXYgaWQ9XCJjb250aW51ZS1idXR0b25cIiBjbGFzcz1cImxhdW5jaCBhcnJvdy1jb250YWluZXIgYXJyb3ctcmlnaHRcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVwiYXJyb3ctaGVhZFwiPjxpbWcgc3JjPVwiJywgZXNjYXBlKCgzNSwgIGRhdGEuYXNzZXRVcmwoJ21lZGlhL25leHQtYXJyb3ctaGVhZC5wbmcnKSApKSwgJ1wiIGFsdD1cIkFycm93aGVhZFwiIHdpZHRoPVwiNjZcIiBoZWlnaHQ9XCIxMzBcIi8+PC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cImFycm93LXRleHRcIj4nLCBlc2NhcGUoKDM2LCAgZGF0YS5jb250aW51ZVRleHQgKSksICc8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAnKTszODsgfSBlbHNlIHs7IGJ1Zi5wdXNoKCcgICAgPGJ1dHRvbiBpZD1cImNvbnRpbnVlLWJ1dHRvblwiIGNsYXNzPVwibGF1bmNoXCIgc3R5bGU9XCJmbG9hdDogcmlnaHRcIj5cXG4gICAgICAnLCBlc2NhcGUoKDM5LCAgZGF0YS5jb250aW51ZVRleHQgKSksICdcXG4gICAgPC9idXR0b24+XFxuICAnKTs0MTsgfTsgYnVmLnB1c2goJycpOzQxOyB9OyBidWYucHVzaCgnPGRpdiBjbGFzcz1cImFmdGVyLWZlZWRiYWNrLWJ1dHRvbnNcIi8+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBoZWxwZXIgY2xhc3MgZm9yIGFsbCBhY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCBQdXp6bGVcbiAqIFJhdGluZ3MsIGFrYSB0aGUgRnVuLU8tTWV0ZXIuXG4gKi9cblxudmFyIHB1enpsZVJhdGluZ1V0aWxzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gcHV6emxlUmF0aW5nVXRpbHM7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4vKipcbiAqIENvbnN0cnVjdCB0aGUgcHV6emxlIHJhdGluZyBidXR0b25zIHRoZW1zZWx2ZXNcbiAqXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZGl2IGNvbnRhaW5pbmcgcHV6emxlIHJhdG5nIGJ1dHRvbnMgd2l0aCBhdHRhY2hlZFxuICogICAgICAgICAgY2xpY2sgaGFuZGxlcnNcbiAqL1xucHV6emxlUmF0aW5nVXRpbHMuYnVpbGRQdXp6bGVSYXRpbmdCdXR0b25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbkNvbnRhaW5lci5pZCA9ICdwdXp6bGVSYXRpbmdCdXR0b25zJztcbiAgYnV0dG9uQ29udGFpbmVyLmlubmVySFRNTCA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3B1enpsZVJhdGluZy5odG1sLmVqcycpKCk7XG5cbiAgdmFyIGJ1dHRvbnMgPSBidXR0b25Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnB1enpsZS1yYXRpbmctYnRuJyk7XG4gIHZhciBidXR0b25DbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGJ1dHRvbjsgKGJ1dHRvbiA9IGJ1dHRvbnNbaV0pOyBpKyspIHtcbiAgICAgIGlmIChidXR0b24gIT0gdGhpcykge1xuICAgICAgICAkKGJ1dHRvbikucmVtb3ZlQ2xhc3MoJ2VuYWJsZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgJCh0aGlzKS50b2dnbGVDbGFzcygnZW5hYmxlZCcpO1xuICB9O1xuICBmb3IgKHZhciBpID0gMCwgYnV0dG9uOyAoYnV0dG9uID0gYnV0dG9uc1tpXSk7IGkrKykge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoYnV0dG9uLCBidXR0b25DbGlja0hhbmRsZXIpO1xuICB9XG5cbiAgcmV0dXJuIGJ1dHRvbkNvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHV6emxlUmF0aW5nXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjcmlwdF9pZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsX2lkXG4gKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IHJhdGluZyAtIGNhbiBiZSBhIG51bWJlciBvciBhblxuICogICAgICAgICAgIGludGVnZXItcGFyc2VhYmxlIHN0cmluZ1xuICovXG5cbi8qKlxuICogUHJpdmF0ZSBnZXR0ZXIvbG9jYWxTdG9yYWdlIHByb3h5XG4gKiBAcmV0dXJucyB7UHV6emxlUmF0aW5nW119IC0gcmF0aW5nc1xuICovXG5wdXp6bGVSYXRpbmdVdGlscy5nZXRQdXp6bGVSYXRpbmdzXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhdGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncHV6emxlUmF0aW5ncycpO1xuICB0cnkge1xuICAgIHJldHVybiByYXRpbmdzID8gSlNPTi5wYXJzZShyYXRpbmdzKSA6IFtdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqIFByaXZhdGUgc2V0dGVyL2xvY2FsU3RvcmFnZSBwcm94eVxuICogQHBhcmFtIHtQdXp6bGVSYXRpbmdbXX0gcmF0aW5nc1xuICovXG5wdXp6bGVSYXRpbmdVdGlscy5zZXRQdXp6bGVSYXRpbmdzXyA9IGZ1bmN0aW9uIChyYXRpbmdzKSB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwdXp6bGVSYXRpbmdzJywgSlNPTi5zdHJpbmdpZnkocmF0aW5ncykpO1xufTtcblxuLyoqXG4gKiBQcml2YXRlIGRlbGV0ZXIvbG9jYWxTdG9yYWdlIHByb3h5XG4gKiBAcGFyYW0ge1B1enpsZVJhdGluZ30gcmF0aW5nXG4gKi9cbnB1enpsZVJhdGluZ1V0aWxzLnJlbW92ZVB1enpsZVJhdGluZ18gPSBmdW5jdGlvbiAocmF0aW5nKSB7XG4gIHZhciByYXRpbmdzID0gcHV6emxlUmF0aW5nVXRpbHMuZ2V0UHV6emxlUmF0aW5nc18oKS5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIG90aGVyRXF1YWxzUmF0aW5nID0gKHJhdGluZy5sZXZlbF9pZCA9PT0gb3RoZXIubGV2ZWxfaWQgJiZcbiAgICAgIHJhdGluZy5zY3JpcHRfaWQgPT09IG90aGVyLnNjcmlwdF9pZCAmJlxuICAgICAgcmF0aW5nLnJhdGluZyA9PT0gb3RoZXIucmF0aW5nKTtcbiAgICByZXR1cm4gIW90aGVyRXF1YWxzUmF0aW5nO1xuICB9KTtcbiAgcHV6emxlUmF0aW5nVXRpbHMuc2V0UHV6emxlUmF0aW5nc18ocmF0aW5ncyk7XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSBzZWxlY3RlZCByYXRpbmcsIHRvIGJlIHN1Ym1pdHRlZCAocG9zc2libHkgd2l0aCBvdGhlclxuICogY2FjaGVkIHJhdGluZ3MpIGF0IHNvbWUgbGF0ZXIgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge2pRdWVyeX0gY29udGFpbmVyIC0gc29tZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGJ1dHRvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3RoZXIgZGF0YSB0byBiZSBzdWJtaXR0ZWQgYWxvbmcgd2l0aCB0aGVcbiAqICAgICAgICByYXRpbmcuIFVzdWFsbHkgc2NyaXB0X2lkIGFuZCBsZXZlbF9pZFxuICovXG5wdXp6bGVSYXRpbmdVdGlscy5jYWNoZVB1enpsZVJhdGluZyA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGVjdGVkQnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wdXp6bGUtcmF0aW5nLWJ0bi5lbmFibGVkJyk7XG4gIGlmIChzZWxlY3RlZEJ1dHRvbikge1xuICAgIHZhciByYXRpbmcgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywgeyByYXRpbmc6IHNlbGVjdGVkQnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIH0pO1xuICAgIHZhciByYXRpbmdzID0gcHV6emxlUmF0aW5nVXRpbHMuZ2V0UHV6emxlUmF0aW5nc18oKTtcbiAgICByYXRpbmdzLnB1c2gocmF0aW5nKTtcbiAgICBwdXp6bGVSYXRpbmdVdGlscy5zZXRQdXp6bGVSYXRpbmdzXyhyYXRpbmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQT1NUIHRoZSBjYWNoZWQgcmF0aW5ncyB0byB0aGUgZ2l2ZW4gVVJMIGFuZCBjbGVhciB0aGUgY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgXG4gKi9cbnB1enpsZVJhdGluZ1V0aWxzLnN1Ym1pdENhY2hlZFB1enpsZVJhdGluZ3MgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHZhciByYXRpbmdzID0gcHV6emxlUmF0aW5nVXRpbHMuZ2V0UHV6emxlUmF0aW5nc18oKTtcbiAgcmF0aW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChyYXRpbmcpIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB1cmwsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiByYXRpbmcsXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBwdXp6bGVSYXRpbmdVdGlscy5yZW1vdmVQdXp6bGVSYXRpbmdfKHJhdGluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPGhyPlxcbjxwPkRpZCB5b3UgbGlrZSB0aGlzIHB1enpsZT88L3A+XFxuXFxuPGEgY2xhc3M9XCJwdXp6bGUtcmF0aW5nLWJ0blwiIGlkPVwibGlrZVwiIGRhdGEtdmFsdWU9XCIxXCI+XFxuICA8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIlxcbiAgICAgIHdpZHRoPVwiMjdweFwiIGhlaWdodD1cIjI3cHhcIiB2aWV3Qm94PVwiMCAwIDI2LjA1NSAyMS4wNThcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMjYuMDU1IDIxLjA1OFwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCIgdmFsdWU9XCIxXCI+XFxuICAgIDxwYXRoIGQ9XCJNMTQuNDI2LDIuNWMwLjk4Ni0xLjM0OCwyLjgzLTIuNSw1LjA5Mi0yLjVjMy42MTMsMCw2LjUzNywzLjA0NCw2LjUzNyw2LjUzN1xcbiAgICAgICAgYzAsMi4zNTctMS4wNzYsMy43MDktMS44OTQsNC41MjVjLTAuOTQxLDAuOTQxLTguMDgyLDguMDgyLTkuMTEzLDkuMTEzYy0xLjI0NCwxLjI0My0zLjAxOSwxLjEzNy00LjI0Ni0wLjA5XFxuICAgICAgICBjLTEuMzE0LTEuMzE0LTcuMTU4LTcuMTU4LTkuMTMxLTkuMTMxQzAuNDA4LDkuNjkzLDAsOC4xMTMsMCw2LjUzN0MwLDIuOTI2LDMuMTk3LDAsNi41MzcsMGMyLjQ1MSwwLDQuNDM4LDEuNTA4LDUuMTg4LDIuNTM1XFxuICAgICAgICBDMTIuNCwzLjQ1OSwxMy42NDMsMy41NjQsMTQuNDI2LDIuNXpcIi8+XFxuICA8L3N2Zz5cXG48L2E+XFxuXFxuPGEgY2xhc3M9XCJwdXp6bGUtcmF0aW5nLWJ0blwiIGlkPVwiZGlzbGlrZVwiIGRhdGEtdmFsdWU9XCIwXCI+XFxuICA8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIlxcbiAgICAgIHdpZHRoPVwiMjdweFwiIGhlaWdodD1cIjI3cHhcIiB2aWV3Qm94PVwiMzgyLjMyMSAyOTIuODIgMjYuMzcgMjYuMzcxXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMzgyLjMyMSAyOTIuODIgMjYuMzcgMjYuMzcxXCJcXG4gICAgICB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbiAgICA8cGF0aCBkPVwiTTM5NS41MDYsMjkyLjgyYy03LjI4MiwwLjAwMi0xMy4xODQsNS45MDQtMTMuMTg1LDEzLjE4NWMwLjAwMSw3LjI4Myw1LjkwMiwxMy4xODQsMTMuMTg1LDEzLjE4NlxcbiAgICAgICAgYzcuMjgxLTAuMDAyLDEzLjE4My01LjkwMiwxMy4xODUtMTMuMTg2QzQwOC42ODksMjk4LjcyNSw0MDIuNzg3LDI5Mi44MjIsMzk1LjUwNiwyOTIuODJ6IE00MDIuNSwzMTNcXG4gICAgICAgIGMtMS43OTUsMS43OTMtNC4yNTcsMi44OTYtNi45OTQsMi44OThjLTIuNzM3LTAuMDAyLTUuMTk5LTEuMTA1LTYuOTk0LTIuODk4Yy0xLjc5NC0xLjc5NS0yLjg5Ny00LjI1OC0yLjg5Ny02Ljk5NFxcbiAgICAgICAgczEuMTAzLTUuMTk5LDIuODk3LTYuOTk0YzEuNzk1LTEuNzkzLDQuMjU3LTIuODk3LDYuOTk0LTIuODk3czUuMTk5LDEuMTA0LDYuOTk0LDIuODk3YzEuNzkyLDEuNzk1LDIuODk2LDQuMjU4LDIuODk2LDYuOTk0XFxuICAgICAgICBTNDA0LjI5MiwzMTEuMjA1LDQwMi41LDMxM3ogTTM5MS4zMTcsMzA0Ljk1MWMxLjA1NCwwLDEuOTA3LTAuODU0LDEuOTA3LTEuOTA2YzAtMS4wNTMtMC44NTQtMS45MDYtMS45MDctMS45MDZcXG4gICAgICAgIGMtMS4wNTQsMC0xLjkwNywwLjg1NC0xLjkwNywxLjkwNkMzODkuNDEsMzA0LjA5OCwzOTAuMjY0LDMwNC45NTEsMzkxLjMxNywzMDQuOTUxeiBNMzk5LjY5MSwzMDQuOTUxXFxuICAgICAgICBjMS4wNTMsMCwxLjkwNi0wLjg1NCwxLjkwNi0xLjkwNmMwLTEuMDUzLTAuODUzLTEuOTA2LTEuOTA2LTEuOTA2cy0xLjkwNywwLjg1NC0xLjkwNywxLjkwNlxcbiAgICAgICAgQzM5Ny43ODQsMzA0LjA5OCwzOTguNjM5LDMwNC45NTEsMzk5LjY5MSwzMDQuOTUxeiBNMzkxLjc3MywzMTEuOTI4YzEuMDM3LTEuMDM1LDIuMzc5LTEuNTQzLDMuNzM5LTEuNTQ1XFxuICAgICAgICBjMS4zNTIsMC4wMDIsMi42ODksMC41MTIsMy43MjQsMS41NDVjMC42NDIsMC42NDMsMS42ODUsMC42NDMsMi4zMjgsMGMwLjY0NS0wLjY0MywwLjY0NS0xLjY4NiwwLTIuMzNcXG4gICAgICAgIGMtMS42NjUtMS42NjYtMy44NjQtMi41MS02LjA1Mi0yLjUwOGgtMC4wMDhjLTIuMTg1LDAtNC4zOSwwLjgzOC02LjA2LDIuNTFjLTAuNjQyLDAuNjQzLTAuNjQzLDEuNjg2LDAsMi4zMjhcXG4gICAgICAgIEMzOTAuMDg4LDMxMi41NzEsMzkxLjEzMSwzMTIuNTcxLDM5MS43NzMsMzExLjkyOHpcIi8+XFxuICA8L3N2Zz5cXG48L2E+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgcGFyc2VYbWxFbGVtZW50ID0gcmVxdWlyZSgnLi94bWwnKS5wYXJzZUVsZW1lbnQ7XG5cbnZhciBUZXN0UmVzdWx0cyA9IGNvbnN0YW50cy5UZXN0UmVzdWx0cztcblxuLy8gVE9ETyAoYnItcGFpcik6IGNhbiB3ZSBub3QgcGFzcyBpbiB0aGUgc3R1ZGlvQXBwXG52YXIgRmVlZGJhY2tCbG9ja3MgPSBmdW5jdGlvbihvcHRpb25zLCBtaXNzaW5nUmVxdWlyZWRCbG9ja3MsIG1pc3NpbmdSZWNvbW1lbmRlZEJsb2Nrcywgc3R1ZGlvQXBwKSB7XG4gIC8vIENoZWNrIHdoZXRoZXIgYmxvY2tzIGFyZSBlbWJlZGRlZCBpbiB0aGUgaGludCByZXR1cm5lZCBmcm9tIGRhc2hib2FyZC5cbiAgLy8gU2VlIGJlbG93IGNvbW1lbnQgZm9yIGZvcm1hdC5cbiAgdmFyIGVtYmVkZGVkQmxvY2tzID0gb3B0aW9ucy5yZXNwb25zZSAmJiBvcHRpb25zLnJlc3BvbnNlLmhpbnQgJiZcbiAgICAgIG9wdGlvbnMucmVzcG9uc2UuaGludC5pbmRleE9mKFwiW3tcIikgIT09IDA7XG4gIGlmICghZW1iZWRkZWRCbG9ja3MgJiZcbiAgICAgIG9wdGlvbnMuZmVlZGJhY2tUeXBlICE9PSBUZXN0UmVzdWx0cy5NSVNTSU5HX0JMT0NLX1VORklOSVNIRUQgJiZcbiAgICAgIG9wdGlvbnMuZmVlZGJhY2tUeXBlICE9PSBUZXN0UmVzdWx0cy5NSVNTSU5HX0JMT0NLX0ZJTklTSEVEICYmXG4gICAgICBvcHRpb25zLmZlZWRiYWNrVHlwZSAhPT0gVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19VTkZJTklTSEVEICYmXG4gICAgICBvcHRpb25zLmZlZWRiYWNrVHlwZSAhPT0gVGVzdFJlc3VsdHMuTUlTU0lOR19SRUNPTU1FTkRFRF9CTE9DS19GSU5JU0hFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9ja3NUb0Rpc3BsYXkgPSBbXTtcbiAgaWYgKGVtYmVkZGVkQmxvY2tzKSB7XG4gICAgLy8gSGludCBzaG91bGQgYmUgb2YgdGhlIGZvcm06IFNPTUUgVEVYVCBbey4ufSwgey4ufSwgLi5dIElHTk9SRUQuXG4gICAgLy8gRXhhbXBsZTogJ1RyeSB0aGUgZm9sbG93aW5nIGJsb2NrOiBbe1widHlwZVwiOiBcIm1hemVfbW92ZUZvcndhcmRcIn1dJ1xuICAgIC8vIE5vdGUgdGhhdCBkb3VibGUgcXVvdGVzIGFyZSByZXF1aXJlZCBieSB0aGUgSlNPTiBwYXJzZXIuXG4gICAgdmFyIHBhcnRzID0gb3B0aW9ucy5yZXNwb25zZS5oaW50Lm1hdGNoKC8oLiopKFxcWy4qXFxdKS8pO1xuICAgIGlmICghcGFydHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5yZXNwb25zZS5oaW50ID0gcGFydHNbMV0udHJpbSgpOyAgLy8gUmVtb3ZlIGJsb2NrcyBmcm9tIGhpbnQuXG4gICAgdHJ5IHtcbiAgICAgIGJsb2Nrc1RvRGlzcGxheSA9IEpTT04ucGFyc2UocGFydHNbMl0pO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAvLyBUaGUgYmxvY2tzIGNvdWxkIG5vdCBiZSBwYXJzZWQuICBJZ25vcmUgdGhlbS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWlzc2luZ1JlcXVpcmVkQmxvY2tzLmJsb2Nrc1RvRGlzcGxheS5sZW5ndGgpIHtcbiAgICBoYW5kbGVNaXNzaW5nQmxvY2tzKG1pc3NpbmdSZXF1aXJlZEJsb2Nrcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlTWlzc2luZ0Jsb2NrcyhtaXNzaW5nUmVjb21tZW5kZWRCbG9ja3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWlzc2luZ0Jsb2NrcyhibG9ja3MpIHtcbiAgICBibG9ja3NUb0Rpc3BsYXkgPSBibG9ja3MuYmxvY2tzVG9EaXNwbGF5O1xuICAgIGlmIChibG9ja3MubWVzc2FnZSkge1xuICAgICAgb3B0aW9ucy5tZXNzYWdlID0gYmxvY2tzLm1lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJsb2Nrc1RvRGlzcGxheS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnhtbCA9IHRoaXMuZ2VuZXJhdGVYTUxGb3JCbG9ja3NfKGJsb2Nrc1RvRGlzcGxheSk7XG5cbiAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKCdpZCcsICdmZWVkYmFja0Jsb2NrcycpO1xuXG4gIC8vIFdpbGwgYmUgc2V0IGJ5IHRoaXMucmVuZGVyKClcbiAgdGhpcy5ibG9ja1NwYWNlRWRpdG9yID0gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWVkYmFja0Jsb2NrcztcblxuRmVlZGJhY2tCbG9ja3MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSByZW5kZXIgaWYgdGhpcy5kaXYgZXhpc3RzIGluIHRoZSBET01cbiAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuZGl2KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJzZWRYbWwgPSBwYXJzZVhtbEVsZW1lbnQodGhpcy54bWwpO1xuICB2YXIgYmxvY2tTcGFjZSA9IEJsb2NrbHkuQmxvY2tTcGFjZS5jcmVhdGVSZWFkT25seUJsb2NrU3BhY2UodGhpcy5kaXYsIHBhcnNlZFhtbCk7XG4gIHRoaXMuYmxvY2tTcGFjZUVkaXRvciA9IGJsb2NrU3BhY2UuYmxvY2tTcGFjZUVkaXRvcjtcbn07XG5cbkZlZWRiYWNrQmxvY2tzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9ICcnO1xuICBpZiAodGhpcy5ibG9ja1NwYWNlRWRpdG9yKSB7XG4gICAgdGhpcy5ibG9ja1NwYWNlRWRpdG9yLnN2Z1Jlc2l6ZSgpO1xuICB9XG59O1xuXG5GZWVkYmFja0Jsb2Nrcy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9ICcwcHgnO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYTUwgZm9yIGJsb2NrcyB0byBiZSBkaXNwbGF5ZWQgaW4gYSByZWFkLW9ubHkgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSBibG9ja3MgQW4gYXJyYXkgb2YgYmxvY2tzIHRvIGRpc3BsYXkgKHdpdGggb3B0aW9uYWwgYXJncykuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgc3RyaW5nIG9mIFhNTC5cbiAqL1xuRmVlZGJhY2tCbG9ja3MucHJvdG90eXBlLmdlbmVyYXRlWE1MRm9yQmxvY2tzXyA9IGZ1bmN0aW9uKGJsb2Nrcykge1xuICB2YXIgYmxvY2tYTUxTdHJpbmdzID0gWyc8eG1sPiddO1xuICB2YXIgYmxvY2tYID0gMTA7ICAvLyBQcmV2ZW50IGxlZnQgb3V0cHV0IHBsdWdzIGZyb20gYmVpbmcgY3V0IG9mZi5cbiAgdmFyIGJsb2NrWSA9IDA7XG4gIHZhciBibG9ja1hQYWRkaW5nID0gMjAwO1xuICB2YXIgYmxvY2tZUGFkZGluZyA9IDEyMDtcbiAgdmFyIGJsb2Nrc1BlckxpbmUgPSAyO1xuICB2YXIgaywgbmFtZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrLmJsb2NrRGlzcGxheVhNTCkge1xuICAgICAgYmxvY2tYTUxTdHJpbmdzLnB1c2goYmxvY2suYmxvY2tEaXNwbGF5WE1MKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBibG9ja1hNTFN0cmluZ3MucHVzaCgnPGJsb2NrJywgJyB0eXBlPVwiJywgYmxvY2sudHlwZSwgJ1wiIHg9XCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tYLnRvU3RyaW5nKCksICdcIiB5PVwiJywgYmxvY2tZLCAnXCI+Jyk7XG4gICAgaWYgKGJsb2NrLnRpdGxlcykge1xuICAgICAgdmFyIHRpdGxlTmFtZXMgPSBPYmplY3Qua2V5cyhibG9jay50aXRsZXMpO1xuICAgICAgZm9yIChrID0gMDsgayA8IHRpdGxlTmFtZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgbmFtZSA9IHRpdGxlTmFtZXNba107XG4gICAgICAgIGJsb2NrWE1MU3RyaW5ncy5wdXNoKCc8dGl0bGUgbmFtZT1cIicsIG5hbWUsICdcIj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnRpdGxlc1tuYW1lXSwgJzwvdGl0bGU+Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChibG9jay52YWx1ZXMpIHtcbiAgICAgIHZhciB2YWx1ZU5hbWVzID0gT2JqZWN0LmtleXMoYmxvY2sudmFsdWVzKTtcbiAgICAgIGZvciAoayA9IDA7IGsgPCB2YWx1ZU5hbWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIG5hbWUgPSB2YWx1ZU5hbWVzW2tdO1xuICAgICAgICBibG9ja1hNTFN0cmluZ3MucHVzaCgnPHZhbHVlIG5hbWU9XCInLCBuYW1lLCAnXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay52YWx1ZXNbbmFtZV0sICc8L3ZhbHVlPicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2suZXh0cmEpIHtcbiAgICAgIGJsb2NrWE1MU3RyaW5ncy5wdXNoKGJsb2NrLmV4dHJhKTtcbiAgICB9XG4gICAgYmxvY2tYTUxTdHJpbmdzLnB1c2goJzwvYmxvY2s+Jyk7XG4gICAgaWYgKChpICsgMSkgJSBibG9ja3NQZXJMaW5lID09PSAwKSB7XG4gICAgICBibG9ja1kgKz0gYmxvY2tZUGFkZGluZztcbiAgICAgIGJsb2NrWCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsb2NrWCArPSBibG9ja1hQYWRkaW5nO1xuICAgIH1cbiAgfVxuICBibG9ja1hNTFN0cmluZ3MucHVzaCgnPC94bWw+Jyk7XG4gIHJldHVybiBibG9ja1hNTFN0cmluZ3Muam9pbignJyk7XG59O1xuIiwiLyogZ2xvYmFsIGRhc2hib2FyZCAqL1xuLy8gVE9ETyhkYXZlKTogTWVyZ2Ugd2l0aCB0aGUgY2xpZW50IEFQSSBpbiAvc2hhcmVkLlxuLy8gVE9ETzogVGhlIGNsaWVudCBBUEkgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBjaGFubmVsIElELCBpbnN0ZWFkIG9mIGdyYWJiaW5nIGl0IGZyb20gdGhlIGBkYXNoYm9hcmQucHJvamVjdGAgZ2xvYmFsLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzZXRzOiBjbGllbnRBcGkoJ2Fzc2V0cycpLFxuICBzb3VyY2VzOiBjbGllbnRBcGkoJ3NvdXJjZXMnKVxufTtcblxuZnVuY3Rpb24gY2xpZW50QXBpKGVuZHBvaW50KSB7XG4gIHJldHVybiB7XG4gICAgYmFzZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gJy92My8nICsgZW5kcG9pbnQgKyAnLycgKyBkYXNoYm9hcmQucHJvamVjdC5nZXRDdXJyZW50SWQoKSArIChwYXRoID8gJy8nICsgcGF0aCA6ICcnKTtcbiAgICB9LFxuICAgIGFqYXg6IGZ1bmN0aW9uIChtZXRob2QsIGZpbGUsIHN1Y2Nlc3MsIGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoIXdpbmRvdy5kYXNoYm9hcmQpIHtcbiAgICAgICAgZXJyb3Ioe3N0YXR1czogXCJObyBkYXNoYm9hcmRcIn0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgZXJyb3IoeGhyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VjY2Vzcyh4aHIpO1xuICAgICAgfSk7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVycm9yKHhocik7XG4gICAgICB9KTtcblxuICAgICAgeGhyLm9wZW4obWV0aG9kLCB0aGlzLmJhc2VQYXRoKGZpbGUpLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfTtcbn1cbiIsInZhciB4bWwgPSByZXF1aXJlKCcuL3htbCcpO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgeG1sIGZvciBhIGxldmVsJ3MgdG9vbGJveFxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrcyBUaGUgeG1sIG9mIHRoZSBibG9ja3MgdG8gZ28gaW4gdGhlIHRvb2xib3hcbiAqL1xuZXhwb3J0cy5jcmVhdGVUb29sYm94ID0gZnVuY3Rpb24oYmxvY2tzKSB7XG4gIHJldHVybiAnPHhtbCBpZD1cInRvb2xib3hcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+JyArIGJsb2NrcyArICc8L3htbD4nO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHhtbCBmb3IgYSBibG9jayBvZiB0aGUgZ2l2ZW4gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGJsb2NrXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFt0aXRsZXNdIERpY3Rpb25hcnkgb2YgdGl0bGVzIG1hcHBpbmcgbmFtZSB0byB2YWx1ZVxuICovXG5leHBvcnRzLmJsb2NrT2ZUeXBlID0gZnVuY3Rpb24odHlwZSwgdGl0bGVzKSB7XG4gIHZhciB0aXRsZVRleHQgPSAnJztcbiAgaWYgKHRpdGxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiB0aXRsZXMpIHtcbiAgICAgIHRpdGxlVGV4dCArPSAnPHRpdGxlIG5hbWU9XCInICsga2V5ICsgJ1wiPicgKyB0aXRsZXNba2V5XSArICc8L3RpdGxlPic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnPGJsb2NrIHR5cGU9XCInICsgdHlwZSArICdcIj4nICsgdGl0bGVUZXh0ICsnPC9ibG9jaz4nO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHhtbCBmb3IgYSBibG9jayBvZiB0aGUgZ2l2ZW4gdHlwZSwgd2l0aCB0aGUgcHJvdmlkZWQgY2hpbGQgbmVzdGVkXG4gKiBpbiBhIG5leHQgYmxvY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBibG9ja1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBbdGl0bGVzXSBEaWN0aW9uYXJ5IG9mIHRpdGxlcyBtYXBwaW5nIG5hbWUgdG8gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZCBYbWwgZm9yIHRoZSBjaGlsZCBibG9ja1xuICovXG5leHBvcnRzLmJsb2NrV2l0aE5leHQgPSBmdW5jdGlvbiAodHlwZSwgdGl0bGVzLCBjaGlsZCkge1xuICB2YXIgdGl0bGVUZXh0ID0gJyc7XG4gIGlmICh0aXRsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGl0bGVzKSB7XG4gICAgICB0aXRsZVRleHQgKz0gJzx0aXRsZSBuYW1lPVwiJyArIGtleSArICdcIj4nICsgdGl0bGVzW2tleV0gKyAnPC90aXRsZT4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxibG9jayB0eXBlPVwiJyArIHR5cGUgKyAnXCI+JyArIHRpdGxlVGV4dCArICc8bmV4dD4nICsgY2hpbGQgKyAnPC9uZXh0PjwvYmxvY2s+Jztcbn07XG5cbi8qKlxuICogR2l2ZSBhIGxpc3Qgb2YgdHlwZXMsIHJldHVybnMgdGhlIHhtbCBhc3N1bWluZyBlYWNoIGJsb2NrIGlzIGEgY2hpbGQgb2ZcbiAqIHRoZSBwcmV2aW91cyBibG9jay5cbiAqL1xuZXhwb3J0cy5ibG9ja3NGcm9tTGlzdCA9IGZ1bmN0aW9uICh0eXBlcykge1xuICBpZiAodHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tPZlR5cGUodHlwZXNbMF0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYmxvY2tXaXRoTmV4dCh0eXBlc1swXSwge30sIHRoaXMuYmxvY2tzRnJvbUxpc3QodHlwZXMuc2xpY2UoMSkpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB4bWwgZm9yIGEgY2F0ZWdvcnkgaW4gYSB0b29sYm94XG4gKi9cbmV4cG9ydHMuY3JlYXRlQ2F0ZWdvcnkgPSBmdW5jdGlvbihuYW1lLCBibG9ja3MsIGN1c3RvbSkge1xuICByZXR1cm4gJzxjYXRlZ29yeSBuYW1lPVwiJyArIG5hbWUgKyAnXCInICtcbiAgICAgICAgICAoY3VzdG9tID8gJyBjdXN0b209XCInICsgY3VzdG9tICsgJ1wiJyA6ICcnKSArXG4gICAgICAgICAgJz4nICsgYmxvY2tzICsgJzwvY2F0ZWdvcnk+Jztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzaW1wbGUgYmxvY2sgd2l0aCBhIHBsYWluIHRpdGxlIGFuZCBuZXh0L3ByZXZpb3VzIGNvbm5lY3RvcnMuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVTaW1wbGVCbG9jayA9IGZ1bmN0aW9uIChibG9ja2x5LCBnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgWyduYW1lJywgJ3RpdGxlJywgJ3Rvb2x0aXAnLCAnZnVuY3Rpb25OYW1lJ10uZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBpZiAoIW9wdGlvbnNbcGFyYW1dKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlU2ltcGxlQmxvY2sgcmVxdWlyZXMgcGFyYW0gXCInICsgcGFyYW0gKyAnXCInKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICB2YXIgaGVscFVybCA9IG9wdGlvbnMuaGVscFVybCB8fCBcIlwiOyAvLyBvcHRpb25hbCBwYXJhbVxuICB2YXIgdGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICB2YXIgdGl0bGVJbWFnZSA9IG9wdGlvbnMudGl0bGVJbWFnZTtcbiAgdmFyIHRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXA7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBvcHRpb25zLmZ1bmN0aW9uTmFtZTtcblxuICBibG9ja2x5LkJsb2Nrc1tuYW1lXSA9IHtcbiAgICBoZWxwVXJsOiBoZWxwVXJsLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm90ZTogaGFzIGEgZml4ZWQgSFNWLiAgQ291bGQgbWFrZSB0aGlzIGN1c3RvbWl6YWJsZSBpZiBuZWVkIGJlXG4gICAgICB0aGlzLnNldEhTVigxODQsIDEuMDAsIDAuNzQpO1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5hcHBlbmREdW1teUlucHV0KCk7XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgaW5wdXQuYXBwZW5kVGl0bGUodGl0bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlSW1hZ2UpIHtcbiAgICAgICAgaW5wdXQuYXBwZW5kVGl0bGUobmV3IGJsb2NrbHkuRmllbGRJbWFnZSh0aXRsZUltYWdlKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFByZXZpb3VzU3RhdGVtZW50KHRydWUpO1xuICAgICAgdGhpcy5zZXROZXh0U3RhdGVtZW50KHRydWUpO1xuICAgICAgdGhpcy5zZXRUb29sdGlwKHRvb2x0aXApO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0b3JbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAvLyBHZW5lcmF0ZSBKYXZhU2NyaXB0IGZvciBwdXR0aW5nIGRpcnQgb24gdG8gYSB0aWxlLlxuICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyAnKFxcJ2Jsb2NrX2lkXycgKyB0aGlzLmlkICsgJ1xcJyk7XFxuJztcbiAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2luZ2xlIGJsb2NrIGZyb20gYSA8YmxvY2svPiBET00gZWxlbWVudCwgYWRkaW5nIGl0IHRvIHRoZSBtYWluIHdvcmtzcGFjZVxuICogQHBhcmFtIGJsb2NrRE9NIHtFbGVtZW50fVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuZG9tVG9CbG9jayA9IGZ1bmN0aW9uKGJsb2NrRE9NKSB7XG4gIHJldHVybiBCbG9ja2x5LlhtbC5kb21Ub0Jsb2NrKEJsb2NrbHkubWFpbkJsb2NrU3BhY2UsIGJsb2NrRE9NKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2luZ2xlIGJsb2NrIGZyb20gYSBibG9jayBYTUwgc3RyaW5n4oCUZS5nLiwgPGJsb2NrIHR5cGU9XCJ0ZXN0QmxvY2tcIj48L2Jsb2NrPixcbiAqIGFuZCBhZGRzIGl0IHRvIHRoZSBtYWluIHdvcmtzcGFjZVxuICogQHBhcmFtIGJsb2NrRE9NU3RyaW5nXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5kb21TdHJpbmdUb0Jsb2NrID0gZnVuY3Rpb24oYmxvY2tET01TdHJpbmcpIHtcbiAgcmV0dXJuIGV4cG9ydHMuZG9tVG9CbG9jayh4bWwucGFyc2VFbGVtZW50KGJsb2NrRE9NU3RyaW5nKS5maXJzdENoaWxkKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Ygc3RhcnQgYmxvY2tzLCBhbmQgcmV0dXJucyB0aGVtIHdpdGggYSBwYXJ0aWN1bGFyIHRvcCBsZXZlbFxuICogYmxvY2sgaW5zZXJ0ZWQgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IG5vbi1mdW5jdGlvbiBibG9jay4gIElmIHdlIGFscmVhZHkgaGF2ZVxuICogdGhpcyBibG9jaywgZG9lcyBub3RoaW5nLlxuICovXG5leHBvcnRzLmZvcmNlSW5zZXJ0VG9wQmxvY2sgPSBmdW5jdGlvbiAoaW5wdXQsIGJsb2NrVHlwZSkge1xuICBpbnB1dCA9IGlucHV0IHx8ICcnO1xuXG4gIGlmIChibG9ja1R5cGUgPT09IG51bGwgfHwgaW5wdXQuaW5kZXhPZihibG9ja1R5cGUpICE9PSAtMSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIHZhciByb290ID0geG1sLnBhcnNlRWxlbWVudChpbnB1dCk7XG5cbiAgLy8gRXh0cmFjdCB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgcm9vdC4gVGhlIHJlYXNvbiBJIGRvIHRoaXMgaW5zdGVhZCBvZiBqdXN0XG4gIC8vIHVzaW5nIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgZWxzZXdoZXJlIGlzXG4gIHZhciBkb2MgPSByb290LnBhcmVudE5vZGU7XG5cbiAgdmFyIHRvcEJsb2NrID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrJyk7XG4gIHRvcEJsb2NrLnNldEF0dHJpYnV0ZSgndHlwZScsIGJsb2NrVHlwZSk7XG4gIHRvcEJsb2NrLnNldEF0dHJpYnV0ZSgnbW92YWJsZScsICdmYWxzZScpO1xuICB0b3BCbG9jay5zZXRBdHRyaWJ1dGUoJ2RlbGV0YWJsZScsICdmYWxzZScpO1xuXG4gIHZhciBudW1DaGlsZHJlbiA9IHJvb3QuY2hpbGROb2RlcyA/IHJvb3QuY2hpbGROb2Rlcy5sZW5ndGggOiAwO1xuXG4gIC8vIGZpbmQgdGhlIGZpcnN0IG5vbi1mdW5jdGlvbiBkZWZpbml0aW9uIGJsb2NrIGFuZCBleHRyYWN0IGl0XG4gIHZhciBmaXJzdEJsb2NrID0gbnVsbCwgaSA9IDA7XG4gIHdoaWxlIChpIDwgbnVtQ2hpbGRyZW4gJiYgZmlyc3RCbG9jayA9PT0gbnVsbCkge1xuICAgIHZhciBjaGlsZCA9IHJvb3QuY2hpbGROb2Rlc1tpXTtcbiAgICAvLyBvbmx5IGxvb2sgYXQgZWxlbWVudCBub2Rlc1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgIGlmICh0eXBlICE9PSAncHJvY2VkdXJlc19kZWZub3JldHVybicgJiYgdHlwZSAhPT0gJ3Byb2NlZHVyZXNfZGVmcmV0dXJuJykge1xuICAgICAgICBmaXJzdEJsb2NrID0gcm9vdC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIG51bUNoaWxkcmVuLS07XG4gICAgICB9XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIGlmIChmaXJzdEJsb2NrICE9PSBudWxsKSB7XG4gICAgLy8gd2hlbiBydW4gLT4gbmV4dCAtPiBmaXJzdEJsb2NrXG4gICAgdmFyIG5leHQ7XG4gICAgaWYgKC9eZnVuY3Rpb25hbC8udGVzdChibG9ja1R5cGUpKSB7XG4gICAgICBuZXh0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2Z1bmN0aW9uYWxfaW5wdXQnKTtcbiAgICAgIG5leHQuc2V0QXR0cmlidXRlKCduYW1lJywgJ0FSRzEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCA9IGRvYy5jcmVhdGVFbGVtZW50KCduZXh0Jyk7XG4gICAgfVxuICAgIG5leHQuYXBwZW5kQ2hpbGQoZmlyc3RCbG9jayk7XG4gICAgdG9wQmxvY2suYXBwZW5kQ2hpbGQobmV4dCk7XG4gIH1cblxuICBpZiAobnVtQ2hpbGRyZW4gPiAwKSB7XG4gICAgcm9vdC5pbnNlcnRCZWZvcmUodG9wQmxvY2ssIHJvb3QuY2hpbGROb2Rlc1swXSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5hcHBlbmRDaGlsZCh0b3BCbG9jayk7XG4gIH1cbiAgcmV0dXJuIHhtbC5zZXJpYWxpemUocm9vdCk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB4bWwgZm9yIGEgYmxvY2sgZm9yIHRoZSBjYWxjIGFwcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgZm9yIHRoaXMgYmxvY2tcbiAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IGFyZ3MgTGlzdCBvZiBhcmdzLCB3aGVyZSBlYWNoIGFyZyBpcyBlaXRoZXIgdGhlXG4gKiAgIHhtbCBmb3IgYSBjaGlsZCBibG9jaywgYSBudW1iZXIsIG9yIHRoZSBuYW1lIG9mIGEgdmFyaWFibGUuXG4gKi9cbmV4cG9ydHMuY2FsY0Jsb2NrWG1sID0gZnVuY3Rpb24gKHR5cGUsIGFyZ3MpIHtcbiAgdmFyIHN0ciA9ICc8YmxvY2sgdHlwZT1cIicgKyB0eXBlICsgJ1wiIGlubGluZT1cImZhbHNlXCI+JztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHN0ciArPSAnPGZ1bmN0aW9uYWxfaW5wdXQgbmFtZT1cIkFSRycgKyBpICsgJ1wiPic7XG4gICAgdmFyIGFyZyA9IGFyZ3NbaSAtIDFdO1xuICAgIGlmICh0eXBlb2YoYXJnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYXJnID0gJzxibG9jayB0eXBlPVwiZnVuY3Rpb25hbF9tYXRoX251bWJlclwiPjx0aXRsZSBuYW1lPVwiTlVNXCI+JyArIGFyZyArXG4gICAgICAgICc8L3RpdGxlPjwvYmxvY2s+JztcbiAgICB9IGVsc2UgaWYgKC9ePGJsb2NrLy50ZXN0KGFyZykpIHtcbiAgICAgIC8vIHdlIGhhdmUgeG1sLCBkb250IG1ha2UgYW55IGNoYW5nZXNcbiAgICAgIGFyZyA9IGFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgdGhpbmsgd2UgaGF2ZSBhIHZhcmlhYmxlXG4gICAgICBhcmcgPSBleHBvcnRzLmNhbGNCbG9ja0dldFZhcihhcmcpO1xuICAgIH1cbiAgICBzdHIgKz0gYXJnO1xuICAgIHN0ciArPSAnPC9mdW5jdGlvbmFsX2lucHV0Pic7XG4gIH1cbiAgc3RyICs9ICc8L2Jsb2NrPic7XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdGhlIHhtbCBmb3IgYSBmdW5jdGlvbmFsX3BhcmFtZXRlcnNfZ2V0IGJsb2NrIHdpdGggdGhlIGdpdmVuXG4gKiAgIHZhcmlhYmxlTmFtZVxuICovXG5leHBvcnRzLmNhbGNCbG9ja0dldFZhciA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgcmV0dXJuICcnICtcbiAgICAnPGJsb2NrIHR5cGU9XCJmdW5jdGlvbmFsX3BhcmFtZXRlcnNfZ2V0XCIgdXNlcnZpc2libGU9XCJmYWxzZVwiPicgK1xuICAgICcgIDxtdXRhdGlvbj4nICtcbiAgICAnICAgIDxvdXRwdXR0eXBlPk51bWJlcjwvb3V0cHV0dHlwZT4nICtcbiAgICAnICA8L211dGF0aW9uPicgK1xuICAgICcgIDx0aXRsZSBuYW1lPVwiVkFSXCI+JyArIHZhcmlhYmxlTmFtZSArICc8L3RpdGxlPicgK1xuICAgICc8L2Jsb2NrPic7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB4bWwgZm9yIGEgbWF0aCBibG9jayAoZWl0aGVyIGNhbGMgb3IgZXZhbCBhcHBzKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgZm9yIHRoaXMgYmxvY2tcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nfSBpbnB1dHMgRGljdGlvbmFyeSBtYXBwaW5nIGlucHV0IG5hbWUgdG8gdGhlXG4gICAgIHhtbCBmb3IgdGhhdCBpbnB1dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZy5zdHJpbmc+fSBbdGl0bGVzXSBEaWN0aW9uYXJ5IG9mIHRpdGxlcyBtYXBwaW5nIG5hbWUgdG8gdmFsdWVcbiAqL1xuZXhwb3J0cy5tYXRoQmxvY2tYbWwgPSBmdW5jdGlvbiAodHlwZSwgaW5wdXRzLCB0aXRsZXMpIHtcbiAgdmFyIHN0ciA9ICc8YmxvY2sgdHlwZT1cIicgKyB0eXBlICsgJ1wiIGlubGluZT1cImZhbHNlXCI+JztcbiAgZm9yICh2YXIgdGl0bGUgaW4gdGl0bGVzKSB7XG4gICAgc3RyICs9ICc8dGl0bGUgbmFtZT1cIicgKyB0aXRsZSArICdcIj4nICsgdGl0bGVzW3RpdGxlXSArICc8L3RpdGxlPic7XG4gIH1cblxuICBmb3IgKHZhciBpbnB1dCBpbiBpbnB1dHMpIHtcbiAgICBzdHIgKz0gJzxmdW5jdGlvbmFsX2lucHV0IG5hbWU9XCInICsgaW5wdXQgKyAnXCI+JyArIGlucHV0c1tpbnB1dF0gKyAnPC9mdW5jdGlvbmFsX2lucHV0Pic7XG4gIH1cblxuICBzdHIgKz0gJzwvYmxvY2s+JztcblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB4bWwgZm9yIGEgZnVuY3Rpb25hbCBkZWZpbnRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG91dHB1dFR5cGUgRnVuY3Rpb24ncyBvdXRwdXQgdHlwZVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+W119IGFyZ0xpc3QgTmFtZSBhbmQgdHlwZSBmb3IgZWFjaCBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja1htbCBYbWwgZm9yIHRoZSBibG9ja3MgdGhhdCBhY3R1YWxseSBkZWZpbmUgdGhlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25hbERlZmluaXRpb25YbWwgPSBmdW5jdGlvbiAobmFtZSwgb3V0cHV0VHlwZSwgYXJnTGlzdCwgYmxvY2tYbWwpIHtcbiAgdmFyIG11dGF0aW9uID0gJzxtdXRhdGlvbj4nO1xuICBhcmdMaXN0LmZvckVhY2goZnVuY3Rpb24gKGFyZ0luZm8pIHtcbiAgICBtdXRhdGlvbiArPSAnPGFyZyBuYW1lPVwiJyArIGFyZ0luZm8ubmFtZSArICdcIiB0eXBlPVwiJyArIGFyZ0luZm8udHlwZSArICdcIj48L2FyZz4nO1xuICB9KTtcbiAgbXV0YXRpb24gKz0gJzxvdXRwdXR0eXBlPicgKyBvdXRwdXRUeXBlICsgJzwvb3V0cHV0dHlwZT48L211dGF0aW9uPic7XG5cbiAgcmV0dXJuICc8YmxvY2sgdHlwZT1cImZ1bmN0aW9uYWxfZGVmaW5pdGlvblwiIGlubGluZT1cImZhbHNlXCI+JytcbiAgICAgIG11dGF0aW9uICtcbiAgICAgICc8dGl0bGUgbmFtZT1cIk5BTUVcIj4nICsgbmFtZSArICc8L3RpdGxlPicgK1xuICAgICAnPGZ1bmN0aW9uYWxfaW5wdXQgbmFtZT1cIlNUQUNLXCI+JyArIGJsb2NrWG1sICsgJzwvZnVuY3Rpb25hbF9pbnB1dD4nICtcbiAgICAnPC9ibG9jaz4nO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB4bWwgZm9yIGEgY2FsbGluZyBhIGZ1bmN0aW9uYWwgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+W119IGFyZ0xpc3QgTmFtZSBhbmQgdHlwZSBmb3IgZWFjaCBhcmdcbiAqL1xuZXhwb3J0cy5mdW5jdGlvbmFsQ2FsbFhtbCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdMaXN0LCBpbnB1dENvbnRlbnRzKSB7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCAhPT0gaW5wdXRDb250ZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgZGVmaW5lIGNvbnRlbnRzIGZvciBlYWNoIGFyZycpO1xuICB9XG5cbiAgdmFyIG11dGF0aW9uID0gJzxtdXRhdGlvbiBuYW1lPVwiJyArIG5hbWUgKyAnXCI+JztcbiAgYXJnTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChhcmdJbmZvKSB7XG4gICAgbXV0YXRpb24gKz0gJzxhcmcgbmFtZT1cIicgKyBhcmdJbmZvLm5hbWUgKyAnXCIgdHlwZT1cIicgKyBhcmdJbmZvLnR5cGUgKyAnXCI+PC9hcmc+JztcbiAgfSk7XG4gIG11dGF0aW9uICs9ICc8L211dGF0aW9uPic7XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIGlucHV0Q29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2tYbWwsIGluZGV4KSB7XG4gICAgY29udGVudHMgKz0gJzxmdW5jdGlvbmFsX2lucHV0IG5hbWU9XCJBUkcnICsgaW5kZXggKyAnXCI+JyArIGJsb2NrWG1sICsgJzwvZnVuY3Rpb25hbF9pbnB1dD4nO1xuICB9KTtcblxuICByZXR1cm4gJzxibG9jayB0eXBlPVwiZnVuY3Rpb25hbF9jYWxsXCI+JyArXG4gICAgICBtdXRhdGlvbiArXG4gICAgICBjb250ZW50cyArXG4gICAgJzwvYmxvY2s+Jztcbn07XG4iLCJ2YXIgRHJvcGxldEZ1bmN0aW9uVG9vbHRpcCA9IHJlcXVpcmUoJy4vRHJvcGxldEZ1bmN0aW9uVG9vbHRpcCcpO1xudmFyIERyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyID0gcmVxdWlyZSgnLi9Ecm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlcicpO1xudmFyIERyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyID0gcmVxdWlyZSgnLi9Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlcicpO1xudmFyIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlciA9IHJlcXVpcmUoJy4vRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyJyk7XG52YXIgZHJvcGxldFV0aWxzID0gcmVxdWlyZSgnLi4vZHJvcGxldFV0aWxzJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBNYW5hZ2VzIGEgc3RvcmUgb2Yga25vd24gYmxvY2tzIGFuZCB0b29sdGlwc1xuICovXG5cbi8qKlxuICogU3RvcmUgZm9yIGZpbmRpbmcgdG9vbHRpcHMgZm9yIGJsb2Nrc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERyb3BsZXRUb29sdGlwTWFuYWdlcihhcHBNc2csIGRyb3BsZXRDb25maWcsIGNvZGVGdW5jdGlvbnMsIGF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSkge1xuICAvKipcbiAgICogQXBwLXNwZWNpZmljIHN0cmluZ3MgKHRvIG92ZXJyaWRlIGNvbW1vbiBtc2cpXG4gICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgRnVuY3Rpb24+fVxuICAgKi9cbiAgdGhpcy5hcHBNc2cgPSBhcHBNc2cgfHwge307XG4gIHRoaXMudG9vbHRpcHNFbmFibGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogRHJvcGxldCBjb25maWcgZm9yIHRoaXMgYXBwXG4gICAqL1xuICB0aGlzLmRyb3BsZXRDb25maWcgPSBkcm9wbGV0Q29uZmlnIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBDb2RlIGZ1bmN0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmc+fSBvcHRpb25hbCBvYmplY3Qgd2l0aCBrZXlzIHRvIG1vZGlmeSB0aGUgYmxvY2tzXG4gICAqL1xuICB0aGlzLmNvZGVGdW5jdGlvbnMgPSBjb2RlRnVuY3Rpb25zO1xuXG4gIC8qKlxuICAgKiBGbGFnIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgQVBJcyB0aGF0IHNlZSBhdXRvY29tcGxldGUgYmVoYXZpb3JcbiAgICovXG4gIHRoaXMuYXV0b2NvbXBsZXRlUGFsZXR0ZUFwaXNPbmx5ID0gYXV0b2NvbXBsZXRlUGFsZXR0ZUFwaXNPbmx5O1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYmxvY2sgdHlwZXMgdG8gdG9vbHRpcCBvYmplY3RzXG4gICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgRHJvcGxldEZ1bmN0aW9uVG9vbHRpcD59XG4gICAqL1xuICB0aGlzLmJsb2NrVHlwZVRvVG9vbHRpcF8gPSB7fTtcblxuICAvKipcbiAgICogTWFwcyBmdW5jIGZyb20gb25lIGJsb2NrIHR5cGUgdG8gYW5vdGhlciwgc3VjaCB0aGF0IHdlIHVzZSB0aGUgdGFyZ2V0IGZvclxuICAgKiBkb2N1bWVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHNvdXJjZVxuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59XG4gICAqL1xuICB0aGlzLmRvY0Z1bmNNYXBwaW5nXyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7RHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyXyA9IG5ldyBEcm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlcih0aGlzKTtcblxuICAvKipcbiAgICogQHR5cGUge0Ryb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kcm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlcl8gPSBuZXcgRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIodGhpcyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtEcm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyXyA9IG5ldyBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIodGhpcyk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBkcm9wbGV0IGJsb2NrIHRvb2x0aXBzLlxuICogQHBhcmFtIGRyb3BsZXRFZGl0b3JcbiAqL1xuRHJvcGxldFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlckRyb3BsZXRCbG9ja01vZGVIYW5kbGVycyA9IGZ1bmN0aW9uIChkcm9wbGV0RWRpdG9yKSB7XG4gIHRoaXMuZHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXJfLmluc3RhbGxUb29sdGlwc0ZvckVkaXRvcl8oZHJvcGxldEVkaXRvcik7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgQUNFIG1vZGUgdG9vbHRpcHNcbiAqIEBwYXJhbSBkcm9wbGV0RWRpdG9yXG4gKi9cbkRyb3BsZXRUb29sdGlwTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJEcm9wbGV0VGV4dE1vZGVIYW5kbGVycyA9IGZ1bmN0aW9uIChkcm9wbGV0RWRpdG9yKSB7XG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXJfLmluc3RhbGxUb29sdGlwc0ZvckVkaXRvcl8oZHJvcGxldEVkaXRvcik7XG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyXy5pbnN0YWxsVG9vbHRpcHNGb3JFZGl0b3JfKGRyb3BsZXRFZGl0b3IpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYmxvY2sgdG9vbHRpcHMgZm9yIGJsb2NrcyBiYXNlZCBvbiB0aGUgZHJvcGxldEJsb2NrcyBhbmRcbiAqIGNvZGVGdW5jdGlvbnMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICovXG5Ecm9wbGV0VG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmxvY2tzID0gZHJvcGxldFV0aWxzLmdldEFsbEF2YWlsYWJsZURyb3BsZXRCbG9ja3MoXG4gICAgdGhpcy5kcm9wbGV0Q29uZmlnLFxuICAgIHRoaXMuY29kZUZ1bmN0aW9ucyxcbiAgICB0aGlzLmF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSk7XG4gIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChkcm9wbGV0QmxvY2tEZWZpbml0aW9uKSB7XG4gICAgdmFyIGtleSA9IGRyb3BsZXRCbG9ja0RlZmluaXRpb24ubW9kZU9wdGlvbk5hbWUgfHwgZHJvcGxldEJsb2NrRGVmaW5pdGlvbi5mdW5jO1xuICAgIGlmIChkcm9wbGV0QmxvY2tEZWZpbml0aW9uLmRvY0Z1bmMpIHtcbiAgICAgIC8vIElmIGEgZG9jRnVuYyB3YXMgc3BlY2lmaWVkLCB1cGRhdGUgb3VyIG1hcHBpbmdcbiAgICAgIHRoaXMuZG9jRnVuY01hcHBpbmdfW2tleV0gPSBkcm9wbGV0QmxvY2tEZWZpbml0aW9uLmRvY0Z1bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxvY2tUeXBlVG9Ub29sdGlwX1trZXldID1cbiAgICAgICAgbmV3IERyb3BsZXRGdW5jdGlvblRvb2x0aXAodGhpcy5hcHBNc2csIGRyb3BsZXRCbG9ja0RlZmluaXRpb24pO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59O1xuXG5Ecm9wbGV0VG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmdldERvY0ZvciA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIGRvY0Z1bmNOYW1lID0gdGhpcy5kb2NGdW5jTWFwcGluZ19bZnVuY3Rpb25OYW1lXSB8fCBmdW5jdGlvbk5hbWU7XG4gIHJldHVybiB0aGlzLmJsb2NrVHlwZVRvVG9vbHRpcF9bZG9jRnVuY05hbWVdO1xufTtcblxuRHJvcGxldFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zaG93RG9jRm9yID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICBpZiAoIXRoaXMudG9vbHRpcHNFbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gICQoJy50b29sdGlwc3RlcmVkJykudG9vbHRpcHN0ZXIoJ2hpZGUnKTtcbiAgdmFyIGRpYWxvZyA9IG5ldyB3aW5kb3cuRGlhbG9nKHtcbiAgICBib2R5OiAkKCc8aWZyYW1lPicpXG4gICAgICAuYWRkQ2xhc3MoJ21hcmtkb3duLWluc3RydWN0aW9ucy1jb250YWluZXInKVxuICAgICAgLndpZHRoKCcxMDAlJylcbiAgICAgIC5hdHRyKCdzcmMnLCB0aGlzLmdldERyb3BsZXRUb29sdGlwKGZ1bmN0aW9uTmFtZSkuZ2V0RnVsbERvY3VtZW50YXRpb25VUkwoKSksXG4gICAgYXV0b1Jlc2l6ZVNjcm9sbGFibGVFbGVtZW50OiAnLm1hcmtkb3duLWluc3RydWN0aW9ucy1jb250YWluZXInLFxuICAgIGlkOiAnYmxvY2stZG9jdW1lbnRhdGlvbi1saWdodGJveCdcbiAgfSk7XG4gIGRpYWxvZy5zaG93KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm5zIHtEcm9wbGV0RnVuY3Rpb25Ub29sdGlwfVxuICovXG5Ecm9wbGV0VG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmdldERyb3BsZXRUb29sdGlwID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICB2YXIgdG9vbHRpcCA9IHRoaXMuZ2V0RG9jRm9yKGZ1bmN0aW9uTmFtZSk7XG4gIGlmICghdG9vbHRpcCkge1xuICAgIHRocm93IFwiRnVuY3Rpb24gbmFtZSBcIiArIGZ1bmN0aW9uTmFtZSArIFwiIG5vdCByZWdpc3RlcmVkIGluIGRvY3VtZW50YXRpb24gbWFuYWdlci5cIjtcbiAgfVxuXG4gIHJldHVybiB0b29sdGlwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgaWYgdG9vbHRpcHMgc2hvdWxkIGJlIGVuYWJsZWQuXG4gKi9cbkRyb3BsZXRUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuc2V0VG9vbHRpcHNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgdGhpcy50b29sdGlwc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIHRoaXMuZHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXJfLnNldFRvb2x0aXBzRW5hYmxlZChlbmFibGVkKTtcbiAgdGhpcy5kcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXJfLnNldFRvb2x0aXBzRW5hYmxlZChlbmFibGVkKTtcbiAgdGhpcy5kcm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlcl8uc2V0VG9vbHRpcHNFbmFibGVkKGVuYWJsZWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcm9wbGV0VG9vbHRpcE1hbmFnZXI7XG4iLCJ2YXIgRHJvcGxldEZ1bmN0aW9uVG9vbHRpcCA9IHJlcXVpcmUoJy4vRHJvcGxldEZ1bmN0aW9uVG9vbHRpcCcpO1xudmFyIERyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAgPSByZXF1aXJlKCcuL0Ryb3BsZXRGdW5jdGlvblRvb2x0aXAuaHRtbC5lanMnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9kb20nKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpc3BsYXlzIHRvb2x0aXBzIGZvciBEcm9wbGV0IGJsb2Nrc1xuICovXG5cbi8qKlxuICogSGFuZGxlcyBkaXNwbGF5aW5nIHRvb2x0aXBzIG9uIERyb3BsZXQgYmxvY2tzXG4gKiBAcGFyYW0ge0Ryb3BsZXRUb29sdGlwTWFuYWdlcn0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyID0gZnVuY3Rpb24gKGRyb3BsZXRUb29sdGlwTWFuYWdlcikge1xuICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlciA9IGRyb3BsZXRUb29sdGlwTWFuYWdlcjtcbiAgdGhpcy5zaG93RXhhbXBsZXNMaW5rID0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmRyb3BsZXRDb25maWcuc2hvd0V4YW1wbGVzTGluaztcbiAgdGhpcy50b29sdGlwc0VuYWJsZWQgPSB0cnVlO1xufTtcblxudmFyIERFRkFVTFRfVE9PTFRJUF9DT05GSUcgPSB7XG4gIGludGVyYWN0aXZlOiB0cnVlLFxuICBzcGVlZDogMTUwLFxuICBtYXhXaWR0aDogNDUwLFxuICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgY29udGVudEFzSFRNTDogdHJ1ZSxcbiAgdGhlbWU6ICdkcm9wbGV0LWJsb2NrLXRvb2x0aXBzdGVyJyxcbiAgb2Zmc2V0WTogMixcbiAgZGVsYXk6IDQwMFxufTtcblxuLyoqXG4gKiBTaW1wbGUgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBzd2FsbG93IGV4Y2VwdGlvbnMsIGFuZCBsb2cgdGhlbSBhc1xuICogY29uc29sZS5lcnJvci4gVGhpcyBpcyBkb25lIGJlY2F1c2UgdGhlIHdheSB0aGF0IHNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBhcmVcbiAqIGNhbGxlZCBieSBkcm9wbGV0LCBleGNlcHRpb25zIHdvdWxkIGJ1YmJsZSBkb3duIHRvIHRoZSBkcm9wbGV0IGNvZGUsIGFuZFxuICogcHJldmVudCBkZXNpcmVkIGJlaGF2aW9yIChpLmUuIHdlIGZhaWwgdG8gdHJhbnNpdGlvbiBiYWNrIHRvIGJsb2NrIG1vZGUpLlxuICovXG5mdW5jdGlvbiBzd2FsbG93RXJyb3JzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mKGNvbnNvbGUpICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VkaXRvcn0gZHJvcGxldEVkaXRvclxuICovXG5Ecm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuaW5zdGFsbFRvb2x0aXBzRm9yRWRpdG9yXyA9IGZ1bmN0aW9uIChkcm9wbGV0RWRpdG9yKSB7XG4gIHRoaXMuaW5zdGFsbFRvb2x0aXBzRm9yQ3VycmVudENhdGVnb3J5QmxvY2tzXygpO1xuICB0aGlzLmhpZGVUb29sdGlwc09uQmxvY2tQaWNrXyhkcm9wbGV0RWRpdG9yKTtcblxuICBkcm9wbGV0RWRpdG9yLm9uKCdjaGFuZ2VwYWxldHRlJyxcbiAgICBzd2FsbG93RXJyb3JzKHRoaXMuaW5zdGFsbFRvb2x0aXBzRm9yQ3VycmVudENhdGVnb3J5QmxvY2tzXy5iaW5kKHRoaXMpKSk7XG4gIGRyb3BsZXRFZGl0b3Iub24oJ3RvZ2dsZWRvbmUnLFxuICAgIHN3YWxsb3dFcnJvcnModGhpcy5pbnN0YWxsVG9vbHRpcHNJZk5vdEluc3RhbGxlZF8uYmluZCh0aGlzKSkpO1xufTtcblxuRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmluc3RhbGxUb29sdGlwc0lmTm90SW5zdGFsbGVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEkKCcuZHJvcGxldC1ob3Zlci1kaXYnKS5oYXNDbGFzcygndG9vbHRpcHN0ZXJlZCcpKSB7XG4gICAgdGhpcy5pbnN0YWxsVG9vbHRpcHNGb3JDdXJyZW50Q2F0ZWdvcnlCbG9ja3NfKCk7XG4gIH1cbn07XG5cbkRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5pbnN0YWxsVG9vbHRpcHNGb3JDdXJyZW50Q2F0ZWdvcnlCbG9ja3NfID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudG9vbHRpcHNFbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgJCgnLmRyb3BsZXQtaG92ZXItZGl2JykuZWFjaChmdW5jdGlvbiAoXywgYmxvY2tIb3ZlckRpdikge1xuICAgIGlmICgkKGJsb2NrSG92ZXJEaXYpLmhhc0NsYXNzKCd0b29sdGlwc3RlcmVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnVuY05hbWUgPSAkKGJsb2NrSG92ZXJEaXYpLmF0dHIoJ3RpdGxlJyk7XG5cbiAgICB2YXIgaG92ZXJEaXZXaWR0aCA9ICQoYmxvY2tIb3ZlckRpdikud2lkdGgoKTtcbiAgICB2YXIgaG92ZXJEaXZMZWZ0VG9Ub29sYm94UmlnaHQgPSAkKCcuZHJvcGxldC1wYWxldHRlLWNhbnZhcycpLndpZHRoKCkgLVxuICAgICAgcGFyc2VJbnQoYmxvY2tIb3ZlckRpdi5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgdmFyIGRlc2lyZWRYUG9zaXRpb24gPSBNYXRoLm1pbihob3ZlckRpdldpZHRoLCBob3ZlckRpdkxlZnRUb1Rvb2xib3hSaWdodCk7XG4gICAgdmFyIHRvb2x0aXBPZmZzZXRYID0gZGVzaXJlZFhQb3NpdGlvbiAtIGhvdmVyRGl2V2lkdGg7XG5cbiAgICB2YXIgY29uZmlndXJhdGlvbiA9ICQuZXh0ZW5kKHt9LCBERUZBVUxUX1RPT0xUSVBfQ09ORklHLCB7XG4gICAgICBjb250ZW50OiB0aGlzLmdldFRvb2x0aXBIVE1MKGZ1bmNOYW1lKSxcbiAgICAgIG9mZnNldFg6IHRvb2x0aXBPZmZzZXRYLFxuICAgICAgZnVuY3Rpb25SZWFkeTogZnVuY3Rpb24gKF8sIGNvbnRlbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5zaG93RXhhbXBsZXNMaW5rKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVFeGFtcGxlc0xpbmsgPSBjb250ZW50cy5maW5kKCcudG9vbHRpcC1leGFtcGxlLWxpbmsgPiBhJylbMF07XG4gICAgICAgIC8vIEltcG9ydGFudCB0aGlzIGJpbmRzIHRvIG1vdXNlRG93bi90b3VjaERvd24gcmF0aGVyIHRoYW4gY2xpY2ssIG5lZWRzIHRvXG4gICAgICAgIC8vIGhhcHBlbiBiZWZvcmUgYGJsdXJgIHdoaWNoIHRyaWdnZXJzIHRoZSBhY2UgZWRpdG9yIGNvbXBsZXRlciBwb3B1cFxuICAgICAgICAvLyBoaWRlIHdoaWNoIGluIHR1cm4gd291bGQgaGlkZSB0aGUgbGluayBhbmQgbm90IHNob3cgdGhlIGRvY3MuXG4gICAgICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2VlRXhhbXBsZXNMaW5rLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5zaG93RG9jRm9yKGZ1bmNOYW1lKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgLy8gU3RvcmUgdGhlIHRpdGxlL2Z1bmNOYW1lIGFzIGEgYmxvY2sgaWQgc28gd2UgY2FuIGF0dGFjaCBjYWxsb3V0cyBsYXRlcjpcbiAgICAkKGJsb2NrSG92ZXJEaXYpLmF0dHIoJ2lkJywgJ2Ryb3BsZXRfcGFsZXR0ZV9ibG9ja18nICsgZnVuY05hbWUpO1xuICAgICQoYmxvY2tIb3ZlckRpdikudG9vbHRpcHN0ZXIoY29uZmlndXJhdGlvbik7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFRvb2x0aXBzdGVyJ3MgaGlkZU9uQ2xpY2sgc2V0dGluZyBkb2VzIG5vdCB3b3JrIHdpdGggdGhlIGRyb3BsZXQgaG92ZXJcbiAqIG92ZXJsYXkgYXMtaXMuIEhpZGUgdGhlIHRvb2x0aXAgb24gYmxvY2sgcGlja2luZyBleHBsaWNpdGx5LlxuICovXG5Ecm9wbGV0QmxvY2tUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuaGlkZVRvb2x0aXBzT25CbG9ja1BpY2tfID0gZnVuY3Rpb24gKGRyb3BsZXRFZGl0b3IpIHtcbiAgZHJvcGxldEVkaXRvci5vbigncGlja2Jsb2NrJywgZnVuY3Rpb24gKCkge1xuICAgICQoJy50b29sdGlwc3RlcmVkJykudG9vbHRpcHN0ZXIoJ2hpZGUnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgZm9yIHRvb2x0aXBcbiAqL1xuRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmdldFRvb2x0aXBIVE1MID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICB2YXIgdG9vbHRpcEluZm8gPSB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5nZXREcm9wbGV0VG9vbHRpcChmdW5jdGlvbk5hbWUpO1xuICByZXR1cm4gRHJvcGxldEZ1bmN0aW9uVG9vbHRpcE1hcmt1cCh7XG4gICAgZnVuY3Rpb25OYW1lOiB0b29sdGlwSW5mby5mdW5jdGlvbk5hbWUsXG4gICAgaXNQcm9wZXJ0eTogdG9vbHRpcEluZm8uaXNQcm9wZXJ0eSxcbiAgICB0aXBQcmVmaXg6IHRvb2x0aXBJbmZvLnRpcFByZWZpeCxcbiAgICBmdW5jdGlvblNob3J0RGVzY3JpcHRpb246IHRvb2x0aXBJbmZvLmRlc2NyaXB0aW9uLFxuICAgIHBhcmFtZXRlcnM6IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zLFxuICAgIHNpZ25hdHVyZU92ZXJyaWRlOiB0b29sdGlwSW5mby5zaWduYXR1cmVPdmVycmlkZSxcbiAgICBzaG93RXhhbXBsZXNMaW5rOiB0aGlzLnNob3dFeGFtcGxlc0xpbmtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBpZiB0b29sdGlwcyBzaG91bGQgYmUgZW5hYmxlZFxuICovXG5cbkRyb3BsZXRCbG9ja1Rvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zZXRUb29sdGlwc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICB0aGlzLnRvb2x0aXBzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJvcGxldEJsb2NrVG9vbHRpcE1hbmFnZXI7XG4iLCJ2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVwcmVzZW50YXRpb24gb2YgYSBkcm9wbGV0IGZ1bmN0aW9uL2Jsb2NrJ3MgdG9vbHRpcFxuICovXG5cbnZhciBEUk9QTEVUX0JMT0NLX0kxOE5fUFJFRklYID0gXCJkcm9wbGV0QmxvY2tfXCI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gcGFyYW1ldGVySW5mb1xuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7P1N0cmluZ30gZGVzY3JpcHRpb25cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyBhIGJsb2NrJ3MgdG9vbHRpcCBpbmZvcm1hdGlvbiBhbmQgaGVscHMgcmVuZGVyIGl0XG4gKiBHcmFicyBtdWNoIG9mIHRoZSB0b29sdGlwJ3MgaW5mb3JtYXRpb24gZnJvbSBlaXRoZXIgYXBwLXNwZWNpZmljIGxvY2FsZVxuICogZmlsZSAocGFzc2VkIGluIGFzIGFwcE1zZykgb3IsIGlmIG5vdCBwcmVzZW50LCB0aGUgJ2NvbW1vbicgbG9jYWxlIGZpbGUsXG4gKiAoYXBwcy9pMThuL2NvbW1vbi9lbl91cy5qc29uKSwga2V5ZWQgYnkgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gKlxuICogZS5nLixcbiAqXG4gKiBcImRyb3BsZXRCbG9ja19yZWFkUmVjb3Jkc19kZXNjcmlwdGlvblwiOiBcIlJlYWRzIHJlY29yZHMgWy4uLl0uXCIsXG4gKiBcImRyb3BsZXRCbG9ja19yZWFkUmVjb3Jkc19wYXJhbTBcIjogXCJ0YWJsZVwiLFxuICogXCJkcm9wbGV0QmxvY2tfcmVhZFJlY29yZHNfcGFyYW0xXCI6IFwic2VhcmNoUGFyYW1zXCIsXG4gKiBcImRyb3BsZXRCbG9ja19yZWFkUmVjb3Jkc19wYXJhbTJcIjogXCJvblN1Y2Nlc3NcIixcbiAqXG4gKiBXaWxsIHJlc3VsdCBpbiBhIHRvb2x0aXAgd2l0aCB0aGUgY29udGVudHM6XG4gKlxuICogICAgcmVhZFJlY29yZHModGFibGUsIHNlYXJjaFBhcmFtcywgb25TdWNjZXNzKVxuICogICAgUmVhZHMgcmVjb3JkcyBbLi4uXS5cbiAqICAgIFtSZWFkIE1vcmVdIChsaW5rcyB0byBgcmVhZFJlY29yZHNgIGRvYyBmaWxlKVxuICpcbiAqIEJsb2NrcyB3aGljaCBoYXZlIGZ1bmN0aW9uTmFtZXMgdGhhdCBzaG91bGQgbm90IGJlIHVzZXItdmlzaWJsZSBjYW4gZGVmaW5lXG4gKiB0aGVpciBvd24gc2lnbmF0dXJlIG92ZXJyaWRlLlxuICpcbiAqIGUuZy4sXG4gKlxuICogXCJkcm9wbGV0QmxvY2tfZnVuY3Rpb25QYXJhbXNfbl9kZXNjcmlwdGlvblwiOiBcIkRlZmluZSBhIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBwYXJhbWV0ZXJcIixcbiAqIFwiZHJvcGxldEJsb2NrX2Z1bmN0aW9uUGFyYW1zX25fc2lnbmF0dXJlT3ZlcnJpZGVcIjogXCJGdW5jdGlvbiB3aXRoIGEgUGFyYW1ldGVyXCIsXG4gKlxuICogV2lsbCByZXN1bHQgaW4gYSB0b29sdGlwIHdpdGggdGhlIGNvbnRlbnRzOlxuICpcbiAqICAgIEZ1bmN0aW9uIHdpdGggYSBQYXJhbWV0ZXIgPC0tIG5vdGUsIG5vICgpc1xuICogICAgRGVmaW5lIGEgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIHBhcmFtZXRlci5cbiAqICAgIFtSZWFkIE1vcmVdIChsaW5rcyB0byBgZnVuY3Rpb25QYXJhbXNfbmAgZG9jIGZpbGUpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwID0gZnVuY3Rpb24gKGFwcE1zZywgZGVmaW5pdGlvbikge1xuICB0aGlzLmFwcE1zZyA9IGFwcE1zZztcblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5mdW5jdGlvbk5hbWUgPSBkZWZpbml0aW9uLmZ1bmM7XG5cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLmlzUHJvcGVydHkgPSBkZWZpbml0aW9uLnR5cGUgPT09ICdwcm9wZXJ0eSc7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIHRoaXMudGlwUHJlZml4ID0gZGVmaW5pdGlvbi50aXBQcmVmaXg7XG5cbiAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5nZXRMb2NhbGl6YXRpb24odGhpcy5kZXNjcmlwdGlvbktleSgpKTtcbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uKCk7XG4gIH1cblxuICB2YXIgc2lnbmF0dXJlT3ZlcnJpZGUgPSB0aGlzLmdldExvY2FsaXphdGlvbih0aGlzLnNpZ25hdHVyZU92ZXJyaWRlS2V5KCkpO1xuICBpZiAoc2lnbmF0dXJlT3ZlcnJpZGUpIHtcbiAgICB0aGlzLnNpZ25hdHVyZU92ZXJyaWRlID0gc2lnbmF0dXJlT3ZlcnJpZGUoKTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7QXJyYXkuPHBhcmFtZXRlckluZm8+fSAqL1xuICB0aGlzLnBhcmFtZXRlckluZm9zID0gW107XG5cbiAgZm9yICh2YXIgcGFyYW1JZCA9IDA7IDsgcGFyYW1JZCsrKSB7XG4gICAgdmFyIHBhcmFtSW5mbyA9IHt9O1xuICAgIC8qXG4gICAgICogUGFyYW1ldGVyIG5hbWVzIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGxvY2FsaXphdGlvbiBmaWxlIGlmIGRlc2lyZWQsXG4gICAgICogYnV0IHdpbGwgYWxzbyBiZSBwdWxsZWQgZnJvbSB0aGUgYmxvY2sgZGVmaW5pdGlvbidzIHBhbGV0dGVQYXJhbXMgYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHBhcmFtTmFtZSA9IHRoaXMuZ2V0TG9jYWxpemF0aW9uKHRoaXMucGFyYW1ldGVyTmFtZUtleShwYXJhbUlkKSk7XG4gICAgaWYgKHBhcmFtTmFtZSkge1xuICAgICAgcGFyYW1JbmZvLm5hbWUgPSBwYXJhbU5hbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1JbmZvLm5hbWUgPSBkZWZpbml0aW9uLnBhbGV0dGVQYXJhbXMgJiYgZGVmaW5pdGlvbi5wYWxldHRlUGFyYW1zW3BhcmFtSWRdO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtSW5mby5uYW1lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1EZXNjID0gdGhpcy5nZXRMb2NhbGl6YXRpb24odGhpcy5wYXJhbWV0ZXJEZXNjcmlwdGlvbktleShwYXJhbUlkKSk7XG4gICAgaWYgKHBhcmFtRGVzYykge1xuICAgICAgcGFyYW1JbmZvLmRlc2NyaXB0aW9uID0gcGFyYW1EZXNjKCk7XG4gICAgfVxuICAgIGlmIChkZWZpbml0aW9uLmFzc2V0VG9vbHRpcCkge1xuICAgICAgcGFyYW1JbmZvLmFzc2V0VG9vbHRpcCA9IGRlZmluaXRpb24uYXNzZXRUb29sdGlwW3BhcmFtSWRdO1xuICAgIH1cbiAgICB0aGlzLnBhcmFtZXRlckluZm9zLnB1c2gocGFyYW1JbmZvKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbkRyb3BsZXRGdW5jdGlvblRvb2x0aXAucHJvdG90eXBlLmdldExvY2FsaXphdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuYXBwTXNnW2tleV0gfHwgbXNnW2tleV07XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkRyb3BsZXRGdW5jdGlvblRvb2x0aXAucHJvdG90eXBlLmRlc2NyaXB0aW9uS2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pMThuUHJlZml4KCkgKyBcIl9kZXNjcmlwdGlvblwiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5zaWduYXR1cmVPdmVycmlkZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaTE4blByZWZpeCgpICsgXCJfc2lnbmF0dXJlT3ZlcnJpZGVcIjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtSW5kZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkRyb3BsZXRGdW5jdGlvblRvb2x0aXAucHJvdG90eXBlLnBhcmFtZXRlck5hbWVLZXkgPSBmdW5jdGlvbiAocGFyYW1JbmRleCkge1xuICByZXR1cm4gdGhpcy5pMThuUHJlZml4KCkgKyBcIl9wYXJhbVwiICsgcGFyYW1JbmRleDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtSW5kZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkRyb3BsZXRGdW5jdGlvblRvb2x0aXAucHJvdG90eXBlLnBhcmFtZXRlckRlc2NyaXB0aW9uS2V5ID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuaTE4blByZWZpeCgpICsgXCJfcGFyYW1cIiArIHBhcmFtSW5kZXggKyAnX2Rlc2NyaXB0aW9uJztcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gaTE4biBmaWxlIHByZWZpeCBmb3IgdGhpcyBmdW5jdGlvblxuICovXG5Ecm9wbGV0RnVuY3Rpb25Ub29sdGlwLnByb3RvdHlwZS5pMThuUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRFJPUExFVF9CTE9DS19JMThOX1BSRUZJWCArIHRoaXMuZnVuY3Rpb25OYW1lO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgZm9yIGZ1bGwgZG9jIGFib3V0IHRoaXMgZnVuY3Rpb25cbiAqL1xuRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5wcm90b3R5cGUuZ2V0RnVsbERvY3VtZW50YXRpb25VUkwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnLy8nICsgdXRpbHMuZ2V0UGVnYXN1c0hvc3QoKSArICcvYXBwbGFiL2RvY3MvJyArIHRoaXMuZnVuY3Rpb25OYW1lICsgJz9lbWJlZGRlZCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BsZXRGdW5jdGlvblRvb2x0aXA7XG4iLCJ2YXIgRHJvcGxldEZ1bmN0aW9uVG9vbHRpcE1hcmt1cCA9IHJlcXVpcmUoJy4vRHJvcGxldEZ1bmN0aW9uVG9vbHRpcC5odG1sLmVqcycpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2RvbScpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGlzcGxheXMgdG9vbHRpcHMgZm9yIERyb3BsZXQgYmxvY2tzXG4gKi9cblxuLyoqXG4gKiBIYW5kbGVzIGRpc3BsYXlpbmcgdG9vbHRpcHMgb24gRHJvcGxldCdzIEFDRSBlZGl0b3IgYXV0b2NvbXBsZXRlIGRyb3Bkb3duXG4gKiBAcGFyYW0ge0Ryb3BsZXRUb29sdGlwTWFuYWdlcn0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyID0gZnVuY3Rpb24gKGRyb3BsZXRUb29sdGlwTWFuYWdlcikge1xuICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlciA9IGRyb3BsZXRUb29sdGlwTWFuYWdlcjtcbiAgdGhpcy5zaG93RXhhbXBsZXNMaW5rID0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmRyb3BsZXRDb25maWcuc2hvd0V4YW1wbGVzTGluaztcbiAgdGhpcy50b29sdGlwc0VuYWJsZWQgPSB0cnVlO1xufTtcblxudmFyIERFRkFVTFRfVE9PTFRJUF9DT05GSUcgPSB7XG4gIGludGVyYWN0aXZlOiB0cnVlLFxuICBhdXRvQ2xvc2U6IGZhbHNlLFxuICB0cmlnZ2VyOiAnY3VzdG9tJyxcbiAgc3BlZWQ6IDEwMCxcbiAgbWF4V2lkdGg6IDQ1MCxcbiAgcG9zaXRpb246ICdsZWZ0JyxcbiAgY29udGVudEFzSFRNTDogdHJ1ZSxcbiAgdGhlbWU6ICdkcm9wbGV0LWJsb2NrLXRvb2x0aXBzdGVyJyxcbiAgb2Zmc2V0WTogMixcbiAgcmVzdG9yYXRpb246ICdub25lJyxcbiAgdXBkYXRlQW5pbWF0aW9uOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VkaXRvcn0gZHJvcGxldEVkaXRvclxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuaW5zdGFsbFRvb2x0aXBzRm9yRWRpdG9yXyA9IGZ1bmN0aW9uIChkcm9wbGV0RWRpdG9yKSB7XG4gIHZhciBhY2VFZGl0b3IgPSBkcm9wbGV0RWRpdG9yLmFjZUVkaXRvcjtcblxuICB0aGlzLmVkaXRvckNoYW5nZWRFdmVudEhhbmRsZXJfID0gdGhpcy5zZXR1cE9uUG9wdXBTaG93bl8uYmluZCh0aGlzLCBhY2VFZGl0b3IpO1xuICBhY2VFZGl0b3IuY29tbWFuZHMub24oXCJhZnRlckV4ZWNcIiwgdGhpcy5lZGl0b3JDaGFuZ2VkRXZlbnRIYW5kbGVyXyk7XG59O1xuXG4vKipcbiAqIFdoZW4gYW4gYXV0b2NvbXBsZXRlIHBvcHVwIGhhcyBiZWVuIHNob3duIHRoZSBmaXJzdCB0aW1lLCByZWdpc3RlciBldmVudFxuICogaGFuZGxlcnMgdG8gc2hvdyBhbmQgaGlkZSB0b29sdGlwcyBkdXJpbmcgYXV0b2NvbXBsZXRlIHBvcHVwIHVzYWdlLlxuICogQHBhcmFtIGFjZUVkaXRvciAtIGFjZSBlZGl0b3IgaW5zdGFuY2VcbiAqIEBwYXJhbSBjaGFuZ2VFdmVudCAtIGV2ZW50IGZyb20gYWNlRWRpdG9yLmNvbW1hbmRzLm9uKFwiYWZ0ZXJFeGVjXCIpXG4gKiBAcHJpdmF0ZVxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuc2V0dXBPblBvcHVwU2hvd25fID0gZnVuY3Rpb24gKGFjZUVkaXRvciwgY2hhbmdlRXZlbnQpIHtcbiAgaWYgKGNoYW5nZUV2ZW50LmNvbW1hbmQubmFtZSAhPT0gJ2luc2VydHN0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9wdXBIYXNCZWVuU2hvd25PbmNlID0gYWNlRWRpdG9yLmNvbXBsZXRlciAmJiBhY2VFZGl0b3IuY29tcGxldGVyLnBvcHVwO1xuICBpZiAoIXBvcHVwSGFzQmVlblNob3duT25jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc2V0dXBGb3JFZGl0b3JQb3B1cF8oYWNlRWRpdG9yKTtcblxuICBhY2VFZGl0b3IuY29tbWFuZHMucmVtb3ZlTGlzdGVuZXIoXCJhZnRlckV4ZWNcIiwgdGhpcy5lZGl0b3JDaGFuZ2VkRXZlbnRIYW5kbGVyXyk7XG4gIHRoaXMuZWRpdG9yQ2hhbmdlZEV2ZW50SGFuZGxlcl8gPSBudWxsO1xufTtcblxuRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnNldHVwRm9yRWRpdG9yUG9wdXBfID0gZnVuY3Rpb24gKGFjZUVkaXRvcikge1xuICBhY2VFZGl0b3IuY29tcGxldGVyLnBvcHVwLnNldFNlbGVjdE9uSG92ZXIodHJ1ZSk7XG5cbiAgYWNlRWRpdG9yLmNvbXBsZXRlci5wb3B1cC5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZUF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcChhY2VFZGl0b3IpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIGFjZUVkaXRvci5jb21wbGV0ZXIucG9wdXAub24oXCJoaWRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lBdXRvY29tcGxldGVUb29sdGlwc18oKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVBdXRvY29tcGxldGVQb3B1cFRvb2x0aXAgPSBmdW5jdGlvbiAoYWNlRWRpdG9yKSB7XG4gIGlmICghdGhpcy50b29sdGlwc0VuYWJsZWQgfHwgIWFjZUVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5Ym9hcmRSb3cgPSBhY2VFZGl0b3IuY29tcGxldGVyLnBvcHVwLmdldFJvdygpO1xuXG4gIGlmIChrZXlib2FyZFJvdyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlsdGVyZWRDb21wbGV0aW9ucyA9IGFjZUVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMuZmlsdGVyZWQ7XG4gIHZhciBmdW5jTmFtZSA9IGZpbHRlcmVkQ29tcGxldGlvbnNba2V5Ym9hcmRSb3ddLmRvY0Z1bmMgfHwgZmlsdGVyZWRDb21wbGV0aW9uc1trZXlib2FyZFJvd10udmFsdWU7XG5cbiAgdGhpcy5kZXN0cm95QXV0b2NvbXBsZXRlVG9vbHRpcHNfKCk7XG5cbiAgaWYgKCF0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5nZXREb2NGb3IoZnVuY05hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5hdHRhY2hUb29sdGlwRm9yRnVuY3Rpb24oZnVuY05hbWUpO1xufTtcblxuRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmF0dGFjaFRvb2x0aXBGb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICB2YXIgdG9vbHRpcERPTSA9IHRoaXMuZ2V0VG9vbHRpcEhUTUwoZnVuY05hbWUpO1xuICB2YXIgY29uZmlndXJhdGlvbiA9ICQuZXh0ZW5kKHt9LCBERUZBVUxUX1RPT0xUSVBfQ09ORklHLCB7XG4gICAgY29udGVudDogdG9vbHRpcERPTSxcbiAgICBmdW5jdGlvblJlYWR5OiBmdW5jdGlvbiAoXywgY29udGVudHMpIHtcbiAgICAgIGlmICghdGhpcy5zaG93RXhhbXBsZXNMaW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWVFeGFtcGxlc0xpbmsgPSBjb250ZW50cy5maW5kKCcudG9vbHRpcC1leGFtcGxlLWxpbmsgPiBhJylbMF07XG4gICAgICAvLyBJbXBvcnRhbnQgdGhpcyBiaW5kcyB0byBtb3VzZURvd24vdG91Y2hEb3duIHJhdGhlciB0aGFuIGNsaWNrLCBuZWVkcyB0b1xuICAgICAgLy8gaGFwcGVuIGJlZm9yZSBgYmx1cmAgd2hpY2ggdHJpZ2dlcnMgdGhlIGFjZSBlZGl0b3IgY29tcGxldGVyIHBvcHVwXG4gICAgICAvLyBoaWRlIHdoaWNoIGluIHR1cm4gd291bGQgaGlkZSB0aGUgbGluayBhbmQgbm90IHNob3cgdGhlIGRvY3MuXG4gICAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHNlZUV4YW1wbGVzTGluaywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLnNob3dEb2NGb3IoZnVuY05hbWUpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpXG4gIH0pO1xuXG4gIHZhciByb3dPdmVybGF5RGl2ID0gJCgnLmFjZV9zZWxlY3RlZCcpO1xuICByb3dPdmVybGF5RGl2LnRvb2x0aXBzdGVyKGNvbmZpZ3VyYXRpb24pO1xuICByb3dPdmVybGF5RGl2LnRvb2x0aXBzdGVyKCdzaG93Jyk7XG59O1xuXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUG9wdXBUb29sdGlwTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveUF1dG9jb21wbGV0ZVRvb2x0aXBzXyA9IGZ1bmN0aW9uICgpIHtcbiAgJCgnLmFjZV9hdXRvY29tcGxldGUgLnRvb2x0aXBzdGVyZWQnKS50b29sdGlwc3RlcignZGVzdHJveScpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBIVE1MIGZvciB0b29sdGlwXG4gKi9cbkRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXRUb29sdGlwSFRNTCA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIHRvb2x0aXBJbmZvID0gdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZ2V0RHJvcGxldFRvb2x0aXAoZnVuY3Rpb25OYW1lKTtcbiAgdmFyIGRyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAgPSBEcm9wbGV0RnVuY3Rpb25Ub29sdGlwTWFya3VwKHtcbiAgICBmdW5jdGlvbk5hbWU6IHRvb2x0aXBJbmZvLmZ1bmN0aW9uTmFtZSxcbiAgICBpc1Byb3BlcnR5OiB0b29sdGlwSW5mby5pc1Byb3BlcnR5LFxuICAgIHRpcFByZWZpeDogdG9vbHRpcEluZm8udGlwUHJlZml4LFxuICAgIGZ1bmN0aW9uU2hvcnREZXNjcmlwdGlvbjogdG9vbHRpcEluZm8uZGVzY3JpcHRpb24sXG4gICAgcGFyYW1ldGVyczogdG9vbHRpcEluZm8ucGFyYW1ldGVySW5mb3MsXG4gICAgc2lnbmF0dXJlT3ZlcnJpZGU6IHRvb2x0aXBJbmZvLnNpZ25hdHVyZU92ZXJyaWRlLFxuICAgIHNob3dFeGFtcGxlc0xpbms6IHRoaXMuc2hvd0V4YW1wbGVzTGlua1xuICB9KTtcbiAgcmV0dXJuIGRyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBpZiB0b29sdGlwcyBhcmUgZW5hYmxlZFxuICovXG5cbkRyb3BsZXRBdXRvY29tcGxldGVQb3B1cFRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5zZXRUb29sdGlwc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICB0aGlzLnRvb2x0aXBzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXI7XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7IGZ1bmN0aW9uIGdldFByZWZpeGVkTmFtZSAoKSB7XG4gIHJldHVybiB0aXBQcmVmaXggPyB0aXBQcmVmaXggKyBmdW5jdGlvbk5hbWUgOiBmdW5jdGlvbk5hbWU7XG59IDsgYnVmLnB1c2goJ1xcbjxkaXYgY2xhc3M9XCJmdW5jdGlvbi1uYW1lXCI+XFxuICAnKTs1OyBpZiAoc2lnbmF0dXJlT3ZlcnJpZGUpIHs7IGJ1Zi5wdXNoKCcgICAgJywgZXNjYXBlKCg1LCAgc2lnbmF0dXJlT3ZlcnJpZGUgKSksICdcXG4gICcpOzY7IH0gZWxzZSBpZiAoaXNQcm9wZXJ0eSkgezsgYnVmLnB1c2goJyAgICAnLCBlc2NhcGUoKDYsICBnZXRQcmVmaXhlZE5hbWUoKSApKSwgJ1xcbiAgJyk7NzsgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBUT0RPKGJqb3JkYW4pOiB3b3VsZCBiZSBuaWNlIHRvIHNwbGl0IHRoZSBmb2xsb3dpbmcgbGluZSB1cCwgY2FuJ3QgZmlndXJlXG4gICAgICogb3V0IGhvdyB0byBkbyBzbyB3aXRob3V0IGluc2VydGluZyBleHRyYW5lb3VzIHNwYWNlcyBiZXR3ZWVuIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICA7IGJ1Zi5wdXNoKCcgICAgJywgZXNjYXBlKCgxMiwgIGdldFByZWZpeGVkTmFtZSgpICkpLCAnKCcpOzEyOyBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHs7IGJ1Zi5wdXNoKCcnLCAoMTIsICBwYXJhbWV0ZXJzW2ldLm5hbWUpLCAnJyk7MTI7IGlmIChpIDwgcGFyYW1ldGVycy5sZW5ndGggLSAxKSB7OyBidWYucHVzaCgnLCAnKTsxMjsgfTsgYnVmLnB1c2goJycpOzEyOyB9OyBidWYucHVzaCgnKSAgJyk7MTI7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7MTQ7IGlmIChmdW5jdGlvblNob3J0RGVzY3JpcHRpb24pIHsgOyBidWYucHVzaCgnPGRpdj4nLCBlc2NhcGUoKDE0LCAgZnVuY3Rpb25TaG9ydERlc2NyaXB0aW9uICkpLCAnPC9kaXY+Jyk7MTQ7IH0gOyBidWYucHVzaCgnXFxuJyk7MTU7IGlmIChzaG93RXhhbXBsZXNMaW5rKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBjbGFzcz1cInRvb2x0aXAtZXhhbXBsZS1saW5rXCI+XFxuICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMCk7XCI+U2VlIGV4YW1wbGVzPC9hPlxcbiAgPC9kaXY+XFxuJyk7MTk7IH0gOyBidWYucHVzaCgnXFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwiLyogZ2xvYmFsIGFjZSAqL1xudmFyIERyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAgPSByZXF1aXJlKCcuL0Ryb3BsZXRQYXJhbWV0ZXJUb29sdGlwLmh0bWwuZWpzJyk7XG52YXIgdG9vbHRpcFV0aWxzID0gcmVxdWlyZSgnLi90b29sdGlwVXRpbHMuanMnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi9kb20nKTtcbnZhciBkcm9wbGV0VXRpbHMgPSByZXF1aXJlKCcuLi9kcm9wbGV0VXRpbHMnKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERpc3BsYXlzIHRvb2x0aXBzIGZvciBEcm9wbGV0IGJsb2Nrc1xuICovXG5cbi8qKlxuICogSGFuZGxlcyBkaXNwbGF5aW5nIHRvb2x0aXBzIG9uIERyb3BsZXQncyBBQ0UgZWRpdG9yIHdoZW4gZmlsbGluZyBpblxuICogYW4gZW1wdHkgcGFyYW1ldGVyLlxuICogQWxzbyB3aWxsIGF1Z21lbnQgQUNFIGVkaXRvcidzIExpdmUgYXV0b2NvbXBsZXRlIGJ5IGludm9raW5nIHNjb3BlZFxuICogYXV0b2NvbXBsZXRlIGRyb3Bkb3ducyBmb3IgZWFjaCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Ryb3BsZXRUb29sdGlwTWFuYWdlcn0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlciA9IGZ1bmN0aW9uIChkcm9wbGV0VG9vbHRpcE1hbmFnZXIpIHtcbiAgdGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIgPSBkcm9wbGV0VG9vbHRpcE1hbmFnZXI7XG4gIHRoaXMuc2hvd0V4YW1wbGVzTGluayA9IGRyb3BsZXRUb29sdGlwTWFuYWdlci5kcm9wbGV0Q29uZmlnLnNob3dFeGFtcGxlc0xpbms7XG4gIHRoaXMuc2hvd1BhcmFtRHJvcGRvd25zID0gZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmRyb3BsZXRDb25maWcuc2hvd1BhcmFtRHJvcGRvd25zO1xuICB0aGlzLnRvb2x0aXBDb25maWcgPSB7XG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICB0cmlnZ2VyOiAnY3VzdG9tJyxcbiAgICBzcGVlZDogMTAwLFxuICAgIG1heFdpZHRoOiA0NTAsXG4gICAgcG9zaXRpb246IHRoaXMuc2hvd1BhcmFtRHJvcGRvd25zID8gJ3RvcCcgOiAnYm90dG9tJyxcbiAgICBjb250ZW50QXNIVE1MOiB0cnVlLFxuICAgIHRoZW1lOiAnZHJvcGxldC1ibG9jay10b29sdGlwc3RlcicsXG4gICAgb2Zmc2V0WTogMixcbiAgICByZXN0b3JhdGlvbjogJ25vbmUnLFxuICAgIHVwZGF0ZUFuaW1hdGlvbjogZmFsc2UsXG4gICAgcG9zaXRpb25UcmFja2VyOiB0cnVlLFxuICAgIHRvb2x0aXBzRW5hYmxlZDogdHJ1ZVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VkaXRvcn0gZHJvcGxldEVkaXRvclxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmluc3RhbGxUb29sdGlwc0ZvckVkaXRvcl8gPSBmdW5jdGlvbiAoZHJvcGxldEVkaXRvcikge1xuICB2YXIgYWNlRWRpdG9yID0gZHJvcGxldEVkaXRvci5hY2VFZGl0b3I7XG5cbiAgdmFyIGN1cnNvck1vdmVtZW50SGFuZGxlciA9IHRoaXMub25DdXJzb3JNb3ZlbWVudF8uYmluZCh0aGlzLCBhY2VFZGl0b3IpO1xuICBhY2VFZGl0b3IuY29tbWFuZHMub24oJ2FmdGVyRXhlYycsIGN1cnNvck1vdmVtZW50SGFuZGxlcik7XG4gIGFjZUVkaXRvci5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZ2V0Q3Vyc29yVG9vbHRpcF8oKS50b29sdGlwc3RlcignaGlkZScpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZWRpdG9yIC0gYWNlIGVkaXRvciBpbnN0YW5jZVxuICogQHBhcmFtIGNoYW5nZUV2ZW50IC0gZXZlbnQgZnJvbSBhY2VFZGl0b3Iuc2Vzc2lvbi5zZWxlY3Rpb24ub24oJ2NoYW5nZUN1cnNvcicpXG4gKiBAcHJpdmF0ZVxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLm9uQ3Vyc29yTW92ZW1lbnRfID0gZnVuY3Rpb24gKGVkaXRvciwgY2hhbmdlRXZlbnQpIHtcbiAgdGhpcy5nZXRDdXJzb3JUb29sdGlwXygpLnRvb2x0aXBzdGVyKCdoaWRlJyk7XG5cbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG5cbiAgdmFyIGN1cnJlbnRQYXJhbWV0ZXJJbmZvID0gdG9vbHRpcFV0aWxzLmZpbmRGdW5jdGlvbkFuZFBhcmFtTnVtYmVyKGVkaXRvciwgY3Vyc29yUG9zaXRpb24pO1xuICBpZiAoIWN1cnJlbnRQYXJhbWV0ZXJJbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuYmxvY2tEcm9wZG93bnNBbmRUb29sdGlwcyB8fCB0aGlzLnN0YXJ0aW5nQXV0b0NvbXBsZXRlKSB7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCByZS1lbnRyYW5jeSB0aGF0IG9jY3VycyBpbnNpZGUgdGhlIHNob3dQYXJhbURyb3Bkb3duSWZOZWVkZWRfKCkgYW5kIHRoZSBjbGlja1xuICAgIC8vIGhhbmRsZXJzIGJlbG93XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVkaXRvci5jb21wbGV0ZXIgJiYgdGhpcy5zaG93UGFyYW1Ecm9wZG93bnMpIHtcbiAgICB0aGlzLnNob3dQYXJhbURyb3Bkb3duSWZOZWVkZWRfKGVkaXRvciwgY3VycmVudFBhcmFtZXRlckluZm8pO1xuICB9XG5cbiAgdGhpcy51cGRhdGVQYXJhbWV0ZXJUb29sdGlwXyhlZGl0b3IsIGN1cnJlbnRQYXJhbWV0ZXJJbmZvKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGVkaXRvciAtIGFjZSBlZGl0b3IgaW5zdGFuY2VcbiAqIEBwYXJhbSBwYXJhbUluZm8gLSBwYXJhbWV0ZXIgaW5mbyBhbHJlYWR5IHJldHJpZXZlZCBiYXNlZCBvbiB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnNob3dQYXJhbURyb3Bkb3duSWZOZWVkZWRfID0gZnVuY3Rpb24gKGVkaXRvciwgcGFyYW1JbmZvKSB7XG4gIC8vIENoZWNrIHRoZSBkcm9wbGV0Q29uZmlnIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBkcm9wZG93biBpbmZvIGZvciB0aGlzIHBhcmFtZXRlclxuICB2YXIgZHJvcGRvd25MaXN0O1xuICBkcm9wbGV0VXRpbHMuZ2V0QWxsQXZhaWxhYmxlRHJvcGxldEJsb2NrcyhcbiAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5kcm9wbGV0Q29uZmlnLFxuICAgIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmNvZGVGdW5jdGlvbnMsXG4gICAgdGhpcy5hdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkpLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICBpZiAoIWJsb2NrLmRyb3Bkb3duIHx8XG4gICAgICAgICAgKGJsb2NrLmZ1bmMgIT09IHBhcmFtSW5mby5mdW5jTmFtZSAmJiBibG9jay5mdW5jICE9PSBwYXJhbUluZm8uZnVsbEZ1bmNOYW1lKSkge1xuICAgICAgICAvLyBOb3QgdGhlIHJpZ2h0IGJsb2NrIG9yIG5vIGRyb3Bkb3duIHNwZWNpZmllZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2subm9BdXRvY29tcGxldGUpIHtcbiAgICAgICAgLy8gQmxvY2sgZG9lc24ndCB3YW50IGF1dG9jb21wbGV0ZSwgc28gaWdub3JlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5hdXRvY29tcGxldGVQYWxldHRlQXBpc09ubHkgJiZcbiAgICAgICAgICB0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5jb2RlRnVuY3Rpb25zICYmXG4gICAgICAgICAgdHlwZW9mIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmNvZGVGdW5jdGlvbnNbYmxvY2suZnVuY10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEluIGF1dG9jb21wbGV0ZVBhbGV0dGVBcGlzT25seSBtb2RlIGFuZCBibG9jayBpcyBub3QgaW4gdGhlIHBhbGV0dGU6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYmxvY2suZHJvcGRvd25bcGFyYW1JbmZvLmN1cnJlbnRQYXJhbWV0ZXJJbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHJvcGRvd25MaXN0ID0gYmxvY2suZHJvcGRvd25bcGFyYW1JbmZvLmN1cnJlbnRQYXJhbWV0ZXJJbmRleF0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyb3Bkb3duTGlzdCA9IGJsb2NrLmRyb3Bkb3duW3BhcmFtSW5mby5jdXJyZW50UGFyYW1ldGVySW5kZXhdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGhpcyk7XG5cbiAgaWYgKGRyb3Bkb3duTGlzdCAmJiAhZWRpdG9yLmNvbXBsZXRlci5hY3RpdmF0ZWQpIHtcbiAgICAvLyBUaGUgY3Vyc29yIGlzIHBvc2l0aW9uZWQgd2hlcmUgYSBwYXJhbWV0ZXIgd2l0aCBhIGRyb3Bkb3duIHNob3VsZCBhcHBlYXJcbiAgICAvLyBhbmQgYXV0b2NvbXBsZXRlIGlzIG5vdCBhbHJlYWR5IGFjdGl2ZSwgc28gbGV0J3MgcG9wIHVwIGEgc3BlY2lhbCBkcm9wZG93blxuICAgIC8vIGF1dG9jb21wbGV0ZVxuXG4gICAgLy8gRmlyc3QsIGluc3RhbGwgb3VyIGhvb2tzIHRvIG1vZGlmeSB0aGUgbm9ybWFsIGFjZSBBdXRvQ29tcGxldGUgKHRoZXNlIGFyZVxuICAgIC8vIHNhZmUgdG8gbGVhdmUgaW4gcGxhY2UsIGFuZCB3ZSBjYW4gY2FsbCB0aGlzIG11bHRpcGxlIHRpbWVzKTpcbiAgICB0aGlzLmluc3RhbGxBY2VDb21wbGV0ZXJIb29rc18oZWRpdG9yKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhY2UgY29tcGxldGVyIGJhc2VkIG9uIHRoZSBkcm9wZG93biBpbmZvIGFuZCBtYXJrIGl0IGFzIHRoZVxuICAgIC8vIFwib3ZlcnJpZGVDb21wbGV0ZXJcIiB3aGljaCB3aWxsIHN0YXkgaW4gcGxhY2UgZm9yIHRoZSBuZXh0IHBvcHVwIGZyb21cbiAgICAvLyBhdXRvY29tcGxldGUgb25seTpcbiAgICB2YXIgZHJvcGRvd25Db21wbGV0aW9ucyA9IFtdO1xuICAgIGRyb3Bkb3duTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0VmFsdWUpIHtcbiAgICAgIHZhciB2YWxTdHJpbmcsIHZhbENsaWNrO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbFN0cmluZyA9IGxpc3RWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN1cHBvcnQgdGhlIHsgdGV4dDogeCwgZGlzcGxheTogeCB9IGZvcm0sIGJ1dCBpZ25vcmUgdGhlIGRpc3BsYXkgZmllbGRcbiAgICAgICAgdmFsU3RyaW5nID0gbGlzdFZhbHVlLnRleHQ7XG4gICAgICAgIC8vIFRhY2sgb24gdGhlIHNwZWNpYWwgY2xpY2sgaGFuZGxlciBpZiBwcmVzZW50XG4gICAgICAgIHZhbENsaWNrID0gbGlzdFZhbHVlLmNsaWNrO1xuICAgICAgfVxuICAgICAgZHJvcGRvd25Db21wbGV0aW9ucy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ2Ryb3Bkb3duJyxcbiAgICAgICAgdmFsdWU6IHZhbFN0cmluZyxcbiAgICAgICAgY2xpY2s6IHZhbENsaWNrXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlZGl0b3IuY29tcGxldGVyLm92ZXJyaWRlQ29tcGxldGVyID0ge1xuICAgICAgZ2V0Q29tcGxldGlvbnM6IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRyb3Bkb3duQ29tcGxldGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gTWFyayB0aGUgd2UgYXJlIHN0YXJ0aW5nIGF1dG8tY29tcGxldGUgc28gdGhhdCB3ZSBjYW4gZ3VhcmQgYWdhaW5zdFxuICAgIC8vIHJlLWVudHJhbmN5IHdoZW4gd2Ugc2VlIG1vcmUgY3Vyc29yIG1vdmVtZW50IGV2ZW50czpcbiAgICB0aGlzLnN0YXJ0aW5nQXV0b0NvbXBsZXRlID0gdHJ1ZTtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoXCJzdGFydEF1dG9jb21wbGV0ZVwiKTtcbiAgICB0aGlzLnN0YXJ0aW5nQXV0b0NvbXBsZXRlID0gZmFsc2U7XG4gIH1cbn07XG5cbkRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUGFyYW1ldGVyVG9vbHRpcF8gPSBmdW5jdGlvbiAoYWNlRWRpdG9yLCBwYXJhbUluZm8pIHtcbiAgaWYgKCF0aGlzLnRvb2x0aXBDb25maWcudG9vbHRpcHNFbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRvY0Z1bmM7XG4gIGlmICh0aGlzLmRyb3BsZXRUb29sdGlwTWFuYWdlci5nZXREb2NGb3IocGFyYW1JbmZvLmZ1bmNOYW1lKSkge1xuICAgIGRvY0Z1bmMgPSBwYXJhbUluZm8uZnVuY05hbWU7XG4gIH0gZWxzZSBpZiAodGhpcy5kcm9wbGV0VG9vbHRpcE1hbmFnZXIuZ2V0RG9jRm9yKHBhcmFtSW5mby5mdWxsRnVuY05hbWUpKSB7XG4gICAgZG9jRnVuYyA9IHBhcmFtSW5mby5mdWxsRnVuY05hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0b29sdGlwSW5mbyA9IHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLmdldERyb3BsZXRUb29sdGlwKGRvY0Z1bmMpO1xuXG4gIHZhciBoYXNUb29sdGlwUGFyYW1zID0gdG9vbHRpcEluZm8ucGFyYW1ldGVySW5mb3MubGVuZ3RoID4gMDtcbiAgaWYgKChoYXNUb29sdGlwUGFyYW1zICYmIHBhcmFtSW5mby5jdXJyZW50UGFyYW1ldGVySW5kZXggPj0gdG9vbHRpcEluZm8ucGFyYW1ldGVySW5mb3MubGVuZ3RoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJzb3JUb29sdGlwID0gdGhpcy5nZXRDdXJzb3JUb29sdGlwXygpO1xuXG4gIGN1cnNvclRvb2x0aXAudG9vbHRpcHN0ZXIoJ2NvbnRlbnQnLCB0aGlzLmdldFRvb2x0aXBIVE1MKHRvb2x0aXBJbmZvLCBwYXJhbUluZm8uY3VycmVudFBhcmFtZXRlckluZGV4KSk7XG4gIGN1cnNvclRvb2x0aXAudG9vbHRpcHN0ZXIoJ3Nob3cnKTtcblxuICBpZiAodGhpcy5zaG93RXhhbXBsZXNMaW5rKSB7XG4gICAgdmFyIHNlZUV4YW1wbGVzTGluayA9ICQoY3Vyc29yVG9vbHRpcC50b29sdGlwc3RlcignZWxlbWVudFRvb2x0aXAnKSkuZmluZCgnLnRvb2x0aXAtZXhhbXBsZS1saW5rID4gYScpWzBdO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc2VlRXhhbXBsZXNMaW5rLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoaXMuZHJvcGxldFRvb2x0aXBNYW5hZ2VyLnNob3dEb2NGb3IoZG9jRnVuYyk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgaWYgKCFoYXNUb29sdGlwUGFyYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNob29zZUFzc2V0ID0gdG9vbHRpcEluZm8ucGFyYW1ldGVySW5mb3NbcGFyYW1JbmZvLmN1cnJlbnRQYXJhbWV0ZXJJbmRleF0uYXNzZXRUb29sdGlwO1xuICBpZiAoY2hvb3NlQXNzZXQpIHtcbiAgICB2YXIgY2hvb3NlQXNzZXRMaW5rID0gJChjdXJzb3JUb29sdGlwLnRvb2x0aXBzdGVyKCdlbGVtZW50VG9vbHRpcCcpKS5maW5kKCcudG9vbHRpcC1jaG9vc2UtbGluayA+IGEnKVswXTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KGNob29zZUFzc2V0TGluaywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGN1cnNvclRvb2x0aXAudG9vbHRpcHN0ZXIoJ2hpZGUnKTtcbiAgICAgIGNob29zZUFzc2V0KGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIGFjZUVkaXRvci5vblRleHRJbnB1dCgnXCInICsgZmlsZW5hbWUgKyAnXCInKTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxufTtcblxuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5nZXRDdXJzb3JUb29sdGlwXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmN1cnNvclRvb2x0aXBfKSB7XG4gICAgdGhpcy5jdXJzb3JUb29sdGlwXyA9ICQoJy5kcm9wbGV0LWFjZSAuYWNlX2N1cnNvcicpO1xuICAgIHRoaXMuY3Vyc29yVG9vbHRpcF8udG9vbHRpcHN0ZXIodGhpcy50b29sdGlwQ29uZmlnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJzb3JUb29sdGlwXztcbn07XG5cbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gSFRNTCBmb3IgdG9vbHRpcFxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLmdldFRvb2x0aXBIVE1MID0gZnVuY3Rpb24gKHRvb2x0aXBJbmZvLCBjdXJyZW50UGFyYW1ldGVySW5kZXgpIHtcbiAgcmV0dXJuIERyb3BsZXRGdW5jdGlvblRvb2x0aXBNYXJrdXAoe1xuICAgIGZ1bmNOYW1lOiB0b29sdGlwSW5mby5mdW5jdGlvbk5hbWUsXG4gICAgZnVuY3Rpb25OYW1lOiB0b29sdGlwSW5mby5mdW5jdGlvbk5hbWUsXG4gICAgaXNQcm9wZXJ0eTogdG9vbHRpcEluZm8uaXNQcm9wZXJ0eSxcbiAgICB0aXBQcmVmaXg6IHRvb2x0aXBJbmZvLnRpcFByZWZpeCxcbiAgICBmdW5jdGlvblNob3J0RGVzY3JpcHRpb246IHRvb2x0aXBJbmZvLmRlc2NyaXB0aW9uLFxuICAgIHBhcmFtZXRlcnM6IHRvb2x0aXBJbmZvLnBhcmFtZXRlckluZm9zLFxuICAgIHNpZ25hdHVyZU92ZXJyaWRlOiB0b29sdGlwSW5mby5zaWduYXR1cmVPdmVycmlkZSxcbiAgICBzaG93RXhhbXBsZXNMaW5rIDogdGhpcy5zaG93RXhhbXBsZXNMaW5rLFxuICAgIGN1cnJlbnRQYXJhbWV0ZXJJbmRleDogY3VycmVudFBhcmFtZXRlckluZGV4XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZWRpdG9yIC0gYWNlIGVkaXRvciBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLnByb3RvdHlwZS5pbnN0YWxsQWNlQ29tcGxldGVySG9va3NfID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLmNvbXBsZXRlci5zaG93UG9wdXAgIT09IERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5zaG93UG9wdXApIHtcbiAgICBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIub3JpZ2luYWxTaG93UG9wdXAgPSBlZGl0b3IuY29tcGxldGVyLnNob3dQb3B1cDtcbiAgICBlZGl0b3IuY29tcGxldGVyLnNob3dQb3B1cCA9IERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5zaG93UG9wdXA7XG4gIH1cbiAgaWYgKGVkaXRvci5jb21wbGV0ZXIuZ2F0aGVyQ29tcGxldGlvbnMgIT09IERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5nYXRoZXJDb21wbGV0aW9ucykge1xuICAgIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5vcmlnaW5hbEdhdGhlckNvbXBsZXRpb25zID0gZWRpdG9yLmNvbXBsZXRlci5nYXRoZXJDb21wbGV0aW9ucztcbiAgICBlZGl0b3IuY29tcGxldGVyLmdhdGhlckNvbXBsZXRpb25zID0gRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLmdhdGhlckNvbXBsZXRpb25zO1xuICB9XG4gIGlmICghZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaE92ZXJyaWRlKSB7XG4gICAgZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaE92ZXJyaWRlID1cbiAgICAgIERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5pbnNlcnRNYXRjaC5iaW5kKGVkaXRvci5jb21wbGV0ZXIsIHRoaXMpO1xuICB9XG4gIGlmIChlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoICE9PSBlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoT3ZlcnJpZGUpIHtcbiAgICBEcm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIub3JpZ2luYWxJbnNlcnRNYXRjaCA9IGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2g7XG4gICAgZWRpdG9yLmNvbXBsZXRlci5pbnNlcnRNYXRjaCA9IGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2hPdmVycmlkZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gdGhpcyBjb21wbGV0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBlZGl0b3IgYWNlIGVkaXRvclxuICogQHBhcmFtIGNhbGxiYWNrIHdlIHBhc3MgdGhpcyB0aHJvdWdoXG4gKi9cbkRyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlci5nYXRoZXJDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChlZGl0b3IsIGNhbGxiYWNrKSB7XG4gIC8vIE92ZXJyaWRlIG5vcm1hbCBhY2UgQXV0b0NvbXBsZXRlIGJlaGF2aW9yIGJ5IHVzaW5nIG9ubHkgb3ZlcnJpZGVDb21wbGV0ZXJcbiAgLy8gaW5zdGVhZCBvZiB0aGUgbm9ybWFsIHNldCBvZiBjb21wbGV0ZXJzIHdoZW4gb3ZlcnJpZGVDb21wbGV0ZXIgaXMgc2V0XG4gIGlmICh0aGlzLm92ZXJyaWRlQ29tcGxldGVyKSB7XG4gICAgdmFyIGFsbENvbXBsZXRlcnMgPSBlZGl0b3IuY29tcGxldGVycztcbiAgICBlZGl0b3IuY29tcGxldGVycyA9IFsgdGhpcy5vdmVycmlkZUNvbXBsZXRlciBdO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYXV0b0luc2VydCBpcyBvZmYgc28gd2UgZG9uJ3QgaW5zZXJ0IGltbWVkaWF0ZWx5IHdoZW4gdGhlcmUgaXMgb25seSBvbmUgb3B0aW9uOlxuICAgIGVkaXRvci5jb21wbGV0ZXIuYXV0b0luc2VydCA9IGZhbHNlO1xuXG4gICAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsR2F0aGVyQ29tcGxldGlvbnMuY2FsbCh0aGlzLCBlZGl0b3IsIGNhbGxiYWNrKTtcbiAgICBlZGl0b3IuY29tcGxldGVycyA9IGFsbENvbXBsZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsR2F0aGVyQ29tcGxldGlvbnMuY2FsbCh0aGlzLCBlZGl0b3IsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gdGhpcyBjb21wbGV0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBlZGl0b3IgYWNlIGVkaXRvclxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuc2hvd1BvcHVwID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAvLyBPdmVycmlkZSBub3JtYWwgYWNlIEF1dG9Db21wbGV0ZSBiZWhhdmlvciBieSBndWFyYW50ZWVpbmcgdGhhdCBvdmVycmlkZUNvbXBsZXRlciBpcyByZXNldFxuICAvLyBhZnRlciBlYWNoIGNhbGwgdG8gc2hvd1BvcHVwKClcbiAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsU2hvd1BvcHVwLmNhbGwodGhpcywgZWRpdG9yKTtcbiAgdGhpcy5vdmVycmlkZUNvbXBsZXRlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB0aGlzIGNvbXBsZXRlciBpbnN0YW5jZVxuICogQHBhcmFtIHNlbGYgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyIGluc3RhbmNlXG4gKiBAcGFyYW0gZGF0YSBpbmZvIHBhc3NlZCB0byBhY2UncyBpbnNlcnRNYXRjaFxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIuaW5zZXJ0TWF0Y2ggPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xuICAvLyBNb2RpZnkgbm9ybWFsIGFjZSBBdXRvQ29tcGxldGUgYmVoYXZpb3IgYnkgY2FsbGluZyBvdXIgc3BlY2lhbCAnY2xpY2snIGhhbmRsZXIgd2hlbiBzdXBwbGllZFxuICAvLyBhbmQgcGFzc2luZyBpdCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBpbnNlcnRNYXRjaCgpIHRvIGJlIGNhbGxlZCB3aXRoaW5cbiAgaWYgKCFkYXRhKSB7XG4gICAgZGF0YSA9IHRoaXMucG9wdXAuZ2V0RGF0YSh0aGlzLnBvcHVwLmdldFJvdygpKTtcbiAgfVxuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZGF0YS5jbGljaykge1xuICAgIC8vIEV4ZWN1dGUgZGV0YWNoKCkgbWV0aG9kIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlIHBvcHVwIGdvZXNcbiAgICAvLyBhd2F5IGJlZm9yZSB3ZSBjYWxsIHRoZSBjbGljaygpIG1ldGhvZFxuICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICAvLyBBbmQgaGlkZSBvdXIgY3Vyc29yIHRvb2x0aXAgYXMgd2VsbDpcbiAgICBzZWxmLmdldEN1cnNvclRvb2x0aXBfKCkudG9vbHRpcHN0ZXIoJ2hpZGUnKTtcblxuICAgIC8vIE5vdGU6IHN0b3AgZHJvcGRvd25zIGFuZCB0b29sdGlwcyB1bnRpbCB0aGUgY2FsbGJhY2sgaXMgY29tcGxldGUuLi5cbiAgICBzZWxmLmJsb2NrRHJvcGRvd25zQW5kVG9vbHRpcHMgPSB0cnVlO1xuXG4gICAgdmFyIGxhbmcgPSBhY2UucmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG5cbiAgICAvLyBVc2UgZGVsYXllZENhbGwgc28gdGhlIHBvcHVwIGFuZCB0b29sdGlwIGRpc2FwcGVhciBpbiB0aGUgY2FzZSB3aGVyZSB0aGVcbiAgICAvLyBFbnRlciBrZXkgd2FzIHByZXNzZWQgYmVmb3JlIHdlIGNob29zZSB0aGlzIGF1dG9jb21wbGV0ZSBpdGVtXG4gICAgdmFyIGNsaWNrRnVuYyA9IGxhbmcuZGVsYXllZENhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2UgY3JlYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggdGhlIGNsaWNrIGZ1bmN0aW9uIHdpbGwgY2FsbCwgcGFzc2luZyBhXG4gICAgICAvLyBzdHJpbmcgd2hpY2ggd2lsbCBiZSBpbnNlcnRlZC5cbiAgICAgIGRhdGEuY2xpY2soZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoXCJpbnNlcnRzdHJpbmdcIiwgZGF0YSk7XG4gICAgICAgIHNlbGYuYmxvY2tEcm9wZG93bnNBbmRUb29sdGlwcyA9IGZhbHNlO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgY2xpY2tGdW5jLnNjaGVkdWxlKCk7XG4gIH0gZWxzZSB7XG4gICAgRHJvcGxldEF1dG9jb21wbGV0ZVBhcmFtZXRlclRvb2x0aXBNYW5hZ2VyLm9yaWdpbmFsSW5zZXJ0TWF0Y2guY2FsbCh0aGlzLCBkYXRhKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBpZiB0b29sdGlwcyBzaG91bGQgYmUgZW5hYmxlZFxuICovXG5Ecm9wbGV0QXV0b2NvbXBsZXRlUGFyYW1ldGVyVG9vbHRpcE1hbmFnZXIucHJvdG90eXBlLnNldFRvb2x0aXBzRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gIHRoaXMudG9vbHRpcENvbmZpZy50b29sdGlwc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BsZXRBdXRvY29tcGxldGVQYXJhbWV0ZXJUb29sdGlwTWFuYWdlcjtcbiIsIi8qIGdsb2JhbCBhY2UgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBfID0gdXRpbHMuZ2V0TG9kYXNoKCk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gcGFyYW1ldGVyU2xvdEluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmdW5jTmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGN1cnJlbnRQYXJhbWV0ZXJJbmRleFxuICovXG5cbnZhciBPTkxZX1dISVRFU1BBQ0VfUkVHRVhQID0gL15cXHMqJC87XG52YXIgRU5ESU5HX09GX0JMT0NLX0NPTU1FTlQgPSAvXFwqXFwvJC87XG52YXIgU1RBUlRfT0ZfQkxPQ0tfQ09NTUVOVCA9IC9eXFwvXFwqLztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIGNoYXJhY3RlciB3aXRoaW4gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb3VudE51bWJlck9mQ2hhcmFjdGVyKHN0cmluZywgY2hhcmFjdGVyKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoY2hhcmFjdGVyKS5sZW5ndGggLSAxO1xufVxuXG5mdW5jdGlvbiBvcGVuZXJNYXRjaGVzQ2xvc2VyKG9wZW5lciwgY2xvc2VyKSB7XG4gIHZhciBjbG9zZXJzVG9PcGVuZXJzID0ge1xuICAgICd9JzogJ3snLFxuICAgICcpJzogJygnLFxuICAgICddJzogJ1snXG4gIH07XG4gIHJldHVybiBjbG9zZXJzVG9PcGVuZXJzW2Nsb3Nlcl0gPT09IG9wZW5lcjtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhY2UgZWRpdG9yIGFuZCByb3cvY29sdW1uIHBvc2l0aW9uLCByZXR1cm5zIHRoZSBmdW5jdGlvblxuICogbmFtZSBhbmQgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBlZGl0ZWQgcGFyYW1ldGVyLlxuICogSWYgYSBwYXJhbWV0ZXIgaXMgbm90IGN1cnJlbnRseSBiZWluZyBmaWxsZWQgaW4sIHJldHVybnMgbnVsbC5cbiAqIFRPRE8oYmpvcmRhbik6IFVuaXQgdGVzdCBvbmNlIGFjZS5yZXF1aXJlIGF2YWlsYWJsZSBpbiB1dGlsaXR5IHRlc3RzXG4gKiBAcGFyYW0gZWRpdG9yXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEByZXR1cm5zIHtwYXJhbWV0ZXJTbG90SW5mb3xudWxsfVxuICovXG5leHBvcnRzLmZpbmRGdW5jdGlvbkFuZFBhcmFtTnVtYmVyID0gZnVuY3Rpb24gKGVkaXRvciwgcG9zaXRpb24pIHtcbiAgdmFyIHNlZW5DbG9zZXJTdGFjayA9IFtdO1xuICB2YXIgc2FtZURlcHRoUHJlY2VkaW5nQ29tbWFDb3VudCA9IDA7XG5cbiAgdmFyIFRva2VuSXRlcmF0b3IgPSBhY2UucmVxdWlyZShcIi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbiAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IoZWRpdG9yLnNlc3Npb24sIHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcblxuICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcblxuICAvLyBTcGVjaWFsIGNhc2VzIGZvciBmaXJzdCB0b2tlblxuXG4gIGlmIChwb3NpdGlvbi5jb2x1bW4gPT09IDApIHtcbiAgICAvLyBBdCBiZWdpbm5pbmcgb2YgYSBsaW5lLiBTdGVwIGJhY2sgb25lIGZvciBmaXJzdCB0b2tlbi5cbiAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICB9IGVsc2UgaWYgKHRva2VuICYmIHRva2VuLnR5cGUubWF0Y2goL15jb21tZW50LykpIHtcbiAgICB2YXIgaXNCbG9ja0NvbW1lbnQgPSB0b2tlbi50eXBlID09PSBcImNvbW1lbnQuZG9jXCIgfHxcbiAgICAgIHRva2VuLnZhbHVlLm1hdGNoKFNUQVJUX09GX0JMT0NLX0NPTU1FTlQpO1xuICAgIGlmIChpc0Jsb2NrQ29tbWVudCkge1xuICAgICAgdmFyIHRva2VuSXNFbmRPZkRvY0NvbW1lbnQgPSB0b2tlbi52YWx1ZS5tYXRjaChFTkRJTkdfT0ZfQkxPQ0tfQ09NTUVOVCk7XG4gICAgICB2YXIgY3Vyc29ySXNFbmRPZlRva2VuID0gKHRva2VuLnN0YXJ0ICsgdG9rZW4udmFsdWUubGVuZ3RoKSA9PT0gcG9zaXRpb24uY29sdW1uO1xuICAgICAgdmFyIGN1cnNvcklzRW5kT2ZCbG9ja0NvbW1lbnQgPSAodG9rZW5Jc0VuZE9mRG9jQ29tbWVudCAmJiBjdXJzb3JJc0VuZE9mVG9rZW4pO1xuICAgICAgaWYgKCFjdXJzb3JJc0VuZE9mQmxvY2tDb21tZW50KSB7XG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGhpbiBhIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHdpdGhpbiBhIGNvbW1lbnRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSBcInBhcmVuLnJwYXJlblwiOlxuICAgICAgICB2YXIgY2xvc2VycyA9IHRva2VuLnZhbHVlLnNwbGl0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBjbG9zZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDbG9zZXIgPSBjbG9zZXJzW2ldO1xuICAgICAgICAgIHNlZW5DbG9zZXJTdGFjay5wdXNoKGN1cnJlbnRDbG9zZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBhcmVuLmxwYXJlblwiOlxuICAgICAgICB2YXIgb3BlbmVycyA9IHRva2VuLnZhbHVlLnNwbGl0KCk7XG4gICAgICAgIGZvciAodmFyIGogPSBvcGVuZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRPcGVuZXIgPSBvcGVuZXJzW2pdO1xuXG4gICAgICAgICAgdmFyIGlzQmVnaW5uaW5nT2ZGdW5jdGlvbkNhbGwgPVxuICAgICAgICAgICAgc2VlbkNsb3NlclN0YWNrLmxlbmd0aCA9PT0gMCAmJiBjdXJyZW50T3BlbmVyID09PSAnKCc7XG4gICAgICAgICAgaWYgKGlzQmVnaW5uaW5nT2ZGdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpLnZhbHVlO1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSB0ZXh0IFwiZm9vLmJhcihcIiwgc3RvcmUgXCJmb28uYmFyXCIgYXMgZnVsbEZ1bmNOYW1lIGFuZFxuICAgICAgICAgICAgLy8gXCIqLmJhclwiIGFzIGZ1bmNOYW1lOlxuICAgICAgICAgICAgdmFyIGZ1bGxGdW5jTmFtZTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuLnZhbHVlID09PSAnLicpIHtcbiAgICAgICAgICAgICAgZnVsbEZ1bmNOYW1lID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCkudmFsdWUgKyAnLicgKyBmdW5jTmFtZTtcbiAgICAgICAgICAgICAgZnVuY05hbWUgPSAnKi4nICsgZnVuY05hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZ1bmNOYW1lOiBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgZnVsbEZ1bmNOYW1lOiBmdWxsRnVuY05hbWUsXG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJhbWV0ZXJJbmRleDogc2FtZURlcHRoUHJlY2VkaW5nQ29tbWFDb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGFzdENsb3NlciA9IHNlZW5DbG9zZXJTdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoIWxhc3RDbG9zZXIgfHwgIW9wZW5lck1hdGNoZXNDbG9zZXIoY3VycmVudE9wZW5lciwgbGFzdENsb3NlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiOlxuICAgICAgICBpZiAoc2VlbkNsb3NlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKHRva2VuLnZhbHVlLCAnOycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF8uY29udGFpbnModG9rZW4udmFsdWUsICcsJykpIHtcbiAgICAgICAgICAgIHNhbWVEZXB0aFByZWNlZGluZ0NvbW1hQ291bnQgKz0gY291bnROdW1iZXJPZkNoYXJhY3Rlcih0b2tlbi52YWx1ZSwgJywnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgY2FzZSBcImNvbW1lbnQuZG9jXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgLy8gV2hpdGVzcGFjZSBvciByYW5kb20gbm9uLWlkZW50aWZpZXIgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoc2VlbkNsb3NlclN0YWNrLmxlbmd0aCAhPT0gMCB8fCB0b2tlbi52YWx1ZS5tYXRjaChPTkxZX1dISVRFU1BBQ0VfUkVHRVhQKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcInN0b3JhZ2UudHlwZVwiOlxuICAgICAgY2FzZSBcImlkZW50aWZpZXJcIjpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNlZW5DbG9zZXJTdGFjay5sZW5ndGggPT09IDAgJiYgc2FtZURlcHRoUHJlY2VkaW5nQ29tbWFDb3VudCA9PT0gMCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdWJzdGFudGlhbCBiZXR3ZWVuIGN1cnNvciBhbmQgc3RhcnQgb2YgcGFyYW1ldGVyIHNsb3RcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9IChmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbiBhbm9ueW1vdXMobG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGVcbi8qKi8pIHtcbmVzY2FwZSA9IGVzY2FwZSB8fCBmdW5jdGlvbiAoaHRtbCl7XG4gIHJldHVybiBTdHJpbmcoaHRtbClcbiAgICAucmVwbGFjZSgvJig/IVxcdys7KS9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG52YXIgYnVmID0gW107XG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7IFxuIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZnVuY3Rpb24tbmFtZVwiPlxcbiAgJyk7MjsgaWYgKHNpZ25hdHVyZU92ZXJyaWRlKSB7OyBidWYucHVzaCgnICAgICcsIGVzY2FwZSgoMiwgIHNpZ25hdHVyZU92ZXJyaWRlICkpLCAnXFxuICAnKTszOyB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIFRPRE8oYmpvcmRhbik6IHdvdWxkIGJlIG5pY2UgdG8gc3BsaXQgdGhlIGZvbGxvd2luZyBsaW5lIHVwLCBjYW4ndCBmaWd1cmVcbiAgICAgKiBvdXQgaG93IHRvIGRvIHNvIHdpdGhvdXQgaW5zZXJ0aW5nIGV4dHJhbmVvdXMgc3BhY2VzIGJldHdlZW4gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgIDsgYnVmLnB1c2goJyAgICAnLCBlc2NhcGUoKDgsICBmdW5jdGlvbk5hbWUgKSksICcoJyk7ODsgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7OyBidWYucHVzaCgnPHNwYW4gY2xhc3M9XCJ0b29sdGlwLXBhcmFtZXRlci1uYW1lICcpOzg7IGlmIChpID09PSBjdXJyZW50UGFyYW1ldGVySW5kZXgpIHsgOyBidWYucHVzaCgnIGN1cnJlbnQtdG9vbHRpcC1wYXJhbWV0ZXItbmFtZScpOzg7IH0gOyBidWYucHVzaCgnXCI+JywgKDgsICBwYXJhbWV0ZXJzW2ldLm5hbWUpLCAnPC9zcGFuPicpOzg7IGlmIChpIDwgcGFyYW1ldGVycy5sZW5ndGggLSAxKSB7OyBidWYucHVzaCgnLCAnKTs4OyB9OyBidWYucHVzaCgnJyk7ODsgfTsgYnVmLnB1c2goJykgICcpOzg7IH0gOyBidWYucHVzaCgnXFxuPC9kaXY+XFxuJyk7MTA7IGlmIChwYXJhbWV0ZXJzW2N1cnJlbnRQYXJhbWV0ZXJJbmRleF0gJiYgcGFyYW1ldGVyc1tjdXJyZW50UGFyYW1ldGVySW5kZXhdLmRlc2NyaXB0aW9uKSB7IDsgYnVmLnB1c2goJzxkaXY+JywgZXNjYXBlKCgxMCwgIHBhcmFtZXRlcnNbY3VycmVudFBhcmFtZXRlckluZGV4XS5kZXNjcmlwdGlvbiApKSwgJzwvZGl2PicpOzEwOyB9IDsgYnVmLnB1c2goJ1xcbicpOzExOyBpZiAocGFyYW1ldGVyc1tjdXJyZW50UGFyYW1ldGVySW5kZXhdICYmIHBhcmFtZXRlcnNbY3VycmVudFBhcmFtZXRlckluZGV4XS5hc3NldFRvb2x0aXApIHsgOyBidWYucHVzaCgnXFxuICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1jaG9vc2UtbGlua1wiPlxcbiAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPkNob29zZS4uLjwvYT5cXG4gIDwvZGl2PlxcbicpOzE1OyB9IDsgYnVmLnB1c2goJ1xcbicpOzE2OyBpZiAoc2hvd0V4YW1wbGVzTGluaykgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWV4YW1wbGUtbGlua1wiPlxcbiAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPlNlZSBleGFtcGxlczwvYT5cXG4gIDwvZGl2PlxcbicpOzIwOyB9IDsgYnVmLnB1c2goJ1xcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIi8qKlxuICogQG92ZXJ2aWV3IGhlbHBlciBjbGFzcyB0byBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBBdXRob3JlZCBIaW50IFVJLlxuICogVXNlZCBleGNsdXNpdmVseSBieSBTdHVkaW9BcHAuXG4gKi9cblxudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi9sb2NhbGUnKTtcbnZhciBIaW50U2VsZWN0ID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvSGludFNlbGVjdC5qc3gnKTtcbnZhciBIaW50c0Rpc3BsYXkgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9IaW50c0Rpc3BsYXkuanN4Jyk7XG52YXIgYXV0aG9yZWRIaW50VXRpbHMgPSByZXF1aXJlKCcuL2F1dGhvcmVkSGludFV0aWxzJyk7XG52YXIgbGlnaHRidWxiU1ZHID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvbGlnaHRidWxiLnN2Zy5lanMnKSgpO1xudmFyIGxpZ2h0YnVsYkRpbVNWRyA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL2xpZ2h0YnVsYl9kaW0uc3ZnLmVqcycpKCk7XG5cbnZhciBBdXRob3JlZEhpbnRzID0gZnVuY3Rpb24gKHN0dWRpb0FwcCkge1xuICB0aGlzLnN0dWRpb0FwcF8gPSBzdHVkaW9BcHA7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEF1dGhvcmVkSGludFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaGludElkXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaW50Q2xhc3NcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGhpbnRUeXBlXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWxyZWFkeVNlZW5cbiAgICovXG4gIC8qKlxuICAgKiBAdHlwZSB7IUF1dGhvcmVkSGludFtdfVxuICAgKi9cbiAgdGhpcy5oaW50c18gPSBbXTtcbiAgdGhpcy5jb250ZXh0dWFsSGludHNfID0gW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnNjcnB0SWRfID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sZXZlbElkXyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQHR5cGUge0VsZW1lbnR9XG4gICAqL1xuICB0aGlzLmxpZ2h0YnVsYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmxpZ2h0YnVsYi5pZCA9IFwibGlnaHRidWxiXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhvcmVkSGludHM7XG5cbi8qKlxuICogQHJldHVybiB7QXV0aG9yZWRIaW50c1tdfVxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5nZXRVbnNlZW5IaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpbnRzID0gdGhpcy5jb250ZXh0dWFsSGludHNfLmNvbmNhdCh0aGlzLmhpbnRzXyB8fCBbXSk7XG4gIHJldHVybiBoaW50cy5maWx0ZXIoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICByZXR1cm4gaGludC5hbHJlYWR5U2VlbiA9PT0gZmFsc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtBdXRob3JlZEhpbnRzW119XG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLmdldFNlZW5IaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpbnRzID0gdGhpcy5jb250ZXh0dWFsSGludHNfLmNvbmNhdCh0aGlzLmhpbnRzXyB8fCBbXSk7XG4gIHJldHVybiBoaW50cy5maWx0ZXIoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICByZXR1cm4gaGludC5hbHJlYWR5U2VlbiA9PT0gdHJ1ZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgY29udGV4dHVhbCBoaW50cyBmb3IgdGhlIHNwZWNpZmllZCBibG9ja3MgYW5kIGFkZHMgdGhlbSB0b1xuICogdGhlIHF1ZXVlIG9mIGhpbnRzIHRvIGRpc3BsYXkuIFRyaWdnZXJzIGFuIGFuaW1hdGlvbiBvbiB0aGUgaGludFxuICogbGlnaHRidWxiIGlmIHRoZSBxdWV1ZSBoYXMgY2hhbmdlZC5cbiAqIEBwYXJhbSB7T2JqZWN0W119IGJsb2NrcyBAc2VlIGF1dGhvcmVkSGludFV0aWxzLmNyZWF0ZUNvbnRleHR1YWxIaW50c0Zyb21CbG9ja3NcbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuZGlzcGxheU1pc3NpbmdCbG9ja0hpbnRzID0gZnVuY3Rpb24gKGJsb2Nrcykge1xuICB2YXIgbmV3Q29udGV4dHVhbEhpbnRzID0gYXV0aG9yZWRIaW50VXRpbHMuY3JlYXRlQ29udGV4dHVhbEhpbnRzRnJvbUJsb2NrcyhibG9ja3MpO1xuXG4gIC8vIGlmIHRoZSBzZXQgb2YgY29udGV4dHVhbCBoaW50cyBjdXJyZW50bHkgYmVpbmcgc2hvd24gaGFzIGNoYW5nZWQsXG4gIC8vIGFuaW1hdGUgdGhlIGhpbnQgZGlzcGxheSBsaWdodGJ1bGIgd2hlbiB3ZSB1cGRhdGUgaXQuXG4gIHZhciBvbGRDb250ZXh0dWFsSGludHMgPSB0aGlzLmNvbnRleHR1YWxIaW50c18uZmlsdGVyKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgcmV0dXJuIGhpbnQuYWxyZWFkeVNlZW4gPT09IGZhbHNlO1xuICB9KTtcbiAgdmFyIGFuaW1hdGVMaWdodGJ1bGIgPSBvbGRDb250ZXh0dWFsSGludHMubGVuZ3RoICE9PSBuZXdDb250ZXh0dWFsSGludHMubGVuZ3RoO1xuXG4gIHRoaXMuY29udGV4dHVhbEhpbnRzXyA9IG5ld0NvbnRleHR1YWxIaW50cztcbiAgdGhpcy51cGRhdGVMaWdodGJ1bGJEaXNwbGF5XyhhbmltYXRlTGlnaHRidWxiKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLmZpbmlzaEhpbnRzID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIGF1dGhvcmVkSGludFV0aWxzLmZpbmlzaEhpbnRzKHtcbiAgICB0aW1lOiAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMuc3R1ZGlvQXBwXy5pbml0VGltZSksXG4gICAgYXR0ZW1wdDogdGhpcy5zdHVkaW9BcHBfLmF0dGVtcHRzLFxuICAgIHRlc3RSZXN1bHQ6IHRoaXMuc3R1ZGlvQXBwXy5sYXN0VGVzdFJlc3VsdCxcbiAgICBhY3Rpdml0eUlkOiByZXNwb25zZSAmJiByZXNwb25zZS5hY3Rpdml0eV9pZCxcbiAgICBsZXZlbFNvdXJjZUlkOiByZXNwb25zZSAmJiByZXNwb25zZS5sZXZlbF9zb3VyY2VfaWQsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLnN1Ym1pdEhpbnRzID0gZnVuY3Rpb24gKHVybCkge1xuICBhdXRob3JlZEhpbnRVdGlscy5zdWJtaXRIaW50cyh1cmwpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F1dGhvcmVkSGludFtdfSBoaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHNjcmlwdElkXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxJZFxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGhpbnRzLCBzY3JpcHRJZCwgbGV2ZWxJZCkge1xuICB0aGlzLmhpbnRzXyA9IGhpbnRzO1xuICB0aGlzLnNjcmlwdElkXyA9IHNjcmlwdElkO1xuICB0aGlzLmxldmVsSWRfID0gbGV2ZWxJZDtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgQXV0aG9yZWQgSGludHMgVUk7IGRlY29yYXRlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBhXG4gKiBsaWdodGJ1bGIgaW1hZ2UgYW5kIGhpbnQgY291bnRlciwgYW5kIGFkZHMgYSBjbGljayBoYW5kbGVyIHRvIHNob3dcbiAqIGEgcXRpcCBmb3IgdGhlIG5leHQgdW5zZWVuIGhpbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwcm9tcHRJY29uIC0gdGhlIHBhZ2UgZWxlbWVudCB0byBcImRlY29yYXRlXCIgd2l0aCB0aGVcbiAqICAgICAgICBsaWdodGJ1bGJcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2xpY2tUYXJnZXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gYSBTdHVkaW9BcHAgZnVuY3Rpb24gdG8gYmUgdHJlYXRlZCBhc1xuICogICAgICAgIHRoZSBcImRlZmF1bHRcIiBhY3Rpb24gd2hlbiB0aGVyZSBhcmUgbm8gdW5zZWVuIGhpbnRzLiBcbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChwcm9tcHRJY29uLCBjbGlja1RhcmdldCwgY2FsbGJhY2spIHtcbiAgdGhpcy5wcm9tcHRJY29uID0gcHJvbXB0SWNvbjtcbiAgdGhpcy51cGRhdGVMaWdodGJ1bGJEaXNwbGF5XygpO1xuICBjbGlja1RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGludHNUb1Nob3cgPSB0aGlzLmdldFVuc2VlbkhpbnRzKCk7XG4gICAgaWYgKGhpbnRzVG9TaG93Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2hvd0hpbnRfKGhpbnRzVG9TaG93WzBdLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBNb3N0bHkgYSBwYXNzdGhyb3VnaCB0byBhdXRob3JlZEhpbnRVdGlscy5yZWNvcmRVbmZpbmlzaGVkSGludC4gQWxzb1xuICogbWFya3MgdGhlIGdpdmVuIGhpbnQgYXMgc2Vlbi5cbiAqIEBwYXJhbSB7QXV0aG9yZWRIaW50fSBoaW50XG4gKi9cbkF1dGhvcmVkSGludHMucHJvdG90eXBlLnJlY29yZFVzZXJWaWV3ZWRIaW50XyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGhpbnQuYWxyZWFkeVNlZW4gPSB0cnVlO1xuICB0aGlzLnVwZGF0ZUxpZ2h0YnVsYkRpc3BsYXlfKCk7XG5cbiAgYXV0aG9yZWRIaW50VXRpbHMucmVjb3JkVW5maW5pc2hlZEhpbnQoe1xuICAgIC8vIGxldmVsIGluZm9cbiAgICBzY3JpcHRJZDogdGhpcy5zY3JpcHRJZF8sXG4gICAgbGV2ZWxJZDogdGhpcy5sZXZlbElkXyxcblxuICAgIC8vIGhpbnQgaW5mb1xuICAgIGhpbnRJZDogaGludC5oaW50SWQsXG4gICAgaGludENsYXNzOiBoaW50LmhpbnRDbGFzcyxcbiAgICBoaW50VHlwZTogaGludC5oaW50VHlwZSxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkanVzdHMgdGhlIGRpc3BsYXllZCBudW1iZXIgb2YgdW5zZWVuIGhpbnRzLiBEaW1zIHRoZSBsaWdodGJ1bGJcbiAqIGltYWdlIGlmIHRoZXJlIGFyZSBubyBoaW50cy4gT3B0aW9uYWxseSBwbGF5cyBhIHNpbXBsZSBDU1MgYW5pbWF0aW9uXG4gKiB0byBoaWdobGlnaHQgdGhlIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSBkZWZhdWx0cyB0byBmYWxzZVxuICovXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS51cGRhdGVMaWdodGJ1bGJEaXNwbGF5XyA9IGZ1bmN0aW9uIChhbmltYXRlKSB7XG4gIGFuaW1hdGUgPSBhbmltYXRlIHx8IGZhbHNlO1xuXG4gIHZhciBoaW50Q291bnQgPSB0aGlzLmdldFVuc2VlbkhpbnRzKCkubGVuZ3RoOyBcblxuICAvLyBJZiB3ZSBoYXZlIGhpbnRzIHRvIHNob3csIGJ1dCBhcmUgbm90IGluIHRoZSBET00sIGluc2VydCBvdXJzZWx2ZXNcbiAgLy8gaW50byB0aGUgRE9NLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb250ZXh0dWFsIGhpbnRzIGFwcGVhciBpbiBhXG4gIC8vIGxldmVsIHRoYXQgd2FzIGluaXRpYWxpemVkIHdpdGggbm8gaGludHMuIE5vdGUgdGhhdCB3ZSBjYW4gYmUgaW5cbiAgLy8gdGhlIERPTSBhbmQgaGF2ZSB6ZXJvIGhpbnRzIHRvIHNob3csIGFuZCB0aGF0J3MganVzdCBmaW5lLlxuICBpZiAoaGludENvdW50ID4gMCAmJiAhZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmxpZ2h0YnVsYikpIHtcbiAgICB0aGlzLnByb21wdEljb24ucGFyZW50Tm9kZS5jbGFzc05hbWUgKz0gJyBhdXRob3JlZF9oaW50cyc7XG4gICAgdGhpcy5wcm9tcHRJY29uLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubGlnaHRidWxiLCB0aGlzLnByb21wdEljb24pO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBuaW5lIGhpbnRzLCBzaW1wbHkgZGlzcGxheSBcIjkrXCJcbiAgdmFyIGhpbnRUZXh0ID0gKGhpbnRDb3VudCA+IDkpID8gXCI5K1wiIDogaGludENvdW50O1xuICBpZiAoaGludENvdW50ID09PSAwKSB7XG4gICAgdGhpcy5saWdodGJ1bGIuaW5uZXJIVE1MID0gbGlnaHRidWxiRGltU1ZHO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGlnaHRidWxiLmlubmVySFRNTCA9IGxpZ2h0YnVsYlNWRztcbiAgICB0aGlzLmxpZ2h0YnVsYi5xdWVyeVNlbGVjdG9yKCcjaGludENvdW50JykudGV4dENvbnRlbnQgPSBoaW50VGV4dDtcbiAgfVxuXG4gIHZhciBidWxiID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidWxiXCIpO1xuICBpZiAoYW5pbWF0ZSAmJiBidWxiKSB7XG4gICAgYnVsYi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FuaW1hdGUtaGludCcpO1xuICB9XG59O1xuXG5BdXRob3JlZEhpbnRzLnByb3RvdHlwZS5nZXRIaW50c0Rpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoaW50c0Rpc3BsYXkgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEhpbnRzRGlzcGxheSwge1xuICAgIGhpbnRSZXZpZXdUaXRsZTogbXNnLmhpbnRSZXZpZXdUaXRsZSgpLFxuICAgIHNlZW5IaW50czogdGhpcy5nZXRTZWVuSGludHMoKSxcbiAgICB1bnNlZW5IaW50czogdGhpcy5nZXRVbnNlZW5IaW50cygpLFxuICAgIGxpZ2h0YnVsYlNWRzogbGlnaHRidWxiU1ZHLFxuICAgIG9uVXNlclZpZXdlZEhpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0SGludCA9IHRoaXMuZ2V0VW5zZWVuSGludHMoKVswXTtcbiAgICAgIHRoaXMucmVjb3JkVXNlclZpZXdlZEhpbnRfKG5leHRIaW50KTtcbiAgICB9LmJpbmQodGhpcylcbiAgfSk7XG5cbiAgcmV0dXJuIGhpbnRzRGlzcGxheTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGEgcXRpcCBwb3B1cCBjb250YWluaW5nIGFuIGludGVyZmFjZSB3aGljaCBnaXZlcyB0aGUgdXNlciB0aGVcbiAqIG9wdGlvbiBvZiB2aWV3aW5nIHRoZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBsZXZlbCAoYWxvbmcgd2l0aCBhbGxcbiAqIHByZXZpb3VzbHktdmlld2VkIGhpbnRzKSBvciB2aWV3aW5nIGEgbmV3IGhpbnQuXG4gKiBAcGFyYW0ge0F1dGhvcmVkSGludH0gaGludFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuQXV0aG9yZWRIaW50cy5wcm90b3R5cGUuc2hvd0hpbnRfID0gZnVuY3Rpb24gKGhpbnQsIGNhbGxiYWNrKSB7XG4gICQoJyNwcm9tcHQtaWNvbicpLnF0aXAoe1xuICAgIGNvbnRlbnQ6IHtcbiAgICAgIHRleHQ6IGZ1bmN0aW9uKGh0bWwsIGFwaSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEhpbnRTZWxlY3QsIHtcbiAgICAgICAgICBzaG93SW5zdHJ1Y3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcGkuZGVzdHJveSgpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgc2hvd0hpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChoaW50LmJsb2NrKSB7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gaGludC5jb250ZW50O1xuICAgICAgICAgICAgICB2YXIgYmxvY2tDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgYmxvY2tDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChibG9ja0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgIGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIGNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgIEJsb2NrbHkuQmxvY2tTcGFjZS5jcmVhdGVSZWFkT25seUJsb2NrU3BhY2UoYmxvY2tDb250YWluZXIsIGhpbnQuYmxvY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBpLnNldCgnY29udGVudC50ZXh0JywgaGludC5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoYXBpLmVsZW1lbnRzLmNvbnRlbnQpLmZpbmQoJ2ltZycpLm9uKCdsb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgYXBpLnJlcG9zaXRpb24oZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkVXNlclZpZXdlZEhpbnRfKGhpbnQpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUmVhY3QucmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGJ1dHRvbjogJCgnPGRpdiBjbGFzcz1cInRvb2x0aXAteC1jbG9zZVwiLz4nKVxuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNsYXNzZXM6IFwiY2RvLXF0aXBzXCIsXG4gICAgICB0aXA6IHtcbiAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICB9XG4gICAgfSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgbXk6IFwiYm90dG9tIGxlZnRcIixcbiAgICAgIGF0OiBcInRvcCByaWdodFwiXG4gICAgfSxcbiAgICBoaWRlOiB7XG4gICAgICBldmVudDogJ3VuZm9jdXMnXG4gICAgfSxcbiAgICBzaG93OiBmYWxzZSAvLyBkb24ndCBzaG93IG9uIG1vdXNlb3ZlclxuICB9KS5xdGlwKCdzaG93Jyk7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJzxzdmcgdmVyc2lvbj1cIjEuMVwiXFxuXHQgaWQ9XCJzdmczMDEzXCIgaW5rc2NhcGU6dmVyc2lvbj1cIjAuNDguMy4xIHI5ODg2XCIgc29kaXBvZGk6ZG9jbmFtZT1cImxpZ2h0X2J1bGJfZm9udF9hd2Vzb21lLnN2Z1wiIHhtbG5zOmlua3NjYXBlPVwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVwiIHhtbG5zOnJkZj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIiB4bWxuczpzb2RpcG9kaT1cImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXCIgeG1sbnM6Y2M9XCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcIiB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOmRjPVwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIlxcblx0IHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHdpZHRoPVwiNDBweFwiIGhlaWdodD1cIjQwcHhcIlxcblx0IHZpZXdCb3g9XCIwIDAgNjEyIDc5MlwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA2MTIgNzkyXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG48c29kaXBvZGk6bmFtZWR2aWV3ICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cIjBcIiBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XCI2NDBcIiBpbmtzY2FwZTpwYWdlc2hhZG93PVwiMlwiIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XCI0ODBcIiBpbmtzY2FwZTp3aW5kb3cteD1cIjBcIiBpbmtzY2FwZTp3aW5kb3cteT1cIjI1XCIgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cIjBcIiBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVwic3ZnMzAxM1wiIGd1aWRldG9sZXJhbmNlPVwiMTBcIiBwYWdlY29sb3I9XCIjZmZmZmZmXCIgb2JqZWN0dG9sZXJhbmNlPVwiMTBcIiBncmlkdG9sZXJhbmNlPVwiMTBcIiBzaG93Z3JpZD1cImZhbHNlXCIgaW5rc2NhcGU6Y3g9XCI4OTZcIiBpbmtzY2FwZTpjeT1cIjg5NlwiIGJvcmRlcm9wYWNpdHk9XCIxXCIgYm9yZGVyY29sb3I9XCIjNjY2NjY2XCIgaW5rc2NhcGU6em9vbT1cIjAuMTMxNjk2NDNcIiBpZD1cIm5hbWVkdmlldzMwMTlcIj5cXG5cdDwvc29kaXBvZGk6bmFtZWR2aWV3PlxcbjxwYXRoIGZpbGw9XCIjQzlDOUM5XCIgZD1cIk00NTMuNzc1LDM1My4xNTZjMCwyNC4wMTItNTcuMTg5LDEyOC45NDItNjEuNDE0LDEzMi4yNjVjLTEyLjM4NCw5Ljc0MS00OC41MTQsMTUuMzE4LTgyLjg2OSwxNi41MThcXG5cdGMtOC4zNjIsMC4yOTItMTYuNjE5LDAuMzI1LTI0LjQwMywwLjA5NmMtMjAuNzE2LTAuNjExLTM4LjA4MS0zLjA3OS00NS4xNTUtNy40NjRjLTYuODk2LTQuMjc0LTc0LjQ3Ny0xMTkuMjQtNzQuNDc3LTE0MS40MTVcXG5cdGMwLTg5LjE5NSw2NC41NDItMTYxLjUwMiwxNDQuMTU5LTE2MS41MDJTNDUzLjc3NSwyNjMuOTYxLDQ1My43NzUsMzUzLjE1NnpcIi8+XFxuPGcgaWQ9XCJnMzAxNVwiIHRyYW5zZm9ybT1cIm1hdHJpeCgxLDAsMCwtMSwzNzkuNjYxMDIsMTI5My4wMTY5KVwiPlxcblx0PHBhdGggaWQ9XCJwYXRoMzAxN1wiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XCIwXCIgZmlsbD1cIiM1RDVENURcIiBkPVwiTTcuMzU3LDk4MC44NTdjMC0yLjk2LTEuMDgxLTUuNTIxLTMuMjQ0LTcuNjg0XFxuXHRcdHMtNC43MjQtMy4yNDQtNy42ODQtMy4yNDRzLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NGMwLDEwLjQ3My02LjE0NywxOC41NTYtMTguNDQyLDI0LjI0OFxcblx0XHRjLTEyLjI5NSw1LjY5Mi0yNC4zNjIsOC41MzgtMzYuMjAxLDguNTM4Yy0yLjk2LDAtNS41MjEsMS4wODEtNy42ODQsMy4yNDRzLTMuMjQ0LDQuNzI0LTMuMjQ0LDcuNjg0XFxuXHRcdGMwLDIuOTYsMS4wODEsNS41MjEsMy4yNDQsNy42ODRzNC43MjQsMy4yNDQsNy42ODQsMy4yNDRjMTEuMzg0LDAsMjIuNzExLTEuODIxLDMzLjk4MS01LjQ2NHMyMS4xNzQtOS43OSwyOS43MTItMTguNDQyXFxuXHRcdFM3LjM1Nyw5OTIuNjk2LDcuMzU3LDk4MC44NTd6IE02Miw5ODAuODU3YzAsMTYuMzkzLTMuOTI3LDMxLjY0Ny0xMS43ODIsNDUuNzYzcy0xOC4xLDI1LjY3MS0zMC43MzcsMzQuNjY0XFxuXHRcdHMtMjYuNjM4LDE2LjA1MS00Mi4wMDcsMjEuMTc0cy0zMC45MDcsNy42ODQtNDYuNjE3LDcuNjg0cy0zMS4yNDktMi41NjEtNDYuNjE3LTcuNjg0cy0yOS4zNzEtMTIuMTgxLTQyLjAwNy0yMS4xNzRcXG5cdFx0Yy0xMi42MzYtOC45OTMtMjIuODgyLTIwLjU0OC0zMC43MzctMzQuNjY0Yy03Ljg1NS0xNC4xMTYtMTEuNzgyLTI5LjM3MS0xMS43ODItNDUuNzYzYzAtMjIuOTk2LDcuNzQxLTQzLjQ4NywyMy4yMjMtNjEuNDczXFxuXHRcdGMyLjI3Ny0yLjUwNCw1Ljc0OS02LjI2MSwxMC40MTYtMTEuMjdjNC42NjctNS4wMDksOC4xNC04Ljc2NiwxMC40MTYtMTEuMjdjMjkuMTQzLTM0LjgzNSw0NS4xOTQtNjguNzU5LDQ4LjE1NC0xMDEuNzcyaDc3Ljg2Nlxcblx0XHRjMi45NiwzMy4wMTMsMTkuMDExLDY2LjkzOCw0OC4xNTQsMTAxLjc3MmMyLjI3NywyLjUwNCw1Ljc0OSw2LjI2MSwxMC40MTYsMTEuMjdzOC4xNCw4Ljc2NiwxMC40MTYsMTEuMjdcXG5cdFx0QzU0LjI1OSw5MzcuMzcsNjIsOTU3Ljg2Miw2Miw5ODAuODU3eiBNMTA1LjcxNCw5ODAuODU3YzAtMzUuMjktMTEuNzI1LTY1Ljc5OS0zNS4xNzYtOTEuNTI3XFxuXHRcdGMtMTAuMjQ2LTExLjE1Ni0xOC43MjctMjEuMDYtMjUuNDQzLTI5LjcxMnMtMTMuNDktMTkuNTIzLTIwLjMyLTMyLjYxNWMtNi44My0xMy4wOTItMTAuNzAxLTI1LjMyOS0xMS42MTItMzYuNzEzXFxuXHRcdGMxMC43MDEtNi4zNzUsMTYuMDUxLTE1LjcxLDE2LjA1MS0yOC4wMDRjMC04LjQyNC0yLjg0Ni0xNS43MS04LjUzOC0yMS44NTdjNS42OTItNi4xNDcsOC41MzgtMTMuNDMzLDguNTM4LTIxLjg1N1xcblx0XHRjMC0xMS44MzktNS4xMjMtMjEuMDYtMTUuMzY4LTI3LjY2M2MyLjk2LTUuMjM3LDQuNDQtMTAuNTg3LDQuNDQtMTYuMDUxYzAtMTAuNDczLTMuNTg2LTE4LjU1Ni0xMC43NTgtMjQuMjQ4XFxuXHRcdHMtMTUuOTk0LTguNTM4LTI2LjQ2OC04LjUzOGMtNC41NTQtMTAuMDE4LTExLjM4NC0xNy45ODctMjAuNDkxLTIzLjkwNmMtOS4xMDctNS45Mi0xOS4wMTEtOC44NzktMjkuNzEyLTguODc5XFxuXHRcdGMtMTAuNzAxLDAtMjAuNjA1LDIuOTYtMjkuNzEyLDguODc5Yy05LjEwNyw1LjkyLTE1LjkzOCwxMy44ODgtMjAuNDkxLDIzLjkwNmMtMTAuNDczLDAtMTkuMjk2LDIuODQ2LTI2LjQ2OCw4LjUzOFxcblx0XHRzLTEwLjc1OCwxMy43NzUtMTAuNzU4LDI0LjI0OGMwLDUuNDY0LDEuNDgsMTAuODE1LDQuNDQsMTYuMDUxYy0xMC4yNDYsNi42MDMtMTUuMzY4LDE1LjgyNC0xNS4zNjgsMjcuNjYzXFxuXHRcdGMwLDguNDI0LDIuODQ2LDE1LjcxLDguNTM4LDIxLjg1N2MtNS42OTIsNi4xNDctOC41MzgsMTMuNDMzLTguNTM4LDIxLjg1N2MwLDEyLjI5NSw1LjM1LDIxLjYyOSwxNi4wNTEsMjguMDA0XFxuXHRcdGMtMC45MTEsMTEuMzg0LTQuNzgxLDIzLjYyMi0xMS42MTIsMzYuNzEzYy02LjgzLDEzLjA5MS0xMy42MDQsMjMuOTYzLTIwLjMyLDMyLjYxNXMtMTUuMTk4LDE4LjU1Ni0yNS40NDMsMjkuNzEyXFxuXHRcdEMtMjMyLjI3NSw5MTUuMDU4LTI0NCw5NDUuNTY3LTI0NCw5ODAuODU3YzAsMjIuNTQsNS4wNjYsNDMuNTQ0LDE1LjE5OCw2My4wMWMxMC4xMzIsMTkuNDY3LDIzLjQ1MSwzNS42MzIsMzkuOTU4LDQ4LjQ5Nlxcblx0XHRjMTYuNTA3LDEyLjg2NCwzNS4xNzYsMjIuOTk1LDU2LjAwOSwzMC4zOTVzNDIuMDY0LDExLjA5OSw2My42OTMsMTEuMDk5czQyLjg2LTMuNyw2My42OTMtMTEuMDk5czM5LjUwMi0xNy41MzEsNTYuMDA5LTMwLjM5NVxcblx0XHRjMTYuNTA3LTEyLjg2NCwyOS44MjYtMjkuMDI5LDM5Ljk1OC00OC40OTZDMTAwLjY0OCwxMDI0LjQwMSwxMDUuNzE0LDEwMDMuMzk3LDEwNS43MTQsOTgwLjg1N3pcIi8+XFxuPC9nPlxcbjxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xNTM4Ljc3NS0xODcuODQ0YzAsMjQuMDEyLTU3LjE4OSwxMjguOTQyLTYxLjQxNCwxMzIuMjY1Yy0xMi4zODQsOS43NDEtNDguNTE0LDE1LjMxOC04Mi44NjksMTYuNTE4XFxuXHRjLTguMzYyLDAuMjkyLTE2LjYxOSwwLjMyNS0yNC40MDMsMC4wOTZjLTIwLjcxNi0wLjYxMS0zOC4wODEtMy4wNzktNDUuMTU1LTcuNDY0Yy02Ljg5Ni00LjI3NC03NC40NzctMTE5LjI0LTc0LjQ3Ny0xNDEuNDE1XFxuXHRjMC04OS4xOTUsNjQuNTQyLTE2MS41MDIsMTQ0LjE1OS0xNjEuNTAyUzE1MzguNzc1LTI3Ny4wMzksMTUzOC43NzUtMTg3Ljg0NHpcIi8+XFxuPGcgaWQ9XCJnMzAxNV8xX1wiIHRyYW5zZm9ybT1cIm1hdHJpeCgxLDAsMCwtMSwzNzkuNjYxMDIsMTI5My4wMTY5KVwiPlxcblx0PHBhdGggaWQ9XCJwYXRoMzAxN18xX1wiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XCIwXCIgZmlsbD1cIiM1RDVENURcIiBkPVwiTTEwOTIuMzU3LDE1MjEuODU3YzAtMi45Ni0xLjA4Mi01LjUyMS0zLjI0NC03LjY4NFxcblx0XHRjLTIuMTYzLTIuMTYzLTQuNzI0LTMuMjQ1LTcuNjg0LTMuMjQ1cy01LjUyMSwxLjA4Mi03LjY4NCwzLjI0NWMtMi4xNjMsMi4xNjMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRcXG5cdFx0YzAsMTAuNDczLTYuMTQ3LDE4LjU1Ni0xOC40NDIsMjQuMjQ4Yy0xMi4yOTUsNS42OTItMjQuMzYyLDguNTM4LTM2LjIwMSw4LjUzOGMtMi45NiwwLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0XFxuXHRcdGMtMi4xNjMsMi4xNjMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRjMCwyLjk2LDEuMDgxLDUuNTIxLDMuMjQ0LDcuNjg0YzIuMTYzLDIuMTYzLDQuNzI0LDMuMjQ0LDcuNjg0LDMuMjQ0XFxuXHRcdGMxMS4zODQsMCwyMi43MTEtMS44MjEsMzMuOTgxLTUuNDY0YzExLjI3LTMuNjQzLDIxLjE3NC05Ljc5LDI5LjcxMi0xOC40NDJcXG5cdFx0QzEwODguMDg4LDE1NDMuOTQyLDEwOTIuMzU3LDE1MzMuNjk2LDEwOTIuMzU3LDE1MjEuODU3eiBNMTE0NywxNTIxLjg1N2MwLDE2LjM5My0zLjkyNywzMS42NDctMTEuNzgyLDQ1Ljc2M1xcblx0XHRzLTE4LjEsMjUuNjcxLTMwLjczNywzNC42NjRjLTEyLjYzNiw4Ljk5My0yNi42MzgsMTYuMDUxLTQyLjAwNywyMS4xNzRzLTMwLjkwNyw3LjY4NC00Ni42MTcsNy42ODRzLTMxLjI0OS0yLjU2MS00Ni42MTctNy42ODRcXG5cdFx0Yy0xNS4zNjgtNS4xMjMtMjkuMzcxLTEyLjE4MS00Mi4wMDctMjEuMTc0cy0yMi44ODItMjAuNTQ4LTMwLjczNy0zNC42NjRzLTExLjc4Mi0yOS4zNzEtMTEuNzgyLTQ1Ljc2M1xcblx0XHRjMC0yMi45OTUsNy43NDEtNDMuNDg3LDIzLjIyMy02MS40NzNjMi4yNzctMi41MDUsNS43NDktNi4yNjEsMTAuNDE2LTExLjI3czguMTM5LTguNzY2LDEwLjQxNi0xMS4yN1xcblx0XHRjMjkuMTQzLTM0LjgzNSw0NS4xOTQtNjguNzU5LDQ4LjE1NC0xMDEuNzcyaDc3Ljg2NmMyLjk2LDMzLjAxMywxOS4wMTEsNjYuOTM4LDQ4LjE1NCwxMDEuNzcyXFxuXHRcdGMyLjI3NywyLjUwNSw1Ljc0OSw2LjI2MSwxMC40MTYsMTEuMjdjNC42NjcsNS4wMDksOC4xNCw4Ljc2NiwxMC40MTYsMTEuMjdDMTEzOS4yNTksMTQ3OC4zNywxMTQ3LDE0OTguODYyLDExNDcsMTUyMS44NTd6XFxuXHRcdCBNMTE5MC43MTQsMTUyMS44NTdjMC0zNS4yOS0xMS43MjUtNjUuNzk5LTM1LjE3Ni05MS41MjdjLTEwLjI0NS0xMS4xNTYtMTguNzI3LTIxLjA2LTI1LjQ0My0yOS43MTJcXG5cdFx0Yy02LjcxNy04LjY1Mi0xMy40OS0xOS41MjQtMjAuMzItMzIuNjE1Yy02LjgzLTEzLjA5Mi0xMC43MDEtMjUuMzI5LTExLjYxMi0zNi43MTNjMTAuNzAxLTYuMzc1LDE2LjA1MS0xNS43MSwxNi4wNTEtMjguMDA1XFxuXHRcdGMwLTguNDI0LTIuODQ2LTE1LjcxLTguNTM4LTIxLjg1N2M1LjY5Mi02LjE0Nyw4LjUzOC0xMy40MzMsOC41MzgtMjEuODU3YzAtMTEuODM5LTUuMTIzLTIxLjA2LTE1LjM2OC0yNy42NjNcXG5cdFx0YzIuOTYtNS4yMzcsNC40NC0xMC41ODcsNC40NC0xNi4wNTFjMC0xMC40NzMtMy41ODYtMTguNTU2LTEwLjc1OC0yNC4yNDhjLTcuMTcyLTUuNjkyLTE1Ljk5NS04LjUzOC0yNi40NjgtOC41MzhcXG5cdFx0Yy00LjU1NC0xMC4wMTgtMTEuMzg0LTE3Ljk4Ny0yMC40OTEtMjMuOTA2Yy05LjEwNy01LjkyLTE5LjAxMS04Ljg3OS0yOS43MTItOC44NzljLTEwLjcwMSwwLTIwLjYwNSwyLjk2LTI5LjcxMiw4Ljg3OVxcblx0XHRjLTkuMTA3LDUuOTItMTUuOTM4LDEzLjg4OC0yMC40OTEsMjMuOTA2Yy0xMC40NzMsMC0xOS4yOTYsMi44NDYtMjYuNDY4LDguNTM4Yy03LjE3Miw1LjY5Mi0xMC43NTgsMTMuNzc1LTEwLjc1OCwyNC4yNDhcXG5cdFx0YzAsNS40NjQsMS40OCwxMC44MTUsNC40NCwxNi4wNTFjLTEwLjI0NSw2LjYwMy0xNS4zNjgsMTUuODI0LTE1LjM2OCwyNy42NjNjMCw4LjQyNCwyLjg0NiwxNS43MSw4LjUzOCwyMS44NTdcXG5cdFx0Yy01LjY5Miw2LjE0Ny04LjUzOCwxMy40MzMtOC41MzgsMjEuODU3YzAsMTIuMjk1LDUuMzUsMjEuNjMsMTYuMDUxLDI4LjAwNWMtMC45MTEsMTEuMzg0LTQuNzgxLDIzLjYyMi0xMS42MTIsMzYuNzEzXFxuXHRcdGMtNi44MywxMy4wOTEtMTMuNjA0LDIzLjk2My0yMC4zMiwzMi42MTVjLTYuNzE3LDguNjUyLTE1LjE5OCwxOC41NTYtMjUuNDQzLDI5LjcxMmMtMjMuNDUxLDI1LjcyOC0zNS4xNzYsNTYuMjM3LTM1LjE3Niw5MS41MjdcXG5cdFx0YzAsMjIuNTQsNS4wNjYsNDMuNTQ0LDE1LjE5OCw2My4wMWMxMC4xMzIsMTkuNDY3LDIzLjQ1MSwzNS42MzIsMzkuOTU4LDQ4LjQ5NmMxNi41MDcsMTIuODY0LDM1LjE3NiwyMi45OTUsNTYuMDA5LDMwLjM5NVxcblx0XHRzNDIuMDY0LDExLjA5OSw2My42OTMsMTEuMDk5YzIxLjYyOSwwLDQyLjg2LTMuNyw2My42OTMtMTEuMDk5YzIwLjgzMy03LjQsMzkuNTAyLTE3LjUzMSw1Ni4wMDktMzAuMzk1XFxuXHRcdGMxNi41MDctMTIuODY0LDI5LjgyNi0yOS4wMjksMzkuOTU4LTQ4LjQ5NkMxMTg1LjY0OCwxNTY1LjQwMSwxMTkwLjcxNCwxNTQ0LjM5NywxMTkwLjcxNCwxNTIxLjg1N3pcIi8+XFxuPC9nPlxcbjxnPlxcblx0PGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjE1NTguNTgyXCIgeTE9XCItMzMyLjlcIiB4Mj1cIjE2NDUuNTc4XCIgeTI9XCItMzgxLjg0XCIvPlxcblx0PHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTE1NTguMTQxLTMzMy42ODVjMCwwLDEuMjI1LTEuMDAzLDMuMzk2LTIuNzExYzEuMDgtMC44NjQsMi40MDItMS44OTQsMy45MjUtMy4wNjNcXG5cdFx0YzEuNTI1LTEuMTY3LDMuMjI3LTIuNTE0LDUuMTE3LTMuOTI3YzEuODg3LTEuNDE4LDMuOTMxLTIuOTU0LDYuMDkyLTQuNTc4YzIuMTU4LTEuNjMyLDQuNDYzLTMuMyw2LjgzMS01LjA1NVxcblx0XHRjMi4zODYtMS43MjMsNC44NDMtMy41MTksNy4zNzItNS4yODVjMi41MTUtMS43OTEsNS4xMDQtMy41NTIsNy42NzctNS4zNDFjMi41NzgtMS43NzgsNS4wNjUtMy43MjEsNy41MDMtNS42NDhcXG5cdFx0YzEuMjI4LTAuOTQ4LDIuNDM2LTEuOTA3LDMuNjY1LTIuNzkyYzEuMjMxLTAuODgxLDIuNDc4LTEuNjk1LDMuNzM2LTIuNDQyYzIuNTI3LTEuNDcyLDUuMTItMi42MjksNy42NTYtMy41ODdcXG5cdFx0YzIuNTI5LTAuOTcxLDQuOTk4LTEuNzUxLDcuMzMxLTIuMzc3YzQuNjU2LTEuMjY4LDguNzk3LTEuODU4LDExLjgxLTIuMDY5YzEuNTA0LTAuMTA5LDIuNzE4LTAuMTM4LDMuNTcyLTAuMTExXFxuXHRcdGMwLjg0MywwLjAwNywxLjMxMywwLjA0NywxLjMxMywwLjA0N2wwLjg4MiwxLjU2OWMwLDAtMC4yMSwwLjQyMi0wLjY0MSwxLjE0NmMtMC40MiwwLjc0NC0xLjA3NSwxLjc2Ni0xLjk1LDIuOTk1XFxuXHRcdGMtMS43NDUsMi40NjUtNC40LDUuNjk4LTcuOSw5LjAxOWMtMS43NDYsMS42NjktMy42OTQsMy4zNzQtNS44MzgsNS4wMzFjLTIuMTM2LDEuNjcxLTQuNDcxLDMuMjg1LTcuMDQxLDQuNjgxXFxuXHRcdGMtMS4yOTEsMC42ODctMi42MzUsMS4zMzEtNC4wMjcsMS45MjVjLTEuMzk0LDAuNTkxLTIuODQxLDEuMTI2LTQuMjg5LDEuNjgzYy0yLjkxNCwxLjA4My01Ljg2NSwyLjItOC43MjMsMy40OFxcblx0XHRjLTIuODY1LDEuMjctNS43MTMsMi41NjgtOC41NSwzLjc4OGMtMi44MjMsMS4yNDUtNS42MzMsMi40MTItOC4zNDUsMy41NTZjLTIuNzI5LDEuMTEzLTUuMzUyLDIuMjE3LTcuODY3LDMuMjEzXFxuXHRcdGMtMi41MTEsMS4wMDQtNC44ODUsMS45NTMtNy4wNzYsMi44M2MtMi4xODgsMC44ODEtNC4yMjQsMS42MzctNi4wMTMsMi4zMzRjLTEuNzksMC42OTUtMy4zNTcsMS4yOS00LjY1NiwxLjc2NFxcblx0XHRjLTIuNTg3LDAuOTY4LTQuMDgsMS40OTQtNC4wOCwxLjQ5NEwxNTU4LjE0MS0zMzMuNjg1elwiLz5cXG48L2c+XFxuPGc+XFxuXHQ8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTU3Ny4zNDhcIiB5MT1cIi0xMzAuOTkyXCIgeDI9XCIxNjc0LjUwOVwiIHkyPVwiLTEwOC4xMTdcIi8+XFxuXHQ8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTU3Ny41NTUtMTMxLjg2OGMwLDAsMS41ODEsMC4wOTEsNC4zMzUsMC4zMDNjMS4zOCwwLjA5NSwzLjA1LDAuMjMyLDQuOTYyLDAuNDAzXFxuXHRcdGMxLjkxMiwwLjE3Myw0LjA3NywwLjMzNCw2LjQyNCwwLjU3NGMyLjM0OCwwLjIzNCw0Ljg5MiwwLjQ4Nyw3LjU4MywwLjc1NWMyLjY5MywwLjI1OSw1LjUxOSwwLjU5Miw4LjQ1LDAuOTA0XFxuXHRcdGMyLjkyMywwLjM0Nyw1Ljk0NywwLjY4OCw5LjAwNCwxLjEwMWMzLjA2NCwwLjM4NCw2LjE2MSwwLjg0MSw5LjI2NiwxLjI2NmMzLjEwMiwwLjQzNyw2LjI0NiwwLjY5MSw5LjM0NiwwLjkyMlxcblx0XHRjMS41NDYsMC4xMzMsMy4wODQsMC4yNDYsNC41ODgsMC40MjZjMS41MDIsMC4xODUsMi45NzIsMC40Myw0LjQwMywwLjczMmMyLjg1NiwwLjYyOCw1LjU0OCwxLjUzMSw4LjA2NCwyLjU0M1xcblx0XHRjMi41MTksMC45OTgsNC44NjQsMi4wOTUsNy4wMDQsMy4yMTNjNC4yODUsMi4yMTksNy43MzIsNC41ODgsMTAuMDkzLDYuNDcyYzEuMTgxLDAuOTM4LDIuMDk0LDEuNzM4LDIuNzA0LDIuMzM3XFxuXHRcdGMwLjYxNSwwLjU3NiwwLjkzNCwwLjkyMywwLjkzNCwwLjkyM2wtMC40MTIsMS43NTJjMCwwLTAuNDQsMC4xNjktMS4yNDgsMC40MWMtMC44MTMsMC4yNjMtMS45ODcsMC41NzItMy40NjMsMC44ODVcXG5cdFx0Yy0yLjk1MywwLjYzMy03LjA5NiwxLjIxNi0xMS45MiwxLjI5Yy0yLjQxNCwwLjA0Ni01LjAwMy0wLjAxOC03LjcwMi0wLjI0OWMtMi43MDMtMC4yMTYtNS41MTUtMC42MDktOC4zNTEtMS4zMjJcXG5cdFx0Yy0xLjQxNi0wLjM2OC0yLjg0LTAuODA0LTQuMjY3LTEuMzA5Yy0xLjQyNi0wLjUwOS0yLjg1My0xLjA5NS00LjI5Ni0xLjY2NWMtMi44NzgtMS4xNzYtNS44MDUtMi4zNTEtOC43NzYtMy4zNDRcXG5cdFx0Yy0yLjk2OC0xLjAwNC01Ljk0My0xLjk3Ny04Ljg1Ny0zYy0yLjkyLTAuOTk1LTUuNzc5LTIuMDM4LTguNTQ5LTMuMDMyYy0yLjc2Mi0xLjAyOS01LjQ0LTEuOTkyLTcuOTY1LTIuOTYxXFxuXHRcdGMtMi41MjgtMC45NjEtNC45MTgtMS44NjktNy4xMjQtMi43MDhjLTIuMjA3LTAuODMzLTQuMjE3LTEuNjU1LTYuMDA1LTIuMzUzYy0xLjc4OC0wLjctMy4zNDQtMS4zMjMtNC42MjEtMS44NTRcXG5cdFx0Yy0yLjU1OS0xLjAzOS00LjAxNS0xLjY2My00LjAxNS0xLjY2M0wxNTc3LjU1NS0xMzEuODY4elwiLz5cXG48L2c+XFxuPGc+XFxuXHQ8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTU4Ny41NTlcIiB5MT1cIi0yMzkuM1wiIHgyPVwiMTY4Ny4zN1wiIHkyPVwiLTI0MC4zMTVcIi8+XFxuXHQ8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTU4Ny41NS0yNDAuMmMwLDAsMS41NTctMC4yODksNC4yODItMC43NDJjMS4zNjItMC4yMzcsMy4wMTctMC41MDQsNC45MTUtMC43OTVcXG5cdFx0YzEuODk4LTAuMjg5LDQuMDM5LTAuNjUsNi4zNzUtMC45NzljMi4zMzYtMC4zMzQsNC44NjctMC42OTcsNy41NDQtMS4wOGMyLjY3Ny0wLjM5Miw1LjUtMC43NDQsOC40MjEtMS4xNDJcXG5cdFx0YzIuOTIxLTAuMzYyLDUuOTM5LTAuNzUzLDkuMDA2LTEuMDg0YzMuMDY3LTAuMzU5LDYuMTgzLTAuNjU2LDkuMjk5LTAuOTg1YzMuMTE2LTAuMzE3LDYuMjMtMC44MjMsOS4yOTYtMS4zMzlcXG5cdFx0YzEuNTMzLTAuMjQsMy4wNTMtMC40OTksNC41NTYtMC42ODNjMS41MDMtMC4xOCwyLjk4OS0wLjI5Myw0LjQ1LTAuMzQyYzIuOTI0LTAuMDczLDUuNzUzLDAuMTYsOC40MzgsMC41NDJcXG5cdFx0YzIuNjg0LDAuMzY2LDUuMjI0LDAuODcxLDcuNTY5LDEuNDQ2YzQuNjkxLDEuMTMsOC42MDUsMi42MDcsMTEuMzQ3LDMuODcyYzEuMzcxLDAuNjI5LDIuNDQ5LDEuMTg3LDMuMTg1LDEuNjIyXFxuXHRcdGMwLjczNSwwLjQxMiwxLjEyOCwwLjY3MywxLjEyOCwwLjY3M2wwLjAxOCwxLjhjMCwwLTAuMzg3LDAuMjY5LTEuMTE0LDAuNjk2Yy0wLjcyNiwwLjQ1LTEuNzkzLDEuMDMxLTMuMTUxLDEuNjg3XFxuXHRcdGMtMi43MTYsMS4zMjEtNi42LDIuODc3LTExLjI2Niw0LjEwMmMtMi4zMzMsMC42MjItNC44NjIsMS4xNzktNy41MzksMS41OTljLTIuNjc2LDAuNDM2LTUuNSwwLjcyNy04LjQyNSwwLjcxM1xcblx0XHRjLTEuNDYyLTAuMDE5LTIuOTUtMC4xMDItNC40NTYtMC4yNTFjLTEuNTA2LTAuMTUzLTMuMDMyLTAuMzgxLTQuNTY5LTAuNTljLTMuMDc1LTAuNDU0LTYuMTk5LTAuODk1LTkuMzIxLTEuMTQ5XFxuXHRcdGMtMy4xMjItMC4yNjYtNi4yNDQtMC40OTktOS4zMTgtMC43OTZjLTMuMDczLTAuMjY4LTYuMDk5LTAuNTk4LTkuMDI2LTAuOWMtMi45MjgtMC4zMzgtNS43NTgtMC42MzQtOC40NDItMC45NzFcXG5cdFx0Yy0yLjY4NC0wLjMyOS01LjIyMi0wLjYzOS03LjU2NC0wLjkyNmMtMi4zNDMtMC4yODEtNC40OS0wLjU5OS02LjM5NC0wLjg0OWMtMS45MDMtMC4yNTMtMy41NjMtMC40ODYtNC45My0wLjY5NVxcblx0XHRjLTIuNzM0LTAuMzk3LTQuMjk2LTAuNjU1LTQuMjk2LTAuNjU1TDE1ODcuNTUtMjQwLjJ6XCIvPlxcbjwvZz5cXG48Zz5cXG5cdDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMjIwLjY2MVwiIHkxPVwiLTMyOC4yMzZcIiB4Mj1cIjExMzMuNjY1XCIgeTI9XCItMzc3LjE3NlwiLz5cXG5cdDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMjIwLjIyLTMyNy40NTJjMCwwLTEuNDkzLTAuNTI2LTQuMDgtMS40OTRjLTEuMjk5LTAuNDc0LTIuODY2LTEuMDY5LTQuNjU2LTEuNzY0XFxuXHRcdGMtMS43ODktMC42OTctMy44MjQtMS40NTMtNi4wMTMtMi4zMzRjLTIuMTkxLTAuODc2LTQuNTY1LTEuODI2LTcuMDc2LTIuODNjLTIuNTE1LTAuOTk2LTUuMTM4LTIuMS03Ljg2Ny0zLjIxM1xcblx0XHRjLTIuNzEyLTEuMTQ0LTUuNTIyLTIuMzEyLTguMzQ1LTMuNTU2Yy0yLjgzNy0xLjIyLTUuNjg2LTIuNTE4LTguNTUtMy43ODhjLTIuODU5LTEuMjgtNS44MS0yLjM5Ny04LjcyMy0zLjQ4XFxuXHRcdGMtMS40NDgtMC41NTctMi44OTUtMS4wOTItNC4yODktMS42ODNjLTEuMzkyLTAuNTk0LTIuNzM2LTEuMjM4LTQuMDI3LTEuOTI1Yy0yLjU3LTEuMzk2LTQuOTA1LTMuMDEtNy4wNDEtNC42ODFcXG5cdFx0Yy0yLjE0My0xLjY1Ny00LjA5Mi0zLjM2My01LjgzOC01LjAzMWMtMy41LTMuMzItNi4xNTUtNi41NTQtNy45LTkuMDE5Yy0wLjg3NS0xLjIyOS0xLjUzLTIuMjUxLTEuOTUtMi45OTVcXG5cdFx0Yy0wLjQzMS0wLjcyNC0wLjY0MS0xLjE0Ni0wLjY0MS0xLjE0NmwwLjg4My0xLjU2OWMwLDAsMC40Ny0wLjA0LDEuMzEzLTAuMDQ3YzAuODU0LTAuMDI3LDIuMDY4LDAuMDAyLDMuNTczLDAuMTExXFxuXHRcdGMzLjAxMywwLjIxMSw3LjE1NSwwLjgwMSwxMS44MSwyLjA2OWMyLjMzMiwwLjYyNSw0LjgwMiwxLjQwNiw3LjMzMSwyLjM3N2MyLjUzNywwLjk1OCw1LjEyOSwyLjExNSw3LjY1NiwzLjU4N1xcblx0XHRjMS4yNTgsMC43NDYsMi41MDUsMS41NjEsMy43MzYsMi40NDJjMS4yMjksMC44ODUsMi40MzcsMS44NDQsMy42NjUsMi43OTJjMi40MzgsMS45MjgsNC45MjUsMy44Nyw3LjUwMyw1LjY0OFxcblx0XHRjMi41NzMsMS43ODksNS4xNjEsMy41NDksNy42NzcsNS4zNDFjMi41MywxLjc2Niw0Ljk4NiwzLjU2Miw3LjM3Miw1LjI4NWMyLjM2OCwxLjc1NSw0LjY3MywzLjQyMyw2LjgzMSw1LjA1NVxcblx0XHRjMi4xNjIsMS42MjUsNC4yMDYsMy4xNiw2LjA5Miw0LjU3OGMxLjg4OSwxLjQxMywzLjU5MiwyLjc2LDUuMTE2LDMuOTI3YzEuNTIzLDEuMTY5LDIuODQ1LDIuMTk5LDMuOTI1LDMuMDYzXFxuXHRcdGMyLjE3MSwxLjcwOCwzLjM5NiwyLjcxMSwzLjM5NiwyLjcxMUwxMjIwLjIyLTMyNy40NTJ6XCIvPlxcbjwvZz5cXG48Zz5cXG5cdDxsaW5lIGZpbGw9XCIjRUZCODM0XCIgeDE9XCIxMjA1Ljg5NVwiIHkxPVwiLTEyOS4zMjhcIiB4Mj1cIjExMDguNzM0XCIgeTI9XCItMTA2LjQ1M1wiLz5cXG5cdDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk0xMjA2LjEwMS0xMjguNDUyYzAsMC0xLjQ1NSwwLjYyMy00LjAxNSwxLjY2M2MtMS4yNzcsMC41My0yLjgzMywxLjE1My00LjYyMSwxLjg1NFxcblx0XHRjLTEuNzg4LDAuNjk4LTMuNzk4LDEuNTItNi4wMDUsMi4zNTNjLTIuMjA2LDAuODM4LTQuNTk2LDEuNzQ3LTcuMTI0LDIuNzA4Yy0yLjUyNiwwLjk2OS01LjIwMywxLjkzMi03Ljk2NSwyLjk2MVxcblx0XHRjLTIuNzcsMC45OTMtNS42MjksMi4wMzctOC41NDksMy4wMzJjLTIuOTE0LDEuMDIzLTUuODg5LDEuOTk2LTguODU3LDNjLTIuOTcxLDAuOTkzLTUuODk5LDIuMTY5LTguNzc2LDMuMzQ0XFxuXHRcdGMtMS40NDMsMC41Ny0yLjg3LDEuMTU2LTQuMjk2LDEuNjY1Yy0xLjQyNywwLjUwNS0yLjg1MiwwLjk0MS00LjI2NywxLjMwOWMtMi44MzYsMC43MTMtNS42NDgsMS4xMDUtOC4zNTEsMS4zMjFcXG5cdFx0Yy0yLjcsMC4yMzEtNS4yODgsMC4yOTUtNy43MDMsMC4yNDljLTQuODI0LTAuMDc0LTguOTY3LTAuNjU3LTExLjkyLTEuMjljLTEuNDc2LTAuMzEzLTIuNjUtMC42MjEtMy40NjMtMC44ODVcXG5cdFx0Yy0wLjgwOC0wLjI0MS0xLjI0OC0wLjQxLTEuMjQ4LTAuNDFsLTAuNDEyLTEuNzUyYzAsMCwwLjMxOS0wLjM0NywwLjkzNC0wLjkyM2MwLjYxLTAuNTk4LDEuNTIzLTEuMzk5LDIuNzA0LTIuMzM3XFxuXHRcdGMyLjM2LTEuODg0LDUuODA4LTQuMjU0LDEwLjA5My02LjQ3MmMyLjE0LTEuMTE5LDQuNDg1LTIuMjE2LDcuMDA0LTMuMjEzYzIuNTE2LTEuMDEyLDUuMjA3LTEuOTE1LDguMDY0LTIuNTQzXFxuXHRcdGMxLjQzMS0wLjMwMiwyLjkwMS0wLjU0Nyw0LjQwMy0wLjczMmMxLjUwMy0wLjE4MSwzLjA0Mi0wLjI5Myw0LjU4OC0wLjQyNmMzLjEtMC4yMzIsNi4yNDUtMC40ODYsOS4zNDYtMC45MjJcXG5cdFx0YzMuMTA0LTAuNDI1LDYuMjAyLTAuODgyLDkuMjY2LTEuMjY2YzMuMDU3LTAuNDEyLDYuMDgxLTAuNzU0LDkuMDA0LTEuMTAxYzIuOTMxLTAuMzEyLDUuNzU3LTAuNjQ0LDguNDUtMC45MDRcXG5cdFx0YzIuNjkxLTAuMjY4LDUuMjM1LTAuNTIxLDcuNTgzLTAuNzU1YzIuMzQ3LTAuMjM5LDQuNTEyLTAuNCw2LjQyNC0wLjU3NGMxLjkxMy0wLjE3MSwzLjU4My0wLjMwOCw0Ljk2Mi0wLjQwM1xcblx0XHRjMi43NTQtMC4yMTIsNC4zMzUtMC4zMDMsNC4zMzUtMC4zMDNMMTIwNi4xMDEtMTI4LjQ1MnpcIi8+XFxuPC9nPlxcbjxnPlxcblx0PGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjExOTcuNjg0XCIgeTE9XCItMjM0LjYzNlwiIHgyPVwiMTA5Ny44NzNcIiB5Mj1cIi0yMzUuNjUxXCIvPlxcblx0PHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTExOTcuNjc1LTIzMy43MzZjMCwwLTEuNTYyLDAuMjU3LTQuMjk2LDAuNjU1Yy0xLjM2NywwLjIxLTMuMDI2LDAuNDQzLTQuOTMsMC42OTVcXG5cdFx0Yy0xLjkwNCwwLjI1LTQuMDUxLDAuNTY4LTYuMzk0LDAuODQ5Yy0yLjM0MiwwLjI4Ny00Ljg4LDAuNTk4LTcuNTY0LDAuOTI2Yy0yLjY4NCwwLjMzNy01LjUxNCwwLjYzMy04LjQ0MiwwLjk3MVxcblx0XHRjLTIuOTI4LDAuMzAyLTUuOTUzLDAuNjMyLTkuMDI2LDAuOWMtMy4wNzQsMC4yOTctNi4xOTUsMC41My05LjMxOCwwLjc5NmMtMy4xMjIsMC4yNTQtNi4yNDYsMC42OTYtOS4zMjEsMS4xNDlcXG5cdFx0Yy0xLjUzOCwwLjIwOS0zLjA2MywwLjQzNy00LjU2OSwwLjU5Yy0xLjUwNiwwLjE0OS0yLjk5NCwwLjIzMi00LjQ1NiwwLjI1MWMtMi45MjUsMC4wMTQtNS43NDktMC4yNzctOC40MjUtMC43MTNcXG5cdFx0Yy0yLjY3Ny0wLjQyMS01LjIwNS0wLjk3Ny03LjUzOS0xLjU5OWMtNC42NjctMS4yMjUtOC41NS0yLjc4MS0xMS4yNjYtNC4xMDJjLTEuMzU4LTAuNjU2LTIuNDI0LTEuMjM3LTMuMTUxLTEuNjg3XFxuXHRcdGMtMC43MjctMC40MjctMS4xMTQtMC42OTYtMS4xMTQtMC42OTZsMC4wMTgtMS44YzAsMCwwLjM5My0wLjI2MSwxLjEyOC0wLjY3M2MwLjczNi0wLjQzNSwxLjgxMy0wLjk5NCwzLjE4NS0xLjYyMlxcblx0XHRjMi43NDItMS4yNjUsNi42NTctMi43NDIsMTEuMzQ3LTMuODcyYzIuMzQ1LTAuNTc1LDQuODg1LTEuMDc5LDcuNTctMS40NDZjMi42ODUtMC4zODIsNS41MTQtMC42MTUsOC40MzgtMC41NDJcXG5cdFx0YzEuNDYyLDAuMDQ5LDIuOTQ3LDAuMTYyLDQuNDUsMC4zNDJjMS41MDMsMC4xODQsMy4wMjQsMC40NDMsNC41NTYsMC42ODNjMy4wNjUsMC41MTYsNi4xOCwxLjAyMSw5LjI5NiwxLjMzOVxcblx0XHRjMy4xMTYsMC4zMjksNi4yMzMsMC42MjYsOS4zLDAuOTg1YzMuMDY3LDAuMzMsNi4wODUsMC43MjIsOS4wMDYsMS4wODRjMi45MjEsMC4zOTgsNS43NDQsMC43NSw4LjQyMSwxLjE0Mlxcblx0XHRjMi42NzcsMC4zODMsNS4yMDgsMC43NDUsNy41NDQsMS4wOGMyLjMzNiwwLjMyOSw0LjQ3NywwLjY5LDYuMzc1LDAuOTc5YzEuODk4LDAuMjkxLDMuNTUyLDAuNTU4LDQuOTE1LDAuNzk1XFxuXHRcdGMyLjcyNSwwLjQ1Myw0LjI4MiwwLjc0Miw0LjI4MiwwLjc0MkwxMTk3LjY3NS0yMzMuNzM2elwiLz5cXG48L2c+XFxuPHBhdGggZmlsbD1cIiNDOUM5QzlcIiBkPVwiTTI2MzMuODgzLTQ2LjMxOWMwLDI0LjAxMi01Ny4xODksMTI4Ljk0Mi02MS40MTQsMTMyLjI2NWMtMTIuMzg0LDkuNzQxLTQ4LjUxNCwxNS4zMTgtODIuODY5LDE2LjUxOFxcblx0Yy04LjM2MiwwLjI5Mi0xNi42MTksMC4zMjUtMjQuNDAzLDAuMDk2Yy0yMC43MTYtMC42MTEtMzguMDgxLTMuMDc5LTQ1LjE1NS03LjQ2NGMtNi44OTYtNC4yNzQtNzQuNDc3LTExOS4yNC03NC40NzctMTQxLjQxNVxcblx0YzAtODkuMTk1LDY0LjU0Mi0xNjEuNTAyLDE0NC4xNTktMTYxLjUwMkMyNTY5LjM0MS0yMDcuODIsMjYzMy44ODMtMTM1LjUxNCwyNjMzLjg4My00Ni4zMTl6XCIvPlxcbjxnIGlkPVwiZzMwMTVfMl9cIiB0cmFuc2Zvcm09XCJtYXRyaXgoMSwwLDAsLTEsMzc5LjY2MTAyLDEyOTMuMDE2OSlcIj5cXG5cdDxwYXRoIGlkPVwicGF0aDMwMTdfMl9cIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVwiMFwiIGZpbGw9XCIjNUQ1RDVEXCIgZD1cIk0yMTg3LjQ2NiwxMzgwLjMzMmMwLTIuOTYtMS4wODItNS41MjEtMy4yNDQtNy42ODRcXG5cdFx0Yy0yLjE2My0yLjE2My00LjcyNC0zLjI0NC03LjY4NC0zLjI0NGMtMi45NiwwLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NFxcblx0XHRjMCwxMC40NzMtNi4xNDcsMTguNTU2LTE4LjQ0MiwyNC4yNDhjLTEyLjI5NSw1LjY5Mi0yNC4zNjIsOC41MzgtMzYuMjAxLDguNTM4Yy0yLjk2LDAtNS41MjEsMS4wODEtNy42ODQsMy4yNDRcXG5cdFx0Yy0yLjE2MywyLjE2My0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NHMxLjA4Miw1LjUyMSwzLjI0NCw3LjY4NGMyLjE2MywyLjE2Myw0LjcyNCwzLjI0NCw3LjY4NCwzLjI0NFxcblx0XHRjMTEuMzg0LDAsMjIuNzExLTEuODIxLDMzLjk4MS01LjQ2NGMxMS4yNy0zLjY0MywyMS4xNzQtOS43OSwyOS43MTItMTguNDQyXFxuXHRcdEMyMTgzLjE5NywxNDAyLjQxNiwyMTg3LjQ2NiwxMzkyLjE3MSwyMTg3LjQ2NiwxMzgwLjMzMnogTTIyNDIuMTA4LDEzODAuMzMyYzAsMTYuMzkzLTMuOTI3LDMxLjY0Ny0xMS43ODIsNDUuNzYzXFxuXHRcdGMtNy44NTUsMTQuMTE2LTE4LjEsMjUuNjcxLTMwLjczNywzNC42NjRzLTI2LjYzOCwxNi4wNTEtNDIuMDA3LDIxLjE3NGMtMTUuMzY4LDUuMTIzLTMwLjkwNyw3LjY4NC00Ni42MTcsNy42ODRcXG5cdFx0Yy0xNS43MSwwLTMxLjI0OS0yLjU2MS00Ni42MTctNy42ODRjLTE1LjM2OC01LjEyMy0yOS4zNzEtMTIuMTgxLTQyLjAwNy0yMS4xNzRjLTEyLjYzNi04Ljk5My0yMi44ODItMjAuNTQ4LTMwLjczNy0zNC42NjRcXG5cdFx0Yy03Ljg1NS0xNC4xMTYtMTEuNzgyLTI5LjM3LTExLjc4Mi00NS43NjNjMC0yMi45OTYsNy43NDEtNDMuNDg3LDIzLjIyMy02MS40NzNjMi4yNzctMi41MDUsNS43NDktNi4yNjEsMTAuNDE2LTExLjI3XFxuXHRcdGM0LjY2Ny01LjAwOSw4LjE0LTguNzY2LDEwLjQxNi0xMS4yN2MyOS4xNDMtMzQuODM1LDQ1LjE5NC02OC43NTksNDguMTU0LTEwMS43NzJoNzcuODY2XFxuXHRcdGMyLjk2LDMzLjAxMywxOS4wMTEsNjYuOTM4LDQ4LjE1NCwxMDEuNzcyYzIuMjc3LDIuNTA0LDUuNzQ5LDYuMjYxLDEwLjQxNiwxMS4yN2M0LjY2Nyw1LjAwOSw4LjE0LDguNzY2LDEwLjQxNywxMS4yN1xcblx0XHRDMjIzNC4zNjcsMTMzNi44NDUsMjI0Mi4xMDgsMTM1Ny4zMzYsMjI0Mi4xMDgsMTM4MC4zMzJ6IE0yMjg1LjgyMywxMzgwLjMzMmMwLTM1LjI5LTExLjcyNi02NS43OTktMzUuMTc3LTkxLjUyN1xcblx0XHRjLTEwLjI0NS0xMS4xNTYtMTguNzI3LTIxLjA2LTI1LjQ0My0yOS43MTJzLTEzLjQ5LTE5LjUyMy0yMC4zMi0zMi42MTVjLTYuODMtMTMuMDkyLTEwLjcwMS0yNS4zMjktMTEuNjEyLTM2LjcxM1xcblx0XHRjMTAuNzAxLTYuMzc1LDE2LjA1Mi0xNS43MSwxNi4wNTItMjguMDA1YzAtOC40MjQtMi44NDYtMTUuNzEtOC41MzgtMjEuODU3YzUuNjkyLTYuMTQ3LDguNTM4LTEzLjQzMyw4LjUzOC0yMS44NTdcXG5cdFx0YzAtMTEuODM5LTUuMTIzLTIxLjA2LTE1LjM2OC0yNy42NjNjMi45Ni01LjIzNyw0LjQ0LTEwLjU4Nyw0LjQ0LTE2LjA1MWMwLTEwLjQ3My0zLjU4Ni0xOC41NTYtMTAuNzU4LTI0LjI0OFxcblx0XHRjLTcuMTcyLTUuNjkyLTE1Ljk5NC04LjUzOC0yNi40NjgtOC41MzhjLTQuNTU0LTEwLjAxOC0xMS4zODQtMTcuOTg3LTIwLjQ5MS0yMy45MDZjLTkuMTA3LTUuOTItMTkuMDExLTguODc5LTI5LjcxMi04Ljg3OVxcblx0XHRjLTEwLjcwMSwwLTIwLjYwNSwyLjk2LTI5LjcxMiw4Ljg3OWMtOS4xMDcsNS45Mi0xNS45MzgsMTMuODg4LTIwLjQ5MSwyMy45MDZjLTEwLjQ3MywwLTE5LjI5NiwyLjg0Ni0yNi40NjgsOC41MzhcXG5cdFx0Yy03LjE3Miw1LjY5Mi0xMC43NTgsMTMuNzc1LTEwLjc1OCwyNC4yNDhjMCw1LjQ2NCwxLjQ4LDEwLjgxNSw0LjQ0LDE2LjA1MWMtMTAuMjQ2LDYuNjAzLTE1LjM2OCwxNS44MjQtMTUuMzY4LDI3LjY2M1xcblx0XHRjMCw4LjQyNCwyLjg0NiwxNS43MSw4LjUzOCwyMS44NTdjLTUuNjkyLDYuMTQ3LTguNTM4LDEzLjQzMy04LjUzOCwyMS44NTdjMCwxMi4yOTUsNS4zNSwyMS42MywxNi4wNTEsMjguMDA1XFxuXHRcdGMtMC45MTEsMTEuMzg0LTQuNzgxLDIzLjYyMi0xMS42MTIsMzYuNzEzcy0xMy42MDQsMjMuOTYzLTIwLjMyLDMyLjYxNXMtMTUuMTk4LDE4LjU1Ni0yNS40NDMsMjkuNzEyXFxuXHRcdGMtMjMuNDUxLDI1LjcyOC0zNS4xNzYsNTYuMjM3LTM1LjE3Niw5MS41MjdjMCwyMi41NCw1LjA2Niw0My41NDMsMTUuMTk4LDYzLjAxczIzLjQ1MSwzNS42MzIsMzkuOTU4LDQ4LjQ5NVxcblx0XHRjMTYuNTA3LDEyLjg2NCwzNS4xNzYsMjIuOTk2LDU2LjAwOSwzMC4zOTVjMjAuODMzLDcuNCw0Mi4wNjMsMTEuMDk5LDYzLjY5MywxMS4wOTljMjEuNjI5LDAsNDIuODYtMy43LDYzLjY5My0xMS4wOTlcXG5cdFx0YzIwLjgzMy03LjQsMzkuNTAyLTE3LjUzMSw1Ni4wMDktMzAuMzk1YzE2LjUwNy0xMi44NjQsMjkuODI2LTI5LjAyOSwzOS45NTgtNDguNDk1XFxuXHRcdEMyMjgwLjc1NywxNDIzLjg3NSwyMjg1LjgyMywxNDAyLjg3MiwyMjg1LjgyMywxMzgwLjMzMnpcIi8+XFxuPC9nPlxcbjwvc3ZnPlxcbicpOyB9KSgpO1xufSBcbnJldHVybiBidWYuam9pbignJyk7XG59O1xuICByZXR1cm4gZnVuY3Rpb24obG9jYWxzKSB7XG4gICAgcmV0dXJuIHQobG9jYWxzLCByZXF1aXJlKFwiZWpzXCIpLmZpbHRlcnMpO1xuICB9XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gZnVuY3Rpb24gYW5vbnltb3VzKGxvY2FscywgZmlsdGVycywgZXNjYXBlXG4vKiovKSB7XG5lc2NhcGUgPSBlc2NhcGUgfHwgZnVuY3Rpb24gKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xudmFyIGJ1ZiA9IFtdO1xud2l0aCAobG9jYWxzIHx8IHt9KSB7IChmdW5jdGlvbigpeyBcbiBidWYucHVzaCgnPHN2ZyB2ZXJzaW9uPVwiMS4xXCJcXG5cdCBpZD1cInN2ZzMwMTNcIiB4bWxuczpzb2RpcG9kaT1cImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXCIgeG1sbnM6c3ZnPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCIgeG1sbnM6aW5rc2NhcGU9XCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXCIgeG1sbnM6ZGM9XCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1wiIHhtbG5zOmNjPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXCIgc29kaXBvZGk6ZG9jbmFtZT1cImxpZ2h0X2J1bGJfZm9udF9hd2Vzb21lLnN2Z1wiIGlua3NjYXBlOnZlcnNpb249XCIwLjQ4LjMuMSByOTg4NlwiXFxuXHQgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI0MHB4XCIgaGVpZ2h0PVwiNDBweFwiXFxuXHQgdmlld0JveD1cIjAgMCA2MTIgNzkyXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDYxMiA3OTJcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbjxnIGlkPVwiYnVsYlwiPlxcbiAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ1My43NzUsMzUzLjE1NmMwLDI0LjAxMi01Ny4xODksMTI4Ljk0Mi02MS40MTQsMTMyLjI2NWMtMTIuMzg0LDkuNzQxLTQ4LjUxNCwxNS4zMTgtODIuODY5LDE2LjUxOFxcbiAgICBjLTguMzYyLDAuMjkyLTE2LjYxOSwwLjMyNS0yNC40MDMsMC4wOTZjLTIwLjcxNi0wLjYxMS0zOC4wODEtMy4wNzktNDUuMTU1LTcuNDY0Yy02Ljg5Ni00LjI3NC03NC40NzctMTE5LjI0LTc0LjQ3Ny0xNDEuNDE1XFxuICAgIGMwLTg5LjE5NSw2NC41NDItMTYxLjUwMiwxNDQuMTU5LTE2MS41MDJTNDUzLjc3NSwyNjMuOTYxLDQ1My43NzUsMzUzLjE1NnpcIi8+XFxuICA8ZyBpZD1cImczMDE1XCIgdHJhbnNmb3JtPVwibWF0cml4KDEsMCwwLC0xLDM3OS42NjEwMiwxMjkzLjAxNjkpXCI+XFxuICAgIDxwYXRoIGlkPVwicGF0aDMwMTdcIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVwiMFwiIGZpbGw9XCIjNUQ1RDVEXCIgZD1cIk03LjM1Nyw5ODAuODU3YzAtMi45Ni0xLjA4MS01LjUyMS0zLjI0NC03LjY4NFxcbiAgICAgIHMtNC43MjQtMy4yNDQtNy42ODQtMy4yNDRzLTUuNTIxLDEuMDgxLTcuNjg0LDMuMjQ0cy0zLjI0NCw0LjcyNC0zLjI0NCw3LjY4NGMwLDEwLjQ3My02LjE0NywxOC41NTYtMTguNDQyLDI0LjI0OFxcbiAgICAgIGMtMTIuMjk1LDUuNjkyLTI0LjM2Miw4LjUzOC0zNi4yMDEsOC41MzhjLTIuOTYsMC01LjUyMSwxLjA4MS03LjY4NCwzLjI0NHMtMy4yNDQsNC43MjQtMy4yNDQsNy42ODRcXG4gICAgICBjMCwyLjk2LDEuMDgxLDUuNTIxLDMuMjQ0LDcuNjg0czQuNzI0LDMuMjQ0LDcuNjg0LDMuMjQ0YzExLjM4NCwwLDIyLjcxMS0xLjgyMSwzMy45ODEtNS40NjRzMjEuMTc0LTkuNzksMjkuNzEyLTE4LjQ0MlxcbiAgICAgIFM3LjM1Nyw5OTIuNjk2LDcuMzU3LDk4MC44NTd6IE02Miw5ODAuODU3YzAsMTYuMzkzLTMuOTI3LDMxLjY0Ny0xMS43ODIsNDUuNzYzcy0xOC4xLDI1LjY3MS0zMC43MzcsMzQuNjY0XFxuICAgICAgcy0yNi42MzgsMTYuMDUxLTQyLjAwNywyMS4xNzRzLTMwLjkwNyw3LjY4NC00Ni42MTcsNy42ODRzLTMxLjI0OS0yLjU2MS00Ni42MTctNy42ODRzLTI5LjM3MS0xMi4xODEtNDIuMDA3LTIxLjE3NFxcbiAgICAgIGMtMTIuNjM2LTguOTkzLTIyLjg4Mi0yMC41NDgtMzAuNzM3LTM0LjY2NGMtNy44NTUtMTQuMTE2LTExLjc4Mi0yOS4zNzEtMTEuNzgyLTQ1Ljc2M2MwLTIyLjk5Niw3Ljc0MS00My40ODcsMjMuMjIzLTYxLjQ3M1xcbiAgICAgIGMyLjI3Ny0yLjUwNCw1Ljc0OS02LjI2MSwxMC40MTYtMTEuMjdjNC42NjctNS4wMDksOC4xNC04Ljc2NiwxMC40MTYtMTEuMjdjMjkuMTQzLTM0LjgzNSw0NS4xOTQtNjguNzU5LDQ4LjE1NC0xMDEuNzcyaDc3Ljg2NlxcbiAgICAgIGMyLjk2LDMzLjAxMywxOS4wMTEsNjYuOTM4LDQ4LjE1NCwxMDEuNzcyYzIuMjc3LDIuNTA0LDUuNzQ5LDYuMjYxLDEwLjQxNiwxMS4yN3M4LjE0LDguNzY2LDEwLjQxNiwxMS4yN1xcbiAgICAgIEM1NC4yNTksOTM3LjM3LDYyLDk1Ny44NjIsNjIsOTgwLjg1N3ogTTEwNS43MTQsOTgwLjg1N2MwLTM1LjI5LTExLjcyNS02NS43OTktMzUuMTc2LTkxLjUyN1xcbiAgICAgIGMtMTAuMjQ2LTExLjE1Ni0xOC43MjctMjEuMDYtMjUuNDQzLTI5LjcxMnMtMTMuNDktMTkuNTIzLTIwLjMyLTMyLjYxNWMtNi44My0xMy4wOTItMTAuNzAxLTI1LjMyOS0xMS42MTItMzYuNzEzXFxuICAgICAgYzEwLjcwMS02LjM3NSwxNi4wNTEtMTUuNzEsMTYuMDUxLTI4LjAwNGMwLTguNDI0LTIuODQ2LTE1LjcxLTguNTM4LTIxLjg1N2M1LjY5Mi02LjE0Nyw4LjUzOC0xMy40MzMsOC41MzgtMjEuODU3XFxuICAgICAgYzAtMTEuODM5LTUuMTIzLTIxLjA2LTE1LjM2OC0yNy42NjNjMi45Ni01LjIzNyw0LjQ0LTEwLjU4Nyw0LjQ0LTE2LjA1MWMwLTEwLjQ3My0zLjU4Ni0xOC41NTYtMTAuNzU4LTI0LjI0OFxcbiAgICAgIHMtMTUuOTk0LTguNTM4LTI2LjQ2OC04LjUzOGMtNC41NTQtMTAuMDE4LTExLjM4NC0xNy45ODctMjAuNDkxLTIzLjkwNmMtOS4xMDctNS45Mi0xOS4wMTEtOC44NzktMjkuNzEyLTguODc5XFxuICAgICAgYy0xMC43MDEsMC0yMC42MDUsMi45Ni0yOS43MTIsOC44NzljLTkuMTA3LDUuOTItMTUuOTM4LDEzLjg4OC0yMC40OTEsMjMuOTA2Yy0xMC40NzMsMC0xOS4yOTYsMi44NDYtMjYuNDY4LDguNTM4XFxuICAgICAgcy0xMC43NTgsMTMuNzc1LTEwLjc1OCwyNC4yNDhjMCw1LjQ2NCwxLjQ4LDEwLjgxNSw0LjQ0LDE2LjA1MWMtMTAuMjQ2LDYuNjAzLTE1LjM2OCwxNS44MjQtMTUuMzY4LDI3LjY2M1xcbiAgICAgIGMwLDguNDI0LDIuODQ2LDE1LjcxLDguNTM4LDIxLjg1N2MtNS42OTIsNi4xNDctOC41MzgsMTMuNDMzLTguNTM4LDIxLjg1N2MwLDEyLjI5NSw1LjM1LDIxLjYyOSwxNi4wNTEsMjguMDA0XFxuICAgICAgYy0wLjkxMSwxMS4zODQtNC43ODEsMjMuNjIyLTExLjYxMiwzNi43MTNjLTYuODMsMTMuMDkxLTEzLjYwNCwyMy45NjMtMjAuMzIsMzIuNjE1cy0xNS4xOTgsMTguNTU2LTI1LjQ0MywyOS43MTJcXG4gICAgICBDLTIzMi4yNzUsOTE1LjA1OC0yNDQsOTQ1LjU2Ny0yNDQsOTgwLjg1N2MwLDIyLjU0LDUuMDY2LDQzLjU0NCwxNS4xOTgsNjMuMDFjMTAuMTMyLDE5LjQ2NywyMy40NTEsMzUuNjMyLDM5Ljk1OCw0OC40OTZcXG4gICAgICBjMTYuNTA3LDEyLjg2NCwzNS4xNzYsMjIuOTk1LDU2LjAwOSwzMC4zOTVzNDIuMDY0LDExLjA5OSw2My42OTMsMTEuMDk5czQyLjg2LTMuNyw2My42OTMtMTEuMDk5czM5LjUwMi0xNy41MzEsNTYuMDA5LTMwLjM5NVxcbiAgICAgIGMxNi41MDctMTIuODY0LDI5LjgyNi0yOS4wMjksMzkuOTU4LTQ4LjQ5NkMxMDAuNjQ4LDEwMjQuNDAxLDEwNS43MTQsMTAwMy4zOTcsMTA1LjcxNCw5ODAuODU3elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiNDczLjU4MlwiIHkxPVwiMjA4LjFcIiB4Mj1cIjU2MC41NzhcIiB5Mj1cIjE1OS4xNlwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ3My4xNDEsMjA3LjMxNWMwLDAsMS4yMjUtMS4wMDMsMy4zOTYtMi43MTFjMS4wOC0wLjg2NCwyLjQwMi0xLjg5NCwzLjkyNS0zLjA2M1xcbiAgICAgIGMxLjUyNS0xLjE2NywzLjIyNy0yLjUxNCw1LjExNy0zLjkyN2MxLjg4Ny0xLjQxOCwzLjkzMS0yLjk1NCw2LjA5Mi00LjU3OGMyLjE1OC0xLjYzMiw0LjQ2Mi0zLjMsNi44MzEtNS4wNTVcXG4gICAgICBjMi4zODYtMS43MjMsNC44NDMtMy41MTksNy4zNzItNS4yODVjMi41MTUtMS43OTEsNS4xMDQtMy41NTIsNy42NzctNS4zNDFjMi41NzgtMS43NzgsNS4wNjUtMy43MjEsNy41MDMtNS42NDhcXG4gICAgICBjMS4yMjgtMC45NDgsMi40MzYtMS45MDcsMy42NjUtMi43OTJjMS4yMzEtMC44ODEsMi40NzgtMS42OTUsMy43MzYtMi40NDJjMi41MjctMS40NzIsNS4xMi0yLjYyOSw3LjY1Ni0zLjU4N1xcbiAgICAgIGMyLjUyOS0wLjk3MSw0Ljk5OC0xLjc1MSw3LjMzMS0yLjM3N2M0LjY1NS0xLjI2OCw4Ljc5Ny0xLjg1OCwxMS44MS0yLjA2OWMxLjUwNC0wLjEwOSwyLjcxOC0wLjEzOCwzLjU3Mi0wLjExMVxcbiAgICAgIGMwLjg0MywwLjAwNywxLjMxMywwLjA0NywxLjMxMywwLjA0N2wwLjg4MywxLjU2OWMwLDAtMC4yMSwwLjQyMi0wLjY0MSwxLjE0NmMtMC40MiwwLjc0NC0xLjA3NSwxLjc2Ni0xLjk1LDIuOTk1XFxuICAgICAgYy0xLjc0NSwyLjQ2NS00LjQsNS42OTgtNy45LDkuMDE5Yy0xLjc0NiwxLjY2OS0zLjY5NCwzLjM3NC01LjgzOCw1LjAzMWMtMi4xMzYsMS42NzEtNC40NzEsMy4yODUtNy4wNDEsNC42ODFcXG4gICAgICBjLTEuMjkxLDAuNjg3LTIuNjM1LDEuMzMxLTQuMDI3LDEuOTI1Yy0xLjM5NCwwLjU5MS0yLjg0MSwxLjEyNi00LjI4OSwxLjY4M2MtMi45MTQsMS4wODMtNS44NjUsMi4yLTguNzIzLDMuNDhcXG4gICAgICBjLTIuODY1LDEuMjctNS43MTMsMi41NjgtOC41NSwzLjc4OGMtMi44MjMsMS4yNDUtNS42MzMsMi40MTItOC4zNDUsMy41NTZjLTIuNzI5LDEuMTEzLTUuMzUyLDIuMjE3LTcuODY3LDMuMjEzXFxuICAgICAgYy0yLjUxMSwxLjAwNC00Ljg4NSwxLjk1My03LjA3NiwyLjgzYy0yLjE4OSwwLjg4MS00LjIyNCwxLjYzNy02LjAxMywyLjMzNGMtMS43OSwwLjY5NS0zLjM1NywxLjI5LTQuNjU2LDEuNzY0XFxuICAgICAgYy0yLjU4NywwLjk2OC00LjA4LDEuNDk0LTQuMDgsMS40OTRMNDczLjE0MSwyMDcuMzE1elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiNDkyLjM0OFwiIHkxPVwiNDEwLjAwOFwiIHgyPVwiNTg5LjUwOVwiIHkyPVwiNDMyLjg4M1wiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTQ5Mi41NTUsNDA5LjEzMmMwLDAsMS41ODEsMC4wOTEsNC4zMzUsMC4zMDNjMS4zOCwwLjA5NSwzLjA1LDAuMjMyLDQuOTYyLDAuNDAzXFxuICAgICAgYzEuOTEyLDAuMTczLDQuMDc3LDAuMzM0LDYuNDI0LDAuNTc0YzIuMzQ4LDAuMjM0LDQuODkyLDAuNDg3LDcuNTgzLDAuNzU1YzIuNjkzLDAuMjU5LDUuNTE5LDAuNTkyLDguNDUsMC45MDRcXG4gICAgICBjMi45MjMsMC4zNDcsNS45NDcsMC42ODgsOS4wMDQsMS4xMDFjMy4wNjQsMC4zODQsNi4xNjEsMC44NDEsOS4yNjYsMS4yNjZjMy4xMDIsMC40MzcsNi4yNDcsMC42OTEsOS4zNDYsMC45MjJcXG4gICAgICBjMS41NDYsMC4xMzMsMy4wODQsMC4yNDYsNC41ODgsMC40MjZjMS41MDIsMC4xODUsMi45NzIsMC40Myw0LjQwMywwLjczMmMyLjg1NywwLjYyOCw1LjU0OCwxLjUzMSw4LjA2NCwyLjU0M1xcbiAgICAgIGMyLjUxOSwwLjk5OCw0Ljg2NCwyLjA5NSw3LjAwNCwzLjIxM2M0LjI4NSwyLjIxOSw3LjczMiw0LjU4OCwxMC4wOTMsNi40NzJjMS4xODEsMC45MzgsMi4wOTQsMS43MzgsMi43MDQsMi4zMzdcXG4gICAgICBjMC42MTUsMC41NzYsMC45MzQsMC45MjMsMC45MzQsMC45MjNsLTAuNDEyLDEuNzUyYzAsMC0wLjQ0LDAuMTY5LTEuMjQ4LDAuNDFjLTAuODEzLDAuMjYzLTEuOTg3LDAuNTcyLTMuNDYzLDAuODg1XFxuICAgICAgYy0yLjk1MywwLjYzMy03LjA5NiwxLjIxNi0xMS45MiwxLjI5Yy0yLjQxNCwwLjA0Ni01LjAwMy0wLjAxOC03LjcwMi0wLjI0OWMtMi43MDMtMC4yMTYtNS41MTUtMC42MDktOC4zNTEtMS4zMjJcXG4gICAgICBjLTEuNDE1LTAuMzY4LTIuODQtMC44MDQtNC4yNjctMS4zMDljLTEuNDI2LTAuNTA5LTIuODUzLTEuMDk1LTQuMjk2LTEuNjY1Yy0yLjg3OC0xLjE3Ni01LjgwNS0yLjM1MS04Ljc3Ni0zLjM0NFxcbiAgICAgIGMtMi45NjgtMS4wMDQtNS45NDQtMS45NzctOC44NTctM2MtMi45Mi0wLjk5NS01Ljc3OS0yLjAzOC04LjU0OS0zLjAzMmMtMi43NjItMS4wMjktNS40NC0xLjk5Mi03Ljk2NS0yLjk2MVxcbiAgICAgIGMtMi41MjgtMC45NjEtNC45MTgtMS44NjktNy4xMjQtMi43MDhjLTIuMjA3LTAuODMzLTQuMjE3LTEuNjU1LTYuMDA1LTIuMzUzYy0xLjc4OC0wLjctMy4zNDQtMS4zMjMtNC42MjEtMS44NTRcXG4gICAgICBjLTIuNTU5LTEuMDM5LTQuMDE1LTEuNjYzLTQuMDE1LTEuNjYzTDQ5Mi41NTUsNDA5LjEzMnpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjUwMi41NTlcIiB5MT1cIjMwMS43XCIgeDI9XCI2MDIuMzdcIiB5Mj1cIjMwMC42ODVcIi8+XFxuICAgIDxwYXRoIGZpbGw9XCIjRUZCODM0XCIgZD1cIk01MDIuNTUsMzAwLjhjMCwwLDEuNTU3LTAuMjg5LDQuMjgyLTAuNzQyYzEuMzYyLTAuMjM3LDMuMDE3LTAuNTA0LDQuOTE1LTAuNzk1XFxuICAgICAgYzEuODk4LTAuMjg5LDQuMDM5LTAuNjUsNi4zNzUtMC45NzljMi4zMzYtMC4zMzQsNC44NjctMC42OTcsNy41NDQtMS4wOGMyLjY3Ny0wLjM5Miw1LjUtMC43NDQsOC40MjEtMS4xNDJcXG4gICAgICBjMi45MjEtMC4zNjIsNS45MzktMC43NTMsOS4wMDYtMS4wODRjMy4wNjctMC4zNTksNi4xODMtMC42NTYsOS4zLTAuOTg1YzMuMTE2LTAuMzE3LDYuMjMtMC44MjMsOS4yOTYtMS4zMzlcXG4gICAgICBjMS41MzMtMC4yNCwzLjA1My0wLjQ5OSw0LjU1Ni0wLjY4M2MxLjUwMy0wLjE4LDIuOTg5LTAuMjkzLDQuNDUtMC4zNDJjMi45MjQtMC4wNzMsNS43NTMsMC4xNiw4LjQzOCwwLjU0MlxcbiAgICAgIGMyLjY4NSwwLjM2Niw1LjIyNCwwLjg3MSw3LjU3LDEuNDQ2YzQuNjkxLDEuMTMsOC42MDUsMi42MDcsMTEuMzQ3LDMuODcyYzEuMzcxLDAuNjI5LDIuNDQ5LDEuMTg3LDMuMTg1LDEuNjIyXFxuICAgICAgYzAuNzM1LDAuNDEyLDEuMTI4LDAuNjczLDEuMTI4LDAuNjczbDAuMDE4LDEuOGMwLDAtMC4zODcsMC4yNjktMS4xMTQsMC42OTZjLTAuNzI3LDAuNDUtMS43OTMsMS4wMzEtMy4xNTEsMS42ODdcXG4gICAgICBjLTIuNzE2LDEuMzIxLTYuNiwyLjg3Ny0xMS4yNjYsNC4xMDJjLTIuMzMzLDAuNjIyLTQuODYyLDEuMTc5LTcuNTM5LDEuNTk5Yy0yLjY3NiwwLjQzNi01LjUsMC43MjctOC40MjUsMC43MTNcXG4gICAgICBjLTEuNDYyLTAuMDE5LTIuOTUtMC4xMDItNC40NTYtMC4yNTFjLTEuNTA2LTAuMTUzLTMuMDMyLTAuMzgxLTQuNTY5LTAuNTljLTMuMDc1LTAuNDU0LTYuMTk5LTAuODk1LTkuMzIxLTEuMTQ5XFxuICAgICAgYy0zLjEyMi0wLjI2Ni02LjI0NC0wLjQ5OS05LjMxOC0wLjc5NmMtMy4wNzMtMC4yNjgtNi4wOTktMC41OTgtOS4wMjYtMC45Yy0yLjkyOC0wLjMzOC01Ljc1OC0wLjYzNC04LjQ0Mi0wLjk3MVxcbiAgICAgIGMtMi42ODQtMC4zMjktNS4yMjItMC42MzktNy41NjQtMC45MjZjLTIuMzQyLTAuMjgxLTQuNDktMC41OTktNi4zOTQtMC44NDljLTEuOTAzLTAuMjUzLTMuNTYzLTAuNDg2LTQuOTMtMC42OTVcXG4gICAgICBjLTIuNzM0LTAuMzk3LTQuMjk2LTAuNjU1LTQuMjk2LTAuNjU1TDUwMi41NSwzMDAuOHpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjEzNS42NjFcIiB5MT1cIjIxMi43NjRcIiB4Mj1cIjQ4LjY2NVwiIHkyPVwiMTYzLjgyNFwiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTEzNS4yMiwyMTMuNTQ4YzAsMC0xLjQ5My0wLjUyNi00LjA4LTEuNDk0Yy0xLjI5OS0wLjQ3NC0yLjg2Ni0xLjA2OS00LjY1Ni0xLjc2NFxcbiAgICAgIGMtMS43ODktMC42OTctMy44MjQtMS40NTMtNi4wMTMtMi4zMzRjLTIuMTkxLTAuODc2LTQuNTY1LTEuODI2LTcuMDc2LTIuODNjLTIuNTE1LTAuOTk2LTUuMTM4LTIuMS03Ljg2Ny0zLjIxM1xcbiAgICAgIGMtMi43MTItMS4xNDQtNS41MjItMi4zMTItOC4zNDUtMy41NTZjLTIuODM3LTEuMjItNS42ODYtMi41MTgtOC41NS0zLjc4OGMtMi44NTktMS4yOC01LjgxLTIuMzk3LTguNzIzLTMuNDhcXG4gICAgICBjLTEuNDQ4LTAuNTU3LTIuODk1LTEuMDkyLTQuMjg5LTEuNjgzYy0xLjM5Mi0wLjU5NC0yLjczNi0xLjIzOC00LjAyNy0xLjkyNWMtMi41Ny0xLjM5Ni00LjkwNS0zLjAxLTcuMDQxLTQuNjgxXFxuICAgICAgYy0yLjE0My0xLjY1Ny00LjA5Mi0zLjM2My01LjgzOC01LjAzMWMtMy41LTMuMzItNi4xNTUtNi41NTQtNy45LTkuMDE5Yy0wLjg3NC0xLjIyOS0xLjUzLTIuMjUxLTEuOTUtMi45OTVcXG4gICAgICBjLTAuNDMxLTAuNzI0LTAuNjQxLTEuMTQ2LTAuNjQxLTEuMTQ2bDAuODgzLTEuNTY5YzAsMCwwLjQ3LTAuMDQsMS4zMTMtMC4wNDdjMC44NTQtMC4wMjcsMi4wNjgsMC4wMDIsMy41NzIsMC4xMTFcXG4gICAgICBjMy4wMTMsMC4yMTEsNy4xNTUsMC44MDEsMTEuODEsMi4wNjljMi4zMzIsMC42MjUsNC44MDEsMS40MDYsNy4zMzEsMi4zNzdjMi41MzcsMC45NTgsNS4xMjksMi4xMTUsNy42NTYsMy41ODdcXG4gICAgICBjMS4yNTgsMC43NDYsMi41MDUsMS41NjEsMy43MzYsMi40NDJjMS4yMjksMC44ODUsMi40MzcsMS44NDQsMy42NjUsMi43OTJjMi40MzgsMS45MjgsNC45MjUsMy44Nyw3LjUwMyw1LjY0OFxcbiAgICAgIGMyLjU3MywxLjc4OSw1LjE2MSwzLjU0OSw3LjY3Nyw1LjM0MWMyLjUyOSwxLjc2Niw0Ljk4NiwzLjU2Miw3LjM3Miw1LjI4NWMyLjM2OCwxLjc1NSw0LjY3MywzLjQyMyw2LjgzMSw1LjA1NVxcbiAgICAgIGMyLjE2MiwxLjYyNSw0LjIwNiwzLjE2LDYuMDkyLDQuNTc4YzEuODg5LDEuNDEzLDMuNTkyLDIuNzYsNS4xMTcsMy45MjdjMS41MjMsMS4xNjksMi44NDUsMi4xOTksMy45MjUsMy4wNjNcXG4gICAgICBjMi4xNywxLjcwOCwzLjM5NiwyLjcxMSwzLjM5NiwyLjcxMUwxMzUuMjIsMjEzLjU0OHpcIi8+XFxuICA8L2c+XFxuICA8Zz5cXG4gICAgPGxpbmUgZmlsbD1cIiNFRkI4MzRcIiB4MT1cIjEyMC44OTVcIiB5MT1cIjQxMS42NzJcIiB4Mj1cIjIzLjczNFwiIHkyPVwiNDM0LjU0N1wiLz5cXG4gICAgPHBhdGggZmlsbD1cIiNFRkI4MzRcIiBkPVwiTTEyMS4xMDEsNDEyLjU0OGMwLDAtMS40NTYsMC42MjMtNC4wMTUsMS42NjNjLTEuMjc3LDAuNTMtMi44MzMsMS4xNTMtNC42MjEsMS44NTRcXG4gICAgICBjLTEuNzg4LDAuNjk4LTMuNzk4LDEuNTItNi4wMDUsMi4zNTNjLTIuMjA2LDAuODM4LTQuNTk2LDEuNzQ3LTcuMTI0LDIuNzA4Yy0yLjUyNiwwLjk2OS01LjIwMywxLjkzMi03Ljk2NSwyLjk2MVxcbiAgICAgIGMtMi43NywwLjk5My01LjYyOSwyLjAzNy04LjU0OSwzLjAzMmMtMi45MTQsMS4wMjMtNS44ODksMS45OTYtOC44NTcsM2MtMi45NzEsMC45OTMtNS44OTksMi4xNjktOC43NzYsMy4zNDRcXG4gICAgICBjLTEuNDQzLDAuNTctMi44NywxLjE1Ni00LjI5NiwxLjY2NWMtMS40MjcsMC41MDUtMi44NTIsMC45NDEtNC4yNjcsMS4zMDljLTIuODM2LDAuNzEzLTUuNjQ4LDEuMTA1LTguMzUxLDEuMzIxXFxuICAgICAgYy0yLjY5OSwwLjIzMS01LjI4OCwwLjI5NS03LjcwMiwwLjI0OWMtNC44MjQtMC4wNzQtOC45NjctMC42NTctMTEuOTItMS4yOWMtMS40NzYtMC4zMTMtMi42NS0wLjYyMS0zLjQ2My0wLjg4NVxcbiAgICAgIGMtMC44MDgtMC4yNDEtMS4yNDgtMC40MS0xLjI0OC0wLjQxbC0wLjQxMy0xLjc1MmMwLDAsMC4zMTktMC4zNDcsMC45MzQtMC45MjNjMC42MS0wLjU5OCwxLjUyMy0xLjM5OSwyLjcwNC0yLjMzN1xcbiAgICAgIGMyLjM2LTEuODg0LDUuODA4LTQuMjU0LDEwLjA5My02LjQ3MmMyLjE0LTEuMTE5LDQuNDg1LTIuMjE2LDcuMDA0LTMuMjEzYzIuNTE2LTEuMDEyLDUuMjA3LTEuOTE1LDguMDY0LTIuNTQzXFxuICAgICAgYzEuNDMxLTAuMzAyLDIuOS0wLjU0Nyw0LjQwMy0wLjczMmMxLjUwMy0wLjE4MSwzLjA0Mi0wLjI5Myw0LjU4OC0wLjQyNmMzLjEtMC4yMzIsNi4yNDUtMC40ODYsOS4zNDYtMC45MjJcXG4gICAgICBjMy4xMDQtMC40MjUsNi4yMDEtMC44ODIsOS4yNjUtMS4yNjZjMy4wNTctMC40MTIsNi4wODEtMC43NTQsOS4wMDQtMS4xMDFjMi45MzEtMC4zMTIsNS43NTctMC42NDQsOC40NS0wLjkwNFxcbiAgICAgIGMyLjY5MS0wLjI2OCw1LjIzNS0wLjUyMSw3LjU4My0wLjc1NWMyLjM0Ny0wLjIzOSw0LjUxMi0wLjQsNi40MjQtMC41NzRjMS45MTMtMC4xNzEsMy41ODMtMC4zMDgsNC45NjItMC40MDNcXG4gICAgICBjMi43NTQtMC4yMTIsNC4zMzUtMC4zMDMsNC4zMzUtMC4zMDNMMTIxLjEwMSw0MTIuNTQ4elwiLz5cXG4gIDwvZz5cXG4gIDxnPlxcbiAgICA8bGluZSBmaWxsPVwiI0VGQjgzNFwiIHgxPVwiMTEyLjY4NFwiIHkxPVwiMzA2LjM2NFwiIHgyPVwiMTIuODczXCIgeTI9XCIzMDUuMzQ5XCIvPlxcbiAgICA8cGF0aCBmaWxsPVwiI0VGQjgzNFwiIGQ9XCJNMTEyLjY3NSwzMDcuMjY0YzAsMC0xLjU2MiwwLjI1Ny00LjI5NiwwLjY1NWMtMS4zNjcsMC4yMS0zLjAyNiwwLjQ0My00LjkzLDAuNjk1XFxuICAgICAgYy0xLjkwNCwwLjI1LTQuMDUxLDAuNTY4LTYuMzk0LDAuODQ5Yy0yLjM0MywwLjI4Ny00Ljg4LDAuNTk4LTcuNTY0LDAuOTI2Yy0yLjY4NCwwLjMzNy01LjUxNCwwLjYzMy04LjQ0MiwwLjk3MVxcbiAgICAgIGMtMi45MjgsMC4zMDItNS45NTMsMC42MzItOS4wMjYsMC45Yy0zLjA3NCwwLjI5Ny02LjE5NSwwLjUzLTkuMzE4LDAuNzk2Yy0zLjEyMiwwLjI1NC02LjI0NiwwLjY5Ni05LjMyMSwxLjE0OVxcbiAgICAgIGMtMS41MzcsMC4yMDktMy4wNjMsMC40MzctNC41NjksMC41OWMtMS41MDYsMC4xNDktMi45OTQsMC4yMzItNC40NTYsMC4yNTFjLTIuOTI1LDAuMDE0LTUuNzQ5LTAuMjc3LTguNDI1LTAuNzEzXFxuICAgICAgYy0yLjY3Ni0wLjQyMS01LjIwNS0wLjk3Ny03LjUzOS0xLjU5OWMtNC42NjctMS4yMjUtOC41NS0yLjc4MS0xMS4yNjYtNC4xMDJjLTEuMzU4LTAuNjU2LTIuNDI0LTEuMjM3LTMuMTUxLTEuNjg3XFxuICAgICAgYy0wLjcyNy0wLjQyNy0xLjExNC0wLjY5Ni0xLjExNC0wLjY5NmwwLjAxOC0xLjhjMCwwLDAuMzkzLTAuMjYxLDEuMTI4LTAuNjczYzAuNzM2LTAuNDM1LDEuODE0LTAuOTk0LDMuMTg1LTEuNjIyXFxuICAgICAgYzIuNzQyLTEuMjY1LDYuNjU3LTIuNzQyLDExLjM0Ny0zLjg3MmMyLjM0NS0wLjU3NSw0Ljg4NS0xLjA3OSw3LjU3LTEuNDQ2YzIuNjg1LTAuMzgyLDUuNTE0LTAuNjE1LDguNDM4LTAuNTQyXFxuICAgICAgYzEuNDYyLDAuMDQ5LDIuOTQ3LDAuMTYyLDQuNDUsMC4zNDJjMS41MDMsMC4xODQsMy4wMjQsMC40NDMsNC41NTYsMC42ODNjMy4wNjUsMC41MTYsNi4xOCwxLjAyMSw5LjI5NiwxLjMzOVxcbiAgICAgIGMzLjExNiwwLjMyOSw2LjIzMiwwLjYyNiw5LjI5OSwwLjk4NWMzLjA2NywwLjMzLDYuMDg1LDAuNzIyLDkuMDA2LDEuMDg0YzIuOTIsMC4zOTgsNS43NDQsMC43NSw4LjQyMSwxLjE0MlxcbiAgICAgIGMyLjY3NywwLjM4Myw1LjIwOCwwLjc0NSw3LjU0NCwxLjA4YzIuMzM2LDAuMzI5LDQuNDc3LDAuNjksNi4zNzUsMC45NzljMS44OTgsMC4yOTEsMy41NTIsMC41NTgsNC45MTUsMC43OTVcXG4gICAgICBjMi43MjUsMC40NTMsNC4yODIsMC43NDIsNC4yODIsMC43NDJMMTEyLjY3NSwzMDcuMjY0elwiLz5cXG4gIDwvZz5cXG48L2c+XFxuPGcgaWQ9XCJjb3VudFwiPlxcbiAgPHRleHQgeD1cIjQwMFwiIHk9XCI3MDBcIiBpZD1cImhpbnRDb3VudFwiPjwvdGV4dD5cXG48L2c+XFxuPC9zdmc+XFxuJyk7IH0pKCk7XG59IFxucmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICByZXR1cm4gdChsb2NhbHMsIHJlcXVpcmUoXCJlanNcIikuZmlsdGVycyk7XG4gIH1cbn0oKSk7IiwidmFyIG1zZyA9IHJlcXVpcmUoJy4uL2xvY2FsZScpO1xudmFyIEhpbnQgPSByZXF1aXJlKCcuL0hpbnQuanN4Jyk7XG5cbi8qKlxuICogQG92ZXJ2aWV3IFJlYWN0IENvbXBvbmVudCBmb3IgZGlzcGxheWluZyBBdXRob3JlZCBIaW50cyBpbiB0aGVcbiAqIEluc3RydWN0aW9ucyBkaWFsb2cuIEFueSBoaW50cyB0aGUgdXNlciBoYXMgYWxyZWFkeSByZXF1ZXN0ZWQgdG8gc2VlXG4gKiBhcmUgbGlzdGVkLCBhbG9uZyB3aXRoIGEgYnV0dG9uIHRvIHNlZSB0aGUgbmV4dCBoaW50LlxuICogUHJlc3NpbmcgdGhlIGJ1dHRvbiBhZGRzIHRoZSBuZXh0IGhpbnQgKG9yIHRoZSBmaXJzdCBoaW50IGlmIG5vbmVcbiAqIGhhdmUgcHJldmlvdXNseSBiZWVuIHZpZXdlZCkgdG8gdGhlIGxpc3Qgb2YgaGludHMgYW5kIHJlbW92ZXMgdGhlXG4gKiBidXR0b24uXG4gKiBDbG9zaW5nIHRoZSBpbnN0cnVjdGlvbnMgYW5kIHJlLW9wZW5pbmcgdGhlbSB3aWxsIHJlc2V0IHRoaXNcbiAqIENvbXBvbmVudCwgYWxsb3dpbmcgdGhlIGJ1dHRvbiB0byBiZSBwcmVzc2VkIG9uY2UgbW9yZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGludFJldmlld1RpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgc2VlbkhpbnRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMub2JqZWN0KS5pc1JlcXVpcmVkLFxuICAgIHVuc2VlbkhpbnRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMub2JqZWN0KS5pc1JlcXVpcmVkLFxuICAgIG9uVXNlclZpZXdlZEhpbnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbGlnaHRidWxiU1ZHOiBSZWFjdC5Qcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93TmV4dFVuc2VlbkhpbnQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICB2aWV3SGludDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJvcHMub25Vc2VyVmlld2VkSGludCgpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd05leHRVbnNlZW5IaW50OiB0cnVlXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hbnkgb2Ygb3VyIGhpbnRzIGluY2x1ZGUgQmxvY2tseSBibG9ja3MuIFVuZm9ydHVuYXRlbHksIEJsb2NrbHlcbiAgICogQmxvY2tTcGFjZXMgaGF2ZSBhIHJlYWwgcHJvYmxlbSB3aXRoIGJlaW5nIGNyZWF0ZWQgYmVmb3JlIHRoZXkgYXJlXG4gICAqIGluIHRoZSBET00sIHNvIHdlIG5lZWQgdG8gaW5qZWN0IHRoaXMgQmxvY2tTcGFjZSBvdXRzaWRlIG9mIG91clxuICAgKiBSZWFjdCByZW5kZXIgbWV0aG9kIG9uY2Ugd2UncmUgY29uZmlkZW50IHRoYXQgdGhpcyBjb21wb25lbnQgaXMgaW5cbiAgICogdGhlIERPTS5cbiAgICovXG4gIGluamVjdEJsb2NrbHlIaW50OiBmdW5jdGlvbiAoaGludCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZnNbaGludC5oaW50SWRdO1xuICAgIHJlZi5pbmplY3RCbG9ja2x5SGludCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm93IHRoYXQgd2UncmUgaW4gdGhlIERPTSwgd2UgY2FuIHJlbmRlciBvdXIgQmxvY2tseSBibG9ja3MgZm9yXG4gICAgLy8gdGhvc2UgaGludHMgdGhhdCBoYXZlIHRoZW1cbiAgICB0aGlzLnByb3BzLnNlZW5IaW50cy5maWx0ZXIoZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIHJldHVybiBoaW50LmJsb2NrO1xuICAgIH0pLmZvckVhY2godGhpcy5pbmplY3RCbG9ja2x5SGludCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgb3VyIHVwZGF0ZSBoYXMgdXMgc2hvd2luZyBhIG5ldyBoaW50LCBtYWtlIHN1cmUgdG8gcmVuZGVyIHRoZVxuICAgIC8vIGJsb2NrIGlmIGl0IGhhcyBvbmVcbiAgICBpZiAodGhpcy5zdGF0ZS5zaG93TmV4dFVuc2VlbkhpbnQgJiYgdGhpcy5wcm9wcy51bnNlZW5IaW50c1swXS5ibG9jaykge1xuICAgICAgdGhpcy5pbmplY3RCbG9ja2x5SGludCh0aGlzLnByb3BzLnVuc2VlbkhpbnRzWzBdKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpbnRzVG9TaG93ID0gdGhpcy5wcm9wcy5zZWVuSGludHM7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd05leHRVbnNlZW5IaW50KSB7XG4gICAgICBoaW50c1RvU2hvdyA9IGhpbnRzVG9TaG93LmNvbmNhdCh0aGlzLnByb3BzLnVuc2VlbkhpbnRzWzBdKTtcbiAgICB9XG5cbiAgICB2YXIgc2VlbkhpbnRzO1xuICAgIGlmIChoaW50c1RvU2hvdyAmJiBoaW50c1RvU2hvdy5sZW5ndGgpIHtcbiAgICAgIHNlZW5IaW50cyA9IFtcbiAgICAgICAgICA8aDE+eyB0aGlzLnByb3BzLmhpbnRSZXZpZXdUaXRsZSB9PC9oMT4sXG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAge2hpbnRzVG9TaG93Lm1hcChmdW5jdGlvbiAoaGludCkge1xuICAgICAgICAgICAgICByZXR1cm4gPEhpbnQgaGludD17aGludH0gcmVmPXtoaW50LmhpbnRJZH0gLz47XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgdmlld0hpbnRCdXR0b247XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNob3dOZXh0VW5zZWVuSGludCAmJiB0aGlzLnByb3BzLnVuc2VlbkhpbnRzICYmIHRoaXMucHJvcHMudW5zZWVuSGludHMubGVuZ3RoKSB7XG4gICAgICB2aWV3SGludEJ1dHRvbiA9IChcbiAgICAgICAgPGJ1dHRvbiBpZD1cImhpbnQtYnV0dG9uXCIgb25DbGljaz17IHRoaXMudmlld0hpbnQgfSBjbGFzc05hbWU9XCJsaWdodGJ1bGItYnV0dG9uXCI+XG4gICAgICAgICAgPHNwYW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB0aGlzLnByb3BzLmxpZ2h0YnVsYlNWRyB9fSAvPlxuICAgICAgICAgIHttc2cuaGludFNlbGVjdE5ld0hpbnQoKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImF1dGhvcmVkLWhpbnRzXCI+XG4gICAgICB7c2VlbkhpbnRzfVxuICAgICAge3ZpZXdIaW50QnV0dG9ufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaW50OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICAvKipcbiAgICogQHNlZSBIaW50c0Rpc3BsYXkuaW5qZWN0QmxvY2tseUhpbnRcbiAgICovXG4gIGluamVjdEJsb2NrbHlIaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnMuaGludEJsb2NrKTtcbiAgICAvLyBPbmx5IHJlbmRlciBpZiB0aGUgbm9kZSBleGlzdHMgaW4gdGhlIERPTVxuICAgIGlmIChub2RlICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIEJsb2NrbHkuQmxvY2tTcGFjZS5jcmVhdGVSZWFkT25seUJsb2NrU3BhY2Uobm9kZSwgdGhpcy5wcm9wcy5oaW50LmJsb2NrKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhpbnRCbG9jaztcbiAgICBpZiAodGhpcy5wcm9wcy5oaW50LmJsb2NrKSB7XG4gICAgICBoaW50QmxvY2sgPSAoPGRpdiBjbGFzc05hbWU9XCJibG9jay1oaW50XCIgcmVmPVwiaGludEJsb2NrXCIgaWQ9eyB0aGlzLnByb3BzLmhpbnQuaGludElkIH0gc3R5bGU9e3sgbWF4SGVpZ2h0OiAnMTAwcHgnIH19IC8+KTtcbiAgICB9XG4gICAgcmV0dXJuICg8bGkgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAnMTJweCcgfX0+XG4gICAgICA8ZGl2IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbCA6IHRoaXMucHJvcHMuaGludC5jb250ZW50IH19IC8+XG4gICAgICB7aGludEJsb2NrfVxuICAgIDwvbGk+KTtcbiAgfSxcbn0pO1xuXG4iLCJ2YXIgbXNnID0gcmVxdWlyZSgnLi4vbG9jYWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBwcm9wVHlwZXM6IHtcbiAgICBzaG93SW5zdHJ1Y3Rpb25zOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHNob3dIaW50OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8aDQ+e21zZy5oaW50UHJvbXB0KCl9PC9oND5cbiAgICAgICAgPGEgY2xhc3NOYW1lPSdidG4gYnRuLWxpbmsgc2hvdy1pbnN0cnVjdGlvbnMnIG9uQ2xpY2s9e3RoaXMucHJvcHMuc2hvd0luc3RydWN0aW9uc30+e21zZy5oaW50U2VsZWN0SW5zdHJ1Y3Rpb25zKCl9PC9hPlxuICAgICAgICA8YSBjbGFzc05hbWU9J2J0biBidG4tbGluayBzaG93LWhpbnQnIG9uQ2xpY2s9e3RoaXMucHJvcHMuc2hvd0hpbnR9Pnttc2cuaGludFNlbGVjdE5ld0hpbnQoKX08L2E+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59KTtcbiIsIi8qIGdsb2JhbCBtYXJrZWQgKi9cbnZhciBwYXJzZVhtbEVsZW1lbnQgPSByZXF1aXJlKCcuL3htbCcpLnBhcnNlRWxlbWVudDtcbnZhciBtc2cgPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG4vKipcbiAqIEBvdmVydmlldyBBIGhlbHBlciBjbGFzcyBmb3IgYWxsIGFjdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBBdXRob3JlZFxuICogSGludCB2aWV3aW5nIGFuZCBsb2dnaW5nIHN5c3RlbS5cbiAqXG4gKiBUaGUgZ2VuZXJhbCBwYXR0ZXJuIGZvciB1c2FnZSBpcyBzdHJhaWdodGZvcndhcmQ6XG4gKlxuICogRXZlcnkgdGltZSBhIHVzZXIgcmVxdWVzdHMgdG8gdmlldyBhIG5ldyBoaW50LCB3ZSBsb2cgaW5mb3JtYXRpb25cbiAqIGFib3V0IHRoYXQgaGludCBhcyB3ZWxsIGFzIHRoZSBtb3N0IHJlY2VudCBhdHRlbXB0LlxuICpcbiAqIEV2ZXJ5IHRpbWUgYSB1c2VyIG1ha2VzIGFuIFwiYXR0ZW1wdFwiIGF0IHRoZSBsZXZlbCBhbmQgc2VuZCBhbiBhdHRlbXB0XG4gKiByZXBvcnQsIHdlIHNhdmUgc29tZSBpbmZvcm1hdGlvbiBhYm91dCB0aGF0IG1vc3QgcmVjZW50IGF0dGVtcHQsIGFuZFxuICogYWRkIHRoYXQgaW5mb3JtYXRpb24gdG8gYWxsIGhpbnQgdmlld3MgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbiAqXG4gKiBGaW5hbGx5LCB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyB0byBhIG5ldyBwYWdlIChlaXRoZXIgYnkgY29tcGxldGluZ1xuICogdGhlIGxldmVsIGFuZCBtb3Zpbmcgb24gb3IgYnkgbGVhdmluZyB0aGUgbGV2ZWwgYW5kIGNvbWluZyBiYWNrXG4gKiBsYXRlciksIHdlIHJlY29yZCBmb3IgYWxsIGhpbnRzIHRoZSBcImZpbmFsXCIgYXR0ZW1wdCBpbiB0aGF0IHNlc3Npb25cbiAqIGFuZCBwb3N0IHRoZSByZXN1bHRzIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogVGh1cywgZWFjaCBoaW50IGhhcyB0aHJlZSBhdHRlbXB0IHJlY29yZHMgYnkgdGhlIGVuZCBvZiB0aGVcbiAqIGxpZmVjeWNsZTpcbiAqICAxKSBhIFwicHJldmlvdXNcIiBhdHRlbXB0IChjYW4gYmUgZW1wdHkpXG4gKiAgMikgYSBcIm5leHRcIiBhdHRlbXB0XG4gKiAgMykgYSBcImZpbmFsXCIgYXR0ZW1wdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSGludERhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY3JpcHRJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsSWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaW50SWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaW50Q2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaW50VHlwZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuZmluaXNoZWRIaW50XG4gKiBAYXVnbWVudHMgSGludERhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJldlRpbWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZXZBdHRlbXB0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmV2VGVzdFJlc3VsdF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJldkFjdGl2aXR5SWRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZXZMZXZlbFNvdXJjZUlkXVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbmlzaGVkSGludFxuICogQGF1Z21lbnRzIFVuZmluaXNoZWRIaW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gbmV4dFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0QXR0ZW1wdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHRUZXN0UmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbmV4dEFjdGl2aXR5SWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0TGV2ZWxTb3VyY2VJZFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbmFsaXplZEhpbnRcbiAqIEBhdWdtZW50cyBGaW5pc2hlZEhpbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaW5hbFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaW5hbEF0dGVtcHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaW5hbFRlc3RSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaW5hbEFjdGl2aXR5SWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaW5hbExldmVsU291cmNlSWRcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdHRlbXB0UmVjb3JkXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF0dGVtcHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXN0UmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gYWN0aXZpdHlJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsU291cmNlSWRcbiAqL1xuXG52YXIgYXV0aG9yZWRIaW50VXRpbHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXRob3JlZEhpbnRVdGlscztcblxuYXV0aG9yZWRIaW50VXRpbHMuZ2V0RnJvbUxvY2FsU3RvcmFnZV8gPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0ID8gSlNPTi5wYXJzZShyZXN1bHQpIDogZGVmYXVsdFZhbHVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0ID0gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge1VuZmluaXNoZWRIaW50W119XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmdldFVuZmluaXNoZWRIaW50c18gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhdXRob3JlZEhpbnRVdGlscy5nZXRGcm9tTG9jYWxTdG9yYWdlXygndW5maW5pc2hlZF9hdXRob3JlZF9oaW50X3ZpZXdzJywgW10pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtGaW5pc2hlZEhpbnRbXX1cbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMuZ2V0RmluaXNoZWRIaW50c18gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhdXRob3JlZEhpbnRVdGlscy5nZXRGcm9tTG9jYWxTdG9yYWdlXygnZmluaXNoZWRfYXV0aG9yZWRfaGludF92aWV3cycsIFtdKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7QXR0ZW1wdFJlY29yZH1cbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMuZ2V0TGFzdEF0dGVtcHRSZWNvcmRfID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXV0aG9yZWRIaW50VXRpbHMuZ2V0RnJvbUxvY2FsU3RvcmFnZV8oJ2xhc3RfYXR0ZW1wdF9yZWNvcmQnLCB1bmRlZmluZWQpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBoaW50cyB0byB0aGUgYXJyYXkgb2YgZXhpc3RpbmcgRmluaXNoZWRIaW50c1xuICogQHBhcmFtIHtGaW5pc2hlZEhpbnRbXX0gaGludHNcbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMucmVjb3JkRmluaXNoZWRIaW50c18gPSBmdW5jdGlvbiAoaGludHMpIHtcbiAgdmFyIGZpbmlzaGVkSGludFZpZXdzID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0RmluaXNoZWRIaW50c18oKTtcbiAgZmluaXNoZWRIaW50Vmlld3MgPSBmaW5pc2hlZEhpbnRWaWV3cy5jb25jYXQoaGludHMpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZmluaXNoZWRfYXV0aG9yZWRfaGludF92aWV3cycsIEpTT04uc3RyaW5naWZ5KGZpbmlzaGVkSGludFZpZXdzKSk7XG59O1xuXG5hdXRob3JlZEhpbnRVdGlscy5jbGVhclVuZmluaXNoZWRIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VuZmluaXNoZWRfYXV0aG9yZWRfaGludF92aWV3cycsIEpTT04uc3RyaW5naWZ5KFtdKSk7XG59O1xuXG5hdXRob3JlZEhpbnRVdGlscy5jbGVhckZpbmlzaGVkSGludHNfID0gZnVuY3Rpb24gKCkge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZmluaXNoZWRfYXV0aG9yZWRfaGludF92aWV3cycsIEpTT04uc3RyaW5naWZ5KFtdKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0ZpbmFsaXplZEhpbnRzW119XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmZpbmFsaXplSGludHNfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmluYWxBdHRlbXB0UmVjb3JkID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0TGFzdEF0dGVtcHRSZWNvcmRfKCk7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdsYXN0X2F0dGVtcHRfcmVjb3JkJyk7XG4gIHZhciBoaW50cyA9IGF1dGhvcmVkSGludFV0aWxzLmdldEZpbmlzaGVkSGludHNfKCk7XG4gIGlmIChmaW5hbEF0dGVtcHRSZWNvcmQpIHtcbiAgICBoaW50cyA9IGhpbnRzLm1hcChmdW5jdGlvbihoaW50KXtcbiAgICAgIGhpbnQgPSAkLmV4dGVuZCh7XG4gICAgICAgIGZpbmFsVGltZTogZmluYWxBdHRlbXB0UmVjb3JkLnRpbWUsXG4gICAgICAgIGZpbmFsQXR0ZW1wdDogZmluYWxBdHRlbXB0UmVjb3JkLmF0dGVtcHQsXG4gICAgICAgIGZpbmFsVGVzdFJlc3VsdDogZmluYWxBdHRlbXB0UmVjb3JkLnRlc3RSZXN1bHQsXG4gICAgICAgIGZpbmFsQWN0aXZpdHlJZDogZmluYWxBdHRlbXB0UmVjb3JkLmFjdGl2aXR5SWQsXG4gICAgICAgIGZpbmFsTGV2ZWxTb3VyY2VJZDogZmluYWxBdHRlbXB0UmVjb3JkLmxldmVsU291cmNlSWQsXG4gICAgICB9LCBoaW50KTtcbiAgICAgIHJldHVybiBoaW50O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBoaW50cztcbn07XG5cbi8qKlxuICogQWRkcyBhIGhpbnQgdG8gdGhlIGxpc3Qgb2YgXCJ1bmZpbmlzaGVkXCIgaGludHMgZm9yIHRoZSBhdHRlbXB0XG4gKiBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuIElmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBhdHRlbXB0IG9mIHRoZVxuICogc2Vzc2lvbiwgc2F2ZSBhbG9uZyB3aXRoIHRoZSBoaW50IGEgcmVjb3JkIG9mIHRoZSBtb3N0IHJlY2VudFxuICogYXR0ZW1wdC5cbiAqXG4gKiBAcGFyYW0ge0hpbnREYXRhfSBoaW50XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLnJlY29yZFVuZmluaXNoZWRIaW50ID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgdmFyIGxhc3RBdHRlbXB0UmVjb3JkID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0TGFzdEF0dGVtcHRSZWNvcmRfKCk7XG4gIGlmIChsYXN0QXR0ZW1wdFJlY29yZCkge1xuICAgIGhpbnQgPSAkLmV4dGVuZCh7XG4gICAgICBwcmV2VGltZTogbGFzdEF0dGVtcHRSZWNvcmQudGltZSxcbiAgICAgIHByZXZBdHRlbXB0OiBsYXN0QXR0ZW1wdFJlY29yZC5hdHRlbXB0LFxuICAgICAgcHJldlRlc3RSZXN1bHQ6IGxhc3RBdHRlbXB0UmVjb3JkLnRlc3RSZXN1bHQsXG4gICAgICBwcmV2QWN0aXZpdHlJZDogbGFzdEF0dGVtcHRSZWNvcmQuYWN0aXZpdHlJZCxcbiAgICAgIHByZXZMZXZlbFNvdXJjZUlkOiBsYXN0QXR0ZW1wdFJlY29yZC5sZXZlbFNvdXJjZUlkLFxuICAgIH0sIGhpbnQpO1xuICB9XG4gIHZhciB1bmZpbmlzaGVkSGludFZpZXdzID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0VW5maW5pc2hlZEhpbnRzXygpO1xuICB1bmZpbmlzaGVkSGludFZpZXdzLnB1c2goaGludCk7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1bmZpbmlzaGVkX2F1dGhvcmVkX2hpbnRfdmlld3MnLCBKU09OLnN0cmluZ2lmeSh1bmZpbmlzaGVkSGludFZpZXdzKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXR0ZW1wdFJlY29yZH0gbmV4dEF0dGVtcHRSZWNvcmRcbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMuZmluaXNoSGludHMgPSBmdW5jdGlvbiAobmV4dEF0dGVtcHRSZWNvcmQpIHtcbiAgaWYgKCFuZXh0QXR0ZW1wdFJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbGFzdF9hdHRlbXB0X3JlY29yZCcsIEpTT04uc3RyaW5naWZ5KG5leHRBdHRlbXB0UmVjb3JkKSk7XG4gIHZhciB1bmZpbmlzaGVkSGludFZpZXdzID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0VW5maW5pc2hlZEhpbnRzXygpO1xuICBhdXRob3JlZEhpbnRVdGlscy5jbGVhclVuZmluaXNoZWRIaW50cygpO1xuICB2YXIgZmluaXNoZWRIaW50Vmlld3MgPSB1bmZpbmlzaGVkSGludFZpZXdzLm1hcChmdW5jdGlvbihoaW50KXtcbiAgICBoaW50ID0gJC5leHRlbmQoe1xuICAgICAgbmV4dFRpbWU6IG5leHRBdHRlbXB0UmVjb3JkLnRpbWUsXG4gICAgICBuZXh0QXR0ZW1wdDogbmV4dEF0dGVtcHRSZWNvcmQuYXR0ZW1wdCxcbiAgICAgIG5leHRUZXN0UmVzdWx0OiBuZXh0QXR0ZW1wdFJlY29yZC50ZXN0UmVzdWx0LFxuICAgICAgbmV4dEFjdGl2aXR5SWQ6IG5leHRBdHRlbXB0UmVjb3JkLmFjdGl2aXR5SWQsXG4gICAgICBuZXh0TGV2ZWxTb3VyY2VJZDogbmV4dEF0dGVtcHRSZWNvcmQubGV2ZWxTb3VyY2VJZCxcbiAgICB9LCBoaW50KTtcbiAgICByZXR1cm4gaGludDtcbiAgfSk7XG4gIGF1dGhvcmVkSGludFV0aWxzLnJlY29yZEZpbmlzaGVkSGludHNfKGZpbmlzaGVkSGludFZpZXdzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICovXG5hdXRob3JlZEhpbnRVdGlscy5zdWJtaXRIaW50cyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgLy8gZmlyc3QsIGZpbmlzaCBhbGwgdW5maW5pc2hlZCBoaW50c1xuICB2YXIgdW5maW5pc2hlZEhpbnRzID0gYXV0aG9yZWRIaW50VXRpbHMuZ2V0VW5maW5pc2hlZEhpbnRzXygpO1xuICBpZiAodW5maW5pc2hlZEhpbnRzICYmIHVuZmluaXNoZWRIaW50cy5sZW5ndGgpIHtcbiAgICB2YXIgZmluYWxIaW50ID0gdW5maW5pc2hlZEhpbnRzW3VuZmluaXNoZWRIaW50cy5sZW5ndGgtMV07XG4gICAgYXV0aG9yZWRIaW50VXRpbHMuZmluaXNoSGludHMoe1xuICAgICAgdGltZTogZmluYWxIaW50LnByZXZUaW1lLFxuICAgICAgYXR0ZW1wdDogZmluYWxIaW50LnByZXZBdHRlbXB0LFxuICAgICAgdGVzdFJlc3VsdDogZmluYWxIaW50LnByZXZUZXN0UmVzdWx0LFxuICAgICAgYWN0aXZpdHlJZDogZmluYWxIaW50LnByZXZBY3Rpdml0eUlkLFxuICAgICAgbGV2ZWxTb3VyY2VJZDogZmluYWxIaW50LnByZXZMZXZlbFNvdXJjZUlkLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gdGhlbiwgZmluYWxpemUgYWxsIGhpbnRzXG4gIHZhciBoaW50cyA9IGF1dGhvcmVkSGludFV0aWxzLmZpbmFsaXplSGludHNfKCk7XG5cbiAgLy8gbm93LCBhbGwgaGludHMgc2hvdWxkIGJlIGZpbmlzaGVkIGFuZCBmaW5hbGl6ZWQuIFNvIHN1Ym1pdCB0aGVtIGFsbFxuICBpZiAoaGludHMgJiYgaGludHMubGVuZ3RoKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe2hpbnRzOiBoaW50c30pLFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXV0aG9yZWRIaW50VXRpbHMuY2xlYXJGaW5pc2hlZEhpbnRzXygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBjb250ZXh0dWFsIGhpbnRzIGFzIHVzZWQgYnkgU3R1ZGlvQXBwIGZyb20gQmxvY2tseSBYTUxcbiAqIEBwYXJhbSB7T2JqZWN0W119IGJsb2NrcyBBbiBhcnJheSBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICAgICBtaXNzaW5nIHJlY29tbWVuZGVkIEJsb2NrbHkgQmxvY2tzIGZvciB3aGljaCB3ZSB3YW50IHRvXG4gKiAgICAgICAgY3JlYXRlIGhpbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2Nrc1tdLmJsb2NrRGlzcGxheVhNTFxuICogQHBhcmFtIHtib29sZWFufSBibG9ja3NbXS5hbHJlYWR5U2VlblxuICogQHJldHVybiB7QXV0aG9yZWRIaW50W119XG4gKi9cbmF1dGhvcmVkSGludFV0aWxzLmNyZWF0ZUNvbnRleHR1YWxIaW50c0Zyb21CbG9ja3MgPSBmdW5jdGlvbiAoYmxvY2tzKSB7XG4gIHZhciBoaW50cyA9IGJsb2Nrcy5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgdmFyIHhtbEJsb2NrID0gcGFyc2VYbWxFbGVtZW50KGJsb2NrLmJsb2NrRGlzcGxheVhNTCk7XG4gICAgdmFyIGJsb2NrVHlwZSA9IHhtbEJsb2NrLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogbWFya2VkKG1zZy5yZWNvbW1lbmRlZEJsb2NrQ29udGV4dHVhbEhpbnRUaXRsZSgpKSxcbiAgICAgIGJsb2NrOiB4bWxCbG9jayxcbiAgICAgIGhpbnRJZDogXCJyZWNvbW1lbmRlZF9ibG9ja19cIiArIGJsb2NrVHlwZSxcbiAgICAgIGhpbnRDbGFzczogJ3JlY29tbWVuZGVkJyxcbiAgICAgIGhpbnRUeXBlOiAnY29udGV4dHVhbCcsXG4gICAgICBhbHJlYWR5U2VlbjogYmxvY2suYWxyZWFkeVNlZW5cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGhpbnRzO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYXV0aG9yZWQgaGludHMgYXMgdXNlZCBieSBTdHVkaW9BcHAgZnJvbSBsZXZlbGJ1aWxkZXIgSlNPTi5cbiAqIEBwYXJhbSB7c3RyaW5nfSAtIEpTT04gcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIGhpbnRzXG4gKiBAcmV0dXJuIHtBdXRob3JlZEhpbnRbXX1cbiAqL1xuYXV0aG9yZWRIaW50VXRpbHMuZ2VuZXJhdGVBdXRob3JlZEhpbnRzID0gZnVuY3Rpb24gKGxldmVsQnVpbGRlckF1dGhvcmVkSGludHMpIHtcbiAgaWYgKCFtYXJrZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGhpbnRzO1xuICB0cnkge1xuICAgIGhpbnRzID0gSlNPTi5wYXJzZShsZXZlbEJ1aWxkZXJBdXRob3JlZEhpbnRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhpbnRzID0gW107XG4gIH1cbiAgcmV0dXJuIGhpbnRzLm1hcChmdW5jdGlvbiAoaGludCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBtYXJrZWQoaGludC5oaW50X21hcmtkb3duKSxcbiAgICAgIGhpbnRJZDogaGludC5oaW50X2lkLFxuICAgICAgaGludENsYXNzOiBoaW50LmhpbnRfY2xhc3MsXG4gICAgICBoaW50VHlwZTogaGludC5oaW50X3R5cGUsXG4gICAgICBhbHJlYWR5U2VlbjogZmFsc2VcbiAgICB9O1xuICB9KTtcbn07XG5cbiIsIi8vIFNlcmlhbGl6ZXMgYW4gWE1MIERPTSBub2RlIHRvIGEgc3RyaW5nLlxuZXhwb3J0cy5zZXJpYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcobm9kZSk7XG59O1xuXG4vLyBQYXJzZXMgYSBzaW5nbGUgcm9vdCBlbGVtZW50IHN0cmluZywgd3JhcHBpbmcgaXQgaW4gYW4gPHhtbC8+IGVsZW1lbnRcbmV4cG9ydHMucGFyc2VFbGVtZW50ID0gZnVuY3Rpb24odGV4dCkge1xuICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gIHZhciBkb20gPSB0ZXh0LmluZGV4T2YoJzx4bWwnKSA9PT0gMCA/XG4gICAgICBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsICd0ZXh0L3htbCcpIDpcbiAgICAgIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoJzx4bWw+JyArIHRleHQgKyAnPC94bWw+JywgJ3RleHQveG1sJyk7XG4gIHZhciBlcnJvcnMgPSBkb20uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKTtcbiAgdmFyIGVsZW1lbnQgPSBkb20uZmlyc3RDaGlsZDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3RoaW5nIHBhcnNlZCcpO1xuICB9XG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLnNlcmlhbGl6ZShlcnJvcnNbMF0pKTtcbiAgfVxuICBpZiAoZWxlbWVudCAhPT0gZG9tLmxhc3RDaGlsZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VkIG11bHRpcGxlIGVsZW1lbnRzJyk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuIiwiLy8gRm9yIHByb3h5aW5nIG5vbi1odHRwcyBhc3NldHNcbnZhciBNRURJQV9QUk9YWSA9ICcvLycgKyBsb2NhdGlvbi5ob3N0ICsgJy9tZWRpYT91PSc7XG5cbi8vIHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHNcbnZhciBBQlNPTFVURV9SRUdFWFAgPSBuZXcgUmVnRXhwKCdeaHR0cHM/Oi8vJywgJ2knKTtcblxudmFyIGFzc2V0UGF0aFByZWZpeCA9IFwiL3YzL2Fzc2V0cy9cIjtcbnZhciBjaGFubmVsSWQ7XG5cbm1vZHVsZS5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIGlmIChjb25maWcuYXNzZXRQYXRoUHJlZml4KSB7XG4gICAgYXNzZXRQYXRoUHJlZml4ID0gY29uZmlnLmFzc2V0UGF0aFByZWZpeDtcbiAgfVxuICBpZiAoY29uZmlnLmNoYW5uZWwpIHtcbiAgICBjaGFubmVsSWQgPSBjb25maWcuY2hhbm5lbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiB0aGUgZmlsZW5hbWUgaXMgcmVsYXRpdmUgKGNvbnRhaW5zIG5vIHNsYXNoZXMpLCB0aGVuIHByZXBlbmRcbiAqIHRoZSBwYXRoIHRvIHRoZSBhc3NldHMgZGlyZWN0b3J5IGZvciB0aGlzIHByb2plY3QgdG8gdGhlIGZpbGVuYW1lLlxuICpcbiAqIElmIHRoZSBmaWxlbmFtZSBVUkwgaXMgYWJzb2x1dGUsIHJvdXRlIGl0IHRocm91Z2ggdGhlIE1FRElBX1BST1hZLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cy5maXhQYXRoID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG5cbiAgaWYgKEFCU09MVVRFX1JFR0VYUC50ZXN0KGZpbGVuYW1lKSkge1xuICAgIC8vIFdlIHdhbnQgdG8gYmUgYWJsZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3VyIGZpbGVuYW1lIGNvbnRhaW5zIGFcbiAgICAvLyBzcGFjZSwgaS5lLiBcInd3dy5leGFtcGxlLmNvbS9pbWFnZXMvZm9vIGJhci5wbmdcIiwgZXZlbiB0aG91Z2ggdGhpcyBpcyBhXG4gICAgLy8gdGVjaG5pY2FsbHkgaW52YWxpZCBVUkwuIGVuY29kZVVSSUNvbXBvbmVudCB3aWxsIHJlcGxhY2Ugc3BhY2Ugd2l0aCAlMjBcbiAgICAvLyBmb3IgdXMsIGJ1dCBhcyBzb29uIGFzIGl0J3MgZGVjb2RlZCwgd2UgYWdhaW4gaGF2ZSBhbiBpbnZhbGlkIFVSTC4gRm9yXG4gICAgLy8gdGhpcyByZWFzb24gd2UgZmlyc3QgcmVwbGFjZSBzcGFjZSB3aXRoICUyMCBvdXJzZWx2ZXMsIHN1Y2ggdGhhdCB3ZSBub3dcbiAgICAvLyBoYXZlIGEgdmFsaWQgVVJMLCBhbmQgdGhlbiBjYWxsIGVuY29kZVVSSUNvbXBvbmVudCBvbiB0aGUgcmVzdWx0LlxuICAgIHJldHVybiBNRURJQV9QUk9YWSArIGVuY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZS5yZXBsYWNlKC8gL2csICclMjAnKSk7XG4gIH1cblxuICBmaWxlbmFtZSA9IGZpbGVuYW1lIHx8ICcnO1xuICBpZiAoZmlsZW5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcvYmxvY2tseS9tZWRpYS8xeDEuZ2lmJztcbiAgfVxuXG4gIGlmIChmaWxlbmFtZS5pbmRleE9mKCcvJykgIT09IC0xIHx8ICFjaGFubmVsSWQpIHtcbiAgICByZXR1cm4gZmlsZW5hbWU7XG4gIH1cblxuICByZXR1cm4gYXNzZXRQYXRoUHJlZml4ICsgY2hhbm5lbElkICsgJy8nICsgZmlsZW5hbWU7XG59O1xuIiwidmFyIGFzc2V0cyA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVzZXQ6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgYXNzZXRzID0gbGlzdC5zbGljZSgpO1xuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKGFzc2V0KSB7XG4gICAgYXNzZXRzLnB1c2goYXNzZXQpO1xuICAgIHJldHVybiBhc3NldHMuc2xpY2UoKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgIGFzc2V0cyA9IGFzc2V0cy5maWx0ZXIoZnVuY3Rpb24gKGFzc2V0KSB7XG4gICAgICByZXR1cm4gYXNzZXQuZmlsZW5hbWUgIT09IGZpbGVuYW1lO1xuICAgIH0pO1xuICAgIHJldHVybiBhc3NldHMuc2xpY2UoKTtcbiAgfSxcblxuICBsaXN0OiBmdW5jdGlvbiAodHlwZUZpbHRlcikge1xuICAgIHJldHVybiB0eXBlRmlsdGVyID8gYXNzZXRzLmZpbHRlcihmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICAgIHJldHVybiBhc3NldC5jYXRlZ29yeSA9PT0gdHlwZUZpbHRlcjtcbiAgICB9KSA6IGFzc2V0cy5zbGljZSgpO1xuICB9XG59O1xuIiwiLyogZ2xvYmFsIGFjZSAqL1xudmFyIGRyb3BsZXRVdGlscyA9IHJlcXVpcmUoJy4uL2Ryb3BsZXRVdGlscycpO1xudmFyIGFubm90YXRpb25MaXN0ID0gcmVxdWlyZSgnLi9hbm5vdGF0aW9uTGlzdCcpO1xuXG5leHBvcnRzLmRlZmluZUZvckFjZSA9IGZ1bmN0aW9uIChkcm9wbGV0Q29uZmlnLCB1bnVzZWRDb25maWcsIGRyb3BsZXRFZGl0b3IpIHtcbiAgLy8gZGVmaW5lIG91cnNlbHZlcyBmb3IgYWNlLCBzbyB0aGF0IGl0IGtub3dzIHdoZXJlIHRvIGdldCB1c1xuICBhY2UuZGVmaW5lKFwiYWNlL21vZGUvamF2YXNjcmlwdF9jb2Rlb3JnXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL21vZGUvamF2YXNjcmlwdFwiLFwiYWNlL21vZGUvamF2YXNjcmlwdF9oaWdobGlnaHRfcnVsZXNcIixcImFjZS93b3JrZXIvd29ya2VyX2NsaWVudFwiLFwiYWNlL21vZGUvbWF0Y2hpbmdfYnJhY2Vfb3V0ZGVudFwiLFwiYWNlL21vZGUvYmVoYXZpb3VyL2NzdHlsZVwiLFwiYWNlL21vZGUvZm9sZGluZy9jc3R5bGVcIixcImFjZS9jb25maWdcIixcImFjZS9saWIvbmV0XCIsXCJhY2UvZXh0L3NlYXJjaGJveFwiXSwgZnVuY3Rpb24oYWNlcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgICB2YXIgb29wID0gYWNlcmVxdWlyZShcImFjZS9saWIvb29wXCIpO1xuICAgIHZhciBKYXZhU2NyaXB0TW9kZSA9IGFjZXJlcXVpcmUoXCJhY2UvbW9kZS9qYXZhc2NyaXB0XCIpLk1vZGU7XG4gICAgdmFyIEphdmFTY3JpcHRIaWdobGlnaHRSdWxlcyA9IGFjZXJlcXVpcmUoXCJhY2UvbW9kZS9qYXZhc2NyaXB0X2hpZ2hsaWdodF9ydWxlc1wiKS5KYXZhU2NyaXB0SGlnaGxpZ2h0UnVsZXM7XG4gICAgdmFyIFdvcmtlck1vZHVsZSA9IGFjZXJlcXVpcmUoXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcIik7XG4gICAgdmFyIFdvcmtlckNsaWVudCA9IFdvcmtlck1vZHVsZS5Xb3JrZXJDbGllbnQ7XG4gICAgaWYgKCF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBzdXBwb3J0IHdlYiB3b3JrZXJzLCBkbyBldmVyeXRoaW5nIG9uIHRoZSBVSSB0aHJlYWRcbiAgICAgIFdvcmtlckNsaWVudCA9IFdvcmtlck1vZHVsZS5VSVdvcmtlckNsaWVudDtcbiAgICAgIHdpbmRvdy5Xb3JrZXIgPSBXb3JrZXJDbGllbnQ7XG4gICAgfVxuXG4gICAgdmFyIE1hdGNoaW5nQnJhY2VPdXRkZW50ID0gYWNlcmVxdWlyZShcIi4vbWF0Y2hpbmdfYnJhY2Vfb3V0ZGVudFwiKS5NYXRjaGluZ0JyYWNlT3V0ZGVudDtcbiAgICB2YXIgQ3N0eWxlQmVoYXZpb3VyID0gYWNlcmVxdWlyZShcIi4vYmVoYXZpb3VyL2NzdHlsZVwiKS5Dc3R5bGVCZWhhdmlvdXI7XG4gICAgdmFyIENTdHlsZUZvbGRNb2RlID0gYWNlcmVxdWlyZShcIi4vZm9sZGluZy9jc3R5bGVcIikuRm9sZE1vZGU7XG5cbiAgICB2YXIgTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLkhpZ2hsaWdodFJ1bGVzID0gSmF2YVNjcmlwdEhpZ2hsaWdodFJ1bGVzO1xuICAgICAgICB0aGlzLiRvdXRkZW50ID0gbmV3IE1hdGNoaW5nQnJhY2VPdXRkZW50KCk7XG4gICAgICAgIHRoaXMuJGJlaGF2aW91ciA9IG5ldyBDc3R5bGVCZWhhdmlvdXIoKTtcbiAgICAgICAgdGhpcy5mb2xkaW5nUnVsZXMgPSBuZXcgQ1N0eWxlRm9sZE1vZGUoKTtcbiAgICB9O1xuICAgIG9vcC5pbmhlcml0cyhNb2RlLCBKYXZhU2NyaXB0TW9kZSk7XG5cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBNYW51YWxseSBjcmVhdGUgb3VyIGhpZ2hsaWdodCBydWxlcyBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgaXRcbiAgICAgIHRoaXMuJGhpZ2hsaWdodFJ1bGVzID0gbmV3IEphdmFTY3JpcHRIaWdobGlnaHRSdWxlcygpO1xuXG4gICAgICAvLyBXZSBuZXZlciB3YW50IHRvIHNob3cgYW55IG9mIHRoZSBidWlsdGluIGtleXdvcmRzIGluIGF1dG9jb21wbGV0ZVxuICAgICAgdGhpcy4kaGlnaGxpZ2h0UnVsZXMuJGtleXdvcmRMaXN0ID0gW107XG5cbiAgICAgIHRoaXMuY3JlYXRlV29ya2VyID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlckNsaWVudChbXCJhY2VcIl0sIFwiYWNlL21vZGUvamF2YXNjcmlwdF93b3JrZXJcIiwgXCJKYXZhU2NyaXB0V29ya2VyXCIpO1xuICAgICAgICB3b3JrZXIuYXR0YWNoVG9Eb2N1bWVudChzZXNzaW9uLmdldERvY3VtZW50KCkpO1xuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHtcbiAgICAgICAgICB1bnVzZWQ6IHRydWUsXG4gICAgICAgICAgdW5kZWY6IHRydWUsXG4gICAgICAgICAgbWF4ZXJyOiAxMDAwLFxuICAgICAgICAgIHByZWRlZjoge1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwb3J0ZWQ6IHtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBNYXJrIGFsbCBvZiBvdXIgYmxvY2tzIGFzIHByZWRlZmluZWQgc28gdGhhdCBsaW50ZXIgZG9lc250IGNvbXBsYWluIGFib3V0XG4gICAgICAgIC8vIHVzaW5nIHVuZGVmaW5lZCB2YXJpYWJsZXNcbiAgICAgICAgZHJvcGxldFV0aWxzLmdldEFsbEF2YWlsYWJsZURyb3BsZXRCbG9ja3MoZHJvcGxldENvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICBuZXdPcHRpb25zLnByZWRlZltibG9jay5mdW5jXSA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZHJvcGxldENvbmZpZy5hZGRpdGlvbmFsUHJlZGVmVmFsdWVzKSB7XG4gICAgICAgICAgZHJvcGxldENvbmZpZy5hZGRpdGlvbmFsUHJlZGVmVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5wcmVkZWZbdmFsXSA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gdGhlIHNhbWUgd2l0aCB1bnVzZWRDb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh1bnVzZWRDb25maWcpIHtcbiAgICAgICAgICB1bnVzZWRDb25maWcuZm9yRWFjaChmdW5jdGlvbiAodW51c2VkVmFyKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zLmV4cG9ydGVkW3VudXNlZFZhcl0gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFubm90YXRpb25MaXN0LmF0dGFjaFRvU2Vzc2lvbihzZXNzaW9uLCBkcm9wbGV0RWRpdG9yKTtcblxuICAgICAgICB3b3JrZXIuc2VuZChcImNoYW5nZU9wdGlvbnNcIiwgW25ld09wdGlvbnNdKTtcblxuICAgICAgICB3b3JrZXIub24oXCJqc2xpbnRcIiwgYW5ub3RhdGlvbkxpc3Quc2V0SlNMaW50QW5ub3RhdGlvbnMpO1xuXG4gICAgICAgIHdvcmtlci5vbihcInRlcm1pbmF0ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZXNzaW9uLmNsZWFyQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYW5ub3RhdGlvbkxpc3QuZGV0YWNoRnJvbVNlc3Npb24oKTtcbiAgICAgIH07XG4gICAgfSkuY2FsbChNb2RlLnByb3RvdHlwZSk7XG5cbiAgZXhwb3J0cy5Nb2RlID0gTW9kZTtcbiAgfSk7XG59O1xuIiwidmFyIGVycm9yTWFwcGVyID0gcmVxdWlyZSgnLi9lcnJvck1hcHBlcicpO1xuXG52YXIgbGludEFubm90YXRpb25zID0gW107XG52YXIgcnVudGltZUFubm90YXRpb25zID0gW107XG52YXIgYWNlU2Vzc2lvbjtcbnZhciBkcm9wbGV0RWRpdG9yO1xuXG4vKipcbiAqIFVwZGF0ZSBndXR0ZXIgd2l0aCBvdXIgYW5ub3RhdGlvbiBsaXN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXIoKSB7XG4gIGlmICghYWNlU2Vzc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkcm9wbGV0RWRpdG9yKSB7XG4gICAgLy8gRHJvcGxldCB3aWxsIGNhbGwgYWNlU2Vzc2lvbi5zZXRBbm5vdGF0aW9ucygpIHVuZGVyIHRoZSBob29kXG4gICAgLy8gZm9yIHVzXG4gICAgZHJvcGxldEVkaXRvci5zZXRBbm5vdGF0aW9ucyhsaW50QW5ub3RhdGlvbnMuY29uY2F0KHJ1bnRpbWVBbm5vdGF0aW9ucykpO1xuICB9XG4gIGVsc2Uge1xuICAgIGFjZVNlc3Npb24uc2V0QW5ub3RhdGlvbnMobGludEFubm90YXRpb25zLmNvbmNhdChydW50aW1lQW5ub3RhdGlvbnMpKTtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCBmb3IgdHJhY2tpbmcgYW5ub3RhdGlvbnMgcGxhY2VkIGluIGd1dHRlci4gR2VuZXJhbCBkZXNpZ24gaXMgYXNcbiAqIGZvbGxvd3M6XG4gKiBXaGVuIGpzbGludCBydW5zIChpLmUuIGNvZGUgY2hhbmdlcykgZGlzcGxheSBqdXN0IGpzbGludCBlcnJvcnNcbiAqIFdoZW4gY29kZSBydW5zLCBkaXNwbGF5IGpzbGludCBlcnJvcnMgYW5kIHJ1bnRpbWUgZXJyb3JzLiBSdW50aW1lIGVycm9ycyB3aWxsXG4gKiBnbyBhd2F5IHRoZSBuZXh0IHRpbWUganN0bGludCBnZXRzIHJ1biAod2hlbiBjb2RlIGNoYW5nZXMpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXRhY2hGcm9tU2Vzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgIGFjZVNlc3Npb24gPSBudWxsO1xuICAgIGRyb3BsZXRFZGl0b3IgPSBudWxsO1xuICB9LFxuXG4gIGF0dGFjaFRvU2Vzc2lvbjogZnVuY3Rpb24gKHNlc3Npb24sIGVkaXRvcikge1xuICAgIGlmIChhY2VTZXNzaW9uICYmIHNlc3Npb24gIT09IGFjZVNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSBhdHRhY2hlZCB0byBhY2Ugc2Vzc2lvbicpO1xuICAgIH1cbiAgICBhY2VTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICBkcm9wbGV0RWRpdG9yID0gZWRpdG9yO1xuICB9LFxuXG4gIHNldEpTTGludEFubm90YXRpb25zOiBmdW5jdGlvbiAoanNsaW50UmVzdWx0cykge1xuICAgIGVycm9yTWFwcGVyLnByb2Nlc3NSZXN1bHRzKGpzbGludFJlc3VsdHMpO1xuICAgIC8vIGNsb25lIGFubm90YXRpb25zIGluIGNhc2UgYW55b25lIGVsc2UgaGFzIGEgcmVmZXJlbmNlIHRvIGRhdGFcbiAgICBsaW50QW5ub3RhdGlvbnMgPSBqc2xpbnRSZXN1bHRzLmRhdGEuc2xpY2UoKTtcbiAgICB1cGRhdGVHdXR0ZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lTnVtYmVyIE9uZSBpbmRleCBsaW5lIG51bWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBFcnJvciBzdHJpbmdcbiAgICovXG4gIGFkZFJ1bnRpbWVBbm5vdGF0aW9uOiBmdW5jdGlvbiAobGV2ZWwsIGxpbmVOdW1iZXIsIHRleHQpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IHtcbiAgICAgIHJvdzogbGluZU51bWJlciAtIDEsXG4gICAgICBjb2w6IDAsXG4gICAgICByYXc6IHRleHQsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgdHlwZTogbGV2ZWwudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgcnVudGltZUFubm90YXRpb25zLnB1c2goYW5ub3RhdGlvbik7XG4gICAgdXBkYXRlR3V0dGVyKCk7XG4gIH0sXG5cbiAgY2xlYXJSdW50aW1lQW5ub3RhdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocnVudGltZUFubm90YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBydW50aW1lQW5ub3RhdGlvbnMgPSBbXTtcbiAgICB1cGRhdGVHdXR0ZXIoKTtcbiAgfSxcbn07XG4iLCJ2YXIgZXJyb3JNYXAgPSBbXG4gIHtcbiAgICBvcmlnaW5hbDogL0Fzc2lnbm1lbnQgaW4gY29uZGl0aW9uYWwgZXhwcmVzc2lvbi8sXG4gICAgcmVwbGFjZW1lbnQ6IFwiRm9yIGNvbmRpdGlvbmFscywgdXNlIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yICg9PT0pIHRvIGNoZWNrIGlmIHR3byB0aGluZ3MgYXJlIGVxdWFsLlwiXG4gIH0sXG4gIHtcbiAgICBvcmlnaW5hbDogLyguKilcXHNpcyBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkLi8sXG4gICAgcmVwbGFjZW1lbnQ6IFwiJDEgaXMgZGVmaW5lZCwgYnV0IGl0J3Mgbm90IGNhbGxlZCBpbiB5b3VyIHByb2dyYW0uXCJcbiAgfSxcbiAge1xuICAgIG9yaWdpbmFsOiAvKC4qKVxcc2lzIG5vdCBkZWZpbmVkLi8sXG4gICAgcmVwbGFjZW1lbnQ6IFwiJDEgaGFzbid0IGJlZW4gZGVjbGFyZWQgeWV0LlwiXG4gIH1cbl07XG5cbi8qKlxuICogVGFrZXMgdGhlIHJlc3VsdHMgb2YgYSBKU0xpbnQgcGFzcywgYW5kIG1vZGlmaWVzIHRoZSBlcnJvciB0ZXh0IGFjY29yZGluZyB0b1xuICogb3VyIG1hcHBpbmcuIE5vdGUgdGhpcyBtYWtlcyBjaGFuZ2VzIGluIHBsYWNlIHRvIHRoZSBwYXNzZWQgaW4gcmVzdWx0c1xuICogb2JqZWN0LlxuICovXG5tb2R1bGUuZXhwb3J0cy5wcm9jZXNzUmVzdWx0cyA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gIHJlc3VsdHMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2luZm8nKSB7XG4gICAgICBpdGVtLnR5cGUgPSAnd2FybmluZyc7XG4gICAgfVxuXG4gICAgZXJyb3JNYXAuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JNYXBwaW5nKSB7XG4gICAgICBpZiAoIWVycm9yTWFwcGluZy5vcmlnaW5hbC50ZXN0KGl0ZW0udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVtLnRleHQgPSBpdGVtLnRleHQucmVwbGFjZShlcnJvck1hcHBpbmcub3JpZ2luYWwsIGVycm9yTWFwcGluZy5yZXBsYWNlbWVudCk7XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IE1hcmMgSi4gU2NobWlkdC4gU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbFxuICogZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5cbiAqL1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgZm9yIGRpbWVuc2lvbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXXxFbGVtZW50c3xqUXVlcnl9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKCkge1xuICAgICAgICAgICAgdGhpcy5xID0gW107XG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xLnB1c2goZXYpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGksIGo7XG4gICAgICAgICAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5xLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnFbaV0uY2FsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBwcm9wXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jdXJyZW50U3R5bGVbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgcmVzaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudCwgcmVzaXplZCkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkID0gbmV3IEV2ZW50UXVldWUoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuYWRkKHJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yJztcbiAgICAgICAgICAgIHZhciBzdHlsZSA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgb3ZlcmZsb3c6IHNjcm9sbDsgei1pbmRleDogLTE7IHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuICAgICAgICAgICAgdmFyIHN0eWxlQ2hpbGQgPSAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7JztcblxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3ItZXhwYW5kXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICcgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJVwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LnJlc2l6ZVNlbnNvcik7XG5cbiAgICAgICAgICAgIGlmICgnYWJzb2x1dGUnICE9PSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICdwb3NpdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBlbGVtZW50LnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkID0gZXhwYW5kLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB2YXIgc2hyaW5rID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgIHZhciBzaHJpbmtDaGlsZCA9IHNocmluay5jaGlsZE5vZGVzWzBdO1xuXG4gICAgICAgICAgICB2YXIgbGFzdFdpZHRoLCBsYXN0SGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9IGV4cGFuZC5vZmZzZXRXaWR0aCArIDEwICsgJ3B4JztcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBleHBhbmQub2Zmc2V0SGVpZ2h0ICsgMTAgKyAncHgnO1xuICAgICAgICAgICAgICAgIGV4cGFuZC5zY3JvbGxMZWZ0ID0gZXhwYW5kLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSBleHBhbmQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ID0gc2hyaW5rLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxUb3AgPSBzaHJpbmsuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxhc3RXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzZXQoKTtcblxuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5jYWxsKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhZGRFdmVudChleHBhbmQsICdzY3JvbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCA+IGxhc3RXaWR0aCB8fCBlbGVtZW50Lm9mZnNldEhlaWdodCA+IGxhc3RIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFkZEV2ZW50KHNocmluaywgJ3Njcm9sbCcsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggPCBsYXN0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBsYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHxcbiAgICAgICAgICAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBqUXVlcnkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIGpRdWVyeSkgfHwgLy9qcXVlcnlcbiAgICAgICAgICAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBFbGVtZW50cyAmJiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudHMpIC8vbW9vdG9vbHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGogPSBlbGVtZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudFtpXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiIsIi8qKiBAZmlsZSBUaGUgbWFlc3RybyEgSGVscGVyIHRoYXQga25vd3Mgd2hpY2ggbXVzaWMgdHJhY2tzIGNhbiBiZSBwbGF5ZWQsIGFuZFxuICogICAgICAgIHdoaWNoIG9uZSBpcyBwbGF5aW5nIG5vdywgYW5kIHNlbGVjdHMgYW5kIHBsYXlzIHRoZW0gYXBwcm9wcmlhdGVseS4gKi9cbi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgXyA9IHV0aWxzLmdldExvZGFzaCgpO1xuXG52YXIgZGVidWdMb2dnaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBkZWJ1Zyhtc2cpIHtcbiAgaWYgKGRlYnVnTG9nZ2luZyAmJiBjb25zb2xlICYmIGNvbnNvbGUuaW5mbykge1xuICAgIGNvbnNvbGUuaW5mbygobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgJzogTXVzaWNDb250cm9sbGVyOiAnICsgbXNnKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE11c2ljVHJhY2tEZWZpbml0aW9uXG4gKiBFeHRlcm5hbCB0cmFjayByZXByZXNlbnRhdGlvbiwgdXNlZCB0byBkZWZpbmUgdHJhY2sgaW5mbyBpbiBza2lucy5qcy5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIGNvcnJlc3BvbmRzIHRvIG11c2ljIGZpbGVuYW1lc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSAtIG9uIGEgMC4uMSBzY2FsZVxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNPZ2cgLSB3aGV0aGVyIGEgLm9nZyB2ZXJzaW9uIG9mIHRoZSBmaWxlIHNob3VsZCBhbHNvXG4gKiAgICAgICAgICAgYXZhaWxhYmxlIGluIGFkZGl0aW9uIHRvIHRoZSAubXAzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNdXNpY1RyYWNrXG4gKiBJbnRlcm5hbCB0cmFjayByZXByZXNlbnRhdGlvbiwgaW5jbHVkZXMgdHJhY2sgbWV0YWRhdGEgYW5kIHJlZmVyZW5jZXMgdG9cbiAqIGxvYWRlZCBzb3VuZCBvYmplY3QuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGFzc2V0VXJsc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZVxuICogQHByb3BlcnR5IHtTb3VuZH0gc291bmRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNMb2FkZWRcbiAqL1xuXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIHRoYXQgaGFuZGxlcyBsb2FkaW5nLCBjaG9vc2luZywgcGxheWluZyBhbmQgc3RvcHBpbmdcbiAqIGJhY2tncm91bmQgbXVzaWMgZm9yIGNlcnRhaW4gc3R1ZGlvIGFwcHMgKGUuZy4gcGxheWxhYiwgY3JhZnQpLlxuICpcbiAqIEBwYXJhbSB7QXVkaW9QbGF5ZXJ9IGF1ZGlvUGxheWVyIC0gUmVmZXJlbmNlIHRvIHRoZSBTb3VuZHMgb2JqZWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gYXNzZXRVcmwgLSBGdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBwYXRocyB0byBzdGF0aWMgYXNzZXRzXG4gKiAgICAgICAgZm9yIHRoZSBjdXJyZW50IHNraW4uXG4gKiBAcGFyYW0ge011c2ljVHJhY2tEZWZpbml0aW9uW119IFt0cmFja0RlZmluaXRpb25zXSAtIExpc3Qgb2YgbXVzaWMgYXNzZXRzIGFuZFxuICogICAgICAgIGdlbmVyYWwgaW5mbyBhYm91dCBob3cgdGhleSBzaG91bGQgYmUgcGxheWVkLiBDYW4gYmUgb21pdHRlZCBvciBlbXB0eVxuICogICAgICAgIGlmIG5vIG11c2ljIHNob3VsZCBiZSBwbGF5ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xvb3BSYW5kb21XaXRoRGVsYXldIC0gaWYgc3BlY2lmaWVkLCBhZnRlciBhIHNvbmcgaXNcbiAqICAgICAgICBjb21wbGV0ZWQsIHdpbGwgcGxheSBhIHJhbmRvbSB0cmFjayBhZnRlciBnaXZlbiBkdXJhdGlvbiAoaW4gbXMpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNdXNpY0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYXVkaW9QbGF5ZXIsIGFzc2V0VXJsLCB0cmFja0RlZmluaXRpb25zLFxuICAgIGxvb3BSYW5kb21XaXRoRGVsYXkpIHtcbiAgLyoqIEBwcml2YXRlIHtBdWRpb1BsYXllcn0gKi9cbiAgdGhpcy5hdWRpb1BsYXllcl8gPSBhdWRpb1BsYXllcjtcblxuICAvKiogQHByaXZhdGUge2Z1bmN0aW9ufSAqL1xuICB0aGlzLmFzc2V0VXJsXyA9IGFzc2V0VXJsO1xuXG4gIC8qKiBAcHJpdmF0ZSB7TXVzaWNUcmFja1tdfSAqL1xuICB0aGlzLnRyYWNrTGlzdF8gPSBidWlsZFRyYWNrRGF0YSh0cmFja0RlZmluaXRpb25zLCBhc3NldFVybCk7XG5cbiAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gIHRoaXMubm93UGxheWluZ18gPSBudWxsO1xuXG4gIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSBOYW1lIG9mIHRyYWNrIHRvIHBsYXkgb24gbG9hZCAqL1xuICB0aGlzLnBsYXlPbkxvYWRfID0gbnVsbDtcblxuXG4gIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICB0aGlzLmxvb3BSYW5kb21XaXRoRGVsYXlfID0gbG9vcFJhbmRvbVdpdGhEZWxheTtcblxuICAvKipcbiAgICogQHByaXZhdGUge2Jvb2xlYW59IHdoZXRoZXIgd2Ugc3RvcHBlZCBwbGF5aW5nIG11c2ljIGR1ZSB0byB2aWRlbyBiZWluZ1xuICAgKiAgICAgICAgICBzaG93blxuICAgKi9cbiAgdGhpcy53YXNQbGF5aW5nV2hlblZpZGVvU2hvd25fID0gZmFsc2U7XG5cbiAgLyoqIEBwcml2YXRlIHtudW1iZXJ9IHNldFRpbWVvdXQgY2FsbGJhY2sgaWRlbnRpZmllciBmb3IgdW4tYmluZGluZyByZXBlYXQgKi9cbiAgdGhpcy5iZXR3ZWVuVHJhY2tUaW1lb3V0XyA9IG51bGw7XG5cbiAgLy8gSWYgdGhlIHZpZGVvIHBsYXllciBnZXRzIHB1bGxlZCB1cCwgbWFrZSBzdXJlIHdlIHN0b3AgdGhlIG11c2ljLlxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aWRlb1Nob3duJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKFwidmlkZW8gc2hvd25cIik7XG4gICAgaWYgKHRoaXMubm93UGxheWluZ18gfHwgdGhpcy5iZXR3ZWVuVHJhY2tUaW1lb3V0Xykge1xuICAgICAgdGhpcy53YXNQbGF5aW5nV2hlblZpZGVvU2hvd25fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuYmV0d2VlblRyYWNrVGltZW91dF8pIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmJldHdlZW5UcmFja1RpbWVvdXRfKTtcbiAgICAgICAgdGhpcy5iZXR3ZWVuVHJhY2tUaW1lb3V0XyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmZhZGVPdXQoKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gSWYgdGhlIHZpZGVvIHBsYXllciBnZXRzIGNsb3NlZCwgbWFrZSBzdXJlIHdlIHJlLXN0YXJ0IHRoZSBtdXNpYy5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlkZW9IaWRkZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXyAmJlxuICAgICAgICB0aGlzLmxvb3BSYW5kb21XaXRoRGVsYXlfICYmXG4gICAgICAgICF0aGlzLm5vd1BsYXlpbmdfKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gICAgdGhpcy53YXNQbGF5aW5nV2hlblZpZGVvU2hvd25fID0gZmFsc2U7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgZGVidWcoJ2NvbnN0cnVjdGVkJyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNdXNpY0NvbnRyb2xsZXI7XG5cbi8qKlxuICogQnVpbGQgdXAgaW5pdGlhbCBpbnRlcm5hbCB0cmFjayBtZXRhZGF0YS5cbiAqIEBwYXJhbSB7TXVzaWNUcmFja0RlZmluaXRpb25bXX0gdHJhY2tEZWZpbml0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gYXNzZXRVcmxcbiAqIEByZXR1cm4ge011c2ljVHJhY2tbXX1cbiAqL1xuZnVuY3Rpb24gYnVpbGRUcmFja0RhdGEodHJhY2tEZWZpbml0aW9ucywgYXNzZXRVcmwpIHtcbiAgdHJhY2tEZWZpbml0aW9ucyA9IHV0aWxzLnZhbHVlT3IodHJhY2tEZWZpbml0aW9ucywgW10pO1xuICByZXR1cm4gdHJhY2tEZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKHRyYWNrRGVmKSB7XG5cbiAgICB2YXIgYXNzZXRVcmxzID0gW107XG4gICAgYXNzZXRVcmxzLnB1c2goYXNzZXRVcmwodHJhY2tEZWYubmFtZSArICcubXAzJykpO1xuICAgIGlmICh0cmFja0RlZi5oYXNPZ2cpIHtcbiAgICAgIGFzc2V0VXJscy5wdXNoKGFzc2V0VXJsKHRyYWNrRGVmLm5hbWUgKyAnLm9nZycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdHJhY2tEZWYubmFtZSxcbiAgICAgIGFzc2V0VXJsczogYXNzZXRVcmxzLFxuICAgICAgdm9sdW1lOiB1dGlscy52YWx1ZU9yKHRyYWNrRGVmLnZvbHVtZSwgMSksXG4gICAgICBzb3VuZDogbnVsbCxcbiAgICAgIGlzTG9hZGVkOiBmYWxzZVxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIFByZWxvYWQgYWxsIG11c2ljIGFzc2V0c1xuICovXG5NdXNpY0NvbnRyb2xsZXIucHJvdG90eXBlLnByZWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5hdWRpb1BsYXllcl8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnRyYWNrTGlzdF8uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB0cmFjay5zb3VuZCA9IHRoaXMuYXVkaW9QbGF5ZXJfLnJlZ2lzdGVyQnlGaWxlbmFtZXNBbmRJRChcbiAgICAgICAgdHJhY2suYXNzZXRVcmxzLCB0cmFjay5uYW1lKTtcbiAgICB0cmFjay5zb3VuZC5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnZG9uZSBsb2FkaW5nICcgKyB0cmFjay5uYW1lKTtcbiAgICAgIHRyYWNrLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnBsYXlPbkxvYWRfID09PSB0cmFjay5uYW1lKSB7XG4gICAgICAgIHRoaXMucGxheSh0cmFjay5uYW1lKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBCZWdpbnMgcGxheWluZyBhIHBhcnRpY3VsYXIgcGllY2Ugb2YgbXVzaWMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tOYW1lXG4gKi9cbk11c2ljQ29udHJvbGxlci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgZGVidWcoJ3BsYXkgJyArIHRyYWNrTmFtZSk7XG4gIGlmICghdGhpcy5hdWRpb1BsYXllcl8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhY2s7XG4gIGlmICh0cmFja05hbWUpIHtcbiAgICB0cmFjayA9IHRoaXMuZ2V0VHJhY2tCeU5hbWVfKHRyYWNrTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJhY2sgPSB0aGlzLmdldFJhbmRvbVRyYWNrXygpO1xuICB9XG5cbiAgaWYgKCF0cmFjaykge1xuICAgIC8vIE5vIHRyYWNrIHRvIHBsYXkgLSB0aHJvdyBhbiBleGNlcHRpb24/XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRyYWNrLnNvdW5kICYmIHRyYWNrLmlzTG9hZGVkKSB7XG4gICAgZGVidWcoJ3BsYXlpbmcgbm93Jyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy53aGVuTXVzaWNTdG9wcGVkXy5iaW5kKHRoaXMsIHRyYWNrLm5hbWUpO1xuICAgIHRyYWNrLnNvdW5kLnBsYXkoeyB2b2x1bWU6IHRyYWNrLnZvbHVtZSwgb25FbmRlZDogY2FsbGJhY2sgfSk7XG4gICAgdGhpcy5ub3dQbGF5aW5nXyA9IHRyYWNrLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ25vdCBkb25lIGxvYWRpbmcsIHBsYXlpbmcgYWZ0ZXIgbG9hZCcpO1xuICAgIHRoaXMucGxheU9uTG9hZF8gPSB0cmFjay5uYW1lO1xuICB9XG59O1xuXG4vKipcbiAqIFN0b3BzIHBsYXlpbmcgd2hhdGV2ZXIgbXVzaWMgaXMgY3VycmVudGx5IHBsYXlpbmcsIGltbWVkaWF0ZWx5LlxuICovXG5NdXNpY0NvbnRyb2xsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5ub3dQbGF5aW5nXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzb3VuZCA9IHRoaXMuYXVkaW9QbGF5ZXJfLmdldCh0aGlzLm5vd1BsYXlpbmdfKTtcbiAgaWYgKHNvdW5kKSB7XG4gICAgc291bmQuc3RvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZhZGVzIG11c2ljIHRvIG5vdGhpbmcsIHRoZW4gc3RvcHMgaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uU2Vjb25kc10gaW4gc2Vjb25kcy4gIERlZmF1bHQgMy5cbiAqL1xuTXVzaWNDb250cm9sbGVyLnByb3RvdHlwZS5mYWRlT3V0ID0gZnVuY3Rpb24gKGR1cmF0aW9uU2Vjb25kcykge1xuICBpZiAoIXRoaXMubm93UGxheWluZ18pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkdXJhdGlvblNlY29uZHMgPSB1dGlscy52YWx1ZU9yKGR1cmF0aW9uU2Vjb25kcywgMyk7XG5cbiAgLy8gVHJpZ2dlciBhIGZhZGVcbiAgdmFyIHNvdW5kID0gdGhpcy5hdWRpb1BsYXllcl8uZ2V0KHRoaXMubm93UGxheWluZ18pO1xuICBpZiAoc291bmQpIHtcbiAgICBzb3VuZC5mYWRlVG9HYWluKDAsIGR1cmF0aW9uU2Vjb25kcyk7XG4gIH1cblxuICAvLyBTdG9wIHRoZSBhdWRpbyBhZnRlciB0aGUgZmFkZS5cbiAgLy8gQWRkIGEgc21hbGwgbWFyZ2luIGR1ZSB0byBwb29yIGZhZGUgZ3JhbnVsYXJpdHkgb24gZmFsbGJhY2sgcGxheWVyLlxuICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH0uYmluZCh0aGlzKSwgMTAwMCAqIGR1cmF0aW9uU2Vjb25kcyArIDEwMCk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIGZvciB3aGVuIG11c2ljIHN0b3BzLCB0byB1cGRhdGUgaW50ZXJuYWwgc3RhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbXVzaWNOYW1lIHRoYXQgd2FzIHBsYXlpbmcuICBTaG91bGQgYmUgYm91bmQgd2hlbiBtdXNpY1xuICogICAgICAgIGlzIHN0YXJ0ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5NdXNpY0NvbnRyb2xsZXIucHJvdG90eXBlLndoZW5NdXNpY1N0b3BwZWRfID0gZnVuY3Rpb24gKG11c2ljTmFtZSkge1xuICBpZiAodGhpcy5ub3dQbGF5aW5nXyA9PT0gbXVzaWNOYW1lKSB7XG4gICAgdGhpcy5ub3dQbGF5aW5nXyA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMubG9vcFJhbmRvbVdpdGhEZWxheV8gJiYgIXRoaXMud2FzUGxheWluZ1doZW5WaWRlb1Nob3duXykge1xuICAgIHRoaXMuYmV0d2VlblRyYWNrVGltZW91dF8gPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJldHdlZW5UcmFja1RpbWVvdXRfID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5ub3dQbGF5aW5nXyAmJiAhdGhpcy53YXNQbGF5aW5nV2hlblZpZGVvU2hvd25fKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5sb29wUmFuZG9tV2l0aERlbGF5Xyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtNdXNpY1RyYWNrfHVuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbk11c2ljQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0VHJhY2tCeU5hbWVfID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF8uZmluZCh0aGlzLnRyYWNrTGlzdF8sIGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHJldHVybiB0cmFjay5uYW1lID09PSBuYW1lO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge011c2ljVHJhY2t8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuTXVzaWNDb250cm9sbGVyLnByb3RvdHlwZS5nZXRSYW5kb21UcmFja18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFja0luZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy50cmFja0xpc3RfLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzLnRyYWNrTGlzdF9bdHJhY2tJbmRleF07XG59O1xuIiwiLyoqIEBmaWxlIE9ic2VydmVzIGEgSlNJbnRlcnByZXRlciBhbmQgbG9ncyB0byB0aGUgZGVzaWduYXRlZCBicm93c2VyIGNvbnNvbGUuICovXG4vLyBTdHJpY3QgbGludGluZzogQWJzb3JiIGludG8gZ2xvYmFsIGNvbmZpZyB3aGVuIHBvc3NpYmxlXG4vKiBqc2hpbnRcbiB1bnVzZWQ6IHRydWUsXG4gZXFlcWVxOiB0cnVlLFxuIG1heGxlbjogMTIwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xuXG4vKipcbiAqIE9ic2VydmVyIHJlc3BvbnNpYmxlIGZvciBsb2dnaW5nIHRvIHRoZSBwcm92aWRlZCBicm93c2VyIGNvbnNvbGUgd2hlblxuICogdGhlIGludGVycHJldGVyIGl0IGlzIG9ic2VydmluZyByYWlzZXMgbG9nLXdvcnRoeSBldmVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc29sZX0gd2luZG93IGNvbnNvbGUgQVBJXG4gKi9cbnZhciBKc0ludGVycHJldGVyTG9nZ2VyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3V0cHV0Q29uc29sZSkge1xuICAvKiogQHByaXZhdGUge0NvbnNvbGV9ICovXG4gIHRoaXMub3V0cHV0Q29uc29sZV8gPSBvdXRwdXRDb25zb2xlO1xuXG4gIC8qKiBAcHJpdmF0ZSB7T2JzZXJ2ZXJ9ICovXG4gIHRoaXMub2JzZXJ2ZXJfID0gbmV3IE9ic2VydmVyKCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaCB0aGUgbG9nZ2VyIHRvIGEgcGFydGljdWxhciBKU0ludGVycHJldGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtKU0ludGVycHJldGVyfSBqc0ludGVycHJldGVyXG4gKi9cbkpzSW50ZXJwcmV0ZXJMb2dnZXIucHJvdG90eXBlLmF0dGFjaFRvID0gZnVuY3Rpb24gKGpzSW50ZXJwcmV0ZXIpIHtcbiAgdGhpcy5vYnNlcnZlcl8ub2JzZXJ2ZShqc0ludGVycHJldGVyLm9uRXhlY3V0aW9uV2FybmluZyxcbiAgICAgIHRoaXMubG9nLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBEZXRhY2ggdGhlIGxvZ2dlciBmcm9tIHdoYXRldmVyIGludGVycHJldGVyIGluc3RhbmNlIGl0IGlzIGN1cnJlbnRseVxuICogYXR0YWNoZWQgdG8sIHVucmVnaXN0ZXJpbmcgaGFuZGxlcnMuXG4gKiBTYWZlIHRvIGNhbGwgd2hlbiB0aGUgbG9nZ2VyIGlzIGFscmVhZHkgZGV0YWNoZWQuXG4gKi9cbkpzSW50ZXJwcmV0ZXJMb2dnZXIucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vYnNlcnZlcl8udW5vYnNlcnZlQWxsKCk7XG59O1xuXG4vKipcbiAqIExvZyB0byB0aGUgY29uc29sZSBvYmplY3Qgd2Ugd2VyZSBjb25zdHJ1Y3RlZCB3aXRoLlxuICogQHBhcmFtIHsqfSBhcmd1bWVudHMuLi5cbiAqIEBzZWUgQ29uc29sZS5sb2dcbiAqL1xuSnNJbnRlcnByZXRlckxvZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vdXRwdXRDb25zb2xlXyAmJiB0aGlzLm91dHB1dENvbnNvbGVfLmxvZykge1xuICAgIHRoaXMub3V0cHV0Q29uc29sZV8ubG9nLmFwcGx5KHRoaXMub3V0cHV0Q29uc29sZV8sIGFyZ3VtZW50cyk7XG4gIH1cbn07XG4iLCIvKiogQGZpbGUgRGVidWdnZXIgY29udHJvbHMgYW5kIGRlYnVnIGNvbnNvbGUgdXNlZCBpbiBvdXIgcmljaCBKYXZhU2NyaXB0IElERXMgKi9cbi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tbWFuZEhpc3RvcnkgPSByZXF1aXJlKCcuL0NvbW1hbmRIaXN0b3J5Jyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBEZWJ1Z0FyZWEgPSByZXF1aXJlKCcuL0RlYnVnQXJlYScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgSlNJbnRlcnByZXRlciA9IHJlcXVpcmUoJy4vSlNJbnRlcnByZXRlcicpO1xudmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIFNsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBLZXlDb2RlcyA9IGNvbnN0YW50cy5LZXlDb2RlcztcbnZhciBTdGVwVHlwZSA9IEpTSW50ZXJwcmV0ZXIuU3RlcFR5cGU7XG5cbi8qKiBAY29uc3Qge251bWJlcn0gKi9cbnZhciBNSU5fREVCVUdfQVJFQV9IRUlHSFQgPSAxMjA7XG4vKiogQGNvbnN0IHtudW1iZXJ9ICovXG52YXIgTUFYX0RFQlVHX0FSRUFfSEVJR0hUID0gNDAwO1xuXG4vKipcbiAqIERlYnVnZ2VyIGNvbnRyb2xzIGFuZCBkZWJ1ZyBjb25zb2xlIHVzZWQgaW4gb3VyIHJpY2ggSmF2YVNjcmlwdCBJREVzLCBsaWtlXG4gKiBBcHAgTGFiLCBHYW1lIExhYiwgZXRjLlxuICogQHBhcmFtIHshZnVuY3Rpb259IHJ1bkFwcCAtIGNhbGxiYWNrIGZvciBcImxhdW5jaGluZ1wiIHRoZSBhcHAsIHdoaWNoIGlzIHVzZWRcbiAqICAgICAgICBieSB0aGUgXCJTdGVwIEluXCIgYnV0dG9uIHdoZW4gdGhlIGFwcCBpc24ndCBydW5uaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKc0RlYnVnZ2VyVWkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChydW5BcHApIHtcbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byBjdXJyZW50bHkgYXR0YWNoZWQgSlNJbnRlcnByZXRlciwgbnVsbCBpZiB1bmF0dGFjaGVkLlxuICAgKiBAcHJpdmF0ZSB7SlNJbnRlcnByZXRlcn1cbiAgICovXG4gIHRoaXMuanNJbnRlcnByZXRlcl8gPSBudWxsO1xuXG4gIC8qKiBAcHJpdmF0ZSB7T2JzZXJ2ZXJ9ICovXG4gIHRoaXMub2JzZXJ2ZXJfID0gbmV3IE9ic2VydmVyKCk7XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBcImxhdW5jaGluZ1wiIHRoZSBhcHAsIHVzZWQgYnkgdGhlIFwiU3RlcCBJblwiIGJ1dHRvbiB3aGVuIHRoZSBhcHBcbiAgICogaXNuJ3QgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAqIEBwcml2YXRlIHtmdW5jdGlvbn1cbiAgICovXG4gIHRoaXMucnVuQXBwXyA9IHJ1bkFwcDtcblxuICAvKipcbiAgICogQnJvd3NlYWJsZSBoaXN0b3J5IG9mIGNvbW1hbmRzIGVudGVyZWQgaW50byB0aGUgZGVidWcgY29uc29sZS5cbiAgICogQHByaXZhdGUge0NvbW1hbmRIaXN0b3J5fVxuICAgKi9cbiAgdGhpcy5oaXN0b3J5XyA9IG5ldyBDb21tYW5kSGlzdG9yeSgpO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgdGhhdCBoYW5kbGVzIG9wZW4vc2h1dCBhY3Rpb25zIGZvciBkZWJ1Z2dlciBVSVxuICAgKiBAcHJpdmF0ZSB7RGVidWdBcmVhfVxuICAgKi9cbiAgdGhpcy5kZWJ1Z09wZW5TaHV0Q29udHJvbGxlcl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSb290IGVsZW1lbnQgZm9yIGRlYnVnIFVJOiBkaXYjZGVidWctYXJlYVxuICAgKiBAcHJpdmF0ZSB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgRE9NIGVsZW1lbnQgbWFya3VwIGZyb20gYW4gZWpzIGZpbGUgZm9yIHRoZSBkZWJ1ZyBhcmVhLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGFzc2V0VXJsIC0gSGVscGVyIGZvciBnZXR0aW5nIGFzc2V0IFVSTHMuXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7IWJvb2xlYW59IG9wdGlvbnMuc2hvd0J1dHRvbnMgLSBXaGV0aGVyIHRvIHNob3cgdGhlIGRlYnVnIGJ1dHRvbnNcbiAqIEBwYXJhbSB7IWJvb2xlYW59IG9wdGlvbnMuc2hvd0NvbnNvbGUgLSBXaGV0aGVyIHRvIHNob3cgdGhlIGRlYnVnIGNvbnNvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG9mIEhUTUwgbWFya3VwIHRvIGJlIGVtYmVkZGVkIGluIGNvZGVXb3Jrc3BhY2UuaHRtbC5lanNcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5nZXRNYXJrdXAgPSBmdW5jdGlvbiAoYXNzZXRVcmwsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vSnNEZWJ1Z2dlclVpLmh0bWwuZWpzJykoe1xuICAgIGFzc2V0VXJsOiBhc3NldFVybCxcbiAgICBkZWJ1Z0J1dHRvbnM6IG9wdGlvbnMuc2hvd0J1dHRvbnMsXG4gICAgZGVidWdDb25zb2xlOiBvcHRpb25zLnNob3dDb25zb2xlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBdHRhY2ggdGhlIGRlYnVnZ2VyIHRvIGEgcGFydGljdWxhciBKU0ludGVycHJldGVyIGluc3RhbmNlLiAgUmVpbml0aWFsaXplc1xuICogdGhlIFVJIHN0YXRlIGFuZCBiZWdpbnMgbGlzdGVuaW5nIGZvciBpbnRlcnByZXRlciBldmVudHMuXG4gKiBAcGFyYW0ge0pTSW50ZXJwcmV0ZXJ9IGpzSW50ZXJwcmV0ZXJcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uIChqc0ludGVycHJldGVyKSB7XG4gIHRoaXMuanNJbnRlcnByZXRlcl8gPSBqc0ludGVycHJldGVyO1xuICB0aGlzLm9ic2VydmVyXy5vYnNlcnZlKGpzSW50ZXJwcmV0ZXIub25OZXh0U3RlcENoYW5nZWQsXG4gICAgICB0aGlzLnVwZGF0ZVBhdXNlVWlTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vYnNlcnZlcl8ub2JzZXJ2ZShqc0ludGVycHJldGVyLm9uUGF1c2UsXG4gICAgICB0aGlzLm9uUGF1c2VDb250aW51ZUJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vYnNlcnZlcl8ub2JzZXJ2ZShqc0ludGVycHJldGVyLm9uRXhlY3V0aW9uV2FybmluZyxcbiAgICAgIHRoaXMubG9nLmJpbmQodGhpcykpO1xuXG4gIHRoaXMudXBkYXRlUGF1c2VVaVN0YXRlKCk7XG4gIHRoaXMuY2xlYXJEZWJ1Z091dHB1dCgpO1xuICB0aGlzLmNsZWFyRGVidWdJbnB1dCgpO1xufTtcblxuLyoqXG4gKiBEZXRhY2ggdGhlIGRlYnVnZ2VyIGZyb20gd2hhdGV2ZXIgaW50ZXJwcmV0ZXIgaW5zdGFuY2UgaXQgaXMgY3VycmVudGx5XG4gKiBhdHRhY2hlZCB0bywgdW5yZWdpc3RlcmluZyBoYW5kbGVycyBhbmQgcmVzZXR0aW5nIHRoZSBjb250cm9scyB0byBhXG4gKiAnZGV0YWNoZWQnIHN0YXRlLlxuICogU2FmZSB0byBjYWxsIHdoZW4gdGhlIGRlYnVnZ2VyIGlzIGFscmVhZHkgZGV0YWNoZWQuXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9ic2VydmVyXy51bm9ic2VydmVBbGwoKTtcbiAgdGhpcy5qc0ludGVycHJldGVyXyA9IG51bGw7XG5cbiAgdGhpcy5yZXNldERlYnVnQ29udHJvbHNfKCk7XG59O1xuXG4vKipcbiAqIEVsZW1lbnQgZ2V0dGVyIGZvciBlbGVtZW50cyB3aXRoaW4gdGhlIGRlYnVnZ2VyIFVJLlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmdldEVsZW1lbnRfID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHZhciByb290RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnLWFyZWEnKTtcbiAgaWYgKHJvb3REaXYpIHtcbiAgICByZXR1cm4gcm9vdERpdi5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBQb3N0LURPTSBpbml0aWFsaXphdGlvbiwgd2hpY2ggYWxsb3dzIHRoaXMgY29udHJvbGxlciB0byBncmFiIGFsbCB0aGUgRE9NXG4gKiByZWZlcmVuY2VzIGl0IG5lZWRzLCBiaW5kIGhhbmRsZXJzLCBhbmQgY3JlYXRlIGFueSBzdWJvcmRpbmF0ZSBjb250cm9sbGVycy5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlZmF1bHRTdGVwU3BlZWRdIGluIHJhbmdlIDAuLjFcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5pbml0aWFsaXplQWZ0ZXJEb21DcmVhdGVkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gR2V0IHJlZmVyZW5jZXMgdG8gaW1wb3J0YW50IGVsZW1lbnRzIG9mIHRoZSBET01cbiAgdGhpcy5yb290RGl2XyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWJ1Zy1hcmVhJyk7XG5cbiAgLy8gQ3JlYXRlIGNvbnRyb2xsZXIgZm9yIG9wZW4vc2h1dCBiZWhhdmlvciBvZiBkZWJ1ZyBhcmVhXG4gIHRoaXMuZGVidWdPcGVuU2h1dENvbnRyb2xsZXJfID0gbmV3IERlYnVnQXJlYShcbiAgICAgIHRoaXMucm9vdERpdl8sXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZVRleHRib3gnKSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBkZWJ1ZyBzcGVlZCBzbGlkZXJcbiAgdmFyIHNsaWRlciA9IHRoaXMucm9vdERpdl8ucXVlcnlTZWxlY3RvcignI3NwZWVkLXNsaWRlcicpO1xuICBpZiAoc2xpZGVyKSB7XG4gICAgdmFyIHNsaWRlclhPZmZzZXQgPSAxMCxcbiAgICAgICAgc2xpZGVyWU9mZnNldCA9IDIyLFxuICAgICAgICBzbGlkZXJXaWR0aCA9IDEzMDtcbiAgICB0aGlzLnNwZWVkU2xpZGVyXyA9IG5ldyBTbGlkZXIoc2xpZGVyWE9mZnNldCwgc2xpZGVyWU9mZnNldCwgc2xpZGVyV2lkdGgsXG4gICAgICAgIHNsaWRlcik7XG5cbiAgICAvLyBDaGFuZ2UgZGVmYXVsdCBzcGVlZCAoZWcgU3BlZWQgdXAgbGV2ZWxzIHRoYXQgaGF2ZSBsb3RzIG9mIHN0ZXBzKS5cbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0U3RlcFNwZWVkKSB7XG4gICAgICB0aGlzLnNldFN0ZXBTcGVlZChvcHRpb25zLmRlZmF1bHRTdGVwU3BlZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF0dGFjaCBrZXlkb3duIGhhbmRsZXIgZm9yIGRlYnVnIGNvbnNvbGUgaW5wdXQgYXJlYVxuICB2YXIgZGVidWdJbnB1dCA9IHRoaXMucm9vdERpdl8ucXVlcnlTZWxlY3RvcignI2RlYnVnLWlucHV0Jyk7XG4gIGlmIChkZWJ1Z0lucHV0KSB7XG4gICAgZGVidWdJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbkRlYnVnSW5wdXRLZXlEb3duLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gQXR0YWNoIGNsaWNrIGhhbmRsZXIgZm9yIGZvY3VzaW5nIG9uIGNvbnNvbGUgaW5wdXQgd2hlbiBjbGlja2luZyBvdXRwdXRcbiAgdmFyIGRlYnVnT3V0cHV0ID0gdGhpcy5yb290RGl2Xy5xdWVyeVNlbGVjdG9yKCcjZGVidWctb3V0cHV0Jyk7XG4gIGlmIChkZWJ1Z091dHB1dCkge1xuICAgIGRlYnVnT3V0cHV0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uRGVidWdPdXRwdXRNb3VzZVVwLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciB0aGUgZGVidWcgYXJlYSByZXNpemUgY29udHJvbFxuICB2YXIgcmVzaXplQmFyID0gdGhpcy5nZXRFbGVtZW50XygnI2RlYnVnUmVzaXplQmFyJyk7XG4gIGlmIChyZXNpemVCYXIpIHtcbiAgICBkb20uYWRkTW91c2VEb3duVG91Y2hFdmVudChyZXNpemVCYXIsIHRoaXMub25Nb3VzZURvd25EZWJ1Z1Jlc2l6ZUJhci5iaW5kKHRoaXMpKTtcblxuICAgIC8vIENhbid0IHVzZSBkb20uYWRkTW91c2VVcFRvdWNoRXZlbnQoKSBiZWNhdXNlIGl0IHdpbGwgcHJldmVudERlZmF1bHQgb25cbiAgICAvLyBhbGwgdG91Y2hlbmQgZXZlbnRzIG9uIHRoZSBwYWdlLCBicmVha2luZyBjbGljayBldmVudHMuLi5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLFxuICAgICAgICB0aGlzLm9uTW91c2VVcERlYnVnUmVzaXplQmFyLmJpbmQodGhpcykpO1xuICAgIHZhciBtb3VzZVVwVG91Y2hFdmVudE5hbWUgPSBkb20uZ2V0VG91Y2hFdmVudE5hbWUoJ21vdXNldXAnKTtcbiAgICBpZiAobW91c2VVcFRvdWNoRXZlbnROYW1lKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIobW91c2VVcFRvdWNoRXZlbnROYW1lLFxuICAgICAgICAgIHRoaXMub25Nb3VzZVVwRGVidWdSZXNpemVCYXIuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXR0YWNoIGhhbmRsZXIgZm9yIGNvbnNvbGUgY2xlYXIgYnV0dG9uXG4gIHZhciBjbGVhckJ1dHRvbiA9IHRoaXMucm9vdERpdl8ucXVlcnlTZWxlY3RvcignI2NsZWFyLWNvbnNvbGUtaGVhZGVyJyk7XG4gIGlmIChjbGVhckJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoY2xlYXJCdXR0b24sIHRoaXMuY2xlYXJEZWJ1Z091dHB1dC5iaW5kKHRoaXMpKTtcbiAgfVxuXG5cbiAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBkZWJ1Z2dlciBjb250cm9sc1xuICB2YXIgcGF1c2VCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjcGF1c2VCdXR0b24nKTtcbiAgdmFyIGNvbnRpbnVlQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI2NvbnRpbnVlQnV0dG9uJyk7XG4gIHZhciBzdGVwSW5CdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcEluQnV0dG9uJyk7XG4gIHZhciBzdGVwT3ZlckJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwT3ZlckJ1dHRvbicpO1xuICB2YXIgc3RlcE91dEJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwT3V0QnV0dG9uJyk7XG4gIGlmIChwYXVzZUJ1dHRvbiAmJiBjb250aW51ZUJ1dHRvbiAmJiBzdGVwSW5CdXR0b24gJiYgc3RlcE92ZXJCdXR0b24gJiYgc3RlcE91dEJ1dHRvbikge1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQocGF1c2VCdXR0b24sIHRoaXMub25QYXVzZUNvbnRpbnVlQnV0dG9uLmJpbmQodGhpcykpO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoY29udGludWVCdXR0b24sIHRoaXMub25QYXVzZUNvbnRpbnVlQnV0dG9uLmJpbmQodGhpcykpO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc3RlcEluQnV0dG9uLCB0aGlzLm9uU3RlcEluQnV0dG9uLmJpbmQodGhpcykpO1xuICAgIGRvbS5hZGRDbGlja1RvdWNoRXZlbnQoc3RlcE92ZXJCdXR0b24sIHRoaXMub25TdGVwT3ZlckJ1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHN0ZXBPdXRCdXR0b24sIHRoaXMub25TdGVwT3V0QnV0dG9uLmJpbmQodGhpcykpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3RlcCBkZWxheSBpbiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgc3BlZWQgc2xpZGVyIGluIHRoZSBkZWJ1Z2dlciBVSS5cbiAqIElmIG5vIHNwZWVkIHNsaWRlciBpcyBwcmVzZW50LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9XG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUuZ2V0U3RlcERlbGF5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zcGVlZFNsaWRlcl8pIHtcbiAgICByZXR1cm4gSnNEZWJ1Z2dlclVpLnN0ZXBEZWxheUZyb21TdGVwU3BlZWQodGhpcy5zcGVlZFNsaWRlcl8uZ2V0VmFsdWUoKSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzcGVlZCBzbGlkZXIgcG9zaXRpb24uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNwZWVkIC0gaW4gcmFuZ2UgMC4uMVxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLnNldFN0ZXBTcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xuICBpZiAodGhpcy5zcGVlZFNsaWRlcl8pIHtcbiAgICB0aGlzLnNwZWVkU2xpZGVyXy5zZXRWYWx1ZShzcGVlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb25lbnRpYWwgY29udmVyc2lvbiBmcm9tIHN0ZXAgc3BlZWQgKGFzIHNsaWRlciBwb3NpdGlvbiwgcmFuZ2UgMC4uMSkgdG9cbiAqIGEgc3RlcCBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHN0ZXBTcGVlZCBpbiByYW5nZSAwLi4xXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdGVwIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5Kc0RlYnVnZ2VyVWkuc3RlcERlbGF5RnJvbVN0ZXBTcGVlZCA9IGZ1bmN0aW9uIChzdGVwU3BlZWQpIHtcbiAgcmV0dXJuIDMwMCAqIE1hdGgucG93KDEgLSBzdGVwU3BlZWQsIDIpO1xufTtcblxuLyoqXG4gKiBHaXZlbiBzb21lIG9iamVjdCBvciBtZXNzYWdlLCBhdHRlbXB0IHRvIGxvZyBpdCBib3RoIHRvIHRoZSBicm93c2VyIGNvbnNvbGVcbiAqIGFuZCB0byB0aGUgdXNlci1mYWNpbmcgZGVidWcgY29uc29sZS5cbiAqIEBwYXJhbSB7Kn0gb3V0cHV0XG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG91dHB1dCkge1xuICB2YXIgZGVidWdPdXRwdXREaXYgPSB0aGlzLmdldEVsZW1lbnRfKCcjZGVidWctb3V0cHV0Jyk7XG4gIGlmIChkZWJ1Z091dHB1dERpdikge1xuICAgIGlmIChkZWJ1Z091dHB1dERpdi50ZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBkZWJ1Z091dHB1dERpdi50ZXh0Q29udGVudCArPSAnXFxuJztcbiAgICB9XG4gICAgZGVidWdPdXRwdXREaXYudGV4dENvbnRlbnQgKz0gc3RyaW5naWZ5Tm9uU3RyaW5ncyhvdXRwdXQpO1xuXG4gICAgZGVidWdPdXRwdXREaXYuc2Nyb2xsVG9wID0gZGVidWdPdXRwdXREaXYuc2Nyb2xsSGVpZ2h0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlOb25TdHJpbmdzKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgfHwgb2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGtleSBldmVudHMgaW4gdGhlIGRlYnVnIGNvbnNvbGUgaW5wdXQgYm94LlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gKi9cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUub25EZWJ1Z0lucHV0S2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gIHZhciBpbnB1dCA9IGUudGFyZ2V0LnRleHRDb250ZW50O1xuICBpZiAoZS5rZXlDb2RlID09PSBLZXlDb2Rlcy5FTlRFUikge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmhpc3RvcnlfLnB1c2goaW5wdXQpO1xuICAgIGUudGFyZ2V0LnRleHRDb250ZW50ID0gJyc7XG4gICAgdGhpcy5sb2coJz4gJyArIGlucHV0KTtcbiAgICB2YXIganNJbnRlcnByZXRlciA9IHRoaXMuanNJbnRlcnByZXRlcl87XG4gICAgaWYgKGpzSW50ZXJwcmV0ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBqc0ludGVycHJldGVyLmV2YWxJbkN1cnJlbnRTY29wZShpbnB1dCk7XG4gICAgICAgIHRoaXMubG9nKCc8ICcgKyBTdHJpbmcocmVzdWx0KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5sb2coJzwgJyArIFN0cmluZyhlcnIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coJzwgKG5vdCBydW5uaW5nKScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtleUNvZGVzLlVQKSB7XG4gICAgZS50YXJnZXQudGV4dENvbnRlbnQgPSB0aGlzLmhpc3RvcnlfLmdvQmFjayhpbnB1dCk7XG4gICAgbW92ZUNhcmV0VG9FbmRPZkRpdihlLnRhcmdldCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBCbG9jayBkZWZhdWx0IEhvbWUvRW5kLWxpa2UgYmVoYXZpb3IgaW4gQ2hyb21lXG4gIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLZXlDb2Rlcy5ET1dOKSB7XG4gICAgZS50YXJnZXQudGV4dENvbnRlbnQgPSB0aGlzLmhpc3RvcnlfLmdvRm9yd2FyZChpbnB1dCk7XG4gICAgbW92ZUNhcmV0VG9FbmRPZkRpdihlLnRhcmdldCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBCbG9jayBkZWZhdWx0IEhvbWUvRW5kLWxpa2UgYmVoYXZpb3IgaW4gQ2hyb21lXG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgdGV4dCBjb250ZW50IGluIGEgZGl2IGVsZW1lbnQuXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyNDk0NDAvNTAwMDEyOVxuICogQHBhcmFtIHshSFRNTERpdkVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNhcmV0VG9FbmRPZkRpdihlbGVtZW50KSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudC5sYXN0Q2hpbGQsIGVsZW1lbnQubGFzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcblxuICAvLyBDaGFuZ2Ugd2luZG93IHNlbGVjdGlvbiB0byBuZXcgcmFuZ2UgdG8gc2V0IGN1cnNvciBwb3NpdGlvblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG59XG5cbi8qKlxuICogT24gbW91c2V1cCBvdmVyIHRoZSBjb25zb2xlIG91dHB1dCwgaWYgdGhlIHVzZXIgaGFzbid0IGp1c3Qgc2VsZWN0ZWQgc29tZVxuICogdGV4dCwgcGxhY2UgdGhlIGZvY3VzIGluIHRoZSBjb25zb2xlIGlucHV0IGJveC5cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uRGVidWdPdXRwdXRNb3VzZVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIGRlYnVnSW5wdXQgPSB0aGlzLmdldEVsZW1lbnRfKCcjZGVidWctaW5wdXQnKTtcbiAgaWYgKGRlYnVnSW5wdXQgJiYgZS50YXJnZXQudGFnTmFtZSA9PT0gXCJESVZcIiAmJlxuICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVidWdJbnB1dC5mb2N1cygpO1xuICB9XG59O1xuXG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG52YXIgZHJhZ2dpbmdEZWJ1Z1Jlc2l6ZUJhciA9IGZhbHNlO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9ufSAqL1xudmFyIGJvdW5kTW91c2VNb3ZlSGFuZGxlcjtcblxuLyoqIEB0eXBlIHtzdHJpbmd9ICovXG52YXIgbW91c2VNb3ZlVG91Y2hFdmVudE5hbWU7XG5cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUub25Nb3VzZURvd25EZWJ1Z1Jlc2l6ZUJhciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBXaGVuIHdlIHNlZSBhIG1vdXNlIGRvd24gaW4gdGhlIHJlc2l6ZSBiYXIsIHN0YXJ0IHRyYWNraW5nIG1vdXNlIG1vdmVzOlxuICB2YXIgZXZlbnRTb3VyY2VFbG0gPSBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50LnRhcmdldDtcbiAgaWYgKGV2ZW50U291cmNlRWxtLmlkID09PSAnZGVidWdSZXNpemVCYXInKSB7XG4gICAgZHJhZ2dpbmdEZWJ1Z1Jlc2l6ZUJhciA9IHRydWU7XG4gICAgYm91bmRNb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5vbk1vdXNlTW92ZURlYnVnUmVzaXplQmFyLmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIG1vdXNlTW92ZVRvdWNoRXZlbnROYW1lID0gZG9tLmdldFRvdWNoRXZlbnROYW1lKCdtb3VzZW1vdmUnKTtcbiAgICBpZiAobW91c2VNb3ZlVG91Y2hFdmVudE5hbWUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihtb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSxcbiAgICAgICAgICBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogIEhhbmRsZSBtb3VzZSBtb3ZlcyB3aGlsZSBkcmFnZ2luZyB0aGUgZGVidWcgcmVzaXplIGJhci5cbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5vbk1vdXNlTW92ZURlYnVnUmVzaXplQmFyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjb2RlQXBwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVBcHAnKTtcbiAgdmFyIGNvZGVUZXh0Ym94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGVUZXh0Ym94Jyk7XG5cbiAgdmFyIHJlc2l6ZUJhciA9IHRoaXMuZ2V0RWxlbWVudF8oJyNkZWJ1Z1Jlc2l6ZUJhcicpO1xuICB2YXIgcmVjdCA9IHJlc2l6ZUJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIG9mZnNldCA9IChwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb2RlQXBwKS5ib3R0b20sIDEwKSB8fCAwKSAtXG4gICAgICByZWN0LmhlaWdodCAvIDI7XG4gIHZhciBuZXdEYmdIZWlnaHQgPSBNYXRoLm1heChNSU5fREVCVUdfQVJFQV9IRUlHSFQsXG4gICAgICBNYXRoLm1pbihNQVhfREVCVUdfQVJFQV9IRUlHSFQsXG4gICAgICAgICAgKHdpbmRvdy5pbm5lckhlaWdodCAtIGV2ZW50LnBhZ2VZKSAtIG9mZnNldCkpO1xuXG4gIGlmICh0aGlzLmRlYnVnT3BlblNodXRDb250cm9sbGVyXy5pc1NodXQoKSkge1xuICAgIHRoaXMuZGVidWdPcGVuU2h1dENvbnRyb2xsZXJfLnNuYXBPcGVuKCk7XG4gIH1cblxuICBjb2RlVGV4dGJveC5zdHlsZS5ib3R0b20gPSBuZXdEYmdIZWlnaHQgKyAncHgnO1xuICB0aGlzLnJvb3REaXZfLnN0eWxlLmhlaWdodCA9IG5ld0RiZ0hlaWdodCArICdweCc7XG5cbiAgLy8gRmlyZSByZXNpemUgc28gYmxvY2tseSBhbmQgZHJvcGxldCBoYW5kbGUgdGhpcyB0eXBlIG9mIHJlc2l6ZSBwcm9wZXJseTpcbiAgdXRpbHMuZmlyZVJlc2l6ZUV2ZW50KCk7XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uTW91c2VVcERlYnVnUmVzaXplQmFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBJZiB3ZSBoYXZlIGJlZW4gdHJhY2tpbmcgbW91c2UgbW92ZXMsIHJlbW92ZSB0aGUgaGFuZGxlciBub3c6XG4gIGlmIChkcmFnZ2luZ0RlYnVnUmVzaXplQmFyKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGlmIChtb3VzZU1vdmVUb3VjaEV2ZW50TmFtZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlTW92ZVRvdWNoRXZlbnROYW1lLFxuICAgICAgICAgIGJvdW5kTW91c2VNb3ZlSGFuZGxlcik7XG4gICAgfVxuICAgIGRyYWdnaW5nRGVidWdSZXNpemVCYXIgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbXB0eSB0aGUgY29udGVudHMgb2YgdGhlIGRlYnVnIGNvbnNvbGUgc2Nyb2xsYmFjayBhcmVhLlxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmNsZWFyRGVidWdPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWJ1Z091dHB1dERpdiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNkZWJ1Zy1vdXRwdXQnKTtcbiAgaWYgKGRlYnVnT3V0cHV0RGl2KSB7XG4gICAgZGVidWdPdXRwdXREaXYudGV4dENvbnRlbnQgPSAnJztcbiAgfVxufTtcblxuLyoqXG4gKiBFbXB0eSB0aGUgZGVidWcgY29uc29sZSBpbnB1dCBhcmVhLlxuICovXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLmNsZWFyRGVidWdJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlYnVnSW5wdXQgPSB0aGlzLmdldEVsZW1lbnRfKCcjZGVidWctaW5wdXQnKTtcbiAgaWYgKGRlYnVnSW5wdXQpIHtcbiAgICBkZWJ1Z0lucHV0LnRleHRDb250ZW50ID0gJyc7XG4gIH1cbn07XG5cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUub25QYXVzZUNvbnRpbnVlQnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgaWYgKGpzSW50ZXJwcmV0ZXIpIHtcbiAgICAvLyBXZSBoYXZlIGNvZGUgYW5kIGFyZSBlaXRoZXIgcnVubmluZyBvciBwYXVzZWRcbiAgICBpZiAoanNJbnRlcnByZXRlci5wYXVzZWQgJiZcbiAgICAgICAganNJbnRlcnByZXRlci5uZXh0U3RlcCA9PT0gU3RlcFR5cGUuUlVOKSB7XG4gICAgICBqc0ludGVycHJldGVyLnBhdXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc0ludGVycHJldGVyLnBhdXNlZCA9IHRydWU7XG4gICAgICBqc0ludGVycHJldGVyLm5leHRTdGVwID0gU3RlcFR5cGUuUlVOO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlUGF1c2VVaVN0YXRlKCk7XG4gIH1cbn07XG5cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUudXBkYXRlUGF1c2VVaVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgaWYgKCFqc0ludGVycHJldGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhdXNlQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3BhdXNlQnV0dG9uJyk7XG4gIHZhciBjb250aW51ZUJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNjb250aW51ZUJ1dHRvbicpO1xuICB2YXIgc3Bpbm5lciA9IHRoaXMuZ2V0RWxlbWVudF8oJyNydW5uaW5nLXNwaW5uZXInKTtcbiAgdmFyIHBhdXNlZEljb24gPSB0aGlzLmdldEVsZW1lbnRfKCcjcGF1c2VkLWljb24nKTtcbiAgaWYgKHBhdXNlQnV0dG9uICYmIGNvbnRpbnVlQnV0dG9uICYmIHNwaW5uZXIgJiYgcGF1c2VkSWNvbikge1xuICAgIGlmIChqc0ludGVycHJldGVyLnBhdXNlZCAmJiBqc0ludGVycHJldGVyLm5leHRTdGVwID09PSBTdGVwVHlwZS5SVU4pIHtcbiAgICAgIHBhdXNlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIGNvbnRpbnVlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgY29udGludWVCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHNwaW5uZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHBhdXNlZEljb24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXVzZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgIHBhdXNlQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBjb250aW51ZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBzcGlubmVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgIHBhdXNlZEljb24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gIH1cblxuICB2YXIgc3RlcEluQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBJbkJ1dHRvbicpO1xuICB2YXIgc3RlcE92ZXJCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcE92ZXJCdXR0b24nKTtcbiAgdmFyIHN0ZXBPdXRCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjc3RlcE91dEJ1dHRvbicpO1xuICBpZiAoc3RlcEluQnV0dG9uICYmIHN0ZXBPdmVyQnV0dG9uICYmIHN0ZXBPdXRCdXR0b24pIHtcbiAgICBzdGVwSW5CdXR0b24uZGlzYWJsZWQgPSAhanNJbnRlcnByZXRlci5wYXVzZWQ7XG4gICAgc3RlcE92ZXJCdXR0b24uZGlzYWJsZWQgPSAhanNJbnRlcnByZXRlci5wYXVzZWQ7XG4gICAgc3RlcE91dEJ1dHRvbi5kaXNhYmxlZCA9ICFqc0ludGVycHJldGVyLnBhdXNlZDtcbiAgfVxufTtcblxuLyoqXG4gKiBQdXQgdGhlIGRlYnVnIGNvbnRyb2xzIGJhY2sgaW50byBhIGRldGFjaGVkIHN0YXRlLlxuICogQHByaXZhdGVcbiAqL1xuSnNEZWJ1Z2dlclVpLnByb3RvdHlwZS5yZXNldERlYnVnQ29udHJvbHNfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3Bpbm5lciA9IHRoaXMuZ2V0RWxlbWVudF8oJyNydW5uaW5nLXNwaW5uZXInKTtcbiAgaWYgKHNwaW5uZXIpIHtcbiAgICBzcGlubmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICB2YXIgcGF1c2VkSWNvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNwYXVzZWQtaWNvbicpO1xuICBpZiAocGF1c2VkSWNvbikge1xuICAgIHBhdXNlZEljb24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHZhciBwYXVzZUJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNwYXVzZUJ1dHRvbicpO1xuICB2YXIgY29udGludWVCdXR0b24gPSB0aGlzLmdldEVsZW1lbnRfKCcjY29udGludWVCdXR0b24nKTtcbiAgdmFyIHN0ZXBJbkJ1dHRvbiA9IHRoaXMuZ2V0RWxlbWVudF8oJyNzdGVwSW5CdXR0b24nKTtcbiAgdmFyIHN0ZXBPdmVyQnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBPdmVyQnV0dG9uJyk7XG4gIHZhciBzdGVwT3V0QnV0dG9uID0gdGhpcy5nZXRFbGVtZW50XygnI3N0ZXBPdXRCdXR0b24nKTtcbiAgaWYgKHBhdXNlQnV0dG9uICYmIGNvbnRpbnVlQnV0dG9uICYmIHN0ZXBJbkJ1dHRvbiAmJlxuICAgICAgc3RlcE92ZXJCdXR0b24gJiYgc3RlcE91dEJ1dHRvbikge1xuICAgIHBhdXNlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgIHBhdXNlQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBjb250aW51ZUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgc3RlcEluQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgc3RlcE92ZXJCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIHN0ZXBPdXRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICB9XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uU3RlcE92ZXJCdXR0b24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGpzSW50ZXJwcmV0ZXIgPSB0aGlzLmpzSW50ZXJwcmV0ZXJfO1xuICBpZiAoanNJbnRlcnByZXRlcikge1xuICAgIGpzSW50ZXJwcmV0ZXIucGF1c2VkID0gdHJ1ZTtcbiAgICBqc0ludGVycHJldGVyLm5leHRTdGVwID0gU3RlcFR5cGUuT1ZFUjtcbiAgICB0aGlzLnVwZGF0ZVBhdXNlVWlTdGF0ZSgpO1xuICB9XG59O1xuXG5Kc0RlYnVnZ2VyVWkucHJvdG90eXBlLm9uU3RlcEluQnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgaWYgKCFqc0ludGVycHJldGVyKSB7XG4gICAgdGhpcy5ydW5BcHBfKCk7XG4gICAgdGhpcy5vblBhdXNlQ29udGludWVCdXR0b24oKTtcbiAgICBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgfVxuICBqc0ludGVycHJldGVyLnBhdXNlZCA9IHRydWU7XG4gIGpzSW50ZXJwcmV0ZXIubmV4dFN0ZXAgPSBTdGVwVHlwZS5JTjtcbiAgdGhpcy51cGRhdGVQYXVzZVVpU3RhdGUoKTtcbn07XG5cbkpzRGVidWdnZXJVaS5wcm90b3R5cGUub25TdGVwT3V0QnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqc0ludGVycHJldGVyID0gdGhpcy5qc0ludGVycHJldGVyXztcbiAgaWYgKGpzSW50ZXJwcmV0ZXIpIHtcbiAgICBqc0ludGVycHJldGVyLnBhdXNlZCA9IHRydWU7XG4gICAganNJbnRlcnByZXRlci5uZXh0U3RlcCA9IFN0ZXBUeXBlLk9VVDtcbiAgICB0aGlzLnVwZGF0ZVBhdXNlVWlTdGF0ZSgpO1xuICB9XG59O1xuIiwiLyoqXG4gKiBCbG9ja2x5IEFwcHM6IFNWRyBTbGlkZXJcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBHb29nbGUgSW5jLlxuICogaHR0cDovL2Jsb2NrbHkuZ29vZ2xlY29kZS5jb20vXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBzbGlkZXIgY29udHJvbCBpbiBTVkcuXG4gKiBAYXV0aG9yIGZyYXNlckBnb29nbGUuY29tIChOZWlsIEZyYXNlcilcbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFNWR19OUyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuU1ZHX05TO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgc2xpZGVyIHdpZGdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIG9mZnNldCBvZiB0aGUgc2xpZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHZlcnRpY2FsIG9mZnNldCBvZiB0aGUgc2xpZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB0b3RhbCB3aWR0aCBvZiB0aGUgc2xpZGVyLlxuICogQHBhcmFtIHshRWxlbWVudH0gc3ZnUGFyZW50IFRoZSBTVkcgZWxlbWVudCB0byBhcHBlbmQgdGhlIHNsaWRlciB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdF9jaGFuZ2VGdW5jIE9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICogICAgIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgaXMgbW92ZWQuICBUaGUgY3VycmVudCB2YWx1ZSBpcyBwYXNzZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNsaWRlciA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBzdmdQYXJlbnQsIG9wdF9jaGFuZ2VGdW5jKSB7XG4gIHRoaXMuS05PQl9ZXyA9IHkgLSAxMjtcbiAgdGhpcy5LTk9CX01JTl9YXyA9IHggKyA4O1xuICB0aGlzLktOT0JfTUFYX1hfID0geCArIHdpZHRoIC0gODtcbiAgdGhpcy52YWx1ZV8gPSAwLjU7XG4gIHRoaXMuY2hhbmdlRnVuY18gPSBvcHRfY2hhbmdlRnVuYztcbiAgdGhpcy5pc0FuZHJvaWRfID0gZG9tLmlzQW5kcm9pZCgpO1xuICB0aGlzLmlzSU9TXyA9IGRvbS5pc0lPUygpO1xuICB0aGlzLmlzV2luZG93c1RvdWNoXyA9IGRvbS5pc1dpbmRvd3NUb3VjaCgpO1xuXG4gIC8vIERyYXcgdGhlIHNsaWRlci5cbiAgLypcbiAgPGxpbmUgY2xhc3M9XCJzbGlkZXJUcmFja1wiIHgxPVwiMTBcIiB5MT1cIjM1XCIgeDI9XCIxNDBcIiB5Mj1cIjM1XCIgLz5cbiAgPHBhdGggaWQ9XCJrbm9iXCJcbiAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2NywgMjMpXCJcbiAgICAgIGQ9XCJtIDgsMCBsIC04LDggdiAxMiBoIDE2IHYgLTEyIHpcIiAvPlxuICAqL1xuICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAnbGluZScpO1xuICB0cmFjay5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NsaWRlclRyYWNrJyk7XG4gIHRyYWNrLnNldEF0dHJpYnV0ZSgneDEnLCB4KTtcbiAgdHJhY2suc2V0QXR0cmlidXRlKCd5MScsIHkpO1xuICB0cmFjay5zZXRBdHRyaWJ1dGUoJ3gyJywgeCArIHdpZHRoKTtcbiAgdHJhY2suc2V0QXR0cmlidXRlKCd5MicsIHkpO1xuICBzdmdQYXJlbnQuYXBwZW5kQ2hpbGQodHJhY2spO1xuICB0aGlzLnRyYWNrXyA9IHRyYWNrO1xuICB2YXIga25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdwYXRoJyk7XG4gIGtub2Iuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzbGlkZXJLbm9iJyk7XG4gIGtub2Iuc2V0QXR0cmlidXRlKCdkJywgJ20gMCwwIGwgLTgsOCB2IDEyIGggMTYgdiAtMTIgeicpO1xuICBzdmdQYXJlbnQuYXBwZW5kQ2hpbGQoa25vYik7XG4gIHRoaXMua25vYl8gPSBrbm9iO1xuICB0aGlzLnNldFZhbHVlKDAuNSk7XG5cbiAgLy8gRmluZCB0aGUgcm9vdCBTVkcgb2JqZWN0LlxuICB3aGlsZSAoc3ZnUGFyZW50ICYmIHN2Z1BhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdzdmcnKSB7XG4gICAgc3ZnUGFyZW50ID0gc3ZnUGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgdGhpcy5TVkdfID0gc3ZnUGFyZW50O1xuXG4gIC8vIEJpbmQgdGhlIGV2ZW50cyB0byB0aGlzIHNsaWRlci5cbiAgdmFyIHRoaXNTbGlkZXIgPSB0aGlzO1xuICBkb20uYWRkTW91c2VEb3duVG91Y2hFdmVudCh0aGlzLmtub2JfLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXNTbGlkZXIua25vYk1vdXNlRG93bl8oZSk7XG4gIH0pO1xuICBkb20uYWRkTW91c2VEb3duVG91Y2hFdmVudCh0aGlzLnRyYWNrXywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzU2xpZGVyLnRyYWNrTW91c2VEb3duXyhlKTtcbiAgfSk7XG4gIGRvbS5hZGRNb3VzZVVwVG91Y2hFdmVudCh0aGlzLlNWR18sIFNsaWRlci5rbm9iTW91c2VVcF8pO1xuICBkb20uYWRkTW91c2VNb3ZlVG91Y2hFdmVudCh0aGlzLlNWR18sIFNsaWRlci5rbm9iTW91c2VNb3ZlXyk7XG4gIC8vIERvbid0IGFkZCB0b3VjaCBldmVudHMgZm9yIG1vdXNlb3Zlci4gVGhlIFVYIGlzIGJldHRlciBvbiBBbmRyb2lkXG4gIC8vIGFuZCBpT1MgaWYgdGhlIGRyYWcgYWN0aW9uIGlzIGFsbG93ZWQgdG8gY29udGludWUgd2hlbiB0aGVcbiAgLy8gdG91Y2htb3ZlIHRhcmdldCBtb3ZlcyBhYm92ZSBvciBiZWxvdyB0aGUgU1ZHIGVsZW1lbnQuXG4gIFNsaWRlci5iaW5kRXZlbnRfKGRvY3VtZW50LCAnbW91c2VvdmVyJywgU2xpZGVyLm1vdXNlT3Zlcl8pO1xufTtcblxuU2xpZGVyLmFjdGl2ZVNsaWRlcl8gPSBudWxsO1xuU2xpZGVyLnN0YXJ0TW91c2VYXyA9IDA7XG5TbGlkZXIuc3RhcnRLbm9iWF8gPSAwO1xuXG4vKipcbiAqIFN0YXJ0IGEgZHJhZyB3aGVuIGNsaWNraW5nIGRvd24gb24gdGhlIGtub2IuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBNb3VzZS1kb3duIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5rbm9iTW91c2VEb3duXyA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5iZWdpbkRyYWdfKHRoaXMubW91c2VUb1N2Z18oZSkpO1xuXG4gIC8vIFN0b3AgYnJvd3NlciBmcm9tIGF0dGVtcHRpbmcgdG8gZHJhZyB0aGUga25vYi5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNuYXAgdGhlIGtub2IgdG8gdGhlIG1vdXNlIGxvY2F0aW9uIGFuZCBzdGFydCBhIGRyYWdcbiAqIHdoZW4gY2xpY2tpbmcgb24gdGhlIHRyYWNrIChidXQgbm90IG9uIHRoZSBrbm9iKS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIE1vdXNlLWRvd24gZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5TbGlkZXIucHJvdG90eXBlLnRyYWNrTW91c2VEb3duXyA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIG1vdXNlU1ZHUG9zaXRpb24gPSB0aGlzLm1vdXNlVG9TdmdfKGUpO1xuICB0aGlzLnNuYXBUb1Bvc2l0aW9uXyhtb3VzZVNWR1Bvc2l0aW9uLngpO1xuICB0aGlzLmJlZ2luRHJhZ18obW91c2VTVkdQb3NpdGlvbik7XG5cbiAgLy8gU3RvcCBicm93c2VyIGZyb20gYXR0ZW1wdGluZyB0byBkcmFnIHRoZSB0cmFjay5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGRyYWdnaW5nIHRoZSBzbGlkZXIga25vYi5cbiAqIEBwYXJhbSB7IU9iamVjdH0gbW91c2VTdGFydFNWRyBNb3VzZSBzdGFydCBwb3NpdGlvbiBpbiBTVkcgc3BhY2VcbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5wcm90b3R5cGUuYmVnaW5EcmFnXyA9IGZ1bmN0aW9uKHN0YXJ0TW91c2VTVkcpIHtcbiAgU2xpZGVyLmFjdGl2ZVNsaWRlcl8gPSB0aGlzO1xuICBTbGlkZXIuc3RhcnRNb3VzZVhfID0gc3RhcnRNb3VzZVNWRy54O1xuICBTbGlkZXIuc3RhcnRLbm9iWF8gPSAwO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy5rbm9iXy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmFyIHIgPSB0cmFuc2Zvcm0ubWF0Y2goL3RyYW5zbGF0ZVxcKFxccyooWy1cXGQuXSspLyk7XG4gICAgaWYgKHIpIHtcbiAgICAgIFNsaWRlci5zdGFydEtub2JYXyA9IE51bWJlcihyWzFdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU25hcCB0aGUgc2xpZGVyIGtub2IgdG8gdGhlIGNsaWNrZWQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0geFBvc2l0aW9uIFNWRyB4LWNvb3JkaW5hdGVcbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5wcm90b3R5cGUuc25hcFRvUG9zaXRpb25fID0gZnVuY3Rpb24oeFBvc2l0aW9uKSB7XG4gIHZhciB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeFBvc2l0aW9uLCBcbiAgICAgICAgdGhpcy5LTk9CX01JTl9YXyksIHRoaXMuS05PQl9NQVhfWF8pO1xuICB0aGlzLmtub2JfLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB0aGlzLktOT0JfWV8gKyAnKScpO1xuXG4gIHRoaXMudmFsdWVfID0gKHggLSB0aGlzLktOT0JfTUlOX1hfKSAvXG4gICAgICAodGhpcy5LTk9CX01BWF9YXyAtIHRoaXMuS05PQl9NSU5fWF8pO1xuICBpZiAodGhpcy5jaGFuZ2VGdW5jXykge1xuICAgIHRoaXMuY2hhbmdlRnVuY18odGhpcy52YWx1ZV8pO1xuICB9XG59O1xuXG4vKipcbiAqIFN0b3AgYSBkcmFnIHdoZW4gY2xpY2tpbmcgdXAgYW55d2hlcmUuXG4gKiBAcGFyYW0ge0V2ZW50fSBlIE1vdXNlLXVwIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLmtub2JNb3VzZVVwXyA9IGZ1bmN0aW9uKGUpIHtcbiAgU2xpZGVyLmFjdGl2ZVNsaWRlcl8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBTdG9wIGEgZHJhZyB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgYSBub2RlIG5vdCBwYXJ0IG9mIHRoZSBTVkcuXG4gKiBAcGFyYW0ge0V2ZW50fSBlIE1vdXNlLXVwIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLm1vdXNlT3Zlcl8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICghU2xpZGVyLmFjdGl2ZVNsaWRlcl8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRmluZCB0aGUgcm9vdCBTVkcgb2JqZWN0LlxuICBmb3IgKHZhciBub2RlID0gZS50YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBTbGlkZXIuYWN0aXZlU2xpZGVyXy5TVkdfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIFNsaWRlci5rbm9iTW91c2VVcF8oZSk7XG59O1xuXG4vKipcbiAqIERyYWcgdGhlIGtub2IgdG8gZm9sbG93IHRoZSBtb3VzZS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIE1vdXNlLW1vdmUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5TbGlkZXIua25vYk1vdXNlTW92ZV8gPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0aGlzU2xpZGVyID0gU2xpZGVyLmFjdGl2ZVNsaWRlcl87XG4gIGlmICghdGhpc1NsaWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgeCA9IHRoaXNTbGlkZXIubW91c2VUb1N2Z18oZSkueCAtIFNsaWRlci5zdGFydE1vdXNlWF8gK1xuICAgICAgU2xpZGVyLnN0YXJ0S25vYlhfO1xuICB0aGlzU2xpZGVyLnNuYXBUb1Bvc2l0aW9uXyh4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2xpZGVyJ3MgdmFsdWUgKDAuMCAtIDEuMCkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEN1cnJlbnQgdmFsdWUuXG4gKi9cblNsaWRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVfO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzbGlkZXIncyB2YWx1ZSAoMC4wIC0gMS4wKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBOZXcgdmFsdWUuXG4gKi9cblNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnZhbHVlXyA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMSk7XG4gIHZhciB4ID0gdGhpcy5LTk9CX01JTl9YXyArXG4gICAgICAodGhpcy5LTk9CX01BWF9YXyAtIHRoaXMuS05PQl9NSU5fWF8pICogdGhpcy52YWx1ZV87XG4gIHRoaXMua25vYl8uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLFxuICAgICAgJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHRoaXMuS05PQl9ZXyArICcpJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIGludG8gU1ZHIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHshT2JqZWN0fSBlIE9iamVjdCB3aXRoIHggYW5kIHkgbW91c2UgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBPYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgaW4gU1ZHIGNvb3JkaW5hdGVzLlxuICogQHByaXZhdGVcbiAqL1xuU2xpZGVyLnByb3RvdHlwZS5tb3VzZVRvU3ZnXyA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHN2Z1BvaW50ID0gdGhpcy5TVkdfLmNyZWF0ZVNWR1BvaW50KCk7XG4gIC8vIE1vc3QgYnJvd3NlcnMgcHJvdmlkZSBjbGllbnRYL1kuIGlPUyBvbmx5IHByb3ZpZGVzIHBhZ2VYL1kuXG4gIC8vIEFuZHJvaWQgQ2hyb21lIG9ubHkgcHJvdmlkZXMgY29vcmRpbmF0ZXMgd2l0aGluIGUuY2hhbmdlZFRvdWNoZXMuXG4gIGlmICh0aGlzLmlzV2luZG93c1RvdWNoXykge1xuICAgIC8vIE9ubHkgc2NyZWVuWC9ZIHByb3Blcmx5IGFjY291bnRzIGZvciB6b29taW5nIGluIG9uIHdpbmRvd3MgdG91Y2guXG4gICAgc3ZnUG9pbnQueCA9IGUuc2NyZWVuWDtcbiAgICBzdmdQb2ludC55ID0gZS5zY3JlZW5ZO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNBbmRyb2lkXykge1xuICAgIHN2Z1BvaW50LnggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHN2Z1BvaW50LnkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNJT1NfKSB7XG4gICAgc3ZnUG9pbnQueCA9IGUucGFnZVg7XG4gICAgc3ZnUG9pbnQueSA9IGUucGFnZVk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnUG9pbnQueCA9IGUuY2xpZW50WDtcbiAgICBzdmdQb2ludC55ID0gZS5jbGllbnRZO1xuICB9XG4gIHZhciBtYXRyaXggPSB0aGlzLlNWR18uZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xuICByZXR1cm4gc3ZnUG9pbnQubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG59O1xuXG4vKipcbiAqIEJpbmQgYW4gZXZlbnQgdG8gYSBmdW5jdGlvbiBjYWxsLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHVwb24gd2hpY2ggdG8gbGlzdGVuLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBsaXN0ZW4gdG8gKGUuZy4gJ21vdXNlZG93bicpLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAqIEBwcml2YXRlXG4gKi9cblNsaWRlci5iaW5kRXZlbnRfID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgZnVuYykge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgZmFsc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29uc3RhbnRzIHVzZWQgaW4gcHJvZHVjdGlvbiBjb2RlIGFuZCB0ZXN0cy5cbiAqL1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHVzZXIgcHJvZ3JhbSBleGVjdXRpb24gb3V0Y29tZXMuXG4gKiBUaGVzZSBhcmUgZGV0ZXJtaW5lZCBieSBlYWNoIGFwcC5cbiAqL1xuZXhwb3J0cy5SZXN1bHRUeXBlID0ge1xuICBVTlNFVDogMCwgICAgICAgLy8gVGhlIHJlc3VsdCBoYXMgbm90IHlldCBiZWVuIGNvbXB1dGVkLlxuICBTVUNDRVNTOiAxLCAgICAgLy8gVGhlIHByb2dyYW0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgYWNoaWV2aW5nIHRoZSBnb2FsLlxuICBGQUlMVVJFOiAtMSwgICAgLy8gVGhlIHByb2dyYW0gcmFuIHdpdGhvdXQgZXJyb3IgYnV0IGRpZCBub3QgYWNoaWV2ZSBnb2FsLlxuICBUSU1FT1VUOiAyLCAgICAgLy8gVGhlIHByb2dyYW0gZGlkIG5vdCBjb21wbGV0ZSAobGlrZWx5IGluZmluaXRlIGxvb3ApLlxuICBFUlJPUjogLTIgICAgICAgLy8gVGhlIHByb2dyYW0gZ2VuZXJhdGVkIGFuIGVycm9yLlxufTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiB0ZXN0IHJlc3VsdHMuXG4gKiBFTVBUWV9CTE9DS19GQUlMIGFuZCBFTVBUWV9GVU5DVElPTl9CTE9DS19GQUlMIGNhbiBvbmx5IG9jY3VyIGlmXG4gKiBTdHVkaW9BcHAuY2hlY2tGb3JFbXB0eUJsb2Nrc18gaXMgdHJ1ZS5cbiAqIE5PVEU6IFdlIHN0b3JlIHRoZSByZXN1bHRzIGZvciB1c2VyIGF0dGVtcHRzIGluIG91ciBkYiwgc28gY2hhbmdpbmcgdGhlc2VcbiAqIHZhbHVlcyB3b3VsZCBuZWNlc3NpdGF0ZSBhIG1pZ3JhdGlvblxuICovXG5leHBvcnRzLlRlc3RSZXN1bHRzID0ge1xuICAvLyBEZWZhdWx0IHZhbHVlIGJlZm9yZSBhbnkgdGVzdHMgYXJlIHJ1bi5cbiAgTk9fVEVTVFNfUlVOOiAtMSxcblxuICAvLyBUaGUgbGV2ZWwgd2FzIG5vdCBzb2x2ZWQuXG4gIEVNUFRZX0JMT0NLX0ZBSUw6IDEsICAgICAgICAgICAgICAgIC8vIEFuIFwiaWZcIiBvciBcInJlcGVhdFwiIGJsb2NrIHdhcyBlbXB0eS5cbiAgVE9PX0ZFV19CTE9DS1NfRkFJTDogMiwgICAgICAgICAgICAgLy8gRmV3ZXIgdGhhbiB0aGUgaWRlYWwgbnVtYmVyIG9mIGJsb2NrcyB1c2VkLlxuICBMRVZFTF9JTkNPTVBMRVRFX0ZBSUw6IDMsICAgICAgICAgICAvLyBEZWZhdWx0IGZhaWx1cmUgdG8gY29tcGxldGUgYSBsZXZlbC5cbiAgTUlTU0lOR19CTE9DS19VTkZJTklTSEVEOiA0LCAgICAgICAgLy8gQSByZXF1aXJlZCBibG9jayB3YXMgbm90IHVzZWQuXG4gIEVYVFJBX1RPUF9CTE9DS1NfRkFJTDogNSwgICAgICAgICAgIC8vIFRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIHRvcC1sZXZlbCBibG9jay5cbiAgUlVOVElNRV9FUlJPUl9GQUlMOiA2LCAgICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgcnVudGltZSBlcnJvciBpbiB0aGUgcHJvZ3JhbS5cbiAgU1lOVEFYX0VSUk9SX0ZBSUw6IDcsICAgICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgc3ludGF4IGVycm9yIGluIHRoZSBwcm9ncmFtLlxuICBNSVNTSU5HX0JMT0NLX0ZJTklTSEVEOiAxMCwgICAgICAgICAvLyBUaGUgbGV2ZWwgd2FzIHNvbHZlZCB3aXRob3V0IHJlcXVpcmVkIGJsb2NrLlxuICBBUFBfU1BFQ0lGSUNfRkFJTDogMTEsICAgICAgICAgICAgICAvLyBBcHBsaWNhdGlvbi1zcGVjaWZpYyBmYWlsdXJlLlxuICBFTVBUWV9GVU5DVElPTl9CTE9DS19GQUlMOiAxMiwgICAgICAvLyBBIFwiZnVuY3Rpb25cIiBibG9jayB3YXMgZW1wdHlcbiAgVU5VU0VEX1BBUkFNOiAxMywgICAgICAgICAgICAgICAgICAgLy8gUGFyYW0gZGVjbGFyZWQgYnV0IG5vdCB1c2VkIGluIGZ1bmN0aW9uLlxuICBVTlVTRURfRlVOQ1RJT046IDE0LCAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBkZWNsYXJlZCBidXQgbm90IHVzZWQgaW4gd29ya3NwYWNlLlxuICBQQVJBTV9JTlBVVF9VTkFUVEFDSEVEOiAxNSwgICAgICAgICAvLyBGdW5jdGlvbiBub3QgY2FsbGVkIHdpdGggZW5vdWdoIHBhcmFtcy5cbiAgSU5DT01QTEVURV9CTE9DS19JTl9GVU5DVElPTjogMTYsICAgLy8gSW5jb21wbGV0ZSBibG9jayBpbnNpZGUgYSBmdW5jdGlvbi5cbiAgUVVFU1RJT05fTUFSS1NfSU5fTlVNQkVSX0ZJRUxEOiAxNywgLy8gQmxvY2sgaGFzID8/PyBpbnN0ZWFkIG9mIGEgdmFsdWUuXG4gIEVNUFRZX0ZVTkNUSU9OQUxfQkxPQ0s6IDE4LCAgICAgICAgIC8vIFRoZXJlJ3MgYSBmdW5jdGlvbmFsIGJsb2NrIHdpdGggYW4gb3BlbiBpbnB1dFxuICBFWEFNUExFX0ZBSUxFRDogMTksICAgICAgICAgICAgICAgICAvLyBPbmUgb2Ygb3VyIGV4YW1wbGVzIGRpZG4ndCBtYXRjaCB0aGUgZGVmaW5pdGlvblxuXG4gIC8vIHN0YXJ0IHVzaW5nIG5lZ2F0aXZlIHZhbHVlcywgc2luY2Ugd2UgY29uc2lkZXIgPj0gMjAgdG8gYmUgXCJzb2x2ZWRcIlxuICBORVNURURfRk9SX1NBTUVfVkFSSUFCTEU6IC0yLCAgICAgICAvLyBXZSBoYXZlIG5lc3RlZCBmb3IgbG9vcHMgZWFjaCB1c2luZyB0aGUgc2FtZSBjb3VudGVyIHZhcmlhYmxlXG4gIC8vIE5PVEU6IGZvciBzbW9lIHBlcmlvZCBvZiB0aW1lLCB0aGlzIHdhcyAtMSBhbmQgY29uZmxpY3RlZCB3aXRoIE5PX1RFU1RTX1JVTlxuICBFTVBUWV9GVU5DVElPTl9OQU1FOiAtMywgICAgICAgICAgICAvLyBXZSBoYXZlIGEgdmFyaWFibGUgb3IgZnVuY3Rpb24gd2l0aCB0aGUgbmFtZSBcIlwiXG4gIE1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfVU5GSU5JU0hFRDogLTQsIC8vIFRoZSBsZXZlbCB3YXMgYXR0ZW1wdGVkIGJ1dCBub3Qgc29sdmVkIHdpdGhvdXQgYSByZWNvbW1lbmRlZCBibG9ja1xuICBFWFRSQV9GVU5DVElPTl9GQUlMOiAtNSwgICAgICAgICAgICAvLyBUaGUgcHJvZ3JhbSBjb250YWlucyBhIEphdmFTY3JpcHQgZnVuY3Rpb24gd2hlbiBpdCBzaG91bGQgbm90XG4gIExPQ0FMX0ZVTkNUSU9OX0ZBSUw6IC02LCAgICAgICAgICAgIC8vIFRoZSBwcm9ncmFtIGNvbnRhaW5zIGFuIHVuZXhwZWN0ZWQgSmF2YVNjcmlwdCBsb2NhbCBmdW5jdGlvblxuXG4gIC8vIFRoZSBsZXZlbCB3YXMgc29sdmVkIGluIGEgbm9uLW9wdGltYWwgd2F5LiAgVXNlciBtYXkgYWR2YW5jZSBvciByZXRyeS5cbiAgVE9PX01BTllfQkxPQ0tTX0ZBSUw6IDIwLCAgICAgICAgICAgICAgIC8vIE1vcmUgdGhhbiB0aGUgaWRlYWwgbnVtYmVyIG9mIGJsb2NrcyB3ZXJlIHVzZWQuXG4gIEFQUF9TUEVDSUZJQ19BQ0NFUFRBQkxFX0ZBSUw6IDIxLCAgICAgICAvLyBBcHBsaWNhdGlvbi1zcGVjaWZpYyBhY2NlcHRhYmxlIGZhaWx1cmUuXG4gIE1JU1NJTkdfUkVDT01NRU5ERURfQkxPQ0tfRklOSVNIRUQ6IDIyLCAvLyBUaGUgbGV2ZWwgd2FzIHNvbHZlZCB3aXRob3V0IGEgcmVjb21tZW5kZWQgYmxvY2tcblxuICAvLyBPdGhlci5cbiAgRlJFRV9QTEFZOiAzMCwgICAvLyBUaGUgdXNlciBpcyBpbiBmcmVlLXBsYXkgbW9kZS5cbiAgRURJVF9CTE9DS1M6IDcwLCAvLyBUaGUgdXNlciBpcyBjcmVhdGluZy9lZGl0aW5nIGEgbmV3IGxldmVsLlxuXG4gIC8vIFRoZSBsZXZlbCB3YXMgc29sdmVkIGluIHRoZSBpZGVhbCBtYW5uZXIuXG4gIEFMTF9QQVNTOiAxMDBcbn07XG5cbmV4cG9ydHMuQmVlVGVybWluYXRpb25WYWx1ZSA9IHtcbiAgRkFJTFVSRTogZmFsc2UsXG4gIFNVQ0NFU1M6IHRydWUsXG4gIElORklOSVRFX0xPT1A6IEluZmluaXR5LFxuICBOT1RfQVRfRkxPV0VSOiAxLCAgICAgLy8gVHJpZWQgdG8gZ2V0IG5lY3RhciB3aGVuIG5vdCBhdCBmbG93ZXIuXG4gIEZMT1dFUl9FTVBUWTogMiwgICAgICAvLyBUcmllZCB0byBnZXQgbmVjdGFyIHdoZW4gZmxvd2VyIGVtcHR5LlxuICBOT1RfQVRfSE9ORVlDT01COiAzLCAgLy8gVHJpZWQgdG8gbWFrZSBob25leSB3aGVuIG5vdCBhdCBob25leWNvbWIuXG4gIEhPTkVZQ09NQl9GVUxMOiA0LCAgICAvLyBUcmllZCB0byBtYWtlIGhvbmV5LCBidXQgbm8gcm9vbSBhdCBob25leWNvbWIuXG4gIFVOQ0hFQ0tFRF9DTE9VRDogNSwgICAgLy8gRmluaXNoZWQgcHV6emxlLCBidXQgZGlkbid0IGNoZWNrIGV2ZXJ5IGNsb3VkZWQgaXRlbVxuICBVTkNIRUNLRURfUFVSUExFOiA2LCAgIC8vIEZpbmlzaGVkIHB1enpsZSwgYnV0IGRpZG4ndCBjaGVjayBldmVyeSBwdXJwbGUgZmxvd2VyXG4gIElOU1VGRklDSUVOVF9ORUNUQVI6IDcsLy8gRGlkbid0IGNvbGxlY3QgYWxsIG5lY3RhciBieSBmaW5pc2hcbiAgSU5TVUZGSUNJRU5UX0hPTkVZOiA4LCAvLyBEaWRuJ3QgbWFrZSBhbGwgaG9uZXkgYnkgZmluaXNoXG4gIERJRF9OT1RfQ09MTEVDVF9FVkVSWVRISU5HOiA5IC8vIEZvciBxdWFudHVtIGxldmVscywgZGlkbid0IHRyeSB0byBjb2xsZWN0IGFsbCBhdmFpbGFibGUgaG9uZXkvbmVjdGFyXG59O1xuXG5leHBvcnRzLktleUNvZGVzID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIEVOVEVSOiAxMyxcbiAgU1BBQ0U6IDMyLFxuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBSSUdIVDogMzksXG4gIERPV046IDQwLFxuICBERUxFVEU6IDEyN1xufTtcblxuLyoqIEBjb25zdCB7c3RyaW5nfSBTVkcgZWxlbWVudCBuYW1lc3BhY2UgKi9cbmV4cG9ydHMuU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiIsIi8qKiBAZmlsZSBIZWxwZXIgZm9yIGNvbnN1bWluZyBPYnNlcnZhYmxlRXZlbnRzLiAqL1xuLy8gU3RyaWN0IGxpbnRpbmc6IEFic29yYiBpbnRvIGdsb2JhbCBjb25maWcgd2hlbiBwb3NzaWJsZVxuLyoganNoaW50XG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcbiBtYXhsZW46IDEyMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSGVscGVyIG9iamVjdCBmb3IgY29uc3VtaW5nIE9ic2VydmFibGVFdmVudHMsIGRlc2lnbmVkIGZvciBjb21wb3NpdGlvbiBpbnRvXG4gKiBvdGhlciBjbGFzc2VzLiAgUmVtZW1iZXJzIHdoYXQgaXQncyBvYnNlcnZpbmcgYW5kIHByb3ZpZGVzIHNhZmVyIHdheXMgdG9cbiAqIHN0b3Agb2JzZXJ2aW5nIHRob3NlIHRoaW5ncy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT2JzZXJ2ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlIHtBcnJheS48T2JqZWN0Pn0gZXZlbnQta2V5IHBhaXJzIG9mIG9ic2VydmVkIGV2ZW50cywgZm9yIGVhc3lcbiAgICogICAgICAgICAgdW5yZWdpc3RlcmluZyBsYXRlci5cbiAgICovXG4gIHRoaXMub2JzZXJ2ZWRfID0gW107XG59O1xuXG4vKipcbiAqIEJlZ2luIG9ic2VydmluZyB0aGUgZ2l2ZW4gZXZlbnQsIGZvcndhcmRpbmcgaXQgdG8gdGhlIHByb3ZpZGVkIGNhbGxiYWNrXG4gKiB3aGVuZXZlciB0aGUgZXZlbnQgb2NjdXJzLlxuICogQHBhcmFtIHshT2JzZXJ2YWJsZUV2ZW50fSBldmVudFxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gZXZlbnQucmVnaXN0ZXIoY2FsbGJhY2spO1xuICB0aGlzLm9ic2VydmVkXy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAga2V5OiBrZXlcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIgYWxsIGNhbGxiYWNrcyBmcm9tIGFsbCBvYnNlcnZlZCBldmVudHMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub2JzZXJ2ZWRfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICBvYnNlcnZhYmxlLmV2ZW50LnVucmVnaXN0ZXIob2JzZXJ2YWJsZS5rZXkpO1xuICB9KTtcbiAgdGhpcy5vYnNlcnZlZF8ubGVuZ3RoID0gMDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IGZ1bmN0aW9uIGFub255bW91cyhsb2NhbHMsIGZpbHRlcnMsIGVzY2FwZVxuLyoqLykge1xuZXNjYXBlID0gZXNjYXBlIHx8IGZ1bmN0aW9uIChodG1sKXtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mKD8hXFx3KzspL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbnZhciBidWYgPSBbXTtcbndpdGggKGxvY2FscyB8fCB7fSkgeyAoZnVuY3Rpb24oKXsgXG4gYnVmLnB1c2goJycpOzE7IHZhciBpMThuID0gcmVxdWlyZSgnLi9sb2NhbGUnKTsgOyBidWYucHVzaCgnXFxuXFxuPGRpdiBpZD1cImRlYnVnLWFyZWFcIj5cXG4gIDxkaXYgaWQ9XCJkZWJ1Z1Jlc2l6ZUJhclwiIGNsYXNzPVwiZmEgZmEtZWxsaXBzaXMtaFwiPjwvZGl2PlxcbiAgPGRpdiBpZD1cImRlYnVnLWFyZWEtaGVhZGVyXCI+XFxuICAgIDxzcGFuIGNsYXNzPVwiaGVhZGVyLXRleHRcIj4nLCBlc2NhcGUoKDYsICBpMThuLmRlYnVnQ29uc29sZUhlYWRlcigpICkpLCAnPC9zcGFuPlxcbiAgICA8aSBpZD1cInNob3ctaGlkZS1kZWJ1Zy1pY29uXCIgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1kb3duXCI+PC9pPlxcbiAgICAnKTs4OyBpZiAoZGVidWdCdXR0b25zKSB7IDsgYnVmLnB1c2goJ1xcbiAgICA8ZGl2IGlkPVwiZGVidWctY29tbWFuZHMtaGVhZGVyXCIgY2xhc3M9XCJ3b3Jrc3BhY2UtaGVhZGVyXCI+XFxuICAgICAgPGkgaWQ9XCJydW5uaW5nLXNwaW5uZXJcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgY2xhc3M9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIj48L2k+XFxuICAgICAgPGkgaWQ9XCJwYXVzZWQtaWNvblwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIiBjbGFzcz1cImZhIGZhLXBhdXNlXCI+PC9pPlxcbiAgICAgIDxzcGFuIGNsYXNzPVwiaGVhZGVyLXRleHRcIj4nLCBlc2NhcGUoKDEyLCAgaTE4bi5kZWJ1Z0NvbW1hbmRzSGVhZGVyV2hlbk9wZW4oKSApKSwgJzwvc3Bhbj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgaWQ9XCJjbGVhci1jb25zb2xlLWhlYWRlclwiIGNsYXNzPVwid29ya3NwYWNlLWhlYWRlciB3b3Jrc3BhY2UtaGVhZGVyLWJ1dHRvblwiPjxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtZXJhc2VyXCI+PC9pPkNsZWFyPC9zcGFuPjwvZGl2PlxcbiAgICAnKTsxNTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICAgPGRpdiBpZD1cInNsaWRlci1jZWxsXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDogJywgZXNjYXBlKCgxNiwgIGRlYnVnQnV0dG9ucyA/IDAgOiA0MCApKSwgJ3B4XCI+XFxuICAgICAgPHN2ZyBpZD1cInNwZWVkLXNsaWRlclwiXFxuICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcXG4gICAgICAgICAgIHhtbG5zOnN2Zz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcXG4gICAgICAgICAgIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXFxuICAgICAgICAgICB2ZXJzaW9uPVwiMS4xXCJcXG4gICAgICAgICAgIHdpZHRoPVwiMTUwXCJcXG4gICAgICAgICAgIGhlaWdodD1cIjI4XCI+XFxuICAgICAgICAgIDwhLS0gU2xvdyBpY29uLiAtLT5cXG4gICAgICAgICAgPGNsaXBQYXRoIGlkPVwic2xvd0NsaXBQYXRoXCI+XFxuICAgICAgICAgICAgPHJlY3Qgd2lkdGg9MjYgaGVpZ2h0PTEyIHg9NSB5PTYgLz5cXG4gICAgICAgICAgPC9jbGlwUGF0aD5cXG4gICAgICAgICAgPGltYWdlIHhsaW5rOmhyZWY9XCInLCBlc2NhcGUoKDI4LCAgYXNzZXRVcmwoJ21lZGlhL3R1cnRsZV9pY29ucy5wbmcnKSApKSwgJ1wiIGhlaWdodD00MiB3aWR0aD04NCB4PS0yMSB5PS0xOFxcbiAgICAgICAgICAgICAgY2xpcC1wYXRoPVwidXJsKCNzbG93Q2xpcFBhdGgpXCIgLz5cXG4gICAgICAgICAgPCEtLSBGYXN0IGljb24uIC0tPlxcbiAgICAgICAgICA8Y2xpcFBhdGggaWQ9XCJmYXN0Q2xpcFBhdGhcIj5cXG4gICAgICAgICAgICA8cmVjdCB3aWR0aD0yNiBoZWlnaHQ9MTYgeD0xMjAgeT0yIC8+XFxuICAgICAgICAgIDwvY2xpcFBhdGg+XFxuICAgICAgICAgIDxpbWFnZSB4bGluazpocmVmPVwiJywgZXNjYXBlKCgzNCwgIGFzc2V0VXJsKCdtZWRpYS90dXJ0bGVfaWNvbnMucG5nJykgKSksICdcIiBoZWlnaHQ9NDIgd2lkdGg9ODQgeD0xMjAgeT0tMTlcXG4gICAgICAgICAgICAgIGNsaXAtcGF0aD1cInVybCgjZmFzdENsaXBQYXRoKVwiIC8+XFxuICAgICAgPC9zdmc+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICAnKTs0MDsgaWYgKGRlYnVnQnV0dG9ucykgeyA7IGJ1Zi5wdXNoKCdcXG4gIDxkaXYgaWQ9XCJkZWJ1Zy1jb21tYW5kc1wiIGNsYXNzPVwiZGVidWctY29tbWFuZHNcIj5cXG4gICAgPGRpdiBpZD1cImRlYnVnLWJ1dHRvbnNcIj5cXG4gICAgICA8YnV0dG9uIGlkPVwicGF1c2VCdXR0b25cIiBjbGFzcz1cImRlYnVnZ2VyX2J1dHRvblwiPlxcbiAgICAgICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDQ0LCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwicGF1c2UtYnRuIGljb24yMVwiPlxcbiAgICAgICAgJywgZXNjYXBlKCg0NSwgIGkxOG4ucGF1c2UoKSApKSwgJ1xcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gaWQ9XCJjb250aW51ZUJ1dHRvblwiIGNsYXNzPVwiZGVidWdnZXJfYnV0dG9uXCI+XFxuICAgICAgICA8aW1nIHNyYz1cIicsIGVzY2FwZSgoNDgsICBhc3NldFVybCgnbWVkaWEvMXgxLmdpZicpICkpLCAnXCIgY2xhc3M9XCJjb250aW51ZS1idG4gaWNvbjIxXCI+XFxuICAgICAgICAnLCBlc2NhcGUoKDQ5LCAgaTE4bi5jb250aW51ZSgpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBpZD1cInN0ZXBPdmVyQnV0dG9uXCIgY2xhc3M9XCJkZWJ1Z2dlcl9idXR0b25cIj5cXG4gICAgICAgIDxpbWcgc3JjPVwiJywgZXNjYXBlKCg1MiwgIGFzc2V0VXJsKCdtZWRpYS8xeDEuZ2lmJykgKSksICdcIiBjbGFzcz1cInN0ZXAtb3Zlci1idG4gaWNvbjIxXCI+XFxuICAgICAgICAnLCBlc2NhcGUoKDUzLCAgaTE4bi5zdGVwT3ZlcigpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBpZD1cInN0ZXBPdXRCdXR0b25cIiBjbGFzcz1cImRlYnVnZ2VyX2J1dHRvblwiPlxcbiAgICAgICAgPGltZyBzcmM9XCInLCBlc2NhcGUoKDU2LCAgYXNzZXRVcmwoJ21lZGlhLzF4MS5naWYnKSApKSwgJ1wiIGNsYXNzPVwic3RlcC1vdXQtYnRuIGljb24yMVwiPlxcbiAgICAgICAgJywgZXNjYXBlKCg1NywgIGkxOG4uc3RlcE91dCgpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBpZD1cInN0ZXBJbkJ1dHRvblwiIGNsYXNzPVwiZGVidWdnZXJfYnV0dG9uXCI+XFxuICAgICAgICA8aW1nIHNyYz1cIicsIGVzY2FwZSgoNjAsICBhc3NldFVybCgnbWVkaWEvMXgxLmdpZicpICkpLCAnXCIgY2xhc3M9XCJzdGVwLWluLWJ0biBpY29uMjFcIj5cXG4gICAgICAgICcsIGVzY2FwZSgoNjEsICBpMThuLnN0ZXBJbigpICkpLCAnXFxuICAgICAgPC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICAnKTs2NTsgfSA7IGJ1Zi5wdXNoKCdcXG4gICcpOzY2OyBpZiAoZGVidWdDb25zb2xlKSB7IDsgYnVmLnB1c2goJ1xcbiAgPGRpdiBpZD1cImRlYnVnLWNvbnNvbGVcIiBjbGFzcz1cImRlYnVnLWNvbnNvbGUgJywgZXNjYXBlKCg2NywgIGRlYnVnQnV0dG9ucyA/ICcnIDogJ2Z1bGwnICkpLCAnXCI+XFxuICAgIDxkaXYgaWQ9XCJkZWJ1Zy1vdXRwdXRcIiBjbGFzcz1cImRlYnVnLW91dHB1dFwiPjwvZGl2PlxcbiAgICA8c3BhbiBjbGFzcz1cImRlYnVnLWlucHV0LXByb21wdFwiPlxcbiAgICAgICZndDtcXG4gICAgPC9zcGFuPlxcbiAgICA8ZGl2IGNvbnRlbnRlZGl0YWJsZSBzcGVsbGNoZWNrPVwiZmFsc2VcIiBpZD1cImRlYnVnLWlucHV0XCIgY2xhc3M9XCJkZWJ1Zy1pbnB1dFwiPjwvZGl2PlxcbiAgPC9kaXY+XFxuICAnKTs3NDsgfSA7IGJ1Zi5wdXNoKCdcXG48L2Rpdj5cXG4nKTsgfSkoKTtcbn0gXG5yZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHJldHVybiB0KGxvY2FscywgcmVxdWlyZShcImVqc1wiKS5maWx0ZXJzKTtcbiAgfVxufSgpKTsiLCJcbi8qIVxuICogRUpTXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuICAsIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbiAgLCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWVcbiAgLCBkaXJuYW1lID0gcGF0aC5kaXJuYW1lXG4gICwgZXh0bmFtZSA9IHBhdGguZXh0bmFtZVxuICAsIGpvaW4gPSBwYXRoLmpvaW5cbiAgLCBmcyA9IHJlcXVpcmUoJ2ZzJylcbiAgLCByZWFkID0gZnMucmVhZEZpbGVTeW5jO1xuXG4vKipcbiAqIEZpbHRlcnMuXG4gKlxuICogQHR5cGUgT2JqZWN0XG4gKi9cblxudmFyIGZpbHRlcnMgPSBleHBvcnRzLmZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcblxuLyoqXG4gKiBJbnRlcm1lZGlhdGUganMgY2FjaGUuXG4gKlxuICogQHR5cGUgT2JqZWN0XG4gKi9cblxudmFyIGNhY2hlID0ge307XG5cbi8qKlxuICogQ2xlYXIgaW50ZXJtZWRpYXRlIGpzIGNhY2hlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24oKXtcbiAgY2FjaGUgPSB7fTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGZpbHRlcmVkIGNvZGUgaW50byBmdW5jdGlvbiBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZpbHRlcmVkKGpzKSB7XG4gIHJldHVybiBqcy5zdWJzdHIoMSkuc3BsaXQoJ3wnKS5yZWR1Y2UoZnVuY3Rpb24oanMsIGZpbHRlcil7XG4gICAgdmFyIHBhcnRzID0gZmlsdGVyLnNwbGl0KCc6JylcbiAgICAgICwgbmFtZSA9IHBhcnRzLnNoaWZ0KClcbiAgICAgICwgYXJncyA9IHBhcnRzLmpvaW4oJzonKSB8fCAnJztcbiAgICBpZiAoYXJncykgYXJncyA9ICcsICcgKyBhcmdzO1xuICAgIHJldHVybiAnZmlsdGVycy4nICsgbmFtZSArICcoJyArIGpzICsgYXJncyArICcpJztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlLXRocm93IHRoZSBnaXZlbiBgZXJyYCBpbiBjb250ZXh0IHRvIHRoZVxuICogYHN0cmAgb2YgZWpzLCBgZmlsZW5hbWVgLCBhbmQgYGxpbmVub2AuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lbm9cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHJldGhyb3coZXJyLCBzdHIsIGZpbGVuYW1lLCBsaW5lbm8pe1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpXG4gICAgLCBzdGFydCA9IE1hdGgubWF4KGxpbmVubyAtIDMsIDApXG4gICAgLCBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVubyArIDMpO1xuXG4gIC8vIEVycm9yIGNvbnRleHRcbiAgdmFyIGNvbnRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaSl7XG4gICAgdmFyIGN1cnIgPSBpICsgc3RhcnQgKyAxO1xuICAgIHJldHVybiAoY3VyciA9PSBsaW5lbm8gPyAnID4+ICcgOiAnICAgICcpXG4gICAgICArIGN1cnJcbiAgICAgICsgJ3wgJ1xuICAgICAgKyBsaW5lO1xuICB9KS5qb2luKCdcXG4nKTtcblxuICAvLyBBbHRlciBleGNlcHRpb24gbWVzc2FnZVxuICBlcnIucGF0aCA9IGZpbGVuYW1lO1xuICBlcnIubWVzc2FnZSA9IChmaWxlbmFtZSB8fCAnZWpzJykgKyAnOidcbiAgICArIGxpbmVubyArICdcXG4nXG4gICAgKyBjb250ZXh0ICsgJ1xcblxcbidcbiAgICArIGVyci5tZXNzYWdlO1xuICBcbiAgdGhyb3cgZXJyO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBvZiBlanMsIHJldHVybmluZyB0aGUgZnVuY3Rpb24gYm9keS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpe1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAsIG9wZW4gPSBvcHRpb25zLm9wZW4gfHwgZXhwb3J0cy5vcGVuIHx8ICc8JSdcbiAgICAsIGNsb3NlID0gb3B0aW9ucy5jbG9zZSB8fCBleHBvcnRzLmNsb3NlIHx8ICclPidcbiAgICAsIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZVxuICAgICwgY29tcGlsZURlYnVnID0gb3B0aW9ucy5jb21waWxlRGVidWcgIT09IGZhbHNlXG4gICAgLCBidWYgPSBbXTtcblxuICBidWYucHVzaCgndmFyIGJ1ZiA9IFtdOycpO1xuICBpZiAoZmFsc2UgIT09IG9wdGlvbnMuX3dpdGgpIGJ1Zi5wdXNoKCdcXG53aXRoIChsb2NhbHMgfHwge30pIHsgKGZ1bmN0aW9uKCl7ICcpO1xuICBidWYucHVzaCgnXFxuIGJ1Zi5wdXNoKFxcJycpO1xuXG4gIHZhciBsaW5lbm8gPSAxO1xuXG4gIHZhciBjb25zdW1lRU9MID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoc3RyLnNsaWNlKGksIG9wZW4ubGVuZ3RoICsgaSkgPT0gb3Blbikge1xuICAgICAgaSArPSBvcGVuLmxlbmd0aFxuICBcbiAgICAgIHZhciBwcmVmaXgsIHBvc3RmaXgsIGxpbmUgPSAoY29tcGlsZURlYnVnID8gJ19fc3RhY2subGluZW5vPScgOiAnJykgKyBsaW5lbm87XG4gICAgICBzd2l0Y2ggKHN0ci5zdWJzdHIoaSwgMSkpIHtcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgcHJlZml4ID0gXCInLCBlc2NhcGUoKFwiICsgbGluZSArICcsICc7XG4gICAgICAgICAgcG9zdGZpeCA9IFwiKSksICdcIjtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHByZWZpeCA9IFwiJywgKFwiICsgbGluZSArICcsICc7XG4gICAgICAgICAgcG9zdGZpeCA9IFwiKSwgJ1wiO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmVmaXggPSBcIicpO1wiICsgbGluZSArICc7JztcbiAgICAgICAgICBwb3N0Zml4ID0gXCI7IGJ1Zi5wdXNoKCdcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZCA9IHN0ci5pbmRleE9mKGNsb3NlLCBpKVxuICAgICAgICAsIGpzID0gc3RyLnN1YnN0cmluZyhpLCBlbmQpXG4gICAgICAgICwgc3RhcnQgPSBpXG4gICAgICAgICwgaW5jbHVkZSA9IG51bGxcbiAgICAgICAgLCBuID0gMDtcblxuICAgICAgaWYgKCctJyA9PSBqc1tqcy5sZW5ndGgtMV0pe1xuICAgICAgICBqcyA9IGpzLnN1YnN0cmluZygwLCBqcy5sZW5ndGggLSAyKTtcbiAgICAgICAgY29uc3VtZUVPTCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgwID09IGpzLnRyaW0oKS5pbmRleE9mKCdpbmNsdWRlJykpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBqcy50cmltKCkuc2xpY2UoNykudHJpbSgpO1xuICAgICAgICBpZiAoIWZpbGVuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVuYW1lIG9wdGlvbiBpcyByZXF1aXJlZCBmb3IgaW5jbHVkZXMnKTtcbiAgICAgICAgdmFyIHBhdGggPSByZXNvbHZlSW5jbHVkZShuYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgIGluY2x1ZGUgPSByZWFkKHBhdGgsICd1dGY4Jyk7XG4gICAgICAgIGluY2x1ZGUgPSBleHBvcnRzLnBhcnNlKGluY2x1ZGUsIHsgZmlsZW5hbWU6IHBhdGgsIF93aXRoOiBmYWxzZSwgb3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlLCBjb21waWxlRGVidWc6IGNvbXBpbGVEZWJ1ZyB9KTtcbiAgICAgICAgYnVmLnB1c2goXCInICsgKGZ1bmN0aW9uKCl7XCIgKyBpbmNsdWRlICsgXCJ9KSgpICsgJ1wiKTtcbiAgICAgICAganMgPSAnJztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKH4obiA9IGpzLmluZGV4T2YoXCJcXG5cIiwgbikpKSBuKyssIGxpbmVubysrO1xuICAgICAgaWYgKGpzLnN1YnN0cigwLCAxKSA9PSAnOicpIGpzID0gZmlsdGVyZWQoanMpO1xuICAgICAgaWYgKGpzKSB7XG4gICAgICAgIGlmIChqcy5sYXN0SW5kZXhPZignLy8nKSA+IGpzLmxhc3RJbmRleE9mKCdcXG4nKSkganMgKz0gJ1xcbic7XG4gICAgICAgIGJ1Zi5wdXNoKHByZWZpeCwganMsIHBvc3RmaXgpO1xuICAgICAgfVxuICAgICAgaSArPSBlbmQgLSBzdGFydCArIGNsb3NlLmxlbmd0aCAtIDE7XG5cbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoaSwgMSkgPT0gXCJcXFxcXCIpIHtcbiAgICAgIGJ1Zi5wdXNoKFwiXFxcXFxcXFxcIik7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKGksIDEpID09IFwiJ1wiKSB7XG4gICAgICBidWYucHVzaChcIlxcXFwnXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihpLCAxKSA9PSBcIlxcclwiKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoaSwgMSkgPT0gXCJcXG5cIikge1xuICAgICAgaWYgKGNvbnN1bWVFT0wpIHtcbiAgICAgICAgY29uc3VtZUVPTCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnB1c2goXCJcXFxcblwiKTtcbiAgICAgICAgbGluZW5vKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5wdXNoKHN0ci5zdWJzdHIoaSwgMSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5fd2l0aCkgYnVmLnB1c2goXCInKTsgfSkoKTtcXG59IFxcbnJldHVybiBidWYuam9pbignJyk7XCIpXG4gIGVsc2UgYnVmLnB1c2goXCInKTtcXG5yZXR1cm4gYnVmLmpvaW4oJycpO1wiKTtcblxuICByZXR1cm4gYnVmLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb21waWxlIHRoZSBnaXZlbiBgc3RyYCBvZiBlanMgaW50byBhIGBGdW5jdGlvbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgY29tcGlsZSA9IGV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZXNjYXBlID0gb3B0aW9ucy5lc2NhcGUgfHwgdXRpbHMuZXNjYXBlO1xuICBcbiAgdmFyIGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoc3RyKVxuICAgICwgY29tcGlsZURlYnVnID0gb3B0aW9ucy5jb21waWxlRGVidWcgIT09IGZhbHNlXG4gICAgLCBjbGllbnQgPSBvcHRpb25zLmNsaWVudFxuICAgICwgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lXG4gICAgICAgID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5maWxlbmFtZSlcbiAgICAgICAgOiAndW5kZWZpbmVkJztcbiAgXG4gIGlmIChjb21waWxlRGVidWcpIHtcbiAgICAvLyBBZGRzIHRoZSBmYW5jeSBzdGFjayB0cmFjZSBtZXRhIGluZm9cbiAgICBzdHIgPSBbXG4gICAgICAndmFyIF9fc3RhY2sgPSB7IGxpbmVubzogMSwgaW5wdXQ6ICcgKyBpbnB1dCArICcsIGZpbGVuYW1lOiAnICsgZmlsZW5hbWUgKyAnIH07JyxcbiAgICAgIHJldGhyb3cudG9TdHJpbmcoKSxcbiAgICAgICd0cnkgeycsXG4gICAgICBleHBvcnRzLnBhcnNlKHN0ciwgb3B0aW9ucyksXG4gICAgICAnfSBjYXRjaCAoZXJyKSB7JyxcbiAgICAgICcgIHJldGhyb3coZXJyLCBfX3N0YWNrLmlucHV0LCBfX3N0YWNrLmZpbGVuYW1lLCBfX3N0YWNrLmxpbmVubyk7JyxcbiAgICAgICd9J1xuICAgIF0uam9pbihcIlxcblwiKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBleHBvcnRzLnBhcnNlKHN0ciwgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIGlmIChvcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhzdHIpO1xuICBpZiAoY2xpZW50KSBzdHIgPSAnZXNjYXBlID0gZXNjYXBlIHx8ICcgKyBlc2NhcGUudG9TdHJpbmcoKSArICc7XFxuJyArIHN0cjtcblxuICB0cnkge1xuICAgIHZhciBmbiA9IG5ldyBGdW5jdGlvbignbG9jYWxzLCBmaWx0ZXJzLCBlc2NhcGUnLCBzdHIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoJ1N5bnRheEVycm9yJyA9PSBlcnIubmFtZSkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICA/ICcgaW4gJyArIGZpbGVuYW1lXG4gICAgICAgIDogJyB3aGlsZSBjb21waWxpbmcgZWpzJztcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKGNsaWVudCkgcmV0dXJuIGZuO1xuXG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpe1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGxvY2FscywgZmlsdGVycywgZXNjYXBlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGBzdHJgIG9mIGVqcy5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAgLSBgbG9jYWxzYCAgICAgICAgICBMb2NhbCB2YXJpYWJsZXMgb2JqZWN0XG4gKiAgIC0gYGNhY2hlYCAgICAgICAgICAgQ29tcGlsZWQgZnVuY3Rpb25zIGFyZSBjYWNoZWQsIHJlcXVpcmVzIGBmaWxlbmFtZWBcbiAqICAgLSBgZmlsZW5hbWVgICAgICAgICBVc2VkIGJ5IGBjYWNoZWAgdG8ga2V5IGNhY2hlc1xuICogICAtIGBzY29wZWAgICAgICAgICAgIEZ1bmN0aW9uIGV4ZWN1dGlvbiBjb250ZXh0XG4gKiAgIC0gYGRlYnVnYCAgICAgICAgICAgT3V0cHV0IGdlbmVyYXRlZCBmdW5jdGlvbiBib2R5XG4gKiAgIC0gYG9wZW5gICAgICAgICAgICAgT3BlbiB0YWcsIGRlZmF1bHRpbmcgdG8gXCI8JVwiXG4gKiAgIC0gYGNsb3NlYCAgICAgICAgICAgQ2xvc2luZyB0YWcsIGRlZmF1bHRpbmcgdG8gXCIlPlwiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZW5kZXIgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpe1xuICB2YXIgZm5cbiAgICAsIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgaWYgKG9wdGlvbnMuZmlsZW5hbWUpIHtcbiAgICAgIGZuID0gY2FjaGVbb3B0aW9ucy5maWxlbmFtZV0gfHwgKGNhY2hlW29wdGlvbnMuZmlsZW5hbWVdID0gY29tcGlsZShzdHIsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhY2hlXCIgb3B0aW9uIHJlcXVpcmVzIFwiZmlsZW5hbWVcIi4nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm4gPSBjb21waWxlKHN0ciwgb3B0aW9ucyk7XG4gIH1cblxuICBvcHRpb25zLl9fcHJvdG9fXyA9IG9wdGlvbnMubG9jYWxzO1xuICByZXR1cm4gZm4uY2FsbChvcHRpb25zLnNjb3BlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGFuIEVKUyBmaWxlIGF0IHRoZSBnaXZlbiBgcGF0aGAgYW5kIGNhbGxiYWNrIGBmbihlcnIsIHN0cilgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gb3B0aW9ucyBvciBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZW5kZXJGaWxlID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgZm4pe1xuICB2YXIga2V5ID0gcGF0aCArICc6c3RyaW5nJztcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucywgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucy5maWxlbmFtZSA9IHBhdGg7XG5cbiAgdmFyIHN0cjtcbiAgdHJ5IHtcbiAgICBzdHIgPSBvcHRpb25zLmNhY2hlXG4gICAgICA/IGNhY2hlW2tleV0gfHwgKGNhY2hlW2tleV0gPSByZWFkKHBhdGgsICd1dGY4JykpXG4gICAgICA6IHJlYWQocGF0aCwgJ3V0ZjgnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZm4oZXJyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm4obnVsbCwgZXhwb3J0cy5yZW5kZXIoc3RyLCBvcHRpb25zKSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgaW5jbHVkZSBgbmFtZWAgcmVsYXRpdmUgdG8gYGZpbGVuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlSW5jbHVkZShuYW1lLCBmaWxlbmFtZSkge1xuICB2YXIgcGF0aCA9IGpvaW4oZGlybmFtZShmaWxlbmFtZSksIG5hbWUpO1xuICB2YXIgZXh0ID0gZXh0bmFtZShuYW1lKTtcbiAgaWYgKCFleHQpIHBhdGggKz0gJy5lanMnO1xuICByZXR1cm4gcGF0aDtcbn1cblxuLy8gZXhwcmVzcyBzdXBwb3J0XG5cbmV4cG9ydHMuX19leHByZXNzID0gZXhwb3J0cy5yZW5kZXJGaWxlO1xuXG4vKipcbiAqIEV4cG9zZSB0byByZXF1aXJlKCkuXG4gKi9cblxuaWYgKHJlcXVpcmUuZXh0ZW5zaW9ucykge1xuICByZXF1aXJlLmV4dGVuc2lvbnNbJy5lanMnXSA9IGZ1bmN0aW9uKG1vZHVsZSwgZmlsZW5hbWUpIHtcbiAgICBzb3VyY2UgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0Zi04Jyk7XG4gICAgbW9kdWxlLl9jb21waWxlKGNvbXBpbGUoc291cmNlLCB7fSksIGZpbGVuYW1lKTtcbiAgfTtcbn0gZWxzZSBpZiAocmVxdWlyZS5yZWdpc3RlckV4dGVuc2lvbikge1xuICByZXF1aXJlLnJlZ2lzdGVyRXh0ZW5zaW9uKCcuZWpzJywgZnVuY3Rpb24oc3JjKSB7XG4gICAgcmV0dXJuIGNvbXBpbGUoc3JjLCB7fSk7XG4gIH0pO1xufVxuIiwiXG4vKiFcbiAqIEVKU1xuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogRXNjYXBlIHRoZSBnaXZlbiBzdHJpbmcgb2YgYGh0bWxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uKGh0bWwpe1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHcrOykvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xuICIsIlxuLyohXG4gKiBFSlMgLSBGaWx0ZXJzXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBGaXJzdCBlbGVtZW50IG9mIHRoZSB0YXJnZXQgYG9iamAuXG4gKi9cblxuZXhwb3J0cy5maXJzdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqWzBdO1xufTtcblxuLyoqXG4gKiBMYXN0IGVsZW1lbnQgb2YgdGhlIHRhcmdldCBgb2JqYC5cbiAqL1xuXG5leHBvcnRzLmxhc3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9ialtvYmoubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgdGFyZ2V0IGBzdHJgLlxuICovXG5cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBEb3duY2FzZSB0aGUgdGFyZ2V0IGBzdHJgLlxuICovXG5cbmV4cG9ydHMuZG93bmNhc2UgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gU3RyaW5nKHN0cikudG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSB0YXJnZXQgYHN0cmAuXG4gKi9cblxuZXhwb3J0cy51cGNhc2UgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gU3RyaW5nKHN0cikudG9VcHBlckNhc2UoKTtcbn07XG5cbi8qKlxuICogU29ydCB0aGUgdGFyZ2V0IGBvYmpgLlxuICovXG5cbmV4cG9ydHMuc29ydCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG9iaikuc29ydCgpO1xufTtcblxuLyoqXG4gKiBTb3J0IHRoZSB0YXJnZXQgYG9iamAgYnkgdGhlIGdpdmVuIGBwcm9wYCBhc2NlbmRpbmcuXG4gKi9cblxuZXhwb3J0cy5zb3J0X2J5ID0gZnVuY3Rpb24ob2JqLCBwcm9wKXtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqKS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgIGEgPSBhW3Byb3BdLCBiID0gYltwcm9wXTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2l6ZSBvciBsZW5ndGggb2YgdGhlIHRhcmdldCBgb2JqYC5cbiAqL1xuXG5leHBvcnRzLnNpemUgPSBleHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIGBhYCBhbmQgYGJgLlxuICovXG5cbmV4cG9ydHMucGx1cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gTnVtYmVyKGEpICsgTnVtYmVyKGIpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBgYmAgZnJvbSBgYWAuXG4gKi9cblxuZXhwb3J0cy5taW51cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICByZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBgYWAgYnkgYGJgLlxuICovXG5cbmV4cG9ydHMudGltZXMgPSBmdW5jdGlvbihhLCBiKXtcbiAgcmV0dXJuIE51bWJlcihhKSAqIE51bWJlcihiKTtcbn07XG5cbi8qKlxuICogRGl2aWRlIGBhYCBieSBgYmAuXG4gKi9cblxuZXhwb3J0cy5kaXZpZGVkX2J5ID0gZnVuY3Rpb24oYSwgYil7XG4gIHJldHVybiBOdW1iZXIoYSkgLyBOdW1iZXIoYik7XG59O1xuXG4vKipcbiAqIEpvaW4gYG9iamAgd2l0aCB0aGUgZ2l2ZW4gYHN0cmAuXG4gKi9cblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24ob2JqLCBzdHIpe1xuICByZXR1cm4gb2JqLmpvaW4oc3RyIHx8ICcsICcpO1xufTtcblxuLyoqXG4gKiBUcnVuY2F0ZSBgc3RyYCB0byBgbGVuYC5cbiAqL1xuXG5leHBvcnRzLnRydW5jYXRlID0gZnVuY3Rpb24oc3RyLCBsZW4pe1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbGVuKTtcbn07XG5cbi8qKlxuICogVHJ1bmNhdGUgYHN0cmAgdG8gYG5gIHdvcmRzLlxuICovXG5cbmV4cG9ydHMudHJ1bmNhdGVfd29yZHMgPSBmdW5jdGlvbihzdHIsIG4pe1xuICB2YXIgc3RyID0gU3RyaW5nKHN0cilcbiAgICAsIHdvcmRzID0gc3RyLnNwbGl0KC8gKy8pO1xuICByZXR1cm4gd29yZHMuc2xpY2UoMCwgbikuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIGBwYXR0ZXJuYCB3aXRoIGBzdWJzdGl0dXRpb25gIGluIGBzdHJgLlxuICovXG5cbmV4cG9ydHMucmVwbGFjZSA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybiwgc3Vic3RpdHV0aW9uKXtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocGF0dGVybiwgc3Vic3RpdHV0aW9uIHx8ICcnKTtcbn07XG5cbi8qKlxuICogUHJlcGVuZCBgdmFsYCB0byBgb2JqYC5cbiAqL1xuXG5leHBvcnRzLnByZXBlbmQgPSBmdW5jdGlvbihvYmosIHZhbCl7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iailcbiAgICA/IFt2YWxdLmNvbmNhdChvYmopXG4gICAgOiB2YWwgKyBvYmo7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBgdmFsYCB0byBgb2JqYC5cbiAqL1xuXG5leHBvcnRzLmFwcGVuZCA9IGZ1bmN0aW9uKG9iaiwgdmFsKXtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKVxuICAgID8gb2JqLmNvbmNhdCh2YWwpXG4gICAgOiBvYmogKyB2YWw7XG59O1xuXG4vKipcbiAqIE1hcCB0aGUgZ2l2ZW4gYHByb3BgLlxuICovXG5cbmV4cG9ydHMubWFwID0gZnVuY3Rpb24oYXJyLCBwcm9wKXtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gb2JqW3Byb3BdO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKi9cblxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKVxuICAgID8gb2JqLnJldmVyc2UoKVxuICAgIDogU3RyaW5nKG9iaikuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogR2V0IGBwcm9wYCBvZiB0aGUgZ2l2ZW4gYG9iamAuXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihvYmosIHByb3Ape1xuICByZXR1cm4gb2JqW3Byb3BdO1xufTtcblxuLyoqXG4gKiBQYWNrcyB0aGUgZ2l2ZW4gYG9iamAgaW50byBqc29uIHN0cmluZ1xuICovXG5leHBvcnRzLmpzb24gPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsbnVsbCwiLy8gU3RyaWN0IGxpbnRpbmc6IEFic29yYiBpbnRvIGdsb2JhbCBjb25maWcgd2hlbiBwb3NzaWJsZVxuLyoganNoaW50XG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcbiBtYXhsZW46IDEyMFxuICovXG5cbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnLi9jb2RlZ2VuJyk7XG52YXIgT2JzZXJ2YWJsZUV2ZW50ID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlRXZlbnQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBKU0ludGVycHJldGVyIG9iamVjdC4gVGhpcyBvYmplY3Qgd3JhcHMgYW4gSW50ZXJwcmV0ZXIgb2JqZWN0IGFuZFxuICogYWRkcyBzdGVwcGluZywgYmF0Y2hpbmcgb2Ygc3RlcHMsIGNvZGUgaGlnaGxpZ2h0aW5nLCBlcnJvciBoYW5kbGluZyxcbiAqIGJyZWFrcG9pbnRzLCBnZW5lcmFsIGRlYnVnIGNhcGFiaWxpdGllcyAoc3RlcCBpbiwgc3RlcCBvdXQsIHN0ZXAgb3ZlciksIGFuZFxuICogYW4gb3B0aW9uYWwgZXZlbnQgcXVldWUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHshU3R1ZGlvQXBwfSBvcHRpb25zLnN0dWRpb0FwcFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuc2hvdWxkUnVuQXRNYXhTcGVlZF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJbnRlcnByZXRlclN0ZXBzUGVyVGlja11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllc11cbiAqL1xudmFyIEpTSW50ZXJwcmV0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMuc3R1ZGlvQXBwID0gb3B0aW9ucy5zdHVkaW9BcHA7XG4gIHRoaXMuc2hvdWxkUnVuQXRNYXhTcGVlZCA9IG9wdGlvbnMuc2hvdWxkUnVuQXRNYXhTcGVlZCB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMubWF4SW50ZXJwcmV0ZXJTdGVwc1BlclRpY2sgPSBvcHRpb25zLm1heEludGVycHJldGVyU3RlcHNQZXJUaWNrIHx8IDEwMDAwO1xuICB0aGlzLmN1c3RvbU1hcnNoYWxHbG9iYWxQcm9wZXJ0aWVzID0gb3B0aW9ucy5jdXN0b21NYXJzaGFsR2xvYmFsUHJvcGVydGllcyB8fCB7fTtcblxuICAvLyBQdWJsaWNseS1leHBvc2VkIGV2ZW50cyB0aGF0IGFueW9uZSB3aXRoIGFjY2VzcyB0byB0aGUgSlNJbnRlcnByZXRlciBjYW5cbiAgLy8gb2JzZXJ2ZSBhbmQgcmVzcG9uZCB0by5cblxuICAvKiogQHR5cGUge09ic2VydmFibGVFdmVudH0gKi9cbiAgdGhpcy5vbk5leHRTdGVwQ2hhbmdlZCA9IG5ldyBPYnNlcnZhYmxlRXZlbnQoKTtcblxuICAvKiogQHR5cGUge09ic2VydmFibGVFdmVudH0gKi9cbiAgdGhpcy5vblBhdXNlID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIC8qKiBAdHlwZSB7T2JzZXJ2YWJsZUV2ZW50fSAqL1xuICB0aGlzLm9uRXhlY3V0aW9uRXJyb3IgPSBuZXcgT2JzZXJ2YWJsZUV2ZW50KCk7XG5cbiAgLyoqIEB0eXBlIHtPYnNlcnZhYmxlRXZlbnR9ICovXG4gIHRoaXMub25FeGVjdXRpb25XYXJuaW5nID0gbmV3IE9ic2VydmFibGVFdmVudCgpO1xuXG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gIHRoaXMueWllbGRFeGVjdXRpb24gPSBmYWxzZTtcbiAgdGhpcy5zdGFydGVkSGFuZGxpbmdFdmVudHMgPSBmYWxzZTtcbiAgdGhpcy5leGVjdXRpb25FcnJvciA9IG51bGw7XG4gIHRoaXMubmV4dFN0ZXAgPSBTdGVwVHlwZS5SVU47XG4gIHRoaXMubWF4VmFsaWRDYWxsRXhwcmVzc2lvbkRlcHRoID0gMDtcbiAgdGhpcy5leGVjdXRlTG9vcERlcHRoID0gMDtcbiAgdGhpcy5jYWxsRXhwcmVzc2lvblNlZW5BdERlcHRoID0gW107XG4gIHRoaXMuc3RvcHBlZEF0QnJlYWtwb2ludFJvd3MgPSBbXTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgSlNJbnRlcnByZXRlciwgcGFyc2luZyB0aGUgcHJvdmlkZWQgY29kZSBhbmQgcHJlcGFyaW5nIHRvXG4gKiBleGVjdXRlIGl0IG9uZSBzdGVwIGF0IGEgdGltZS5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgLSBmb3Igbm93LCBzYW1lIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshc3RyaW5nfSBvcHRpb25zLmNvZGUgLSBDb2RlIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSBpbnRlcnByZXRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJsb2Nrc10gLSBpbiBkcm9wbGV0Q29uZmlnLmJsb2NrcyBmb3JtYXQuICBJZiBhIGJsb2NrXG4gKiAgICAgICAgaGFzIGEgcGFyZW50IHByb3BlcnR5LCB3ZSB3aWxsIHBvcHVsYXRlIHRoYXQgZnVuY3Rpb24gaW50byB0aGVcbiAqICAgICAgICBpbnRlcnByZXRlciBnbG9iYWwgc2NvcGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYmxvY2tGaWx0ZXJdIC0gYW4gb2JqZWN0IHdpdGggYmxvY2stbmFtZSBrZXlzIHRoYXRcbiAqICAgICAgICBzaG91bGQgYmUgdXNlZCB0byBmaWx0ZXIgd2hpY2ggYmxvY2tzIGFyZSBwb3B1bGF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5nbG9iYWxGdW5jdGlvbnNdIC0gb2JqZWN0cyBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogICAgICAgIHBsYWNlIGluIHRoZSBpbnRlcnByZXRlciBnbG9iYWwgc2NvcGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZUV2ZW50c10gLSBhbGxvdyB0aGUgaW50ZXJwcmV0ZXIgdG8gZGVmaW5lXG4gKiAgICAgICAgZXZlbnQgaGFuZGxlcnMgdGhhdCBjYW4gYmUgaW52b2tlZCBieSBuYXRpdmUgY29kZS4gKGRlZmF1bHQgZmFsc2UpXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLnN0dWRpb0FwcC5oaWRlU291cmNlKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVDb2RlSW5mbyhvcHRpb25zLmNvZGUpO1xuXG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnN0dWRpb0FwcC5lZGl0b3IuYWNlRWRpdG9yLmdldFNlc3Npb24oKTtcbiAgICB0aGlzLmlzQnJlYWtwb2ludFJvdyA9IGNvZGVnZW4uaXNBY2VCcmVha3BvaW50Um93LmJpbmQobnVsbCwgc2Vzc2lvbik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0JyZWFrcG9pbnRSb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRXZlbnRzKSB7XG4gICAgdGhpcy5ldmVudFF1ZXVlID0gW107XG4gICAgLy8gQXBwZW5kIG91ciBtaW5pLXJ1bnRpbWUgYWZ0ZXIgdGhlIHVzZXIncyBjb2RlLiBUaGlzIHdpbGwgc3BpbiBhbmQgcHJvY2Vzc1xuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uczpcbiAgICBvcHRpb25zLmNvZGUgKz0gJ1xcbndoaWxlICh0cnVlKSB7IHZhciBvYmogPSBnZXRDYWxsYmFjaygpOyAnICtcbiAgICAgICdpZiAob2JqKSB7IHZhciByZXQgPSBvYmouZm4uYXBwbHkobnVsbCwgb2JqLmFyZ3VtZW50cyA/IG9iai5hcmd1bWVudHMgOiBudWxsKTsnICtcbiAgICAgICAgICAgICAgICAgJ3NldENhbGxiYWNrUmV0VmFsKHJldCk7IH19JztcblxuICAgIGNvZGVnZW4uY3JlYXRlTmF0aXZlRnVuY3Rpb25Gcm9tSW50ZXJwcmV0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnRGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5pbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgc2VsZi5xdWV1ZUV2ZW50KGludEZ1bmMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNlbGYuZXhlY3V0ZUxvb3BEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgaW50ZXJwcmV0ZXIgYW5kIGlmIGEgcmV0dXJuIHZhbHVlIGlzIHNlbnQgYmFjayBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJwcmV0ZXIncyBldmVudCBoYW5kbGVyLCBwYXNzIHRoYXQgYmFjayBpbiB0aGUgbmF0aXZlIHdvcmxkXG5cbiAgICAgICAgICAgIC8vIE5PVEU6IHRoZSBpbnRlcnByZXRlciB3aWxsIG5vdCBleGVjdXRlIGZvcmV2ZXIsIGlmIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAvLyB0YWtlcyB0b28gbG9uZywgZXhlY3V0ZUludGVycHJldGVyKCkgd2lsbCByZXR1cm4gYW5kIHRoZSBuYXRpdmUgc2lkZVxuICAgICAgICAgICAgLy8gd2lsbCBqdXN0IHNlZSAndW5kZWZpbmVkJyBhcyB0aGUgcmV0dXJuIHZhbHVlLiBUaGUgcmVzdCBvZiB0aGUgaW50ZXJwcmV0ZXJcbiAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZXIgd2lsbCBydW4gaW4gdGhlIG5leHQgb25UaWNrKCksIGJ1dCB0aGUgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICAgICAgICAgIC8vIG5vIGxvbmdlciBoYXZlIGFueSBlZmZlY3QuXG4gICAgICAgICAgICBzZWxmLmV4ZWN1dGVJbnRlcnByZXRlcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5sYXN0Q2FsbGJhY2tSZXRWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5pdEZ1bmMgPSBmdW5jdGlvbiAoaW50ZXJwcmV0ZXIsIHNjb3BlKSB7XG4gICAgLy8gU3RvcmUgSW50ZXJwcmV0ZXIgb24gSlNJbnRlcnByZXRlclxuICAgIHNlbGYuaW50ZXJwcmV0ZXIgPSBpbnRlcnByZXRlcjtcbiAgICAvLyBTdG9yZSBnbG9iYWxTY29wZSBvbiBKU0ludGVycHJldGVyXG4gICAgc2VsZi5nbG9iYWxTY29wZSA9IHNjb3BlO1xuICAgIC8vIE92ZXJyaWRlIEludGVycHJldGVyJ3MgZ2V0L3NldCBQcm9wZXJ0eSBmdW5jdGlvbnMgd2l0aCBKU0ludGVycHJldGVyXG4gICAgaW50ZXJwcmV0ZXIuZ2V0UHJvcGVydHkgPSBzZWxmLmdldFByb3BlcnR5LmJpbmQoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGludGVycHJldGVyLFxuICAgICAgICBpbnRlcnByZXRlci5nZXRQcm9wZXJ0eSk7XG4gICAgLy8gU3RvcmUgdGhpcyBmb3IgbGF0ZXIgYmVjYXVzZSB3ZSBuZWVkIHRvIGJ5cGFzcyBvdXIgb3ZlcnJpZGVuIGZ1bmN0aW9uXG4gICAgLy8gaW4gY3JlYXRlR2xvYmFsUHJvcGVydHkoKVxuICAgIHNlbGYuYmFzZVNldFByb3BlcnR5ID0gaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHk7XG4gICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkgPSBzZWxmLnNldFByb3BlcnR5LmJpbmQoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGludGVycHJldGVyLFxuICAgICAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eSk7XG4gICAgY29kZWdlbi5pbml0SlNJbnRlcnByZXRlcihcbiAgICAgICAgaW50ZXJwcmV0ZXIsXG4gICAgICAgIG9wdGlvbnMuYmxvY2tzLFxuICAgICAgICBvcHRpb25zLmJsb2NrRmlsdGVyLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgb3B0aW9ucy5nbG9iYWxGdW5jdGlvbnMpO1xuXG4gICAgLy8gT25seSBhbGxvdyBmaXZlIGxldmVscyBvZiBkZXB0aCB3aGVuIG1hcnNoYWxsaW5nIHRoZSByZXR1cm4gdmFsdWVcbiAgICAvLyBzaW5jZSB3ZSB3aWxsIG9jY2FzaW9uYWxseSByZXR1cm4gRE9NIEV2ZW50IG9iamVjdHMgd2hpY2ggY29udGFpblxuICAgIC8vIHByb3BlcnRpZXMgdGhhdCByZWN1cnNlIG92ZXIgYW5kIG92ZXIuLi5cbiAgICB2YXIgd3JhcHBlciA9IGNvZGVnZW4ubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKHtcbiAgICAgICAgaW50ZXJwcmV0ZXI6IGludGVycHJldGVyLFxuICAgICAgICBuYXRpdmVGdW5jOiBzZWxmLm5hdGl2ZUdldENhbGxiYWNrLmJpbmQoc2VsZiksXG4gICAgICAgIG1heERlcHRoOiA1XG4gICAgfSk7XG4gICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dldENhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlci5jcmVhdGVOYXRpdmVGdW5jdGlvbih3cmFwcGVyKSk7XG5cbiAgICB3cmFwcGVyID0gY29kZWdlbi5tYWtlTmF0aXZlTWVtYmVyRnVuY3Rpb24oe1xuICAgICAgICBpbnRlcnByZXRlcjogaW50ZXJwcmV0ZXIsXG4gICAgICAgIG5hdGl2ZUZ1bmM6IHNlbGYubmF0aXZlU2V0Q2FsbGJhY2tSZXRWYWwuYmluZChzZWxmKSxcbiAgICB9KTtcbiAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2V0Q2FsbGJhY2tSZXRWYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGVyLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uKHdyYXBwZXIpKTtcbiAgfTtcblxuICB0cnkge1xuICAgIC8vIFJldHVybiB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB0aGlzLmludGVycHJldGVyIGluc2lkZSB0aGUgc3VwcGxpZWRcbiAgICAvLyBpbml0RnVuYygpIChvdGhlciBjb2RlIGluIGluaXRGdW5jKCkgZGVwZW5kcyBvbiB0aGlzLmludGVycHJldGVyLCBzb1xuICAgIC8vIHdlIGNhbid0IHdhaXQgdW50aWwgdGhlIGNvbnN0cnVjdG9yIHJldHVybnMpXG4gICAgLyoganNoaW50IG5vbmV3OmZhbHNlICovXG4gICAgbmV3IHdpbmRvdy5JbnRlcnByZXRlcihvcHRpb25zLmNvZGUsIGluaXRGdW5jKTtcbiAgICAvKiBqc2hpbnQgbm9uZXc6dHJ1ZSAqL1xuICB9XG4gIGNhdGNoKGVycikge1xuICAgIHRoaXMuZXhlY3V0aW9uRXJyb3IgPSBlcnI7XG4gICAgdGhpcy5oYW5kbGVFcnJvcigpO1xuICB9XG5cbn07XG5cbi8qKlxuICogSW5pdCBgdGhpcy5jb2RlSW5mb2Agd2l0aCBjdW11bGF0aXZlIGxlbmd0aCBpbmZvICh1c2VkIHRvIGxvY2F0ZSBicmVha3BvaW50cykuXG4gKiBAcGFyYW0gY29kZVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5jYWxjdWxhdGVDb2RlSW5mbyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIHRoaXMuY29kZUluZm8gPSB7fTtcbiAgdGhpcy5jb2RlSW5mby51c2VyQ29kZVN0YXJ0T2Zmc2V0ID0gMDtcbiAgdGhpcy5jb2RlSW5mby51c2VyQ29kZUxlbmd0aCA9IGNvZGUubGVuZ3RoO1xuICB0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGggPSBjb2RlZ2VuLmNhbGN1bGF0ZUN1bXVsYXRpdmVMZW5ndGgoY29kZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSlNJbnRlcnByZXRlciBpbnN0YW5jZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkuIFRoaXNcbiAqIHdvdWxkIHR5cGljYWxseSBmYWlsIHdoZW4gdGhlIHByb2dyYW0gY29udGFpbnMgYSBzeW50YXggZXJyb3IuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISF0aGlzLmludGVycHJldGVyO1xufTtcblxuLyoqXG4gKiBEZXRlY2ggdGhlIEludGVycHJldGVyIGluc3RhbmNlLiBDYWxsIGJlZm9yZSByZWxlYXNpbmcgcmVmZXJlbmNlcyB0b1xuICogSlNJbnRlcnByZXRlciBzbyBhbnkgYXN5bmMgY2FsbGJhY2tzIHdpbGwgbm90IGV4ZWN1dGUuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmRlaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbnRlcnByZXRlciA9IG51bGw7XG59O1xuXG5KU0ludGVycHJldGVyLlN0ZXBUeXBlID0ge1xuICBSVU46ICAwLFxuICBJTjogICAxLFxuICBPVkVSOiAyLFxuICBPVVQ6ICAzLFxufTtcblxuLyoqXG4gKiBBIG1pbmlhdHVyZSBydW50aW1lIGluIHRoZSBpbnRlcnByZXRlZCB3b3JsZCBjYWxscyB0aGlzIGZ1bmN0aW9uIHJlcGVhdGVkbHlcbiAqIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBzaG91bGQgaW52b2tlIGFueSBjYWxsYmFja3MgZnJvbSB3aXRoaW4gdGhlXG4gKiBpbnRlcnByZXRlZCB3b3JsZC4gSWYgdGhlIGV2ZW50UXVldWUgaXMgbm90IGVtcHR5LCB3ZSB3aWxsIHJldHVybiBhbiBvYmplY3RcbiAqIHRoYXQgY29udGFpbnMgYW4gaW50ZXJwcmV0ZWQgY2FsbGJhY2sgZnVuY3Rpb24gKHN0b3JlZCBpbiBcImZuXCIpIGFuZCxcbiAqIG9wdGlvbmFsbHksIGNhbGxiYWNrIGFyZ3VtZW50cyAoc3RvcmVkIGluIFwiYXJndW1lbnRzXCIpXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLm5hdGl2ZUdldENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0YXJ0ZWRIYW5kbGluZ0V2ZW50cyA9IHRydWU7XG4gIHZhciByZXRWYWwgPSB0aGlzLmV2ZW50UXVldWUuc2hpZnQoKTtcbiAgaWYgKHR5cGVvZiByZXRWYWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aGlzLnlpZWxkKCk7XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn07XG5cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLm5hdGl2ZVNldENhbGxiYWNrUmV0VmFsID0gZnVuY3Rpb24gKHJldFZhbCkge1xuICBpZiAodGhpcy5ldmVudFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIG5vdGhpbmcgZWxzZSBpcyBpbiB0aGUgZXZlbnQgcXVldWUsIHRoZW4gc3RvcmUgdGhpcyByZXR1cm4gdmFsdWVcbiAgICAvLyBhd2F5IHNvIGl0IGNhbiBiZSByZXR1cm5lZCBpbiB0aGUgbmF0aXZlIGV2ZW50IGhhbmRsZXJcbiAgICB0aGlzLnNlZW5SZXR1cm5Gcm9tQ2FsbGJhY2tEdXJpbmdFeGVjdXRpb24gPSB0cnVlO1xuICAgIHRoaXMubGFzdENhbGxiYWNrUmV0VmFsID0gcmV0VmFsO1xuICB9XG4gIC8vIFByb3ZpZGUgd2FybmluZ3MgdG8gdGhlIHVzZXIgaWYgdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQgd2l0aCBhXG4gIC8vIG1lYW5pbmdmdWwgcmV0dXJuIHZhbHVlIHdoaWxlIHdlIGFyZSBubyBsb25nZXIgaW4gdGhlIG5hdGl2ZSBldmVudCBoYW5kbGVyXG5cbiAgLy8gVE9ETyAoY3BpcmljaCk6IENoZWNrIHRvIHNlZSBpZiB0aGUgRE9NIGV2ZW50IG9iamVjdCB3YXMgbW9kaWZpZWRcbiAgLy8gKHByZXZlbnREZWZhdWx0KCksIHN0b3BQcm9wYWdhdGlvbigpLCByZXR1cm5WYWx1ZSkgYW5kIHByb3ZpZGUgYSBzaW1pbGFyXG4gIC8vIHdhcm5pbmcgc2luY2UgdGhlc2Ugd29uJ3Qgd29yayBhcyBleHBlY3RlZCB1bmxlc3MgcnVubmluZyBhdE1heFNwZWVkXG4gIGlmICghdGhpcy5ydW5VbnRpbENhbGxiYWNrUmV0dXJuICYmXG4gICAgICB0eXBlb2YgdGhpcy5sYXN0Q2FsbGJhY2tSZXRWYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5vbkV4ZWN1dGlvbldhcm5pbmcubm90aWZ5T2JzZXJ2ZXJzKFwiRnVuY3Rpb24gcGFzc2VkIHRvIG9uRXZlbnQoKSBcIiArXG4gICAgICAgIFwiaGFzIHRha2VuIHRvbyBsb25nIC0gdGhlIHJldHVybiB2YWx1ZSB3YXMgaWdub3JlZC5cIik7XG4gICAgaWYgKCF0aGlzLnNob3VsZFJ1bkF0TWF4U3BlZWQoKSkge1xuICAgICAgdGhpcy5vbkV4ZWN1dGlvbldhcm5pbmcubm90aWZ5T2JzZXJ2ZXJzKFwiICAodHJ5IG1vdmluZyB0aGUgc3BlZWQgXCIgK1xuICAgICAgICAgIFwic2xpZGVyIHRvIGl0cyBtYXhpbXVtIHZhbHVlKVwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUXVldWUgYW4gZXZlbnQgdG8gYmUgZmlyZWQgaW4gdGhlIGludGVycHJldGVyLiBUaGUgbmF0aXZlQXJncyBhcmUgb3B0aW9uYWwuXG4gKiBUaGUgZnVuY3Rpb24gbXVzdCBiZSBhbiBpbnRlcnByZXRlciBmdW5jdGlvbiBvYmplY3QgKG5vdCBuYXRpdmUpLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5xdWV1ZUV2ZW50ID0gZnVuY3Rpb24gKGludGVycHJldGVyRnVuYywgbmF0aXZlQXJncykge1xuICB0aGlzLmV2ZW50UXVldWUucHVzaCh7XG4gICAgJ2ZuJzogaW50ZXJwcmV0ZXJGdW5jLFxuICAgICdhcmd1bWVudHMnOiBuYXRpdmVBcmdzID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobmF0aXZlQXJncykgOiBbXVxuICB9KTtcbn07XG5cbi8qKlxuICogWWllbGQgZXhlY3V0aW9uIChjYXVzZXMgZXhlY3V0ZUludGVycHJldGVyIGxvb3AgdG8gYnJlYWsgb3V0IGlmIHRoaXMgaXNcbiAqIGNhbGxlZCBieSBBUElzIGNhbGxlZCBieSBpbnRlcnByZXRlZCBjb2RlKVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS55aWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy55aWVsZEV4ZWN1dGlvbiA9IHRydWU7XG59O1xuXG5cbnZhciBTdGVwVHlwZSA9IEpTSW50ZXJwcmV0ZXIuU3RlcFR5cGU7XG5cbi8qKlxuICogU21hbGwgaGVscGVyIHRvIHN0ZXAgdGhlIGludGVycHJldGVyIHNvIHRoYXQgZXhjZXB0aW9uIGhhbmRsZXIgY2FuIGV4aXN0IG91dHNpZGVcbiAqIG9mIHRoZSBjb3JlIGV4ZWN1dGVJbnRlcnBldGVyKCkgZnVuY3Rpb24gKGltcHJvdmVzIGJyb3dzZXIgSlMgZW5naW5lIHBlcmZvcm1hbmNlKVxuICovXG5mdW5jdGlvbiBzYWZlU3RlcEludGVycHJldGVyKGpzaSkge1xuICB0cnkge1xuICAgIGpzaS5pbnRlcnByZXRlci5zdGVwKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kIGEgYnBSb3cgZnJvbSB0aGUgXCJzdG9wcGVkIGF0IGJyZWFrcG9pbnRcIiBhcnJheSBieSBtYXRjaGluZyB0aGUgc2NvcGVcbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHNjb3BlIHRvIG1hdGNoIGZyb20gdGhlIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcm93XSB0byBtYXRjaCBmcm9tIHRoZSBsaXN0IC0gaW4gYWRkaXRpb24gdG8gc2NvcGVcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZmluZFN0b3BwZWRBdEJyZWFrcG9pbnRSb3cgPSBmdW5jdGlvbiAoc2NvcGUsIHJvdykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHBlZEF0QnJlYWtwb2ludFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnBSb3cgPSB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzW2ldO1xuICAgIGlmIChicFJvdy5zY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygcm93ID09PSAndW5kZWZpbmVkJyB8fCByb3cgPT09IGJwUm93LnJvdykge1xuICAgICAgICByZXR1cm4gYnBSb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSBicFJvdyBmcm9tIHRoZSBcInN0b3BwZWQgYXQgYnJlYWtwb2ludFwiIGFycmF5IGJ5IG1hdGNoaW5nXG4gKiB0aGUgc2NvcGUuXG4gKlxuICogSWYgbm8gcm93cyBhcmUgZm91bmQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNjb3BlLCBhIG5ldyBvbmUgaXMgaW50cm9kdWNlZC5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHNjb3BlIHRvIG1hdGNoIGZyb20gdGhlIGxpc3RcbiAqIEBwYXJhbSB7IW51bWJlcn0gcm93IHRvIHJlcGxhY2UgaW4gdGhlIGxpc3QuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHdoZW4gZ2l2ZW4gYW4gaW52YWxpZCByb3cuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLnJlcGxhY2VTdG9wcGVkQXRCcmVha3BvaW50Um93Rm9yU2NvcGUgPSBmdW5jdGlvbiAoc2NvcGUsIHJvdykge1xuICBpZiAodHlwZW9mIHJvdyAhPT0gJ251bWJlcicgfHwgcm93IDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JvdyAnICsgcm93ICsgJyBpcyBub3QgYSB2YWxpZCByb3cgaW4gdXNlciBjb2RlLicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJwUm93ID0gdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93c1tpXTtcbiAgICBpZiAoYnBSb3cuc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAvLyBVcGRhdGUgcm93IG51bWJlclxuICAgICAgYnBSb3cucm93ID0gcm93O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBTY29wZSBub3QgZm91bmQsIGluc2VydCBuZXcgb2JqZWN0IGluIGFycmF5OlxuICB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzLnVuc2hpZnQoe1xuICAgIHJvdzogcm93LFxuICAgIHNjb3BlOiBzY29wZVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgYnBSb3cgZnJvbSB0aGUgXCJzdG9wcGVkIGF0IGJyZWFrcG9pbnRcIiBhcnJheSBieSBtYXRjaGluZ1xuICogdGhlIHNjb3BlLlxuICpcbiAqIERvZXMgbm90aGluZyBpZiBubyByb3dzIGFyZSBmb3VuZCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2NvcGUuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBzY29wZSB0byBtYXRjaCBmcm9tIHRoZSBsaXN0XG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLnJlbW92ZVN0b3BwZWRBdEJyZWFrcG9pbnRSb3dGb3JTY29wZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHBlZEF0QnJlYWtwb2ludFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnBSb3cgPSB0aGlzLnN0b3BwZWRBdEJyZWFrcG9pbnRSb3dzW2ldO1xuICAgIGlmIChicFJvdy5zY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXJyYXlcbiAgICAgICAgdGhpcy5zdG9wcGVkQXRCcmVha3BvaW50Um93cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvZ3JhbSBpcyBkb25lIGV4ZWN1dGluZy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHByb2dyYW0gaXMgY29tcGxldGUgKG9yIGFuIGVycm9yIGhhcyBvY2N1cnJlZCkuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmlzUHJvZ3JhbURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmV4ZWN1dGlvbkVycm9yIHx8XG4gICAgICAhdGhpcy5pbnRlcnByZXRlciB8fFxuICAgICAgIXRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFjay5sZW5ndGg7XG59O1xuXG4vKipcbiAqIE5vZGVzIHRoYXQgYXJlIHZpc2l0ZWQgYmV0d2VlbiBleHByZXNzaW9ucywgc2lnbmlmeWluZyB0aGUgcHJldmlvdXNcbiAqIGV4cHJlc3Npb24gaXMgZG9uZS5cbiAqL1xudmFyIElOVEVSU1RJVElBTF9OT0RFUyA9IHtcbiAgUHJvZ3JhbTogdHJ1ZSxcbiAgQmxvY2tTdGF0ZW1lbnQ6IHRydWUsXG4gIFN3aXRjaFN0YXRlbWVudDogdHJ1ZVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBpbnRlcnByZXRlclxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5leGVjdXRlSW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiAoZmlyc3RTdGVwLCBydW5VbnRpbENhbGxiYWNrUmV0dXJuKSB7XG4gIHRoaXMuZXhlY3V0ZUxvb3BEZXB0aCsrO1xuICB0aGlzLnJ1blVudGlsQ2FsbGJhY2tSZXR1cm4gPSBydW5VbnRpbENhbGxiYWNrUmV0dXJuO1xuICBpZiAocnVuVW50aWxDYWxsYmFja1JldHVybikge1xuICAgIGRlbGV0ZSB0aGlzLmxhc3RDYWxsYmFja1JldFZhbDtcbiAgfVxuICB0aGlzLnlpZWxkRXhlY3V0aW9uID0gZmFsc2U7XG4gIHRoaXMuc2VlblJldHVybkZyb21DYWxsYmFja0R1cmluZ0V4ZWN1dGlvbiA9IGZhbHNlO1xuXG4gIHZhciBhdEluaXRpYWxCcmVha3BvaW50ID0gdGhpcy5wYXVzZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGVwID09PSBTdGVwVHlwZS5JTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U3RlcDtcbiAgdmFyIGF0TWF4U3BlZWQgPSBmYWxzZTtcblxuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICBzd2l0Y2ggKHRoaXMubmV4dFN0ZXApIHtcbiAgICAgIGNhc2UgU3RlcFR5cGUuUlVOOlxuICAgICAgICAvLyBCYWlsIG91dCBoZXJlIGlmIGluIGEgYnJlYWsgc3RhdGUgKHBhdXNlZCksIGJ1dCBtYWtlIHN1cmUgdGhhdCB3ZSBzdGlsbFxuICAgICAgICAvLyBoYXZlIHRoZSBuZXh0IHRpY2sgcXVldWVkIGZpcnN0LCBzbyB3ZSBjYW4gcmVzdW1lIGFmdGVyIHVuLXBhdXNpbmcpOlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFN0ZXBUeXBlLk9VVDpcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IHN0ZXBPdXRUb1N0YWNrRGVwdGgsIHdvcmsgYmFja3dhcmRzIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIGhpc3Rvcnkgb2YgY2FsbEV4cHJlc3Npb25TZWVuQXREZXB0aCB1bnRpbCB3ZSBmaW5kIHRoZSBvbmUgd2Ugd2FudCB0b1xuICAgICAgICAvLyBzdGVwIG91dCB0byAtIGFuZCBzdG9yZSB0aGF0IGluIHN0ZXBPdXRUb1N0YWNrRGVwdGg6XG4gICAgICAgIGlmICh0aGlzLmludGVycHJldGVyICYmIHR5cGVvZiB0aGlzLnN0ZXBPdXRUb1N0YWNrRGVwdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5zdGVwT3V0VG9TdGFja0RlcHRoID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5tYXhWYWxpZENhbGxFeHByZXNzaW9uRGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxFeHByZXNzaW9uU2VlbkF0RGVwdGhbaV0pIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGVwT3V0VG9TdGFja0RlcHRoID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkb25lVXNlckxpbmUgPSBmYWxzZTtcbiAgdmFyIHJlYWNoZWRCcmVhayA9IGZhbHNlO1xuICB2YXIgdW53aW5kaW5nQWZ0ZXJTdGVwID0gZmFsc2U7XG4gIHZhciBpblVzZXJDb2RlO1xuICB2YXIgdXNlckNvZGVSb3c7XG5cbiAgLy8gSW4gZWFjaCB0aWNrLCB3ZSB3aWxsIHN0ZXAgdGhlIGludGVycHJldGVyIG11bHRpcGxlIHRpbWVzIGluIGEgdGlnaHRcbiAgLy8gbG9vcCBhcyBsb25nIGFzIHdlIGFyZSBpbnRlcnByZXRpbmcgY29kZSB0aGF0IHRoZSB1c2VyIGNhbid0IHNlZVxuICAvLyAoZnVuY3Rpb24gYWxpYXNlcyBhdCB0aGUgYmVnaW5uaW5nLCBnZXRDYWxsYmFjayBldmVudCBsb29wIGF0IHRoZSBlbmQpXG4gIGZvciAodmFyIHN0ZXBzVGhpc1RpY2sgPSAwO1xuICAgICAgIChzdGVwc1RoaXNUaWNrIDwgdGhpcy5tYXhJbnRlcnByZXRlclN0ZXBzUGVyVGljaykgfHwgdW53aW5kaW5nQWZ0ZXJTdGVwO1xuICAgICAgIHN0ZXBzVGhpc1RpY2srKykge1xuICAgIC8vIENoZWNrIHRoaXMgZXZlcnkgdGltZSBiZWNhdXNlIHRoZSBzcGVlZCBpcyBhbGxvd2VkIHRvIGNoYW5nZS4uLlxuICAgIGF0TWF4U3BlZWQgPSB0aGlzLnNob3VsZFJ1bkF0TWF4U3BlZWQoKTtcbiAgICAvLyBOT1RFOlxuICAgIC8vICgxKSBXaGVuIHJ1bm5pbmcgd2l0aCBubyBzb3VyY2UgdmlzaWJsZSBBTkQgYXQgbWF4IHNwZWVkLCBhbHdheXMgc2V0XG4gICAgLy8gICBgdXNlckNvZGVSb3dgIHRvIC0xLiBXZSdsbCBuZXZlciBoaXQgYSBicmVha3BvaW50IG9yIG5lZWQgdG8gYWRkIGRlbGF5LlxuICAgIC8vICgyKSBXaGVuIHJ1bm5pbmcgd2l0aCBubyBzb3VyY2UgdmlzaWJsZSBPUiBhdCBtYXggc3BlZWQsIGNhbGwgYSBzaW1wbGVcbiAgICAvLyAgIGZ1bmN0aW9uIHRvIGp1c3QgZ2V0IHRoZSBsaW5lIG51bWJlci4gTmVlZCB0byBjaGVjayBgaW5Vc2VyQ29kZWAgdG9cbiAgICAvLyAgIG1heWJlIHN0b3AgYXQgYSBicmVha3BvaW50LCBvciBhZGQgYSBgc3BlZWQobilgIGRlbGF5LlxuICAgIC8vICgzKSBPdGhlcndpc2UgY2FsbCBhIGZ1bmN0aW9uIHRoYXQgYWxzbyBoaWdobGlnaHRzIHRoZSBjb2RlLlxuICAgIHZhciBzZWxlY3RDb2RlRnVuYztcbiAgICBpZiAodGhpcy5zdHVkaW9BcHAuaGlkZVNvdXJjZSAmJiBhdE1heFNwZWVkKSB7XG4gICAgICBzZWxlY3RDb2RlRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xOyB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdHVkaW9BcHAuaGlkZVNvdXJjZSB8fCBhdE1heFNwZWVkKSB7XG4gICAgICBzZWxlY3RDb2RlRnVuYyA9IHRoaXMuZ2V0VXNlckNvZGVMaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RDb2RlRnVuYyA9IHRoaXMuc2VsZWN0Q3VycmVudENvZGU7XG4gICAgfVxuICAgIHZhciBjdXJyZW50U2NvcGUgPSB0aGlzLmludGVycHJldGVyLmdldFNjb3BlKCk7XG5cbiAgICBpZiAoKHJlYWNoZWRCcmVhayAmJiAhdW53aW5kaW5nQWZ0ZXJTdGVwKSB8fFxuICAgICAgICAoZG9uZVVzZXJMaW5lICYmICF1bndpbmRpbmdBZnRlclN0ZXAgJiYgIWF0TWF4U3BlZWQpIHx8XG4gICAgICAgIHRoaXMueWllbGRFeGVjdXRpb24gfHxcbiAgICAgICAgdGhpcy5pbnRlcnByZXRlci5wYXVzZWRfIHx8XG4gICAgICAgIChydW5VbnRpbENhbGxiYWNrUmV0dXJuICYmIHRoaXMuc2VlblJldHVybkZyb21DYWxsYmFja0R1cmluZ0V4ZWN1dGlvbikpIHtcbiAgICAgIC8vIHN0b3Agc3RlcHBpbmcgdGhlIGludGVycHJldGVyIGFuZCB3YWl0IHVudGlsIHRoZSBuZXh0IHRpY2sgb25jZSB3ZTpcbiAgICAgIC8vICgxKSByZWFjaGVkIGEgYnJlYWtwb2ludCBhbmQgYXJlIGRvbmUgdW53aW5kaW5nIE9SXG4gICAgICAvLyAoMikgY29tcGxldGVkIGEgbGluZSBvZiB1c2VyIGNvZGUgYW5kIGFyZSBhcmUgZG9uZSB1bndpbmRpbmdcbiAgICAgIC8vICAgICAod2hpbGUgbm90IHJ1bm5pbmcgYXRNYXhTcGVlZCkgT1JcbiAgICAgIC8vICgzKSB3ZSd2ZSBiZWVuIGFza2VkIHRvIHlpZWxkIG91ciBleGVjdXRlSW50ZXJwZXRlcigpIGxvb3AgT1JcbiAgICAgIC8vICg0KSB0aGUgaW50ZXJwcmV0ZXIgaXMgcGF1c2VkIChoYW5kbGluZyBhIG5hdGl2ZSBhc3luYyBmdW5jIHRoYXQgaXNcbiAgICAgIC8vICAgICBnb2luZyB0byBibG9jayB0byByZXR1cm4gYSB2YWx1ZSBzeW5jaHJvbm91c2x5IGluIHRoZSBpbnRlcnByZXRlcikgT1JcbiAgICAgIC8vICg1KSBoYXZlIHNlZW4gYW4gZW1wdHkgZXZlbnQgcXVldWUgaW4gbmF0aXZlR2V0Q2FsbGJhY2sgKG5vIGV2ZW50cykgT1JcbiAgICAgIC8vICg2KSBoYXZlIHNlZW4gYSBuYXRpdmVTZXRDYWxsYmFja1JldFZhbCBjYWxsIGluIHJ1blVudGlsQ2FsbGJhY2tSZXR1cm4gbW9kZVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHVzZXJDb2RlUm93ID0gc2VsZWN0Q29kZUZ1bmMuY2FsbCh0aGlzKTtcbiAgICBpblVzZXJDb2RlID0gKC0xICE9PSB1c2VyQ29kZVJvdyk7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFycml2ZWQgYXQgYSBuZXcgYnJlYWtwb2ludDpcbiAgICAvLyAgKDEpIHNob3VsZCBiZSBpbiB1c2VyIGNvZGVcbiAgICAvLyAgKDIpIHNob3VsZCBuZXZlciBoYXBwZW4gd2hpbGUgdW53aW5kaW5nXG4gICAgLy8gICgzKSBzaG91bGQgbmV2ZXIgaGFwcGVuIHdoZW4gcmV2aXNpdGluZyBhbiBpbnRlcnN0aXRpYWwgbm9kZVxuICAgIC8vICAoNCkgcmVxdWlyZXMgZWl0aGVyXG4gICAgLy8gICAoYSkgYXRJbml0aWFsQnJlYWtwb2ludCBPUlxuICAgIC8vICAgKGIpIGlzQWNlQnJlYWtwb2ludFJvdygpIEFORCBub3Qgc3RpbGwgYXQgdGhlIHNhbWUgbGluZSBudW1iZXIgd2hlcmVcbiAgICAvLyAgICAgICB3ZSBoYXZlIGFscmVhZHkgc3RvcHBlZCBmcm9tIHRoZSBsYXN0IHN0ZXAvYnJlYWtwb2ludFxuICAgIGlmIChpblVzZXJDb2RlICYmICF1bndpbmRpbmdBZnRlclN0ZXAgJiYgIXRoaXMuYXRJbnRlcnN0aXRpYWxOb2RlICYmXG4gICAgICAgIChhdEluaXRpYWxCcmVha3BvaW50IHx8XG4gICAgICAgICAodGhpcy5pc0JyZWFrcG9pbnRSb3codXNlckNvZGVSb3cpICYmXG4gICAgICAgICAgIXRoaXMuZmluZFN0b3BwZWRBdEJyZWFrcG9pbnRSb3coY3VycmVudFNjb3BlLCB1c2VyQ29kZVJvdykpKSkge1xuICAgICAgLy8gWWVzLCBhcnJpdmVkIGF0IGEgbmV3IGJyZWFrcG9pbnQ6XG4gICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBuZXh0U3RlcCB2YWx1ZS4gKElmIHdlIGhpdCBhIGJyZWFrcG9pbnQgZHVyaW5nIGEgc3RlcFxuICAgICAgICAvLyBvdXQgb3Igc3RlcCBvdmVyLCB0aGlzIHdpbGwgY2FuY2VsIHRoYXQgc3RlcCBvcGVyYXRpb24gZWFybHkpXG4gICAgICAgIHRoaXMubmV4dFN0ZXAgPSBTdGVwVHlwZS5SVU47XG4gICAgICAgIHRoaXMub25OZXh0U3RlcENoYW5nZWQubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uUGF1c2Uubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBzb21lIHByb3BlcnRpZXMgYWJvdXQgd2hlcmUgd2Ugc3RvcHBlZDpcbiAgICAgIHRoaXMucmVwbGFjZVN0b3BwZWRBdEJyZWFrcG9pbnRSb3dGb3JTY29wZShjdXJyZW50U2NvcGUsIHVzZXJDb2RlUm93KTtcblxuICAgICAgLy8gTWFyayByZWFjaGVkQnJlYWsgdG8gc3RvcCBzdGVwcGluZywgYW5kIHN0YXJ0IHVud2luZGluZyBpZiBuZWVkZWQ6XG4gICAgICByZWFjaGVkQnJlYWsgPSB0cnVlO1xuICAgICAgdW53aW5kaW5nQWZ0ZXJTdGVwID0gY29kZWdlbi5pc05leHRTdGVwU2FmZVdoaWxlVW53aW5kaW5nKHRoaXMuaW50ZXJwcmV0ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIElmIHdlJ3ZlIG1vdmVkIHBhc3QgdGhlIHBsYWNlIG9mIHRoZSBsYXN0IGJyZWFrcG9pbnQgaGl0IHdpdGhvdXQgYmVpbmdcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHN0YWNrLCB3ZSB3aWxsIGRpc2NhcmQgdGhlIHN0b3BwZWRBdEJyZWFrcG9pbnQgcHJvcGVydGllczpcbiAgICBpZiAoaW5Vc2VyQ29kZSAmJiAhdGhpcy5maW5kU3RvcHBlZEF0QnJlYWtwb2ludFJvdyhjdXJyZW50U2NvcGUsIHVzZXJDb2RlUm93KSkge1xuICAgICAgdGhpcy5yZW1vdmVTdG9wcGVkQXRCcmVha3BvaW50Um93Rm9yU2NvcGUoY3VycmVudFNjb3BlKTtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgdW53aW5kaW5nLCBjb250aW51ZSB0byB1cGRhdGUgdGhlIHN0b3BwZWRBdEJyZWFrcG9pbnQgcHJvcGVydGllc1xuICAgIC8vIHRvIGVuc3VyZSB0aGF0IHdlIGhhdmUgdGhlIHJpZ2h0IHByb3BlcnRpZXMgc3RvcmVkIHdoZW4gdGhlIHVud2luZCBjb21wbGV0ZXM6XG4gICAgaWYgKGluVXNlckNvZGUgJiYgdW53aW5kaW5nQWZ0ZXJTdGVwKSB7XG4gICAgICB0aGlzLnJlcGxhY2VTdG9wcGVkQXRCcmVha3BvaW50Um93Rm9yU2NvcGUoY3VycmVudFNjb3BlLCB1c2VyQ29kZVJvdyk7XG4gICAgfVxuICAgIHRoaXMuZXhlY3V0aW9uRXJyb3IgPSBzYWZlU3RlcEludGVycHJldGVyKHRoaXMpO1xuICAgIGlmICghdGhpcy5leGVjdXRpb25FcnJvciAmJiB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2subGVuZ3RoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2tbMF0sIG5vZGVUeXBlID0gc3RhdGUubm9kZS50eXBlO1xuICAgICAgdGhpcy5hdEludGVyc3RpdGlhbE5vZGUgPSBJTlRFUlNUSVRJQUxfTk9ERVMuaGFzT3duUHJvcGVydHkobm9kZVR5cGUpO1xuICAgICAgaWYgKGluVXNlckNvZGUpIHtcbiAgICAgICAgZG9uZVVzZXJMaW5lID0gZG9uZVVzZXJMaW5lIHx8IChzdGF0ZS5kb25lIHx8IHRoaXMuYXRJbnRlcnN0aXRpYWxOb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YWNrRGVwdGggPSB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2subGVuZ3RoO1xuICAgICAgLy8gUmVtZW1iZXIgdGhlIHN0YWNrIGRlcHRocyBvZiBjYWxsIGV4cHJlc3Npb25zIChzbyB3ZSBjYW4gaW1wbGVtZW50ICdzdGVwIG91dCcpXG5cbiAgICAgIC8vIFRydW5jYXRlIGFueSBoaXN0b3J5IG9mIGNhbGwgZXhwcmVzc2lvbnMgc2VlbiBkZWVwZXIgdGhhbiBvdXIgY3VycmVudCBzdGFjayBwb3NpdGlvbjpcbiAgICAgIGZvciAodmFyIGRlcHRoID0gc3RhY2tEZXB0aCArIDE7XG4gICAgICAgICAgICBkZXB0aCA8PSB0aGlzLm1heFZhbGlkQ2FsbEV4cHJlc3Npb25EZXB0aDtcbiAgICAgICAgICAgIGRlcHRoKyspIHtcbiAgICAgICAgdGhpcy5jYWxsRXhwcmVzc2lvblNlZW5BdERlcHRoW2RlcHRoXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXhWYWxpZENhbGxFeHByZXNzaW9uRGVwdGggPSBzdGFja0RlcHRoO1xuXG4gICAgICBpZiAoaW5Vc2VyQ29kZSAmJiB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2tbMF0ubm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhhdCB3ZSd2ZSBzZWVuIGEgY2FsbCBleHByZXNzaW9uIGF0IHRoaXMgZGVwdGggaW4gY2FsbEV4cHJlc3Npb25TZWVuQXREZXB0aDpcbiAgICAgICAgdGhpcy5jYWxsRXhwcmVzc2lvblNlZW5BdERlcHRoW3N0YWNrRGVwdGhdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBjYWxsIGV4cHJlc3Npb24gc3RhY2sgZGVwdGggc2VlbiB3aGlsZSBpbiB0aGlzIHN0ZXAgb3BlcmF0aW9uOlxuICAgICAgICBpZiAoaW5Vc2VyQ29kZSAmJiB0aGlzLmludGVycHJldGVyLnN0YXRlU3RhY2tbMF0ubm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmlyc3RDYWxsU3RhY2tEZXB0aFRoaXNTdGVwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5maXJzdENhbGxTdGFja0RlcHRoVGhpc1N0ZXAgPSBzdGFja0RlcHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB0aGUgc3RlcCBpbiBjYXNlLCB3ZSB3YW50IHRvIHN0b3AgdGhlIGludGVycHJldGVyIGFzIHNvb24gYXMgd2UgZW50ZXIgdGhlIGNhbGxlZTpcbiAgICAgICAgaWYgKCFkb25lVXNlckxpbmUgJiZcbiAgICAgICAgICAgIGluVXNlckNvZGUgJiZcbiAgICAgICAgICAgIHRoaXMubmV4dFN0ZXAgPT09IFN0ZXBUeXBlLklOICYmXG4gICAgICAgICAgICBzdGFja0RlcHRoID4gdGhpcy5maXJzdENhbGxTdGFja0RlcHRoVGhpc1N0ZXApIHtcbiAgICAgICAgICByZWFjaGVkQnJlYWsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFmdGVyIHRoZSBpbnRlcnByZXRlciBzYXlzIGEgbm9kZSBpcyBcImRvbmVcIiAobWVhbmluZyBpdCBpcyB0aW1lIHRvIHN0b3ApLCB3ZSB3aWxsXG4gICAgICAgIC8vIGFkdmFuY2UgYSBsaXR0bGUgZnVydGhlciB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RhdGVtZW50LiBXZSBhY2hpZXZlIHRoaXMgYnlcbiAgICAgICAgLy8gY29udGludWluZyB0byBzZXQgdW53aW5kaW5nQWZ0ZXJTdGVwIHRvIHRydWUgdG8ga2VlcCB0aGUgbG9vcCBnb2luZzpcbiAgICAgICAgaWYgKGRvbmVVc2VyTGluZSB8fCByZWFjaGVkQnJlYWspIHtcbiAgICAgICAgICB2YXIgd2FzVW53aW5kaW5nID0gdW53aW5kaW5nQWZ0ZXJTdGVwO1xuICAgICAgICAgIC8vIHN0ZXAoKSBhZGRpdGlvbmFsIHRpbWVzIGlmIHdlIGtub3cgaXQgdG8gYmUgc2FmZSB0byBnZXQgdXMgdG8gdGhlIG5leHQgc3RhdGVtZW50OlxuICAgICAgICAgIHVud2luZGluZ0FmdGVyU3RlcCA9IGNvZGVnZW4uaXNOZXh0U3RlcFNhZmVXaGlsZVVud2luZGluZyh0aGlzLmludGVycHJldGVyKTtcbiAgICAgICAgICBpZiAod2FzVW53aW5kaW5nICYmICF1bndpbmRpbmdBZnRlclN0ZXApIHtcbiAgICAgICAgICAgIC8vIGRvbmUgdW53aW5kaW5nLi4gc2VsZWN0IGNvZGUgdGhhdCBpcyBuZXh0IHRvIGV4ZWN1dGU6XG4gICAgICAgICAgICB1c2VyQ29kZVJvdyA9IHNlbGVjdENvZGVGdW5jLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpblVzZXJDb2RlID0gKC0xICE9PSB1c2VyQ29kZVJvdyk7XG4gICAgICAgICAgICBpZiAoIWluVXNlckNvZGUpIHtcbiAgICAgICAgICAgICAgLy8gbm90IGluIHVzZXIgY29kZSwgc28ga2VlcCB1bndpbmRpbmcgYWZ0ZXIgYWxsLi4uXG4gICAgICAgICAgICAgIHVud2luZGluZ0FmdGVyU3RlcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChyZWFjaGVkQnJlYWsgfHwgZG9uZVVzZXJMaW5lKSAmJiAhdW53aW5kaW5nQWZ0ZXJTdGVwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmV4dFN0ZXAgPT09IFN0ZXBUeXBlLk9VVCAmJlxuICAgICAgICAgICAgICBzdGFja0RlcHRoID4gdGhpcy5zdGVwT3V0VG9TdGFja0RlcHRoKSB7XG4gICAgICAgICAgICAvLyB0cnlpbmcgdG8gc3RlcCBvdXQsIGJ1dCB3ZSBkaWRuJ3QgZ2V0IG91dCB5ZXQuLi4gY29udGludWUgb24uXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHRTdGVwID09PSBTdGVwVHlwZS5PVkVSICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB0aGlzLmZpcnN0Q2FsbFN0YWNrRGVwdGhUaGlzU3RlcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgc3RhY2tEZXB0aCA+IHRoaXMuZmlyc3RDYWxsU3RhY2tEZXB0aFRoaXNTdGVwKSB7XG4gICAgICAgICAgICAvLyB0cnlpbmcgdG8gc3RlcCBvdmVyLCBhbmQgd2UncmUgaW4gZGVlcGVyIGluc2lkZSBhIGZ1bmN0aW9uIGNhbGwuLi4gY29udGludWUgbmV4dCBvblRpY2tcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3VyIHN0ZXAgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLCByZXNldCBuZXh0U3RlcCB0byBTdGVwVHlwZS5SVU4gdG9cbiAgICAgICAgICAgIC8vIHJldHVybiB0byBhIG5vcm1hbCAnYnJlYWsnIHN0YXRlOlxuICAgICAgICAgICAgdGhpcy5uZXh0U3RlcCA9IFN0ZXBUeXBlLlJVTjtcbiAgICAgICAgICAgIHRoaXMub25OZXh0U3RlcENoYW5nZWQubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICBpZiAoaW5Vc2VyQ29kZSkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBzb21lIHByb3BlcnRpZXMgYWJvdXQgd2hlcmUgd2Ugc3RvcHBlZDpcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3RvcHBlZEF0QnJlYWtwb2ludFJvd0ZvclNjb3BlKHRoaXMuaW50ZXJwcmV0ZXIuZ2V0U2NvcGUoKSwgdXNlckNvZGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RlcE91dFRvU3RhY2tEZXB0aDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpcnN0Q2FsbFN0YWNrRGVwdGhUaGlzU3RlcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5leGVjdXRpb25FcnJvcikge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGluVXNlckNvZGUgPyAodXNlckNvZGVSb3cgKyAxKSA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVMb29wRGVwdGgtLTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHJlYWNoZWRCcmVhayAmJiBhdE1heFNwZWVkKSB7XG4gICAgLy8gSWYgd2Ugd2VyZSBydW5uaW5nIGF0TWF4U3BlZWQgYW5kIGp1c3QgcmVhY2hlZCBhIGJyZWFrcG9pbnQsIHRoZVxuICAgIC8vIGNvZGUgbWF5IG5vdCBiZSBzZWxlY3RlZCBpbiB0aGUgZWRpdG9yLCBzbyBkbyBpdCBub3c6XG4gICAgdGhpcy5zZWxlY3RDdXJyZW50Q29kZSgpO1xuICB9XG4gIHRoaXMuZXhlY3V0ZUxvb3BEZXB0aC0tO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCB3cmFwcyBzb21lIGVycm9yIHByZXByb2Nlc3NpbmcgYmVmb3JlIHdlIG5vdGlmeSBvYnNlcnZlcnMgdGhhdFxuICogYW4gZXhlY3V0aW9uIGVycm9yIGhhcyBvY2N1cnJlZC4gT3BlcmF0ZXMgb24gdGhlIGN1cnJlbnQgZXJyb3IgdGhhdCBpc1xuICogYWxyZWFkeSBzYXZlZCBhcyB0aGlzLmV4ZWN1dGlvbkVycm9yXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lTnVtYmVyXVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChsaW5lTnVtYmVyKSB7XG4gIGlmICghbGluZU51bWJlciAmJiB0aGlzLmV4ZWN1dGlvbkVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAvLyBzeW50YXggZXJyb3JzIGNhbWUgYmVmb3JlIGV4ZWN1dGlvbiAoZHVyaW5nIHBhcnNpbmcpLCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHRoZSBwcm9wZXIgbGluZSBudW1iZXIgYnkgbG9va2luZyBhdCB0aGUgZXhjZXB0aW9uXG4gICAgbGluZU51bWJlciA9IHRoaXMuZXhlY3V0aW9uRXJyb3IubG9jLmxpbmU7XG4gICAgLy8gTm93IHNlbGVjdCB0aGlzIGxvY2F0aW9uIGluIHRoZSBlZGl0b3IsIHNpbmNlIHdlIGtub3cgd2UgZGlkbid0IGhpdFxuICAgIC8vIHRoaXMgd2hpbGUgZXhlY3V0aW5nIChpbiB3aGljaCBjYXNlLCBpdCB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBzZWxlY3RlZClcbiAgICBjb2RlZ2VuLnNlbGVjdEVkaXRvclJvd0NvbEVycm9yKFxuICAgICAgICB0aGlzLnN0dWRpb0FwcC5lZGl0b3IsXG4gICAgICAgIGxpbmVOdW1iZXIgLSAxLFxuICAgICAgICB0aGlzLmV4ZWN1dGlvbkVycm9yLmxvYy5jb2x1bW4pO1xuICB9XG5cbiAgLy8gU2VsZWN0IGNvZGUgdGhhdCBqdXN0IGV4ZWN1dGVkOlxuICB0aGlzLnNlbGVjdEN1cnJlbnRDb2RlKFwiYWNlX2Vycm9yXCIpO1xuICAvLyBHcmFiIGxpbmUgbnVtYmVyIGlmIHdlIGRvbid0IGhhdmUgb25lIGFscmVhZHk6XG4gIGlmICghbGluZU51bWJlcikge1xuICAgIGxpbmVOdW1iZXIgPSAxICsgdGhpcy5nZXROZWFyZXN0VXNlckNvZGVMaW5lKCk7XG4gIH1cblxuICB0aGlzLm9uRXhlY3V0aW9uRXJyb3Iubm90aWZ5T2JzZXJ2ZXJzKHRoaXMuZXhlY3V0aW9uRXJyb3IsIGxpbmVOdW1iZXIpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGFuIGludGVycGV0ZXIgcHJpbWl0aXZlIHZhbHVlLiBVc2VmdWwgd2hlbiBleHRlbmRpbmcgdGhlXG4gKiBpbnRlcnByZXRlciB3aXRob3V0IHJlbHlpbmcgb24gY29kZWdlbiBtYXJzaGFsbGluZyBoZWxwZXJzLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5jcmVhdGVQcmltaXRpdmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBpZiAodGhpcy5pbnRlcnByZXRlcikge1xuICAgIHJldHVybiB0aGlzLmludGVycHJldGVyLmNyZWF0ZVByaW1pdGl2ZShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcmFwcGVyIHRvIEludGVycHJldGVyJ3MgZ2V0UHJvcGVydHkgKGV4dGVuZGVkIGZvciBjdXN0b20gbWFyc2hhbGluZylcbiAqXG4gKiBGZXRjaCBhIHByb3BlcnR5IHZhbHVlIGZyb20gYSBkYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gaW50ZXJwZXRlciBJbnRlcnByZXRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBiYXNlR2V0UHJvcGVydHkgT3JpZ2luYWwgZ2V0UHJvcGVydHkoKSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIERhdGEgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBuYW1lIE5hbWUgb2YgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBQcm9wZXJ0eSB2YWx1ZSAobWF5IGJlIFVOREVGSU5FRCkuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gKFxuICAgIGludGVycHJldGVyLFxuICAgIGJhc2VHZXRQcm9wZXJ0eSxcbiAgICBvYmosXG4gICAgbmFtZSkge1xuICBuYW1lID0gbmFtZS50b1N0cmluZygpO1xuICB2YXIgbmF0aXZlUGFyZW50O1xuICBpZiAob2JqLmlzQ3VzdG9tTWFyc2hhbCB8fFxuICAgICAgKG9iaiA9PT0gdGhpcy5nbG9iYWxTY29wZSAmJlxuICAgICAgICAgICghIShuYXRpdmVQYXJlbnQgPSB0aGlzLmN1c3RvbU1hcnNoYWxHbG9iYWxQcm9wZXJ0aWVzW25hbWVdKSkpKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChvYmouaXNDdXN0b21NYXJzaGFsKSB7XG4gICAgICB2YWx1ZSA9IG9iai5kYXRhW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IG5hdGl2ZVBhcmVudFtuYW1lXTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJyB8fCB0eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludGVycHJldGVyLmNyZWF0ZVByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb2RlZ2VuLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKGludGVycHJldGVyLCB2YWx1ZSwgb2JqLmRhdGEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZUdldFByb3BlcnR5LmNhbGwoaW50ZXJwcmV0ZXIsIG9iaiwgbmFtZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JhcHBlciB0byBJbnRlcnByZXRlcidzIHNldFByb3BlcnR5IChleHRlbmRlZCBmb3IgY3VzdG9tIG1hcnNoYWxpbmcpXG4gKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBkYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gaW50ZXJwZXRlciBJbnRlcnByZXRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBiYXNlU2V0UHJvcGVydHkgT3JpZ2luYWwgc2V0UHJvcGVydHkoKSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIERhdGEgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBuYW1lIE5hbWUgb2YgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2ZpeGVkIFVuY2hhbmdlYWJsZSBwcm9wZXJ0eSBpZiB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRfbm9uZW51bSBOb24tZW51bWVyYWJsZSBwcm9wZXJ0eSBpZiB0cnVlLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKFxuICAgIGludGVycHJldGVyLFxuICAgIGJhc2VTZXRQcm9wZXJ0eSxcbiAgICBvYmosXG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICBvcHRfZml4ZWQsXG4gICAgb3B0X25vbmVudW0pIHtcbiAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgdmFyIG5hdGl2ZVBhcmVudDtcbiAgaWYgKG9iai5pc0N1c3RvbU1hcnNoYWwpIHtcbiAgICBvYmouZGF0YVtuYW1lXSA9IGNvZGVnZW4ubWFyc2hhbEludGVycHJldGVyVG9OYXRpdmUoaW50ZXJwcmV0ZXIsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChvYmogPT09IHRoaXMuZ2xvYmFsU2NvcGUgJiZcbiAgICAgICghIShuYXRpdmVQYXJlbnQgPSB0aGlzLmN1c3RvbU1hcnNoYWxHbG9iYWxQcm9wZXJ0aWVzW25hbWVdKSkpIHtcbiAgICBuYXRpdmVQYXJlbnRbbmFtZV0gPSBjb2RlZ2VuLm1hcnNoYWxJbnRlcnByZXRlclRvTmF0aXZlKGludGVycHJldGVyLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2VTZXRQcm9wZXJ0eS5jYWxsKFxuICAgICAgICBpbnRlcnByZXRlciwgb2JqLCBuYW1lLCB2YWx1ZSwgb3B0X2ZpeGVkLCBvcHRfbm9uZW51bSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VsZWN0cyBjb2RlIGluIGRyb3BsZXQvYWNlIGVkaXRvci5cbiAqXG4gKiBSZXR1cm5zIHRoZSByb3cgKGxpbmUpIG9mIGNvZGUgaGlnaGxpZ2h0ZWQuIElmIG5vdGhpbmcgaXMgaGlnaGxpZ2h0ZWRcbiAqIGJlY2F1c2UgaXQgaXMgb3V0c2lkZSBvZiB0aGUgdXNlckNvZGUgYXJlYSwgdGhlIHJldHVybiB2YWx1ZSBpcyAtMVxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5zZWxlY3RDdXJyZW50Q29kZSA9IGZ1bmN0aW9uIChoaWdobGlnaHRDbGFzcykge1xuICBpZiAodGhpcy5zdHVkaW9BcHAuaGlkZVNvdXJjZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gY29kZWdlbi5zZWxlY3RDdXJyZW50Q29kZSh0aGlzLmludGVycHJldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZUluZm8udXNlckNvZGVTdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlSW5mby51c2VyQ29kZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHVkaW9BcHAuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRDbGFzcyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjdXJyZW50IGxpbmUgb2YgY29kZSBpbiBkcm9wbGV0L2FjZSBlZGl0b3IuXG4gKlxuICogUmV0dXJucyB0aGUgbGluZSBvZiBjb2RlIHdoZXJlIHRoZSBpbnRlcnByZXRlciBpcyBhdC4gSWYgaXQgaXMgb3V0c2lkZVxuICogb2YgdGhlIHVzZXJDb2RlIGFyZWEsIHRoZSByZXR1cm4gdmFsdWUgaXMgLTFcbiAqL1xuSlNJbnRlcnByZXRlci5wcm90b3R5cGUuZ2V0VXNlckNvZGVMaW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXNlckNvZGVSb3cgPSAtMTtcbiAgaWYgKHRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFja1swXSkge1xuICAgIHZhciBub2RlID0gdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdLm5vZGU7XG4gICAgLy8gQWRqdXN0IHN0YXJ0L2VuZCBieSB1c2VyQ29kZVN0YXJ0T2Zmc2V0IHNpbmNlIHRoZSBjb2RlIHJ1bm5pbmdcbiAgICAvLyBoYXMgYmVlbiBleHBhbmRlZCB2cy4gd2hhdCB0aGUgdXNlciBzZWVzIGluIHRoZSBlZGl0b3Igd2luZG93OlxuICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQgLSB0aGlzLmNvZGVJbmZvLnVzZXJDb2RlU3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBPbmx5IHJldHVybiBhIHZhbGlkIHVzZXJDb2RlUm93IGlmIHRoZSBub2RlIGJlaW5nIGV4ZWN1dGVkIGlzIGluc2lkZSB0aGVcbiAgICAvLyB1c2VyJ3MgY29kZSAobm90IGluc2lkZSBjb2RlIHdlIGluc2VydGVkIGJlZm9yZSBvciBhZnRlciB0aGVpciBjb2RlIHRoYXRcbiAgICAvLyBpcyBub3QgdmlzaWJsZSBpbiB0aGUgZWRpdG9yKTpcbiAgICBpZiAoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuY29kZUluZm8udXNlckNvZGVMZW5ndGgpIHtcbiAgICAgIHVzZXJDb2RlUm93ID0gY29kZWdlbi5hY2VGaW5kUm93KHRoaXMuY29kZUluZm8uY3VtdWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGgubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXNlckNvZGVSb3c7XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjdXJyZW50IGxpbmUgb2YgY29kZSBpbiBkcm9wbGV0L2FjZSBlZGl0b3IuIFdhbGtzIHVwIHRoZSBzdGFjayBpZlxuICogbm90IGN1cnJlbnRseSBpbiB0aGUgdXNlciBjb2RlIGFyZWEuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldE5lYXJlc3RVc2VyQ29kZUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN0dWRpb0FwcC5oaWRlU291cmNlKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciB1c2VyQ29kZVJvdyA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFjay5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdGhpcy5pbnRlcnByZXRlci5zdGF0ZVN0YWNrW2ldLm5vZGU7XG4gICAgLy8gQWRqdXN0IHN0YXJ0L2VuZCBieSB1c2VyQ29kZVN0YXJ0T2Zmc2V0IHNpbmNlIHRoZSBjb2RlIHJ1bm5pbmdcbiAgICAvLyBoYXMgYmVlbiBleHBhbmRlZCB2cy4gd2hhdCB0aGUgdXNlciBzZWVzIGluIHRoZSBlZGl0b3Igd2luZG93OlxuICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQgLSB0aGlzLmNvZGVJbmZvLnVzZXJDb2RlU3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBPbmx5IHJldHVybiBhIHZhbGlkIHVzZXJDb2RlUm93IGlmIHRoZSBub2RlIGJlaW5nIGV4ZWN1dGVkIGlzIGluc2lkZSB0aGVcbiAgICAvLyB1c2VyJ3MgY29kZSAobm90IGluc2lkZSBjb2RlIHdlIGluc2VydGVkIGJlZm9yZSBvciBhZnRlciB0aGVpciBjb2RlIHRoYXRcbiAgICAvLyBpcyBub3QgdmlzaWJsZSBpbiB0aGUgZWRpdG9yKTpcbiAgICBpZiAoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuY29kZUluZm8udXNlckNvZGVMZW5ndGgpIHtcbiAgICAgIHVzZXJDb2RlUm93ID0gY29kZWdlbi5hY2VGaW5kUm93KHRoaXMuY29kZUluZm8uY3VtdWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGVJbmZvLmN1bXVsYXRpdmVMZW5ndGgubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB1c2VyQ29kZVJvdztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3BlcnR5IGluIHRoZSBpbnRlcnByZXRlcidzIGdsb2JhbCBzY29wZS4gV2hlbiBhIHBhcmVudCBpc1xuICogc3VwcGxpZWQgYW5kIHRoYXQgcGFyZW50IG9iamVjdCBpcyBpbiBjb2RlZ2VuJ3MgY3VzdG9tTWFyc2hhbE9iamVjdExpc3QsXG4gKiBwcm9wZXJ0eSBnZXRzL3NldHMgaW4gdGhlIGludGVycHJldGVyIHdpbGwgYmUgcmVmbGVjdGVkIG9uIHRoZSBuYXRpdmUgcGFyZW50XG4gKiBvYmplY3QuIEZ1bmN0aW9ucyBjYW4gYWxzbyBiZSBpbnNlcnRlZCBpbnRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlIHVzaW5nIHRoaXNcbiAqIG1ldGhvZC4gSWYgYSBwYXJlbnQgaXMgc3VwcGxpZWQsIHRoZXkgd2lsbCBiZSBpbnZva2VkIG5hdGl2ZWx5IHdpdGggdGhhdFxuICogcGFyZW50IGFzIHRoZSB0aGlzIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIGZvciB0aGUgcHJvcGVydHkgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgTmF0aXZlIHZhbHVlIHRoYXQgd2lsbCBiZSBtYXJzaGFsbGVkIHRvIHRoZSBpbnRlcnByZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgKE9wdGlvbmFsKSBwYXJlbnQgZm9yIHRoZSBuYXRpdmUgdmFsdWUuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNyZWF0ZUdsb2JhbFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwYXJlbnQpIHtcblxuICB2YXIgaW50ZXJwcmV0ZXJWYWw7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgd3JhcHBlciA9IGNvZGVnZW4ubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKHtcbiAgICAgICAgaW50ZXJwcmV0ZXI6IHRoaXMuaW50ZXJwcmV0ZXIsXG4gICAgICAgIG5hdGl2ZUZ1bmM6IHZhbHVlLFxuICAgICAgICBuYXRpdmVQYXJlbnRPYmo6IHBhcmVudFxuICAgIH0pO1xuICAgIGludGVycHJldGVyVmFsID0gdGhpcy5pbnRlcnByZXRlci5jcmVhdGVOYXRpdmVGdW5jdGlvbih3cmFwcGVyKTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcnByZXRlclZhbCA9IGNvZGVnZW4ubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIoXG4gICAgICAgIHRoaXMuaW50ZXJwcmV0ZXIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB1dGlscy52YWx1ZU9yKHBhcmVudCwgd2luZG93KSk7XG4gIH1cblxuICAvLyBCeXBhc3Mgc2V0UHJvcGVydHkgc2luY2Ugd2UndmUgaG9va2VkIGl0IGFuZCBpdCB3aWxsIG5vdCBjcmVhdGUgdGhlXG4gIC8vIHByb3BlcnR5IGlmIGl0IGlzIGluIGN1c3RvbU1hcnNoYWxHbG9iYWxQcm9wZXJ0aWVzXG4gIHRoaXMuYmFzZVNldFByb3BlcnR5LmNhbGwoXG4gICAgICB0aGlzLmludGVycHJldGVyLFxuICAgICAgdGhpcy5nbG9iYWxTY29wZSxcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcnByZXRlclZhbCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludGVycHJldGVyIGZ1bmN0aW9uIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvICdmdW5jTmFtZScgaWYgYVxuICogZnVuY3Rpb24gd2l0aCB0aGF0IG5hbWUgaXMgZm91bmQgaW4gdGhlIGludGVycHJldGVyJ3MgZ2xvYmFsIHNjb3BlLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5maW5kR2xvYmFsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuY05hbWUpIHtcbiAgdmFyIGZ1bmNPYmogPSB0aGlzLmludGVycHJldGVyLmdldFByb3BlcnR5KHRoaXMuZ2xvYmFsU2NvcGUsIGZ1bmNOYW1lKTtcbiAgaWYgKGZ1bmNPYmoudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jT2JqO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIG9mIHRoZSBnbG9iYWwgZnVuY3Rpb25zXG4gKiBpbiB0aGUgaW50ZXJwcmV0ZXIncyBnbG9iYWwgc2NvcGUuIEJ1aWx0LWluIGdsb2JhbCBmdW5jdGlvbnMgYXJlIGV4Y2x1ZGVkLlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5nZXRHbG9iYWxGdW5jdGlvbk5hbWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnVpbHRJbkV4Y2x1c2lvbkxpc3QgPSBbIFwiZXZhbFwiLCBcImdldENhbGxiYWNrXCIsIFwic2V0Q2FsbGJhY2tSZXRWYWxcIiBdO1xuXG4gIHZhciBuYW1lcyA9IFtdO1xuICBmb3IgKHZhciBvYmpOYW1lIGluIHRoaXMuZ2xvYmFsU2NvcGUucHJvcGVydGllcykge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLmdsb2JhbFNjb3BlLnByb3BlcnRpZXNbb2JqTmFtZV07XG4gICAgaWYgKG9iamVjdC50eXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICFvYmplY3QubmF0aXZlRnVuYyAmJlxuICAgICAgICBidWlsdEluRXhjbHVzaW9uTGlzdC5pbmRleE9mKG9iak5hbWUpID09PSAtMSkge1xuICAgICAgbmFtZXMucHVzaChvYmpOYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBvZiB0aGUgZnVuY3Rpb25zIGRlZmluZWRcbiAqIGluc2lkZSBvdGhlciBmdW5jdGlvbnMuXG4gKi9cbkpTSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldExvY2FsRnVuY3Rpb25OYW1lcyA9IGZ1bmN0aW9uIChzY29wZSkge1xuICBpZiAoIXNjb3BlKSB7XG4gICAgc2NvcGUgPSB0aGlzLmdsb2JhbFNjb3BlO1xuICB9XG4gIHZhciBuYW1lcyA9IFtdO1xuICBmb3IgKHZhciBvYmpOYW1lIGluIHNjb3BlLnByb3BlcnRpZXMpIHtcbiAgICB2YXIgb2JqZWN0ID0gc2NvcGUucHJvcGVydGllc1tvYmpOYW1lXTtcbiAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdmdW5jdGlvbicgJiYgIW9iamVjdC5uYXRpdmVGdW5jICYmIG9iamVjdC5ub2RlKSB7XG4gICAgICBpZiAoc2NvcGUgIT09IHRoaXMuZ2xvYmFsU2NvcGUpIHtcbiAgICAgICAgbmFtZXMucHVzaChvYmpOYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhbFNjb3BlID0gdGhpcy5pbnRlcnByZXRlci5jcmVhdGVTY29wZShvYmplY3Qubm9kZS5ib2R5LCBvYmplY3QucGFyZW50U2NvcGUpO1xuICAgICAgdmFyIGxvY2FsTmFtZXMgPSB0aGlzLmdldExvY2FsRnVuY3Rpb25OYW1lcyhsb2NhbFNjb3BlKTtcbiAgICAgIG5hbWVzID0gbmFtZXMuY29uY2F0KGxvY2FsTmFtZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgaW50ZXJwcmV0ZXIgc3RhdGUgb2JqZWN0LlxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5nZXRDdXJyZW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmludGVycHJldGVyICYmIHRoaXMuaW50ZXJwcmV0ZXIuc3RhdGVTdGFja1swXTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBpbiB0aGUgaW50ZXJwcmV0ZXIncyBjdXJyZW50IHNjb3BlLCBhbmQgcmV0dXJuIHRoZVxuICogdmFsdWUgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7P30gdmFsdWUgb2YgdGhlIGV4cHJlc3Npb25cbiAqIEB0aHJvd3MgaWYgdGhlcmUncyBhIHByb2JsZW0gZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvblxuICovXG5KU0ludGVycHJldGVyLnByb3RvdHlwZS5ldmFsSW5DdXJyZW50U2NvcGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICB2YXIgY3VycmVudFNjb3BlID0gdGhpcy5pbnRlcnByZXRlci5nZXRTY29wZSgpO1xuICB2YXIgZXZhbEludGVycHJldGVyID0gbmV3IHdpbmRvdy5JbnRlcnByZXRlcihleHByZXNzaW9uKTtcbiAgLy8gU2V0IHNjb3BlIHRvIHRoZSBjdXJyZW50IHNjb3BlIG9mIHRoZSBydW5uaW5nIHByb2dyYW1cbiAgLy8gTk9URTogd2UgYXJlIGJlaW5nIGEgbGl0dGxlIHRyaWNreSBoZXJlICh3ZSBhcmUgcmUtcnVubmluZ1xuICAvLyBwYXJ0IG9mIHRoZSBJbnRlcnByZXRlciBjb25zdHJ1Y3RvciB3aXRoIGEgZGlmZmVyZW50IGludGVycHJldGVyJ3NcbiAgLy8gc2NvcGUpXG4gIGV2YWxJbnRlcnByZXRlci5wb3B1bGF0ZVNjb3BlXyhldmFsSW50ZXJwcmV0ZXIuYXN0LCBjdXJyZW50U2NvcGUpO1xuICBldmFsSW50ZXJwcmV0ZXIuc3RhdGVTdGFjayA9IFt7XG4gICAgbm9kZTogZXZhbEludGVycHJldGVyLmFzdCxcbiAgICBzY29wZTogY3VycmVudFNjb3BlLFxuICAgIHRoaXNFeHByZXNzaW9uOiBjdXJyZW50U2NvcGVcbiAgfV07XG4gIC8vIENvcHkgdGhlc2UgcHJvcGVydGllcyBkaXJlY3RseSBpbnRvIHRoZSBldmFsSW50ZXJwcmV0ZXIgc28gdGhlIC5pc2EoKVxuICAvLyBtZXRob2QgYmVoYXZlcyBhcyBleHBlY3RlZFxuICBbJ0FSUkFZJywgJ0JPT0xFQU4nLCAnREFURScsICdGVU5DVElPTicsICdOVU1CRVInLCAnT0JKRUNUJywgJ1NUUklORycsXG4gICAgJ1VOREVGSU5FRCddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBldmFsSW50ZXJwcmV0ZXJbcHJvcF0gPSB0aGlzLmludGVycHJldGVyW3Byb3BdO1xuICB9LCB0aGlzKTtcblxuICAvLyBQYXRjaCBnZXRQcm9wZXJ0eSBhbmQgc2V0UHJvcGVydHkgdG8gZW5hYmxlIGN1c3RvbSBtYXJzaGFsbGluZ1xuICBldmFsSW50ZXJwcmV0ZXIuZ2V0UHJvcGVydHkgPSB0aGlzLmdldFByb3BlcnR5LmJpbmQoXG4gICAgICB0aGlzLFxuICAgICAgZXZhbEludGVycHJldGVyLFxuICAgICAgZXZhbEludGVycHJldGVyLmdldFByb3BlcnR5KTtcbiAgZXZhbEludGVycHJldGVyLnNldFByb3BlcnR5ID0gdGhpcy5zZXRQcm9wZXJ0eS5iaW5kKFxuICAgICAgdGhpcyxcbiAgICAgIGV2YWxJbnRlcnByZXRlcixcbiAgICAgIGV2YWxJbnRlcnByZXRlci5zZXRQcm9wZXJ0eSk7XG5cbiAgLy8gcnVuKCkgbWF5IHRocm93IGlmIHRoZXJlJ3MgYSBwcm9ibGVtIGluIHRoZSBleHByZXNzaW9uXG4gIGV2YWxJbnRlcnByZXRlci5ydW4oKTtcbiAgcmV0dXJuIGV2YWxJbnRlcnByZXRlci52YWx1ZTtcbn07XG4iLCIvKiBnbG9iYWwgSW50ZXJwcmV0ZXIsIENhbnZhc1BpeGVsQXJyYXksIGFjZSAqL1xuXG52YXIgZHJvcGxldFV0aWxzID0gcmVxdWlyZSgnLi9kcm9wbGV0VXRpbHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFdmFsdWF0ZXMgYSBzdHJpbmcgb2YgY29kZSBwYXJhbWV0ZXJpemVkIHdpdGggYSBkaWN0aW9uYXJ5LlxuICovXG5leHBvcnRzLmV2YWxXaXRoID0gZnVuY3Rpb24oY29kZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5TdHVkaW9BcHAgJiYgb3B0aW9ucy5TdHVkaW9BcHAuZWRpdENvZGUpIHtcbiAgICAvLyBVc2UgSlMgaW50ZXJwcmV0ZXIgb24gZWRpdENvZGUgbGV2ZWxzXG4gICAgdmFyIGluaXRGdW5jID0gZnVuY3Rpb24oaW50ZXJwcmV0ZXIsIHNjb3BlKSB7XG4gICAgICBleHBvcnRzLmluaXRKU0ludGVycHJldGVyKGludGVycHJldGVyLCBudWxsLCBudWxsLCBzY29wZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICB2YXIgbXlJbnRlcnByZXRlciA9IG5ldyBJbnRlcnByZXRlcihjb2RlLCBpbml0RnVuYyk7XG4gICAgLy8gaW50ZXJwcmV0IHRoZSBKUyBwcm9ncmFtIGFsbCBhdCBvbmNlOlxuICAgIG15SW50ZXJwcmV0ZXIucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhlY3V0ZSBKUyBjb2RlIFwibmF0aXZlbHlcIlxuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgcGFyYW1zLnB1c2goayk7XG4gICAgICBhcmdzLnB1c2gob3B0aW9uc1trXSk7XG4gICAgfVxuICAgIHBhcmFtcy5wdXNoKGNvZGUpO1xuICAgIHZhciBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIGN0b3IucHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgY3RvcigpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBiYXNlZCBvbiBhIHN0cmluZyBvZiBjb2RlIHBhcmFtZXRlcml6ZWQgd2l0aCBhIGRpY3Rpb25hcnkuXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuU3R1ZGlvQXBwICYmIG9wdGlvbnMuU3R1ZGlvQXBwLmVkaXRDb2RlKSB7XG4gICAgLy8gU2luY2UgdGhpcyByZXR1cm5zIGEgbmV3IG5hdGl2ZSBmdW5jdGlvbiwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIGluIHRoZVxuICAgIC8vIGVkaXRDb2RlIGNhc2UgKHdlIGFzc3VtZSB0aGF0IHRoZSBhcHAgd2lsbCBiZSB1c2luZyBKU0ludGVycHJldGVyKVxuICAgIHRocm93IFwiVW5leHBlY3RlZFwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgcGFyYW1zLnB1c2goayk7XG4gICAgICBhcmdzLnB1c2gob3B0aW9uc1trXSk7XG4gICAgfVxuICAgIHBhcmFtcy5wdXNoKGNvZGUpO1xuICAgIHZhciBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICB9O1xuICAgIGN0b3IucHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgY3RvcigpO1xuICB9XG59O1xuXG4vL1xuLy8gQmxvY2tseSBzcGVjaWZpYyBjb2RlZ2VuIGZ1bmN0aW9uczpcbi8vXG5cbnZhciBJTkZJTklURV9MT09QX1RSQVAgPSAnICBleGVjdXRpb25JbmZvLmNoZWNrVGltZW91dCgpOyBpZiAoZXhlY3V0aW9uSW5mby5pc1Rlcm1pbmF0ZWQoKSl7cmV0dXJuO31cXG4nO1xuXG52YXIgTE9PUF9ISUdITElHSFQgPSAnbG9vcEhpZ2hsaWdodCgpO1xcbic7XG52YXIgTE9PUF9ISUdITElHSFRfUkUgPVxuICAgIG5ldyBSZWdFeHAoTE9PUF9ISUdITElHSFQucmVwbGFjZSgvXFwoLipcXCkvLCAnXFxcXCguKlxcXFwpJyksICdnJyk7XG5cbi8qKlxuICogUmV0dXJucyBqYXZhc2NyaXB0IGNvZGUgdG8gY2FsbCBhIHRpbWVvdXQgY2hlY2tcbiAqL1xuZXhwb3J0cy5sb29wVHJhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSU5GSU5JVEVfTE9PUF9UUkFQO1xufTtcblxuZXhwb3J0cy5sb29wSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGFwaU5hbWUsIGJsb2NrSWQpIHtcbiAgdmFyIGFyZ3MgPSBcIidibG9ja19pZF9cIiArIGJsb2NrSWQgKyBcIidcIjtcbiAgaWYgKGJsb2NrSWQgPT09IHVuZGVmaW5lZCkge1xuICAgIGFyZ3MgPSBcIiUxXCI7XG4gIH1cbiAgcmV0dXJuIGFwaU5hbWUgKyAnLicgKyBMT09QX0hJR0hMSUdIVC5yZXBsYWNlKCcoKScsICcoJyArIGFyZ3MgKyAnKScpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IHRoZSB1c2VyJ3MgY29kZSBhcyByYXcgSmF2YVNjcmlwdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIEdlbmVyYXRlZCBjb2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29kZSB3aXRob3V0IHNlcmlhbCBudW1iZXJzIGFuZCB0aW1lb3V0IGNoZWNrcy5cbiAqL1xuZXhwb3J0cy5zdHJpcCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlXG4gICAgLy8gU3RyaXAgb3V0IHNlcmlhbCBudW1iZXJzLlxuICAgIC5yZXBsYWNlKC8oLFxccyopPydibG9ja19pZF9cXGQrJ1xcKS9nLCAnKScpXG4gICAgLy8gUmVtb3ZlIHRpbWVvdXRzLlxuICAgIC5yZXBsYWNlKElORklOSVRFX0xPT1BfVFJBUCwgJycpXG4gICAgLy8gU3RyaXAgb3V0IGxvb3AgaGlnaGxpZ2h0XG4gICAgLnJlcGxhY2UoTE9PUF9ISUdITElHSFRfUkUsICcnKVxuICAgIC8vIFN0cmlwIG91dCBjbGFzcyBuYW1lc3BhY2VzLlxuICAgIC5yZXBsYWNlKC8oU3R1ZGlvQXBwfE1hemV8VHVydGxlKVxcLi9nLCAnJylcbiAgICAvLyBTdHJpcCBvdXQgcGFydGljdWxhciBoZWxwZXIgZnVuY3Rpb25zLlxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24gKGNvbG91cl9yYW5kb20pW1xcc1xcU10qP159L2dtLCAnJylcbiAgICAvLyBDb2xsYXBzZSBjb25zZWN1dGl2ZSBibGFuayBsaW5lcy5cbiAgICAucmVwbGFjZSgvXFxuXFxuKy9nbSwgJ1xcblxcbicpXG4gICAgLy8gVHJpbS5cbiAgICAucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gICk7XG59O1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHVzZXIncyBjb2RlIGFzIHJhdyBKYXZhU2NyaXB0LlxuICovXG5leHBvcnRzLndvcmtzcGFjZUNvZGUgPSBmdW5jdGlvbihibG9ja2x5KSB7XG4gIHZhciBjb2RlID0gYmxvY2tseS5HZW5lcmF0b3IuYmxvY2tTcGFjZVRvQ29kZSgnSmF2YVNjcmlwdCcsIG51bGwsIGZhbHNlKTtcbiAgcmV0dXJuIGV4cG9ydHMuc3RyaXAoY29kZSk7XG59O1xuXG4vL1xuLy8gUHJvcGVydHkgYWNjZXNzIHdyYXBwZWQgaW4gdHJ5L2NhdGNoLiBUaGlzIGlzIGluIGFuIGluZGVwZWRlbmRlbnQgZnVuY3Rpb25cbi8vIHNvIHRoZSBKSVQgY29tcGlsZXIgY2FuIG9wdGltaXplIHRoZSBjYWxsaW5nIGZ1bmN0aW9uLlxuLy9cblxuZnVuY3Rpb24gc2FmZVJlYWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vL1xuLy8gTWFyc2hhbCBhIHNpbmdsZSBuYXRpdmUgb2JqZWN0IGZyb20gbmF0aXZlIHRvIGludGVycHJldGVyLiBUaGlzIGlzIGluIGFuXG4vLyBpbmRlcGVkZW5kZW50IGZ1bmN0aW9uIHNvIHRoZSBKSVQgY29tcGlsZXIgY2FuIG9wdGltaXplIHRoZSBjYWxsaW5nIGZ1bmN0aW9uLlxuLy8gKENocm9tZSBWOCBzYXlzIEZvckluU3RhdGVtZW50IGlzIG5vdCBmYXN0IGNhc2UpXG4vL1xuXG4vKipcbiAqIE1hcnNoYWwgYSBuYXRpdmUgb2JqZWN0IHRvIGFuIGludGVycHJldGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0ludGVycHJldGVyfSBpbnRlcnByZXRlciBJbnRlcnByZXRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG5hdGl2ZU9iamVjdCBPYmplY3QgdG8gbWFyc2hhbFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERlcHRoIE9wdGlvbmFsIG1heGltdW0gZGVwdGggdG8gdHJhdmVyc2UgaW4gcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IGludGVycHJldGVyT2JqZWN0IE9wdGlvbmFsIGV4aXN0aW5nIGludGVycHJldGVyIG9iamVjdFxuICogQHJldHVybiB7IU9iamVjdH0gVGhlIGludGVycHJldGVyIG9iamVjdCwgd2hpY2ggd2FzIGNyZWF0ZWQgaWYgbmVlZGVkLlxuICovXG5mdW5jdGlvbiBtYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlck9iamVjdChcbiAgICBpbnRlcnByZXRlcixcbiAgICBuYXRpdmVPYmplY3QsXG4gICAgbWF4RGVwdGgsXG4gICAgaW50ZXJwcmV0ZXJPYmplY3QpIHtcbiAgdmFyIHJldFZhbCA9IGludGVycHJldGVyT2JqZWN0IHx8IGludGVycHJldGVyLmNyZWF0ZU9iamVjdChpbnRlcnByZXRlci5PQkpFQ1QpO1xuICB2YXIgaXNGdW5jID0gaW50ZXJwcmV0ZXIuaXNhKHJldFZhbCwgaW50ZXJwcmV0ZXIuRlVOQ1RJT04pO1xuICBmb3IgKHZhciBwcm9wIGluIG5hdGl2ZU9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IHNhZmVSZWFkUHJvcGVydHkobmF0aXZlT2JqZWN0LCBwcm9wKTtcbiAgICBpZiAoaXNGdW5jICYmXG4gICAgICAgICh2YWx1ZSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLnRyaWdnZXIgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMpKSB7XG4gICAgICAvLyBEb24ndCBtYXJzaGFsIHRoZXNlIHRoYXQgd2VyZSBhZGRlZCBieSBqcXVlcnkgb3IgZWxzZSB3ZSB3aWxsIHJlY3Vyc2VcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShyZXRWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLm1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyKGludGVycHJldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCkpO1xuICB9XG4gIHJldHVybiByZXRWYWw7XG59XG5cbmZ1bmN0aW9uIGlzQ2FudmFzSW1hZ2VEYXRhKG5hdGl2ZVZhcikge1xuICAvLyBJRSA5LzEwIGRvbid0IGtub3cgYWJvdXQgVWludDhDbGFtcGVkQXJyYXkgYW5kIGNhbGwgaXQgQ2FudmFzUGl4ZWxBcnJheSBpbnN0ZWFkXG4gIGlmICh0eXBlb2YoVWludDhDbGFtcGVkQXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVZhciBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5O1xuICB9XG4gIHJldHVybiBuYXRpdmVWYXIgaW5zdGFuY2VvZiBDYW52YXNQaXhlbEFycmF5O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFwiY3VzdG9tIG1hcnNoYWxcIiBpbnRlcnByZXRlciBvYmplY3QgdGhhdCBjb3JyZXNwb25kcyB0byBhIG5hdGl2ZVxuICogb2JqZWN0LlxuICogQHBhcmFtIHtJbnRlcnByZXRlcn0gaW50ZXJwcmV0ZXIgSW50ZXJwcmV0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVPYmogT2JqZWN0IHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVQYXJlbnRPYmogUGFyZW50IG9mIG9iamVjdCB0byB3cmFwXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBOZXcgaW50ZXJwcmV0ZXIgb2JqZWN0LlxuICovXG52YXIgY3JlYXRlQ3VzdG9tTWFyc2hhbE9iamVjdCA9IGZ1bmN0aW9uIChpbnRlcnByZXRlciwgbmF0aXZlT2JqLCBuYXRpdmVQYXJlbnRPYmopIHtcbiAgaWYgKG5hdGl2ZU9iaiA9PT0gdW5kZWZpbmVkICYmIGludGVycHJldGVyLlVOREVGSU5FRCkge1xuICAgIHJldHVybiBpbnRlcnByZXRlci5VTkRFRklORUQ7ICAvLyBSZXVzZSB0aGUgc2FtZSBvYmplY3QuXG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgbmF0aXZlT2JqO1xuICB2YXIgb2JqID0ge1xuICAgIGRhdGE6IG5hdGl2ZU9iaixcbiAgICBpc1ByaW1pdGl2ZTogZmFsc2UsXG4gICAgaXNDdXN0b21NYXJzaGFsOiB0cnVlLFxuICAgIHR5cGU6IHR5cGVvZiBuYXRpdmVPYmosXG4gICAgcGFyZW50OiBuYXRpdmVQYXJlbnRPYmosIC8vIFRPRE8gKGNwaXJpY2gpOiByZXBsYWNlIHdpdGggaW50ZXJwcmV0ZXIgb2JqZWN0P1xuICAgIHRvQm9vbGVhbjogZnVuY3Rpb24oKSB7cmV0dXJuIEJvb2xlYW4odGhpcy5kYXRhKTt9LFxuICAgIHRvTnVtYmVyOiBmdW5jdGlvbigpIHtyZXR1cm4gTnVtYmVyKHRoaXMuZGF0YSk7fSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7cmV0dXJuIFN0cmluZyh0aGlzLmRhdGEpO30sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZGF0YTt9XG4gIH07XG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmN1c3RvbU1hcnNoYWxPYmplY3RMaXN0ID0gW107XG5leHBvcnRzLmFzeW5jRnVuY3Rpb25MaXN0ID0gW107XG5leHBvcnRzLm5hdGl2ZUNhbGxzSW50ZXJwcmV0ZXJGdW5jdGlvbkxpc3QgPSBbXTtcblxuLy8gSWYgdGhpcyBpcyBvbiBvdXIgbGlzdCBvZiBcImN1c3RvbSBtYXJzaGFsXCIgb2JqZWN0cyAtIG9yIGlmIGl0IGEgcHJvcGVydHlcbi8vIG9uIG9uZSBvZiB0aG9zZSBvYmplY3RzIChvdGhlciB0aGFuIGEgZnVuY3Rpb24pLCByZXR1cm4gdHJ1ZVxuXG52YXIgc2hvdWxkQ3VzdG9tTWFyc2hhbE9iamVjdCA9IGZ1bmN0aW9uIChuYXRpdmVWYXIsIG5hdGl2ZVBhcmVudE9iaikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cG9ydHMuY3VzdG9tTWFyc2hhbE9iamVjdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWFyc2hhbE9iaiA9IGV4cG9ydHMuY3VzdG9tTWFyc2hhbE9iamVjdExpc3RbaV07XG4gICAgaWYgKChuYXRpdmVWYXIgaW5zdGFuY2VvZiBtYXJzaGFsT2JqLmluc3RhbmNlICYmXG4gICAgICAgICAgKHR5cGVvZiBtYXJzaGFsT2JqLnJlcXVpcmVkTWV0aG9kID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgbmF0aXZlVmFyW21hcnNoYWxPYmoucmVxdWlyZWRNZXRob2RdICE9PSB1bmRlZmluZWQpKSB8fFxuICAgICAgICAodHlwZW9mIG5hdGl2ZVZhciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgbmF0aXZlUGFyZW50T2JqIGluc3RhbmNlb2YgbWFyc2hhbE9iai5pbnN0YW5jZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBXaGVuIG1hcnNoYWxpbmcgbWV0aG9kcyBvbiBcImN1c3RvbSBtYXJzaGFsXCIgb2JqZWN0cywgd2UgbWF5IG5lZWQgdG8gYXVnbWVudFxuLy8gdGhlIG1hcnNoYWxpbmcgb3B0aW9ucy4gVGhpcyByZXR1cm5zIHRob3NlIG9wdGlvbnMuXG5cbnZhciBnZXRDdXN0b21NYXJzaGFsTWV0aG9kT3B0aW9ucyA9IGZ1bmN0aW9uIChuYXRpdmVQYXJlbnRPYmopIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBvcnRzLmN1c3RvbU1hcnNoYWxPYmplY3RMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcnNoYWxPYmogPSBleHBvcnRzLmN1c3RvbU1hcnNoYWxPYmplY3RMaXN0W2ldO1xuICAgIGlmIChuYXRpdmVQYXJlbnRPYmogaW5zdGFuY2VvZiBtYXJzaGFsT2JqLmluc3RhbmNlKSB7XG4gICAgICBpZiAodHlwZW9mIG1hcnNoYWxPYmoucmVxdWlyZWRNZXRob2QgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgIG5hdGl2ZVBhcmVudE9ialttYXJzaGFsT2JqLnJlcXVpcmVkTWV0aG9kXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtYXJzaGFsT2JqLm1ldGhvZE9wdHMgfHwge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn07XG5cbi8vXG4vLyBEcm9wbGV0L0phdmFTY3JpcHQvSW50ZXJwcmV0ZXIgY29kZWdlbiBmdW5jdGlvbnM6XG4vL1xuZXhwb3J0cy5tYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlciA9IGZ1bmN0aW9uIChpbnRlcnByZXRlciwgbmF0aXZlVmFyLCBuYXRpdmVQYXJlbnRPYmosIG1heERlcHRoKSB7XG4gIGlmIChtYXhEZXB0aCA9PT0gMCB8fCB0eXBlb2YgbmF0aXZlVmFyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBpbnRlcnByZXRlci5VTkRFRklORUQ7XG4gIH1cbiAgdmFyIGksIHJldFZhbDtcbiAgaWYgKHR5cGVvZiBtYXhEZXB0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1heERlcHRoID0gSW5maW5pdHk7IC8vIGRlZmF1bHQgdG8gaW5maW5pdGUgbGV2ZWxzIG9mIGRlcHRoXG4gIH1cbiAgaWYgKHNob3VsZEN1c3RvbU1hcnNoYWxPYmplY3QobmF0aXZlVmFyLCBuYXRpdmVQYXJlbnRPYmopKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUN1c3RvbU1hcnNoYWxPYmplY3QoaW50ZXJwcmV0ZXIsIG5hdGl2ZVZhciwgbmF0aXZlUGFyZW50T2JqKTtcbiAgfVxuICBpZiAobmF0aXZlVmFyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXRWYWwgPSBpbnRlcnByZXRlci5jcmVhdGVPYmplY3QoaW50ZXJwcmV0ZXIuQVJSQVkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYXRpdmVWYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFZhbC5wcm9wZXJ0aWVzW2ldID0gZXhwb3J0cy5tYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlcihpbnRlcnByZXRlcixcbiAgICAgICAgbmF0aXZlVmFyW2ldLCBudWxsLCBtYXhEZXB0aCAtIDEpO1xuICAgIH1cbiAgICByZXRWYWwubGVuZ3RoID0gbmF0aXZlVmFyLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChpc0NhbnZhc0ltYWdlRGF0YShuYXRpdmVWYXIpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBjYW52YXMgaW1hZ2UgZGF0YSAtIGNvdWxkIGV4cGFuZCB0byBzdXBwb3J0IFR5cGVkQXJyYXlcbiAgICByZXRWYWwgPSBpbnRlcnByZXRlci5jcmVhdGVPYmplY3QoaW50ZXJwcmV0ZXIuQVJSQVkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYXRpdmVWYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFZhbC5wcm9wZXJ0aWVzW2ldID0gaW50ZXJwcmV0ZXIuY3JlYXRlUHJpbWl0aXZlKG5hdGl2ZVZhcltpXSk7XG4gICAgfVxuICAgIHJldFZhbC5sZW5ndGggPSBuYXRpdmVWYXIubGVuZ3RoO1xuICB9IGVsc2UgaWYgKG5hdGl2ZVZhciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgdmFyIG1ha2VOYXRpdmVPcHRzID0ge1xuICAgICAgaW50ZXJwcmV0ZXI6IGludGVycHJldGVyLFxuICAgICAgbmF0aXZlRnVuYzogbmF0aXZlVmFyLFxuICAgICAgbmF0aXZlUGFyZW50T2JqOiBuYXRpdmVQYXJlbnRPYmosXG4gICAgfTtcbiAgICBpZiAoZXhwb3J0cy5hc3luY0Z1bmN0aW9uTGlzdC5pbmRleE9mKG5hdGl2ZVZhcikgIT09IC0xKSB7XG4gICAgICAvLyBNYXJrIGlmIHRoaXMgc2hvdWxkIGJlIG5hdGl2ZUlzQXN5bmM6XG4gICAgICBtYWtlTmF0aXZlT3B0cy5uYXRpdmVJc0FzeW5jID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMubmF0aXZlQ2FsbHNJbnRlcnByZXRlckZ1bmN0aW9uTGlzdC5pbmRleE9mKG5hdGl2ZVZhcikgIT09IC0xKSB7XG4gICAgICAvLyBNYXJrIGlmIHRoaXMgc2hvdWxkIGJlIG5hdGl2ZUNhbGxzQmFja0ludGVycHJldGVyOlxuICAgICAgbWFrZU5hdGl2ZU9wdHMubmF0aXZlQ2FsbHNCYWNrSW50ZXJwcmV0ZXIgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZXh0cmFPcHRzID0gZ2V0Q3VzdG9tTWFyc2hhbE1ldGhvZE9wdGlvbnMobmF0aXZlUGFyZW50T2JqKTtcbiAgICAvLyBBZGQgZXh0cmEgb3B0aW9ucyBpZiB0aGUgcGFyZW50IG9mIHRoaXMgZnVuY3Rpb24gaXMgaW4gb3VyIGN1c3RvbSBtYXJzaGFsXG4gICAgLy8gbW9kaWZpZWQgb2JqZWN0IGxpc3Q6XG4gICAgZm9yICh2YXIgcHJvcCBpbiBleHRyYU9wdHMpIHtcbiAgICAgIG1ha2VOYXRpdmVPcHRzW3Byb3BdID0gZXh0cmFPcHRzW3Byb3BdO1xuICAgIH1cbiAgICB2YXIgd3JhcHBlciA9IGV4cG9ydHMubWFrZU5hdGl2ZU1lbWJlckZ1bmN0aW9uKG1ha2VOYXRpdmVPcHRzKTtcbiAgICBpZiAobWFrZU5hdGl2ZU9wdHMubmF0aXZlSXNBc3luYykge1xuICAgICAgcmV0VmFsID0gaW50ZXJwcmV0ZXIuY3JlYXRlQXN5bmNGdW5jdGlvbih3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0VmFsID0gaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlcik7XG4gICAgfVxuICAgIC8vIEFsc28gbWFyc2hhbCBwcm9wZXJ0aWVzIG9uIHRoZSBuYXRpdmUgZnVuY3Rpb24gb2JqZWN0OlxuICAgIG1hcnNoYWxOYXRpdmVUb0ludGVycHJldGVyT2JqZWN0KGludGVycHJldGVyLCBuYXRpdmVWYXIsIG1heERlcHRoIC0gMSwgcmV0VmFsKTtcbiAgfSBlbHNlIGlmIChuYXRpdmVWYXIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBub3RlIE9iamVjdCBtdXN0IGJlIGNoZWNrZWQgYWZ0ZXIgRnVuY3Rpb24gYW5kIEFycmF5IChzaW5jZSB0aGV5IGFyZSBhbHNvIE9iamVjdHMpXG4gICAgaWYgKGludGVycHJldGVyLmlzYShuYXRpdmVWYXIsIGludGVycHJldGVyLkZVTkNUSU9OKSkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHNlZSBpZiB3ZSBhcmUgdHJ5aW5nIHRvIG1hcnNoYWwgYW4gaW50ZXJwcmV0ZXIgb2JqZWN0XG4gICAgICAvLyAodGhpcyBjdXJyZW50bHkgaGFwcGVucyB3aGVuIHdlIHN0b3JlIGludGVycHJldGVyIGZ1bmN0aW9uIG9iamVjdHMgaW4gbmF0aXZlXG4gICAgICAvLyAgYW5kIHJldHVybiB0aGVtIGJhY2sgaW4gbmF0aXZlR2V0Q2FsbGJhY2spXG5cbiAgICAgIC8vIE5PVEU6IHRoaXMgY2hlY2sgY291bGQgYmUgZXhwYW5kZWQgdG8gY2hlY2sgZm9yIG90aGVyIGludGVycHJldGVyIG9iamVjdCB0eXBlc1xuICAgICAgLy8gaWYgd2UgaGF2ZSByZWFzb24gdG8gYmVsaWV2ZSB0aGF0IHdlIG1heSBiZSBwYXNzaW5nIHRob3NlIGJhY2tcblxuICAgICAgcmV0VmFsID0gbmF0aXZlVmFyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRWYWwgPSBtYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlck9iamVjdChpbnRlcnByZXRlciwgbmF0aXZlVmFyLCBtYXhEZXB0aCAtIDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXRWYWwgPSBpbnRlcnByZXRlci5jcmVhdGVQcmltaXRpdmUobmF0aXZlVmFyKTtcbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufTtcblxuZXhwb3J0cy5jcmVhdGVOYXRpdmVGdW5jdGlvbkZyb21JbnRlcnByZXRlckZ1bmN0aW9uID0gbnVsbDtcblxuZXhwb3J0cy5tYXJzaGFsSW50ZXJwcmV0ZXJUb05hdGl2ZSA9IGZ1bmN0aW9uIChpbnRlcnByZXRlciwgaW50ZXJwcmV0ZXJWYXIpIHtcbiAgaWYgKGludGVycHJldGVyVmFyLmlzUHJpbWl0aXZlIHx8IGludGVycHJldGVyVmFyLmlzQ3VzdG9tTWFyc2hhbCkge1xuICAgIHJldHVybiBpbnRlcnByZXRlclZhci5kYXRhO1xuICB9IGVsc2UgaWYgKGludGVycHJldGVyLmlzYShpbnRlcnByZXRlclZhciwgaW50ZXJwcmV0ZXIuQVJSQVkpKSB7XG4gICAgdmFyIG5hdGl2ZUFycmF5ID0gW107XG4gICAgbmF0aXZlQXJyYXkubGVuZ3RoID0gaW50ZXJwcmV0ZXJWYXIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF0aXZlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hdGl2ZUFycmF5W2ldID0gZXhwb3J0cy5tYXJzaGFsSW50ZXJwcmV0ZXJUb05hdGl2ZShpbnRlcnByZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlclZhci5wcm9wZXJ0aWVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUFycmF5O1xuICB9IGVsc2UgaWYgKGludGVycHJldGVyLmlzYShpbnRlcnByZXRlclZhciwgaW50ZXJwcmV0ZXIuT0JKRUNUKSB8fFxuICAgICAgaW50ZXJwcmV0ZXJWYXIudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgbmF0aXZlT2JqZWN0ID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBpbnRlcnByZXRlclZhci5wcm9wZXJ0aWVzKSB7XG4gICAgICBuYXRpdmVPYmplY3RbcHJvcF0gPSBleHBvcnRzLm1hcnNoYWxJbnRlcnByZXRlclRvTmF0aXZlKGludGVycHJldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlclZhci5wcm9wZXJ0aWVzW3Byb3BdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZU9iamVjdDtcbiAgfSBlbHNlIGlmIChpbnRlcnByZXRlci5pc2EoaW50ZXJwcmV0ZXJWYXIsIGludGVycHJldGVyLkZVTkNUSU9OKSkge1xuICAgIGlmIChleHBvcnRzLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uRnJvbUludGVycHJldGVyRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uRnJvbUludGVycHJldGVyRnVuY3Rpb24oaW50ZXJwcmV0ZXJWYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKdXN0IHJldHVybiB0aGUgaW50ZXJwcmV0ZXIgb2JqZWN0IGlmIHdlIGNhbid0IGNvbnZlcnQgaXQuIFRoaXMgaXMgbmVlZGVkXG4gICAgICAvLyBmb3IgcGFzc2luZyBpbnRlcnByZXRlciBjYWxsYmFjayBmdW5jdGlvbnMgaW50byBuYXRpdmUuXG5cbiAgICAgIHJldHVybiBpbnRlcnByZXRlclZhcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJDYW4ndCBtYXJzaGFsIHR5cGUgXCIgKyB0eXBlb2YgaW50ZXJwcmV0ZXJWYXI7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmdW5jdGlvbiB3cmFwcGVyIGZvciBhbiBpbnRlcnByZXRlciBhc3luYyBmdW5jdGlvbiBjYWxsYmFjay5cbiAqIFRoZSBpbnRlcnByZXRlciBhc3luYyBmdW5jdGlvbiBjYWxsYmFjayB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsIHdoaWNoXG4gKiBiZWNvbWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGluIHRoZSBpbnRlcnByZXRlclxuICogd29ybGQuIEhlcmUsIHdlIHdyYXAgdGhlIHN1cHBsaWVkIGNhbGxiYWNrIHRvIG1hcnNoYWwgdGhlIHNpbmdsZSBwYXJhbWV0ZXJcbiAqIGZyb20gbmF0aXZlIHRvIGludGVycHJldGVyIGJlZm9yZSBjYWxsaW5nIHRoZSBzdXBwbGllZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIGJsb2NrIHdpdGggaW50ZXJwcmV0ZXIgYW5kIG1heERlcHRoIHByb3ZpZGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgaW50ZXJwcmV0ZXIgc3VwcGxpZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xudmFyIGNyZWF0ZU5hdGl2ZUNhbGxiYWNrRm9yQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZVZhbHVlKSB7XG4gICAgY2FsbGJhY2soXG4gICAgICAgIGV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIoXG4gICAgICAgICAgICBvcHRzLmludGVycHJldGVyLFxuICAgICAgICAgICAgbmF0aXZlVmFsdWUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgb3B0cy5tYXhEZXB0aCkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZ1bmN0aW9uIHdyYXBwZXIgZm9yIGFuIGludGVycHJldGVyIGNhbGxiYWNrIHRoYXQgd2lsbCBiZVxuICogaW52b2tlZCBieSBhIHNwZWNpYWwgbmF0aXZlIGZ1bmN0aW9uIHRoYXQgY2FuIGV4ZWN1dGUgdGhlc2UgY2FsbGJhY2tzIGlubGluZVxuICogb24gdGhlIGludGVycHJldGVyIHN0YWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMgYmxvY2sgd2l0aCBpbnRlcnByZXRlciBhbmQgbWF4RGVwdGggcHJvdmlkZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGludEZ1bmMgVGhlIGludGVycHJldGVyIHN1cHBsaWVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbnZhciBjcmVhdGVOYXRpdmVJbnRlcnByZXRlckNhbGxiYWNrID0gZnVuY3Rpb24gKG9wdHMsIGludEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVWYWx1ZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgaW50QXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgaW50QXJnc1tpXSA9IGV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIoXG4gICAgICAgICAgb3B0cy5pbnRlcnByZXRlcixcbiAgICAgICAgICBhcmdzW2ldLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgb3B0cy5tYXhEZXB0aCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgQ2FsbEV4cHJlc3Npb24gbm9kZSBvbiB0aGUgc3RhY2sgdGhhdCBhbHJlYWR5IGhhcyBpdHMgZnVuY18sXG4gICAgLy8gYXJndW1lbnRzLCBhbmQgb3RoZXIgc3RhdGUgcG9wdWxhdGVkOlxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIG5vZGU6IHtcbiAgICAgICAgdHlwZTogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgYXJndW1lbnRzOiBpbnRBcmdzIC8qIHRoaXMganVzdCBuZWVkcyB0byBiZSBhcnJheSBvZiB0aGUgc2FtZSBzaXplICovXG4gICAgICAgIH0sXG4gICAgICBkb25lQ2FsbGVlXzogdHJ1ZSxcbiAgICAgIGZ1bmNfOiBpbnRGdW5jLFxuICAgICAgYXJndW1lbnRzOiBpbnRBcmdzLFxuICAgICAgbl86IGludEFyZ3MubGVuZ3RoXG4gICAgfTtcbiAgICBvcHRzLmludGVycHJldGVyLnN0YXRlU3RhY2sudW5zaGlmdChzdGF0ZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmF0aXZlIGZ1bmN0aW9uIHdyYXBwZXIgZm9yIHVzZSB3aXRoIHRoZSBKUyBpbnRlcnByZXRlci5cbiAqL1xuZXhwb3J0cy5tYWtlTmF0aXZlTWVtYmVyRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAob3B0cy5kb250TWFyc2hhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEp1c3QgY2FsbCB0aGUgbmF0aXZlIGZ1bmN0aW9uIGFuZCBtYXJzaGFsIHRoZSByZXR1cm4gdmFsdWU6XG4gICAgICB2YXIgbmF0aXZlUmV0VmFsID0gb3B0cy5uYXRpdmVGdW5jLmFwcGx5KG9wdHMubmF0aXZlUGFyZW50T2JqLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMubWFyc2hhbE5hdGl2ZVRvSW50ZXJwcmV0ZXIob3B0cy5pbnRlcnByZXRlciwgbmF0aXZlUmV0VmFsLFxuICAgICAgICBudWxsLCBvcHRzLm1heERlcHRoKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIENhbGwgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhZnRlciBtYXJzaGFsbGluZyBwYXJhbWV0ZXJzOlxuICAgICAgdmFyIG5hdGl2ZUFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvcHRzLm5hdGl2ZUlzQXN5bmMgJiYgKGkgPT09IGFyZ3VtZW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIC8vIEFzeW5jIGZ1bmN0aW9ucyByZWNlaXZlIGEgbmF0aXZlIGNhbGxiYWNrIG1ldGhvZCBhcyB0aGVpciBsYXN0XG4gICAgICAgICAgLy8gcGFyYW1ldGVyLCBhbmQgd2Ugd2FudCB0byB3cmFwIHRoYXQgY2FsbGJhY2sgdG8gZWFzZSBtYXJzaGFsbGluZzpcbiAgICAgICAgICBuYXRpdmVBcmdzW2ldID0gY3JlYXRlTmF0aXZlQ2FsbGJhY2tGb3JBc3luY0Z1bmN0aW9uKG9wdHMsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5uYXRpdmVDYWxsc0JhY2tJbnRlcnByZXRlciAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG9wdHMuaW50ZXJwcmV0ZXIuaXNhKGFyZ3VtZW50c1tpXSwgb3B0cy5pbnRlcnByZXRlci5GVU5DVElPTikpIHtcbiAgICAgICAgICAvLyBBIHNlbGVjdCBjbGFzcyBvZiBuYXRpdmUgZnVuY3Rpb25zIGlzIGF3YXJlIG9mIHRoZSBpbnRlcnByZXRlciBhbmRcbiAgICAgICAgICAvLyBjYXBhYmxlIG9mIGNhbGxpbmcgdGhlIGludGVycHJldGVyIG9uIHRoZSBzdGFjayBpbW1lZGlhdGVseS4gV2VcbiAgICAgICAgICAvLyBtYXJzaGFsIHRoZXNlIGRpZmZlcmVudGx5OlxuICAgICAgICAgIG5hdGl2ZUFyZ3NbaV0gPSBjcmVhdGVOYXRpdmVJbnRlcnByZXRlckNhbGxiYWNrKG9wdHMsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmF0aXZlQXJnc1tpXSA9IGV4cG9ydHMubWFyc2hhbEludGVycHJldGVyVG9OYXRpdmUob3B0cy5pbnRlcnByZXRlciwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5hdGl2ZVJldFZhbCA9IG9wdHMubmF0aXZlRnVuYy5hcHBseShvcHRzLm5hdGl2ZVBhcmVudE9iaiwgbmF0aXZlQXJncyk7XG4gICAgICByZXR1cm4gZXhwb3J0cy5tYXJzaGFsTmF0aXZlVG9JbnRlcnByZXRlcihvcHRzLmludGVycHJldGVyLCBuYXRpdmVSZXRWYWwsXG4gICAgICAgIG51bGwsIG9wdHMubWF4RGVwdGgpO1xuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvcHVsYXRlRnVuY3Rpb25zSW50b1Njb3BlKGludGVycHJldGVyLCBzY29wZSwgZnVuY3NPYmosIHBhcmVudE9iaiwgb3B0aW9ucykge1xuICBmb3IgKHZhciBwcm9wIGluIGZ1bmNzT2JqKSB7XG4gICAgdmFyIGZ1bmMgPSBmdW5jc09ialtwcm9wXTtcbiAgICBpZiAoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAvLyBQb3B1bGF0ZSB0aGUgc2NvcGUgd2l0aCBuYXRpdmUgZnVuY3Rpb25zXG4gICAgICAvLyBOT1RFOiBvdGhlciBwcm9wZXJ0aWVzIGFyZSBub3QgY3VycmVudGx5IHBhc3NlZCB0byB0aGUgaW50ZXJwcmV0ZXJcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRPYmogPyBwYXJlbnRPYmogOiBmdW5jc09iajtcbiAgICAgIHZhciB3cmFwcGVyID0gZXhwb3J0cy5tYWtlTmF0aXZlTWVtYmVyRnVuY3Rpb24odXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICBpbnRlcnByZXRlcjogaW50ZXJwcmV0ZXIsXG4gICAgICAgICAgbmF0aXZlRnVuYzogZnVuYyxcbiAgICAgICAgICBuYXRpdmVQYXJlbnRPYmo6IHBhcmVudCxcbiAgICAgIH0pKTtcbiAgICAgIGludGVycHJldGVyLnNldFByb3BlcnR5KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGVyLmNyZWF0ZU5hdGl2ZUZ1bmN0aW9uKHdyYXBwZXIpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVHbG9iYWxGdW5jdGlvbnMoaW50ZXJwcmV0ZXIsIGJsb2NrcywgYmxvY2tGaWx0ZXIsIHNjb3BlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJsb2NrID0gYmxvY2tzW2ldO1xuICAgIGlmIChibG9jay5wYXJlbnQgJiZcbiAgICAgICAgKCFibG9ja0ZpbHRlciB8fCB0eXBlb2YgYmxvY2tGaWx0ZXJbYmxvY2suZnVuY10gIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgdmFyIGZ1bmNTY29wZSA9IHNjb3BlO1xuICAgICAgdmFyIGZ1bmNOYW1lID0gYmxvY2suZnVuYztcbiAgICAgIHZhciBmdW5jQ29tcG9uZW50cyA9IGZ1bmNOYW1lLnNwbGl0KCcuJyk7XG4gICAgICBpZiAoZnVuY0NvbXBvbmVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgYWNjb21tb2RhdGlvbiBmb3IgT2JqZWN0LmZ1bmN0aW9uIHN5bnRheCAoMiBjb21wb25lbnRzIG9ubHkpOlxuICAgICAgICB2YXIgb2JqTmFtZSA9IGZ1bmNDb21wb25lbnRzWzBdO1xuICAgICAgICAvLyBGaW5kIG9yIGNyZWF0ZSBnbG9iYWwgb2JqZWN0IG5hbWVkICdvYmpOYW1lJyBhbmQgbWFrZSBpdCB0aGUgc2NvcGU6XG4gICAgICAgIGZ1bmNTY29wZSA9IGludGVycHJldGVyLmdldFByb3BlcnR5KHNjb3BlLCBvYmpOYW1lKTtcbiAgICAgICAgaWYgKGludGVycHJldGVyLlVOREVGSU5FRCA9PT0gZnVuY1Njb3BlKSB7XG4gICAgICAgICAgZnVuY1Njb3BlID0gaW50ZXJwcmV0ZXIuY3JlYXRlT2JqZWN0KGludGVycHJldGVyLk9CSkVDVCk7XG4gICAgICAgICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkoc2NvcGUsIG9iak5hbWUsIGZ1bmNTY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY05hbWUgPSBmdW5jQ29tcG9uZW50c1sxXTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gYmxvY2sucGFyZW50W2Z1bmNOYW1lXTtcbiAgICAgIHZhciB3cmFwcGVyID0gZXhwb3J0cy5tYWtlTmF0aXZlTWVtYmVyRnVuY3Rpb24oe1xuICAgICAgICAgIGludGVycHJldGVyOiBpbnRlcnByZXRlcixcbiAgICAgICAgICBuYXRpdmVGdW5jOiBmdW5jLFxuICAgICAgICAgIG5hdGl2ZVBhcmVudE9iajogYmxvY2sucGFyZW50LFxuICAgICAgICAgIGRvbnRNYXJzaGFsOiBibG9jay5kb250TWFyc2hhbCxcbiAgICAgICAgICBuYXRpdmVJc0FzeW5jOiBibG9jay5uYXRpdmVJc0FzeW5jXG4gICAgICB9KTtcbiAgICAgIHZhciBpbnRGdW5jO1xuICAgICAgaWYgKGJsb2NrLm5hdGl2ZUlzQXN5bmMpIHtcbiAgICAgICAgaW50RnVuYyA9IGludGVycHJldGVyLmNyZWF0ZUFzeW5jRnVuY3Rpb24od3JhcHBlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRGdW5jID0gaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlcik7XG4gICAgICB9XG4gICAgICBpbnRlcnByZXRlci5zZXRQcm9wZXJ0eShmdW5jU2NvcGUsIGZ1bmNOYW1lLCBpbnRGdW5jKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVKU0Z1bmN0aW9ucyhpbnRlcnByZXRlcikge1xuICAvLyBUaGUgaW50ZXJwcmV0ZXIgaXMgbWlzc2luZyBzb21lIGJhc2ljIEpTIGZ1bmN0aW9ucy4gQWRkIHRoZW0gYXMgbmVlZGVkOlxuICB2YXIgd3JhcHBlcjtcblxuICAvLyBBZGQgc3RhdGljIG1ldGhvZHMgZnJvbSBTdHJpbmc6XG4gIHZhciBmdW5jdGlvbnMgPSBbJ2Zyb21DaGFyQ29kZSddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHdyYXBwZXIgPSBleHBvcnRzLm1ha2VOYXRpdmVNZW1iZXJGdW5jdGlvbih7XG4gICAgICBpbnRlcnByZXRlcjogaW50ZXJwcmV0ZXIsXG4gICAgICBuYXRpdmVGdW5jOiBTdHJpbmdbZnVuY3Rpb25zW2ldXSxcbiAgICAgIG5hdGl2ZVBhcmVudE9iajogU3RyaW5nLFxuICAgIH0pO1xuICAgIGludGVycHJldGVyLnNldFByb3BlcnR5KGludGVycHJldGVyLlNUUklORywgZnVuY3Rpb25zW2ldLFxuICAgICAgaW50ZXJwcmV0ZXIuY3JlYXRlTmF0aXZlRnVuY3Rpb24od3JhcHBlciksIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEFkZCBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG4gIHdyYXBwZXIgPSBmdW5jdGlvbihzZWFyY2hTdHIpIHtcbiAgICAvLyBQb2x5ZmlsbCBiYXNlZCBvZmYgb2YgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG4gICAgcmV0dXJuIGludGVycHJldGVyLmNyZWF0ZVByaW1pdGl2ZShcbiAgICAgIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICE9PSAtMSk7XG4gIH07XG4gIGludGVycHJldGVyLnNldFByb3BlcnR5KGludGVycHJldGVyLlNUUklORy5wcm9wZXJ0aWVzLnByb3RvdHlwZSwgJ2luY2x1ZGVzJyxcbiAgICBpbnRlcnByZXRlci5jcmVhdGVOYXRpdmVGdW5jdGlvbih3cmFwcGVyKSwgZmFsc2UsIHRydWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBKUyBpbnRlcnByZXRlci5cbiAqXG4gKiBpbnRlcnByZXRlciAocmVxdWlyZWQpOiBKUyBpbnRlcnByZXRlciBpbnN0YW5jZS5cbiAqIGJsb2NrcyAob3B0aW9uYWwpOiBibG9ja3MgaW4gZHJvcGxldENvbmZpZy5ibG9ja3MgZm9ybWF0LiBJZiBhIGJsb2NrIGhhc1xuICogIGEgcGFyZW50IHByb3BlcnR5LCB3ZSB3aWxsIHBvcHVsYXRlIHRoYXQgZnVuY3Rpb24gaW50byB0aGUgc3BlY2lmaWVkIHNjb3BlLlxuICogYmxvY2tGaWx0ZXIgKG9wdGlvbmFsKTogYW4gb2JqZWN0IHdpdGggYmxvY2stbmFtZSBrZXlzIHRoYXQgc2hvdWxkIGJlIHVzZWRcbiAqICB0byBmaWx0ZXIgd2hpY2ggYmxvY2tzIGFyZSBwb3B1bGF0ZWQuXG4gKiBzY29wZSAocmVxdWlyZWQpOiBpbnRlcnByZXRlcidzIGdsb2JhbCBzY29wZS5cbiAqIGdsb2JhbE9iamVjdHMgKG9wdGlvbmFsKTogb2JqZWN0cyBjb250YWluaW5nIGZ1bmN0aW9ucyB0byBwbGFjZWQgaW4gYSBuZXcgc2NvcGVcbiAqICBjcmVhdGVkIGJlbmVhdGggdGhlIHN1cHBsaWVkIHNjb3BlLlxuICovXG5leHBvcnRzLmluaXRKU0ludGVycHJldGVyID0gZnVuY3Rpb24gKGludGVycHJldGVyLCBibG9ja3MsIGJsb2NrRmlsdGVyLCBzY29wZSwgZ2xvYmFsT2JqZWN0cykge1xuICBmb3IgKHZhciBnbG9iYWxPYmogaW4gZ2xvYmFsT2JqZWN0cykge1xuICAgIC8vIFRoZSBnbG9iYWxPYmplY3RzIG9iamVjdCBjb250YWlucyBvYmplY3RzIHRoYXQgd2lsbCBiZSByZWZlcmVuY2VkXG4gICAgLy8gYnkgdGhlIGNvZGUgd2UgcGxhbiB0byBleGVjdXRlLiBTaW5jZSB0aGVzZSBvYmplY3RzIGV4aXN0IGluIHRoZSBuYXRpdmVcbiAgICAvLyB3b3JsZCwgd2UgbmVlZCB0byBjcmVhdGUgYXNzb2NpYXRlZCBvYmplY3RzIGluIHRoZSBpbnRlcnByZXRlcidzIHdvcmxkXG4gICAgLy8gc28gdGhlIGludGVycHJldGVkIGNvZGUgY2FuIGNhbGwgb3V0IHRvIHRoZXNlIG5hdGl2ZSBvYmplY3RzXG5cbiAgICAvLyBDcmVhdGUgZ2xvYmFsIG9iamVjdHMgaW4gdGhlIGludGVycHJldGVyIGZvciBldmVyeXRoaW5nIGluIG9wdGlvbnNcbiAgICB2YXIgb2JqID0gaW50ZXJwcmV0ZXIuY3JlYXRlT2JqZWN0KGludGVycHJldGVyLk9CSkVDVCk7XG4gICAgaW50ZXJwcmV0ZXIuc2V0UHJvcGVydHkoc2NvcGUsIGdsb2JhbE9iai50b1N0cmluZygpLCBvYmopO1xuICAgIC8vIE1hcnNoYWwgcmV0dXJuIHZhbHVlcyB3aXRoIGEgbWF4RGVwdGggb2YgMiAoanVzdCBhbiBvYmplY3QgYW5kIGl0cyBjaGlsZFxuICAgIC8vIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgb25seSlcbiAgICBwb3B1bGF0ZUZ1bmN0aW9uc0ludG9TY29wZShcbiAgICAgICAgaW50ZXJwcmV0ZXIsXG4gICAgICAgIG9iaixcbiAgICAgICAgZ2xvYmFsT2JqZWN0c1tnbG9iYWxPYmpdLFxuICAgICAgICBudWxsLFxuICAgICAgICB7IG1heERlcHRoOiAyIH0pO1xuICB9XG4gIHBvcHVsYXRlR2xvYmFsRnVuY3Rpb25zKFxuICAgICAgaW50ZXJwcmV0ZXIsXG4gICAgICBkcm9wbGV0VXRpbHMuZHJvcGxldEdsb2JhbENvbmZpZ0Jsb2NrcyxcbiAgICAgIGJsb2NrRmlsdGVyLFxuICAgICAgc2NvcGUpO1xuICBpZiAoYmxvY2tzKSB7XG4gICAgcG9wdWxhdGVHbG9iYWxGdW5jdGlvbnMoXG4gICAgICAgIGludGVycHJldGVyLFxuICAgICAgICBibG9ja3MsXG4gICAgICAgIGJsb2NrRmlsdGVyLFxuICAgICAgICBzY29wZSk7XG4gIH1cbiAgcG9wdWxhdGVKU0Z1bmN0aW9ucyhpbnRlcnByZXRlcik7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBpdCBpcyBzYWZlIHRvIHN0ZXAgdGhlIGludGVycHJldGVyIHdoaWxlIHdlIGFyZSB1bndpbmRpbmcuXG4gKiAoQ2FsbGVkIHJlcGVhdGVkbHkgYWZ0ZXIgY29tcGxldGluZyBhIHN0ZXAgd2hlcmUgdGhlIG5vZGUgd2FzIG1hcmtlZCAnZG9uZScpXG4gKi9cbmV4cG9ydHMuaXNOZXh0U3RlcFNhZmVXaGlsZVVud2luZGluZyA9IGZ1bmN0aW9uIChpbnRlcnByZXRlcikge1xuICB2YXIgc3RhdGUgPSBpbnRlcnByZXRlci5zdGF0ZVN0YWNrWzBdO1xuICB2YXIgdHlwZSA9IHN0YXRlLm5vZGUudHlwZTtcbiAgaWYgKHN0YXRlLmRvbmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJTd2l0Y2hTdGF0ZW1lbnRcIikge1xuICAgIC8vIFNhZmUgdG8gc2tpcCBvdmVyIFN3aXRjaFN0YXRlbWVudCdzIGV4Y2VwdCB0aGUgdmVyeSBzdGFydCAoYmVmb3JlIGFcbiAgICAvLyBzd2l0Y2hWYWx1ZSBoYXMgYmVlbiBzZXQpOlxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUuc3dpdGNoVmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh0eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgIC8vIE9ubHkgc3RvcCB0aGUgZmlyc3QgdGltZSB0aGlzIFZhcmlhYmxlRGVjbGFyYXRpb24gaXMgcHJvY2Vzc2VkICh0aGVcbiAgICAvLyBpbnRlcnByZXRlciB3aWxsIHN0b3Agb24gdGhpcyBub2RlIG11bHRpcGxlIHRpbWVzLCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgICAvLyBgc3RhdGUubmAgcmVwcmVzZW50aW5nIHdoaWNoIFZhcmlhYmxlRGVjbGFyYXRvciBpcyBiZWluZyBleGVjdXRlZCkuXG4gICAgcmV0dXJuIHN0YXRlLm4gPiAwO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIERlY2xhcmF0aW9uczpcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgLy8gU3RhdGVtZW50czpcbiAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICAvLyBBbGwgRXhwcmVzc2lvbnM6XG4gICAgY2FzZSBcIlRoaXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkFycm93RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVXBkYXRlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgIC8vIE90aGVyOlxuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gc2Vzc2lvbiBpcyBhbiBpbnN0YW5jZSBvZiBBY2UgZWRpdFNlc3Npb25cbi8vIFVzYWdlXG4vLyB2YXIgbGVuZ3RoQXJyYXkgPSBjYWxjdWxhdGVDdW11bGF0aXZlTGVuZ3RoKGVkaXRvci5nZXRTZXNzaW9uKCkpO1xuLy8gTmVlZCB0byBjYWxsIHRoaXMgb25seSBpZiB0aGUgZG9jdW1lbnQgaXMgdXBkYXRlZCBhZnRlciB0aGUgbGFzdCBjYWxsLlxuZXhwb3J0cy5jYWxjdWxhdGVDdW11bGF0aXZlTGVuZ3RoID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgdmFyIHJlZ2V4ID0gL1xcbi9nLCByZXN1bHQgPSBbXTtcbiAgZG8ge1xuICAgIHJlc3VsdC5wdXNoKHJlZ2V4Lmxhc3RJbmRleCk7XG4gICAgcmVnZXguZXhlYyhjb2RlKTtcbiAgfSB3aGlsZSAocmVnZXgubGFzdEluZGV4ICE9PSAwKTtcblxuICByZXN1bHQucHVzaChjb2RlLmxlbmd0aCArIDEpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gRmFzdCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uXG4vLyBQYXNzIHRoZSBjdW11bGF0aXZlIGxlbmd0aCBhcnJheSBoZXJlLlxuLy8gVXNhZ2Vcbi8vIHZhciByb3cgPSBhY2VGaW5kUm93KGxlbmd0aEFycmF5LCAwLCBsZW5ndGhBcnJheS5sZW5ndGgsIDI1MTIpO1xuLy8gdHJpZXMgdG8gZmluZCAyNTEydGggY2hhcmFjdGVyIGxpZXMgaW4gd2hpY2ggcm93LlxuZXhwb3J0cy5hY2VGaW5kUm93ID0gZnVuY3Rpb24gKGN1bXVsYXRpdmVMZW5ndGgsIHJvd3MsIHJvd2UsIHBvcykge1xuICBpZiAocm93cyA+IHJvd2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm93cyArIDEgPT09IHJvd2UpIHtcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChyb3dzICsgcm93ZSkgLyAyKTtcblxuICBpZiAocG9zIDwgY3VtdWxhdGl2ZUxlbmd0aFttaWRdKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuYWNlRmluZFJvdyhjdW11bGF0aXZlTGVuZ3RoLCByb3dzLCBtaWQsIHBvcyk7XG4gIH0gZWxzZSBpZihwb3MgPiBjdW11bGF0aXZlTGVuZ3RoW21pZF0pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5hY2VGaW5kUm93KGN1bXVsYXRpdmVMZW5ndGgsIG1pZCwgcm93ZSwgcG9zKTtcbiAgfVxuICByZXR1cm4gbWlkO1xufTtcblxuZXhwb3J0cy5pc0FjZUJyZWFrcG9pbnRSb3cgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgdXNlckNvZGVSb3cpIHtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBicHMgPSBzZXNzaW9uLmdldEJyZWFrcG9pbnRzKCk7XG4gIHJldHVybiBCb29sZWFuKGJwc1t1c2VyQ29kZVJvd10pO1xufTtcblxudmFyIGxhc3RIaWdobGlnaHRNYXJrZXJJZHMgPSB7fTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGhpZ2hsaWdodHMgdGhhdCB3ZSBoYXZlIGFkZGVkIGluIHRoZSBhY2UgZWRpdG9yLlxuICovXG5mdW5jdGlvbiBjbGVhckFsbEhpZ2hsaWdodGVkQWNlTGluZXMgKGFjZUVkaXRvcikge1xuICB2YXIgc2Vzc2lvbiA9IGFjZUVkaXRvci5nZXRTZXNzaW9uKCk7XG4gIGZvciAodmFyIGhsQ2xhc3MgaW4gbGFzdEhpZ2hsaWdodE1hcmtlcklkcykge1xuICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKGxhc3RIaWdobGlnaHRNYXJrZXJJZHNbaGxDbGFzc10pO1xuICB9XG4gIGxhc3RIaWdobGlnaHRNYXJrZXJJZHMgPSB7fTtcbn1cblxuLyoqXG4gKiBIaWdobGlnaHRzIGxpbmVzIGluIHRoZSBhY2UgZWRpdG9yLiBBbHdheXMgbW92ZXMgdGhlIHByZXZpb3VzIGhpZ2hsaWdodCB3aXRoXG4gKiB0aGUgc2FtZSBjbGFzcyB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICpcbiAqIElmIHRoZSByb3cgcGFyYW1ldGVycyBhcmUgbm90IHN1cHBsaWVkLCBqdXN0IGNsZWFyIHRoZSBsYXN0IGhpZ2hsaWdodC5cbiAqL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWNlTGluZXMgKGFjZUVkaXRvciwgY2xhc3NOYW1lLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIGVuZFJvdywgZW5kQ29sdW1uKSB7XG4gIHZhciBzZXNzaW9uID0gYWNlRWRpdG9yLmdldFNlc3Npb24oKTtcbiAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICdhY2Vfc3RlcCc7XG4gIGlmIChsYXN0SGlnaGxpZ2h0TWFya2VySWRzW2NsYXNzTmFtZV0pIHtcbiAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihsYXN0SGlnaGxpZ2h0TWFya2VySWRzW2NsYXNzTmFtZV0pO1xuICAgIGxhc3RIaWdobGlnaHRNYXJrZXJJZHNbY2xhc3NOYW1lXSA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydFJvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsYXN0SGlnaGxpZ2h0TWFya2VySWRzW2NsYXNzTmFtZV0gPSBzZXNzaW9uLmFkZE1hcmtlcihcbiAgICAgICAgbmV3ICh3aW5kb3cuYWNlLnJlcXVpcmUoJ2FjZS9yYW5nZScpLlJhbmdlKShcbiAgICAgICAgICAgIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pLCBjbGFzc05hbWUsICd0ZXh0Jyk7XG4gICAgaWYgKCFhY2VFZGl0b3IuaXNSb3dGdWxseVZpc2libGUoc3RhcnRSb3cpKSB7XG4gICAgICBhY2VFZGl0b3Iuc2Nyb2xsVG9MaW5lKHN0YXJ0Um93LCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZWxlY3RzIGFuZCBoaWdobGlnaHRzIGNvZGUgaW4gZHJvcGxldC9hY2UgZWRpdG9yIHRvIGluZGljYXRlIGFuIGVycm9yLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGhpZ2hsaWdodHMgb25lIHNwb3QsIG5vdCBhIHJhbmdlLiBJdCBpcyB0eXBpY2FsbHkgdXNlZFxuICogdG8gaGlnaGxpZ2h0IHdoZXJlIGFuIGVycm9yIGhhcyBvY2N1cnJlZC5cbiAqL1xuZXhwb3J0cy5zZWxlY3RFZGl0b3JSb3dDb2xFcnJvciA9IGZ1bmN0aW9uIChlZGl0b3IsIHJvdywgY29sKSB7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGl0b3IuY3VycmVudGx5VXNpbmdCbG9ja3MpIHtcbiAgICB2YXIgc3R5bGUgPSB7Y29sb3I6ICcjRkZGRjIyJ307XG4gICAgZWRpdG9yLmNsZWFyTGluZU1hcmtzKCk7XG4gICAgZWRpdG9yLm1hcmtMaW5lKHJvdywgc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuYWNlRWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuXG4gICAgcmFuZ2Uuc3RhcnQucm93ID0gcm93O1xuICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IGNvbDtcbiAgICByYW5nZS5lbmQucm93ID0gcm93O1xuICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBjb2wgKyAxO1xuXG4gICAgLy8gc2V0dGluZyB3aXRoIHRoZSBiYWNrd2FyZHMgcGFyYW1ldGVyIHNldCB0byB0cnVlIC0gdGhpcyBwcmV2ZW50cyBob3Jpem9udGFsXG4gICAgLy8gc2Nyb2xsaW5nIHRvIHRoZSByaWdodFxuICAgIHNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgdHJ1ZSk7XG4gIH1cbiAgbGFzdEhpZ2hsaWdodE1hcmtlcklkcy5hY2VfZXJyb3IgPSBlZGl0b3IuYWNlRWRpdG9yLmdldFNlc3Npb24oKVxuICAgICAgLmhpZ2hsaWdodExpbmVzKHJvdywgcm93LCAnYWNlX2Vycm9yJykuaWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgaGlnaGxpZ2h0cyAoZm9yIHRoZSBkZWZhdWx0IGFjZV9zdGVwIGNsYXNzKSBhbmQgc2VsZWN0aW9uIGluXG4gKiBkcm9wbGV0IGFuZCBhY2UgZWRpdG9ycy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbENsYXNzZXMgV2hlbiBzZXQgdG8gdHJ1ZSwgcmVtb3ZlIGFsbCBjbGFzc2VzIG9mXG4gKiBoaWdobGlnaHRzIChpbmNsdWRpbmcgYWNlX3N0ZXAsIGFjZV9lcnJvciwgYW5kIGFueXRoaW5nIGVsc2UpXG4gKi9cbmV4cG9ydHMuY2xlYXJEcm9wbGV0QWNlSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKGVkaXRvciwgYWxsQ2xhc3Nlcykge1xuICBpZiAoZWRpdG9yLmN1cnJlbnRseVVzaW5nQmxvY2tzKSB7XG4gICAgZWRpdG9yLmNsZWFyTGluZU1hcmtzKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRpdG9yLmFjZUVkaXRvci5nZXRTZWxlY3Rpb24oKS5jbGVhclNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChhbGxDbGFzc2VzKSB7XG4gICAgY2xlYXJBbGxIaWdobGlnaHRlZEFjZUxpbmVzKGVkaXRvci5hY2VFZGl0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIHdoZW4gY2FsbGluZyB3aXRob3V0IGEgY2xhc3Mgb3Igcm93cywgaGlnaGxpZ2h0QWNlTGluZXMoKSB3aWxsIGNsZWFyXG4gICAgLy8gZXZlcnl0aGluZyBoaWdobGlnaHRlZCB3aXRoIHRoZSBkZWZhdWx0IGhpZ2hsaWdodCBjbGFzc1xuICAgIGhpZ2hsaWdodEFjZUxpbmVzKGVkaXRvci5hY2VFZGl0b3IpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzZWxlY3RBbmRIaWdobGlnaHRDb2RlIChhY2VFZGl0b3IsIGN1bXVsYXRpdmVMZW5ndGgsIHN0YXJ0LCBlbmQsIGhpZ2hsaWdodENsYXNzKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBhY2VFZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuXG4gIHJhbmdlLnN0YXJ0LnJvdyA9IGV4cG9ydHMuYWNlRmluZFJvdyhjdW11bGF0aXZlTGVuZ3RoLCAwLCBjdW11bGF0aXZlTGVuZ3RoLmxlbmd0aCwgc3RhcnQpO1xuICByYW5nZS5zdGFydC5jb2x1bW4gPSBzdGFydCAtIGN1bXVsYXRpdmVMZW5ndGhbcmFuZ2Uuc3RhcnQucm93XTtcbiAgcmFuZ2UuZW5kLnJvdyA9IGV4cG9ydHMuYWNlRmluZFJvdyhjdW11bGF0aXZlTGVuZ3RoLCAwLCBjdW11bGF0aXZlTGVuZ3RoLmxlbmd0aCwgZW5kKTtcbiAgcmFuZ2UuZW5kLmNvbHVtbiA9IGVuZCAtIGN1bXVsYXRpdmVMZW5ndGhbcmFuZ2UuZW5kLnJvd107XG5cbiAgaGlnaGxpZ2h0QWNlTGluZXMoYWNlRWRpdG9yLCBoaWdobGlnaHRDbGFzcyB8fCBcImFjZV9zdGVwXCIsIHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcmFuZ2UuZW5kLnJvdywgcmFuZ2UuZW5kLmNvbHVtbik7XG59XG5cbi8qKlxuICogU2VsZWN0cyBjb2RlIGluIGRyb3BsZXQvYWNlIGVkaXRvci5cbiAqXG4gKiBSZXR1cm5zIHRoZSByb3cgKGxpbmUpIG9mIGNvZGUgaGlnaGxpZ2h0ZWQuIElmIG5vdGhpbmcgaXMgaGlnaGxpZ2h0ZWRcbiAqIGJlY2F1c2UgaXQgaXMgb3V0c2lkZSBvZiB0aGUgdXNlckNvZGUgYXJlYSwgdGhlIHJldHVybiB2YWx1ZSBpcyAtMVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoaWdobGlnaHRDbGFzcyBDU1MgY2xhc3MgdG8gdXNlIHdoZW4gaGlnaGxpZ2h0aW5nIGluIEFDRVxuICovXG5leHBvcnRzLnNlbGVjdEN1cnJlbnRDb2RlID0gZnVuY3Rpb24gKGludGVycHJldGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0aXZlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyQ29kZVN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyQ29kZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRDbGFzcykge1xuICB2YXIgdXNlckNvZGVSb3cgPSAtMTtcbiAgaWYgKGludGVycHJldGVyICYmIGludGVycHJldGVyLnN0YXRlU3RhY2tbMF0pIHtcbiAgICB2YXIgbm9kZSA9IGludGVycHJldGVyLnN0YXRlU3RhY2tbMF0ubm9kZTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnKSB7XG4gICAgICB2YXIgbW9kZSA9IGludGVycHJldGVyLnN0YXRlU3RhY2tbMF0ubW9kZSB8fCAwLCBzdWJOb2RlO1xuICAgICAgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgICAgc3ViTm9kZSA9IG5vZGUuaW5pdDtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gMSkge1xuICAgICAgICBzdWJOb2RlID0gbm9kZS50ZXN0O1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAyKSB7XG4gICAgICAgIHN1Yk5vZGUgPSBub2RlLmJvZHk7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IDMpIHtcbiAgICAgICAgc3ViTm9kZSA9IG5vZGUudXBkYXRlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHN1Yk5vZGUgfHwgbm9kZTtcbiAgICB9XG5cbiAgICAvLyBBZGp1c3Qgc3RhcnQvZW5kIGJ5IHVzZXJDb2RlU3RhcnRPZmZzZXQgc2luY2UgdGhlIGNvZGUgcnVubmluZ1xuICAgIC8vIGhhcyBiZWVuIGV4cGFuZGVkIHZzLiB3aGF0IHRoZSB1c2VyIHNlZXMgaW4gdGhlIGVkaXRvciB3aW5kb3c6XG4gICAgdmFyIHN0YXJ0ID0gbm9kZS5zdGFydCAtIHVzZXJDb2RlU3RhcnRPZmZzZXQ7XG4gICAgdmFyIGVuZCA9IG5vZGUuZW5kIC0gdXNlckNvZGVTdGFydE9mZnNldDtcblxuICAgIC8vIE9ubHkgc2hvdyBzZWxlY3Rpb24gaWYgdGhlIG5vZGUgYmVpbmcgZXhlY3V0ZWQgaXMgaW5zaWRlIHRoZSB1c2VyJ3NcbiAgICAvLyBjb2RlIChub3QgaW5zaWRlIGNvZGUgd2UgaW5zZXJ0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZWlyIGNvZGUgdGhhdCBpc1xuICAgIC8vIG5vdCB2aXNpYmxlIGluIHRoZSBlZGl0b3IpOlxuICAgIGlmIChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdXNlckNvZGVMZW5ndGggJiYgZW5kIDw9IHVzZXJDb2RlTGVuZ3RoKSB7XG4gICAgICB1c2VyQ29kZVJvdyA9IGV4cG9ydHMuYWNlRmluZFJvdyhjdW11bGF0aXZlTGVuZ3RoLCAwLCBjdW11bGF0aXZlTGVuZ3RoLmxlbmd0aCwgc3RhcnQpO1xuICAgICAgLy8gSGlnaGxpZ2h0IHRoZSBjb2RlIGJlaW5nIGV4ZWN1dGVkIGluIGVhY2ggc3RlcDpcbiAgICAgIGlmIChlZGl0b3IuY3VycmVudGx5VXNpbmdCbG9ja3MpIHtcbiAgICAgICAgdmFyIHN0eWxlID0ge2NvbG9yOiAnI0ZGRkYyMid9O1xuICAgICAgICBlZGl0b3IuY2xlYXJMaW5lTWFya3MoKTtcbiAgICAgICAgZWRpdG9yLm1hcmsoe3JvdzogdXNlckNvZGVSb3csIGNvbDogc3RhcnQgLSBjdW11bGF0aXZlTGVuZ3RoW3VzZXJDb2RlUm93XX0sIHN0eWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdEFuZEhpZ2hsaWdodENvZGUoZWRpdG9yLmFjZUVkaXRvciwgY3VtdWxhdGl2ZUxlbmd0aCwgc3RhcnQsIGVuZCxcbiAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5jbGVhckRyb3BsZXRBY2VIaWdobGlnaHRpbmcoZWRpdG9yKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5jbGVhckRyb3BsZXRBY2VIaWdobGlnaHRpbmcoZWRpdG9yKTtcbiAgfVxuICByZXR1cm4gdXNlckNvZGVSb3c7XG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIF8gPSB1dGlscy5nZXRMb2Rhc2goKTtcblxuLyoqXG4gKiBAbmFtZSBEcm9wbGV0QmxvY2tcbiAqIEBkZXNjcmlwdGlvbiBEZWZpbml0aW9uIG9mIGEgYmxvY2sgdG8gYmUgdXNlZCBpbiBEcm9wbGV0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnVuYyBpZGVudGlmeWluZyB0aGUgZnVuY3Rpb24gdGhpcyBibG9jayBydW5zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmxvY2tQcmVmaXggUHJlcGVuZCB0aGlzIHN0cmluZyBiZWZvcmUgdGhlIG5vcm1hbCBibG9jayBuYW1lIGluIHRoZSBwYWxldHRlXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGFyZW50IG9iamVjdCB3aXRoaW4gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBkZWZpbmVkIGFzIGEgcHJvcGVydHksIGtleWVkIGJ5IHRoZSBmdW5jIG5hbWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeSB3aXRoaW4gd2hpY2ggdG8gcGxhY2UgdGhlIGJsb2NrXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSB0eXBlIG9mIHRoZSBibG9jayAoZS5nLiB2YWx1ZSwgZWl0aGVyLCBwcm9wZXJ0eSlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHBhbGV0dGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHBhcmFtc1xuICogQHByb3BlcnR5IHtPYmplY3QuPG51bWJlciwgZnVuY3Rpb24+fSBkcm9wZG93blxuICogQHByb3BlcnR5IHtPYmplY3QuPG51bWJlciwgZnVuY3Rpb24+fSBhc3NldFRvb2x0aXBcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gZG9udE1hcnNoYWwgQVBJIGV4cGVjdHMgcGFyYW1zIGluIGludGVycHJldGVyIGZvcm0gYW5kIHdpbGwgcmV0dXJuIGFuIGludGVycHJldGVyIHZhbHVlXG4gKiBAcHJvcGVydHkge2Jvb2x9IG5vQXV0b2NvbXBsZXRlIERvIG5vdCBpbmNsdWRlIHRoaXMgZnVuY3Rpb24gaW4gb3VyIGFjZSBjb21wbGV0ZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gbmF0aXZlSXNBc3luYyBUaGUgbmF0aXZlIGZ1bmN0aW9uIGlzIGludGVybmFsbHkgYXN5bmMgYW5kIHdpbGwgY2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlc3VtZSB0aGUgaW50ZXJwcmV0ZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXBQcmVmaXggUHJlcGVuZCB0aGlzIHN0cmluZyBiZWZvcmUgdGhlIHRvb2x0aXAgZm9ybWVkIGZyb20gdGhlIGZ1bmN0aW9uIG5hbWUgYW5kIChvcHRpb25hbGx5KSBwYXJhbWV0ZXJzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZG9jRnVuYyBVc2UgdGhlIHByb3ZpZGVkIGZ1bmMgYXMgdGhlIGtleSBmb3Igb3VyIGRvY3VtZW50YXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbW9kZU9wdGlvbk5hbWUgQWx0ZXJuYXRlIG5hbWUgdG8gYmUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgZHJvcGxldCBtb2RlIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBuYW1lIERyb3BsZXRDb25maWdcbiAqIEBkZXNjcmlwdGlvbiBDb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGZvciBEcm9wbGV0XG4gKiBAcHJvcGVydHkge0Ryb3BsZXRCbG9ja1tdfSBibG9ja3MgbGlzdCBvZiBibG9ja3NcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjYXRlZ29yaWVzIGNvbmZpZ3VyYXRpb24gb2YgY2F0ZWdvcmllcyB3aXRoaW4gd2hpY2ggdG8gcGxhY2UgYmxvY2tzXG4gKi9cblxudmFyIENPTE9SX1BJTksgPSAnI0Y1N0FDNic7XG52YXIgQ09MT1JfUFVSUExFID0gJyNCQjc3QzcnO1xudmFyIENPTE9SX0dSRUVOID0gJyM2OEQ5OTUnO1xudmFyIENPTE9SX0xJR0hUX0dSRUVOID0gJyNEM0U5NjUnO1xudmFyIENPTE9SX1dISVRFID0gJyNGRkZGRkYnO1xudmFyIENPTE9SX0JMVUUgPSAnIzY0QjVGNic7XG52YXIgQ09MT1JfT1JBTkdFID0gJyNGRkI3NEQnO1xuXG5leHBvcnRzLnJhbmRvbU51bWJlciA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICBpZiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJZiBvbmx5IG9uZSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIG1heCB3aXRoIHplcm8gYXMgbWluOlxuICAgIG1heCA9IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG4gIC8vIFVzZSBkb3VibGUtdGlsZGUgdG8gZW5zdXJlIHdlIGFyZSBkZWFsaW5nIHdpdGggaW50ZWdlcnM6XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAofn5tYXggLSB+fm1pbiArIDEpKSArIH5+bWluO1xufTtcblxuZXhwb3J0cy5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufTtcblxuLyoqXG4gKiBVc2UgbmF0aXZlIHdpbmRvdy5wcm9tcHQgdG8gYXNrIGZvciBhIHZhbHVlLCBidXQgY29udGludWUgcHJvbXB0aW5nIHVudGlsIHdlXG4gKiBnZXQgYSBudW1lcmljYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVc2VyIHZhbHVlLCBjb252ZXJ0ZWQgdG8gYSBudW1iZXJcbiAqL1xuZXhwb3J0cy5wcm9tcHROdW0gPSBmdW5jdGlvbiAodGV4dCkge1xuICB2YXIgdmFsO1xuICBkbyB7XG4gICAgdmFsID0gcGFyc2VJbnQod2luZG93LnByb21wdCh0ZXh0KSwgMTApO1xuICB9IHdoaWxlIChpc05hTih2YWwpKTtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQHR5cGUge0Ryb3BsZXRCbG9ja1tdfVxuICovXG5leHBvcnRzLmRyb3BsZXRHbG9iYWxDb25maWdCbG9ja3MgPSBbXG4gIHtmdW5jOiAnZ2V0VGltZScsIHBhcmVudDogZXhwb3J0cywgY2F0ZWdvcnk6ICdDb250cm9sJywgdHlwZTogJ3ZhbHVlJyB9LFxuICB7ZnVuYzogJ3JhbmRvbU51bWJlcicsIHBhcmVudDogZXhwb3J0cywgY2F0ZWdvcnk6ICdNYXRoJywgdHlwZTogJ3ZhbHVlJyB9LFxuICB7ZnVuYzogJ3Byb21wdCcsIHBhcmVudDogd2luZG93LCBjYXRlZ29yeTogJ1ZhcmlhYmxlcycsIHR5cGU6ICd2YWx1ZScgfSxcbiAge2Z1bmM6ICdwcm9tcHROdW0nLCBwYXJlbnQ6IGV4cG9ydHMsIGNhdGVnb3J5OiAnVmFyaWFibGVzJywgdHlwZTogJ3ZhbHVlJyB9XG5dO1xuXG4vKipcbiAqIEB0eXBlIHtEcm9wbGV0QmxvY2tbXX1cbiAqL1xuZXhwb3J0cy5kcm9wbGV0QnVpbHRpbkNvbmZpZ0Jsb2NrcyA9IFtcbiAge2Z1bmM6ICdNYXRoLnJvdW5kJywgY2F0ZWdvcnk6ICdNYXRoJywgdHlwZTogJ3ZhbHVlJywgZG9jRnVuYzogJ21hdGhSb3VuZCcgfSxcbiAge2Z1bmM6ICdNYXRoLmFicycsIGNhdGVnb3J5OiAnTWF0aCcsIHR5cGU6ICd2YWx1ZScsIGRvY0Z1bmM6ICdtYXRoQWJzJyB9LFxuICB7ZnVuYzogJ01hdGgubWF4JywgY2F0ZWdvcnk6ICdNYXRoJywgdHlwZTogJ3ZhbHVlJywgZG9jRnVuYzogJ21hdGhNYXgnIH0sXG4gIHtmdW5jOiAnTWF0aC5taW4nLCBjYXRlZ29yeTogJ01hdGgnLCB0eXBlOiAndmFsdWUnLCBkb2NGdW5jOiAnbWF0aE1pbicgfSxcbiAge2Z1bmM6ICdNYXRoLnJhbmRvbScsIGNhdGVnb3J5OiAnTWF0aCcsIHR5cGU6ICd2YWx1ZScsIGRvY0Z1bmM6ICdtYXRoUmFuZG9tJyB9XG5dO1xuXG4vKipcbiAqIEB0eXBlIHtEcm9wbGV0Q29uZmlnfCp9fVxuICovXG52YXIgc3RhbmRhcmRDb25maWcgPSB7fTtcblxuc3RhbmRhcmRDb25maWcuYmxvY2tzID0gW1xuICAvLyBDb250cm9sXG4gIHtmdW5jOiAnZm9yTG9vcF9pXzBfNCcsIGJsb2NrOiAnZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gIF9fO1xcbn0nLCBjYXRlZ29yeTogJ0NvbnRyb2wnIH0sXG4gIHtmdW5jOiAnd2hpbGVCbG9jaycsIGJsb2NrOiAnd2hpbGUgKF9fKSB7XFxuICBfXztcXG59JywgY2F0ZWdvcnk6ICdDb250cm9sJyB9LFxuICB7ZnVuYzogJ2lmQmxvY2snLCBibG9jazogJ2lmIChfXykge1xcbiAgX187XFxufScsIGNhdGVnb3J5OiAnQ29udHJvbCcgfSxcbiAge2Z1bmM6ICdpZkVsc2VCbG9jaycsIGJsb2NrOiAnaWYgKF9fKSB7XFxuICBfXztcXG59IGVsc2Uge1xcbiAgX187XFxufScsIGNhdGVnb3J5OiAnQ29udHJvbCcgfSxcbiAge2Z1bmM6ICdnZXRUaW1lJywgYmxvY2s6ICdnZXRUaW1lKCknLCBjYXRlZ29yeTogJ0NvbnRyb2wnLCB0eXBlOiAndmFsdWUnIH0sXG5cbiAgLy8gTWF0aFxuICB7ZnVuYzogJ2FkZE9wZXJhdG9yJywgYmxvY2s6ICdfXyArIF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ3N1YnRyYWN0T3BlcmF0b3InLCBibG9jazogJ19fIC0gX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbXVsdGlwbHlPcGVyYXRvcicsIGJsb2NrOiAnX18gKiBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdkaXZpZGVPcGVyYXRvcicsIGJsb2NrOiAnX18gLyBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdlcXVhbGl0eU9wZXJhdG9yJywgYmxvY2s6ICdfXyA9PSBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdpbmVxdWFsaXR5T3BlcmF0b3InLCBibG9jazogJ19fICE9IF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ2dyZWF0ZXJUaGFuT3BlcmF0b3InLCBibG9jazogJ19fID4gX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnZ3JlYXRlclRoYW5PckVxdWFsT3BlcmF0b3InLCBibG9jazogJ19fID49IF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ2xlc3NUaGFuT3BlcmF0b3InLCBibG9jazogJ19fIDwgX18nLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbGVzc1RoYW5PckVxdWFsT3BlcmF0b3InLCBibG9jazogJ19fIDw9IF9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ2FuZE9wZXJhdG9yJywgYmxvY2s6ICdfXyAmJiBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdvck9wZXJhdG9yJywgYmxvY2s6ICdfXyB8fCBfXycsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdub3RPcGVyYXRvcicsIGJsb2NrOiAnIV9fJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICAvLyByYW5kb21OdW1iZXJfbWF4IGhhcyBiZWVuIGRlcHJlY2F0ZWRcbiAgLy8ge2Z1bmM6ICdyYW5kb21OdW1iZXJfbWF4JywgYmxvY2s6ICdyYW5kb21OdW1iZXIoX18pJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICAvLyBOb3RlOiBXZSB1c2UgcmFuZG9tTnVtYmVyIGFzIG91ciBiYXNlIGRvY0Z1bmMgaGVyZSBzbyB0aGF0IHdlIGdldCB0aGUgYmVuZWZpdHMgb2YgcGFyYW0gZGVzY3JpcHRpb25zXG4gIHtmdW5jOiAncmFuZG9tTnVtYmVyX21pbl9tYXgnLCBibG9jazogJ3JhbmRvbU51bWJlcihfXywgX18pJywgY2F0ZWdvcnk6ICdNYXRoJywgZG9jRnVuYzogJ3JhbmRvbU51bWJlcid9LFxuICB7ZnVuYzogJ21hdGhSb3VuZCcsIGJsb2NrOiAnTWF0aC5yb3VuZChfXyknLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbWF0aEFicycsIGJsb2NrOiAnTWF0aC5hYnMoX18pJywgY2F0ZWdvcnk6ICdNYXRoJyB9LFxuICB7ZnVuYzogJ21hdGhNYXgnLCBibG9jazogJ01hdGgubWF4KF9fKScsIGNhdGVnb3J5OiAnTWF0aCcgfSxcbiAge2Z1bmM6ICdtYXRoTWluJywgYmxvY2s6ICdNYXRoLm1pbihfXyknLCBjYXRlZ29yeTogJ01hdGgnIH0sXG4gIHtmdW5jOiAnbWF0aFJhbmRvbScsIGJsb2NrOiAnTWF0aC5yYW5kb20oKScsIGNhdGVnb3J5OiAnTWF0aCcgfSxcblxuICAvLyBWYXJpYWJsZXNcbiAge2Z1bmM6ICdkZWNsYXJlQXNzaWduX3gnLCBibG9jazogJ3ZhciB4ID0gX187JywgY2F0ZWdvcnk6ICdWYXJpYWJsZXMnIH0sXG4gIHtmdW5jOiAnZGVjbGFyZU5vQXNzaWduX3gnLCBibG9jazogJ3ZhciB4OycsIGNhdGVnb3J5OiAnVmFyaWFibGVzJyB9LFxuICB7ZnVuYzogJ2Fzc2lnbl94JywgYmxvY2s6ICd4ID0gX187JywgY2F0ZWdvcnk6ICdWYXJpYWJsZXMnIH0sXG4gIHtmdW5jOiAnZGVjbGFyZUFzc2lnbl94X2FycmF5XzFfNCcsIGJsb2NrOiAndmFyIHggPSBbMSwgMiwgMywgNF07JywgY2F0ZWdvcnk6ICdWYXJpYWJsZXMnIH0sXG4gIHtmdW5jOiAnZGVjbGFyZUFzc2lnbl94X3Byb21wdCcsIGJsb2NrOiAndmFyIHggPSBwcm9tcHQoXCJFbnRlciBhIHZhbHVlXCIpOycsIGNhdGVnb3J5OiAnVmFyaWFibGVzJyB9LFxuICB7ZnVuYzogJ2RlY2xhcmVBc3NpZ25feF9wcm9tcHROdW0nLCBibG9jazogJ3ZhciB4ID0gcHJvbXB0TnVtKFwiRW50ZXIgYSB2YWx1ZVwiKTsnLCBjYXRlZ29yeTogJ1ZhcmlhYmxlcycgfSxcblxuICAvLyBGdW5jdGlvbnNcbiAge2Z1bmM6ICdmdW5jdGlvblBhcmFtc19ub25lJywgYmxvY2s6ICdmdW5jdGlvbiBteUZ1bmN0aW9uKCkge1xcbiAgX187XFxufScsIGNhdGVnb3J5OiAnRnVuY3Rpb25zJyB9LFxuICB7ZnVuYzogJ2Z1bmN0aW9uUGFyYW1zX24nLCBibG9jazogJ2Z1bmN0aW9uIG15RnVuY3Rpb24obikge1xcbiAgX187XFxufScsIGNhdGVnb3J5OiAnRnVuY3Rpb25zJyB9LFxuICB7ZnVuYzogJ2NhbGxNeUZ1bmN0aW9uJywgYmxvY2s6ICdteUZ1bmN0aW9uKCknLCBjYXRlZ29yeTogJ0Z1bmN0aW9ucycgfSxcbiAge2Z1bmM6ICdjYWxsTXlGdW5jdGlvbl9uJywgYmxvY2s6ICdteUZ1bmN0aW9uKG4pJywgY2F0ZWdvcnk6ICdGdW5jdGlvbnMnIH0sXG4gIHtmdW5jOiAncmV0dXJuJywgYmxvY2s6ICdyZXR1cm4gX187JywgY2F0ZWdvcnk6ICdGdW5jdGlvbnMnIH0sXG4gIHtmdW5jOiAnY29tbWVudCcsIGJsb2NrOiAnLy8gQ29tbWVudCcsIGNhdGVnb3J5OiAnRnVuY3Rpb25zJyB9XG5dO1xuXG5zdGFuZGFyZENvbmZpZy5jYXRlZ29yaWVzID0ge1xuICBDb250cm9sOiB7XG4gICAgY29sb3I6ICdibHVlJyxcbiAgICByZ2I6IENPTE9SX0JMVUUsXG4gICAgYmxvY2tzOiBbXVxuICB9LFxuICBNYXRoOiB7XG4gICAgY29sb3I6ICdvcmFuZ2UnLFxuICAgIHJnYjogQ09MT1JfT1JBTkdFLFxuICAgIGJsb2NrczogW11cbiAgfSxcbiAgVmFyaWFibGVzOiB7XG4gICAgY29sb3I6ICdwdXJwbGUnLFxuICAgIHJnYjogQ09MT1JfUFVSUExFLFxuICAgIGJsb2NrczogW11cbiAgfSxcbiAgRnVuY3Rpb25zOiB7XG4gICAgY29sb3I6ICdncmVlbicsXG4gICAgcmdiOiBDT0xPUl9HUkVFTixcbiAgICBibG9ja3M6IFtdXG4gIH0sXG4gIC8vIGNyZWF0ZSBibGFuayBjYXRlZ29yeSBpbiBjYXNlIGxldmVsIGJ1aWxkZXJzIHdhbnQgdG8gbW92ZSBhbGwgYmxvY2tzIGhlcmVcbiAgLy8gKHdoaWNoIHdpbGwgY2F1c2UgdGhlIHBhbGV0dGUgaGVhZGVyIHRvIGRpc2FwcGVhcilcbiAgJycgOiB7ICdibG9ja3MnOiBbXSB9LFxufTtcblxuLyoqXG4gKiBHaXZlbiBhIGNvbGxlY3Rpb24gb2YgY29kZSBmdW5jdGlvbnMgYW5kIGEgc2V0IG9mIGRyb3BsZXR0ZUNvbmZpZywgcmV0dXJucyBhXG4gKiBhIGxpc3Qgb2YgYmxvY2tzLlxuICogQHBhcmFtIGNvZGVGdW5jdGlvbnMge29iamVjdH0gQSBjb2xsZWN0aW9uIG9mIG5hbWVkIGtleS92YWx1ZSBwYWlyc1xuICogICBrZXkgaXMgYSBibG9jayBuYW1lIGZyb20gZHJvcGxldEJsb2NrcyBvciBzdGFuZGFyZEJsb2Nrc1xuICogICB2YWx1ZSBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSBibG9jayBkZWZhdWx0c1xuICogQHBhcmFtIHtEcm9wbGV0Q29uZmlnfSBkcm9wbGV0Q29uZmlnXG4gKiBAcGFyYW0ge0Ryb3BsZXRDb25maWd9IG90aGVyQ29uZmlnIG9wdGlvbmFsbHkgdXNlZCB0byBzdXBwbHkgYSBzdGFuZGFyZENvbmZpZ1xuICogIG9iamVjdCB3aGljaCBpcyBub3QgYXBwIHNwZWNpZmljLiBJdCB3aWxsIGJlIHVzZWQgZmlyc3QsIHRoZW4gb3ZlcnJpZGVuXG4gKiAgYnkgdGhlIHByaW1hcnkgZHJvcGxldENvbmZpZyBpZiB0aGVyZSBpcyBvdmVybGFwIGJldHdlZW4gdGhlIHR3by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucGFsZXR0ZU9ubHkgaWdub3JlIGJsb2NrcyBub3QgaW4gY29kZUZ1bmN0aW9ucyBwYWxldHRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaWdub3JlRG9jRnVuYyBkb24ndCBpbmNsdWRlIGJhc2VkIG9uIGJsb2NrLmRvY0Z1bmNcbiAqIEByZXR1cm5zIHtBcnJheTxEcm9wbGV0QmxvY2s+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJlZEJsb2Nrc0Zyb21Db25maWcoY29kZUZ1bmN0aW9ucywgZHJvcGxldENvbmZpZywgb3RoZXJDb25maWcsIG9wdGlvbnMpIHtcbiAgaWYgKCFjb2RlRnVuY3Rpb25zIHx8ICFkcm9wbGV0Q29uZmlnIHx8ICFkcm9wbGV0Q29uZmlnLmJsb2Nrcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBibG9ja3MgPSBbXTtcbiAgaWYgKG90aGVyQ29uZmlnKSB7XG4gICAgYmxvY2tzID0gYmxvY2tzLmNvbmNhdChvdGhlckNvbmZpZy5ibG9ja3MpO1xuICB9XG4gIGJsb2NrcyA9IGJsb2Nrcy5jb25jYXQoZHJvcGxldENvbmZpZy5ibG9ja3MpO1xuXG4gIHZhciBkb2NGdW5jdGlvbnMgPSB7fTtcbiAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgaWYgKCEoYmxvY2suZnVuYyBpbiBjb2RlRnVuY3Rpb25zKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pZ25vcmVEb2NGdW5jKSB7XG4gICAgICAvLyBGb3IgY2FzZXMgd2hlcmUgd2UgdXNlIGEgZGlmZmVyZW50IGJsb2NrIGZvciBvdXIgdG9vbHRpcHMsIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyB0aGUgdGFyZ2V0IGJsb2NrIGVuZHMgdXAgaW4gdGhlIGxpc3Qgb2YgYmxvY2tzIHdlIHdhbnRcbiAgICAgIHZhciBkb2NGdW5jID0gYmxvY2suZG9jRnVuYztcbiAgICAgIGlmIChkb2NGdW5jICYmICEoZG9jRnVuYyBpbiBjb2RlRnVuY3Rpb25zKSkge1xuICAgICAgICBkb2NGdW5jdGlvbnNbZG9jRnVuY10gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJsb2Nrcy5maWx0ZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuICFvcHRpb25zLnBhbGV0dGVPbmx5IHx8IGJsb2NrLmZ1bmMgaW4gY29kZUZ1bmN0aW9ucyB8fCBibG9jay5mdW5jIGluIGRvY0Z1bmN0aW9ucztcbiAgfSkubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgIC8vIFdlIGZvdW5kIHRoaXMgcGFydGljdWxhciBibG9jaywgbm93IG92ZXJyaWRlIHRoZSBkZWZhdWx0cyB3aXRoIGV4dGVuZFxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYmxvY2ssIGNvZGVGdW5jdGlvbnNbYmxvY2suZnVuY10pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgY2F0ZWdvcmllcyBvYmplY3Qgd2l0aCB0aGUgY2F0ZWdvcmllcyBmcm9tIGRyb3BsZXRDb25maWcgKGFwcFxuICogc3BlY2lmaWMgY29uZmlndXJhdGlvbikgbWVyZ2VkIHdpdGggdGhlIG9uZXMgaW4gc3RhbmRhcmRDb25maWcgKGdsb2JhbFxuICogY29uZmlndXJhdGlvbikuIEFwcCBjb25maWd1cmF0aW9uIHRha2VzIHByZWNlbmRlbmNlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ2F0ZWdvcmllc1dpdGhDb25maWcoZHJvcGxldENvbmZpZykge1xuICAvLyBDbG9uZSBvdXIgbWVyZ2VkIGNhdGVnb3JpZXMgc28gdGhhdCBhcyB3ZSBtdXRhdGUgaXQsIHdlJ3JlIG5vdCBtdXRhdGluZ1xuICAvLyBvdXIgb3JpZ2luYWwgY29uZmlnXG4gIHZhciBkcm9wbGV0Q2F0ZWdvcmllcyA9IGRyb3BsZXRDb25maWcgJiYgZHJvcGxldENvbmZpZy5jYXRlZ29yaWVzO1xuICAvLyBXZSBpbmNsdWRlIGRyb3BsZXRDYXRlZ29yaWVzIHR3aWNlIHNvIHRoYXQgKGEpIGl0J3Mgb3JkZXJpbmcgb2YgY2F0ZWdvcmllc1xuICAvLyBnZXRzIHByZWZlcmVuY2UgYW5kIChiKSBpdCdzIHZhbHVlIG92ZXJyaWRlIGFueXRoaW5nIGluIHN0YW5kYXJkQ29uZmlnXG4gIHJldHVybiBfLmNsb25lRGVlcCgkLmV4dGVuZCh7fSwgZHJvcGxldENhdGVnb3JpZXMsIHN0YW5kYXJkQ29uZmlnLmNhdGVnb3JpZXMsXG4gICAgZHJvcGxldENhdGVnb3JpZXMpKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBjb2RlIGFsaWFzZXMgaW4gSmF2YXNjcmlwdCBiYXNlZCBvbiBzb21lIGxldmVsIGRhdGEuXG4gKiBAcGFyYW0ge0Ryb3BsZXRDb25maWd9IGRyb3BsZXRDb25maWdcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRPYmpOYW1lIHN0cmluZyByZWZlcmVuY2UgdG8gb2JqZWN0IHVwb24gd2hpY2ggZnVuYyBpc1xuICogIGEgcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNvZGVcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUNvZGVBbGlhc2VzID0gZnVuY3Rpb24gKGRyb3BsZXRDb25maWcsIHBhcmVudE9iak5hbWUpIHtcbiAgdmFyIGNvZGUgPSAnJztcbiAgdmFyIGFsaWFzRnVuY3Rpb25zID0gZHJvcGxldENvbmZpZy5ibG9ja3M7XG5cbiAgLy8gSW5zZXJ0IGFsaWFzZXMgZnJvbSBhbGlhc0Z1bmN0aW9ucyBpbnRvIGNvZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGlhc0Z1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjZiA9IGFsaWFzRnVuY3Rpb25zW2ldO1xuICAgIGNvZGUgKz0gXCJ2YXIgXCIgKyBjZi5mdW5jICsgXCIgPSBmdW5jdGlvbigpIHsgXCI7XG4gICAgaWYgKGNmLmlkQXJnTm9uZSkge1xuICAgICAgY29kZSArPSBcInJldHVybiBcIiArIHBhcmVudE9iak5hbWUgKyBcIi5cIiArIGNmLmZ1bmMgKyBcIi5hcHBseShcIiArXG4gICAgICAgICAgICAgIHBhcmVudE9iak5hbWUgKyBcIiwgYXJndW1lbnRzKTsgfTtcXG5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcInZhciBuZXdBcmdzID0gXCIgK1xuICAgICAgICAoY2YuaWRBcmdMYXN0ID8gXCJhcmd1bWVudHMuY29uY2F0KFsnJ10pO1wiIDogXCJbJyddLmNvbmNhdChhcmd1bWVudHMpO1wiKSArXG4gICAgICAgIFwiIHJldHVybiBcIiArIHBhcmVudE9iak5hbWUgKyBcIi5cIiArIGNmLmZ1bmMgK1xuICAgICAgICBcIi5hcHBseShcIiArIHBhcmVudE9iak5hbWUgKyBcIiwgbmV3QXJncyk7IH07XFxuXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2RlO1xufTtcblxuZnVuY3Rpb24gYnVpbGRGdW5jdGlvblByb3RvdHlwZShwcmVmaXgsIHBhcmFtcykge1xuICB2YXIgcHJvdG8gPSBwcmVmaXggKyBcIihcIjtcbiAgaWYgKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBwcm90byArPSBcIiwgXCI7XG4gICAgICB9XG4gICAgICBwcm90byArPSBwYXJhbXNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm90byArIFwiKVwiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcGFsZXR0ZSBmb3IgdGhlIGRyb3BsZXQgZWRpdG9yIGJhc2VkIG9uIHNvbWUgbGV2ZWwgZGF0YS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb2RlRnVuY3Rpb25zIFRoZSBzZXQgb2YgZnVuY3Rpb25zIHdlIHdhbnQgdG8gdXNlIGZvciB0aGlzIGxldmVsXG4gKiBAcGFyYW0ge29iamVjdH0gZHJvcGxldENvbmZpZ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZHJvcGxldENvbmZpZy5nZXRCbG9ja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcm9wbGV0Q29uZmlnLmNhdGVnb3JpZXNcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZURyb3BsZXRQYWxldHRlID0gZnVuY3Rpb24gKGNvZGVGdW5jdGlvbnMsIGRyb3BsZXRDb25maWcpIHtcbiAgdmFyIG1lcmdlZENhdGVnb3JpZXMgPSBtZXJnZUNhdGVnb3JpZXNXaXRoQ29uZmlnKGRyb3BsZXRDb25maWcpO1xuICB2YXIgbWVyZ2VkRnVuY3Rpb25zID0gZmlsdGVyZWRCbG9ja3NGcm9tQ29uZmlnKFxuICAgICAgY29kZUZ1bmN0aW9ucyxcbiAgICAgIGRyb3BsZXRDb25maWcsXG4gICAgICBzdGFuZGFyZENvbmZpZyxcbiAgICAgIHsgcGFsZXR0ZU9ubHk6IHRydWUsIGlnbm9yZURvY0Z1bmM6IHRydWUgfVxuICApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVyZ2VkRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZ1bmNJbmZvID0gbWVyZ2VkRnVuY3Rpb25zW2ldO1xuICAgIHZhciBibG9jayA9IGZ1bmNJbmZvLmJsb2NrO1xuICAgIHZhciBleHBhbnNpb24gPSBmdW5jSW5mby5leHBhbnNpb247XG4gICAgaWYgKCFibG9jaykge1xuICAgICAgdmFyIG5hbWVXaXRoUHJlZml4ID0gZnVuY0luZm8uZnVuYztcbiAgICAgIGlmIChmdW5jSW5mby5ibG9ja1ByZWZpeCkge1xuICAgICAgICBuYW1lV2l0aFByZWZpeCA9IGZ1bmNJbmZvLmJsb2NrUHJlZml4ICsgbmFtZVdpdGhQcmVmaXg7XG4gICAgICB9XG4gICAgICBpZiAoZnVuY0luZm8udHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICBibG9jayA9IG5hbWVXaXRoUHJlZml4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhbGV0dGVQYXJhbXMgPSBmdW5jSW5mby5wYWxldHRlUGFyYW1zIHx8IGZ1bmNJbmZvLnBhcmFtcztcbiAgICAgICAgYmxvY2sgPSBidWlsZEZ1bmN0aW9uUHJvdG90eXBlKG5hbWVXaXRoUHJlZml4LCBwYWxldHRlUGFyYW1zKTtcbiAgICAgICAgaWYgKGZ1bmNJbmZvLnBhbGV0dGVQYXJhbXMpIHtcbiAgICAgICAgICAvLyBJZiBwYWxldHRlUGFyYW1zIHdlcmUgc3BlY2lmaWVkIGFuZCB1c2VkIGZvciB0aGUgJ2Jsb2NrJywgdGhlbiB1c2VcbiAgICAgICAgICAvLyB0aGUgcmVndWxhciBwYXJhbXMgZm9yIHRoZSAnZXhwYW5zaW9uJyB3aGljaCBhcHBlYXJzIHdoZW4gdGhlIGJsb2NrXG4gICAgICAgICAgLy8gaXMgZHJhZ2dlZCBvdXQgb2YgdGhlIHBhbGV0dGU6XG4gICAgICAgICAgZXhwYW5zaW9uID0gYnVpbGRGdW5jdGlvblByb3RvdHlwZShuYW1lV2l0aFByZWZpeCwgZnVuY0luZm8ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlcmUgd2Ugc2V0IHRoZSB0aXRsZSBhdHRyaWJ1dGUgdG8gdGhlIGZ1bmN0aW9uIHNob3J0bmFtZSxcbiAgICAgKiB0aGlzIGlzIGxhdGVyIHVzZWQgYXMgYSBrZXkgZm9yIGZ1bmN0aW9uIGRvY3VtZW50YXRpb24gYW5kIHRvb2x0aXBzXG4gICAgICovXG4gICAgdmFyIGJsb2NrUGFpciA9IHtcbiAgICAgIGJsb2NrOiBibG9jayxcbiAgICAgIGV4cGFuc2lvbjogZXhwYW5zaW9uLFxuICAgICAgdGl0bGU6IGZ1bmNJbmZvLm1vZGVPcHRpb25OYW1lIHx8IGZ1bmNJbmZvLmZ1bmNcbiAgICB9O1xuICAgIG1lcmdlZENhdGVnb3JpZXNbZnVuY0luZm8uY2F0ZWdvcnldLmJsb2Nrcy5wdXNoKGJsb2NrUGFpcik7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGRyb3BsZXQncyBleHBlY3RlZCBwYWxldHRlIGZvcm1hdDpcbiAgdmFyIGFkZGVkUGFsZXR0ZSA9IFtdO1xuICBmb3IgKHZhciBjYXRlZ29yeSBpbiBtZXJnZWRDYXRlZ29yaWVzKSB7XG4gICAgaWYgKG1lcmdlZENhdGVnb3JpZXNbY2F0ZWdvcnldLmJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXJnZWRDYXRlZ29yaWVzW2NhdGVnb3J5XS5uYW1lID0gY2F0ZWdvcnk7XG4gICAgICBhZGRlZFBhbGV0dGUucHVzaChtZXJnZWRDYXRlZ29yaWVzW2NhdGVnb3J5XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFkZGVkUGFsZXR0ZTtcbn07XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQ29tcGxldGVyQXBpc0Zyb21Db25maWdCbG9ja3Mob3B0cywgYXBpcywgbWV0aG9kc0FuZFByb3BlcnRpZXMsIGNvbmZpZ0Jsb2Nrcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZ0Jsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBibG9jayA9IGNvbmZpZ0Jsb2Nrc1tpXTtcbiAgICBpZiAoIWJsb2NrLm5vQXV0b2NvbXBsZXRlKSB7XG4gICAgICAvLyBVc2Ugc2NvcmUgdmFsdWUgb2YgMTAwIHRvIGVuc3VyZSB0aGF0IG91ciBBUElzIGFyZSBub3QgcmVwbGFjZWQgYnlcbiAgICAgIC8vIG90aGVyIGNvbXBsZXRlcnMgdGhhdCBhcmUgc3VnZ2VzdGluZyB0aGUgc2FtZSBuYW1lXG4gICAgICB2YXIgbmV3QXBpID0ge1xuICAgICAgICBuYW1lOiAnYXBpJyxcbiAgICAgICAgdmFsdWU6IGJsb2NrLm1vZGVPcHRpb25OYW1lIHx8IGJsb2NrLmZ1bmMsXG4gICAgICAgIHNjb3JlOiAxMDAsXG4gICAgICAgIG1ldGE6IGJsb2NrLmNhdGVnb3J5XG4gICAgICB9O1xuICAgICAgaWYgKG9wdHMuYXV0b2NvbXBsZXRlRnVuY3Rpb25zV2l0aFBhcmVucykge1xuICAgICAgICBuZXdBcGkuY29tcGxldGVyID0ge1xuICAgICAgICAgIGluc2VydE1hdGNoOiBmdW5jdGlvbiAodmFsdWUsIGVkaXRvcikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaWx0ZXJUZXh0IHRoYXQgd2FzIGFscmVhZHkgdHlwZWQgKGFjZSdzIGJ1aWx0LWluXG4gICAgICAgICAgICAvLyBpbnNlcnRNYXRjaCB3b3VsZCBub3JtYWxseSBkbyB0aGlzIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICBpZiAoZWRpdG9yLmNvbXBsZXRlci5jb21wbGV0aW9ucy5maWx0ZXJUZXh0KSB7XG4gICAgICAgICAgICAgIHZhciByYW5nZXMgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcmFuZ2U7ICEhKHJhbmdlID0gcmFuZ2VzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uIC09IGVkaXRvci5jb21wbGV0ZXIuY29tcGxldGlvbnMuZmlsdGVyVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmdW5jdGlvbiBuYW1lIHBsdXMgcGFyZW50aGVzZXMgYW5kIHNlbWljb2xvbjpcbiAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChcImluc2VydHN0cmluZ1wiLCB2YWx1ZSArICcoKTsnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBzZWxlY3Rpb24gYmFjayBzbyBwYXJhbWV0ZXJzIGNhbiBiZSBlbnRlcmVkOlxuICAgICAgICAgICAgICB2YXIgY3VyUmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnN0YXJ0LmNvbHVtbiAtPSAyO1xuICAgICAgICAgICAgICBjdXJSYW5nZS5lbmQuY29sdW1uIC09IDI7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UoY3VyUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0uYmluZChibG9jaywgbmV3QXBpLnZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG5ld0FwaS52YWx1ZS5pbmRleE9mKCcqLicpID09PSAwIHx8IG5ld0FwaS52YWx1ZS5pbmRleE9mKCc/LicpID09PSAwKSB7XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoaXMgaW4gYSBzcGVjaWFsIG1ldGhvZHNBbmRQcm9wZXJ0aWVzIGNvbGxlY3Rpb246XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIG5hbWUgaW4gYSBkb2NGdW5jIHByb3BlcnR5IGZvciB0aGVcbiAgICAgICAgLy8gYmVuZWZpdCBvZiBvdXIgRHJvcGxldEF1dG9jb21wbGV0ZVBvcHVwVG9vbHRpcE1hbmFnZXI6XG4gICAgICAgIG5ld0FwaS5kb2NGdW5jID0gbmV3QXBpLnZhbHVlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIHRvIHNraXAgb3ZlciB0aGUgJyouJyBvciAnPy4nIGF0IHRoZSBiZWdpbm5pbmc6XG4gICAgICAgIG5ld0FwaS52YWx1ZSA9IG5ld0FwaS52YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICAgIG1ldGhvZHNBbmRQcm9wZXJ0aWVzLnB1c2gobmV3QXBpKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQb3B1bGF0ZSB0aGlzIGluIHRoZSBcIm5vcm1hbFwiIGFwaXMgY29sbGVjdGlvbjpcbiAgICAgICAgYXBpcy5wdXNoKG5ld0FwaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQ29tcGxldGVyRnJvbVByZWRlZlZhbHVlcyhhcGlzLCBwcmVkZWZWYWx1ZXMpIHtcbiAgaWYgKHByZWRlZlZhbHVlcykge1xuICAgIHByZWRlZlZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIC8vIFVzZSBzY29yZSB2YWx1ZSBvZiAxMDAgdG8gZW5zdXJlIHRoYXQgb3VyIEFQSXMgYXJlIG5vdCByZXBsYWNlZCBieVxuICAgICAgLy8gb3RoZXIgY29tcGxldGVycyB0aGF0IGFyZSBzdWdnZXN0aW5nIHRoZSBzYW1lIG5hbWVcbiAgICAgIGFwaXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcGknLFxuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBzY29yZTogMTAwLFxuICAgICAgICBtZXRhOiAnY29uc3RhbnRzJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBhY2UgZWRpdG9yIGN1cnNvciBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbWV0aG9kXG4gKiBvciBwcm9wZXJ0eSAoYWZ0ZXIgYSBkb3QpLlxuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gQWNlIGVkaXRvciBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zIEFjZSBlZGl0b3IgcG9zaXRpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbWV0aG9kIG9yIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGlzUG9zaXRpb25BZnRlckRvdCAoc2Vzc2lvbiwgcG9zKSB7XG4gIHZhciBhY1V0aWwgPSB3aW5kb3cuYWNlLnJlcXVpcmUoXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIik7XG4gIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHBvcy5yb3cpO1xuICB2YXIgaWRlbnRpZmllciA9IGFjVXRpbC5yZXRyaWV2ZVByZWNlZGluZ0lkZW50aWZpZXIobGluZSwgcG9zLmNvbHVtbik7XG4gIC8vIElmIHdlJ3JlIHR5cGluZyBhIHZhbGlkIGlkZW50aWZpZXIsIGluc3BlY3QgdGhlIHByZWNlZWRpbmdcbiAgLy8gY2hhcmFjdGVyIHRvIHNlZSBpZiBpdCBpcyBhIHBlcmlvZCBhbmQgZW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3Qgb25lXG4gIC8vIGNoYXJhY3RlciBiZWZvcmVcbiAgaWYgKGlkZW50aWZpZXIubGVuZ3RoID4gMCAmJiBpZGVudGlmaWVyLmxlbmd0aCA8IHBvcy5jb2x1bW4pIHtcbiAgICAvLyBXZSBoYXZlIGFuIGlkZW50aWZpZXIgYW5kIGl0IGlzIHNob3J0ZXIgdGhhbiBvdXIgY29sdW1uIHBvc2l0aW9uIGluXG4gICAgLy8gdGhpcyBsaW5lLCB3aGljaCBtZWFucyBpdCBpcyBzYWZlIHRvIGNoZWNrIHRoZSBsaW5lW10gYmVmb3JlIHRoZVxuICAgIC8vIGlkZW50aWZpZXJcbiAgICB2YXIgcG9zQmVmb3JlSWRlbnRpZmllciA9IHBvcy5jb2x1bW4gLSBpZGVudGlmaWVyLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGxpbmVbcG9zQmVmb3JlSWRlbnRpZmllcl0gPT09ICcuJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gQWNlIGVkaXRvciBjb21wbGV0ZXIgZm9yIGEgc2V0IG9mIEFQSXMgYmFzZWQgb24gc29tZSBsZXZlbCBkYXRhLlxuICpcbiAqIElmIGZ1bmN0aW9uRmlsdGVyIGlzIG5vbi1udWxsLCB1c2UgaXQgdG8gZmlsdGVyIHRoZSBkcm9wbGV0Q29uZmlnXG4gKiBBUElzIHRvIGJlIHNldCBpbiBhdXRvY29tcGxldGUgYW5kIGNyZWF0ZSBubyBvdGhlciBhdXRvY29tcGxldGUgZW50cmllc1xuICovXG5leHBvcnRzLmdlbmVyYXRlQWNlQXBpQ29tcGxldGVyID0gZnVuY3Rpb24gKGZ1bmN0aW9uRmlsdGVyLCBkcm9wbGV0Q29uZmlnKSB7XG4gIHZhciBhcGlzID0gW107XG4gIHZhciBtZXRob2RzQW5kUHJvcGVydGllcyA9IFtdO1xuICB2YXIgb3B0cyA9IHt9O1xuXG4gIC8vIElmIGF1dG9jb21wbGV0ZUZ1bmN0aW9uc1dpdGhQYXJlbnMgaXMgc2V0LCB3ZSB3aWxsIGFwcGVuZCBcIigpO1wiIGFmdGVyIGZ1bmN0aW9uc1xuICBvcHRzLmF1dG9jb21wbGV0ZUZ1bmN0aW9uc1dpdGhQYXJlbnMgPSBkcm9wbGV0Q29uZmlnLmF1dG9jb21wbGV0ZUZ1bmN0aW9uc1dpdGhQYXJlbnM7XG5cbiAgaWYgKGZ1bmN0aW9uRmlsdGVyKSB7XG4gICAgdmFyIG1lcmdlZEJsb2NrcyA9IGZpbHRlcmVkQmxvY2tzRnJvbUNvbmZpZyhmdW5jdGlvbkZpbHRlciwgZHJvcGxldENvbmZpZywgbnVsbCwgeyBwYWxldHRlT25seTogdHJ1ZSB9KTtcbiAgICBwb3B1bGF0ZUNvbXBsZXRlckFwaXNGcm9tQ29uZmlnQmxvY2tzKG9wdHMsIGFwaXMsIG1ldGhvZHNBbmRQcm9wZXJ0aWVzLCBtZXJnZWRCbG9ja3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcHVsYXRlQ29tcGxldGVyQXBpc0Zyb21Db25maWdCbG9ja3Mob3B0cywgYXBpcywgbWV0aG9kc0FuZFByb3BlcnRpZXMsIGV4cG9ydHMuZHJvcGxldEdsb2JhbENvbmZpZ0Jsb2Nrcyk7XG4gICAgcG9wdWxhdGVDb21wbGV0ZXJBcGlzRnJvbUNvbmZpZ0Jsb2NrcyhvcHRzLCBhcGlzLCBtZXRob2RzQW5kUHJvcGVydGllcywgZXhwb3J0cy5kcm9wbGV0QnVpbHRpbkNvbmZpZ0Jsb2Nrcyk7XG4gICAgcG9wdWxhdGVDb21wbGV0ZXJBcGlzRnJvbUNvbmZpZ0Jsb2NrcyhvcHRzLCBhcGlzLCBtZXRob2RzQW5kUHJvcGVydGllcywgZHJvcGxldENvbmZpZy5ibG9ja3MpO1xuICAgIHBvcHVsYXRlQ29tcGxldGVyRnJvbVByZWRlZlZhbHVlcyhhcGlzLCBkcm9wbGV0Q29uZmlnLmFkZGl0aW9uYWxQcmVkZWZWYWx1ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRDb21wbGV0aW9uczogZnVuY3Rpb24oZWRpdG9yLCBzZXNzaW9uLCBwb3MsIHByZWZpeCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzUG9zaXRpb25BZnRlckRvdChzZXNzaW9uLCBwb3MpKSB7XG4gICAgICAgIC8vIEZvbGxvd2luZyBhIGRvdCwgd2UgYXV0b2NvbXBsZXRlIGZyb20gbWV0aG9kc0FuZFByb3BlcnRpZXM6XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGhvZHNBbmRQcm9wZXJ0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGFwaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBkcm9wbGV0IGNvbmZpZywgY3JlYXRlIGEgbW9kZSBvcHRpb24gZnVuY3Rpb25zIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3RbXX0gY29uZmlnLmJsb2Nrc1xuICogQHBhcmFtIHtvYmplY3RbXX0gY29uZmlnLmNhdGVnb3JpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZU9wdGlvbkZ1bmN0aW9uc0Zyb21Db25maWcoY29uZmlnKSB7XG4gIHZhciBtZXJnZWRDYXRlZ29yaWVzID0gbWVyZ2VDYXRlZ29yaWVzV2l0aENvbmZpZyhjb25maWcpO1xuXG4gIHZhciBtb2RlT3B0aW9uRnVuY3Rpb25zID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5ld0Z1bmMgPSB7fTtcblxuICAgIGlmIChjb25maWcuYmxvY2tzW2ldLnR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgIG5ld0Z1bmMudmFsdWUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmJsb2Nrc1tpXS50eXBlID09PSAnZWl0aGVyJykge1xuICAgICAgbmV3RnVuYy52YWx1ZSA9IHRydWU7XG4gICAgICBuZXdGdW5jLmNvbW1hbmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmJsb2Nrc1tpXS50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICBuZXdGdW5jLnByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgIG5ld0Z1bmMudmFsdWUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjYXRlZ29yeSA9IG1lcmdlZENhdGVnb3JpZXNbY29uZmlnLmJsb2Nrc1tpXS5jYXRlZ29yeV07XG4gICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICBuZXdGdW5jLmNvbG9yID0gY2F0ZWdvcnkucmdiIHx8IGNhdGVnb3J5LmNvbG9yO1xuICAgIH1cblxuICAgIG5ld0Z1bmMuZHJvcGRvd24gPSBjb25maWcuYmxvY2tzW2ldLmRyb3Bkb3duO1xuXG4gICAgdmFyIG1vZGVPcHRpb25OYW1lID0gY29uZmlnLmJsb2Nrc1tpXS5tb2RlT3B0aW9uTmFtZSB8fCBjb25maWcuYmxvY2tzW2ldLmZ1bmM7XG4gICAgbmV3RnVuYy50aXRsZSA9IG1vZGVPcHRpb25OYW1lO1xuXG4gICAgbW9kZU9wdGlvbkZ1bmN0aW9uc1ttb2RlT3B0aW9uTmFtZV0gPSBuZXdGdW5jO1xuICB9XG4gIHJldHVybiBtb2RlT3B0aW9uRnVuY3Rpb25zO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIG1vZGVPcHRpb25zIGZvciB0aGUgZHJvcGxldCBlZGl0b3IgYmFzZWQgb24gc29tZSBsZXZlbCBkYXRhLlxuICovXG5leHBvcnRzLmdlbmVyYXRlRHJvcGxldE1vZGVPcHRpb25zID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgbW9kZU9wdGlvbnMgPSB7XG4gICAgZnVuY3Rpb25zOiB7XG4gICAgfSxcbiAgICBjYXRlZ29yaWVzOiB7XG4gICAgICBhcml0aG1ldGljOiB7IGNvbG9yOiBDT0xPUl9PUkFOR0UgfSxcbiAgICAgIGxvZ2ljOiB7IGNvbG9yOiBDT0xPUl9PUkFOR0UgfSxcbiAgICAgIGNvbmRpdGlvbmFsczogeyBjb2xvcjogQ09MT1JfQkxVRSB9LFxuICAgICAgbG9vcHM6IHtcbiAgICAgICAgY29sb3I6IENPTE9SX0JMVUUsXG4gICAgICAgIGJlZ2lubmVyOiBjb25maWcubGV2ZWwuYmVnaW5uZXJNb2RlIHx8IGZhbHNlXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb25zOiB7IGNvbG9yOiBDT0xPUl9HUkVFTiB9LFxuICAgICAgcmV0dXJuczogeyBjb2xvcjogQ09MT1JfR1JFRU4gfSxcbiAgICAgIGNvbW1lbnRzOiB7IGNvbG9yOiBDT0xPUl9XSElURSB9LFxuICAgICAgY29udGFpbmVyczogeyBjb2xvcjogQ09MT1JfUFVSUExFIH0sXG4gICAgICB2YWx1ZTogeyBjb2xvcjogQ09MT1JfUFVSUExFIH0sXG4gICAgICBjb21tYW5kOiB7IGNvbG9yOiBDT0xPUl9HUkVFTiB9LFxuICAgICAgYXNzaWdubWVudHM6IHsgY29sb3I6IENPTE9SX1BVUlBMRSB9XG4gICAgICAvLyBlcnJvcnM6IHsgfSxcbiAgICB9LFxuICAgIGxvY2taZXJvUGFyYW1GdW5jdGlvbnM6IGNvbmZpZy5sZXZlbC5sb2NrWmVyb1BhcmFtRnVuY3Rpb25zXG4gIH07XG5cbiAgJC5leHRlbmQobW9kZU9wdGlvbnMuZnVuY3Rpb25zLFxuICAgIGdldE1vZGVPcHRpb25GdW5jdGlvbnNGcm9tQ29uZmlnKHsgYmxvY2tzOiBleHBvcnRzLmRyb3BsZXRHbG9iYWxDb25maWdCbG9ja3MgfSksXG4gICAgZ2V0TW9kZU9wdGlvbkZ1bmN0aW9uc0Zyb21Db25maWcoeyBibG9ja3M6IGV4cG9ydHMuZHJvcGxldEJ1aWx0aW5Db25maWdCbG9ja3MgfSksXG4gICAgZ2V0TW9kZU9wdGlvbkZ1bmN0aW9uc0Zyb21Db25maWcoY29uZmlnLmRyb3BsZXRDb25maWcpXG4gICk7XG5cbiAgcmV0dXJuIG1vZGVPcHRpb25zO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IG9mIGFsbCBibG9ja3NcbiAqIEBwYXJhbSB7RHJvcGxldENvbmZpZ3xudWxsfSBkcm9wbGV0Q29uZmlnIGN1c3RvbSBjb25maWd1cmF0aW9uLCBtYXkgYmUgbnVsbFxuICogQHBhcmFtIHtjb2RlRnVuY3Rpb25zfG51bGx9IGNvZGVGdW5jdGlvbnMgd2l0aCBibG9jayBvdmVycmlkZXMsIG1heSBiZSBudWxsXG4gKiBAcGFyYW0gcGFsZXR0ZU9ubHkgYm9vbGVhbjogZmlsdGVyIHRvIG9ubHkgdGhvc2UgYmxvY2tzIHRoYXQgYXJlIGluIGNvZGVGdW5jdGlvbnNcbiAqICAgcGFsZXR0ZSwgb3Igd2hvIHNoYXJlIGRvY3VtZW50YXRpb24gKHZpYSBkb2NGdW5jKSB3aXRoIG90aGVyIGJsb2NrcyB0aGF0IGFyZVxuICogQHJldHVybnMge0Ryb3BsZXRCbG9ja1tdfSBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBEcm9wbGV0IGJsb2NrcyxcbiAqICAgICAgaW5jbHVkaW5nIHRoZSBnaXZlbiBjb25maWcncyBibG9ja3NcbiAqL1xuZXhwb3J0cy5nZXRBbGxBdmFpbGFibGVEcm9wbGV0QmxvY2tzID0gZnVuY3Rpb24gKGRyb3BsZXRDb25maWcsIGNvZGVGdW5jdGlvbnMsIHBhbGV0dGVPbmx5KSB7XG4gIHZhciBoYXNDb25maWd1cmVkQmxvY2tzID0gZHJvcGxldENvbmZpZyAmJiBkcm9wbGV0Q29uZmlnLmJsb2NrcztcbiAgdmFyIGNvbmZpZ3VyZWRCbG9ja3MgPSBoYXNDb25maWd1cmVkQmxvY2tzID8gZHJvcGxldENvbmZpZy5ibG9ja3MgOiBbXTtcbiAgaWYgKGNvZGVGdW5jdGlvbnMgJiYgaGFzQ29uZmlndXJlZEJsb2Nrcykge1xuICAgIGNvbmZpZ3VyZWRCbG9ja3MgPSBmaWx0ZXJlZEJsb2Nrc0Zyb21Db25maWcoXG4gICAgICAgIGNvZGVGdW5jdGlvbnMsXG4gICAgICAgIGRyb3BsZXRDb25maWcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHsgcGFsZXR0ZU9ubHk6IHBhbGV0dGVPbmx5IH1cbiAgICApO1xuICB9XG4gIHJldHVybiBleHBvcnRzLmRyb3BsZXRHbG9iYWxDb25maWdCbG9ja3NcbiAgICAuY29uY2F0KGV4cG9ydHMuZHJvcGxldEJ1aWx0aW5Db25maWdCbG9ja3MpXG4gICAgLmNvbmNhdChzdGFuZGFyZENvbmZpZy5ibG9ja3MpXG4gICAgLmNvbmNhdChjb25maWd1cmVkQmxvY2tzKTtcbn07XG5cbmV4cG9ydHMuX19UZXN0SW50ZXJmYWNlID0ge1xuICBtZXJnZUNhdGVnb3JpZXNXaXRoQ29uZmlnOiBtZXJnZUNhdGVnb3JpZXNXaXRoQ29uZmlnLFxuICBmaWx0ZXJlZEJsb2Nrc0Zyb21Db25maWc6IGZpbHRlcmVkQmxvY2tzRnJvbUNvbmZpZ1xufTtcbiIsIi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgc3Vic2NyaXB0aW9uL25vdGlmaWNhdGlvbiBhdG9tLCB1c2VkIHRvIGNsZWFubHkgaG9vayB1cCBjYWxsYmFja3NcbiAqIHdpdGhvdXQgYXR0YWNoaW5nIGFueXRoaW5nIHRvIHRoZSBET00gb3Igb3RoZXIgZ2xvYmFsIHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPYnNlcnZhYmxlRXZlbnQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIE9iamVjdHMgb2JzZXJ2aW5nIHRoaXMuXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMub2JzZXJ2ZXJMaXN0XyA9IFtdO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgYSBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gbm90aWZ5T2JzZXJ2ZXJzIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uTm90aWZ5IC0gbWV0aG9kIGNhbGxlZCB3aGVuIG5vdGlmeU9ic2VydmVycyBnZXRzIGNhbGxlZC5cbiAqICAgICAgICBXaWxsIHJlY2VpdmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gbm90aWZ5T2JzZXJ2ZXJzLlxuICogQHJldHVybnMge09iamVjdH0ga2V5IC0gdXNlZCB0byB1bnJlZ2lzdGVyIGZyb20gb2JzZXJ2YWJsZVxuICovXG5PYnNlcnZhYmxlRXZlbnQucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9uTm90aWZ5KSB7XG4gIHZhciBrZXkgPSB7dG9DYWxsOm9uTm90aWZ5fTtcbiAgT2JqZWN0LmZyZWV6ZShrZXkpO1xuICB0aGlzLm9ic2VydmVyTGlzdF8ucHVzaChrZXkpO1xuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIG5vdGlmaWNhdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5T2JqIC0gS2V5IGdlbmVyYXRlZCB3aGVuIHJlZ2lzdGVyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIGFuIHVucmVnaXN0cmF0aW9uIGFjdHVhbGx5IG9jY3VycmVkXG4gKi9cbk9ic2VydmFibGVFdmVudC5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXlPYmopIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVyTGlzdF8ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5T2JqID09PSB0aGlzLm9ic2VydmVyTGlzdF9baV0pIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJMaXN0Xy5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBtZXRob2RzIHN1YnNjcmliZWQgdG8gdGhpcyBPYnNlcnZhYmxlRXZlbnQsIHBhc3NpbmcgdGhyb3VnaFxuICogYW55IGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7Li4ufSBBbnkgYXJndW1lbnRzLCB3aGljaCBhcmUgcGFzc2VkIHRocm91Z2ggdG8gdGhlIG9ic2VydmluZ1xuICogICAgICAgICAgICAgIGZ1bmN0aW9ucy5cbiAqL1xuT2JzZXJ2YWJsZUV2ZW50LnByb3RvdHlwZS5ub3RpZnlPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuICB0aGlzLm9ic2VydmVyTGlzdF8uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci50b0NhbGwuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSk7XG59OyIsIi8vIFN0cmljdCBsaW50aW5nOiBBYnNvcmIgaW50byBnbG9iYWwgY29uZmlnIHdoZW4gcG9zc2libGVcbi8qIGpzaGludFxuIHVudXNlZDogdHJ1ZSxcbiBlcWVxZXE6IHRydWUsXG4gbWF4bGVuOiAxMjBcbiAqL1xuXG52YXIgaTE4biA9IHJlcXVpcmUoJy4vbG9jYWxlJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWJ1ZyBhcmVhIGNvbnRyb2xsZXIgYW5kIGNvbmZpZ3VyZXMgaXQgdG8gb3BlcmF0ZSBvbiB0aGUgZ2l2ZW5cbiAqIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGRlYnVnQXJlYVJvb3RcbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvZGVUZXh0Ym94Um9vdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEZWJ1Z0FyZWEgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZWJ1Z0FyZWFSb290LCBjb2RlVGV4dGJveFJvb3QpIHtcbiAgaWYgKCFkZWJ1Z0FyZWFSb290IHx8ICFjb2RlVGV4dGJveFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWJ1Z0FyZWFSb290IGFuZCBjb2RlVGV4dGJveFJvb3QgYXJlIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtqUXVlcnl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3REaXZfID0gJChkZWJ1Z0FyZWFSb290KTtcblxuICAvKipcbiAgICogQHR5cGUge2pRdWVyeX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY29kZVRleHRib3hfID0gJChjb2RlVGV4dGJveFJvb3QpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuaXNPcGVuXyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmxhc3RPcGVuSGVpZ2h0XyA9IHRoaXMucm9vdERpdl8uaGVpZ2h0KCk7XG5cbiAgRGVidWdBcmVhLnByb3RvdHlwZS5iaW5kSGFuZGxlcnNGb3JEZWJ1Z0NvbW1hbmRzSGVhZGVyLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIEJpbmRzIG1vdXNlb3ZlciwgbW91c2VvdXQsIGNsaWNrIGFuZCB0b3VjaCBoYW5kbGVycyBmb3IgdGhlIGRlYnVnIGNvbW1hbmRzXG4gKiBoZWFkZXIgZGl2LlxuICovXG5EZWJ1Z0FyZWEucHJvdG90eXBlLmJpbmRIYW5kbGVyc0ZvckRlYnVnQ29tbWFuZHNIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2dnbGVEZWJ1Z0ljb24gPSB0aGlzLnJvb3REaXZfLmZpbmQoJyNzaG93LWhpZGUtZGVidWctaWNvbicpO1xuICBkb20uYWRkQ2xpY2tUb3VjaEV2ZW50KHRvZ2dsZURlYnVnSWNvblswXSwgRGVidWdBcmVhLnByb3RvdHlwZS5zbGlkZVRvZ2dsZS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbkRlYnVnQXJlYS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc09wZW5fO1xufTtcblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuRGVidWdBcmVhLnByb3RvdHlwZS5pc1NodXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc09wZW5fO1xufTtcblxuLyoqXG4gKiBPcGVuL2Nsb3NlIHRoZSBkZWJ1ZyBhcmVhIHRvIHRoZSByZXZlcnNlIG9mIGl0cyBjdXJyZW50IHN0YXRlLCB1c2luZyBub1xuICogYW5pbWF0aW9uLlxuICovXG5EZWJ1Z0FyZWEuc25hcFRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgIHRoaXMuc25hcFNodXQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNuYXBPcGVuKCk7XG4gIH1cbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc25hcE9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIHRoaXMuc2V0Q29udGVudHNWaXNpYmxlKHRydWUpO1xuICB0aGlzLnNldEljb25Qb2ludGluZ0Rvd24odHJ1ZSk7XG4gIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFzdE9wZW5IZWlnaHRfKTtcblxuICAvLyBTZXQgdGhlICdjbGVhcicgYnV0dG9uIHZpc2libGVcbiAgdGhpcy5yb290RGl2Xy5maW5kKCcjY2xlYXItY29uc29sZS1oZWFkZXInKVxuICAgICAgLmNzcygnb3BhY2l0eScsIDEpXG4gICAgICAuY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc25hcFNodXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICB0aGlzLmxhc3RPcGVuSGVpZ2h0XyA9IHRoaXMucm9vdERpdl8uaGVpZ2h0KCk7XG4gIHRoaXMuc2V0Q29udGVudHNWaXNpYmxlKGZhbHNlKTtcbiAgdGhpcy5zZXRJY29uUG9pbnRpbmdEb3duKGZhbHNlKTtcbiAgdGhpcy5zZXRIZWlnaHQodGhpcy5nZXRIZWlnaHRXaGVuQ2xvc2VkKCkpO1xuXG4gIC8vIFNldCB0aGUgJ2NsZWFyJyBidXR0b24gaGlkZGVuIChub3QgZGlzcGxheTpub25lLCBpdCBzaG91bGQgdGFrZSB1cCBzcGFjZSlcbiAgdGhpcy5yb290RGl2Xy5maW5kKCcjY2xlYXItY29uc29sZS1oZWFkZXInKVxuICAgICAgLmNzcygnb3BhY2l0eScsIDApXG4gICAgICAuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xufTtcblxuLyoqXG4gKiBPcGVuL2Nsb3NlIHRoZSBkZWJ1ZyBhcmVhIHRvIHRoZSByZXZlcnNlIG9mIGl0cyBjdXJyZW50IHN0YXRlLCB1c2luZyBhXG4gKiBzbGlkZSBhbmltYXRpb24uXG4gKi9cbkRlYnVnQXJlYS5wcm90b3R5cGUuc2xpZGVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICB0aGlzLnNsaWRlU2h1dCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2xpZGVPcGVuKCk7XG4gIH1cbn07XG5cbkRlYnVnQXJlYS5wcm90b3R5cGUuc2xpZGVPcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB0aGlzLnNldENvbnRlbnRzVmlzaWJsZSh0cnVlKTtcblxuICAvLyBNYW51YWxseSByZW1vdmUgaG92ZXIgZWZmZWN0IGF0IHN0YXJ0IGFuZCBlbmQgb2YgYW5pbWF0aW9uIHRvIGdldCAqY2xvc2UqXG4gIC8vIHRvIHRoZSBjb3JyZWN0IGVmZmVjdC5cbiAgdGhpcy5yb290RGl2Xy5hbmltYXRlKHtcbiAgICBoZWlnaHQ6IHRoaXMubGFzdE9wZW5IZWlnaHRfXG4gIH0se1xuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNldEljb25Qb2ludGluZ0Rvd24odHJ1ZSk7XG4gICAgfS5iaW5kKHRoaXMpXG4gIH0pO1xuXG4gIC8vIEFuaW1hdGUgdGhlIGJvdHRvbSBvZiB0aGUgd29ya3NwYWNlIGF0IHRoZSBzYW1lIHRpbWVcbiAgdGhpcy5jb2RlVGV4dGJveF8uYW5pbWF0ZSh7XG4gICAgYm90dG9tOiB0aGlzLmxhc3RPcGVuSGVpZ2h0X1xuICB9LHtcbiAgICBzdGVwOiB1dGlscy5maXJlUmVzaXplRXZlbnRcbiAgfSk7XG5cbiAgLy8gQW5pbWF0ZSB0aGUgJ2NsZWFyJyBidXR0b24gYXBwZWFyaW5nIGF0IHRoZSBzYW1lIHRpbWVcbiAgdmFyIGNsZWFyQnV0dG9uID0gdGhpcy5yb290RGl2Xy5maW5kKCcjY2xlYXItY29uc29sZS1oZWFkZXInKTtcbiAgY2xlYXJCdXR0b24uY3NzKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgY2xlYXJCdXR0b24uYW5pbWF0ZSh7XG4gICAgb3BhY2l0eTogMS4wXG4gIH0pO1xufTtcblxuRGVidWdBcmVhLnByb3RvdHlwZS5zbGlkZVNodXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICB0aGlzLmxhc3RPcGVuSGVpZ2h0XyA9IHRoaXMucm9vdERpdl8uaGVpZ2h0KCk7XG5cbiAgLy8gV2Ugd2lsbCBsZWF2ZSB0aGUgaGVhZGVyIGFuZCByZXNpemUgYmFyIHZpc2libGUsIHNvIHRvZ2V0aGVyIHRoZXlcbiAgLy8gY29uc3RpdHV0ZSBvdXIgaGVpZ2h0IHdoZW4gY2xvc2VkLlxuICB2YXIgY2xvc2VkSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRXaGVuQ2xvc2VkKCk7XG4gIC8vIE1hbnVhbGx5IHJlbW92ZSBob3ZlciBlZmZlY3QgYXQgc3RhcnQgYW5kIGVuZCBvZiBhbmltYXRpb24gdG8gZ2V0ICpjbG9zZSpcbiAgLy8gdG8gdGhlIGNvcnJlY3QgZWZmZWN0LlxuICB0aGlzLnJvb3REaXZfLmFuaW1hdGUoe1xuICAgIGhlaWdodDogY2xvc2VkSGVpZ2h0XG4gIH0se1xuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNldENvbnRlbnRzVmlzaWJsZShmYWxzZSk7XG4gICAgICB0aGlzLnNldEljb25Qb2ludGluZ0Rvd24oZmFsc2UpO1xuICAgIH0uYmluZCh0aGlzKVxuICB9KTtcblxuICAvLyBBbmltYXRlIHRoZSBib3R0b20gb2YgdGhlIHdvcmtzcGFjZSBhdCB0aGUgc2FtZSB0aW1lXG4gIHRoaXMuY29kZVRleHRib3hfLmFuaW1hdGUoe1xuICAgIGJvdHRvbTogY2xvc2VkSGVpZ2h0XG4gIH0se1xuICAgIHN0ZXA6IHV0aWxzLmZpcmVSZXNpemVFdmVudCxcbiAgICBjb21wbGV0ZTogdXRpbHMuZmlyZVJlc2l6ZUV2ZW50XG4gIH0pO1xuXG4gIC8vIEFuaW1hdGUgdGhlICdjbGVhcicgYnV0dG9uIHZhbmlzaGluZyBhdCB0aGUgc2FtZSB0aW1lXG4gIHZhciBjbGVhckJ1dHRvbiA9IHRoaXMucm9vdERpdl8uZmluZCgnI2NsZWFyLWNvbnNvbGUtaGVhZGVyJyk7XG4gIGNsZWFyQnV0dG9uLmFuaW1hdGUoe1xuICAgIG9wYWNpdHk6IDAuMFxuICB9LHtcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJCdXR0b24uY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5EZWJ1Z0FyZWEucHJvdG90eXBlLnNldENvbnRlbnRzVmlzaWJsZSA9IGZ1bmN0aW9uIChpc1Zpc2libGUpIHtcbiAgdGhpcy5yb290RGl2Xy5maW5kKCcjZGVidWctY29tbWFuZHMnKS50b2dnbGUoaXNWaXNpYmxlKTtcbiAgdGhpcy5yb290RGl2Xy5maW5kKCcjZGVidWctY29uc29sZScpLnRvZ2dsZShpc1Zpc2libGUpO1xufTtcblxuRGVidWdBcmVhLnByb3RvdHlwZS5zZXRJY29uUG9pbnRpbmdEb3duID0gZnVuY3Rpb24gKGlzUG9pbnRpbmdEb3duKSB7XG4gIHZhciBjb21tYW5kc0hlYWRlciA9IHRoaXMucm9vdERpdl8uZmluZCgnI2RlYnVnLWNvbW1hbmRzLWhlYWRlcicpO1xuXG4gIHZhciBpY29uID0gdGhpcy5yb290RGl2Xy5maW5kKCcjc2hvdy1oaWRlLWRlYnVnLWljb24nKTtcbiAgaWNvbi50b2dnbGVDbGFzcygnZmEtY2hldnJvbi1jaXJjbGUtdXAnLCAhaXNQb2ludGluZ0Rvd24pO1xuICBpY29uLnRvZ2dsZUNsYXNzKCdmYS1jaGV2cm9uLWNpcmNsZS1kb3duJywgaXNQb2ludGluZ0Rvd24pO1xuXG4gIHZhciBoZWFkZXJUZXh0ID0gY29tbWFuZHNIZWFkZXIuZmluZCgnLmhlYWRlci10ZXh0Jyk7XG4gIGhlYWRlclRleHQudGV4dChpc1BvaW50aW5nRG93biA/IGkxOG4uZGVidWdDb21tYW5kc0hlYWRlcldoZW5PcGVuKCkgOlxuICAgICAgaTE4bi5kZWJ1Z0NvbW1hbmRzSGVhZGVyV2hlbkNsb3NlZCgpKTtcblxufTtcblxuRGVidWdBcmVhLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAobmV3SGVpZ2h0SW5QaXhlbHMpIHtcbiAgdGhpcy5yb290RGl2Xy5oZWlnaHQobmV3SGVpZ2h0SW5QaXhlbHMpO1xuICB0aGlzLmNvZGVUZXh0Ym94Xy5jc3MoJ2JvdHRvbScsIG5ld0hlaWdodEluUGl4ZWxzKTtcbiAgdXRpbHMuZmlyZVJlc2l6ZUV2ZW50KCk7XG59O1xuXG5EZWJ1Z0FyZWEucHJvdG90eXBlLmdldEhlaWdodFdoZW5DbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3REaXZfLmZpbmQoJyNkZWJ1Zy1hcmVhLWhlYWRlcicpLmhlaWdodCgpICtcbiAgICAgIHRoaXMucm9vdERpdl8uZmluZCgnI2RlYnVnUmVzaXplQmFyJykuaGVpZ2h0KCk7XG59O1xuIiwiLyogZ2xvYmFsIGRlZmluZSAqL1xuLy8gU3RyaWN0IGxpbnRpbmc6IEFic29yYiBpbnRvIGdsb2JhbCBjb25maWcgd2hlbiBwb3NzaWJsZVxuLyoganNoaW50XG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcbiBtYXhsZW46IDEyMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYXZlZEFtZDtcblxuLy8gRG8gc29tZSBoYWNrZXJ5IHRvIG1ha2UgaXQgc28gdGhhdCBsb2Rhc2ggZG9lc24ndCB0aGluayBpdCdzIGJlaW5nIGxvYWRlZFxuLy8gdmlhIHJlcXVpcmUganNcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gIHNhdmVkQW1kID0gZGVmaW5lLmFtZDtcbiAgZGVmaW5lLmFtZCA9IGZhbHNlO1xufVxuXG4vLyBnZXQgbG9kYXNoXG52YXIgXyA9IHJlcXVpcmUoJy4vbG9kYXNoJyk7XG52YXIgSGFtbWVyID0gcmVxdWlyZSgnLi9oYW1tZXInKTtcblxuLy8gdW5kbyBoYWNrZXJ5XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzYXZlZEFtZCkge1xuICBkZWZpbmUuYW1kID0gc2F2ZWRBbWQ7XG4gIHNhdmVkQW1kID0gbnVsbDtcbn1cblxuZXhwb3J0cy5nZXRMb2Rhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfO1xufTtcblxuZXhwb3J0cy5nZXRIYW1tZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBIYW1tZXI7XG59O1xuXG5leHBvcnRzLnNoYWxsb3dDb3B5ID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICByZXN1bHRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9iamVjdCwgc3RyaXBwaW5nIGFueSBmdW5jdGlvbnMgb24gaXQuXG4gKi9cbmV4cG9ydHMuY2xvbmVXaXRob3V0RnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYSBkb3VibGUgcXVvdGUgYmVmb3JlIGFuZCBhZnRlci5cbiAqL1xuZXhwb3J0cy5xdW90ZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gJ1wiJyArIHN0ciArICdcIic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgZnJvbSBkZWZhdWx0cyBvdmVycmlkZGVuIGJ5IGFueVxuICogcHJvcGVydGllcyBpbiBvcHRpb25zLiBMZWF2ZXMgZGVmYXVsdHMgYW5kIG9wdGlvbnMgdW5jaGFuZ2VkLlxuICogTk9URTogRm9yIG5ldyBjb2RlLCB1c2UgJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKSBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgdmFyIGZpbmFsT3B0aW9ucyA9IGV4cG9ydHMuc2hhbGxvd0NvcHkoZGVmYXVsdHMpO1xuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBmaW5hbE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsT3B0aW9ucztcbn07XG5cbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKHVuc2FmZSkge1xuICByZXR1cm4gdW5zYWZlXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xufTtcblxuLyoqXG4gKiBWZXJzaW9uIG9mIG1vZHVsbyB3aGljaCwgdW5saWtlIGphdmFzY3JpcHQncyBgJWAgb3BlcmF0b3IsXG4gKiB3aWxsIGFsd2F5cyByZXR1cm4gYSBwb3NpdGl2ZSByZW1haW5kZXIuXG4gKiBAcGFyYW0gbnVtYmVyXG4gKiBAcGFyYW0gbW9kXG4gKi9cbmV4cG9ydHMubW9kID0gZnVuY3Rpb24obnVtYmVyLCBtb2QpIHtcbiAgcmV0dXJuICgobnVtYmVyICUgbW9kKSArIG1vZCkgJSBtb2Q7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBpbnRlZ2VycyBmcm9tIHN0YXJ0IHRvIGVuZCBpbmNsdXNpdmVcbiAqL1xuZXhwb3J0cy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGludHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgaW50cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBpbnRzO1xufTtcblxuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zLCBnZW5lcmF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGVcbiAqIHNlY29uZCBmdW5jdGlvbiBpZiBhbmQgb25seSBpZiB0aGUgZmlyc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlXG4gKi9cbmV4cG9ydHMuZXhlY3V0ZUlmQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmRpdGlvbmFsKCkpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAqIEBwYXJhbSBpbnB1dFN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIHdpdGhvdXQgcXVvdGVzXG4gKi9cbmV4cG9ydHMuc3RyaXBRdW90ZXMgPSBmdW5jdGlvbihpbnB1dFN0cmluZykge1xuICByZXR1cm4gaW5wdXRTdHJpbmcucmVwbGFjZSgvW1wiJ10vZywgXCJcIik7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYW4gaW5oZXJpdGFuY2UgcmVsYXRpb25zaGlwIGJldHdlZW4gcGFyZW50IGNsYXNzIGFuZCB0aGlzIGNsYXNzLlxuICovXG5GdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHRoaXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0aGlzO1xuICB0aGlzLnN1cGVyUHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbn07XG5cbi8qKlxuICogV3JhcCBhIGNvdXBsZSBvZiBvdXIgQmxvY2tseSBudW1iZXIgdmFsaWRhdG9ycyB0byBhbGxvdyBmb3IgPz8/LiAgVGhpcyBpc1xuICogZG9uZSBzbyB0aGF0IGxldmVsIGJ1aWxkZXJzIGNhbiBzcGVjaWZ5IHJlcXVpcmVkIGJsb2NrcyB3aXRoIHdpbGRjYXJkIGZpZWxkcy5cbiAqL1xuZXhwb3J0cy53cmFwTnVtYmVyVmFsaWRhdG9yc0ZvckxldmVsQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vbk5lZyA9IEJsb2NrbHkuRmllbGRUZXh0SW5wdXQubm9ubmVnYXRpdmVJbnRlZ2VyVmFsaWRhdG9yO1xuICB2YXIgbnVtVmFsID0gQmxvY2tseS5GaWVsZFRleHRJbnB1dC5udW1iZXJWYWxpZGF0b3I7XG5cbiAgQmxvY2tseS5GaWVsZFRleHRJbnB1dC5ub25uZWdhdGl2ZUludGVnZXJWYWxpZGF0b3IgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSAnPz8/Jykge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBub25OZWcodGV4dCk7XG4gIH07XG5cbiAgQmxvY2tseS5GaWVsZFRleHRJbnB1dC5udW1iZXJWYWxpZGF0b3IgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSAnPz8/Jykge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudW1WYWwodGV4dCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybiBhIHJhbmRvbSBrZXkgbmFtZSBmcm9tIGFuIG9iamVjdC5cbiAqXG4gKiBTbGlnaHRseSBtb2RpZmllZCBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTEwNjU0MVxuICovXG5cbmV4cG9ydHMucmFuZG9tS2V5ID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIHJldHVybiBrZXlzW2tleXMubGVuZ3RoICogTWF0aC5yYW5kb20oKSA8PCAwXTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gaWRlbnRpZmllciBpbiBhIGZvcm1hdCBtYXRjaGluZyB0aGUgUkZDLTQxMjIgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBUYWtlbiBmcm9tXG4gKiB7QGxpbmsgaHR0cDovL2J5cm9uc2FsYXUuY29tL2Jsb2cvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0L31cbiAqXG4gKiBAc2VlIFJGQy00MTIyIHN0YW5kYXJkIHtAbGluayBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dH1cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSRkM0MTIyLWNvbXBsaWFudCBVVUlEXG4gKi9cbmV4cG9ydHMuY3JlYXRlVXVpZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmZpcmVSZXNpemVFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gIGV2LmluaXRFdmVudCgncmVzaXplJywgdHJ1ZSwgdHJ1ZSk7XG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2KTtcbn07XG5cbi8vIEVDTUFTY3JpcHQgNiBwb2x5ZmlsbCBmb3IgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRcbi8vIFBvbHlmaWxsIGFkYXB0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2Vcbi8vICAgICAgICAvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuICAvKipcbiAgICogVGhlIHJlcGVhdCgpIG1ldGhvZCBjb25zdHJ1Y3RzIGFuZCByZXR1cm5zIGEgbmV3IHN0cmluZyB3aGljaCBjb250YWluc1xuICAgKiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHN0cmluZyBvbiB3aGljaCBpdCB3YXMgY2FsbGVkLFxuICAgKiBjb25jYXRlbmF0ZWQgdG9nZXRoZXI/XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5cXCd0IGNvbnZlcnQgJyArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICB2YXIgc3RyID0gJycgKyB0aGlzO1xuICAgIGNvdW50ID0gK2NvdW50O1xuICAgIGlmIChjb3VudCAhPT0gY291bnQpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcGVhdCBjb3VudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVwZWF0IGNvdW50IG11c3QgYmUgbGVzcyB0aGFuIGluZmluaXR5Jyk7XG4gICAgfVxuICAgIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gRW5zdXJpbmcgY291bnQgaXMgYSAzMS1iaXQgaW50ZWdlciBhbGxvd3MgdXMgdG8gaGVhdmlseSBvcHRpbWl6ZSB0aGVcbiAgICAvLyBtYWluIHBhcnQuIEJ1dCBhbnl3YXksIG1vc3QgY3VycmVudCAoYXVndXN0IDIwMTQpIGJyb3dzZXJzIGNhbid0IGhhbmRsZVxuICAgIC8vIHN0cmluZ3MgMSA8PCAyOCBjaGFycyBvciBsb25nZXIsIHNvOlxuICAgIGlmIChzdHIubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcGVhdCBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJyk7XG4gICAgfVxuICAgIHZhciBycHQgPSAnJztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgcnB0ICs9IHN0cjtcbiAgICAgIH1cbiAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBzdHI7XG4gICAgfVxuICAgIHJldHVybiBycHQ7XG4gIH07XG59XG5cbi8qKlxuICogU2ltaWxhciB0byB2YWwgfHwgZGVmYXVsdFZhbCwgZXhjZXB0IGl0J3MgZ2F0ZWQgb24gd2hldGhlciBvciBub3QgdmFsIGlzXG4gKiB1bmRlZmluZWQgaW5zdGVhZCBvZiB3aGV0aGVyIHZhbCBpcyBmYWxzZXkuXG4gKiBAcmV0dXJucyB7Kn0gdmFsIGlmIG5vdCB1bmRlZmluZWQsIG90aGVyd2lzZSBkZWZhdWx0VmFsXG4gKi9cbmV4cG9ydHMudmFsdWVPciA9IGZ1bmN0aW9uICh2YWwsIGRlZmF1bHRWYWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbCA6IHZhbDtcbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBhbmFseXplIHdoZXRoZXIgb3Igbm90IGVyciByZXByZXNlbnRzIGluZmluaXRlIHJlY3Vyc2lvbiBoYXZpbmdcbiAqIG9jY3VycmVkLiBUaGlzIGVycm9yIGRpZmZlcnMgcGVyIGJyb3dzZXIsIGFuZCBpdCdzIHBvc3NpYmxlIHRoYXQgd2UgZG9uJ3RcbiAqIHByb3Blcmx5IGRpc2NvdmVyIGFsbCBjYXNlcy5cbiAqIE5vdGU6IE90aGVyIGxhbmd1YWdlcyBwcm9iYWJseSBoYXZlIGxvY2FsaXplZCBtZXNzYWdlcywgbWVhbmluZyB3ZSB3b24ndFxuICogY2F0Y2ggdGhlbS5cbiAqL1xuZXhwb3J0cy5pc0luZmluaXRlUmVjdXJzaW9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIC8vIENocm9tZS9TYWZhcmk6IG1lc3NhZ2UgZW5kcyBpbiBhIHBlcmlvZCBpbiBTYWZhcmksIG5vdCBpbiBDaHJvbWVcbiAgaWYgKGVyciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IgJiZcbiAgICAvXk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkLy50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmlyZWZveFxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIC8vIExpbnRlciBkb2Vzbid0IGxpa2Ugb3VyIHVzZSBvZiBJbnRlcm5hbEVycm9yLCBldmVuIHRob3VnaCB3ZSBnYXRlIG9uIGl0c1xuICAvLyBleGlzdGVuY2UuXG4gIGlmICh0eXBlb2YoSW50ZXJuYWxFcnJvcikgIT09ICd1bmRlZmluZWQnICYmIGVyciBpbnN0YW5jZW9mIEludGVybmFsRXJyb3IgJiZcbiAgICAgIGVyci5tZXNzYWdlID09PSAndG9vIG11Y2ggcmVjdXJzaW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgLy8gSUVcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnIubWVzc2FnZSA9PT0gJ091dCBvZiBzdGFjayBzcGFjZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFRPRE8oZGF2ZSk6IG1vdmUgdGhpcyBsb2dpYyB0byBkYXNoYm9hcmQuXG5leHBvcnRzLmdldFBlZ2FzdXNIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSB7XG4gICAgY2FzZSAnc3R1ZGlvLmNvZGUub3JnJzpcbiAgICBjYXNlICdsZWFybi5jb2RlLm9yZyc6XG4gICAgICByZXR1cm4gJ2NvZGUub3JnJztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuc3BsaXQoJy4nKVswXTtcbiAgICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ2xvY2FsaG9zdCc6XG4gICAgICAgICAgcmV0dXJuICdsb2NhbGhvc3QuY29kZS5vcmc6MzAwMCc7XG4gICAgICAgIGNhc2UgJ2RldmVsb3BtZW50JzpcbiAgICAgICAgY2FzZSAnc3RhZ2luZyc6XG4gICAgICAgIGNhc2UgJ3Rlc3QnOlxuICAgICAgICBjYXNlICdsZXZlbGJ1aWxkZXInOlxuICAgICAgICAgIHJldHVybiBuYW1lICsgJy5jb2RlLm9yZyc7XG4gICAgICAgIGNhc2UgJ3N0YWdpbmctc3R1ZGlvJzpcbiAgICAgICAgICByZXR1cm4gJ3N0YWdpbmcuY29kZS5vcmcnO1xuICAgICAgICBjYXNlICd0ZXN0LXN0dWRpbyc6XG4gICAgICAgICAgcmV0dXJuICd0ZXN0LmNvZGUub3JnJztcbiAgICAgICAgY2FzZSAnbGV2ZWxidWlsZGVyLXN0dWRpbyc6XG4gICAgICAgICAgcmV0dXJuICdsZXZlbGJ1aWxkZXIuY29kZS5vcmcnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElFOSB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyB0aGUgbWVkaWEgZmllbGQgb2YgYSBzdHlsZXNoZWV0XG4gKi9cbmV4cG9ydHMuYnJvd3NlclN1cHBvcnRzQ3NzTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHlsZVNoZWV0cyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ1bGVzID0gc3R5bGVTaGVldHNbaV0uY3NzUnVsZXMgfHwgc3R5bGVTaGVldHNbaV0ucnVsZXM7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHNlZSBpZiB3ZSBjYW4gYWNjZXNzIG1lZGlhXG4gICAgICAgIHZhciBtZWRpYSA9IHJ1bGVzWzBdLm1lZGlhOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXNjYXBlZCBjaGFyYWN0ZXJzIGFuZCBIVE1MIHRvIGNvbnZlcnQgc29tZSByZW5kZXJlZCB0ZXh0IHRvIHdoYXQgc2hvdWxkIGFwcGVhciBpbiB1c2VyLWVkaXRlZCBjb250cm9sc1xuICogQHBhcmFtIHRleHRcbiAqIEByZXR1cm5zIFN0cmluZyB0aGF0IGhhcyBubyBtb3JlIGVzY2FwZSBjaGFyYWN0ZXJzIGFuZCBtdWx0aXBsZSBkaXZzIGNvbnZlcnRlZCB0byBuZXdsaW5lc1xuICovXG5leHBvcnRzLnVuZXNjYXBlVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdmFyIGNsZWFuZWRUZXh0ID0gdGV4dDtcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC88ZGl2Pi9naSwgJ1xcbicpOyAvLyBEaXZzIGdlbmVyYXRlIG5ld2xpbmVzXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvPFtePl0rPi9naSwgJycpOyAvLyBTdHJpcCBhbGwgb3RoZXIgdGFnc1xuXG4gIC8vIFRoaXMgbmV4dCBzdGVwIHJlcXVpcmVzIHNvbWUgZXhwbGFuYXRpb25cbiAgLy8gSW4gbXVsdGlsaW5lIHRleHQgaXQncyBwb3NzaWJsZSBmb3IgdGhlIGZpcnN0IGxpbmUgdG8gcmVuZGVyIHdyYXBwZWQgb3IgdW53cmFwcGVkLlxuICAvLyAgICAgTGluZSAxXG4gIC8vICAgICBMaW5lIDJcbiAgLy8gICBDYW4gcmVuZGVyIGFzIGVpdGhlciBvZjpcbiAgLy8gICAgIExpbmUgMTxkaXY+TGluZSAyPC9kaXY+XG4gIC8vICAgICA8ZGl2PkxpbmUgMTwvZGl2PjxkaXY+TGluZSAyPC9kaXY+XG4gIC8vXG4gIC8vIEJ1dCBsZWFkaW5nIGJsYW5rIGxpbmVzIHdpbGwgYWx3YXlzIHJlbmRlciB3cmFwcGVkIGFuZCBzaG91bGQgYmUgcHJlc2VydmVkXG4gIC8vXG4gIC8vICAgICBMaW5lIDJcbiAgLy8gICAgIExpbmUgM1xuICAvLyAgIFJlbmRlcnMgYXNcbiAgLy8gICAgPGRpdj48YnI+PC9kaXY+PGRpdj5MaW5lIDI8L2Rpdj48ZGl2PkxpbmUgMzwvZGl2PlxuICAvL1xuICAvLyBUbyBoYW5kbGUgdGhpcyBiZWhhdmlvciB3ZSBzdHJpcCBsZWFkaW5nIG5ld2xpbmVzIFVOTEVTUyB0aGV5IGFyZSBmb2xsb3dlZFxuICAvLyBieSBhbm90aGVyIG5ld2xpbmUsIHVzaW5nIGEgbmVnYXRpdmUgbG9va2FoZWFkICg/ISlcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9eXFxuKD8hXFxuKS8sICcnKTsgLy8gU3RyaXAgbGVhZGluZyBub25kb3VibGVkIG5ld2xpbmVcblxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLyZuYnNwOy9naSwgJyAnKTsgLy8gVW5lc2NhcGUgbm9uYnJlYWtpbmcgc3BhY2VzXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvJmd0Oy9naSwgJz4nKTsgICAvLyBVbmVzY2FwZSA+XG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvJmx0Oy9naSwgJzwnKTsgICAvLyBVbmVzY2FwZSA8XG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvJmFtcDsvZ2ksICcmJyk7ICAvLyBVbmVzY2FwZSAmIChtdXN0IGhhcHBlbiBsYXN0ISlcbiAgcmV0dXJuIGNsZWFuZWRUZXh0O1xufTtcblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgcGllY2Ugb2YgdGV4dCwgYW5kIGNvbnZlcnQgbmV3bGluZXMgdG8gc2VwZXJhdGUgZGl2c1xuICogQHBhcmFtIHRleHRcbiAqIEByZXR1cm5zIFN0cmluZyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycyBlc2NhcGVkIGFuZCBuZXdsaW5lcyBjb252ZXJ0ZWQgZGl2c1xuICovXG5leHBvcnRzLmVzY2FwZVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICB2YXIgZXNjYXBlZFRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG4gIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKTsgICAvLyBFc2NhcGUgJiAobXVzdCBoYXBwZW4gZmlyc3QhKVxuICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UoLzwvZywgJyZsdDsnKTsgICAgLy8gRXNjYXBlIDxcbiAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7ICAgIC8vIEVzY2FwZSA+XG4gIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZSgvICAvZywnICZuYnNwOycpOyAvLyBFc2NhcGUgZG91YmxlZCBzcGFjZXNcblxuICAvLyBOb3cgd3JhcCBlYWNoIGxpbmUgZXhjZXB0IHRoZSBmaXJzdCBsaW5lIGluIGEgPGRpdj4sXG4gIC8vIHJlcGxhY2luZyBibGFuayBsaW5lcyB3aXRoIDxkaXY+PGJyPjxkaXY+XG4gIHZhciBsaW5lcyA9IGVzY2FwZWRUZXh0LnNwbGl0KCdcXG4nKTtcbiAgdmFyIHJldHVyblZhbHVlID0gbGluZXNbMF0gKyBsaW5lcy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiAnPGRpdj4nICsgKGxpbmUubGVuZ3RoID8gbGluZSA6ICc8YnI+JykgKyAnPC9kaXY+JztcbiAgICB9KS5qb2luKCcnKTtcblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgaW50byByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSBkZWdyZWVzIC0gVGhlIGRlZ3JlZXMgdG8gY29udmVydCB0byByYWRpYW5zXG4gKiBAcmV0dXJuIGBkZWdyZWVzYCBjb252ZXJ0ZWQgdG8gcmFkaWFuc1xuICovXG5leHBvcnRzLmRlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xufTtcblxuLyoqXG4gKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgbG9jYWxTdG9yYWdlLnNldEl0ZW0gdGhhdCBjYXRjaGVzIGFueSBleGNlcHRpb25zIChmb3JcbiAqIGV4YW1wbGUgd2hlbiB3ZSBjYWxsIHNldEl0ZW0gaW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlKVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB3ZSBzZXQgc3VjY2Vzc2Z1bGx5XG4gKi9cbmV4cG9ydHMudHJ5U2V0TG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oaXRlbSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggaW5jbHVkZT1cImRlYm91bmNlLHJlamVjdCxtYXAsdmFsdWUscmFuZ2Usd2l0aG91dCxzYW1wbGUsY3JlYXRlLGZsYXR0ZW4saXNFbXB0eSx3cmFwLHNpemUsYmluZCxjb250YWlucyxsYXN0LGNsb25lLGNsb25lRGVlcCxpc0VxdWFsLGZpbmQsc29ydEJ5LHRocm90dGxlLHVuaXFcIiAtLW91dHB1dCBzcmMvbG9kYXNoLmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlIEVTNSBlbnZpcm9ubWVudHMgKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCB0byBwb29sIGFycmF5cyBhbmQgb2JqZWN0cyB1c2VkIGludGVybmFsbHkgKi9cbiAgdmFyIGFycmF5UG9vbCA9IFtdLFxuICAgICAgb2JqZWN0UG9vbCA9IFtdO1xuXG4gIC8qKiBVc2VkIGludGVybmFsbHkgdG8gaW5kaWNhdGUgdmFyaW91cyB0aGluZ3MgKi9cbiAgdmFyIGluZGljYXRvck9iamVjdCA9IHt9O1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHJlZ2V4cCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcyAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0ZWQgbmFtZWQgZnVuY3Rpb25zICovXG4gIHZhciByZUZ1bmNOYW1lID0gL15cXHMqZnVuY3Rpb25bIFxcblxcclxcdF0rXFx3LztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gZml4IHRoZSBKU2NyaXB0IFtbRG9udEVudW1dXSBidWcgKi9cbiAgdmFyIHNoYWRvd2VkUHJvcHMgPSBbXG4gICAgJ2NvbnN0cnVjdG9yJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ1xuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZXJyb3JDbGFzcyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCBhcyB0aGUgZGF0YSBvYmplY3QgZm9yIGBpdGVyYXRvclRlbXBsYXRlYCAqL1xuICB2YXIgaXRlcmF0b3JEYXRhID0ge1xuICAgICdhcmdzJzogJycsXG4gICAgJ2FycmF5JzogbnVsbCxcbiAgICAnYm90dG9tJzogJycsXG4gICAgJ2ZpcnN0QXJnJzogJycsXG4gICAgJ2luaXQnOiAnJyxcbiAgICAna2V5cyc6IG51bGwsXG4gICAgJ2xvb3AnOiAnJyxcbiAgICAnc2hhZG93ZWRQcm9wcyc6IG51bGwsXG4gICAgJ3N1cHBvcnQnOiBudWxsLFxuICAgICd0b3AnOiAnJyxcbiAgICAndXNlSGFzJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBgY29sbGVjdGlvbmAgZWxlbWVudHMsIHN0YWJsZSBzb3J0aW5nXG4gICAqIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGFgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBvZiBgMWAgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcoYSwgYikge1xuICAgIHZhciBhYyA9IGEuY3JpdGVyaWEsXG4gICAgICAgIGJjID0gYi5jcml0ZXJpYSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYWMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFjW2luZGV4XSxcbiAgICAgICAgICBvdGhlciA9IGJjW2luZGV4XTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICBpZiAodmFsdWUgPiBvdGhlciB8fCB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBvdGhlciB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAvLyBgYWAgYW5kIGBiYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwXG4gICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCBvciBgbnVsbGAgaWYgY2FjaGluZyBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWNoZShhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gYXJyYXlbMF0sXG4gICAgICAgIG1pZCA9IGFycmF5WyhsZW5ndGggLyAyKSB8IDBdLFxuICAgICAgICBsYXN0ID0gYXJyYXlbbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0ID09ICdvYmplY3QnICYmXG4gICAgICAgIG1pZCAmJiB0eXBlb2YgbWlkID09ICdvYmplY3QnICYmIGxhc3QgJiYgdHlwZW9mIGxhc3QgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gZ2V0T2JqZWN0KCk7XG4gICAgY2FjaGVbJ2ZhbHNlJ10gPSBjYWNoZVsnbnVsbCddID0gY2FjaGVbJ3RydWUnXSA9IGNhY2hlWyd1bmRlZmluZWQnXSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldE9iamVjdCgpO1xuICAgIHJlc3VsdC5hcnJheSA9IGFycmF5O1xuICAgIHJlc3VsdC5jYWNoZSA9IGNhY2hlO1xuICAgIHJlc3VsdC5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBmcm9tIHRoZSBhcnJheSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIGFycmF5UG9vbC5wb3AoKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBmcm9tIHRoZSBvYmplY3QgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiBvYmplY3RQb29sLnBvcCgpIHx8IHtcbiAgICAgICdhcnJheSc6IG51bGwsXG4gICAgICAnY2FjaGUnOiBudWxsLFxuICAgICAgJ2NyaXRlcmlhJzogbnVsbCxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ2luZGV4JzogMCxcbiAgICAgICdudWxsJzogZmFsc2UsXG4gICAgICAnbnVtYmVyJzogbnVsbCxcbiAgICAgICdvYmplY3QnOiBudWxsLFxuICAgICAgJ3B1c2gnOiBudWxsLFxuICAgICAgJ3N0cmluZyc6IG51bGwsXG4gICAgICAndHJ1ZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gbm9kZSBpbiBJRSA8IDkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gbm9kZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgLy8gSUUgPCA5IHByZXNlbnRzIERPTSBub2RlcyBhcyBgT2JqZWN0YCBvYmplY3RzIGV4Y2VwdCB0aGV5IGhhdmUgYHRvU3RyaW5nYFxuICAgIC8vIG1ldGhvZHMgdGhhdCBhcmUgYHR5cGVvZmAgXCJzdHJpbmdcIiBhbmQgc3RpbGwgY2FuIGNvZXJjZSBub2RlcyB0byBzdHJpbmdzXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgKyAnJykgPT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGFycmF5IGJhY2sgdG8gdGhlIGFycmF5IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgIGlmIChhcnJheVBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIGFycmF5UG9vbC5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG9iamVjdCBiYWNrIHRvIHRoZSBvYmplY3QgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGNhY2hlID0gb2JqZWN0LmNhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgfVxuICAgIG9iamVjdC5hcnJheSA9IG9iamVjdC5jYWNoZSA9IG9iamVjdC5jcml0ZXJpYSA9IG9iamVjdC5vYmplY3QgPSBvYmplY3QubnVtYmVyID0gb2JqZWN0LnN0cmluZyA9IG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIG9iamVjdFBvb2wucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGBjb2xsZWN0aW9uYCBmcm9tIHRoZSBgc3RhcnRgIGluZGV4IHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyxcbiAgICogdGhlIGBlbmRgIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIE5vcm1hbGx5IGBBcnJheS5wcm90b3R5cGVgIHdvdWxkIHN1ZmZpY2UsIGhvd2V2ZXIsIHVzaW5nIGFuIGFycmF5IGxpdGVyYWxcbiAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgKi9cbiAgdmFyIGFycmF5UmVmID0gW107XG5cbiAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICB2YXIgZXJyb3JQcm90byA9IEVycm9yLnByb3RvdHlwZSxcbiAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBbW0NsYXNzXV0gb2YgdmFsdWVzICovXG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUgKi9cbiAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICk7XG5cbiAgLyoqIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzICovXG4gIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICBwdXNoID0gYXJyYXlSZWYucHVzaCxcbiAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICB1bnNoaWZ0ID0gYXJyYXlSZWYudW5zaGlmdDtcblxuICAvKiogVXNlZCB0byBzZXQgbWV0YSBkYXRhIG9uIGZ1bmN0aW9ucyAqL1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gSUUgOCBvbmx5IGFjY2VwdHMgRE9NIGVsZW1lbnRzXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGZ1bmMsXG4gICAgICAgICAgcmVzdWx0ID0gZnVuYyhvLCBvLCBvKSAmJiBmdW5jO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSgpKTtcblxuICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICB2YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlLFxuICAgICAgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgdmFyIGN0b3JCeUNsYXNzID0ge307XG4gIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICBjdG9yQnlDbGFzc1tkYXRlQ2xhc3NdID0gRGF0ZTtcbiAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gIGN0b3JCeUNsYXNzW251bWJlckNsYXNzXSA9IE51bWJlcjtcbiAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgLyoqIFVzZWQgdG8gYXZvaWQgaXRlcmF0aW5nIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW4gSUUgPCA5ICovXG4gIHZhciBub25FbnVtUHJvcHMgPSB7fTtcbiAgbm9uRW51bVByb3BzW2FycmF5Q2xhc3NdID0gbm9uRW51bVByb3BzW2RhdGVDbGFzc10gPSBub25FbnVtUHJvcHNbbnVtYmVyQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9Mb2NhbGVTdHJpbmcnOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgbm9uRW51bVByb3BzW2Jvb2xDbGFzc10gPSBub25FbnVtUHJvcHNbc3RyaW5nQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgbm9uRW51bVByb3BzW2Vycm9yQ2xhc3NdID0gbm9uRW51bVByb3BzW2Z1bmNDbGFzc10gPSBub25FbnVtUHJvcHNbcmVnZXhwQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlIH07XG4gIG5vbkVudW1Qcm9wc1tvYmplY3RDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUgfTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHNoYWRvd2VkUHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHNoYWRvd2VkUHJvcHNbbGVuZ3RoXTtcbiAgICAgIGZvciAodmFyIGNsYXNzTmFtZSBpbiBub25FbnVtUHJvcHMpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobm9uRW51bVByb3BzLCBjbGFzc05hbWUpICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vbkVudW1Qcm9wc1tjbGFzc05hbWVdLCBrZXkpKSB7XG4gICAgICAgICAgbm9uRW51bVByb3BzW2NsYXNzTmFtZV1ba2V5XSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KCkpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB0byBlbmFibGUgaW50dWl0aXZlXG4gICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gdG8gTG8tRGFzaCBtZXRob2RzLCB3cmFwcGVycyBhbHNvIGhhdmUgdGhlIGZvbGxvd2luZyBgQXJyYXlgIG1ldGhvZHM6XG4gICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICogYW5kIGB1bnNoaWZ0YFxuICAgKlxuICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgKlxuICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICogYGNvbXBvc2VgLCBgY29uY2F0YCwgYGNvdW50QnlgLCBgY3JlYXRlYCwgYGNyZWF0ZUNhbGxiYWNrYCwgYGN1cnJ5YCxcbiAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICogYHJhbmdlYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAqIGFuZCBgemlwYFxuICAgKlxuICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAqIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgY29udGFpbnNgLCBgZXNjYXBlYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCxcbiAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICogYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsXG4gICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAqIGByZWR1Y2VSaWdodGAsIGByZXN1bHRgLCBgc2hpZnRgLCBgc2l6ZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHJ1bkluQ29udGV4dGAsXG4gICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAqXG4gICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyBgZmlyc3RgIGFuZCBgbGFzdGAgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gYG5gIGlzXG4gICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICpcbiAgICogRXhwbGljaXQgY2hhaW5pbmcgY2FuIGJlIGVuYWJsZWQgYnkgdXNpbmcgdGhlIGBfLmNoYWluYCBtZXRob2QuXG4gICAqXG4gICAqIEBuYW1lIF9cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAqXG4gICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICogfSk7XG4gICAqIC8vID0+IDZcbiAgICpcbiAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihudW0pIHtcbiAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgKiB9KTtcbiAgICpcbiAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmICFpc0FycmF5KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSlcbiAgICAgPyB2YWx1ZVxuICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hhaW5BbGwgQSBmbGFnIHRvIGVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIG1ldGhvZHNcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICB9XG4gIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdG9yID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IDE7IH0sXG4gICAgICAgIG9iamVjdCA9IHsgJzAnOiAxLCAnbGVuZ3RoJzogMSB9LFxuICAgICAgICBwcm9wcyA9IFtdO1xuXG4gICAgY3Rvci5wcm90b3R5cGUgPSB7ICd2YWx1ZU9mJzogMSwgJ3knOiAxIH07XG4gICAgZm9yICh2YXIga2V5IGluIG5ldyBjdG9yKSB7IHByb3BzLnB1c2goa2V5KTsgfVxuICAgIGZvciAoa2V5IGluIGFyZ3VtZW50cykgeyB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYW4gYGFyZ3VtZW50c2Agb2JqZWN0J3MgW1tDbGFzc11dIGlzIHJlc29sdmFibGUgKGFsbCBidXQgRmlyZWZveCA8IDQsIElFIDwgOSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuYXJnc0NsYXNzID0gdG9TdHJpbmcuY2FsbChhcmd1bWVudHMpID09IGFyZ3NDbGFzcztcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIChhbGwgYnV0IE5hcndoYWwgYW5kIE9wZXJhIDwgMTAuNSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuYXJnc09iamVjdCA9IGFyZ3VtZW50cy5jb25zdHJ1Y3RvciA9PSBPYmplY3QgJiYgIShhcmd1bWVudHMgaW5zdGFuY2VvZiBBcnJheSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYG5hbWVgIG9yIGBtZXNzYWdlYCBwcm9wZXJ0aWVzIG9mIGBFcnJvci5wcm90b3R5cGVgIGFyZVxuICAgICAqIGVudW1lcmFibGUgYnkgZGVmYXVsdC4gKElFIDwgOSwgU2FmYXJpIDwgNS4xKVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmVudW1FcnJvclByb3BzID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlcnJvclByb3RvLCAnbWVzc2FnZScpIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ25hbWUnKTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgcHJvdG90eXBlYCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBGaXJlZm94IDwgMy42LCBPcGVyYSA+IDkuNTAgLSBPcGVyYSA8IDExLjYwLCBhbmQgU2FmYXJpIDwgNS4xXG4gICAgICogKGlmIHRoZSBwcm90b3R5cGUgb3IgYSBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlIGhhcyBiZWVuIHNldClcbiAgICAgKiBpbmNvcnJlY3RseSBzZXRzIGEgZnVuY3Rpb24ncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBbW0VudW1lcmFibGVdXVxuICAgICAqIHZhbHVlIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5lbnVtUHJvdG90eXBlcyA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoY3RvciwgJ3Byb3RvdHlwZScpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICogKGFsbCBidXQgUFMzIGFuZCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMgJiBhdm9pZGVkIGluIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKHJvb3QuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgRnVuY3Rpb24jbmFtZWAgaXMgc3VwcG9ydGVkIChhbGwgYnV0IElFKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jTmFtZXMgPSB0eXBlb2YgRnVuY3Rpb24ubmFtZSA9PSAnc3RyaW5nJztcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGVcbiAgICAgKiAoRmlyZWZveCA8IDQsIElFIDwgOSwgUGhhbnRvbUpTLCBTYWZhcmkgPCA1LjEpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0ga2V5ICE9IDA7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgcHJvcGVydGllcyBzaGFkb3dpbmcgdGhvc2Ugb24gYE9iamVjdC5wcm90b3R5cGVgIGFyZSBub24tZW51bWVyYWJsZS5cbiAgICAgKlxuICAgICAqIEluIElFIDwgOSBhbiBvYmplY3RzIG93biBwcm9wZXJ0aWVzLCBzaGFkb3dpbmcgbm9uLWVudW1lcmFibGUgb25lcywgYXJlXG4gICAgICogbWFkZSBub24tZW51bWVyYWJsZSBhcyB3ZWxsIChhLmsuYSB0aGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5ub25FbnVtU2hhZG93cyA9ICEvdmFsdWVPZi8udGVzdChwcm9wcyk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYEFycmF5I3NoaWZ0YCBhbmQgYEFycmF5I3NwbGljZWAgYXVnbWVudCBhcnJheS1saWtlIG9iamVjdHMgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogRmlyZWZveCA8IDEwLCBJRSBjb21wYXRpYmlsaXR5IG1vZGUsIGFuZCBJRSA8IDkgaGF2ZSBidWdneSBBcnJheSBgc2hpZnQoKWBcbiAgICAgKiBhbmQgYHNwbGljZSgpYCBmdW5jdGlvbnMgdGhhdCBmYWlsIHRvIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50LCBgdmFsdWVbMF1gLFxuICAgICAqIG9mIGFycmF5LWxpa2Ugb2JqZWN0cyBldmVuIHRob3VnaCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgaXMgc2V0IHRvIGAwYC5cbiAgICAgKiBUaGUgYHNoaWZ0KClgIG1ldGhvZCBpcyBidWdneSBpbiBJRSA4IGNvbXBhdGliaWxpdHkgbW9kZSwgd2hpbGUgYHNwbGljZSgpYFxuICAgICAqIGlzIGJ1Z2d5IHJlZ2FyZGxlc3Mgb2YgbW9kZSBpbiBJRSA8IDkgYW5kIGJ1Z2d5IGluIGNvbXBhdGliaWxpdHkgbW9kZSBpbiBJRSA5LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LnNwbGljZU9iamVjdHMgPSAoYXJyYXlSZWYuc3BsaWNlLmNhbGwob2JqZWN0LCAwLCAxKSwgIW9iamVjdFswXSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgbGFjayBvZiBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiBJRSA8IDggY2FuJ3QgYWNjZXNzIGNoYXJhY3RlcnMgYnkgaW5kZXggYW5kIElFIDggY2FuIG9ubHkgYWNjZXNzXG4gICAgICogY2hhcmFjdGVycyBieSBpbmRleCBvbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgPSAoJ3gnWzBdICsgT2JqZWN0KCd4JylbMF0pICE9ICd4eCc7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBET00gbm9kZSdzIFtbQ2xhc3NdXSBpcyByZXNvbHZhYmxlIChhbGwgYnV0IElFIDwgOSlcbiAgICAgKiBhbmQgdGhhdCB0aGUgSlMgZW5naW5lIGVycm9ycyB3aGVuIGF0dGVtcHRpbmcgdG8gY29lcmNlIGFuIG9iamVjdCB0b1xuICAgICAqIGEgc3RyaW5nIHdpdGhvdXQgYSBgdG9TdHJpbmdgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgc3VwcG9ydC5ub2RlQ2xhc3MgPSAhKHRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpID09IG9iamVjdENsYXNzICYmICEoeyAndG9TdHJpbmcnOiAwIH0gKyAnJykpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc3VwcG9ydC5ub2RlQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgfSgxKSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB1c2VkIHRvIGNyZWF0ZSBpdGVyYXRvciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICovXG4gIHZhciBpdGVyYXRvclRlbXBsYXRlID0gZnVuY3Rpb24ob2JqKSB7XG5cbiAgICB2YXIgX19wID0gJ3ZhciBpbmRleCwgaXRlcmFibGUgPSAnICtcbiAgICAob2JqLmZpcnN0QXJnKSArXG4gICAgJywgcmVzdWx0ID0gJyArXG4gICAgKG9iai5pbml0KSArXG4gICAgJztcXG5pZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xcbicgK1xuICAgIChvYmoudG9wKSArXG4gICAgJzsnO1xuICAgICBpZiAob2JqLmFycmF5KSB7XG4gICAgX19wICs9ICdcXG52YXIgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoOyBpbmRleCA9IC0xO1xcbmlmICgnICtcbiAgICAob2JqLmFycmF5KSArXG4gICAgJykgeyAgJztcbiAgICAgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xcbiAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlLnNwbGl0KFxcJ1xcJylcXG4gIH0gICc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgJyArXG4gICAgKG9iai5sb29wKSArXG4gICAgJztcXG4gIH1cXG59XFxuZWxzZSB7ICAnO1xuICAgICB9IGVsc2UgaWYgKHN1cHBvcnQubm9uRW51bUFyZ3MpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDsgaW5kZXggPSAtMTtcXG4gIGlmIChsZW5ndGggJiYgaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgaW5kZXggKz0gXFwnXFwnO1xcbiAgICAgICcgK1xuICAgIChvYmoubG9vcCkgK1xuICAgICc7XFxuICAgIH1cXG4gIH0gZWxzZSB7ICAnO1xuICAgICB9XG5cbiAgICAgaWYgKHN1cHBvcnQuZW51bVByb3RvdHlwZXMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIHNraXBQcm90byA9IHR5cGVvZiBpdGVyYWJsZSA9PSBcXCdmdW5jdGlvblxcJztcXG4gICc7XG4gICAgIH1cblxuICAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykge1xuICAgIF9fcCArPSAnXFxuICB2YXIgc2tpcEVycm9yUHJvcHMgPSBpdGVyYWJsZSA9PT0gZXJyb3JQcm90byB8fCBpdGVyYWJsZSBpbnN0YW5jZW9mIEVycm9yO1xcbiAgJztcbiAgICAgfVxuXG4gICAgICAgIHZhciBjb25kaXRpb25zID0gW107ICAgIGlmIChzdXBwb3J0LmVudW1Qcm90b3R5cGVzKSB7IGNvbmRpdGlvbnMucHVzaCgnIShza2lwUHJvdG8gJiYgaW5kZXggPT0gXCJwcm90b3R5cGVcIiknKTsgfSAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykgIHsgY29uZGl0aW9ucy5wdXNoKCchKHNraXBFcnJvclByb3BzICYmIChpbmRleCA9PSBcIm1lc3NhZ2VcIiB8fCBpbmRleCA9PSBcIm5hbWVcIikpJyk7IH1cblxuICAgICBpZiAob2JqLnVzZUhhcyAmJiBvYmoua2V5cykge1xuICAgIF9fcCArPSAnXFxuICB2YXIgb3duSW5kZXggPSAtMSxcXG4gICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXFxuICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xcblxcbiAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcXG4gICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XFxuJztcbiAgICAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgX19wICs9ICcgICAgaWYgKCcgK1xuICAgIChjb25kaXRpb25zLmpvaW4oJyAmJiAnKSkgK1xuICAgICcpIHtcXG4gICc7XG4gICAgIH1cbiAgICBfX3AgKz1cbiAgICAob2JqLmxvb3ApICtcbiAgICAnOyAgICAnO1xuICAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICBfX3AgKz0gJ1xcbiAgICB9JztcbiAgICAgfVxuICAgIF9fcCArPSAnXFxuICB9ICAnO1xuICAgICB9IGVsc2Uge1xuICAgIF9fcCArPSAnXFxuICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XFxuJztcbiAgICAgICAgaWYgKG9iai51c2VIYXMpIHsgY29uZGl0aW9ucy5wdXNoKFwiaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpXCIpOyB9ICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIF9fcCArPSAnICAgIGlmICgnICtcbiAgICAoY29uZGl0aW9ucy5qb2luKCcgJiYgJykpICtcbiAgICAnKSB7XFxuICAnO1xuICAgICB9XG4gICAgX19wICs9XG4gICAgKG9iai5sb29wKSArXG4gICAgJzsgICAgJztcbiAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgX19wICs9ICdcXG4gICAgfSc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgfSAgICAnO1xuICAgICBpZiAoc3VwcG9ydC5ub25FbnVtU2hhZG93cykge1xuICAgIF9fcCArPSAnXFxuXFxuICBpZiAoaXRlcmFibGUgIT09IG9iamVjdFByb3RvKSB7XFxuICAgIHZhciBjdG9yID0gaXRlcmFibGUuY29uc3RydWN0b3IsXFxuICAgICAgICBpc1Byb3RvID0gaXRlcmFibGUgPT09IChjdG9yICYmIGN0b3IucHJvdG90eXBlKSxcXG4gICAgICAgIGNsYXNzTmFtZSA9IGl0ZXJhYmxlID09PSBzdHJpbmdQcm90byA/IHN0cmluZ0NsYXNzIDogaXRlcmFibGUgPT09IGVycm9yUHJvdG8gPyBlcnJvckNsYXNzIDogdG9TdHJpbmcuY2FsbChpdGVyYWJsZSksXFxuICAgICAgICBub25FbnVtID0gbm9uRW51bVByb3BzW2NsYXNzTmFtZV07XFxuICAgICAgJztcbiAgICAgZm9yIChrID0gMDsgayA8IDc7IGsrKykge1xuICAgIF9fcCArPSAnXFxuICAgIGluZGV4ID0gXFwnJyArXG4gICAgKG9iai5zaGFkb3dlZFByb3BzW2tdKSArXG4gICAgJ1xcJztcXG4gICAgaWYgKCghKGlzUHJvdG8gJiYgbm9uRW51bVtpbmRleF0pICYmIGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSknO1xuICAgICAgICAgICAgaWYgKCFvYmoudXNlSGFzKSB7XG4gICAgX19wICs9ICcgfHwgKCFub25FbnVtW2luZGV4XSAmJiBpdGVyYWJsZVtpbmRleF0gIT09IG9iamVjdFByb3RvW2luZGV4XSknO1xuICAgICB9XG4gICAgX19wICs9ICcpIHtcXG4gICAgICAnICtcbiAgICAob2JqLmxvb3ApICtcbiAgICAnO1xcbiAgICB9ICAgICAgJztcbiAgICAgfVxuICAgIF9fcCArPSAnXFxuICB9ICAgICc7XG4gICAgIH1cblxuICAgICB9XG5cbiAgICAgaWYgKG9iai5hcnJheSB8fCBzdXBwb3J0Lm5vbkVudW1BcmdzKSB7XG4gICAgX19wICs9ICdcXG59JztcbiAgICAgfVxuICAgIF9fcCArPVxuICAgIChvYmouYm90dG9tKSArXG4gICAgJztcXG5yZXR1cm4gcmVzdWx0JztcblxuICAgIHJldHVybiBfX3BcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZGAgdGhhdCBjcmVhdGVzIHRoZSBib3VuZCBmdW5jdGlvbiBhbmRcbiAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VCaW5kKGJpbmREYXRhKSB7XG4gICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdO1xuXG4gICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNVxuICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgIC8vIGF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCBkZW9wdGltaXphdGlvbnMgYnkgdXNpbmcgYHNsaWNlYCBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGAgYW5kIG5vdCBhc3NpZ25pbmcgYGFyZ3VtZW50c2AgdG8gYVxuICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgLy8gbWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yXG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICB2YXIgaXNPYmogPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgaWYgKGlzT2JqKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAoIWNsb25lYWJsZUNsYXNzZXNbY2xhc3NOYW1lXSB8fCAoIXN1cHBvcnQubm9kZUNsYXNzICYmIGlzTm9kZSh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3ZhbHVlKTtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIHJldHVybiBuZXcgY3Rvcih2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgIGlmIChpc0RlZXApIHtcbiAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGlzQXJyID8gY3Rvcih2YWx1ZS5sZW5ndGgpIDoge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0gaXNBcnIgPyBzbGljZSh2YWx1ZSkgOiBhc3NpZ24oe30sIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgIGlmIChpc0Fycikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbnB1dCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgIC8vIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmVcbiAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAoaXNBcnIgPyBiYXNlRWFjaCA6IGZvck93bikodmFsdWUsIGZ1bmN0aW9uKG9ialZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKG9ialZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvdHlwZSkgPyBuYXRpdmVDcmVhdGUocHJvdG90eXBlKSA6IHt9O1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICBpZiAoIW5hdGl2ZUNyZWF0ZSkge1xuICAgIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCByb290Lk9iamVjdCgpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAqIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH1cbiAgICAvLyBleGl0IGVhcmx5IGZvciBubyBgdGhpc0FyZ2Agb3IgYWxyZWFkeSBib3VuZCBieSBgRnVuY3Rpb24jYmluZGBcbiAgICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgfHwgISgncHJvdG90eXBlJyBpbiBmdW5jKSkge1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICBiaW5kRGF0YSA9ICFmdW5jLm5hbWU7XG4gICAgICB9XG4gICAgICBiaW5kRGF0YSA9IGJpbmREYXRhIHx8ICFzdXBwb3J0LmZ1bmNEZWNvbXA7XG4gICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIGlmICghc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICBiaW5kRGF0YSA9ICFyZUZ1bmNOYW1lLnRlc3Qoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgLy8gY2hlY2tzIGlmIGBmdW5jYCByZWZlcmVuY2VzIHRoZSBgdGhpc2Aga2V5d29yZCBhbmQgc3RvcmVzIHRoZSByZXN1bHRcbiAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgc2V0QmluZERhdGEoZnVuYywgYmluZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlcmUgYXJlIG5vIGB0aGlzYCByZWZlcmVuY2VzIG9yIGBmdW5jYCBpcyBib3VuZFxuICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYSwgYik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYmluZChmdW5jLCB0aGlzQXJnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY3JlYXRlV3JhcHBlcmAgdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGVyIGFuZFxuICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICBiaXRtYXNrID0gYmluZERhdGFbMV0sXG4gICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgIHBhcnRpYWxSaWdodEFyZ3MgPSBiaW5kRGF0YVszXSxcbiAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdLFxuICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAga2V5ID0gZnVuYztcblxuICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXM7XG4gICAgICBpZiAocGFydGlhbEFyZ3MpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgYXJncyB8fCAoYXJncyA9IHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncykge1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycnkgJiYgYXJncy5sZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVXcmFwcGVyKFtmdW5jLCAoaXNDdXJyeUJvdW5kID8gYml0bWFzayA6IGJpdG1hc2sgJiB+MyksIGFyZ3MsIG51bGwsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBhcmd1bWVudHMpO1xuICAgICAgaWYgKGlzQmluZEtleSkge1xuICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgIH1cbiAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgIHJldHVybiBib3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgaXNMYXJnZSA9IGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUodmFsdWVzKTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChpbmRleE9mKHZhbHVlcywgdmFsdWUpIDwgMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBpc1N0cmljdCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcidcbiAgICAgICAgICAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgdmFsdWUgPSBiYXNlRmxhdHRlbih2YWx1ZSwgaXNTaGFsbG93LCBpc1N0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK3ZhbEluZGV4IDwgdmFsTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAqIHRoYXQgYWxsb3dzIHBhcnRpYWwgXCJfLndoZXJlXCIgc3R5bGUgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2lzV2hlcmU9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGFgIG9iamVjdHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgd2hlbiBjb21wYXJpbmcgb2JqZWN0cywgYGFgIGhhcyBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyBvZiBgYmBcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZXhpdCBlYXJseSBmb3IgaWRlbnRpY2FsIHZhbHVlc1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgcmV0dXJuIGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgb3RoZXJUeXBlID0gdHlwZW9mIGI7XG5cbiAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICEoYSAmJiBvYmplY3RUeXBlc1t0eXBlXSkgJiZcbiAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjRcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgW1tDbGFzc11dIG5hbWVzXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgIG90aGVyQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGIpO1xuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgIH1cbiAgICBpZiAob3RoZXJDbGFzcyA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSAhPSBvdGhlckNsYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAvLyBjb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcbiAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICA/IGIgIT0gK2JcbiAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNClcbiAgICAgICAgLy8gdHJlYXQgc3RyaW5nIHByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluc3RhbmNlcyBhcyBlcXVhbFxuICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgfVxuICAgIHZhciBpc0FyciA9IGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzO1xuICAgIGlmICghaXNBcnIpIHtcbiAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgIHZhciBhV3JhcHBlZCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICBpZiAoYVdyYXBwZWQgfHwgYldyYXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGFXcmFwcGVkID8gYS5fX3dyYXBwZWRfXyA6IGEsIGJXcmFwcGVkID8gYi5fX3dyYXBwZWRfXyA6IGIsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvYmplY3RDbGFzcyB8fCAoIXN1cHBvcnQubm9kZUNsYXNzICYmIChpc05vZGUoYSkgfHwgaXNOb2RlKGIpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgdmFyIGN0b3JBID0gIXN1cHBvcnQuYXJnc09iamVjdCAmJiBpc0FyZ3VtZW50cyhhKSA/IE9iamVjdCA6IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgY3RvckIgPSAhc3VwcG9ydC5hcmdzT2JqZWN0ICYmIGlzQXJndW1lbnRzKGIpID8gT2JqZWN0IDogYi5jb25zdHJ1Y3RvcjtcblxuICAgICAgLy8gbm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWxcbiAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgIShpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckIpICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYilcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3N1bWUgY3ljbGljIHN0cnVjdHVyZXMgYXJlIGVxdWFsXG4gICAgLy8gdGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpYyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjFcbiAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICBzdGFja0EucHVzaChhKTtcbiAgICBzdGFja0IucHVzaChiKTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgIC8vIGNvbXBhcmUgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIHNpemUgPSBiLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gbGVuZ3RoO1xuXG4gICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICBpZiAoaXNXaGVyZSkge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgaWYgKChyZXN1bHQgPSBiYXNlSXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtzaXplXSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAvLyB3aGljaCwgaW4gdGhpcyBjYXNlLCBpcyBtb3JlIGNvc3RseVxuICAgICAgZm9ySW4oYiwgZnVuY3Rpb24odmFsdWUsIGtleSwgYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJiBiYXNlSXNFcXVhbChhW2tleV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgIWlzV2hlcmUpIHtcbiAgICAgICAgLy8gZW5zdXJlIGJvdGggb2JqZWN0cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG4gICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBgc2l6ZWAgd2lsbCBiZSBgLTFgIGlmIGBhYCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gYGJgXG4gICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFja0EucG9wKCk7XG4gICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAqIGZvciByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICogb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgc2VlbiA9IChjYWxsYmFjayB8fCBpc0xhcmdlKSA/IGdldEFycmF5KCkgOiByZXN1bHQ7XG5cbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgc2VlbiA9IGNhY2hlO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICBpZiAoaXNTb3J0ZWRcbiAgICAgICAgICAgID8gIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gY29tcHV0ZWRcbiAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICByZWxlYXNlT2JqZWN0KHNlZW4pO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggYW4gb3B0aW9uYWwgYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgbWV0aG9kIGZsYWdzIHRvIGNvbXBvc2UuXG4gICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICogIDEgLSBgXy5iaW5kYFxuICAgKiAgMiAtIGBfLmJpbmRLZXlgXG4gICAqICA0IC0gYF8uY3VycnlgXG4gICAqICA4IC0gYF8uY3VycnlgIChib3VuZClcbiAgICogIDE2IC0gYF8ucGFydGlhbGBcbiAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlXG4gICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgIGlzUGFydGlhbCA9IGJpdG1hc2sgJiAxNixcbiAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICBpZiAoIWlzQmluZEtleSAmJiAhaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICB9XG4gICAgaWYgKGlzUGFydGlhbCAmJiAhcGFydGlhbEFyZ3MubGVuZ3RoKSB7XG4gICAgICBiaXRtYXNrICY9IH4xNjtcbiAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1BhcnRpYWxSaWdodCAmJiAhcGFydGlhbFJpZ2h0QXJncy5sZW5ndGgpIHtcbiAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHRBcmdzID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgaWYgKGJpbmREYXRhICYmIGJpbmREYXRhICE9PSB0cnVlKSB7XG4gICAgICAvLyBjbG9uZSBgYmluZERhdGFgXG4gICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgIGlmIChiaW5kRGF0YVsyXSkge1xuICAgICAgICBiaW5kRGF0YVsyXSA9IHNsaWNlKGJpbmREYXRhWzJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kRGF0YVszXSkge1xuICAgICAgICBiaW5kRGF0YVszXSA9IHNsaWNlKGJpbmREYXRhWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBgdGhpc0JpbmRpbmdgIGlzIG5vdCBwcmV2aW91c2x5IGJvdW5kXG4gICAgICBpZiAoaXNCaW5kICYmICEoYmluZERhdGFbMV0gJiAxKSkge1xuICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICB9XG4gICAgICAvLyBzZXQgaWYgcHJldmlvdXNseSBib3VuZCBidXQgbm90IGN1cnJlbnRseSAoc3Vic2VxdWVudCBjdXJyaWVkIGZ1bmN0aW9ucylcbiAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICBiaXRtYXNrIHw9IDg7XG4gICAgICB9XG4gICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgaWYgKGlzQ3VycnkgJiYgIShiaW5kRGF0YVsxXSAmIDQpKSB7XG4gICAgICAgIGJpbmREYXRhWzVdID0gYXJpdHk7XG4gICAgICB9XG4gICAgICAvLyBhcHBlbmQgcGFydGlhbCBsZWZ0IGFyZ3VtZW50c1xuICAgICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzXG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgdW5zaGlmdC5hcHBseShiaW5kRGF0YVszXSB8fCAoYmluZERhdGFbM10gPSBbXSksIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgfVxuICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgIGJpbmREYXRhWzFdIHw9IGJpdG1hc2s7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlci5hcHBseShudWxsLCBiaW5kRGF0YSk7XG4gICAgfVxuICAgIC8vIGZhc3QgcGF0aCBmb3IgYF8uYmluZGBcbiAgICB2YXIgY3JlYXRlciA9IChiaXRtYXNrID09IDEgfHwgYml0bWFzayA9PT0gMTcpID8gYmFzZUJpbmQgOiBiYXNlQ3JlYXRlV3JhcHBlcjtcbiAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBjb21waWxlZCBpdGVyYXRpb24gZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW29wdGlvbnNdIFRoZSBjb21waWxlIG9wdGlvbnMgb2JqZWN0KHMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXJyYXldIENvZGUgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpdGVyYWJsZSBpcyBhbiBhcnJheSBvciBhcnJheS1saWtlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZUhhc10gU3BlY2lmeSB1c2luZyBgaGFzT3duUHJvcGVydHlgIGNoZWNrcyBpbiB0aGUgb2JqZWN0IGxvb3AuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmtleXNdIEEgcmVmZXJlbmNlIHRvIGBfLmtleXNgIGZvciB1c2UgaW4gb3duIHByb3BlcnR5IGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFyZ3NdIEEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBpdGVyYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9wXSBDb2RlIHRvIGV4ZWN1dGUgYmVmb3JlIHRoZSBpdGVyYXRpb24gYnJhbmNoZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb29wXSBDb2RlIHRvIGV4ZWN1dGUgaW4gdGhlIG9iamVjdCBsb29wLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm90dG9tXSBDb2RlIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGl0ZXJhdGlvbiBicmFuY2hlcy5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKCkge1xuICAgIC8vIGRhdGEgcHJvcGVydGllc1xuICAgIGl0ZXJhdG9yRGF0YS5zaGFkb3dlZFByb3BzID0gc2hhZG93ZWRQcm9wcztcblxuICAgIC8vIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICBpdGVyYXRvckRhdGEuYXJyYXkgPSBpdGVyYXRvckRhdGEuYm90dG9tID0gaXRlcmF0b3JEYXRhLmxvb3AgPSBpdGVyYXRvckRhdGEudG9wID0gJyc7XG4gICAgaXRlcmF0b3JEYXRhLmluaXQgPSAnaXRlcmFibGUnO1xuICAgIGl0ZXJhdG9yRGF0YS51c2VIYXMgPSB0cnVlO1xuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyBpbnRvIGEgdGVtcGxhdGUgZGF0YSBvYmplY3RcbiAgICBmb3IgKHZhciBvYmplY3QsIGluZGV4ID0gMDsgb2JqZWN0ID0gYXJndW1lbnRzW2luZGV4XTsgaW5kZXgrKykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpdGVyYXRvckRhdGFba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IGl0ZXJhdG9yRGF0YS5hcmdzO1xuICAgIGl0ZXJhdG9yRGF0YS5maXJzdEFyZyA9IC9eW14sXSsvLmV4ZWMoYXJncylbMF07XG5cbiAgICAvLyBjcmVhdGUgdGhlIGZ1bmN0aW9uIGZhY3RvcnlcbiAgICB2YXIgZmFjdG9yeSA9IEZ1bmN0aW9uKFxuICAgICAgICAnYmFzZUNyZWF0ZUNhbGxiYWNrLCBlcnJvckNsYXNzLCBlcnJvclByb3RvLCBoYXNPd25Qcm9wZXJ0eSwgJyArXG4gICAgICAgICdpbmRpY2F0b3JPYmplY3QsIGlzQXJndW1lbnRzLCBpc0FycmF5LCBpc1N0cmluZywga2V5cywgb2JqZWN0UHJvdG8sICcgK1xuICAgICAgICAnb2JqZWN0VHlwZXMsIG5vbkVudW1Qcm9wcywgc3RyaW5nQ2xhc3MsIHN0cmluZ1Byb3RvLCB0b1N0cmluZycsXG4gICAgICAncmV0dXJuIGZ1bmN0aW9uKCcgKyBhcmdzICsgJykge1xcbicgKyBpdGVyYXRvclRlbXBsYXRlKGl0ZXJhdG9yRGF0YSkgKyAnXFxufSdcbiAgICApO1xuXG4gICAgLy8gcmV0dXJuIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgIHJldHVybiBmYWN0b3J5KFxuICAgICAgYmFzZUNyZWF0ZUNhbGxiYWNrLCBlcnJvckNsYXNzLCBlcnJvclByb3RvLCBoYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGluZGljYXRvck9iamVjdCwgaXNBcmd1bWVudHMsIGlzQXJyYXksIGlzU3RyaW5nLCBpdGVyYXRvckRhdGEua2V5cywgb2JqZWN0UHJvdG8sXG4gICAgICBvYmplY3RUeXBlcywgbm9uRW51bVByb3BzLCBzdHJpbmdDbGFzcywgc3RyaW5nUHJvdG8sIHRvU3RyaW5nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBcImluZGV4T2ZcIiBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgdmFyIHJlc3VsdCA9IChyZXN1bHQgPSBsb2Rhc2guaW5kZXhPZikgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFRoZSBkYXRhIGFycmF5IHRvIHNldC5cbiAgICovXG4gIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICBkZWZpbmVQcm9wZXJ0eShmdW5jLCAnX19iaW5kRGF0YV9fJywgZGVzY3JpcHRvcik7XG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3MgfHwgZmFsc2U7XG4gIH1cbiAgLy8gZmFsbGJhY2sgZm9yIGJyb3dzZXJzIHRoYXQgY2FuJ3QgZGV0ZWN0IGBhcmd1bWVudHNgIG9iamVjdHMgYnkgW1tDbGFzc11dXG4gIGlmICghc3VwcG9ydC5hcmdzQ2xhc3MpIHtcbiAgICBpc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBGdW5jdGlvblxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggcHJvZHVjZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSBGdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKi9cbiAgdmFyIHNoaW1LZXlzID0gY3JlYXRlSXRlcmF0b3Ioe1xuICAgICdhcmdzJzogJ29iamVjdCcsXG4gICAgJ2luaXQnOiAnW10nLFxuICAgICd0b3AnOiAnaWYgKCEob2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdF0pKSByZXR1cm4gcmVzdWx0JyxcbiAgICAnbG9vcCc6ICdyZXN1bHQucHVzaChpbmRleCknXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICovXG4gIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoKHN1cHBvcnQuZW51bVByb3RvdHlwZXMgJiYgdHlwZW9mIG9iamVjdCA9PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBvYmplY3QubGVuZ3RoICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKSB7XG4gICAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfTtcblxuICAvKiogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBzaGFyZWQgYnkgYGVhY2hgLCBgZm9ySW5gLCBhbmQgYGZvck93bmAgKi9cbiAgdmFyIGVhY2hJdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ2FyZ3MnOiAnY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcnLFxuICAgICd0b3AnOiBcImNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMylcIixcbiAgICAnYXJyYXknOiBcInR5cGVvZiBsZW5ndGggPT0gJ251bWJlcidcIixcbiAgICAna2V5cyc6IGtleXMsXG4gICAgJ2xvb3AnOiAnaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdCdcbiAgfTtcblxuICAvKiogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBmb3IgYGFzc2lnbmAgYW5kIGBkZWZhdWx0c2AgKi9cbiAgdmFyIGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zID0ge1xuICAgICdhcmdzJzogJ29iamVjdCwgc291cmNlLCBndWFyZCcsXG4gICAgJ3RvcCc6XG4gICAgICAndmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuJyArXG4gICAgICAnICAgIGFyZ3NJbmRleCA9IDAsXFxuJyArXG4gICAgICBcIiAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xcblwiICtcbiAgICAgICd3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XFxuJyArXG4gICAgICAnICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcXG4nICtcbiAgICAgICcgIGlmIChpdGVyYWJsZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSB7JyxcbiAgICAna2V5cyc6IGtleXMsXG4gICAgJ2xvb3AnOiBcImlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XVwiLFxuICAgICdib3R0b20nOiAnICB9XFxufSdcbiAgfTtcblxuICAvKiogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBmb3IgYGZvckluYCBhbmQgYGZvck93bmAgKi9cbiAgdmFyIGZvck93bkl0ZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAndG9wJzogJ2lmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcXG4nICsgZWFjaEl0ZXJhdG9yT3B0aW9ucy50b3AsXG4gICAgJ2FycmF5JzogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiBjb21waWxlZCB0byBpdGVyYXRlIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgb2JqZWN0cywgYW5kXG4gICAqIHN0cmluZ3MgY29uc2lzdGVubHkgYWNyb3NzIGVudmlyb25tZW50cywgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgKiBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAqL1xuICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVJdGVyYXRvcihlYWNoSXRlcmF0b3JPcHRpb25zKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAqIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZVxuICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICogYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBGdW5jdGlvblxuICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICpcbiAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICogICByZXR1cm4gdHlwZW9mIGEgPT0gJ3VuZGVmaW5lZCcgPyBiIDogYTtcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICogZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgKi9cbiAgdmFyIGFzc2lnbiA9IGNyZWF0ZUl0ZXJhdG9yKGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zLCB7XG4gICAgJ3RvcCc6XG4gICAgICBkZWZhdWx0c0l0ZXJhdG9yT3B0aW9ucy50b3AucmVwbGFjZSgnOycsXG4gICAgICAgICc7XFxuJyArXG4gICAgICAgIFwiaWYgKGFyZ3NMZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XFxuXCIgK1xuICAgICAgICAnICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcXG4nICtcbiAgICAgICAgXCJ9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XFxuXCIgK1xuICAgICAgICAnICBjYWxsYmFjayA9IGFyZ3NbLS1hcmdzTGVuZ3RoXTtcXG4nICtcbiAgICAgICAgJ30nXG4gICAgICApLFxuICAgICdsb29wJzogJ3Jlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF0nXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgKiBiZSBjbG9uZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBhIGNhbGxiYWNrXG4gICAqIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlXG4gICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgKiBzaGFsbG93WzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHZhciBkZWVwID0gXy5jbG9uZShjaGFyYWN0ZXJzLCB0cnVlKTtcbiAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5taXhpbih7XG4gICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgKiAgIH0pXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lKGRvY3VtZW50LmJvZHkpO1xuICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICogLy8gPT4gMFxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YFxuICAgIC8vIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzIGZvciBgaXNEZWVwYCBhbmQgYGNhbGxiYWNrYFxuICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBpc0RlZXA7XG4gICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmVcbiAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICogY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobS4gRnVuY3Rpb25zXG4gICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChjaGFyYWN0ZXJzKTtcbiAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogdmFyIHZpZXcgPSB7XG4gICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgKiAgICdub2RlJzogZWxlbWVudFxuICAgKiB9O1xuICAgKlxuICAgKiB2YXIgY2xvbmUgPSBfLmNsb25lRGVlcCh2aWV3LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAqIH0pO1xuICAgKlxuICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAqICAgdGhpcy54ID0gMDtcbiAgICogICB0aGlzLnkgPSAwO1xuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgKiB9XG4gICAqXG4gICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHsgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlIH0pO1xuICAgKlxuICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICogZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBGdW5jdGlvblxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgKiAgIHRoaXMueCA9IDA7XG4gICAqICAgdGhpcy55ID0gMDtcbiAgICogfVxuICAgKlxuICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICogICB0aGlzLnggKz0geDtcbiAgICogICB0aGlzLnkgKz0geTtcbiAgICogfTtcbiAgICpcbiAgICogXy5mb3JJbihuZXcgU2hhcGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgKiB9KTtcbiAgICogLy8gPT4gbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICovXG4gIHZhciBmb3JJbiA9IGNyZWF0ZUl0ZXJhdG9yKGVhY2hJdGVyYXRvck9wdGlvbnMsIGZvck93bkl0ZXJhdG9yT3B0aW9ucywge1xuICAgICd1c2VIYXMnOiBmYWxzZVxuICB9KTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCwgZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBGdW5jdGlvblxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICogfSk7XG4gICAqIC8vID0+IGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICovXG4gIHZhciBmb3JPd24gPSBjcmVhdGVJdGVyYXRvcihlYWNoSXRlcmF0b3JPcHRpb25zLCBmb3JPd25JdGVyYXRvck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBtZXRob2RzXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgKi9cbiAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAqIFwiZW1wdHlcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNFbXB0eSh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0VtcHR5KCcnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHxcbiAgICAgICAgKHN1cHBvcnQuYXJnc0NsYXNzID8gY2xhc3NOYW1lID09IGFyZ3NDbGFzcyA6IGlzQXJndW1lbnRzKHZhbHVlKSkpIHx8XG4gICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICB9XG4gICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChhLCBiKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICpcbiAgICogb2JqZWN0ID09IGNvcHk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNFcXVhbChvYmplY3QsIGNvcHkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHZhciB3b3JkcyA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgKlxuICAgKiBfLmlzRXF1YWwod29yZHMsIG90aGVyV29yZHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICogICAgICAgYkdyZWV0ID0gXy5pc1N0cmluZyhiKSAmJiByZUdyZWV0LnRlc3QoYik7XG4gICAqXG4gICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICogfSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuICBpZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY0NsYXNzO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdCgxKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgKi9cbiAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5jb250YWlucyh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKCdwZWJibGVzJywgJ2ViJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgIHJlc3VsdCA9IChpc1N0cmluZyhjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSkgPiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBzZWxlY3RcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBkZXRlY3QsIGZpbmRXaGVyZVxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5maW5kKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAqIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLmZpbmQoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgKiBlbGVtZW50LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBlYWNoXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXyhbMSwgMiwgM10pLmZvckVhY2goZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAqXG4gICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSk7XG4gICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICovXG4gIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICogdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgY29sbGVjdFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICogLy8gPT4gWzMsIDYsIDldXG4gICAqXG4gICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAqIF07XG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICovXG4gIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgKiBjb2xsZWN0aW9uIHRoYXQgdGhlIGNhbGxiYWNrIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1ZXkgZm9yLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5yZWplY3QoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgKi9cbiAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgKiAgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50cyBhcyBgbmAuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICogLy8gPT4gWzMsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnVuaW5kZXhlZENoYXJzICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbi5zcGxpdCgnJyk7XG4gICAgfVxuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICByZXN1bHQubGVuZ3RoID0gbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAqIC8vID0+IFs0LCAxLCA2LCAzLCA1LCAyXVxuICAgKi9cbiAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICByZXN1bHRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAqIGFuZCBhcnJheS1saWtlIG9iamVjdHMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgY29sbGVjdGlvbi5sZW5ndGhgIG9yIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNpemUoWzEsIDJdKTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiBfLnNpemUoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAqIC8vID0+IDdcbiAgICovXG4gIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICogb2YgZXF1YWwgZWxlbWVudHMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogSWYgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNvbGxlY3Rpb25cbiAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICpcbiAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAqIGVsc2UgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNvcnRlZCBlbGVtZW50cy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguc2luKG51bSk7IH0pO1xuICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICpcbiAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuc2luKG51bSk7IH0sIE1hdGgpO1xuICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDI2IH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgKiAvLyA9PiBbWydiYXJuZXknLCAyNl0sIFsnZnJlZCcsIDMwXSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV1cbiAgICpcbiAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsIFsnbmFtZScsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgKi9cbiAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgIGlmICghaXNBcnIpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0WysraW5kZXhdID0gZ2V0T2JqZWN0KCk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICBvYmplY3QuaW5kZXggPSBpbmRleDtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICByZWxlYXNlQXJyYXkob2JqZWN0LmNyaXRlcmlhKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSAodGhlIG5lc3RpbmcgY2FuIGJlIHRvIGFueSBkZXB0aCkuIElmIGBpc1NoYWxsb3dgXG4gICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICogZmxhdHRlbmluZy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICpcbiAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICovXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgaWYgKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Jvb2xlYW4nICYmIGlzU2hhbGxvdyAhPSBudWxsKSB7XG4gICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICBpc1NoYWxsb3cgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIGFycmF5ID0gbWFwKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBhbHJlYWR5IHNvcnRlZFxuICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAqICB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAqIC8vID0+IDFcbiAgICpcbiAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAqIC8vID0+IDRcbiAgICpcbiAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAqIC8vID0+IDJcbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgfVxuICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAqXG4gICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgKiBlbHNlIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAqIC8vID0+IFsyLCAzXVxuICAgKlxuICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICogfSk7XG4gICAqIC8vID0+IFsyLCAzXVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgKiBdO1xuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgKlxuICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgKi9cbiAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgbiA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5yYW5nZSg0KTtcbiAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAqXG4gICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgKlxuICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICpcbiAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICpcbiAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAqXG4gICAqIF8ucmFuZ2UoMCk7XG4gICAqIC8vID0+IFtdXG4gICAqL1xuICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICBzdGVwID0gdHlwZW9mIHN0ZXAgPT0gJ251bWJlcicgPyBzdGVwIDogKCtzdGVwIHx8IDEpO1xuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAvLyBodHRwOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXNcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoIGEgdmFsdWVcbiAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgKlxuICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICogZWxzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKiAgaW50byBgYXJyYXlgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMjAgfSwgeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogdmFyIGRpY3QgPSB7XG4gICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgKiB9O1xuICAgKlxuICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICogfSk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAqIH0sIGRpY3QpO1xuICAgKiAvLyA9PiAyXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGxvdyA9IDAsXG4gICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkgOiBpZGVudGl0eTtcbiAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICA6IGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICogZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZSB1bmlxdWVuZXNzXG4gICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAqXG4gICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgKiBlbHNlIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIHVuaXF1ZVxuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDIsIDEsIDMsIDFdKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqXG4gICAqIF8udW5pcShbMSwgMSwgMiwgMiwgM10sIHRydWUpO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICpcbiAgICogXy51bmlxKFsnQScsICdiJywgJ0MnLCAnYScsICdCJywgJ2MnXSwgZnVuY3Rpb24obGV0dGVyKSB7IHJldHVybiBsZXR0ZXIudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDIuNSwgMywgMS41LCAyLCAzLjVdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAqXG4gICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICovXG4gIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICBpZiAodHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJyAmJiBpc1NvcnRlZCAhPSBudWxsKSB7XG4gICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAqIC8vID0+IFsyLCAzLCA0XVxuICAgKi9cbiAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgKiB9O1xuICAgKlxuICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAqIGZ1bmMoKTtcbiAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuXG4gICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAqIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICpcbiAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgKlxuICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAqIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAqIH0sIGZhbHNlKTtcbiAgICovXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXJncyxcbiAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHN0YW1wLFxuICAgICAgICB0aGlzQXJnLFxuICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgIH1cbiAgICB3YWl0ID0gbmF0aXZlTWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAobmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICB9XG4gICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAqIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlXG4gICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAqXG4gICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgdGhyb3R0bGVkKTtcbiAgICpcbiAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAqIGpRdWVyeSgnLmludGVyYWN0aXZlJykub24oJ2NsaWNrJywgXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHtcbiAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgKiB9KSk7XG4gICAqL1xuICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICB9XG4gICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICBkZWJvdW5jZU9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBpcyBleGVjdXRlZCB3aXRoXG4gICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAqIH0pO1xuICAgKlxuICAgKiBwKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgKiBJZiBgZnVuY2AgaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICogICB9O1xuICAgKiB9KTtcbiAgICpcbiAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgXCJfLnBsdWNrXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICBhID0gZnVuY1trZXldO1xuXG4gICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgIC8vIGZhc3QgcGF0aCB0aGUgY29tbW9uIGNhc2Ugb2YgcHJvdmlkaW5nIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBiID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWQgYXJlIGNoYWluYWJsZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAqIH1cbiAgICpcbiAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAqIC8vID0+ICdGcmVkJ1xuICAgKlxuICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAqIC8vID0+ICdGcmVkJ1xuICAgKlxuICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCk7XG4gICAqIC8vID0+ICdGcmVkJ1xuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgIGlmICghc291cmNlIHx8ICghb3B0aW9ucyAmJiAhbWV0aG9kTmFtZXMubGVuZ3RoKSkge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgfVxuICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICBvYmplY3QgPSBsb2Rhc2g7XG4gICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICB9XG4gICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24oY3Rvcik7XG5cbiAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBub29wKCkge1xuICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTsgfSk7XG4gICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKi9cbiAgdmFyIG5vdyA9IGlzTmF0aXZlKG5vdyA9IERhdGUubm93KSAmJiBub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgXCJfLnBsdWNrXCIgc3R5bGUgZnVuY3Rpb24sIHdoaWNoIHJldHVybnMgdGhlIGBrZXlgIHZhbHVlIG9mIGFcbiAgICogZ2l2ZW4gb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCduYW1lJyk7XG4gICAqXG4gICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICpcbiAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB3aXRoIGV4cGxpY2l0XG4gICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgKiAgICAgLm1hcChmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5uYW1lICsgJyBpcyAnICsgY2hyLmFnZTsgfSlcbiAgICogICAgIC5maXJzdCgpXG4gICAqICAgICAudmFsdWUoKTtcbiAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICovXG4gIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAbmFtZSBjaGFpblxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICogXTtcbiAgICpcbiAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgKiBfKGNoYXJhY3RlcnMpLmZpcnN0KCk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICpcbiAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICogICAuZmlyc3QoKVxuICAgKiAgIC5waWNrKCdhZ2UnKVxuICAgKiAgIC52YWx1ZSgpO1xuICAgKiAvLyA9PiB7ICdhZ2UnOiAzNiB9XG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBgdG9TdHJpbmdgIHJlc3VsdCBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICpcbiAgICogQG5hbWUgdG9TdHJpbmdcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgKiAvLyA9PiAnMSwyLDMnXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl9fd3JhcHBlZF9fKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICpcbiAgICogQG5hbWUgdmFsdWVPZlxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgdmFsdWVcbiAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkudmFsdWVPZigpO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgbG9kYXNoLmNyZWF0ZUNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2s7XG4gIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgbG9kYXNoLndyYXAgPSB3cmFwO1xuXG4gIC8vIGFkZCBhbGlhc2VzXG4gIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAvLyBhZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYFxuICBtaXhpbihsb2Rhc2gpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICBsb2Rhc2guY29udGFpbnMgPSBjb250YWlucztcbiAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gIGxvZGFzaC5ub3cgPSBub3c7XG4gIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG5cbiAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kO1xuICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuXG4gIG1peGluKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSB7fVxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0oKSwgZmFsc2UpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXT0gZnVuY3Rpb24obiwgZ3VhcmQpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIG4sIGd1YXJkKTtcblxuICAgICAgICByZXR1cm4gIWNoYWluQWxsICYmIChuID09IG51bGwgfHwgKGd1YXJkICYmICEoY2FsbGJhY2thYmxlICYmIHR5cGVvZiBuID09ICdmdW5jdGlvbicpKSlcbiAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBzdHJpbmdcbiAgICovXG4gIGxvZGFzaC5WRVJTSU9OID0gJzIuNC4xJztcblxuICAvLyBhZGQgXCJDaGFpbmluZ1wiIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlclxuICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlT2Y7XG4gIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzXG4gIGJhc2VFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuXG4gICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICA6IHJlc3VsdDtcbiAgICB9O1xuICB9KTtcblxuICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdGhlIGV4aXN0aW5nIHdyYXBwZWQgdmFsdWVcbiAgYmFzZUVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBuZXcgd3JhcHBlZCB2YWx1ZXNcbiAgYmFzZUVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBhdm9pZCBhcnJheS1saWtlIG9iamVjdCBidWdzIHdpdGggYEFycmF5I3NoaWZ0YCBhbmQgYEFycmF5I3NwbGljZWBcbiAgLy8gaW4gSUUgPCA5LCBGaXJlZm94IDwgMTAsIE5hcndoYWwsIGFuZCBSaW5nb0pTXG4gIGlmICghc3VwcG9ydC5zcGxpY2VPYmplY3RzKSB7XG4gICAgYmFzZUVhY2goWydwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgaXNTcGxpY2UgPSBtZXRob2ROYW1lID09ICdzcGxpY2UnO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2hhaW5BbGwgfHwgaXNTcGxpY2UpXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIGlzIGxvYWRlZCB3aXRoIGEgUmVxdWlyZUpTIHNoaW0gY29uZmlnLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sI2NvbmZpZy1zaGltXG4gICAgcm9vdC5fID0gbG9kYXNoO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbG9kYXNoO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gbG9kYXNoKS5fID0gbG9kYXNoO1xuICAgIH1cbiAgICAvLyBpbiBOYXJ3aGFsIG9yIFJoaW5vIC1yZXF1aXJlXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gbG9kYXNoO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBsb2Rhc2g7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKiEgSGFtbWVyLkpTIC0gdjEuMS4zIC0gMjAxNC0wNS0yMlxuICogaHR0cDovL2VpZ2h0bWVkaWEuZ2l0aHViLmlvL2hhbW1lci5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXIgPGoudGFuZ2VsZGVyQGdtYWlsLmNvbT47XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cblxuKGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbWFpblxuICogQG1vZHVsZSBoYW1tZXJcbiAqXG4gKiBAY2xhc3MgSGFtbWVyXG4gKiBAc3RhdGljXG4gKi9cblxuLyoqXG4gKiBIYW1tZXIsIHVzZSB0aGlzIHRvIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGBgYGBcbiAqIHZhciBoYW1tZXJ0aW1lID0gbmV3IEhhbW1lcihteUVsZW1lbnQpO1xuICogYGBgYFxuICpcbiAqIEBtZXRob2QgSGFtbWVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiBAcmV0dXJuIHtIYW1tZXIuSW5zdGFuY2V9XG4gKi9cbnZhciBIYW1tZXIgPSBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSGFtbWVyLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuLyoqXG4gKiB2ZXJzaW9uLCBhcyBkZWZpbmVkIGluIHBhY2thZ2UuanNvblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGF0IGVhY2ggYnVpbGRcbiAqIEBwcm9wZXJ0eSBWRVJTSU9OXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzEuMS4zJztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICogbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBgL2dlc3R1cmVzYC4gRWFjaCBnZXN0dXJlIGNhbiBiZSBkaXNhYmxlZC9lbmFibGVkXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cbiAqIFlvdSBjYW4gc2V0IHRoZSBkZWZhdWx0cyBmb3IgYWxsIGluc3RhbmNlcyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmcgYW4gaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgYFxuICogIEhhbW1lci5kZWZhdWx0cy5kcmFnID0gZmFsc2U7XG4gKiAgSGFtbWVyLmRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uID0gJ3Bhbi15JztcbiAqICBkZWxldGUgSGFtbWVyLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XG4gKiBgYGBgXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiB0aGlzIHNldHRpbmcgb2JqZWN0IGFkZHMgc3R5bGVzIGFuZCBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZ1xuICAgICAqIGl0cyBuYXRpdmUgYmVoYXZpb3IuIFRoZSBjc3MgcHJvcGVydGllcyBhcmUgYXV0byBwcmVmaXhlZCBmb3IgdGhlIGJyb3dzZXJzIHdoZW4gbmVlZGVkLlxuICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgYmVoYXZpb3I6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIFdoZW4gdGhlIHZhbHVlIGlzIGBub25lYCBpdCBhbHNvIHNldHNcbiAgICAgICAgICogYG9uc2VsZWN0c3RhcnQ9ZmFsc2VgIGZvciBJRSBvbiB0aGUgZWxlbWVudC4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgYW5kIGhvdyBhIGdpdmVuIHJlZ2lvbiBjYW4gYmUgbWFuaXB1bGF0ZWQgYnkgdGhlIHVzZXIgKGZvciBpbnN0YW5jZSwgYnkgcGFubmluZyBvciB6b29taW5nKS5cbiAgICAgICAgICogVXNlZCBieSBDaHJvbWUgMzU+IGFuZCBJRTEwPi4gQnkgZGVmYXVsdCB0aGlzIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGFueSB0b3VjaCBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0OiAncGFuLXknXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci50b3VjaENhbGxvdXRcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci5jb250ZW50Wm9vbWluZ1xuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuXG4gICAgICAgICAqIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnVzZXJEcmFnXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gU2FmYXJpIG9uIGlQaG9uZS4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91IGRvbid0IHNwZWNpZnkgYW4gYWxwaGEgdmFsdWUsIFNhZmFyaSBvbiBpUGhvbmUgYXBwbGllcyBhIGRlZmF1bHQgYWxwaGEgdmFsdWVcbiAgICAgICAgICogdG8gdGhlIGNvbG9yLiBUbyBkaXNhYmxlIHRhcCBoaWdobGlnaHRpbmcsIHNldCB0aGUgYWxwaGEgdmFsdWUgdG8gMCAoaW52aXNpYmxlKS5cbiAgICAgICAgICogSWYgeW91IHNldCB0aGUgYWxwaGEgdmFsdWUgdG8gMS4wIChvcGFxdWUpLCB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSB3aGVuIHRhcHBlZC5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnRhcEhpZ2hsaWdodENvbG9yXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbi8qKlxuICogaGFtbWVyIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkhhbW1lci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IYW1tZXIuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkhhbW1lci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IYW1tZXIuTk9fTU9VU0VFVkVOVFMgPSAoSGFtbWVyLkhBU19UT1VDSEVWRU5UUyAmJiBIYW1tZXIuSVNfTU9CSUxFKSB8fCBIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggSGFtbWVyIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkhhbW1lci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBIYW1tZXIuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gSGFtbWVyLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gSGFtbWVyLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBIYW1tZXIuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBIYW1tZXIuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gSGFtbWVyLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gSGFtbWVyLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gSGFtbWVyLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBIYW1tZXIuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEhhbW1lci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkhhbW1lci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuSGFtbWVyLnBsdWdpbnMgPSBIYW1tZXIucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkhhbW1lci5nZXN0dXJlcyA9IEhhbW1lci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGlmKEhhbW1lci5SRUFEWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICAgIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgSGFtbWVyLmdlc3R1cmVzXG4gICAgVXRpbHMuZWFjaChIYW1tZXIuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICAgICAgRGV0ZWN0aW9uLnJlZ2lzdGVyKGdlc3R1cmUpO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgICBFdmVudC5vblRvdWNoKEhhbW1lci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCk7XG4gICAgRXZlbnQub25Ub3VjaChIYW1tZXIuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgICAvLyBIYW1tZXIgaXMgcmVhZHkuLi4hXG4gICAgSGFtbWVyLlJFQURZID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHN0YXRpY1xuICovXG52YXIgVXRpbHMgPSBIYW1tZXIudXRpbHMgPSB7XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAoZGVzdFtrZXldICE9PSB1bmRlZmluZWQgJiYgbWVyZ2UpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgICAqIEBtZXRob2QgZWFjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpLCBsZW47XG5cbiAgICAgICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcihpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgICAqIEBtZXRob2QgaW5TdHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgICAqL1xuICAgIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICAgKiBAbWV0aG9kIGluQXJyYXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgICAqL1xuICAgIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kKSB7XG4gICAgICAgIGlmKHNyYy5pbmRleE9mKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXggPT09IC0xKSA/IGZhbHNlIDogaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICAgKiBAbWV0aG9kIGhhc1BhcmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgICAqL1xuICAgIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgICB3aGlsZShub2RlKSB7XG4gICAgICAgICAgICBpZihub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgICAqIEBtZXRob2QgZ2V0Q2VudGVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgICAgIHZhciBwYWdlWCA9IFtdLFxuICAgICAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgICAgIGNsaWVudFkgPSBbXSxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICAgICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICAgICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICAgICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlWDogKG1pbi5hcHBseShNYXRoLCBwYWdlWCkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVgpKSAvIDIsXG4gICAgICAgICAgICBwYWdlWTogKG1pbi5hcHBseShNYXRoLCBwYWdlWSkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVkpKSAvIDIsXG4gICAgICAgICAgICBjbGllbnRYOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFgpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFgpKSAvIDIsXG4gICAgICAgICAgICBjbGllbnRZOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFkpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFkpKSAvIDJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAgICovXG4gICAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IE1hdGguYWJzKGRlbHRhWCAvIGRlbHRhVGltZSkgfHwgMCxcbiAgICAgICAgICAgIHk6IE1hdGguYWJzKGRlbHRhWSAvIGRlbHRhVGltZSkgfHwgMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAgICogQG1ldGhvZCBnZXRBbmdsZVxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBnZXRBbmdsZTogZnVuY3Rpb24gZ2V0QW5nbGUodG91Y2gxLCB0b3VjaDIpIHtcbiAgICAgICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkbyBhIHNtYWxsIGNvbXBhcmlzaW9uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAgICogQG1ldGhvZCBnZXREaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fTEVGVHxSSUdIVHxVUHxET1dOYFxuICAgICAqL1xuICAgIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgICAgICB5ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSk7XG5cbiAgICAgICAgaWYoeCA+PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAgICogQG1ldGhvZCBnZXREaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqL1xuICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgICAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgICAqIEBtZXRob2QgZ2V0U2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAgICovXG4gICAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgICAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICAgKiBAbWV0aG9kIGdldFJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgICAqL1xuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICAgICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAgICogQG1ldGhvZCBpc1ZlcnRpY2FsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fVVB8RE9XTmBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgICAqL1xuICAgIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldFByZWZpeGVkQ3NzOiBmdW5jdGlvbiBzZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKSB7XG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByb3A7XG4gICAgICAgICAgICAvLyBwcmVmaXhlc1xuICAgICAgICAgICAgaWYocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICBwID0gcHJlZml4ZXNbaV0gKyBwLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSBzdHlsZVxuICAgICAgICAgICAgaWYocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT0gbnVsbCB8fCB0b2dnbGUpICYmIHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3IgYnkgc2V0dGluZyBjc3MgcHJvcGVydGllcy5cbiAgICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9nZ2xlQmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAgICovXG4gICAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICAgICAgaWYoIXByb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgICAgIFV0aWxzLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICAgICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgICAgIGlmKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBhIHN0cmluZyB3aXRoIHVuZGVyc2NvcmVzIHRvIGNhbWVsQ2FzZVxuICAgICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gY2FtZWxDYXNlU3RyXG4gICAgICovXG4gICAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG52YXIgRXZlbnQgPSBIYW1tZXIuZXZlbnQgPSB7XG4gICAgLyoqXG4gICAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICAgKiB0aGlzIGlzIHVzZWQgdG8gc3RvcCBtb3VzZSBldmVudHNcbiAgICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICAgKiBAcHJvcGVydHkgc2hvdWxkX2RldGVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBldmVudCBiaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICAgICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgICAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBldmVudCB1bmJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgICAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgICAqIEBtZXRob2Qgb25Ub3VjaFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJuIG9uVG91Y2hIYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNvcmUgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgaXNQb2ludGVyID0gSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICAgICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAgICAgLy8ganVzdCBhIHZhbGlkIHN0YXJ0IGV2ZW50LCBidXQgbm8gbW91c2VcbiAgICAgICAgICAgIH0gZWxzZSBpZighaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICAgICAgICBpZihzZWxmLnNob3VsZERldGVjdCkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgICAgICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlcmV2ZW50IG9iamVjdCBhZnRlciB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvcmUgZGV0ZWN0aW9uIG1ldGhvZFxuICAgICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgaGFtbWVyLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAgICogQG1ldGhvZCBkb0RldGVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqL1xuICAgIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciB0b3VjaExpc3QgPSB0aGlzLmdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKTtcbiAgICAgICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdmFyIHRyaWdnZXJDaGFuZ2UgPSB0b3VjaExpc3QudHJpZ2dlcjsgLy8gdXNlZCBieSBmYWtlTXVsdGl0b3VjaCBwbHVnaW5cbiAgICAgICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAgICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1RPVUNIO1xuICAgICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgICAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgICAgICAvLyBidXQgb25seSBhZnRlciBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgdGhlIGZpcnN0IHRpbWUgd2UgYWN0dWFseSB3YW50IGEgU1RBUlRcbiAgICAgICAgaWYoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGlzLCBzZWUgYWJvdmVcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICAgICAgdmFyIGV2RGF0YSA9IHRoaXMuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCB0cmlnZ2VyVHlwZSwgdG91Y2hMaXN0LCBldik7XG5cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAgICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICAgICAgaWYoZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICAgICAgaWYodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgICAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgICAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgICAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIGRldGVybWluZUV2ZW50VHlwZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgICAqL1xuICAgIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XG4gICAgICAgIHZhciB0eXBlcztcbiAgICAgICAgaWYoSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBsb3N0cG9pbnRlcmNhcHR1cmUnXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihIYW1tZXIuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAnXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcbiAgICAgICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICAgKiBAbWV0aG9kIGdldFRvdWNoTGlzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hlc1xuICAgICAqL1xuICAgIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICAgICAgaWYoSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0b3VjaGxpc3RcbiAgICAgICAgaWYoZXYudG91Y2hlcykge1xuICAgICAgICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICAgICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgICAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdG91Y2hMaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBmYWtlIHRvdWNoTGlzdCBmcm9tIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGV2LmlkZW50aWZpZXIgPSAxO1xuICAgICAgICByZXR1cm4gW2V2XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAgICogQG1ldGhvZCBjb2xsZWN0RXZlbnREYXRhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9UT1VDSDtcbiAgICAgICAgaWYoVXRpbHMuaW5TdHIoZXYudHlwZSwgJ21vdXNlJykgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX01PVVNFLCBldikpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9NT1VTRTtcbiAgICAgICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyY0V2ZW50ID0gdGhpcy5zcmNFdmVudDtcbiAgICAgICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgaGFtbWVyXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG52YXIgUG9pbnRlckV2ZW50ID0gSGFtbWVyLlBvaW50ZXJFdmVudCA9IHtcbiAgICAvKipcbiAgICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxuICAgICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgcG9pbnRlcnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBwb2ludGVycyBhcyBhbiBhcnJheVxuICAgICAqIEBtZXRob2QgZ2V0VG91Y2hMaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgICAqL1xuICAgIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xuICAgICAgICB2YXIgdG91Y2hsaXN0ID0gW107XG4gICAgICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgICAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgICAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdG91Y2hsaXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgcG9pbnRlclxuICAgICAqIEBtZXRob2QgdXBkYXRlUG9pbnRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgICAqL1xuICAgIHVwZGF0ZVBvaW50ZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnQuaWRlbnRpZmllciA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdID0gcG9pbnRlckV2ZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICAgKiBAbWV0aG9kIG1hdGNoVHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludGVyVHlwZSBtYXRjaGVzIGBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTmBcbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICAgKi9cbiAgICBtYXRjaFR5cGU6IGZ1bmN0aW9uIG1hdGNoVHlwZShwb2ludGVyVHlwZSwgZXYpIHtcbiAgICAgICAgaWYoIWV2LnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHR5cGVzID0ge307XG5cbiAgICAgICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgICAgIHR5cGVzW1BPSU5URVJfVE9VQ0hdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgUE9JTlRFUl9UT1VDSCkpO1xuICAgICAgICB0eXBlc1tQT0lOVEVSX1BFTl0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9QRU4gfHwgUE9JTlRFUl9QRU4pKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXRMaXN0KCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgaGFtbWVyXG4gKlxuICogQGNsYXNzIERldGVjdGlvblxuICogQHN0YXRpY1xuICovXG52YXIgRGV0ZWN0aW9uID0gSGFtbWVyLmRldGVjdGlvbiA9IHtcbiAgICAvLyBjb250YWlucyBhbGwgcmVnaXN0cmVkIEhhbW1lci5nZXN0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICAgIGdlc3R1cmVzOiBbXSxcblxuICAgIC8vIGRhdGEgb2YgdGhlIGN1cnJlbnQgSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uIHNlc3Npb25cbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgLy8gdGhlIHByZXZpb3VzIEhhbW1lci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAgIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxuICAgIHByZXZpb3VzOiBudWxsLFxuXG4gICAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gICAgc3RvcHBlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBzdGFydCBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgKiBAbWV0aG9kIHN0YXJ0RGV0ZWN0XG4gICAgICogQHBhcmFtIHtIYW1tZXIuSW5zdGFuY2V9IGluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAgICovXG4gICAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgICAgICAvLyBhbHJlYWR5IGJ1c3kgd2l0aCBhIEhhbW1lci5nZXN0dXJlIGRldGVjdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaG9sZHMgY3VycmVudCBzZXNzaW9uXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBIYW1tZXJJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgICAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICAgICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbW1lci5nZXN0dXJlIGRldGVjdGlvblxuICAgICAqIEBtZXRob2QgZGV0ZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICAgICAgaWYoIXRoaXMuY3VycmVudCB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICAgICAgZXZlbnREYXRhID0gdGhpcy5leHRlbmRFdmVudERhdGEoZXZlbnREYXRhKTtcblxuICAgICAgICAvLyBoYW1tZXIgaW5zdGFuY2UgYW5kIGluc3RhbmNlIG9wdGlvbnNcbiAgICAgICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgICAgIGluc3RPcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgIC8vIGNhbGwgSGFtbWVyLmdlc3R1cmUgaGFuZGxlcnNcbiAgICAgICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgaW5zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XG4gICAgICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Lmxhc3RFdmVudCA9IGV2ZW50RGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGV2ZW50RGF0YS5ldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNsZWFyIHRoZSBIYW1tZXIuZ2VzdHVyZSB2YXJzXG4gICAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgSGFtbWVyLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICAgKiB0byBzdG9wIG90aGVyIEhhbW1lci5nZXN0dXJlcyBmcm9tIGJlaW5nIGZpcmVkXG4gICAgICogQG1ldGhvZCBzdG9wRGV0ZWN0XG4gICAgICovXG4gICAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAgICAgLy8gY2xvbmUgY3VycmVudCBkYXRhIHRvIHRoZSBzdG9yZSBhcyB0aGUgcHJldmlvdXMgZ2VzdHVyZVxuICAgICAgICAvLyB1c2VkIGZvciB0aGUgZG91YmxlIHRhcCBnZXN0dXJlLCBzaW5jZSB0aGlzIGlzIGFuIG90aGVyIGdlc3R1cmUgZGV0ZWN0IHNlc3Npb25cbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgICAgICAvLyByZXNldCB0aGUgY3VycmVudFxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGdldFZlbG9jaXR5RGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICAgKi9cbiAgICBnZXRDYWxjdWxhdGVkRGF0YTogZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgICAgICBjYWxjRXYgPSBjdXIubGFzdENhbGNFdmVudCxcbiAgICAgICAgICAgIGNhbGNEYXRhID0gY3VyLmxhc3RDYWxjRGF0YTtcblxuICAgICAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEhhbW1lci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICAgICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgICAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFjdXIubGFzdENhbGNFdmVudCB8fCByZWNhbGMpIHtcbiAgICAgICAgICAgIGNhbGNEYXRhLnZlbG9jaXR5ID0gVXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICAgICBjYWxjRGF0YS5hbmdsZSA9IFV0aWxzLmdldEFuZ2xlKGNlbnRlciwgZXYuY2VudGVyKTtcbiAgICAgICAgICAgIGNhbGNEYXRhLmRpcmVjdGlvbiA9IFV0aWxzLmdldERpcmVjdGlvbihjZW50ZXIsIGV2LmNlbnRlcik7XG5cbiAgICAgICAgICAgIGN1ci5sYXN0Q2FsY0V2ZW50ID0gY3VyLmZ1dHVyZUNhbGNFdmVudCB8fCBldjtcbiAgICAgICAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgICAgIGV2LnZlbG9jaXR5WSA9IGNhbGNEYXRhLnZlbG9jaXR5Lnk7XG4gICAgICAgIGV2LmludGVyaW1BbmdsZSA9IGNhbGNEYXRhLmFuZ2xlO1xuICAgICAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBIYW1tZXIuZ2VzdHVyZXNcbiAgICAgKiBAbWV0aG9kIGV4dGVuZEV2ZW50RGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBleHRlbmRFdmVudERhdGE6IGZ1bmN0aW9uIGV4dGVuZEV2ZW50RGF0YShldikge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICAgICAgbGFzdEV2ID0gY3VyLmxhc3RFdmVudCB8fCBzdGFydEV2O1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RhcnQgdG91Y2hsaXN0IHRvIGNhbGN1bGF0ZSB0aGUgc2NhbGUvcm90YXRpb25cbiAgICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgICAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgICAgICBzdGFydEV2LnRvdWNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIHN0YXJ0RXYudGltZVN0YW1wLFxuICAgICAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBzdGFydEV2LmNlbnRlci5jbGllbnRZO1xuXG4gICAgICAgIHRoaXMuZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGxhc3RFdi5jZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICAgICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICAgICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICAgICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgICAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGV2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlciBuZXcgZ2VzdHVyZVxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VzdHVyZSBvYmplY3QsIHNlZSBgZ2VzdHVyZXMvYCBmb3IgZG9jdW1lbnRhdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fSBnZXN0dXJlc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihnZXN0dXJlKSB7XG4gICAgICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgICAgIHZhciBvcHRpb25zID0gZ2VzdHVyZS5kZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgaWYob3B0aW9uc1tnZXN0dXJlLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHRlbmQgSGFtbWVyIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBIYW1tZXIuZ2VzdHVyZSBvcHRpb25zXG4gICAgICAgIFV0aWxzLmV4dGVuZChIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICAgICAgZ2VzdHVyZS5pbmRleCA9IGdlc3R1cmUuaW5kZXggfHwgMTAwMDtcblxuICAgICAgICAvLyBhZGQgSGFtbWVyLmdlc3R1cmUgdG8gdGhlIGxpc3RcbiAgICAgICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgICAgIC8vIHNvcnQgdGhlIGxpc3QgYnkgaW5kZXhcbiAgICAgICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGlmKGEuaW5kZXggPCBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXN0dXJlcztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBoYW1tZXJcbiAqL1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaGFtbWVyIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqXG4gKiBAY2xhc3MgSW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBgSGFtbWVyLmRlZmF1bHRzYFxuICogQHJldHVybiB7SGFtbWVyLkluc3RhbmNlfVxuICovXG5IYW1tZXIuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gc2V0dXAgSGFtbWVySlMgd2luZG93IGV2ZW50cyBhbmQgcmVnaXN0ZXIgYWxsIGdlc3R1cmVzXG4gICAgLy8gdGhpcyBhbHNvIHNldHMgdXAgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgIHNldHVwKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0c1xuICAgICAqIG9wdGlvbnMgd2l0aCBhbiBfIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgICAgIG9wdGlvbnNbVXRpbHMudG9DYW1lbENhc2UobmFtZSldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBIYW1tZXIuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIC8vIGFkZCBzb21lIGNzcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmcgaXRzIG5hdGl2ZSBiZWhhdm9pclxuICAgIGlmKHRoaXMub3B0aW9ucy5iZWhhdmlvcikge1xuICAgICAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZXZlbnQgc3RhcnQgaGFuZGxlciBvbiB0aGUgZWxlbWVudCB0byBzdGFydCB0aGUgZGV0ZWN0aW9uXG4gICAgICogQHByb3BlcnR5IGV2ZW50U3RhcnRIYW5kbGVyXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyID0gRXZlbnQub25Ub3VjaChlbGVtZW50LCBFVkVOVF9TVEFSVCwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYoc2VsZi5lbmFibGVkICYmIGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgRGV0ZWN0aW9uLnN0YXJ0RGV0ZWN0KHNlbGYsIGV2KTtcbiAgICAgICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGtlZXAgYSBsaXN0IG9mIHVzZXIgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbmVlZHMgdG8gYmUgcmVtb3ZlZCB3aGVuIGNhbGxpbmcgJ2Rpc3Bvc2UnXG4gICAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5IYW1tZXIuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZVxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzIG11bHRpcGxlIGdlc3R1cmVzIGJ5IHNwbGl0dGluZyB3aXRoIGEgc3BhY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXIuZXYgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50SGFuZGxlcnMucHVzaCh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IFV0aWxzLmluQXJyYXkoeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgaWYoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XG4gICAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdXG4gICAgICovXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICBpZighZXZlbnREYXRhKSB7XG4gICAgICAgICAgICBldmVudERhdGEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcbiAgICAgICAgdmFyIGV2ZW50ID0gSGFtbWVyLkRPQ1VNRU5ULmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBvbiB0aGUgdGFyZ2V0IGlmIGl0IGlzIGluIHRoZSBpbnN0YW5jZSBlbGVtZW50LFxuICAgICAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYoVXRpbHMuaGFzUGFyZW50KGV2ZW50RGF0YS50YXJnZXQsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZXZlbnREYXRhLnRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbmFibGUgb2YgZGlzYWJsZSBoYW1tZXIuanMgZGV0ZWN0aW9uXG4gICAgICogQG1ldGhvZCBlbmFibGVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZVxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGlzcG9zZSB0aGlzIGhhbW1lciBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgZGlzcG9zZVxuICAgICAqIEByZXR1cm4ge051bGx9XG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIGksIGVoO1xuXG4gICAgICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICAgICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIGZhbHNlKTtcblxuICAgICAgICAvLyB1bmJpbmQgYWxsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgICAgICBmb3IoaSA9IC0xOyAoZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXSk7KSB7XG4gICAgICAgICAgICBVdGlscy5vZmYodGhpcy5lbGVtZW50LCBlaC5nZXN0dXJlLCBlaC5oYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgICAgIC8vIHVuYmluZCB0aGUgc3RhcnQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIGhhbW1lcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZHJhZ0dlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgdmFyIGN1ciA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIC8vIG1heCB0b3VjaGVzXG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcbiAgICAgICAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2VudGVyID0gY3VyLnN0YXJ0RXZlbnQuY2VudGVyO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgICAgICAgICAgIGlmKGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgaW5zdGVhZCBvZiBhdCAwLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENlbnRlci5wYWdlWCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xuICAgICAgICAgICAgICAgIGlmKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2LmRyYWdMb2NrVG9BeGlzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBrZWVwIGRpcmVjdGlvbiBvbiB0aGUgYXhpcyB0aGF0IHRoZSBkcmFnIGdlc3R1cmUgc3RhcnRlZCBvblxuICAgICAgICAgICAgICAgIHZhciBsYXN0RGlyZWN0aW9uID0gY3VyLmxhc3RFdmVudC5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKFV0aWxzLmlzVmVydGljYWwobGFzdERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICAgICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tIb3Jpem9udGFsICYmICFpc1ZlcnRpY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICAgICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBIYW1tZXIuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5kZXg6IDUwLFxuICAgICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIHRvIHRydWUgdG8gbWFrZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWdcbiAgICAgICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgICAgICogdGhyb3VnaCBkcmFnZ2luZyBkaWZmaWN1bHQsIGFuZCBiZSB2aXN1YWxseSB1bmFwcGVhbGluZy5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ01heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrVmVydGljYWxcbiAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGRyYWdMb2NrVG9BeGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgICAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnTG9ja1RvQXhpczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICAgIH1cbiAgICB9O1xufSkoJ2RyYWcnKTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICpcbiAqIEBjbGFzcyBHZXN0dXJlXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGdlc3R1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5IYW1tZXIuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICBuYW1lOiAnZ2VzdHVyZScsXG4gICAgaW5kZXg6IDEzMzcsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAqXG4gKiBAY2xhc3MgSG9sZFxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBob2xkXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXG4gICAgICAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudCAmJiBjdXJyZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaG9sZFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgICAgICAgaWYoZXYuZGlzdGFuY2UgPiBvcHRpb25zLmhvbGRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSGFtbWVyLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGluZGV4OiAxMCxcbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgNTAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaG9sZFRocmVzaG9sZDogMlxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVyOiBob2xkR2VzdHVyZVxuICAgIH07XG59KSgnaG9sZCcpO1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgcmVsZWFzZWQgZnJvbSB0aGUgcGFnZVxuICpcbiAqIEBjbGFzcyBSZWxlYXNlXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IHJlbGVhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5IYW1tZXIuZ2VzdHVyZXMuUmVsZWFzZSA9IHtcbiAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgaW5kZXg6IEluZmluaXR5LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiB0cmlnZ2VycyBzd2lwZSBldmVudHMgd2hlbiB0aGUgZW5kIHZlbG9jaXR5IGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gKiBgYGBgXG4gKiAgaGFtbWVydGltZS5vbihcImRyYWdsZWZ0IHN3aXBlbGVmdFwiLCBmdW5jdGlvbihldikge1xuICogICAgY29uc29sZS5sb2coZXYpO1xuICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICogIH0pO1xuICogYGBgYFxuICpcbiAqIEBjbGFzcyBTd2lwZVxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBzd2lwZVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHN3aXBlbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHN3aXBlcmlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBzd2lwZXVwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgc3dpcGVkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlN3aXBlID0ge1xuICAgIG5hbWU6ICdzd2lwZScsXG4gICAgaW5kZXg6IDQwLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlTWluVG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHN3aXBlTWF4VG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZU1heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhvcml6b250YWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlYXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmVydGljYWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxuICAgIH0sXG5cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgICAgIGlmKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fFxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPiBvcHRpb25zLnN3aXBlTWF4VG91Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICAgICAgaWYoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICpcbiAqIEBjbGFzcyBUYXBcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgdGFwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZG91YmxldGFwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGhhc01vdmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0YXBHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgcHJldiA9IERldGVjdGlvbi5wcmV2aW91cyxcbiAgICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICAgIGRpZERvdWJsZVRhcDtcblxuICAgICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IGhhc01vdmVkIHx8IChldi5kaXN0YW5jZSA+IG9wdGlvbnMudGFwTWF4RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgICAgICAgICBpZighVXRpbHMuaW5TdHIoZXYuc3JjRXZlbnQudHlwZSwgJ2NhbmNlbCcpICYmIGV2LmRlbHRhVGltZSA8IG9wdGlvbnMudGFwTWF4VGltZSAmJiAhaGFzTW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzaW5jZVByZXYgPSBwcmV2ICYmIHByZXYubGFzdEV2ZW50ICYmIGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgICAgICAgICAgICAgICBpZihwcmV2ICYmIHByZXYubmFtZSA9PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2luY2VQcmV2ICYmIHNpbmNlUHJldiA8IG9wdGlvbnMuZG91YmxlVGFwSW50ZXJ2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBldi5kaXN0YW5jZSA8IG9wdGlvbnMuZG91YmxlVGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcignZG91YmxldGFwJywgZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgICAgICAgICAgICBpZighZGlkRG91YmxlVGFwIHx8IG9wdGlvbnMudGFwQWx3YXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKGN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSGFtbWVyLmdlc3R1cmVzLlRhcCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5kZXg6IDEwMCxcbiAgICAgICAgaGFuZGxlcjogdGFwR2VzdHVyZSxcbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcE1heFRpbWU6IDI1MCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhEaXN0YW5jZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBhbHdheXMgdHJpZ2dlciB0aGUgYHRhcGAgZXZlbnQsIGV2ZW4gd2hpbGUgZG91YmxlLXRhcHBpbmdcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRvdWJsZVRhcERpc3RhbmNlOiAyMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwSW50ZXJ2YWxcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgICB9XG4gICAgfTtcbn0pKCd0YXAnKTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHRvdWNoZWQgYXQgdGhlIHBhZ2VcbiAqXG4gKiBAY2xhc3MgVG91Y2hcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgdG91Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5IYW1tZXIuZ2VzdHVyZXMuVG91Y2ggPSB7XG4gICAgbmFtZTogJ3RvdWNoJyxcbiAgICBpbmRleDogLUluZmluaXR5LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAgICogYnV0IGl0IGltcHJvdmVzIGdlc3R1cmVzIGxpa2UgdHJhbnNmb3JtaW5nIGFuZCBkcmFnZ2luZy5cbiAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIHVzaW5nIHRoaXMsIGl0IGNhbiBiZSB2ZXJ5IGFubm95aW5nIGZvciB1c2VycyB0byBiZSBzdHVjayBvbiB0aGUgcGFnZVxuICAgICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAgICogQHByb3BlcnR5IHByZXZlbnRNb3VzZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHByZXZlbnRNb3VzZTogZmFsc2VcbiAgICB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHRvdWNoR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudE1vdXNlICYmIGV2LnBvaW50ZXJUeXBlID09IFBPSU5URVJfTU9VU0UpIHtcbiAgICAgICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIFVzZXIgd2FudCB0byBzY2FsZSBvciByb3RhdGUgd2l0aCAyIGZpbmdlcnNcbiAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICogYHByZXZlbnREZWZhdWx0YCBvcHRpb24uXG4gKlxuICogQGNsYXNzIFRyYW5zZm9ybVxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCB0cmFuc2Zvcm1zdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHBpbmNoaW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBwaW5jaG91dFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHJvdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG11bHRpdG91Y2hcbiAgICAgICAgICAgICAgICBpZihldi50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uVGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSAmJlxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHRyYW5zZm9ybWluZyFcbiAgICAgICAgICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpOyAvLyBiYXNpYyB0cmFuc2Zvcm0gZXZlbnRcblxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdyb3RhdGUnLCBldik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBwaW5jaCBldmVudFxuICAgICAgICAgICAgICAgIGlmKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnLCBldik7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBIYW1tZXIuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbmRleDogNDUsXG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyOiB0cmFuc2Zvcm1HZXN0dXJlXG4gICAgfTtcbn0pKCd0cmFuc2Zvcm0nKTtcblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICovXG5cbi8vIEFNRCBleHBvcnRcbmlmKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xuLy8gY29tbW9uanMgZXhwb3J0XG59IGVsc2UgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbi8vIGJyb3dzZXIgZXhwb3J0XG59IGVsc2Uge1xuICAgIHdpbmRvdy5IYW1tZXIgPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdyk7IiwiLy8gYmFzZSBsb2NhbGVcblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuYmxvY2tseS5jb21tb25fbG9jYWxlO1xuIiwiZXhwb3J0cy5hZGRSZWFkeUxpc3RlbmVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5nZXRUb3VjaEV2ZW50TmFtZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICB2YXIgaXNJRTExVG91Y2ggPSB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkO1xuICB2YXIgaXNJRTEwVG91Y2ggPSB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG4gIHZhciBpc1N0YW5kYXJkVG91Y2ggPSAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHZhciBrZXk7XG4gIGlmIChpc0lFMTFUb3VjaCkge1xuICAgIGtleSA9IFwiaWUxMVwiO1xuICB9IGVsc2UgaWYgKGlzSUUxMFRvdWNoKSB7XG4gICAga2V5ID0gXCJpZTEwXCI7XG4gIH0gZWxzZSBpZiAoaXNTdGFuZGFyZFRvdWNoKSB7XG4gICAga2V5ID0gXCJzdGFuZGFyZFwiO1xuICB9XG4gIGlmIChrZXkgJiYgVE9VQ0hfTUFQW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gVE9VQ0hfTUFQW2V2ZW50TmFtZV1ba2V5XTtcbiAgfVxufTtcblxudmFyIGFkZEV2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIC8vIFNjb3BlIGJvdW5kIGV2ZW50IG1hcCB0byB0aGlzIGFkZEV2ZW50IGNhbGwgLSB3ZSBvbmx5IHByb3ZpZGUgZm9yIHVuYmluZGluZ1xuICAvLyB3aGF0IHdlIGJpbmQgcmlnaHQgaGVyZS5cbiAgdmFyIGJvdW5kRXZlbnRzID0ge307XG5cbiAgdmFyIGJpbmRFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgYm91bmRFdmVudHNbdHlwZV0gPSB7IG5hbWU6IGV2ZW50TmFtZSwgaGFuZGxlcjogaGFuZGxlciB9O1xuICB9O1xuXG4gIHZhciB1bmJpbmRFdmVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGV2ZW50SW5mbyA9IGJvdW5kRXZlbnRzW3R5cGVdO1xuICAgIGlmIChldmVudEluZm8pIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudEluZm8ubmFtZSwgZXZlbnRJbmZvLmhhbmRsZXIpO1xuICAgICAgZGVsZXRlIGJvdW5kRXZlbnRzW3R5cGVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgY2xpY2sgaGFuZGxlclxuICBiaW5kRXZlbnQoJ2NsaWNrJywgZXZlbnROYW1lLCBoYW5kbGVyKTtcblxuICAvLyBPcHRpb25hbGx5IGFkZCB0b3VjaCBoYW5kbGVyXG4gIHZhciB0b3VjaEV2ZW50ID0gZXhwb3J0cy5nZXRUb3VjaEV2ZW50TmFtZShldmVudE5hbWUpO1xuICBpZiAodG91Y2hFdmVudCkge1xuICAgIGJpbmRFdmVudCgndG91Y2gnLCB0b3VjaEV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBTdG9wIG1vdXNlIGV2ZW50cyBhbmQgc3VwcHJlc3MgZGVmYXVsdCBldmVudCBoYW5kbGVyIHRvIHByZXZlbnRcbiAgICAgIC8vIHVuaW50ZW50aW9uYWwgZG91YmxlLWNsaWNraW5nXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB1bmJpbmRFdmVudCgnY2xpY2snKTtcbiAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldHVybiBmdW5jdGlvbiB0aGF0IHVuYmluZHMgYWxsIGhhbmRsZXJzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdW5iaW5kRXZlbnQoJ2NsaWNrJyk7XG4gICAgdW5iaW5kRXZlbnQoJ3RvdWNoJyk7XG4gIH07XG59O1xuXG5leHBvcnRzLmFkZE1vdXNlRG93blRvdWNoRXZlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XG4gIHJldHVybiBhZGRFdmVudChlbGVtZW50LCAnbW91c2Vkb3duJywgaGFuZGxlcik7XG59O1xuXG5leHBvcnRzLmFkZE1vdXNlVXBUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICByZXR1cm4gYWRkRXZlbnQoZWxlbWVudCwgJ21vdXNldXAnLCBoYW5kbGVyKTtcbn07XG5cbmV4cG9ydHMuYWRkTW91c2VNb3ZlVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGFkZEV2ZW50KGVsZW1lbnQsICdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbn07XG5cbmV4cG9ydHMuYWRkQ2xpY2tUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICByZXR1cm4gYWRkRXZlbnQoZWxlbWVudCwgJ2NsaWNrJywgaGFuZGxlcik7XG59O1xuXG4vLyBBIG1hcCBmcm9tIHN0YW5kYXJkIHRvdWNoIGV2ZW50cyB0byB2YXJpb3VzIGFsaWFzZXMuXG52YXIgVE9VQ0hfTUFQID0ge1xuICAvLyAgSW5jb21wbGV0ZSBsaXN0LCBhZGQgYXMgbmVlZGVkLlxuICBjbGljazoge1xuICAgIHN0YW5kYXJkOiAndG91Y2hzdGFydCcsXG4gICAgaWUxMDogJ01TUG9pbnRlckRvd24nLFxuICAgIGllMTE6ICdwb2ludGVyZG93bidcbiAgfSxcbiAgbW91c2Vkb3duOiB7XG4gICAgc3RhbmRhcmQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBpZTEwOiAnTVNQb2ludGVyRG93bicsXG4gICAgaWUxMTogJ3BvaW50ZXJkb3duJ1xuICB9LFxuICBtb3VzZXVwOiB7XG4gICAgc3RhbmRhcmQ6ICd0b3VjaGVuZCcsXG4gICAgaWUxMDogJ01TUG9pbnRlclVwJyxcbiAgICBpZTExOiAncG9pbnRlcnVwJ1xuICB9LFxuICBtb3VzZW1vdmU6IHtcbiAgICBzdGFuZGFyZDogJ3RvdWNobW92ZScsXG4gICAgaWUxMDogJ01TUG9pbnRlck1vdmUnLFxuICAgIGllMTE6ICdwb2ludGVybW92ZSdcbiAgfVxufTtcblxuZXhwb3J0cy5pc01vYmlsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVnID0gL01vYmlsZXxpUChob25lfG9kfGFkKXxBbmRyb2lkfEJsYWNrQmVycnl8SUVNb2JpbGUvO1xuICByZXR1cm4gcmVnLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuZXhwb3J0cy5pc1dpbmRvd3NUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVnID0gL01TSUUuKlRvdWNoLztcbiAgcmV0dXJuIHJlZy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn07XG5cbmV4cG9ydHMuaXNBbmRyb2lkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWcgPSAvQW5kcm9pZC87XG4gIHJldHVybiByZWcudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuXG5leHBvcnRzLmlzSU9TID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWcgPSAvaVAoaG9uZXxvZHxhZCkvO1xuICByZXR1cm4gcmVnLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuZXhwb3J0cy5pc0lQYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlZyA9IC9pUGFkL2k7XG4gIHJldHVybiByZWcudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuIiwiLyoqIEBmaWxlIFByb3ZpZGUgYnJvd3NhYmxlIGNvbW1hbmQgaGlzdG9yeSB0byBhIHRleHRib3ggd2l0aCBsaW1pdGVkIGRlcHRoLiAqL1xuLy8gU3RyaWN0IGxpbnRpbmc6IEFic29yYiBpbnRvIGdsb2JhbCBjb25maWcgd2hlbiBwb3NzaWJsZVxuLyoganNoaW50XG4gdW51c2VkOiB0cnVlLFxuIGVxZXFlcTogdHJ1ZSxcbiBtYXhsZW46IDEyMFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21tYW5kSGlzdG9yeSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogT3JkZXJlZCBjb2xsZWN0aW9uIG9mIGNvbW1hbmQgZW50cmllcy5cbiAgICogQHByaXZhdGUge3N0cmluZ1tdfVxuICAgKi9cbiAgdGhpcy5jb21tYW5kc18gPSBbXTtcblxuICAvKipcbiAgICogQ3VycmVudCBpbmRleCBpbnRvIGNvbW1hbmRzXywgd2hlcmUgMCBpcyB0aGUgb2xkZXN0IGNvbW1hbmQgc3RvcmVkXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmN1cnJlbnRJbmRleF8gPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byBzdG9yZSBpbiB0aGUgY29tbWFuZCBoaXN0b3J5LCB0b1xuICAgKiBwcmV2ZW50IGV2ZXItaW5jcmVhc2luZyBtZW1vcnkgZm9yIHRoaXMgZmVhdHVyZS5cbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4RW50cmllc18gPSA2NDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBjb21tYW5kIHRvIHRoZSBjdXJyZW50IGNvbW1hbmQgaGlzdG9yeS4gIElmIHRoZSBjb21tYW5kXG4gKiBoaXN0b3J5IGhhcyBhbHJlYWR5IHJlYWNoZWQgaXRzIG1heGltdW0gZGVwdGgsIHRoZSBvbGRlc3QgY29tbWFuZCB3aWxsXG4gKiBkcm9wIG9mZiBzbyB0aGF0IHRoZSBuZXdlc3QgY29tbWFuZCBjYW4gYmUgYWRkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZFxuICovXG5Db21tYW5kSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gIGlmICh0aGlzLmNvbW1hbmRzXy5sZW5ndGggPj0gdGhpcy5tYXhFbnRyaWVzXykge1xuICAgIHRoaXMuY29tbWFuZHNfLnNoaWZ0KCk7XG4gICAgdGhpcy5jdXJyZW50SW5kZXhfIC09IDE7XG4gIH1cbiAgdGhpcy5jb21tYW5kc18ucHVzaChjb21tYW5kKTtcbiAgdGhpcy5jdXJyZW50SW5kZXhfID0gdGhpcy5jb21tYW5kc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBNb3ZlIGJhY2sgaW4gdGltZSBieSBvbmUgZW50cnksIHJldHVybmluZyB0aGUgY29tbWFuZCBhdCB0aGUgbmV3XG4gKiBjb21tYW5kIGluZGV4LlxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRJbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQ29tbWFuZEhpc3RvcnkucHJvdG90eXBlLmdvQmFjayA9IGZ1bmN0aW9uIChjdXJyZW50SW5wdXQpIHtcbiAgdGhpcy5hbHRlckhpc3RvcnlfKHRoaXMuY3VycmVudEluZGV4XywgY3VycmVudElucHV0KTtcblxuICBpZiAodGhpcy5jdXJyZW50SW5kZXhfID4gMCkge1xuICAgIHRoaXMuY3VycmVudEluZGV4XyAtPSAxO1xuICB9XG4gIGlmICh0eXBlb2YgdGhpcy5jb21tYW5kc19bdGhpcy5jdXJyZW50SW5kZXhfXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kc19bdGhpcy5jdXJyZW50SW5kZXhfXTtcbiAgfVxuICByZXR1cm4gY3VycmVudElucHV0O1xufTtcblxuLyoqXG4gKiBNb3ZlIGZvcndhcmQgaW4gdGltZSBieSBvbmUgZW50cnksIHJldHVybmluZyB0aGUgY29tbWFuZCBhdCB0aGUgbmV3XG4gKiBjb21tYW5kIGluZGV4LlxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRJbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQ29tbWFuZEhpc3RvcnkucHJvdG90eXBlLmdvRm9yd2FyZCA9IGZ1bmN0aW9uIChjdXJyZW50SW5wdXQpIHtcbiAgdGhpcy5hbHRlckhpc3RvcnlfKHRoaXMuY3VycmVudEluZGV4XywgY3VycmVudElucHV0KTtcblxuICBpZiAodGhpcy5jdXJyZW50SW5kZXhfIDwgdGhpcy5jb21tYW5kc18ubGVuZ3RoKSB7XG4gICAgdGhpcy5jdXJyZW50SW5kZXhfICs9IDE7XG4gIH1cbiAgaWYgKHRoaXMuY3VycmVudEluZGV4XyA9PT0gdGhpcy5jb21tYW5kc18ubGVuZ3RoICYmXG4gICAgICBjdXJyZW50SW5wdXQgPT09IHRoaXMuY29tbWFuZHNfW3RoaXMuY3VycmVudEluZGV4XyAtIDFdKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgdGhpcy5jb21tYW5kc19bdGhpcy5jdXJyZW50SW5kZXhfXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kc19bdGhpcy5jdXJyZW50SW5kZXhfXTtcbiAgfVxuICByZXR1cm4gY3VycmVudElucHV0O1xufTtcblxuLyoqXG4gKiBPdmVyd3JpdGVzIHRoZSBjdXJyZW50bHkgdmlld2VkIGNvbW1hbmQgZW50cnkgaW4gdGhlIGhpc3Rvcnkgd2l0aCBhIG5ld1xuICogdmFsdWUuICBXaWxsIGRvIG5vdGhpbmcgaWYgYXR0ZW1wdGluZyBvdmVyd3JpdGUgYW4gZW1wdHkgZW50cnkuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGluZGV4IC0gcG9zaXRpb24gaW4gY29tbWFuZCBoaXN0b3J5IHRvIHJld3JpdGVcbiAqIEBwYXJhbSB7IXN0cmluZ30gbmV3VmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbW1hbmRIaXN0b3J5LnByb3RvdHlwZS5hbHRlckhpc3RvcnlfID0gZnVuY3Rpb24gKGluZGV4LCBuZXdWYWx1ZSkge1xuICBpZiAodGhpcy5jb21tYW5kc19baW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmNvbW1hbmRzX1tpbmRleF0gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbiJdfQ==
