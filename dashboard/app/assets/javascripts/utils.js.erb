var addClickTouchEvent = function(element, handler) {
  var wrapper = function(e) {
    handler(e);
    e.preventDefault();
  };
  element.on({
    'touchstart': wrapper,
    'click': wrapper
  });
};

function onURLBlocked(base_url, callback) {
  $('<img width=1 height=1>')
      .on("error", callback)
      .attr("src", base_url + "?" + Math.random())
      .css("position", "absolute")
      .css("bottom", 0)
      .css("width", 1)
      .css("height", 1)
      .css("visibility", "hidden")
      .appendTo("body");
}

/**
 * Wrap a function so that it will only be executed a certain amount of time
 * after it's originally called, to avoid multiple calls in quick succession.
 * Subsequent calls to the returned function will reset its timer.
 * Note: Would reuse lodash's debounce method here, but we don't appear to
 * have access to it here.
 * @param {function} callback - to be called after the given delay
 * @param {number} delay - How long to wait after the _last_ call before executing the callback
 * @returns {function}
 */
var debounce = function (callback, delay) {
  return (function () {
    // Scope the key to this particular call to debounce, but outside
    // the call of the returned function.
    var timerKey;
    return function () {
      if (timerKey) {
        clearTimeout(timerKey);
      }
      timerKey = setTimeout(function () {
        timerKey = undefined;
        callback();
      }, delay);
    };
  })();
};
