// New private scope -- a lot of this is boilerplate for class structures, taken from coffeescript
(function() {
  var
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



  // class UIRouter: this is an incredibly simple router with our routes baked into it.
  // This will be completely replaced when we choose a router.
  var UIRouter = (function() {

    function UIRouter() { }

    UIRouter.prototype.route = function() {
      var re, parts, el,
        url = window.location.pathname;


      // s/:script_id/level/:level_id
      // (only applies to the default scripts ID < 8)
      re = /\/s\/(\d+)\/(level|puzzle)\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        levelStore.load({
          script_id: parts[1],
          level_id: parts[3]
        });

        return;
      }

      // hoc|k8intro|editcode|2014|builder|flappy|jigsaw/:level
      re = /\/(\w+)\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        var apps = {
          hoc: 'Hour of Code',
          k8intro: '20-hour',
          editcode: 'edit-code',
          '2014': 'events',
          flappy: 'flappy',
          jigsaw: 'jigsaw'
        };

        var app = apps[parts[1]];
        if (app) {
          levelStore.load({
            script_name: app,
            level_id: parts[2]
          });

          return;
        }
      }

      // s/:script_name/stage/:stage_id/level/:level_id
      re = /\/s\/(.+)\/stage\/(\d+)\/puzzle\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        levelStore.load({
          script_name: parts[1],
          stage_id: parts[2],
          level_id: parts[3]
        });

        return;
      }

      // Right now, the static is a fixed route
      if (window.Frame.isSinglePage) {
        var params = Frame.queryParams() || {
          script: '20-hour',
          stage: 3,  // TODO: Default route
          level: 3
        };

        script_name = params.script;
        levelStore.load({
          script_name: params.script,
          stage_id: params.stage,
          level_id: params.level
        });

        return;
      }

      // Unknown route
      return null;
    }


    return UIRouter;
  })();






  // class UIFrame
  var UIFrame = (function() {

    var loaded_resources = {};

    // Create an AJAX transport for static script loading
    // This works for both file:// and http:// links
    // 1. File is loaded as a <SCRIPT> tag
    // 2. The file contains a call to RESOURCE({ ...json... });
    // 3. RESOURCE() stores the JSON away for later retrieval
    window.RESOURCE = function (json) {
      loaded_resources[Math.random(1)] = json;
    };
    $.ajaxTransport( "static", function( s ) {
      var script, callback, result;
      return {
        send: function( _, complete ) {

          // If needed, we could create a way to store or simulate postbacks.
          if (s.type != 'GET') {
            throw new Error(s.type + "s are not supported.")
          }

          if (s.isStaticResource) {
            s.dataTypes[ 0 ] = "json";
            s.url += "?jsonp=RESOURCE";
          } else {
            s.dataTypes[ 0 ] = "script";
          }

          script = jQuery("<script>", {
            charset: s.scriptCharset,
            src: s.url
          }).on(
            "load error",
            callback = function( evt ) {
              // If we remove this, we can't debug it.
              // script.remove();
              callback = null;

              if (s.isStaticResource) {
                // TODO: are there asynchronicity issues here?
                var json;
                for (var key in loaded_resources) {
                  json = loaded_resources[key];
                  delete loaded_resources[key];
                  break;
                }

                result = { json: json };
              }

              if ( evt ) {
                complete( evt.type === "error" ? 404 : 200, evt.type, result);
              }
            }
          );
          document.head.appendChild( script[ 0 ] );
        },
        abort: function() {
          if ( callback ) {
            callback();
          }
        }
      };
    });

    var rootUrl = function(url) {
      var root = url.match(/^\w+:\/\/[^\/]*/);
      return root[0];
    }

    function UIFrame() {
    }

    UIFrame.prototype.init = function() {
      // Static environment ignores BASE HREF and looks for resources in the directory of this script.
      this.isStatic = this.detectStatic();

      // There are three possible environments:
      if (this.isSinglePage) {
        // a file:// URL
        this.rootUrl = this.baseUrl = document.URL.substr(0, document.URL.lastIndexOf('/'));

        // For now, initial scripts and CSS are still loaded from the server using a BASE HREF
        // pointing at the server.  Once the initial assets are loaded, everything else
        // is loaded from relative paths on the static site, so we remove it.
        // Once assets are bundled for static mode, we won't need to have the BASE HREF at all,
        // and we will remove all references to this.serverRoot.
        this.serverRoot = rootUrl(this.baseURI());
        $('base').remove();

        // Hook into the global CSRF handler for debugging requests to the server.
        this.patchCSRF();
      } else if (this.isStatic) {
        // a static server URL
        this.serverRoot = this.rootUrl = this.baseUrl = rootUrl(document.URL.substr(0, document.URL.lastIndexOf('/')));
      } else {
        // a live server URL
        this.baseUrl = this.baseURI();
        this.serverRoot = this.rootUrl = window.location.protocol + "//" + window.location.host;
      }

      this.router = new UIRouter();
      this.router.route();
    }

    // http://stackoverflow.com/a/21152762/7104
    // Decode query parameters
    UIFrame.prototype.queryParams = function (url) {
      url = url || location.search;
      if (!url)
        return null;

      var qd = {};
      url.substr(1).split("&").forEach(function(item) {
        var k = item.split("=")[0],
          v = decodeURIComponent(item.split("=")[1]); 
        (k in qd) ? qd[k].push(v) : qd[k] = [v,]
      });
      return qd;
    }

    // This is work in progress to patch the XmlHttpRequest service to prevent us from making
    // requests to a file:// URL (because that will fail and prevent other scripts from running.)
    // It also forces the CSRF token into all requests, although there are other ways to do
    // that once we get all the $.ajax() calls under control.
    UIFrame.prototype.patchCSRF = function() {
      var token = $('meta[name=csrf-token]').attr('content');

      var send = XMLHttpRequest.prototype.send;
      XMLHttpRequest.prototype.send = function(data) {
        if (this.skip)
          return;
        return send.apply(this, arguments);
      };

      var open = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(data) {
        var resp = open.apply(this, arguments);

        if (arguments[1].substr(0,5) == 'file:') {
          console.error('skipping ' + arguments[1]);
          this.skip = true;
        }

        // TODO: We're using JQuery from Rails, so it automatically adds this.
        // Is that really what we want to do?
        // this.setRequestHeader('X-CSRF-Token', token);

        return resp;
      };
    }

    // Create an absolute path to a resource.  The second parameter is temporary - only used in a static
    // site that still has references to a dynamic server.
    UIFrame.prototype.getAbsolutePath = function(path, rootUrl) {
      if (path[0] == '/')
        return (rootUrl || this.rootUrl) + path;
      return (rootUrl || this.baseUrl) + "/" + path;
    }

    UIFrame.prototype.baseURI = function() {
      // Check expected property.
      if (document.baseURI)
        return document.baseURI;
      var base = document.getElementsByTagName('base');
      if (base.length > 0)
        return base[0].href;
      return document.URL;
    }

    // Eventually we could support various modes of offline (disconnects, etc)
    UIFrame.prototype.detectStatic = function() {
      // file: URL is static AND single-page
      if (window.location.protocol == 'file:') {
        this.isSinglePage = true;
        return true;
      }

      // react.studio.code.org is static but not single-page
      if (window.location.host.substr(0,6) == 'react.')
        return true;

      /* Enable this to test static on your local dev machine.
      if (window.location.port == 3000)
        return true;
      */
      return false;
    }

    // Load the script at a given URL and return a promise that resolves when it has executed
    UIFrame.prototype.load = function(ajax, resolveStatic) {
      if (this.isStatic) {
        ajax.type = ajax.type || 'GET';

        // Static resolution replaces the URL with a static equivalent
        if (resolveStatic) {
          // All static resources are wrapped as .JS files
          var staticPath = resolveStatic(ajax.data) + ".js";

          // When we have a static asset pipeline, use the 2nd one instead.
          ajax.url = this.getAbsolutePath(staticPath, this.serverRoot);
          // ajax.url = this.getAbsolutePath(staticPath);

          delete ajax.data; // Static resources can't do anything with params
          ajax.cache = true;  // Static resources will have long cache times
          ajax.isStaticResource = true;  // Expect a JSONP resoponse
        } else {
          if (ajax.dataType != 'script')
            console.error("Request for " + ajax.url + " has no static handler.")
        }

        // All resources must be loaded via <SCRIPT> tag when offline.
        ajax.dataType = "static";
      } else if (ajax.dataType == "script") {
        // Use our static script loader instead of $.getScript, which deletes the <script>
        // element and makes it hard to debug into the script.
        ajax.dataType = "static";

      }

      return $.ajax(ajax);
    }

    // Write to an API - assumes a POST that returns JSON
    UIFrame.prototype.save = function(ajax) {
      ajax.method = ajax.method || "POST";
      ajax.dataType = ajax.dataType || "json";
      ajax.contentType = ajax.contentType || "application/x-www-form-urlencoded";

      return this.load(ajax);
    }

    // Load the script at a given URL and return a promise that resolves when it has executed
    UIFrame.prototype.loadSource = function(url) {
      return this.load({
        url: url,
        dataType: "script",
        cache: true
      });
    }

    // Loads the given app stylesheet.
    UIFrame.prototype.loadStyle = function(url) {
      $('<link>', {
        rel: 'stylesheet',
        type: 'text/css',
        href: url
      }).appendTo(document.head);
    }

    // Return a route to a link.  This interface will be improved when we use a real router.
    UIFrame.prototype.linkTo = function(route, forceOnline) {
      // Calculate route for script levels
      if (route.script) {
        if (this.isSinglePage && !forceOnline)
          return window.location.pathname + "?" + $.param( route, true );

        switch (route.script) {
          case '20-hour':
            return "/s/1/level/" + route.level;
          case 'Hour of Code':
            return "/hoc/" + route.level;
          case 'edit-code':
            return "/editcode/" + route.level;
          case 'events':
            return "/2014/" + route.level;
          case 'flappy':
            return "/flappy/" + route.level;
          case 'jigsaw':
            return "/jigsaw/" + route.level;
          case 'step':
            return "/s/step/puzzle/" + route.level;
          case 'hourofcode':  // TODO: For some reason, URLs for #21 generate URLs that resolve to #2. Why?
            return "/hoc/" + route.level;
          default:
            return "/s/" + route.script + "/stage/" + route.stage + "/puzzle/" + route.level;
        }
      }

      if (route.complete) {
        // For now, completion routes are always online.
        switch (route.complete) {
          case 'Hour of Code':
            return "http://code.org/api/hour/finish";
          default:
            // TODO
        }
      }

      // Not a recognized route
      return null;
    }

    UIFrame.prototype.goTo = function(route) {
      var url = this.linkTo(route);
      if (!url)
        return false;

      window.location.href = url;
      return true;
    }

    return UIFrame;
  })();




  // class App, the base class for all level apps
  var App = (function() {

    // Must have a constructor
    function App(opts) {
      $.extend(this, {
        Dialog: Dialog,
        cdoSounds: CDOSounds,
        position: { blockYCoordinateInterval: 25 }
      }, opts);

      // Turn string values into functions for keys that begin with 'fn_' (JSON can't contain function definitions)
      // E.g. { fn_example: 'function () { return; }' } becomes { example: function () { return; } }
      (function fixUpFunctions(node) {
        if (typeof node !== 'object') return;

        for (var i in node) {
          if (/^fn_/.test(i)) {
            try {
              node[i.replace(/^fn_/, '')] = eval('(' + node[i] + ')');
            } catch (e) { }
          } else {
            fixUpFunctions(node[i]);
          }
        }
      })(this.level);

      this.onAttempt = __bind(this.onAttempt, this);
      this.onContinue = __bind(this.onContinue, this);
      this.backToPreviousLevel = __bind(this.backToPreviousLevel, this);
      this.onResetPressed = __bind(this.onResetPressed, this);

      return this;
    }

    App.prototype.init = function() {
      var _this = this;
      this.loadAssets().then(function() {
        window[_this.app + 'Main'](_this);
      });
    }

    App.prototype.loadAssets = function(name) {
    }

    App.prototype.loadSource = function(filename, locale) {
      var _this = this;

      return function () {
        if (locale)
          filename = locale + "/" + filename;
        return Frame.loadSource(_this.baseUrl + "js/" + filename + ".js");
      };
    }

    App.prototype.loadStyle = function(name) {
      return Frame.loadStyle(this.baseUrl + 'css/' + name + '.css');
    }

    return App;
  })();


  // class BlocklyApp extends App
  var BlocklyApp = (function(_super) {
    __extends(BlocklyApp, _super);

    // Must have a constructor
    function BlocklyApp(opts) {
      BlocklyApp.__super__.constructor.apply(this, arguments);

      return this;
    }

    $.extend(BlocklyApp.prototype, {
      loadAssets: function() {
        this.loadStyle('common');
        this.loadStyle(this.app);

        var promise;
        if (this.droplet) {
          this.loadStyle('droplet/droplet.min');
          promise = this.loadSource('jsinterpreter/acorn_interpreter')()
            .then(this.loadSource('requirejs/require'))
            .then(this.loadSource('ace/ace'))
            .then(this.loadSource('ace/ext-language_tools'))
            .then(this.loadSource('droplet/droplet-full.min'));
        } else {
          promise = this.loadSource('blockly')()
            .then(this.loadSource('blockly_locale', this.locale));
        }
        return promise
          .then(this.loadSource('common' + this.pretty))
          .then(this.loadSource('common_locale', this.locale))
          .then(this.loadSource(this.app + '_locale', this.locale))
          .then(this.loadSource(this.app + this.pretty));
      },

      onInitialize: function() {
        // TODO: Confirm that moving this to onInitialize is ok - no timing effects?
        window.startTiming('Puzzle', this.scriptPath, '');

        // Hide callouts when the function editor is closed (otherwise they jump to the top left corner)
        $(window).on('function_editor_closed', function() {
          $('.cdo-qtips').qtip('hide');
        });

        this.createCallouts();
        if (window.wrapExistingClipPaths && window.handleClipPathChanges) {
          wrapExistingClipPaths();
          handleClipPathChanges();
        }

        $(document).trigger('appInitialized', this);
      },

      createCallouts: function() {
        $.fn.qtip.zindex = 500;
        this.callouts && this.callouts.every(function(callout) {
          var selector = callout.element_id; // jquery selector.
          if ($(selector).length === 0 && !callout.on) {
            return true;
          }

          var defaultConfig = {
            content: {
              text: callout.localized_text,
              title: {
                button: $('<div class="tooltip-x-close"/>')
              }
            },
            style: {
              classes: "",
              tip: {
                width: 20,
                height: 20
              }
            },
            position: {
              my: "bottom left",
              at: "top right"
            },
            hide: {
              event: 'click mousedown touchstart'
            },
            show: false // don't show on mouseover
          };

          var customConfig = $.parseJSON(callout.qtip_config);
          var config = $.extend(true, {}, defaultConfig, customConfig);
          config.style.classes = config.style.classes.concat(" cdo-qtips");

          function reverseDirection(token) {
            if (/left/i.test(token)) {
              token = 'right';
            } else if (/right/i.test(token)) {
              token = 'left';
            }
            return token;
          }

          function reverseCallout(position) {
            position = position.split(/\s+/);
            var a = position[0];
            var b = position[1];
            return reverseDirection(a) + reverseDirection(b);
          }

          // Reverse callouts in RTL mode
          if (Blockly.RTL) {
            config.position.my = reverseCallout(config.position.my);
            config.position.at = reverseCallout(config.position.at);
            if (config.position.adjust) {
              config.position.adjust.x *= -1;
            }
          }

          if (callout.on) {
            window.addEventListener(callout.on, function() {
              if (!callout.seen && $(selector).length > 0) {
                callout.seen = true;
                $(selector).qtip(config).qtip('show');
              }
            });
          } else {
            $(selector).qtip(config).qtip('show');
          }

          return true;
        });
      },

      onAttempt: function(report) {
        var scriptPath = this.scriptPath;
        var _this = this;

        // Track puzzle attempt event
        trackEvent('Puzzle', 'Attempt', scriptPath, report.pass ? 1 : 0);
        if (report.pass) {
          trackEvent('Puzzle', 'Success', scriptPath, report.attempt);
          window.stopTiming('Puzzle', scriptPath, '');
        }
        trackEvent('Activity', 'Lines of Code', scriptPath, report.lines);

        // ==============
        // TODO: Removing lastServerResponse -- and therefore nextRedirect, previousLevelRedirect, and videoInfo has broken
        // all other level types besides Blockly.
        // They'll need to be updated to the new method of querying the level info (which is a good idea anyway since they are just
        // extra copies of the same code.)
        // ==============

        var onMilestone = function(response) {
          _this.report = null;

          // This used to be passed back from the milestone API.  It's used in a place that might not have easy access to
          // scriptPath, so we pack it in until we can remove that location.
          response.levelPath = scriptPath;

          if (report.onComplete)
            report.onComplete(response);
        }

        var data = $.extend({}, report);
        delete data.onComplete;

        // Make a POST request to the milestone API
        if (this.report)
          this.report.abort();
        this.report = Frame.save({
          url: this.milestone,
          data: data,
          success: onMilestone,
          error: function (xhr, textStatus, thrownError) {
            // Ignore an aborted API call
            if (textStatus == "abort")
              return;

            // It's okay if milestone fails. Catch the error and pretend it succeeded with minimal info.
            onMilestone({
              'error': xhr.responseText,
              message: report.pass ? 'good job' : 'try again',
              design: 'white_background'
            });
          }
        });
      },
      onResetPressed: function() {
        if (this.report) {
          this.report.abort();
          this.report = null;
        }
      },
      onContinue: function() {
        var route;

        // Is this level the script completion?
        if (opts.level.next === false) {
          route = {
            complete: opts.script_name
          };
        } else {
          // Calculate the next level and route to it.
          var next = opts.level.next || [ opts.level.stage, opts.level.position + 1];
          route = {
            script: opts.script_name,
            stage: next[0],
            level: next[1]
          };
        }

        // If this level has a wrap-up video, show it before moving on.
        if (opts.level.wrapupVideo) {
          opts.level.wrapupVideo.redirect = Frame.linkTo(route);  // someday, can just pass in a route.
          showVideoDialog(opts.level.wrapupVideo);
        } else {
          if (!Frame.goTo(route)) {
            // What kind of message should the user get?
          }
        }
      },
      backToPreviousLevel: function() {
        if (opts.level.previous === false) {
          // Does this mean anything or do we just fail silently?
          return;
        }

        // Calculate the previous level and route to it.
        var prev = opts.level.previous || [ opts.level.stage, opts.level.position - 1];
        var route = {
          script: opts.script_name,
          stage: prev[0],
          level: prev[1]
        };
        if (!Frame.goTo(route)) {
          // What kind of message should the user get?
        }
      },
      showInstructionsWrapper: function(showInstructions) {
        var hasInstructions = this.level.instructions || this.level.aniGifURL;
        if (!hasInstructions || this.share || this.level.skipInstructionsPopup) {
          return;
        }

        if (this.autoplayVideo) {
          showVideoDialog(this.autoplayVideo);
          $('.video-modal').on('hidden.bs.modal', function () {
            showInstructions();
          });
        } else {
          showInstructions();
        }
      }

    });

    return BlocklyApp;
  })(App);


  // Exports:
  window.UIRouter = UIRouter;
  window.UIFrame = UIFrame;
  window.BlocklyApp = BlocklyApp;

}).call(this);
