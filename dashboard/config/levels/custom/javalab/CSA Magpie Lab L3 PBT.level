<Javalab>
  <config><![CDATA[{
  "game_id": 68,
  "created_at": "2022-09-12T14:32:42.000Z",
  "level_num": "custom",
  "user_id": 16889,
  "properties": {
    "encrypted": "false",
    "mini_rubric": "false",
    "submittable": "false",
    "hide_share_and_remix": "false",
    "csa_view_mode": "console",
    "start_sources": {
      "MagpieRunner.java": {
        "text": "import java.util.Scanner;\n\npublic class MagpieRunner\n{\n  public static void main(String[] args)\n  {\n\n    // Instantiate a Magpie object\n    Magpie chatbot = new Magpie();\n\n    // Greet the user and get user input\n    System.out.println(chatbot.getGreeting());\n    Scanner input = new Scanner(System.in);\n    String statement = input.nextLine();\n\n    // Print the Magpie's responses\n    while (!statement.equals(\"Bye\"))\n    {\n      System.out.println(chatbot.getResponse(statement));\n      statement = input.nextLine();\n    }\n    \n  }\n}",
        "isVisible": true
      },
      "Magpie.java": {
        "text": "/**\n * A program to carry on conversations with a human user.\n *\n * This version uses indexOf to find strings and handles\n * responding to simple words and phrases. It uses nested\n * if statements to handle default responses.\n */\npublic class Magpie\n{\n\n  /**\n   * Gets a default greeting\n   * @return a greeting\n   */\n  public String getGreeting()\n  {\n    return \"Hello, let's talk.\";\n  }\n\n  /**\n   * Gives a response to a user's statement\n   * @param statement the user's statement\n   * @return a response based on the rules given\n   */\n  public String getResponse(String statement)\n  {\n    String response = \"\";\n\n    if (statement.length() == 0)\n    {\n      response = \"Say something, please.\";\n    }\n    else if (findKeyword(statement, \"no\") >= 0)\n    {\n      response = \"Why so negative?\";\n    }\n    else if (findKeyword(statement, \"mother\") >= 0 || findKeyword(statement, \"father\") >= 0\n              || findKeyword(statement, \"sister\") >= 0 || findKeyword(statement, \"brother\") >= 0)\n    {\n      response = \"Tell me more about your family.\";\n    }\n    else\n    {\n      response = getRandomResponse();\n    }\n\n    return response;\n  }\n\n  /**\n   * Searches for one word in a phrase. The search is not case-sensitive. This\n   * method will check that the given goal is not a substring of a longer string\n   * (so, for example, \"I know\" does not contain \"no\").\n   *\n   * @param statement the string to search\n   * @param goal the string to search for\n   * @param startPos the character of the string to begin the search at\n   * @return the index of the first occurence of goal in statement or -1 if not found\n   */\n  private int findKeyword(String statement, String goal, int startPos)\n  {\n    String phrase = statement.trim().toLowerCase();\n    goal = goal.toLowerCase();\n\n    // The only change to incorporate the startPos is in the line below.\n    int psn = phrase.indexOf(goal, startPos);\n\n    // Refinement - make sure the goal isn't part of a word\n    while (psn >= 0)\n    {\n      // Find the string of length 1 before and after the word.\n      String before = \" \", after = \" \";\n\n      if (psn > 0)\n      {\n        before = phrase.substring(psn - 1, psn);\n      }\n\n      if (psn + goal.length() < phrase.length())\n      {\n        after = phrase.substring(psn + goal.length(), psn + goal.length() + 1);\n      }\n\n      // If before and after aren't letters, we've found the word.\n      if (((before.compareTo(\"a\") < 0) || (before.compareTo(\"z\") > 0))\n             && ((after.compareTo(\"a\") < 0) || (after.compareTo(\"z\") > 0)))\n      {\n        return psn;\n      }\n\n      // The last position didn't work, so let's find the next if there is one.\n      psn = phrase.indexOf(goal, psn + 1);\n    }\n\n    return -1;\n  }\n\n  /**\n   * Search for one word in phrase. The search is not case-sensitive. This\n   * method will check that the given goal is not a substring of a longer string\n   * (so, for example, \"I know\" does not contain \"no\"). The search begins\n   * at the beginning of the string.\n   *\n   * @param statement the string to search\n   * @param goal the string to search for\n   * @return the index of the first occurrence of goal in statement or -1 if not found\n   */\n  private int findKeyword(String statement, String goal)\n  {\n    return findKeyword(statement, goal, 0);\n  }\n\n  /**\n   * Picks a default response to use if nothing else fits.\n   * @return a noncommittal string\n   */\n  private String getRandomResponse()\n  {\n    final int NUMBER_OF_RESPONSES = 4;\n    double r = Math.random();\n    int whichResponse = (int)(r * NUMBER_OF_RESPONSES);\n    String response = \"\";\n\n    if (whichResponse == 0)\n    {\n      response = \"Interesting, tell me more.\";\n    }\n    else if (whichResponse == 1)\n    {\n      response = \"Hmmm.\";\n    }\n    else if (whichResponse == 2)\n    {\n      response = \"Do you really think so?\";\n    }\n    else if (whichResponse == 3)\n    {\n      response = \"You don't say.\";\n    }\n\n    return response;\n  }\n  \n}",
        "isVisible": true
      }
    },
    "ai_tutor_available": true
  },
  "published": true,
  "audit_log": "[{\"changed_at\":\"2022-09-12T14:32:42.471+00:00\",\"changed\":[\"cloned from \\\"CSA Magpie Lab L2 PBT\\\"\"],\"cloned_from\":\"CSA Magpie Lab L2 PBT\"},{\"changed_at\":\"2022-09-12 14:32:45 +0000\",\"changed\":[],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-09-12 14:43:35 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-09-12 14:43:36 +0000\",\"changed\":[],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"}]"
}]]></config>
</Javalab>
