<Javalab>
  <config><![CDATA[{
  "properties": {
    "encrypted": "false",
    "long_instructions": "##Investigate and Modify\r\n\r\nRun the program to observe the results.\r\n\r\nThen, experiment with the program by making the following modifications. Change one line at a time, then run the program after each change to observe the results.\r\n\r\n1. Look at the `loopReverse()`(#e7e8ea) and `recursiveReverse()`(#e7e8ea) methods in `ListProcessor.java`(#e7e8ea). What similarities do you notice in these methods? What differences do you notice?\r\n\r\n2. In `MyConsole.java`(#e7e8ea), comment out the call to the `loopReverse()`(#e7e8ea) method and add the line `ListProcessor.recursiveReverse(numList, 0, numList.length - 1);`(#e7e8ea) then run the program to observe the results. What do you notice about what is printed?\r\n\r\n2. What is the purpose of the `return`(#e7e8ea) statement in the `recursiveReverse()`(#e7e8ea) method? Change the `return`(#e7e8ea) statement to `System.out.println(\"Done\");`(#e7e8ea) then run the program to observe the results. What is printed? Why do you think this is needed?\r\n\r\n3. Change the body of the `recursiveReverse()`(#e7e8ea) to the following code:\r\n\r\n```\r\nint temp = numbers[start];\r\nnumbers[start] = numbers[end];\r\nnumbers[end] = temp;\r\nrecursiveReverse(numbers, start + 1, end - 1);\r\n```\r\n\r\nRun the program to observe the results. Why do you think this happened?",
    "mini_rubric": "false",
    "submittable": "false",
    "hide_share_and_remix": "false",
    "csa_view_mode": "console",
    "start_sources": {
      "MyConsole.java": {
        "text": "public class MyConsole {\n  public static void main(String[] args) {\n\n    int[] numList = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n\n    ListProcessor.loopReverse(numList);\n\n    ListProcessor.printArray(numList);\n    \n  }\n}",
        "isVisible": true
      },
      "ListProcessor.java": {
        "text": "/*\n * Processes data stored in lists\n */\npublic final class ListProcessor {\n\n  /*\n   * Iteratively reverses an array\n   */\n  public static void loopReverse(int[] numbers) {\n    int start = 0;\n    int end = numbers.length - 1;\n\n    while (start < end) {\n      int temp = numbers[start];\n      numbers[start] = numbers[end];\n      numbers[end] = temp;\n\n      start++;\n      end--;\n    }\n  }\n\n  /*\n   * Recursively reverses an array\n   */\n  public static void recursiveReverse(int[] numbers, int start, int end) {\n    if (start >= end) {\n      return;\n    }\n    else {\n      int temp = numbers[start];\n      numbers[start] = numbers[end];\n      numbers[end] = temp;\n      recursiveReverse(numbers, start + 1, end - 1);\n    }\n  }\n\n  /*\n   * Prints the contents of an array\n   */\n  public static void printArray(int[] numbers) {\n    for (int value : numbers) {\n      System.out.print(value + \" \");\n    }\n  }\n  \n}",
        "isVisible": true
      }
    },
    "name_suffix": "_2022",
    "encrypted_examples": [

    ],
    "teacher_markdown": "##Investigate and Modify\r\n\r\n1. In both, the strategy for reversing the array is similar, we swap the values of `start`(#e7e8ea) and `end`(#e7e8ea) in the array. Each iteration, we *increment* `start`(#e7e8ea) and *decrement* `end`(#e7e8ea). The algorithm will run until `start`(#e7e8ea) and `end`(#e7e8ea) meet in the middle of the array. One main difference is the way in which they accomplish this swap. The `loopReverse()`(#e7e8ea) method uses a `while() loop`(#e7e8ea) to swap and increments `start`(#e7e8ea) / decrements `end`(#e7e8ea) with each pass of the loop until `start < end`(#e7e8ea). The `recursiveReverse()`(#e7e8ea) method includes `start`(#e7e8ea) and `end`(#e7e8ea) as two additional parameters. Instead of relying on a `while() loop`(#e7e8ea), this method will swap the elements found at `start`(#e7e8ea) and `end`(#e7e8ea), and then call itself while incrementing `start`(#e7e8ea) and decrementing `end`(#e7e8ea) in the method parameters. Once `start`(#e7e8ea) is greater than or equal to `end`(#e7e8ea), then method ceases this recursive activity and the array can be considered reversed.\r\n\r\n2. This method successfully reverses the array as shown in the output from the console. The main difference to note here is the need for three parameters vs. the one necessary for `loopReverse()`(#e7e8ea).\r\n\r\n3. The empty `return`(#e7e8ea) statement in the `recursiveReverse()`(#e7e8ea) method exits the method at that point. When we change this statement to `System.out.println(\"Done\");`(#e7e8ea), the message is printed to the console and the method completes as well since the conditional `(start >= end)`(#e7e8ea) is **true**. We could also simply change the conditional to match what is present in the `while loop`(#e7e8ea) in the `loopReverse()`(#e7e8ea) method in order to accomplish the same result: `if (start < end)`(#e7e8ea). \r\n\r\n4. When we change the body of the `recursiveReverse()`(#e7e8ea) and omit the conditional, our method attempts to call itself past the bounds of the array as we keep incrementing `start`(#e7e8ea) and decrementing `end`(#e7e8ea). This results in the following error:\r\n```\r\n[EXCEPTION] Your code hit an exception while it was running.\r\nException message: java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\r\n```\r\n"
  },
  "game_id": 68,
  "published": true,
  "created_at": "2022-02-26T00:32:23.000Z",
  "level_num": "custom",
  "user_id": 16889,
  "audit_log": "[{\"changed_at\":\"2022-02-26T00:32:23.145+00:00\",\"changed\":[\"cloned from \\\"CSA U7L8-L1\\\"\"],\"cloned_from\":\"CSA U7L8-L1\"},{\"changed_at\":\"2022-05-11 13:44:21 +0000\",\"changed\":[\"long_instructions\",\"encrypted_examples\",\"contained_level_names\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 13:46:34 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 14:18:00 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 14:20:40 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 14:21:03 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 14:27:04 +0000\",\"changed\":[\"start_sources\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-05-11 14:27:07 +0000\",\"changed\":[\"long_instructions\"],\"changed_by_id\":16889,\"changed_by_email\":\"jamila+lb@code.org\"},{\"changed_at\":\"2022-11-08 16:53:25 +0000\",\"changed\":[\"contained_level_names\"],\"changed_by_id\":18603,\"changed_by_email\":\"erik+levelbuilder@code.org\"},{\"changed_at\":\"2022-11-08 20:35:32 +0000\",\"changed\":[\"encrypted_examples\",\"teacher_markdown\"],\"changed_by_id\":18603,\"changed_by_email\":\"erik+levelbuilder@code.org\"}]"
}]]></config>
</Javalab>
