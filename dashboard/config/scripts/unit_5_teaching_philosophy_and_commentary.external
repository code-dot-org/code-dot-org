name 'Unit 5 Teaching Philosophy and Commentary'
css 'unplugged'

markdown <<MARKDOWN
# Unit 5 Content and Teaching Strategies

This unit gets back to using App Lab pretty much full time and so most of the lessons are constructed to follow the pattern we described back in Unit 3. 

The biggest difference in this unit from the turtle programming we did in Unit 3 is that this unit focuses on an “event-driven” model of programming. Turtle programming was more “procedural” - the flow of the program started at the top (or with the first function call) and the sequence of steps that the program went through could be traced until the program reached some end state. In event-driven programming the flow of the program is determined by “events” - typically a user doing something like clicking a button, moving the mouse, typing at the keyboard, etc. - and you write snippets of code to “handle” those events. Since the sequence of events cannot be predetermined you have to think a little bit differently about how to maintain the state of your program.

# Why do it this way? • The Role of the Teacher

## Why App Lab?

Building apps that look and feel like things students likely use in their everyday lives serves as an attractive lure. Furthermore, the ease and speed with which a student can put together the components and screen elements of an app of their own design rivals that of professional tools. App Lab decreases the time and “distance” a student must travel to get a concept from their head into a functional prototype. The patterns of user behavior and interaction should be familiar to students and we are banking on the event-driven model making sense to newcomers. “I add a button, and then I add code in a function that gets called when that button is clicked”. It’s pretty straightforward.

## Why so spend so much time on variables?

We spend a good amount of time introducing variables in this unit, seemingly to achieve rather simple results. But the time investment is worth it because students frequently have a number of misconceptions about variables and how they work in programs. The key understanding is that using a variable in programming is a method for storing data in memory for your program to use. Assigning a value to a variable (storing a value in memory) is a command like any other, and the state of that value can change over time. The major misconceptions come around syntax that looks like things students have seen in arithmetic (especially the = operator) but have different meanings in most programming languages. For example, we spend a good deal of time looking at “Variable re-assignment” or a code statement like x = x+1 which is an impossible expression in math class, but is a simple instruction in programming to add 1 the current value of x.

## Do students need to know how to use, read, create flow charts?

We use flow charts in lessons as a visual representation of a logical sequence of decision points that a program might follow, or even to outline the flow of an algorithm. Flow charts are a useful tool in that way, but not the only tool, and there is no expectation for the AP exam or performance tasks that students be able to create flow charts. Some people find flowcharts confusing or unnecessary. If students want to think about program flow and logic in a different way, that’s okay.

## As a teacher how can I help?

The best thing a teacher can do is try the projects and come to their own understandings of the concepts so that if a student is struggling you can help. Find the major projects and try them. It’s also important to remember the big picture: the programming ability that students must ultimately demonstrate on the performance task is rather limited. These lessons get into some of the nitty-gritty-dirty details and dark corners of these concepts because grappling with those issues gives you good insight into the broader concept - but students do not need to demonstrate mastery of those nitty-gritty-dirty details, just the basics. By the same token we spend a good amount of time in these lessons “bug bashing” - tracing code that has errors or problems in it to fix them. Being able to reason about code to explain or determine what it is or isn’t doing is something students will have to do on both the exam and in their written responses to the performance task.

# Teaching Strategies 
## Teaching While Loops and Simulation

Even though students have used a for-loop prior to this lesson, they have only used it as a “repeat loop” and have never been asked to reason about the code construct itself. While loops are a primitive looping structure which simply repeat a block of code as long as some boolean condition is true. Some people liken them to if-statements that repeat but be cautious with this analogy. One difficulty students often have with while loops is to confuse them mentally with so-called “repeat until” loops. When describing algorithms in English we often want something to repeat until some condition is true. While loops must state the condition as the inverse of that - you must state the conditions under which you should run the block of code again, rather then when you should stop. The best use of while loops is to repeatedly perform an action where you really don’t know how many times or how long you need to loop ahead of time. This is why we perform a simple coin flipping experiment in which students must simulate flipping a coin until heads comes up 15 times in a row and report back how many times the coin had to be flipped before that happened. In this way, while loops are very useful for running simple simulations. It’s often easier to write code and run a simulation of some real-world event, and arrive at an expected result experimentally, rather than try to calculate all the probabilities or do the counting by hand. While this is only a brief exercise we intend for it to build students’ understanding that (2.3) models and simulations use abstraction to generate new understanding and knowledge.

## Teaching Arrays and Array Processing

Arrays are the first (and only) real “data structure” that students will encounter and have to write code with in the course. The generic term for an array is a “list” and most programming languages have ways (usually multiple ways) of constructing, maintaining and processing lists of data. In JavaScript the primitive list structure is called an array. In the chapter we teach arrays over 5 lessons, which is a good amount of time. But there are a lot of aspects to using lists that takes some time to sink in. Only toward the end of the unit do we write loops to process the contents of an array (in the canvas drawing app). Doing a linear pass over an array (a loop that starts at the front of a list and does something to or with each element one at a time until it reaches the end) is the most sophisticated programming technique students will do in the course and be expected to reason about in an exam situation. Using a programming language’s built-in list manipulation capabilities is an example of the enduring understanding (5.3) programs employ appropriate abstractions.

Teaching strategies for this chapter will be similar to the previous chapter. We want to encourage students to continue work with a partner or “programming buddy” - a person that they can check their work with, clarify instructions, etc. Since the project/free play at the end is usually individual and creative, there is no “risk” in students helping each other along the way. Students should be held accountable for their work on projects, tests and practice PTs, not necessarily for each tiny step along the way. See the Teaching with Code Studio and App Lab document for more about teaching strategies.

MARKDOWN
