name '3.1 - 3.3 Lesson Connections in the Framework'
css 'unplugged'
markdown <<MARKDOWN
# 3.1 - 3.3 Lesson Connections in the Framework
Many of the Learning Objectives related to abstraction, programming, and algorithms don’t actually require students develop functioning code on a computer. In fact, it’s possible to successfully cover many of those learning objectives with either verbal language or a pseudocoding language, like the human machine language. These lessons cover the following elements of the curriculum framework: 

**Enduring Understanding 2.2 - Multiple levels of abstraction are used to write programs or create other computational artifacts**

2.2.3 - Identify multiple levels of abstractions that are used when writing programs. [P3]

- 2.2.3C - Code in a programming language is often translated into code in another (lower level) language to be executed on a computer.


**Enduring Understanding 4.1 - Algorithms are precise sequences of instructions for processes that can be executed by a computer and are implemented using programming languages.**

4.1.1 - Develop an algorithm for implementation in a program. [P2]

- 4.1.1A - Sequencing, selection, and iteration are building blocks of algorithms.
- 4.1.1B - Sequencing is the application of each step of an algorithm in the order in which the statements are given.
- 4.1.1C - Selection uses a Boolean condition to determine which of two parts of an algorithm is used.
- 4.1.1D - Iteration is the repetition of part of an algorithm until a condition is met or for a specified number of times.
- 4.1.1E - Algorithms can be combined to make new algorithms.
- 4.1.1F - Using existing correct algorithms as building blocks for constructing a new algorithm helps ensure the new algorithm is correct.
- 4.1.1G - Knowledge of standard algorithms can help in constructing new algorithms.
- 4.1.1H - Different algorithms can be developed to solve the same problem.
- 4.1.1I - Developing a new algorithm to solve a problem can yield insight into the problem.


**Enduring Understanding 4.2 - Algorithms can solve many but not all computational problems.**

4.2.4 - Evaluate algorithms analytically and empirically for efficiency, correctness, and clarity. [P4]

- 4.2.4F - Finding an efficient algorithm for a problem can help solve larger instances of the problem.

**Enduring Understanding 5.2 - People write programs to execute algorithms.**

5.2.1 - Explain how programs implement algorithms. [P3]

- 5.2.1A - Algorithms are implemented using program instructions that are processed during program execution.
- 5.2.1B - Program instructions are executed sequentially.
- 5.2.1D - An understanding of instruction processing and program execution is useful for programming.
- 5.2.1E - Program execution automates processes.
- 5.2.1J - Simple algorithms can solve a large set of problems when automated.


**Enduring Understanding 5.4 - Programs are developed, maintained, and used by people for different purposes.**

5.4.1 - Evaluate the correctness of a program. [P4]

- 5.4.1F - Knowledge of what a program is supposed to do is required in order to find most program errors.
- 5.4.1I - Programmers justify and explain a programâ€™s correctness.


## Selection, Iteration, and Sequencing
The findMin problem and the other problems we solved with the Human Machine Language use sequencing, selection, and iteration, which are outlined in 4.1.1A. Here’s what those terms mean:

- **Selection:** also known as “branching” most commonly seen in if-statements – The JUMP…IF command in the Human Machine Language is a form of selection. It gives us a way to compare two things (numbers) and take action if one thing was true.
- **Iteration:** also known as “looping” – The JUMP command in the Human Machine Language allows us to move to a different point in the program and start executing from there. This allows us to re-use lines of code, and this is a form of iteration or looping.
- **Sequencing:** From the framework: “4.1.1B - Sequencing is the application of each step of an algorithm in the order in which the statements are given.” Sequencing is so fundamental to programming it sometimes goes without saying. In our lesson, the sequencing is simply implied by the fact that we number the instructions with the intent to execute them in order.





MARKDOWN
