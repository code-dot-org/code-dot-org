<GamelabJr>
  <config><![CDATA[{
  "game_id": 64,
  "created_at": "2022-02-23T21:02:03.000Z",
  "level_num": "custom",
  "user_id": 9,
  "properties": {
    "skin": "gamelab",
    "show_debug_watch": "true",
    "embed": "false",
    "instructions_important": "true",
    "submittable": "false",
    "is_k1": "false",
    "skip_instructions_popup": "false",
    "never_autoplay_video": "false",
    "disable_param_editing": "true",
    "disable_variable_editing": "false",
    "disable_procedure_autopopulate": "false",
    "top_level_procedure_autopopulate": "false",
    "use_modal_function_editor": "true",
    "use_contract_editor": "false",
    "contract_highlight": "false",
    "contract_collapse": "false",
    "examples_highlight": "false",
    "examples_collapse": "false",
    "examples_required": "false",
    "definition_highlight": "false",
    "definition_collapse": "false",
    "disable_examples": "false",
    "hide_share_and_remix": "true",
    "disable_if_else_editing": "false",
    "free_play": "false",
    "hide_animation_mode": "false",
    "start_in_animation_tab": "false",
    "all_animations_single_frame": "true",
    "hide_view_data_button": "false",
    "expand_debugger": "false",
    "debugger_disabled": "false",
    "pause_animations_by_default": "false",
    "edit_code": "false",
    "helper_libraries": [
      "NativeSpriteLab"
    ],
    "droplet_tooltips_disabled": "false",
    "lock_zero_param_functions": "false",
    "hide_custom_blocks": "true",
    "use_default_sprites": "false",
    "auto_run_setup": "DRAW_LOOP",
    "parent_level_id": 21665,
    "long_instructions": "*Now, let's show your pet's excitement by giving it a behavior when the new sprite touches it.*\r\n\r\n<div style=\"float:right\">\r\n\r\n![expandable](https://images.code.org/3b258ed1cb7ec3e8df4b1208838bcec9-image-1620761093933.2021-05-11 14_29_41.gif)\r\n\r\n</div>\r\n\r\n## Do This:\r\n\r\n1. Add another `when touches` block to your code. Select your pet and its toy or friend.\r\n2. Use a `sprite begins` block to give your pet a new behavior *when the new sprite touches it.*\r\n\r\n**Optional Challenge:**\r\n* Play a sound to show your pet's excitment.",
    "show_type_hints": "true",
    "project_template_level_name": "Virtual Pet Template_2022_pilot",
    "include_shared_functions": "false",
    "block_pool": "gamelab",
    "name_suffix": "_2022_pilot",
    "encrypted": "false",
    "block_pools": [
      "GamelabJr"
    ],
    "mini_rubric": "false",
    "encrypted_examples": "lEL6rU0kqwdWvoMv9socMt9srTwsXK6+hN4tefiL382VwSExcieMxdSEuwiB\ny8YtDm2qbEFXxsAWtAXrEKIg0CNLotg7K2diSAk4dlkrgQUzPnCzgfu4Ge5N\ninjFuQriNj7xEQwteBeepLtGuAYE+w==\n",
    "teacher_markdown": "This lesson contains a **mini-project** called *Virtual Pet*. This progression may feel very different from what has come earlier in the course for you as well as your students. These levels have some new characteristics you may want to explore before starting. \r\n\r\n* The code your students write in one level will automatically transfer over to the other levels. This allows them to build gradually and iterate on their ideas as they learn.\r\n* These levels allow for more open-ended creativity. Empower your students to determine for themselves when they have completed each task. There is no one right answer! \r\n* Example solutions are available for this step of the progression which can be viewed by opening the teacher panel to the right.",
    "hint_prompt_attempts_threshold": "1",
    "validation_enabled": "false",
    "validation_code": "// Similar to 4-4\r\n// WhenTouch should add a new behavior for nondraggable\r\n// new behaviorList must be different than old. Loop thru each new behavior and see if it's in old. If not, we pass\r\n\r\n// just make sure a draggable touch event makes the pet start a new behavior\r\n\r\n// NOTES:\r\n//  - Add the touching handshake to 4-2 and anywhere else we check for sprite creation.\r\n//       - Do it for 4-5 too\r\n//       - Add to this level too\r\n\r\n// The `toyTouchedPet` criteria and where it's being set to true might need to be changed. We can't tell if the draggable is the food or toy so the feedback might not be specific enough (ie. the food is also draggable but will not change the sprite's behavior). \r\n//    - What to say if they only drag the food to the pet? What feedback string and how can we tell?\r\n\r\n// Do we need to check for 3 sprites and unique costumes again?\r\n\r\nif (!validationProps.successCriteria) {\r\n  validationProps.successCriteria = {\r\n    threeSprites: false,\r\n    uniqueCostumes: false,\r\n    hasPet: false,\r\n    hasTwoDraggable: false,\r\n    initialSpritesNotTouching: true,\r\n    toyTouchedPet: false,\r\n    petBeginNewBehaviorByTouch: false,\r\n    hasTouchEventBlock: false,\r\n    spritesTouched: false\r\n  };\r\n}\r\n\r\nif (!validationProps.previous) {\r\n  validationProps.previous = {};\r\n}\r\n\r\n// Helper function\r\nfunction checkEventLog(eventLog, eventType) {\r\n  for (var i = 0; i < eventLog.length; i++) {\r\n    if (eventLog[i].includes(eventType)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Helper function to check if a new behavior was added\r\nfunction addedNewBehavior(prevBehaviors, currBehaivors) {\r\n  for (var i = 0; i < currBehaivors.length; i++) {\r\n    var currentBehavior = currBehaivors[i];\r\n    if (prevBehaviors && !prevBehaviors.toString().includes(currentBehavior)) {\r\n      // a current behavior is not in the previous behavior list\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Helper variables\r\nvar spriteIds = getSpriteIdsInUse();\r\nvar animations = getAnimationsInUse();\r\nvar eventLog = getEventLog();\r\n\r\n// Check for at least 3 sprites\r\nif (spriteIds.length >= 3) {\r\n  validationProps.successCriteria.threeSprites = true;\r\n}\r\n\r\n// Check for all sprites having unique costumes\r\nif (spriteIds.length == animations.length) {\r\n  validationProps.successCriteria.uniqueCostumes = true;\r\n}\r\n\r\nvar numDraggable = 0;\r\nvar numNotDraggable = 0;\r\n\r\n// Check behavior for draggable\r\nfor (var i = 0; i < spriteIds.length; i++) {\r\n  var spriteId = spriteIds[i];\r\n\r\n  // checks if sprite is draggable\r\n  var behaviors = getBehaviorsForSpriteId(spriteId);\r\n  var draggable = behaviors.toString().includes(\"draggable\");\r\n\r\n  if (draggable) {\r\n    numDraggable++;\r\n  } else {\r\n    numNotDraggable++;\r\n  }\r\n}\r\n\r\n// Check for at least 1 non-draggable sprite\r\nif (numNotDraggable >= 1) {\r\n  validationProps.successCriteria.hasPet = true;\r\n}\r\n\r\n// Check for at least 2 draggable sprites\r\nif (numDraggable >= 2) {\r\n  validationProps.successCriteria.hasTwoDraggable = true;\r\n}\r\n\r\n// Check for whenTouch event\r\nif (checkEventLog(eventLog, \"whenTouch\")) {\r\n  validationProps.successCriteria.hasTouchEventBlock = true;\r\n\r\n  var currentEvent = eventLog[eventLog.length - 1] || \"\";\r\n  var spriteId = parseInt(currentEvent.split(\" \")[1]);\r\n  var targetId = parseInt(currentEvent.split(\" \")[2]);\r\n\r\n  var spriteBehaviors = getBehaviorsForSpriteId(spriteId);\r\n  var targetBehaviors = getBehaviorsForSpriteId(targetId);\r\n\r\n  var spriteDraggable = spriteBehaviors.toString().includes(\"draggable\");\r\n  var targetDraggable = targetBehaviors.toString().includes(\"draggable\");\r\n\r\n  // checks that exactly one sprite in the event is draggable\r\n  if (spriteDraggable && !targetDraggable) {\r\n    // spriteId is the draggable sprite\r\n    validationProps.successCriteria.toyTouchedPet = true;\r\n\r\n    var previous = validationProps.previous[targetId];\r\n\r\n    if (addedNewBehavior(previous, targetBehaviors)) {\r\n      validationProps.successCriteria.petBeginNewBehaviorByTouch = true;\r\n    }\r\n  } else if (targetDraggable && !spriteDraggable) {\r\n    // targetId is the draggable sprite\r\n    validationProps.successCriteria.toyTouchedPet = true;\r\n\r\n    var previous = validationProps.previous[spriteId];\r\n\r\n    if (addedNewBehavior(previous, spriteBehaviors)) {\r\n      validationProps.successCriteria.petBeginNewBehaviorByTouch = true;\r\n    }\r\n  }\r\n}\r\n\r\n// Checks to see if sprites are initially touching\r\nif (World.frameCount == 1) {\r\n  for (var i = 0; i < spriteIds.length; i++) {\r\n    var outer = spriteIds[i];\r\n\r\n    for (var j = i+1; j < spriteIds.length; j++) {\r\n      var inner = spriteIds[j];\r\n      \r\n      if (isTouchingSprite({ id: outer }, { id: inner })) {\r\n        validationProps.successCriteria.initialSpritesNotTouching = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Do handshake if no whenTouch event in eventLog\r\nif (!validationProps.successCriteria.hasTouchEventBlock) {\r\n  // See if sprites touched\r\n  for (var i = 0; i < spriteIds.length; i++) {\r\n    var outer = spriteIds[i];\r\n    var outerBehaviors = getBehaviorsForSpriteId(outer);\r\n    var outerDraggable = outerBehaviors.toString().includes(\"draggable\");\r\n\r\n    // This doesn't check that one of the sprites is draggable and the other is not\r\n    for (var j = 0; j < spriteIds.length; j++) {\r\n      var inner = spriteIds[j];\r\n      var innerBehaviors = getBehaviorsForSpriteId(inner);\r\n      var innerDraggable = innerBehaviors.toString().includes(\"draggable\");\r\n\r\n      if (outer != inner && isTouchingSprite({ id: outer }, { id: inner })) {\r\n        validationProps.successCriteria.spritesTouched = true;\r\n\r\n        if (innerDraggable != outerDraggable) {\r\n          // this might be wrong since the toy OR the food can be draggable\r\n          validationProps.successCriteria.toyTouchedPet = true;\r\n        }\r\n      }\r\n    }\r\n  } \r\n}\r\n\r\n// Storing sprite's behavior list\r\nfor (var i = 0; i < spriteIds.length; i++) {\r\n  validationProps.previous[spriteIds[i]] = getBehaviorsForSpriteId(spriteIds[i]);\r\n}\r\n\r\n// Set success time if success\r\nif (validationProps.successCriteria.hasPet&&\r\n    validationProps.successCriteria.hasTwoDraggable &&\r\n    validationProps.successCriteria.initialSpritesNotTouching &&\r\n    validationProps.successCriteria.hasTouchEventBlock && \r\n    validationProps.successCriteria.petBeginNewBehaviorByTouch &&\r\n   !validationProps.successTime)\r\n{\r\n  validationProps.successTime = World.frameCount;\r\n}\r\n\r\n// Delay fail time (so student can observe the wrong animation)\r\nvar earlyFailTime = 10;\r\nvar failTime = 150;\r\n\r\n// Check criteria and give failure feedback\r\nif (World.frameCount > earlyFailTime) {\r\n  if (!validationProps.successCriteria.threeSprites) {\r\n    levelFailure(3, \"createAtLeastThreeSprites\");\r\n  } else if (!validationProps.successCriteria.uniqueCostumes) {\r\n    console.log(\"Make sure all sprites have different costumes.\");\r\n    levelFailure(3, \"spritesNeedUniqueCostumes\");\r\n  } else if (!validationProps.successCriteria.hasPet) {\r\n    console.log(\"Only some of the sprites in this project will be dragable. Remove the draggable behavior from your pet.\");\r\n    levelFailure(3, \"createNotDraggableSPrite\");\r\n  } else if (!validationProps.successCriteria.hasTwoDraggable) {\r\n    console.log(\"Your pet's food and friend sprite need to begin the `being draggable` behavior.\");\r\n    levelFailure(3, \"createTwoDraggableSprites\");\r\n  } else if (!validationProps.successCriteria.initialSpritesNotTouching) {\r\n    console.log(\"To start, make sure none of your sprites are touching. Use the pin on the location block to give them different locations.\");\r\n    levelFailure(3, \"startingSpritesShouldNotTouch\");\r\n  } \r\n}\r\n\r\nif (World.frameCount > failTime) {\r\n  if (!validationProps.successCriteria.spritesTouched || !validationProps.successCriteria.toyTouchedPet) {\r\n    console.log(\"Drag your new sprite so it touches your pet sprite.\");\r\n    levelFailure(3, \"toyNotTouchPet\");\r\n  } else if (validationProps.successCriteria.spritesTouched && !validationProps.successCriteria.hasTouchEventBlock) {\r\n    console.log(\"Add a `when touching` event block and make your pet begin a new behavior.\");\r\n    levelFailure(3, \"addWhenTouchesEventToBeginNewBehavior\");\r\n  } else if (!validationProps.successCriteria.petBeginNewBehaviorByTouch) {\r\n    // Need to chnage feedback string\r\n    console.log(\"Use a `sprite begins` block to give your pet a new behavior *when the new sprite touches it.*\");\r\n    levelFailure(3, \"petNotBeginNewBehaviorOnTouch\");  \r\n  }\r\n}\r\n\r\n// Pass 60 frames after success\r\nvar waitTime = 60;\r\nif (World.frameCount - validationProps.successTime >= waitTime && !mouseDown('left')) {\r\nconsole.log(\"Generic success\");\r\nlevelFailure(0, \"genericSuccess\");\r\n}\r\n\r\npush();\r\nstroke(\"white\");\r\nif (!validationProps.successCriteria.hasPet ||\r\n    !validationProps.successCriteria.hasTwoDraggable ||\r\n    !validationProps.successCriteria.initialSpritesNotTouching ||\r\n    !validationProps.successCriteria.hasTouchEventBlock || \r\n    !validationProps.successCriteria.petBeginNewBehaviorByTouch) \r\n{\r\n  fill(rgb(118,102,160));\r\n  rect(0,390,(World.frameCount*400/failTime),10);\r\n} else {\r\n  fill(rgb(0,173,188));\r\n  rect(0,390,((World.frameCount-validationProps.successTime)*400/waitTime),10);\r\n}\r\npop();\r\n",
    "mini_toolbox": "false",
    "hide_pause_button": "false",
    "short_instructions": "Give your pet a behavior when the new sprite touches it.",
    "instructions_icon": "dog",
    "soft_buttons": [
      "leftButton",
      "rightButton",
      "downButton",
      "upButton"
    ],
    "preload_asset_list": null
  },
  "published": true,
  "notes": "",
  "audit_log": "[{\"changed_at\":\"2022-02-23T21:02:03.108+00:00\",\"changed\":[\"cloned from \\\"Virtual Pet 72022\\\"\"],\"cloned_from\":\"Virtual Pet 72022\"}]",
  "level_concept_difficulty": {
    "sequencing": 4,
    "events": 3
  }
}]]></config>
  <blocks/>
</GamelabJr>