"ka":
  slides:
    maze_intro:
      1:
        image: notes/hoc1_1.jpg
        text: მოგესალმები კოდის პირველ საათზე! დროა, გავუგოთ გემო პროგრამირებას.
      2:
        image: notes/hoc1_2.jpg
        text: ჩვენ გამოვიყენებთ ბლოკლის - პროგრამირების ვიზუალურ ენას, რომელშიც კოდის
          საწერად ბლოკები გამოიყენება.
      3:
        image: notes/hoc1_3.jpg
        text: ძირითადად, კოდს წერენ ხოლმე, მაგრამ ბლოკლი ვიზუალური ენაა. ყოველი ბლოკი
          "ნამდვილი" კოდის ერთ ხაზს შეესაბამება.
      4:
        image: notes/hoc1_4.jpg
        text: თქვენ ისწავლით კომპიუტერული მეცნიერების საწყისებს, რომლებიც გამოიყენება
          ყველგან, დაწყებული აპლიკაციების შექმნით, დამთავრებული მარსზე თვითმავალი
          აპარატის მართვით.
      5:
        image: notes/hoc1_5.jpg
        text: პროგრამა არის ინსტრუქციების ერთობლიობა, რომელსაც ემორჩილება თქვენი კომპიუტერი.
      6:
        image: notes/hoc1_6.jpg
        text: თქვენი პირველი პროგრამის მიზანია ლაბირინთის გავლით მიაღწევინო გაბრაზებულ
          ჩიტს მწვანე გოჭამდე.
      7:
        image: notes/hoc1_7.jpg
        text: მარცხენა მხარესაა ლაბირინთი, რომელშიც გაეშვება პროგრამა. ყოველი ამოცანის
          დავალება ლაბირინთის ქვემოთაა მოცემული.
      8:
        image: notes/hoc1_8.jpg
        text: ინსტრუმენტების შუა პანელი შეიცავს ბრძანებებს გაბრაზებული ჩიტის სამართავად.
          კოდის დასაწერად სწორედ ესენი უნდა გამოიყენოთ.
      9:
        image: notes/hoc1_9.jpg
        text: მარჯვნივ განლაგებულია თქვენი სამუშაო ადგილი, სადაც პროგრამის შესაქმნელად
          უნდა გადაიტანოთ ბლოკები ინსტრუმენტების პანელიდან. ბლოკის წასაშლელად გადაიტანეთ
          ის ნაგვის ყუთში.
      10:
        image: notes/hoc1_10.jpg
        text: ყოველი ბლოკი არის ერთი ბრძანება. თუ სამუშაო ადგილას გადაიტანთ ბლოკს
          "მოძრაობა წინ" და დააჭერთ "კოდის გაშვებას", ჩიტი ლაბირინთში ერთი ნაბიჯით
          გადაადგილდება.
      11:
        image: notes/hoc1_11.jpg
        text: ერთზე მეტი მოქმედების შესასრულებალად შეგიძლიათ სამუშაო ადგილას ბევრი
          ბლოკი გადაიტანოთ და გადააბათ ისინი ერთმანეთს. ჩიტი შეასრულებს ბრძანებებს
          ზემოდან ქვემოთ თანმიმდევრობით.
      12:
        image: notes/hoc1_12.jpg
        text: თუ პროგრამა უკვე გაუშვით, მაგრამ გინდათ რომ შეასწოროთ და თავიდან სცადოთ,
          დააჭირეთ ღილაკს "თავიდან".
      13:
        image: notes/hoc1_13.jpg
        text: დროა ადგილი მივუჩინოთ ამ გოჭებს!
    artist_intro:
      1:
        image: notes/stage5_1.jpg
        text: ჰეი, მე ჯეი ერი ვარ! მრბოლელთა ყოველ გუნდს მოსაგებად სჭირდება პროგრამისტები.
          ისინი ამუშავებენ მანქანის მონაცემებს მის ასაჩქარებლად.
      2:
        image: notes/stage5_2.jpg
        text: ამ თავსატეხებში თქვენ იქნებით მხატვარი, რომელიც ყველგან, სადაც მიდის,
          კვალად ტოვებს ხაზს.
      3:
        image: notes/stage5_3.jpg
        text: ესაა ბლოკი "გადაადგილება 100 პიქსელით". პიქსელი არის უმცირესი წერტილი
          თქვენს ეკრანზე.
      4:
        image: notes/stage5_4.jpg
        text: ესაა ბლოკი "მობრუნება მარჯვნივ 90 გრადუსით". იგი მოაბრუნებს მხატვარს
          ისევე, როგორც "მობრუნების" ბლოკი აბრუნებდა პერსონაჟებს ლაბირინთში.
      5:
        image: notes/stage5_5.jpg
        text: დააჭირეთ ისარს რომელიმე ბლოკში და შეცვალეთ მხატვრის წინ მოძრაობებისა
          ან მობრუნებების რაოდენობა. კარგად გაეცანით ამ ახალი ბლოკების შესაძლებლობებს.
    farmer_intro:
      1:
        image: notes/stage9_1.jpg
        text: ჰეი, მე პაოლა ვარ! ამ თავსატეხებში თქვენ ხაიქნებით ფერმერი, რომელმაც
          უნდა მოასწოროს თავისი ყანა ხორბლის დასათესად.
      2:
        image: notes/stage9_2.jpg
        text: უნდა დაეხმაროთ და მოაშორებინოთ მიწის ყველა გროვა და შეავსებინოთ ყველა
          ორმო.
      3:
        image: notes/stage9_3.jpg
        text: ახალი ბლოკი გროვას ერთ პორცია მიწას აშორებს და ყრის ერთ პორცია მიწას
          ორმოში.
      4:
        image: notes/stage9_4.jpg
        text: გროვები და ორმოები სხვადასხვა ზომისაა, ამიტომ უნდა აცნობოთ ფერმერს,
          რამდენჯერ მოიქნიოს ნიჩაბი.
    flappy_intro:
      1:
        image: notes/flappy01.jpg
        text: ჰეი, მე ვარ ქეითი! პროგრამირებაში ერთ-ერთი ყველაზე მაგარი რამ ისაა,
          რომ კომპიუტერული პროგრამა შეიძლება იყოს ინტერაქტიული.
      2:
        image: notes/flappy02.jpg
        text: ყოველჯერ, როცა ვინმე აჭერს რამე ღილაკს ან წერს რამეს კომპიუტერსა ან
          ტელეფონში, ხდება მოვლენა და არსებობს კოდი, რომელიც განსაზღვრავს, რა უნდა
          მოხდეს ამ მოვლენის დროს.
      3:
        image: notes/flappy03.jpg
        text: 'მაგალითად, შეიძლება მოვლენების გადამმუშავებელი იყოს ასეთი: თუ ვინმე
          დაკლიკავს მაუსით, უნდა გამოიცეს ხმა '
      4:
        image: notes/flappy04.jpg
        text: გაგიგიათ FlappyBird თამაში? მოვლენების გადამმუშავებლების მეშვეობით ჩვენ
          ამ თამაშის საკუთარ ვერსიას შევქმნით!
      5:
        image: notes/flappy05.jpg
        text: კოდი, რომელსაც თქვენ დაწერთ, შეიცავს ბლოკებს ბრძანებებით. დაფარული ნაწილის
          ქვეშ ყოველი ბლოკი ნამდვილი კოდია.
      6:
        image: notes/flappy06.jpg
        text: 'შეხედეთ სამუშაო სივრცეს - ხედავთ რამდენიმე შევსებულ მწვანე ბლოკს? მოვლენებს
          სწორედ ესენი დაამუშავებენ '
      7:
        image: notes/flappy07.jpg
        text: 'თუ გინდათ, რომ ჩიტი ფრთებს იქნევდეს ყოველთვის, როცა მაუსს დაკლიკავთ,
          მიუმაგრეთ "აქნევის" ბლოკი შესაბამისი მოვლენის დამამუშავებელ ბლოკს: ახლა
          თქვენს თამაშში, როცაც კი დაკლიკავთ, ჩიტი აფრინდება.'
      8:
        image: notes/flappy08.jpg
        text: ყოველ თავსატეხში მოვლენების ახალ ტიპებს შემოვიტანთ და თქვენ მოგიწევთ
          გადაწყვიტოთ, რომელი ბლოკები შეიცავს ამ მოვლენების შესაბამის მოქმედებებს.
      9:
        image: notes/flappy09.jpg
        text: როცა ასეთ დაშვებულ ისარს ხედავთ, ეს ნიშნავს რომ პარამეტრების შეცვლა
          შეგიძლიათ - მაგალითად, რომელი ხმა უნდა ისმოდეს, როცა ჩიტი დავარდება ძირს.
      10:
        image: notes/flappy10.jpg
        text: ბოლო თავსატეხში თქვენ შეძლებთ შექმნათ თქვენი საკუთარი თამაში და გაუზიაროთ
          ის მეგობრებს. იხალისეთ!
    loop_times:
      1:
        image: notes/hoc2_1.jpg
        text: ჰეი, მე ვარ მარკი! მოდი, მეტი ვისწავლოთ ციკლებზე. ციკლების გამოყენებით
          თქვენ აცნობებთ კომპიუტერს, რომ მოქმედებათა რაღაც ერთობა მიყოლებით უნდა გამეორდეს,
          ათასჯერ ან თუნდაც მილიონჯერ.
      2:
        image: notes/hoc2_2.jpg
        text: ამ თავსატეხში გოჭის დასაჭერად ჩიტი წინ 5 ნაბიჯით უნდა გადაადგილდეს.
      3:
        image: notes/hoc2_3.jpg
        text: ახალი ბლოკი "გამეორება" ახლა ძალიან დაგვეხმარება.
      4:
        image: notes/hoc2_4.jpg
        text: იმის მაგივრად, რომ ხუთი "წინ გადაადგილების" ბლოკი დააწყოთ...
      5:
        image: notes/hoc2_5.jpg
        text: შეგვიძლია ბლოკი "წინ გადაადგილება" ჩავსვათ "გამეორების" ბლოკში და ჩავწეროთ,
          რამდენჯერ უნდა გამეორდეს მოქმედება.
      6:
        image: notes/hoc2_6.jpg
        text: 'და ეს მნიშვნელოვანია: გამეორების ბლოკში ერთზე მეტი ბრძანების ჩასმა
          შეგიძლიათ.'
      7:
        image: notes/hoc2_7.jpg
        text: გამოიყენეთ ახალი ბლოკი "გამეორება"!
    loop_until:
      1:
        image: notes/hoc3_1.jpg
        text: 'ჰეი, მე კრისი ვარ. სანამ მაიამი ჰითს შევუერთდებოდი, ჯორჯიას ტექ. უნიში
          ვსწავლობთი ინფორმატიკას. მოდი, ვნახოთ, როგორია ჩვენი ახალი ბლოკი: "გაიმეორე,
          სანამ".'
      2:
        image: notes/hoc3_2.jpg
        text: რა ვქნათ, თუ არ ვიცით, რამდენად შორს უნდა წავიდეს ჩიტი, გოჭს რომ მიწვდეს?
      3:
        image: notes/hoc3_3.jpg
        text: თუ ბლოკს "მოძრაობა წინ" ჩავსვამთ ბლოკში "გაიმეორე, სანამ", ჩიტი იმოძრავებს
          წინ, სანამ არ მიაღწევს გოჭამდე (ან შეეჩეხება კედელს).
      4:
        image: notes/hoc3_4.jpg
        text: 'მნიშვნელოვანია: ისევე, როგორც ადრე, "გაიმეორე, სამამ" ბლოკში ბევრი
          ბლოკის ჩასმა შეიძლება და ისინი ყველა გამეორდება.'
    if:
      1:
        image: notes/hoc4_1.jpg
        text: ჰეი, მე ვარ ბილი! ვისწავლოთ ახალი მნიშვნელოვანი ცნება "თუ". ის კომპიუტერს
          გადაწყვეტილებების მიღებაშ იეხმარება.
      2:
        image: notes/hoc4_2.jpg
        text: დააკვირდით, თქვენ თვითონაც ხშირად იყენებთ "თუ"–ს გადაწყვეტილების მისაღებად.
          მაგალითად, ყოველ დილით ფიქრობთ "თუ გარეთ წვიმს, ქოლგას ავიღებ".
      3:
        image: notes/hoc4_3.jpg
        text: შეგვიძლიათ ვუთხრათ ზომბის, რომ შეამოწმოს, თუ არის მარცხნივ გზა, და თუ
          არის, ვუბრძანოთ, რომ მოუხვიოს.
      4:
        image: notes/hoc4_4.jpg
        text: 'დავწეროთ კოდი: გადავიტანოთ "თუ" ბლოკი და ჩავსვათ მასში ბლოკი "მოხვევა
          მარცხნივ".'
      5:
        image: notes/hoc4_5.jpg
        text: ახლა, თუ ზემოთ ჩავსვამთ ბლოკს "მოძრაობა წინ" და გამეორების ბლოკს ყველაფრის
          ირგვლივ, მოძრაობისას ზომბი ყოველთვის შეამოწმებს, არის თუ არა მარცხნივ შესახვევი.
          "გამეორება" ამ შემთხვევაში გადამწყვეტია, იმიტომ რომ ზომბიმ მოსახვევი ყოველ
          ნაბიჯზე უნდა შეამოწმოს.
      6:
        image: notes/hoc4_6.jpg
        text: '"თუ" დებულებები ძალიან მნიშვნელოვანია პროგრამირებაში. ერთ-ერთი პირველი
          თამაში, რაც დავწერე იყო Tic-Tac-Toe, რომელიც შეიცავდა შემდეგ დებულებას:
          "თუ სხვა მოთამაშე იგებს, დაბლოკე კვადრატი, რომლითაც შეუძლია მოგება".'
      7:
        image: notes/hoc4_7.jpg
        text: გამოიეყენეთ ახალი ბლოკი "თუ"!
    if_else:
      1:
        image: notes/hoc5_1.jpg
        text: ჰეი, მე მქვია სალონი. მე ვიყენებ ინფორმატიკას ჯანმრთელობისა და მედიცინის
          პრობლემების გადასაწყვეტად. მოდი, გავიგოთ, რა არის "თუ/ სხვაგვარად" ბრძანება.
          ის ჰგავს "თუ" ბლოკს, მაგრამ შეიცავს "სხვაგვარად" მოქმედების შესაძლებლობას.
      2:
        image: notes/hoc5_2.jpg
        text: თუ "წინ მოძრაობის" ბლოკს ჩავსვამთ იქ, სადაც წერია "შესრულება" და "მარცხნივ
          მოხვევას" იქ, სადაც წერია "სხვაგვარად", გამოვა, რომ ზომბიმ ორ შესაძლებლობას
          შორის უნდა აირჩიოს. თუ წინ იქნება გზა, ზომბი იმოძრავებს წინ, და სხვა შემთხვევაში
          (თუ წინ გზა არ არის), იგი მოუხვევს მარცხნივ.
      3:
        image: notes/hoc5_3.jpg
        text: ისევე, როგორც "თუ" ბლოკი, "თუ/სხვაგვარად" ბლოკიც შეგვიძლია ჩავსვათ გამეორების
          ბლოკში. ასე ზომბი გააგრძელებს მოძრაობას და "თუ/სხვაგვარად" ბლოკის გამო ყოველ
          ნაბიჯზე შეამოწმებს, არის თუ არა შესახვევი.
      4:
        image: notes/hoc5_4.jpg
        text: ახლა კი, მიიყვანეთ ეს ზომბი სადაც საჭიროა!
    if_else_scrat:
      1:
        image: notes/saloni_ifelse_scrat1.jpg
        text: '"თუ/სხვაგვარად" დებულება ასახვს ორ რამეს შორის არჩევანს. ვნახოთ, როგორ
          შეიძლება მისი გამოყენება იმისთვის, რომ ჩვენს მეგობარ სკრატს დავეხმაროთ.'
      2:
        image: notes/saloni_ifelse_scrat2.jpg
        text: ეს ბლოკი გამოიყურება ისევე, როგორც "თუ" ბლოკი, მაგრამ დამატებითი ფუნქცია
          აქვს - სხვაგვარად მოქცევის შესაძლებლობა. თუ იქ, სადაც წერია "შესრულება"
          ჩავსვამთ ბლოკს "მოძრაობა წინ" და იქ, სადაც წერია "სხვაგვარად" - "მარცხნივ
          მოხვევას", გამოვა, რომ ციყვი სკრატი იმოძრავებს წინ სულ, როცა ეს შესაძლებელი
          იქნება და თუ არა - მოუხვევს მარცხნივ.
      3:
        image: notes/saloni_ifelse_scrat3.jpg
        text: ასე ჩვენ ვამოწმებთ შესაძლებლობას და ვიღებთ გადაწყვეტილებას შედეგის საფუძველზე.
          ისევე, როგორც "თუ", "თუ/სხვაგვარად" ბლოკიც შეიძლება ჩაისვას "გამეორების"
          ბლოკში.
      4:
        image: notes/saloni_ifelse_scrat4.jpg
        text: ახლა დავეხმარეოთ ციყვ სკრატს მიაღწიოს ამ რკომდე!
    function:
      1:
        image: notes/stage13_1.jpg
        text: ჰეი, მე ვარ ბრინა, ინსტაგრამის პროგრამისტი. ფუნქცია არის კოდის გარკვეული
          ნაწილი, რომელიც ხშირად დაგჭირდებათ და ამიტომ მისი ყოველჯერ თავიდან დაწერის
          მაგივრად, შეგიძლიათ უბრალოდ ერთი ბლოკი გამოიყენოთ.
      2:
        image: notes/stage13_2.jpg
        text: ახლა უნდა ვისწავლოთ ფუნქციების განსაზღვრა. ფუნქციის განსაზღვრებას კუთხეში
          აქვს ვარსკვლავი, მისი სახელი კი ზედა ხაზში წერია.
      3:
        image: notes/stage13_3.jpg
        text: განსაზღვრებაში შემავალი ბლოკები აღწერენ ფუნქციის მოქმედებას. ამ ფუნქციას
          ჰქვია "შეავსე 5" და ის შედგება ბლოკებისგან "შევსება" და "გამეორება".
      4:
        image: notes/stage13_4.jpg
        text: განსაზღვრება უკვე სამუშაო სივრცეშია, მაგრამ ფერმერი არ შეასრულებს ფუნქციას,
          სანამ ჩვენს "შეავსე 5" ბლოკს არ გადმოვიტანთ ფუნქციების კატეგორიიდან.
      5:
        image: notes/stage13_5.jpg
        text: 'იმედია, ფუნქციები გაამარტივებს თქვენს სწავლას! '
    loop_while:
      1:
        image: notes/stage9_5.jpg
        text: 'ჰეი, მე ვარ მაკინდი! დროა, გავეცნოთ ბლოკს "სანამ". '
      2:
        image: notes/stage9_6.jpg
        text: ბლოკი "სანამ" გააკეთებს ყველაფერს, რაც მასშია ჩასმული, სანამ ზემოთ მოცმული
          დებულება ჭეშმარიტი იქნება.
      3:
        image: notes/stage9_7.jpg
        text: მაგალიად, თუ ფერმერი დგას გროვის გვერდით, იგი გააგრძელებს თითო-თითო
          ნიჩბის მოსმას, სანამ ეს გროვა ჯერ კიდევ არსებობს.
    loop_for:
      1:
        image: notes/stage11_1.jpg
        text: ჰეი, მე ვარ ტრინა და მე პიქსარში ვმუშაობ. სხვადასხვა ფილმებზე მიმუშავია,
          მაგალითად, შრეკზე.
      2:
        image: notes/stage11_2.jpg
        text: ეს არის ჩვენი ახალი ციკლი "მთვლელი". იგი გაიმეორებს მოქმედებებს უსასრულოდ
          და თქვენ ასევე შეგიძლიათ ცოტ-ცოტა შეცვალოთ ეს მოქმედებები ყოველი გამეორებისას.
      3:
        image: notes/stage11_3.jpg
        text: ამ მაგალითში ციკლი "მთვლელი" გვეუბნება "დავითვლი მთვლელით 50-დან 90-მდე
          ბიჯით 10" და მის შიგნით გვაქვს ბლოკი "დახატე კვადრატი". გამოიტანეთ ბლოკი
          "მთვლელი" ცვლადების სექციიდან "სიგრძის" სლოტში.
      4:
        image: notes/stage11_4.jpg
        text: ეს ნიშნავს, რომ ჩვენი მხატვარი დახატვს კვადრატს გვერდით 50 პიქსელი,
          მერე დაუმატებს 10-ს და დახატავს კვადრატს გვერდით 60 პიქსელი და ა. შ. ჯამში
          გვექნება 5 კვადრატი, გვერდებით 50, 60, 70, 80 და 90 პიქსელი.
    parameters:
      1:
        image: notes/stage15_1.jpg
        text: ჰეი, მე ვარ ჯანეტი და მე ვარ პროგრამისტი Zynga-ში.
      2:
        image: notes/stage15_2.jpg
        text: დავუშვათ, გვინდა დავხატოთ რამდენიმე სამკუთხედი სხვადასხვა სიგრძის გვერდებით.
          რა უნდა გავაკეთოთ?
      3:
        image: notes/stage15_3.jpg
        text: შეგვიძლია დავწეროთ მთელი კოდი ხელით ან გამოვიყენოთ ფუნქცია შესაბამისი
          პარამეტრებით.
      4:
        image: notes/stage15_4.jpg
        text: დაკლიკეთ ცისფერ ვარსკვლავს ფუნქციაში "დახატე სამკუთხედი". შემდეგ გადაიტანეთ
          "პარამეტრის სახელი" ბლოკში "პარამეტრი".
      5:
        image: notes/stage15_5.jpg
        text: შემდეგ, თუ იქ, სადაც წერია X ჩაწერთ "სიგრძეს" და დააჭერთ შეყვანის ღილაკს,
          ფუქნციაში შეიქმნება სიგრძის პარამეტრი.
      6:
        image: notes/stage15_6.jpg
        text: ახლა დააჭირეთ ვარსკვლავს, შემდეგ კატეგორიას "ცვლადები" და გადაიტანეთ
          ბლოკი "სიგრძე" ბლოკში "მოძრაობა წინ". წინა რიცხვითი ბლოკი წაშალეთ.
      7:
        image: notes/stage15_7.jpg
        text: ფუნქციის პარამეტრებით გამოსაყენებლად, გადადით კატეგორიაში ფუნქციები
          და გამოიტანეთ ფუნქცია "სამკუთხედის დახატვა მოცემული სიგრძით".
      8:
        image: notes/stage15_8.jpg
        text: ახალ შეგიძლიათ გამოიყენო ბლოკი "მათემატიკა" და შეიყვანოთ მასში სხვადასხვა
          რიცხვები - ასე დახატავთ სხვადასხვა ზომის სამკუთხედებს.
    hoc_wrapup:
      1:
        image: notes/hoc6_1.jpg
        text: გილოცავთ! ბოლო თავსატეხის ამოხსნისას თქვენ დაწერეთ კოდი, რომლითაც ნებისმიერი
          რობოტი გააგნებს გზას ნებისმიერ ხაზოვან ლაბირინთში და ნებისმიერი სიგრძის
          ტუნელში.
      2:
        image: notes/hoc6_2.jpg
        text: ცნებები, რომელსაც იყენებდით არის ნებისმიერი პროგრამის ან აპლიკაციის
          ძირითადი ნაწილი. ჩვენ ვისწავლეთ ციკლების გამეორება, გამეორება მიზნის მიღწევამდე,
          თუ და თუ/სხვაგვარად დებულებები.
      3:
        image: notes/hoc6_3.jpg
        text: თუ მოგეწონათ კოდის თქვენი პირველი საათი, ეწვიეთ code.org-ს და გააგრძელეთ
          პროგრამირების სწავლა. როცა დაასრულებთ ჩვენს ოცსაათან კურსს, პროგრამირების
          საფუძვლები სრულად გექნებათ გავლილი და შეძლებთ დაიწყოთ მობილური აპლიკაციების,
          რობოტების ინსტრუქციების, თამაშების... ნებისმიერი რამის პროგრამირების სწავლა.
      4:
        image: notes/hoc6_4.jpg
        text: 'ტექნოლოგიები ცვლის ყველაფერს და არა აქვს მნიშვნელობა, ახალგაზრდა ხართ
          თუ აღარ: პროგრამირება სახალისოა, კრეატიული და მისი სწავლა ყველას შეუძლია!'
    20_wrapup:
      1:
        image: notes/bird.png
        text: ჩანაწერები მალე იქნება!
    frozen_intro:
      1:
        image: notes/frozen1_1.jpg
        text: ჰეი, მე მქვია ლინდსი. მე ვიგონებ და ვქმნი ჩემს საკუთარ აპლიკაციებს.
          გამოვიყენოთ კოდი და შევუერთდეთ ანასა და ელზას მაგიისა და ყინულის სამყაროში.
      2:
        image: notes/frozen1_2.jpg
        text: ციგურებზე სრიალისას თქვენ დახატავთ სხვადსხვა ფიფქებსა და შექმნით ზამთრის
          საოცრებათა ქვეყანას, მერე კი მისი მეგობრებისთვის გაზიარება შეგეძლებათ.
      3:
        image: notes/frozen1_3.jpg
        text: შემდეგი ერთი საათის განმავლობაში პროგრამირების საფუძვლებს დაეუფლებით.
          ჩვეულებრივ, პროგრამირება ტექსტის წერას ნიშნავს, მაგრამ ჩვენ ვიყენებთ blockly–ს
          - ენას, რომელშიც საკმარისია ბლოკებით მანიპულირება. ასე სწავლობენ პროგრამირების
          საფუძვლებს უნივერსიტეტების სტუდენტებიც კი. სინამდვილეში, თქვენ მაინც წერთ
          კოდს.
      4:
        image: notes/frozen1_4.jpg
        text: პროგრამა არის ინსტრუქციების ნაკრები, რომელიც აცნობებს კომპიუტერს, თუ
          რა უნდა გააკეთოს მან. დავწეროთ კოდი ან პროგრამა, რომელიც დაეხმარება ელზას
          მარტივი ხაზის გავლებაში. შემდეგ ამ კოდს უფრო რთული ნახატების შესაქმნელად
          გამოვიყენებთ.
      5:
        image: notes/frozen1_5.jpg
        text: თქვენი ეკრანი სამ ძირითად ნაწილადაა დაყოფილი. მარცხნივ არის ყინულის
          მოედანი, სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები კი ქვემოთ
          იქნება დაწერილი.
      6:
        image: notes/frozen1_6.jpg
        text: ეს შუა ნაწილი არის ინსტრუმენტების პანელი და ყოველი ბლოკი არის მოქმედება,
          რომლის შესრულება შეუძლიათ ელზასა და ანას.
      7:
        image: notes/frozen1_7.jpg
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
          მაგალითად, ყინულზე გადასაადგილებლად აქ გადმოვიტანთ "წინ მოძრაობის" ბლოკს.
      8:
        image: notes/frozen1_8.jpg
        text: ბლოკი "წინ გადაადგილება" განსაზვღულია, როგორც "გადაადგილება წინ 100
          პიქსელით". რა მოხდება, თუ ამ კოდს გავუშვებთ? ელზა გადაადგილდება ჩვენს ეკრანზე
          ზუსტად 100 პიქსელით. (პიქსელი უმცირესი წერტილია ეკრანზე.)
      9:
        image: notes/frozen1_9.jpg
        text: შემდეგი ბლოკი, რომელიც მოცემული გვაქვს ამ თავსატეხში, განსაზღვრულია,
          როგორც "90 გრადუსით მობრუნება". როცა ვიყენებთ ბლოკს "მარჯვნივ მობრუნება",
          ელზა ტრიალდება გაკრვეული კუთხით. თქვენ შეგიძლიათ სხვადასხვა მნიშვნელობები
          ჩაწეროთ და ნახოთ, რა მოხდება. კუთხე იზომება ელზას წინ მდებარე გზიდან. მაგალითად,
          ეს არის 90 გრადუსით მობრუნება, ეს კი - 120-ით.
      10:
        image: notes/frozen1_10.jpg
        text: გახსოვდეთ, პიქსელებისა და გრადუსების ზომა შეგიძლიათ ისრებით შეცვალოთ.
    frozen_loops:
      1:
        image: notes/frozen2_1.jpg
        text: ჰეი, მე ვარ პაოლა. იცით, კომპიუტერებს ძალიან კარგად გამოსდით მოქმედებების
          გამეორება. თქვენ შეიძლება დათვლით ათამდე, ოცამდე ან ასამდე. მაგრამ კომპიუტერი
          დათვლის მილიარდამდე, ტრილიონამდე. მას ეს არც მობეზრდება და არც ბევრ დროს
          წაართმევს. თვლის, ხატვის - ნებისმიერი მოქმედების გამეორება კომპიუტერს დაუსრულებლად
          შეუძლია.
      2:
        image: notes/frozen2_2.jpg
        text: პროგრამირებაში ჩვენ ამას ვეძახით ციკლს. ციკლია, როდესაც თქვენი მოქმედება
          დაუსრულებლად მეორდება. შემდეგ თავსატეხში თქვენი მიზანია დაახატინოთ ანას
          კვადრატი "გამეორების" ბლოკის გამოყენებით.
      3:
        image: notes/frozen2_3.jpg
        text: კოდის ნებისმიერი ბლოკი, რომელსაც "გამეორების" ბლოკში ჩასვამთ, გამეორედება
          იმდენჯერ, რამდენჯერაც თქვენ ეს გჭირდებათ.
      4:
        image: notes/frozen2_4.jpg
        text: კვადრატის დასახაზად შეგიძლიათ გამოიყენოთ ოთხ-ოთხჯერ ბლოკები "მოძრაობა
          წინ" და "მობრუნება მარჯვნივ". მაგრამ უფრო მარტივი იქნება ეს ორი ბლოკი თითო-თითოჯერ
          გამოიყენოთ, შემდეგ კი 4-ჯერ გაამეორებინოთ კომპიუტერს იგივე მოძრაობა. ამისთვის
          სამარისია ეს ბლოკები ჩასვათ ბლოკში "გამეორება".
      5:
        image: notes/frozen2_5.jpg
        text: გახსოვდეთ, რომ რა რიცხვსაც ჩაწერთ ბლოკში "გამეორება", იმდენჯერ გამეორდება
          ის მოქმედებები, რაც ბლოკის შიგნითაა მოთავსებული.
    frozen_functions:
      1:
        image: notes/frozen3_1.jpg
        text: ჰეი, მე ვარ კრის ბოში. მე პროფესიონალურად ვთამაშობ კალათბურთს, კოლეჯში
          კი პროგრამირებას ვსწავლობდი.
      2:
        image: notes/frozen3_2.jpg
        text: ახალი ბრძანებების განსაზღვრა პროგრამირების ძალიან მნიშვნელოვანი ნაწილია.
          პროგრამირების ენების უმეტესობას სულ 100 სიტყვა და ბრძანება აქვს. ამ ერთეულების
          გამოყენებით ახალი ბრძანებების შექმნა ნამდვილი ხელოვნებაა.
      3:
        image: notes/frozen3_3.jpg
        text: როცა ერთხელ განუმარტავთ კომპიუტერს, როგორ უნდა შეასრულოს მოქმედებების
          რიგი, შეგიძლიათ ამ ერთიან მოქმედებას რამე სახელი დაარქვათ - ასე მისი გამეორება
          მომავალში უფრო მარტივი იქნება. ამას ფუნქციის შექმნა ეწოდება.
      4:
        image: notes/frozen3_4.jpg
        text: ჰეი, მე ვარ ჯესი. ფუნქციები საჭიროა, როცა გვაქვს ქმედებათა ისეთი ნაკრები,
          რომელიც გვინდა, რომ ხშირად გამოვიყენოთ. მაგალითად, თქვენ დაწერეთ კოდი კვადრატის
          დასახატად.
      5:
        image: notes/frozen3_5.jpg
        text: 'შეგიძლიათ განსაზღვროთ ეს როგორც ფუნქცია და დაარქვათ "კვადრატის დახატვა." '
      6:
        image: notes/frozen3_6.jpg
        text: ახლა გაქვთ ახალი ბლოკი, რომელიც შეგიძლიათ გამოიყენოთ კვადრატების დასახატად.
      7:
        image: notes/frozen3_7.jpg
        text: მარტივი ფიგურებით რთული ფორმების შექმნაა შესაძლებელი. შემდეგ თავსატეხში
          კოდი, რომელიც წრის დასახატად დაწერეთ, ფუნქციის სახით გექნებათ მოცემული და
          შეძლებთ სხვადასხვა ზომის წრეების დახატვას. დაეხამრებით ელზას თოვლზე ლამაზი
          და რთული ნახატების შექმნაში?
    playlab_intro:
      1:
        image: notes/playlab_intro_1.png
        text: 'თამაშებს თამაშების ლაბორატორიაში შევქმნით. კარგ თამაშში ყოველთვის არის
          ისტორია და ყოველ ისტორიაში არსებობენ პერსონაჟები. ჩვენ ვისწავლით როგორ ავალაპარაკოთ,
          ავამოძრავოთ და ერთმანეთში ურთიერთობა დავამყარებინოთ ჩვენს პერსონაჟებს: ჯადოქრებს,
          უცხოპლანეტელბს და ცხოველებს. ამ ტუტორიალის დასრულების შემდეგ თქვენ შეძლებთ
          შექმნათ თქვენი თამაში და გაუზიაროთ ის მეგობრებს.'
      2:
        image: notes/playlab_intro_2.png
        text: თქვენი ეკრანი სამ ძირითად ნაწილადაა დაყოფილი. მარცხნივ არის ყინულის
          მოედანი, სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ქვემოთ
          იქნება დაწერილი.
      3:
        image: notes/playlab_intro_3.png
        text: შუაში არის ინსტრუმენტების პანელი, სადაც ყოველი ბლოკი არის კოდი. თეთრი
          სივრცე მარჯვნივ არის სამუშაო სივრცე, სადაც დაიწერება ჩვენი პროგრამა.
      4:
        image: notes/playlab_intro_4.png
        text: პირველ რიგში, ბლოკები უნდა მიემაგროს ნარინჯისფერ ბლოკს "გაშვებისას".
          რამდენიმე ბლოკის ერთად შეკვრა შეგიძლიათ - მიუახლოვეთ ისინი ერთმანეთს, სანამ
          არ გაჩნდება ყვითელი ხაზი და შემდეგ შეაერთეთ.
      5:
        image: notes/playlab_intro_5.png
        text: პირველ თავსატეხში ჩვენი პერსონაჟი არის პინგვინი, რომელსაც უნდა ვასწავლოთ
          მისალმება. ამისთვის ავიღოთ "თქმის" ბლოკი, მივუმაგროთ იგი გაშვების ბლოკს
          და ჩავწეროთ მასში "სალამი". მაჯვნივ და მარცხნივ მოძრაობის ბლოკებით შეგვიძლია
          გადავაადგილოთ კიდევაც ჩვენი პინგვინი. როცა ყველა ბლოკს დაალაგებთ, გაუშვით
          პროგრამა და ნახეთ, რა გამოგივიდა.
      6:
        image: notes/playlab_intro_6.png
        text: დაიწყეთ პროგრამირება და ბოლოს შეძლებთ შექმნათ თქვენი საკუთარი თამაში,
          ყველანაირი პერსონაჟებით, რომელთაც შეეძლებათ ურთიერთობა, მხიარულება ან მოწყენა,
          ქულების დაგროვება და ცეცხლოვანი ბურთების სროლა - ერთმანეთის გაქრობაც კი.
          ყველაფერი თქვენზეა დამოკიდებული.
    playlab_events:
      1:
        image: notes/playlab_events_1.png
        text: ახლა ისეთ რამეს ვისწავლით, რასაც პროგრამისტები ყოველ დღე იყენებენ -
          მოვლენებს. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას უნდა დაუცადოს.
          როცა ეს რაღაც - მოვლენა - მოხდება, პროგრამა გარკვეულ ქმედებას განახორციელებს.
      2:
        image: notes/playlab_events_2.png
        text: 'მოვლენა შეიძლება იყოს: მაუსის დაკლიკვა, ისრის ღილაკზე დაჭერა, ეკრანზე
          შეხება.'
      3:
        image: notes/playlab_events_3.png
        text: ახლა უნდა გავაკეთოთ ისე, რომ კოსმოსური ბოტი მიესალმოს დედამიწელებს,
          როცა მასზე დაკლიკავენ. გამოიყენეთ ბლოკი "როცა დაკლიკავენ" და მიუმაგრეთ მას
          ბლოკი "თქმა". როცა მოთამაშე დაკლიკავს ბოტს, მოხდება ყველაფერი, რაც მიმაგრებულია
          ბლოკს "როცა დაკლიკავენ". ჰმ.. რა უნდა ათქმევინოთ თქვენს უცხოპლანეტელს?
      4:
        image: notes/playlab_events_4.png
        text: კიდევ გვაქვს ბლოკი "როცა ისარი". თუ ამ ბლოკს მოძრაობის ბლოკებს მიუმაგრებთ,
          თქვენი პერსონაჟი ზემოთ, ქვემოთ, მარჯვნივ ან მარცხნივ იმოძრავებს. ხედავთ?
          თქვენი თამაში უფრო და უფრო ინტერაქტიული ხდება.
    playlab_repeat_forever:
      1:
        image: notes/playlab_repeat_forever_1.png
        text: ეს არის ბლოკი "უსასრულოდ გამეორება". ყველაფერი, რასაც მასში ჩასვამთ
          უსასრულოდ გამეორედება თამაშის განმავლობაში.
      2:
        image: notes/playlab_repeat_forever_2.png
        text: თუ გვინდა, რომ პერსონაჟმა რაღაც ქმედება მუდმივად შეასრულოს, მოთამაშის
          ჩარევის გარეშე, ეს ქმედება "უსასრულოდ გამეორების" ბლოკში უნდა ჩავსვათ.
      3:
        image: notes/playlab_repeat_forever_3.png
        text: შემდეგ თავსატეხში ჩვენი მიზანია დავეხმაროთ ჯადოქარს სამეფოს საზღვრების
          დაზვერვაში - ანუ, მან უსასრულოდ უნდა იმოძრავოს მარჯვნივ და მარცხნივ. გამეორების
          ფუნქციების კარგად შესწავლა უამრავ დროს დაგიზოგავთ მომავალში, როცა თქვენს
          საკუთარ თამაშს დაწერთ.
    C1_artist_intro:
      1:
        image: notes/C1_artist_intro_1.png
        text: ესენია თქვენი სახატავი ბლოკები. გამოიყენეთ სწორი - ჩვენი მიზანია, მხატვარი
          წავიდეს იქ, სადაც შესავსებია ნაცრისფერი ხაზები.
      2:
        image: notes/C1_artist_intro_2.png
        text: ესენია ხტუნვის ბლოკები. როცა მათ იყენებთ, თქვენი მხატვარი მოძრაობს,
          მაგრამ არ ხატავს. ამიტომ, შეგიძლიათ გამოიყენოთ ეს ბლოკები შემდეგ ნაცრისფერ
          ხაზთან გადასახტომად.
    C1_bee_level_intro:
      1:
        image: notes/C1_bee_level_intro_1.png
        text: არ გგონიათ, რომ ფუტკრები სუპერ-მაგრები არიან? თავსატეხების შემდეგ ნაკრებში
          თქვენი მიზანი იქნება, დაეხმაროთ ფუტკარს მივიდეს ყვავილებთან, მოკრიბოს ნექტრი
          და შემდეგ გააკეთოთ სკებში თაფლი. ამ სავარჯიშოში დაგჭირდებათ ბლოკები "ნექტარის
          მოპოვება" და "თაფლის გაკეთება".
      2:
        image: notes/C1_bee_level_intro_2.png
        text: 'ყოველ ყვავილს ნექტარის განსხვავებული რაოდენობა აქვს: 1, 2, 3 ან მეტი.
          ვიცით, რამდენი ნექტარი არის წითელ ყვავილებში - კუთხეში პატარა რიცხვის მიხედვით.
          დარწმუნდით, რომ ნექტარი მთლიანად აიღეთ და მხოლოდ შემდეგ გადადით წინ. ამის
          გარდა, გაითვალისწინეთ რომ ყოველ სკაში მხოლოდ 1, 2, 3 ან მეტი თაფლი შეიძლება
          მოთავსდეს, ამიტომ გააკეთეთ ზუსტად იმდენი თაფლი, რამდენის დატევაც შეუძლია
          კონკრეტულ სკას.'
      3:
        image: notes/C1_bee_level_intro_3.png
        text: თუ შეძლებთ და მთელ ნექტარს მოაგროვებთ და მთელ თაფლს გააკეთებთ, შემდეგ
          დონეზე გადახვალთ. სხვა შემთხვევაში, თავიდან მოგიწევთ ამ თავსატეხის გავლა.
          ითამაშეთ და იგრძენით, რას ნიშნავს, იყო პროგრამისტი!
    C1_bee_loops:
      1:
        image: notes/C1_bee_loops_1.png
        text: ციკლი არის ქმედების გამერეობა. როცა სკა უნდა გამოვიკვლიო, მე მას ვიღებ
          და მერე ვდებ უკან. იგივე მოქმედებას ბევრჯერ ვიმეორებ - სწორედ ეს არის ციკლის
          შესრულება, იგივე ქმედების ბევრჯერ გამეორება.
      2:
        image: notes/C1_bee_loops_2.png
        text: ამ დონეზე ფუტკარს ყვავილიდან სამი ნექტარი უნდა მოვაკრებინოთ. იმის მაგივრად,
          რომ სამჯერ გამოვიყენოთ ბლოკი "ნექტარის მოპოვება", გამოვიყენებთ გამეორების
          ბლოკს, რომ ნექტარი სამჯერ მოვიპოვოთ. დააჭირეთ "გაშვებას" და ნახეთ, სწორად
          თუ გამოგივიდათ. კარგია!
    C1_bigevent_unplugged:
      1:
        image: notes/C1_bigevent_unplugged_1.png
        text: ამ გაკვეთილს ჰქვია "დიდი მოვლენა". ჩვენ ვისწავლით, როგორ ვაკონტროლოთ
          ჩვენი პროგრამები და შევცვალოთ მათი ქმედებები მოვლენების გამოყენებით. მაგალითად,
          ღილაკის ან მაუსის დაჭერის მოვლენებით.
      2:
        image: notes/C1_bigevent_unplugged_2.png
        text: ამ გაკვეთილში თქვენ ქაღალდის დისტანციური მართვის პულტით იქნებით მართულნი.
          თითქოს რეალურ ვიდეო-თამაშში ხართ.
      3:
        image: notes/C1_bigevent_unplugged_3.png
        text: მოვლენა არის ქმედება, რომელიც განსაზღვრავს სხვა ხდომილებას. მაგალითად,
          ეს შეიძლება იყოს მაუსზე ღილაკის დაჭერა ან ვერ-გვერდის ჩატვირთვა. როცა პლანშეტის
          ეკრანს ეხებით, გვერდის ჩამოსაწევად, ესეც მოვლენაა. მოვლენები აძლევს მომხმარებელს
          საშუალებას, მათთვის ხელსაყრელი გზით წარმართონ თქვენი პროგრამა.
      4:
        image: notes/C1_bigevent_unplugged_4.png
        text: არის რაღაც მოვლენები, რომლებზეც ყველა ვრეაგირებთ. გვშია და მაცივრისკენ
          მივდივართ. გვესმის, რომ ფოსტალიონი მოვიდა და მივდივართ ჩვენი წერილის მისაღებად.
          ზუსტად ასეთივე მოვნელებია ღილაკის დაჭერა ან მაუსის მოძრაობა. როცა ეს მოვლენები
          ხდება, რაღაც სხვა ხდება საპასუხოდ.
      5:
        image: notes/C1_bigevent_unplugged_5.png
        text: ვიდეო-თამაშებში არის მოვლენა "განახლება" და ის წამში 30-ჯერ ან 60-ჯერ
          ხდება. ვიდეო-თამაშების პროგრამისტებისთვის ის თითქმის უფრო მნიშვნელოვანია,
          ვიდრე ღილაკებზე დაჭერის მოვლენა.
      6:
        image: notes/C1_bigevent_unplugged_6.png
        text: 'ძირითადი მოვლენა, რომელსაც ჩვენ ვყარაულობთ, არის "განახლება". შემდეგ
          კი ვამოწმებთ ამ განახლებას: "დააჭირა ვინმემ ღილაკს? კი თუ არა?" მოვლენების
          გარეშე პერსონაჟი ვერ იმოძრავებდა, თქვენ ვერ ახტებოდით, ვერ გააკონტროლებდით
          მოვლენებს. ვიდეოთამაშში არაფერი არ მოხდებოდა.'
    C1_building_foundation:
      1:
        image: notes/C1_building_foundation_1.jpg
        text: ქვიშის ქანდაკებაში თქვენ ისწავლეთ, რომ წარუმატებლობა პროგამის ნაწილია.
          მაგრამ თუ არ დანებდებით, ყველაფერს გამოასწორებთ და უფრო საინტერესოსაც კი
          გახდით. ამ თამაშს შეუპოვრობა ჰქვია. სცადეთ და მოგეწონებათ.
      2:
        image: notes/C1_building_foundation_2.jpg
        text: ამ გაკვეთილს ჰქვია საძირკვლის ჩაყრა. ამ გაკვეთილში ძალიან რთულ საქმეს
          გავაკეთებთ. უნდა შექმნათ მინიმუმ ამ ჭიქების სიმაღლის სტრუქტურა, რომელიც
          წიგნის წონას გაუძლებს.
      3:
        image: notes/C1_building_foundation_3.jpg
        text: ხანდახან ისე ხდება, რომ ჩვენი ნამუშევარი არ ვარგა. ხანდახან შეიძლება
          იმედი გაგვიცრუვდეს და დავნებდეთ. მაგრამ თუ ცდას არ მოვაკლებთ და მაქსიმალურად
          დავიხარჯებით, ბოლოს - არც ისე დიდი ხნის შემდეგ, აუცილებლად გამოგვივა.
      4:
        image: notes/C1_building_foundation_4.jpg
        text: შეუპოვრობა ნიშნავს არ შეჩერდე და გააგრძელო სწორედ მაშინ, როცა ძალიან
          გინდა თავის დანებება. თუ რამე ახლისა და განსხვავებულის შექმნა გინდათ, გზადაგზა
          საკმაოდ ბევრი წარუმატებლობის გადალახვა მოგიწევთ.
      5:
        image: notes/C1_building_foundation_5.jpg
        text: მთავარია, შეუპოვარნი იყოთ - ისწავლოთ თქვენი შეცდომებით და გააგრძელოთ
          სწავლა, არ დანებდეთ იმედგაცრუების გამო! იმედგაცრუება იმის ნიშანია, რომ რაღაც
          არაჩვეულებრივს მიუახლოვდით - არ დანებდეთ, სანამ მას არ მიაღწევთ!
    C1_getting_loopy:
      1:
        image: notes/C1_getting_loopy_1.png
        text: გამარჯობა, მე ვარ მირალ კოტბი - ილუმინატის შემქმნელი. ჩემს სამუშაოში
          მე ხშირად ვიყენებ ერთ რაღაცას, როგორც ცეკვებში, ასევე სინათლის კოსტუმების
          შექმნისას.. და ეს რაღაც ციკლებია! ციკლს მოქმედების უამრავჯერ გამეორება შეუძლია.
      2:
        image: notes/C1_getting_loopy_2.png
        text: როცა რაღაცას ბევრჯერ იმეორებთ, მაგალითად, როგოც მე ვაგრძელებ ჰულა ჰუპის
          ტრიალს, ამას ეწოდება ქმედების ციკლში გატარება. ეს არის ცილი. ესეც არის ციკლი.
          და ესეც არის ციკლი.
      3:
        image: notes/C1_getting_loopy_3.png
        text: დღეს წვეულება გვექნება და ბევრს ვიცეკვებთ. ახალ ცეკვას ციკლებით, გამეორებებით,
          ავაწყობთ. ცეკვა კარგი მაგალითია ციკლების გასაცნობად. თქვენ ისწავლით რამდენიმე
          მარტივ მოძრაობას და გაიმეორებთ მათ ცეკვის დასასრულებლად.
      4:
        image: notes/C1_getting_loopy_4.png
        text: აი, ნაბიჯები, რომლებიც უნდა ისწავლოთ. შემოჰკარით ხელი ხელს. დააწყვეთ
          ხელები თავის უკან. შემოირტყით დოინჯი. აწიეთ მარცხენი ხელი. აწიეთ მარჯვენა
          ხელი. მარტივია, არა? თქვენ აღმოაჩენთ, რომ ცეკვის ზოგი მოძრაობის ციკლში ჩასმით
          მკვეთრად შეგიძლიათ ინსტრუქციის შემცირება.
      5:
        image: notes/C1_getting_loopy_5.png
        text: ციკლებს ჩვენ ცეკვისასაც კი ვიყენებთ. მოცეკვავეები ერთსა და იმავე ქსელში
          მყოფ კომპიუტერებს ატარებენ. ციკლურად შემიძლია გავაშუქო ერთი და იგივე მოცეკვავეები.
          შემიძლია ისე გავაკეთო, რომ ციკლი 6 მოცეკვავეს გაივლის უსასრულოდ და თან ყოველ
          ჯერზე სინათლის სიჩქარე გაიზრდება. ეს ყველაფერი ციკლებით კეთდება. ციკლები
          ძალიან მნიშვნელოვანია კომპიუტერულ მეცნიერებაში, იმიტომ რომ ისინი ამოკლებენ
          და ამარტივებენ ჩვენს ამოცანას.
    C1_happy_maps_unplugged:
      1:
        image: notes/C1_happy_maps_unplugged_1.png
        text: ამ გაკვეთილს ჰქვია ბედნიერი რუკები. დღეს ჩვენს ფუმფულა მეგობარს, ფლარბის,
          მისი ხილის მოპოვებაში დავეხმარებით.
      2:
        image: notes/C1_happy_maps_unplugged_2.png
        text: მიიყვანეთ ფლარბი ხილთან. ამისთვის უნდა განსაზღვროთ, რა გზით უნდა წავიდეს
          ფლარბი და ამოძრაოთ იგი ისრებით. რა მიმართულებით უნდა იაროს ფლარბიმ, რომ
          ვაშლამდე მივიდეს? მონიშნეთ სწორი გზა.
      3:
        image: notes/C1_happy_maps_unplugged_3.png
        text: მიზნამდე მისაღწევად უნდა გამოსახოთ ტრაექტორია.
      4:
        image: notes/C1_happy_maps_unplugged_4.png
        text: შექმენით თქვენი ალგორითმი - მიაკარით ისრები იმ რუკას, რომლის ამოხსნასაც
          ცდილობთ. მეორე იგივეა, მაგრამ დაბლა მიდის.
      5:
        image: notes/C1_happy_maps_unplugged_5.png
        text: ეს ჰგავს ქაღალდით პროგრამირებას. მართლაც სულ ესაა!
    C1_maze_debugging:
      1:
        image: notes/C1_maze_debugging_1.png
        text: ბაგების გამოსწორება არის პრობლემების პოვნისა და შესწორების პროცესი.
          ბაგების გამოსწორების ბევრი გზა არსებობს. ერთ-ერთი ყველაზე მარტივი მეთოდია
          უბრალოდ მიჰყვეთ კოდს ნაბიჯ-ნაბიჯ, სანამ რაღაც არასწორად არ წავა. აი, აქ
          მე ვცდილობ ძელზე უკანა სალტოს გაკეთებას, მაგრამ რაღაც არ გამომდის.
      2:
        image: notes/C1_maze_debugging_2.png
        text: მე გავიარე ყველა მოძრაობა, ნაბიჯ-ნაბიჯ და გავიგე, სად დავუშვი შეცდომა.
          საქმე იმაშია, რომ არასწორად ვდებდი ხელებს ძელზე. ამიტომ, ხელების ახალი პოზიციით
          ვცადე ნახტომის გაკეთბა და გამომივიდა! ძალიან მიხარია, რომ გამოვასწორე ჩემი
          უკანა სალტოს ბაგი.
      3:
        image: notes/C1_maze_debugging_3.png
        text: ბაგების გამოსწორების პრაქტიკისთვის მოვამზადეთ ბლოკების ნაკრები. თქვენ
          შეამჩნევთ, რომ ამ ბლოკებით მიზანს ვერ მიაღწევთ. უნდა შევამოწმოთ ჩვენი ამონახსნი
          ბაგებზე და გამოვასწოროთ ისინი. სად არის შეცდომა? ალბათ, შეამჩნევთ, რომ ერთით
          მეტი ბლოკით უნდა გადაადგილდეთ აღმოსავლეთით.
      4:
        image: notes/C1_maze_debugging_4.png
        text: ვცადოთ, გამოვასწოროთ - დაამატეთ კიდევ ერთი დასავლეთის ბლოკი და დააჭირეთ
          გაშვებას, რომ შევამოწმოთ, გამოგივიდათ, თუ არა. კი, გამოგივიდათ!
    C1_maze_intro_sequencing:
      1:
        image: notes/C1_maze_intro_sequencing_1.png
        text: ამ თავსატეხში თქვენ უნდა მიიყვანოთ ჩიტი გოჭამდე. შეხედეთ ლაბირინთს და
          მიხვდით, რა მიმართულებებით უნდა იაროს ჩიტმა.
      2:
        image: notes/C1_maze_intro_sequencing_2.png
        text: ეს ბლოკები ინსტრუმენტების პანელიდან სამუშაო სივრცეში უნდა გადმოიტანოთ.
          დარწმუნდით, რომ სხვა ბლოკები "გაშვებისას" ბლოკის ქვემოთაა მოთავსებული. როცა
          ჩათვლით, რომ სწორად დაალაგეთ ბლოკები, დააჭირეთ გაშვებას და ნახეთ, როგორ
          დაიჭერს ჩიტი გოჭს.
    C1_maze_loops:
      1:
        image: notes/C1_maze_loops_1.png
        text: კომპიუტერებს ნამდვილად ძალიან კარგად გამოსდით ბრძანებების გამეორება.
          ადამიანს მალევე სწყინდება ერთი და იმავე რამის ზედიზედ ბევრჯერ გამეორება,
          მაგრამ კომპიუტერი უპრობლემოდ გაიმეორებს ნებისმიერ რამეს მილიონჯერ ან მილიარდჯერაც
          კი.
      2:
        image: notes/C1_maze_loops_2.png
        text: მაგალითად, თუ მინდა რომ დაბადების დღე მივულოცო ყველას Facebook-ზე, შემიძლია
          გავუგზავნო მათ ელ. წერილი.. მაგრამ საუკენეზე მეტი დამჭირდებოდა იმისთვის,
          რომ ყველასთვის სათითაოდ გამეგზავნა ეს წერილები. არადა კოდის სულ რამდენიმე
          ხაზია საკმარისი, რომ ყველას Facebook-ზე გაეგზავნოს მისალოცი წერილი.
      3:
        image: notes/C1_maze_loops_3.png
        text: იმისთვის, რომ ჩიტს გოჭი დააჭერინოთ ამ დონეზე... იმის მაგივრად, რომ ჩრდილოეთის
          ბლოკები გამოდმოვიტანოთ სამუშაო სივრცეში, ჩვენ "გამეორების" ბლოკს გამოვიყენებთ.
          გადმოიტანეთ "გამეორების" ბლოკი სამუშაო სივრცეში და ჩაწერეთ რიცხვი 3. შემდეგ
          ჩასვით გამეორების ბლოკში ბლოკი "მოძრაობა ჩრდილოეთით" და გაუშვით კოდი. გილოცავთ,
          გამოგივიდათ!
    C1_moveitmoveit_unplugged:
      1:
        image: notes/C1_moveitmoveit_unplugged_1.png
        text: ამ გაკვეთილს ჰქვია "გაინძერით, გაინძერით". უნდა დავწეროთ პროგრამა, რომელიც
          ჩვენს მეგობრებს კომპასიდან ღიმილაკამდე მიიყვანს.
      2:
        image: notes/C1_moveitmoveit_unplugged_2.png
        text: მაგრამ სმაილი სახით ქვემოთ წევს და მხოლოდ ერთმა ადამიანმა იცის, როგორ
          ჩავიდეთ იქ. დავიწყოთ ეს პროგრამა.
      3:
        image: notes/C1_moveitmoveit_unplugged_3.png
        text: პროგრამა არის ალგორითმი, ჩაწერილი ისეთ რამეში, რისი გაშვებაც შეუძლია
          მანქანას. ადამიენაბის უმეტესობა პროგრამას, როგორც კომპიუტერისთვის დაწერილ
          კოდს წარმოიდგენს. პროგრამები, ცხადია, ამისთვისაც გამოდგება, მაგრამ უამრავ
          სხვა ადგილასაც შეიძლება მათი გამოყენება. შეგიძლიათ საკუთარი თამაში შექმნათ
          ან დააპროგრამოთ რობოტი.
    C1_going_places_safely:
      1:
        image: notes/C1_going_places_safely_1.png
        text: მე მქვია იერემია. გამარჯობა! შვიდი წლის ვარ. ძალიან მიყვარს დედას კომპიუტერზე
          თამაში, მაგრამ ყოველთვის ვეკითხები ნებართვას. "დე, შეიძლება კომპიუტერს მივუჯდე?
          რა თქმა უნდა, შვილო!"
      2:
        image: notes/C1_going_places_safely_2.png
        text: 'მიყვარს დედას კომპიუტერი, იმიტომ რომ ინტერნეტის გამოყენება შემიძლია.
          ინტერნეტი ძალიან ჰგავს სამეზობლოს: საინტერესო ადგილებში შეგიძლია გასვლა,
          ოჯახთან და მეგობრებთან უერთიერთობა და ბევრი ახალი რამის სწავლა.'
      3:
        image: notes/C1_going_places_safely_3.png
        text: გუშინ ჩემი სახლის მახლობლად მდებარე ზოოპარს ვეწვიე და პატარა ზებრა ვნახე.
          გადავუღე სურათი, შევუცვალე ზოლების ფერები, დავახურე თავზე ქუდი და დავუმატე
          იგი ჩემი უცნაური ცხოველების კოლექციას. მშვენიერია! მოგვიანებით შორეულ ადგილებში
          წავედი სამოგზაუროდ, კენიას ვეწვიე. იქ უამრავი ზებრაა.
      4:
        image: notes/C1_going_places_safely_4.png
        text: ხანდახან ინტერნეტში ნაცნობ ადამიანებს ველაპარაკები, მაგალითად, ბებიას,
          რომელიც სხვა შტატში ცხოვრობს. ის მიმზადებს და დაბადების დღისთვის მიგზავნის
          ორცხობილებს. ძალიან გემრიელია, ნეტა ინერნეტით სუნის გადაცემა შეიძლებოდეს!
          შემიძლია ინტერნეტში სხვადასხვა ადამიანებს ველაპარაკო, როგორც ამას ჩემი დეიდაშვილი
          აკეთებს, მაგრამ მე მხოლოდ ნაცნობებს ველაპარაკები.
      5:
        image: notes/C1_going_places_safely_5.png
        text: ინტერნეტში ყველაზე მეტად ის მომწონს, რომ მხიარული თამაშების თამაში შემიძლია.
          ქულების დაგროვება! ასვე ხატვა, ახალი რაღაცების შემქნა და მეგობრებთან მათი
          გაზიარება მიყვარს. მაგარია! ხანდახან ვეწვევი ვებსაიტებს, სადაც რამე ახალის
          სწავლა შემიძლია, მაგრამ ყოველთვის მხოლოდ ჩემ შესაფერის საიტებზე ვარ. ვაჰ,
          დინოზავრები!
      6:
        image: notes/C1_going_places_safely_6.png
        text: 'ინტერნეტი ძალიან სახალისო ადგილია. მაგრამ ონლაინ გასვლისას ისევე ფრთხილად
          უნდა იყოთ, როგორც სამეზობლოში გასვლისას. სამი წესი უნდა დაიმახსოვროთ. პირველი:
          ყოველთვის ჰკითხეთ ნებართვა მშობლებს. მეორე: მარტო იმ ადამიანებს ესაუბრეთ,
          რომელთაც იცნობთ. მესამე: ეწვიეთ თქვენთვის შესაფერის ადგილებს.'
      7:
        image: notes/C1_going_places_safely_7.png
        text: ვაჰ, როგორ ვიმხიარულეთ! ვახშამის დროა - გავდივარ ქსელიდან. მაგრამ ერთი
          სული მაქვს, ისევ როდის შემოვალ და ახალ ადგილებს ვნახავ.
    C1_pair_programming:
      1:
        image: notes/C1_pair_programming_1.png
        text: დღეს გავეცნობით წყვილში პროგრამირებას. როცა პროგრამას წყვილში წერთ,
          ერთი გუნდივით უნდა იმუშაოთ. რატომ უნდა გამოიყენოს ერთი კომპიუტერი ორმა ადამიანმა?
          იმიტომ რომ ორი თავი ერთზე უკეთესია. წყვილში პროგრამირებისას თქვენ და თქვენი
          პარტნიორი ზიხართ ერთად, ერთ კომპიუტერთან და ორივე ერთსა და იმავე პროექტზე
          მუშაობთ.
      2:
        image: notes/C1_pair_programming_2.png
        text: წყვილში პროგრამირებისას ერთი ადამიანი არის შემსრულებებლი და მეორე -
          წამყვანი. შემსრულებელი ზის კომპიუტერთან და იყენებს კლავიატურასა და მაუსს
          - აკონტროლებს კომპიუტერის ძირითად ქმედებებს. მეორე ადამიანი, წამყავანი,
          პასუხებს სცემს შემსრულებლის კითხვებს და უთითებს შესაძლო პრობლემებსა ან შეცდომებზე.
      3:
        image: notes/C1_pair_programming_3.png
        text: კომუნიკაცია წყვილში პროგრამირების წარმატების საფუძველია. არანაირი შეურაცხყოფა,
          აუცილებელია ურთიერთპატივისცემა. წამყვანი არ უნდა "უფროსობდეს". თქვენ და
          თქვენი პარტნიორი ყოველთვის უნდა ლაპარაკობდეთ. შემსრულებელი უნდა ხსნიდეს,
          რას აკეთებს, წამყვანი კი ურჩევდეს, რა გააკეთოს შემდეგ.
      4:
        image: notes/C1_pair_programming_4.png
        text: წამყვანის დანიშნულებაა მთლიანი სურათის დანახვა, შემსრულებელი კი დეტალებზე
          უნდა ფიქრობდეს. ორივე როლი მნიშვნელოვანია. წყვილში პროგრამირება ნამდვილი
          გუნდური სამუშაოა.
    C1_planting_seed:
      1:
        image: notes/C1_planting_seed_1.png
        text: ამ გაკვეთილს ჰქივია დათესვა და ის დაგვეხმარება, უკეთ გავიგოთ ალგორითმები.
          ალგორითმები იგივე კონკრეტული ინსტრუქციებია, რომლებიც გვიხსნის, რა თანმიმდევრობით
          უნდა შევასრულოთ საქმე. ისეთი ყოველდღიური საქმეებიც კი, როგორიცაა საუზმის
          ჭამა ან კბილების გახეხვა, ალგორითმებია, რომლებიც ბევრი პატარა ნაბიჯისგან
          შედგება.
      2:
        image: notes/C1_planting_seed_2.png
        text: კომპიუტერი შეიძლება იყოს ძალიან ჭკვიანი, მაგრამ ის გაგიგებთ მხოლოდ იმ
          შემთხვევაში, თუ ყველაფერს ნაბიჯ-ნაბიჯ აუხსნით. ალგორითმის შესანიშნავი თვისება
          არის ის, რომ თუ მას მიჰყვებით, შეიძლება ისეთი რამ გააკეთოთ, რისი გაკეთბაც
          ცოტა ხნის წინ არ იცოდით. ეს ძალიან ჰგავს რეცეპტის მიხედვით მომზადებას.
      3:
        image: notes/C1_planting_seed_3.png
        text: დღეს ჩვენი საკუთარი თესლი უნდა დავრგოთ - ალგორითმის გამოყენებით. შექმენით
          თქვენი საკუთარი ალგორითმი სურათების დაჭრით. აირჩიეთ სურათები, რომლებიც დარგვის
          პროცესს ასახავენ და დაალაგეთ ისინი სწორი თანმიმდევრობით.
      4:
        image: notes/C1_planting_seed_4.png
        text: ახლა კი დროა ნახოთ, მუშაობს თუ არა თქვენი ალგორითმი. ფრთხილად მიჰყევით
          ალგორითმში მოცემულ ნაბიჯებს. სწორი თანმიმდევრობითაა დალაგებული? გამოგივიდათ
          თესლის დარგვა ალგორითმის მიხედვით? ეს ძალიან ჰგავს ნახატებით პროგრამირებას!
      5:
        image: notes/C1_planting_seed_5.png
        text: როცა შოკოლადის გაკეთება გვინდა, ბევრი დიდი საქმის შესრულება გვიწევს
          ამ პროცესში. და თითოეული დიდი საქმის უკან არის უფრო პატარა საქმეების ნაკრები.
          ამის გარდა არსებობს ბევრი სხვადასხვა რეცეპტი, ანუ, ალგორითმი, რომელთაც ვირჩევთ
          იქიდან გამომდინარე, თუ როგორი გემო უნდა ჰქონდეს ჩვენს შოკოლადს. ყველა ნაბიჯი,
          ყველაზე პატარაც კი, ძალიან მნიშვნელოვანია - ერთის გარეშე ვერ შესრულდება
          დანარჩენები. ასევე ძალიან მნიშვნელოვანია ისეთი ალგორითმების შექმნა, რომელთა
          გაგებაც სხვებს მარტივად შეუძლიათ. ამიტომ, თითოეული ნაბიჯი უნდა იყოს გაწერილი
          ისეთი სიზუსტით, რომ ვინც არ უნდა აკეთებდეს შოკოლადს, შედეგი ზუსტად იგივე
          გამოუვიდეს.
    C1_playlab_storytelling:
      1:
        image: notes/C1_playlab_storytelling_1.png
        text: შემოქმედების დროა! გამოიყენეთ პროგრამირების უნარები და შექმენით ისტორია.
          თქვენს ისტორიაში იქნებიან პერსონაჟები, რომლებიც ილარაპაკებენ და ერთმანეთზე
          იმოქმედებენ. დაიწყეთ ფიქრი იმაზე, თუ როგორი ისტორიის მოყოლა გსურთ.
      2:
        image: notes/C1_playlab_storytelling_2.png
        text: კატას ყოველთვის ეშინოდა ძაღლის, მაგრამ რა მოხდება, თუ კატა მიხვდება
          - ძაღლი ცდილობს, კეთილად მოეპყროს? ყველაფერი იწყება ბლოკით "გაშვებისას".
          გადაადგილების ბლოკი გადაადგილებს თქვენს პერსონაჟს და თქმის ბლოკი ათქმევინებს
          მას იმას, რასაც ჩაწერთ.
      3:
        image: notes/C1_playlab_storytelling_3.png
        text: ეს არის ბლოკი "როცა პერსონაჟები ეჯახებიან", რომელიც შეგიძლიათ სხვა ბლოკებს
          დაუკავშიროთ.
      4:
        image: notes/C1_playlab_storytelling_4.png
        text: მინდოდა, რომ ძაღლი მოსულიყო და ეთქვა "გამარჯობა", მაგრამ კატას შეეშინდა
          და გაიქცა. აჰ, მეტი დრო რომ ყოფილიყო, ბედნეირი დასასრული გვექნება. დამთავრდა!
    C1_spelling_bee_intro:
      1:
        image: notes/C1_spelling_bee_intro_1.png
        text: 'ეს არის დამარცვლის შეჯიბრის დონე. გამოიყენეთ თავსატეხის ნაწილები და
          აამოძრავეთ ფუტკარი: მოძრაობისას ის შეკრებს სიტყვების ასაწყობად საჭირო ასოებს.'
      2:
        image: notes/C1_spelling_bee_intro_2.png
        text: ნახეთ, შეგიძლიათ თუ არა ასო-ასო დაჰყოთ ქვმოთ მოცემული სიტყვა. მაგრამ
          ფრთხილად იყავით! არასწორი მიმართულებით მოძრაობა არასასურველ ასოებს დაამატებს.
    C1_zuck_repeat_loop:
      1:
        image: notes/C1_zuck_repeat_loop_1.png
        text: კომპიუტერებს ნამდვილად ძალიან კარგად გამოსდით ბრძანებების გამეორება.
          ადამიანს მალევე სწყინდება ერთი და იმავე რამის ზედიზედ ბევრჯერ გამეორება,
          მაგრამ კომპიუტერი უპრობლემოდ გაიმეორებს ნებისმიერ რამეს მილიონჯერ ან მილიარდჯერაც
          კი.
      2:
        image: notes/C1_zuck_repeat_loop_2.png
        text: მაგალითად, თუ მინდა რომ დაბადების დღე მივულოცო ყველას Facebook-ზე, შემიძლია
          გავუგზავნო მათ ელ. წერილი.. მაგრამ საუკენეზე მეტი დამჭირდებოდა იმისთვის,
          რომ ყველასთვის სათითაოდ გამეგზავნა ეს წერილები. არადა კოდის სულ რამდენიმე
          ხაზია საკმარისი, რომ ყველას Facebook-ზე გაეგზავნოს მისალოცი წერილი.
      3:
        image: notes/C1_zuck_repeat_loop_3.png
        text: ამ მაგალითში თქვენი მიზანია გადაადგილოთ ჩიტი ისე, რომ მან დაიჭიროს გოჭი.
          ამის მარტივად გასაკეთებლად გამოვიყენოთ გამეორების ბლოკი. ანუ, ან შეგიძლიათ
          უბრძანოთ კომპიუტერს წინ გადაადგილება ხუთჯერ - ყოველ ჯერზე ჩიტი ერთი ერთეულით
          მიუახლოვდება გოჭს, ან უბრძანოთ კომპიუტერს წინ გადაადგილება ერთხელ და შემდეგ
          გაამეორებინოთ ეს მოძრაობა ხუთჯერ - შედეგი იგივე იქნება.
      4:
        image: notes/C1_zuck_repeat_loop_4.png
        text: ესე იგი, იღებთ თქვენს ბრძანებას "წინ გადაადგილება" და სვამთ მას ბლოკში
          "გამეორება". შემდეგ დაკლიკეთ ბლოკი და ჩაწერეთ, რამდენჯერ უნდა გამეორდეს
          მოქმედება, ანუ, რამდენი ნაბიჯით უნდა წავიდეს პერსონაჟი წინ.
      5:
        image: notes/C1_zuck_repeat_loop_5.png
        text: კიდევ ერთი - გამეორების ბლოკში უსასრულო რაოდენობის ბრძანებების ჩაყრა
          შეგიძლიათ. ამ მაგალითში ბლოკმა ხუთჯერ უნდა გაიმეოროს "წინ გადაადგილება"
          და "მობრუნება მარცხნივ". მშვენიერია, გაერთეთ!
    C2_artist_intro:
      1:
        image: notes/C2_artist_intro_1.png
        text: რბოლაში მონაწილეობის შანსიც კი არ გაქვთ, თუ თქვენს გუნდში გაწაფული პროგრამისტები
          არ გეყოლებათ. სწორედ მათ უნდა მოაგროვონ და გამოიყენონ ინფორმაცია და გააუმჯობესონ
          თქვენი შედეგები.
      2:
        image: notes/C2_artist_intro_2.png
        text: ამ თავსატეხებში თქვენ იქნებით მხატვარი, რომელიც ფანქრით ხატავს სხვადასხვა
          ფიგურებს. სადაც კი წახვალთ, თქვენ უკან ხაზს დატოვებთ კვალად.
      3:
        image: notes/C2_artist_intro_3.png
        text: ტილოზე გადასაადგილებლად უნდა გამოიყენოთ ბლოკი "წინ გადაადგილება". ბლოკი
          "წინ გადაადგილება" განსაზღვრულია, როგორც "გადაადგილება წინ 100 პიქსელით".
          რა მოხდება, თუ ამ კოდს გავუშვებთ? მხატვარი გადაადგილდება ჩვენს ეკრანზე ზუსტად
          100 პიქსელით. (პიქსელი უმცირესი წერტილია ეკრანზე.)
      4:
        image: notes/C2_artist_intro_4.png
        text: შემდეგი ბლოკი, რომელიც მოცემული გვაქვს ამ თავსატეხში, განსაზღვრულია,
          როგორც "90 გრადუსით მობრუნება". როცა ვიყენებთ ბლოკს "მარჯვნივ მობრუნება",
          ჩვენი პერსონაჟი ტრიალდება გაკრვეული კუთხით. თქვენ შეგიძლიათ სხვადასხვა მნიშვნელობები
          ჩაწეროთ და ნახოთ, რა მოხდება. ეს არის 90 გრადუსით მობრუნება.
      5:
        image: notes/C2_artist_intro_5.png
        text: ეს კი არის 120-გრადუსიანი მობრუნება. გახსოვდეთ, რომ ამ მნიშვნელობების
          შეცვლა შეგიძლიათ რიცხვების გვერდით ისრებზე დაჭერით. ისიამოვნეთ თქვენს მხატრავრთან
          ერთად შემოქმედებით!
    C2_bee_conditionals:
      1:
        image: notes/C2_bee_conditionals_1.png
        text: ეს არის პირობის ბლოკი. ის ამბობს, თუ კონკრეტულ რიცხვზე მეტი, ნაკლები
          ან მისი ტოლი ნექტარია, უნდა მოხდეს რაღაც.
      2:
        image: notes/C2_bee_conditionals_2.png
        text: ეს გამოსადეგია, როცა არ ვიცით რამდენი ნექტარი ან თაფლი უნდა მივიღოთ,
          ანუ, როცა ასეთი კითხვის ნიშანს ვხედავთ.
      3:
        image: notes/C2_bee_conditionals_3.png
        text: ამ მაგალითში ჩვენ ვამბობთ, თუ იასამნისფერ ყვავილში 0-ზე მეტი ნექტარია,
          მოვკრიბოთ ნექტარი. ასე ჩვენი ფუტკარი გააგრძელებს ნექტარის მოკრებას, სანამ
          იგი არ გათავდება. ესაა და ეს!
    C2_binary_bracelets:
      1:
        image: notes/C2_binary_bracelets_1.png
        text: ეს გაკვეთილი ბინარულ სამაჯურებს ეხება. ჩვენ დავშიფრავთ ჩვენს ინიციალებს
          სამაჯურზე, რომლის ტარებაც და მეგობრებისთვის ჩვენება შეგვეძლება!
      2:
        image: notes/C2_binary_bracelets_2.png
        text: 'ბინარულობა არის ინფორმაციის მხოლოდ ორი ვარიანტით წარდგენის მეთოდი.
          ხანდახან ადამიანები ფიქრობენ, რომ ეს მხოლოდ 1-იანები და 0-ებია. მაგრამ ბინარული
          სისტემა შეიძლება ააწყოთ ნებისმირი დაპირისპირებული წყვილით: ჩართულით და გამორთულით,
          დაბლით და მაღლით და ა. შ.'
      3:
        image: notes/C2_binary_bracelets_3.png
        text: სალამი, მე ვარ ორიონი და მე ვაპროგრამებ რობოტებს ფლეი-აიემში. კომპიუტერის
          და რობოტის ტვინი მის ყველაზე ბაზისურ დონეზე არის პატარა ელექტრონული კარი.
          როცა ის ღიაა, ელექტროობა გადის მასში და როცა დაკეტილია, ელექტროობა მასში
          ვერ გადის.
      4:
        image: notes/C2_binary_bracelets_4.png
        text: რობოტში ბინარულობის მაგალითი არის რობოტის თვალები. რობოტის თვალები არის
          LED ნათურები, რომლებიც ან ჩართულია, ან გამორთული. ეს არის ბინარული სისტემა
          - ან ერთი, ან მეორე. ბინარული რიცხვების წარმოსადგენად ჩვენ შეგვიძლია გამოვიყენოთ
          სინათლე. თუ რობოტების რაღაც რაოდენობა გვაქვს, შეგვიძლია ვთქვათ, რომ პირველი
          რობოტი არის 1-ლი ადგილი, მეორე რობოტი - მე-2 ადგილი, მესამე - მე-4 ადგილი
          და ა. შ. აი, ასე შეგიძლიათ ბინარული რიცხვის წარმოდგენა რობოტების ბინარული
          თვალებით.
    C2_conditionals_with_cards:
      1:
        image: notes/C2_conditionals_with_cards_1.png
        text: ამ გაკვეთილს ჰქვია პირობითი ბრძანებები კარტით. თქვენ ყოველ დღე იღებთ
          გადაწყვეტილებებს იმის მიხედვით, თუ რას ხედავთ და რა გესმით.
      2:
        image: notes/C2_conditionals_with_cards_2.png
        text: პაკრში მინდა წასვლა, მაგრამ ჯერ უნდა გადავწყვიტო, მჭრიდება თუ არა ქოლგა.
          რას ვაკეთებ? ვიყურები ფანჯრიდან. თუ ცაზე ღრუბლებია, მიმაქვს ქოლგა, თუ არა
          - სათვალე. მგონი, სჯობს ქოლგა წავიღო. ის, რასაც ვხედავ და რაც მესმის, განსაზღვრავს
          იმას, თუ რას წავიღებ პარკში.
      3:
        image: notes/C2_conditionals_with_cards_3.png
        text: პირობითი ბრძანებები თამაშებშიც გამოიყენება. დღეს ვივარჯიშებთ პირობითი
          ბრძანებების კარტის თამაშისას გამოყენებაში. ამ თამაშში, კარტი, რომელსაც მე
          ამოვიღებ, განსაზღვრავს, რას გააკეთებენ ჩემი მეგობრები. თუ ამოვიღებ შვიდიანს,
          ყველა უკრავს თაშს, თუ არა და - ყველა ამბობს "აუუუ"-ს. აბა, ვცდოთ!
      4:
        image: notes/C2_conditionals_with_cards_4.png
        text: თამაში კიდევ უფრო სახალისო შეიძლება იყოს, თუ პირობით ბრძანებებს გამოიყენებთ.
          სცადეთ! პირობითი ბრძანებების დამსახურებითაა, რომ კომპიუტერი ჭკვიანი გვგონია.
          კომპიუტერული პროგრამა, რომელიც შეიცავს პირობით ბრძანებებს რეაგირებს მომხმარებლის
          ქცევაზე და ცვლის თავის მოქმედებას.
      5:
        image: notes/C2_conditionals_with_cards_5.png
        text: იფიქრეთ თქვენს საყვარელ ვიდეო-თამაშზე. ყველა ქმედებისთვის ერთნაირ ქულას
          იღებთ, თუ ზოგისთვის უფრო მეტს? ეს ასე ხდება იმიტომ, რომ კომპიუტერი პირობით
          ბრძანებებს იყენებს გადაწყვეტილებების მისაღებად. მაგალითად, თუ მიზანს გაარტყამთ,
          აიღებს 10 ქულას. თუ ვერა - დაკარგავთ სამს. როცა იცით, როგორ მოქმედებენ პირობითი
          ბრძანებები, ნებისმიერი სახის სახალისო თამაშის შექმნა შეგიძლიათ.
    C2_artist_debugging:
      1:
        image: notes/C2_artist_debugging_1.png
        text: ჩვენს სამუშაო სივრცეში რაღაც ბლოკები უკვე გვაქვს.. მაგრამ რაღაც არასწორადაა.
      2:
        image: notes/C2_artist_debugging_2.png
        text: გამოვასწოროთ ბაგები ამ კოდში - შევანელოთ და ყურადღებით ვუყუროთ, როგორ
          გაივლის ის თითოეულ ბლოკს.
      3:
        image: notes/C2_artist_debugging_3.png
        text: ოჰ, რაღაც პრობლემა გვაქვს! კატის ულვაშის სიგრძეა 75 და არა 25 პიქსელი.
    C2_bee_debugging:
      1:
        image: notes/C2_bee_debugging_1.png
        text: გაგიგონიათ თუ არა აქამდე "პროგრამის ბაგების გამოსწორება"? ეს არის პრობლემების
          აღმოჩენისა და აღმოფხვრის გზა - კოდის ბაგების გამოსწორება.
      2:
        image: notes/C2_bee_debugging_2.png
        text: ჩვენს სამუშაო სივრცეში უკვე არის რამდენიმე ბლოკი. გამოვიყენოთ ნაბიჯის
          ღილაკი და გავიაროთ ეს ბლოკები ერთი მეორეს მიყოლებით - ვნახოთ, არის თუ არა
          ეს სწორი გადაწყვეტა და სადმე რამე ხომ არ არის შესასწორებელი.
      3:
        image: notes/C2_bee_debugging_3.png
        text: როგორც ჩანს, აი, აქ შეგვეშალა! კიდევ ერთი "წინ გადაადგილების" ბლოკი
          გვჭირდება. ნაბიჯის ღილაკი გვეხმარება ბაგების პოვნასა და გამოსწორებაში.
    C2_digital_footprint:
      1:
        image: notes/C2_digital_footprint_1.png
        text: თავი ქუდში გქონდეთ - პირადი ინფორმაცია შეინახეთ და დაიცავით საკუთარი
          პირადი სივრცე, იყავით ფრთხილად. ერთი წამით შეჩერდით და იფიქრეთ ამაზე, მოიკრიბეთ
          მთელი გონება და იფიქრეთ ონლაინ!
      2:
        image: notes/C2_digital_footprint_2.png
        text: მიენდეთ გულს და როცა ონლაინ ხართ, იყავით ყოველთვის სამართლიანები და
          კეთილები, ეცით მეგორებრებს პატივი, იმოქმედეთ სწორად. ერთი წამით შეჩერდით
          და იფიქრეთ ამაზე, მოიკრიბეთ მთელი გონება და იფიქრეთ ონლაინ!
      3:
        image: notes/C2_digital_footprint_3.png
        text: გამოიყენეთ თქვენი ხელები - ჩაეხუტეთ შინაურ ცხოველს, დაიცავით ტანსაცმელი
          დასველებისგან, ატარეთ საყვარელი ხელთათმანები, იფრინეთ. გამოიყენეთ თქვენი
          ხელები, როცა ონლაინ ხართ - შემდეგ კი აიღეთ პაუზა, დაიჭირეთ ბალანსი, შეეშვით
          ტექნოლოგიებს და წადით, ხეზე აძვერით. ერთი წამით შეჩერდით და იფიქრეთ ამაზე,
          მოიკრიბეთ მთელი გონება და იფიქრეთ ონლაინ!
      4:
        image: notes/C2_digital_footprint_4.png
        text: გამოყენეთ თქვენი კუჭი საჭმლის შესანახად და დააკვირდით ხასიათის ცვლილებას,
          დაიტყაპუნეთ მუცელზე და იგრძენით გაზიანი საცემლი. მიენდეთ ინტუიციას, როცა
          ონლაინ ხართ, მიეცით ნება წაგიძღვეთ წინს და დააკვირდეს ყველაფერს და დაუჯერეთ,
          თუ გეტყვით, რომ საქმე ცუდადაა. ერთი წამით შეჩერდით და იფიქრეთ ამაზე, მოიკრიბეთ
          მთელი გონება და იფიქრეთ ონლაინ!
      5:
        image: notes/C2_digital_footprint_5.png
        text: იფიქრეთ ტვინით, იგრძენით გულით, დაიჭირეთ ბალანსი, მიენდეთ ინტუიციას.
          იმხიარულეთ და გაერთეთ, მაგრამ გაუწიეთ წინააღმდეგობა იმათ, ვინც ხაზს კვეთს
          და უხეში ან შეურაცხმყოფელია - თქვენ კი ყოველთვის კეთილად მოექეცით დანარჩენებს.
      6:
        image: notes/C2_digital_footprint_6.png
        text: ერთი წამით შეჩერდით და იფიქრეთ ამაზე, მოიკრიბეთ მთელი გონება და იფიქრეთ
          ონლაინ! იფიქრეთ ტვინით, იგრძენით გულით, დაიჭირეთ ბალანსი, მიენდეთ ინტუიციას.
          ერთი წამით შეჩერდით და იფიქრე ამაზეთ, მოიკრიბეთ მთელი გონება და იფიქრეთ
          ონლაინ!
    C2_digital_footprint_v2:
      1:
        image: notes/C2_digital_footprint_v2_1.png
        text: ყოველჯერ, როცა ონლაინ ხართ, თქვენ ტოვებთ კვალს, რომელიც შეიძლება მოვძებნოთ,
          ასლი გავაკეთოთ, სხვებს გავუზიაროთ, გავავრცელოთ - ეს კვალი მუდმივად რჩება.
          რა ტიპის ციფრულ კვალს ტოვებთ თქვენ? და რა ტიპის კვალი გინდათ, რომ დატოვოთ?
    C2_graph_paper:
      1:
        image: notes/C2_graph_paper_1.png
        text: ამ გაკვეთილს ჰქვია "გრაფიკული პროგრამირება ქაღალდზე" და ის ალგორითმებს
          ეხება. დღეს ვისწავლით, როგორ დავწეროთ პროგრამები, რომელთა მეშვეობითაც სხვები
          შეძლებენ მარტივი შავ-თეთრი სურათების აღდგენას.
      2:
        image: notes/C2_graph_paper_2.png
        text: ალგორითმი არის დავალების შესასრულებლად საჭირო ინსტრუქციების სია. ჩვენ
          მივყვებით ინსტრუქციების ამ სიას თასის გასაკეთებლად. ალგორითმები მართლაც
          ძალიან სასარგებლოა, როცა გინდათ, რომ სხვამაც გაიგოს, როგორ უნდა გააკეთოს
          რაღაც.
      3:
        image: notes/C2_graph_paper_3.png
        text: თუ კომპიუტერისთვის წერთ ალგორითმს, იგი რამდენიმე პატარა ნაბიჯად უნდა
          დაყოთ. დაასრულეთ ეს რიგი, გადადით მეორეზე, შემდეგ მესამეზე და ეგაა.
      4:
        image: notes/C2_graph_paper_4.png
        text: ჩემს სამუშაოში მე ხშირად ვიყენებ ალგორითმებს. თუ ყველა ნაბიჯს ჩამოვწერ,
          შევძლებ ან თვითონვე გავიმეორო იგივე, ან სხვას ვასწავლო. ჩადეთ მინა ღუმელში,
          შეურიეთ, მიჰყევით ინსტრუქციის დანარჩენ ნაბიჯებს და შექმენით თასი. ალგორითმები
          იგივე რუკაზე მონიშნული გზაა, რომელიც საქმის დასრულების საშუალებას გაძლევთ.
    C2_artist_loops:
      1:
        image: notes/C2_artist_loops_1.png
        text: აქ ჩვენ გამოვიყენებთ გამეორების ბლოკს, რათა დავზოგოთ დრო ჩვენი მხატვრის
          დაპროგრამებისას. რამდენიმე ბლოკი უკვე მოცემული გვაქვს, მაგრამ ეს მხოლოდ
          დასაწყებად გვეყოფა.
      2:
        image: notes/C2_artist_loops_2.png
        text: იმისთვის, რომ ეს ბლოკები ოთხჯერ გავატაროთ ციკლში და მთლიანი კვადრატი
          დავხატოთ, გადმოვიტანოთ გამეორების ბლოკი და ჩავსვათ მასში წინ გადაადგილებისა
          და მარჯვნივ მობრუნების ბლოკები. როცა კოდს გავუშვებთ, მხატვარი ოთხჯერ გაიმეორებს
          ამ ნაბიჯებს და დაასრულებს კვადრატს.
    C2_bee_loops:
      1:
        image: notes/C2_bee_loops_1.png
        text: ციკლი არის ქმედების გამერეობა. როცა სკა უნდა გამოვიკვლიო, მე მას ვიღებ
          და მერე ვდებ უკან. იგივე მოქმედებას ბევრჯერ ვიმეორებ - სწორედ ეს არის ციკლის
          შესრულება, იგივე ქმედების ბევრჯერ გამეორება.
      2:
        image: notes/C2_bee_loops_2.png
        text: ეს არის გამეორების ბლოკი. ამ ბლოკში რაც არ უნდა ჩასვათ, იმდენჯერ გაიმეორებს,
          რამდენჯერაც ეტყვით. მაგალითად, ამ დონეზე, იმის მაგივრად, რომ "წინ გადაადგილება"
          და "ნექტარის მოპოვება" სამჯერ გადმოვიტანოთ, თითო-თითოჯერ ჩავსვამთ ამ ბლოკში
          და სამჯერ გავიმეორებთ ამ ერთობლივ ქმედებას. ასე უფრო მარტივია!
    C2_maze_intro:
      1:
        image: notes/C2_maze_intro_1.png
        text: ჩვეულებრივ, პროგრამას ტექსტით წერენ, მაგრამ დღეს ჩვენ გამოვიყენებთ ბლოკლის,
          სისტემას, რომელიც იყენებს ვიზუალურ ბლოკებს, რომელთა გადაადგილებითაც იწერება
          პროგრამა. დასაწყისისთვის, დავწერთ კოდს, რომელიც დაეხმარება ამ გაბრაზებულ
          ჩიტს გაიაროს ლაბირინთი და დაიჭიროს ბოროტი გოჭები, რომლებმაც მისი კვერცხები
          მოიპარეს.
      2:
        image: notes/C2_maze_intro_2.png
        text: ბლოკლი სამ ძირითად ნაწილადაა დაყოფილი. მარცხნივ არის ჩიტის ლაბირინთი,
          სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ლაბირინთის ქვემოთ
          არის მოცემული. შუაში არის ინსტრუმენტების პანელი და ყოველი ბლოკი არის ბრძანება,
          რომლის გაგებაც ამ ჩიტს შეუძლია. მარჯვნივ მდებარე თეთრი სივრცე არის სამუშაო
          სივრცე - სწორედ აქ აეწყობა ჩვენი პროგრამა.
      3:
        image: notes/C2_maze_intro_3.png
        text: რა მოხდება, თუ გადაადგილების ბლოკს სამუშაო სივრცეში გადმოვიტან და "გაშვებას"
          დავაჭერ? ჩიტი წინ ერთი კვადრატით გადაადგილდება. დავუშვათ, მინდა რომ ჩიტმა
          წინ გადაადგილების მერე კიდევ რამე გააკეთოს. რა ვქნა? ჩვენს პროგრამას კიდევ
          ერთი ბლოკი უნდა დავუმატო.
      4:
        image: notes/C2_maze_intro_4.png
        text: მე ავირჩევ ბლოკს "მარჯვნივ მობრუნება" და მივუმაგრებ მას ბლოკს "წინ გადაადგილება"
          - უნდა გადავიტანოთ ერთი ბლოკი მეორეს ქვემოთ და მივუახლოვოთ, სანამ არ გამოჩნდება
          ყვითელი ისარი  - მაშინ შეიძლება გავუშვათ ბლოკი და ის მიემაგრება ზემოთას.
          ახლა, როცა დავაჭერთ ღილაკს "გაშვება" ჩიტი შეასრულებს ყველა ბრძანებას, თანმიმდევრობით
          ზემოდან ქვემოთ.
      5:
        image: notes/C2_maze_intro_5.png
        text: თუ ბლოკის წაშლა დაგჭირდათ, გადაიტანეთ ის სანაგვე ყუთში. გაშვების შემდეგ
          ყოველთვის შეგიძლიათ დააჭიროთ ღილაკს "თავიდან" და ჩიტი საწყის პოზიციას დაუბრუნდება.
          ახლა კი დროა დავიჭიროთ ეს გოჭები!
    C2_paper_airplanes:
      1:
        image: notes/C2_paper_airplanes_1.png
        text: ამ გაკვეთილს ჰქვია რეალური ალგორითმები. ალგორითმები აღწერენ ქმედებებს,
          რომლებსაც ადამიანები ყოველდღე აკეთბენ. ორცხობილების რეცეპტი და ჩიტის სახლის
          აშენების ინსტრუქციები რეალური ალგორითმების მაგალითებია.
      2:
        image: notes/C2_paper_airplanes_2.png
        text: დღეს ჩვენ შევქმნით და დავტესტავთ ქაღალდის თვითმფრინავის ალგორითმს. მაგრამ
          თავიდან ეს დიდი პროექტი პატარა მარტივ ნაბიჯებად უნდა დავყოთ. ანუ, ახლა უნდა
          გადავწყვიტოთ, რა ნაბიჯები და რა თანმიმდევრობითაა საჭირო ქაღალდის თვითმფრინავის
          შესაქმნელად.
      3:
        image: notes/C2_paper_airplanes_3.png
        text: თქვენ შექმნით ალგორითმს. პირველ რიგში, უნდა გაჭრათ სურათები. შემდეგ
          აირჩიოთ ის 6 სურათი, რომელზეც ასახულია ქაღალდის თვითმფრინავის შექმნის ნაბიჯები
          და დაალაგოთ ეს სურათები სწორი თანმიმდევრობით. როცა ყველაფერი მზად იქნება,
          გაცვალეთ ალგორითმები სხვა მოსწავლესთან და გამოსცადეთ ისინი. კარგად დაწერილი
          ალგორითმი ძალიან მნიშვნელოვანია ქაღალდის საუკეთესო თვითმფრინავის ასაწყობად.
      4:
        image: notes/C2_paper_airplanes_4.png
        text: როცა შოკოლადის გაკეთება გვინდა, ბევრი დიდი საქმის შესრულება გვიწევს
          ამ პროცესში. და თითოეული საქმის უკან არის უფრო პატარა საქმეების ნაკრები.
          ამის გარდა არსებობს ბევრი სხვადასხვა რეცეპტი, ანუ, ალგორითმი, რომელთაც ვირჩევთ
          იქიდან გამომდინარე, თუ როგორი გემო უნდა ჰქონდეს ჩვენს შოკოლადს. ყველა ნაბიჯი,
          ყველაზე პატარაც კი, ძალიან მნიშვნელოვანია - ერთის გარეშე ვერ შესრულდება
          დანარჩენები. ასევე ძალიან მნიშვნელოვანია ისეთი ალგორითმების შექმნა, რომელთა
          გაგებაც სხვებს მარტივად შეუძლიათ. ამიტომ, თითოეული ნაბიჯი უნდა იყოს გაწერილი
          ისეთი სიზუსტით, რომ ვინც არ უნდა აკეთებდეს შოკოლადს, შედეგი ზუსტად იგივე
          გამოუვიდეს.
    C2_playlab_createstory:
      1:
        image: notes/C2_playlab_createastory_1.png
        text: აქამდე თქვენ ქმნიდით ანიმაციებს ან თამაშებს, რომლებიც ყოველი გაშვებისას
          ერთსა და იმავეს აკეთებდნენ. ახლა შეგეძლებათ ნამდვილი ინტერაქტიული თამაშის
          შექმნა.
      2:
        image: notes/C2_playlab_createastory_2.png
        text: 'რამდენიმე ახალი ბლოკი გვაქვს: "როცა ისარი" და "მოთამაშის გადაადგილება".
          თუ ამ ბლოკებს გააერთიანებთ, შეძლებთ ამოძრავოთ მოთამაშე ისრების გამოყენებით.
          კიდევ არის რამდენიმე ბლოკი, რომელიც საქმეში ერთვება, თუ პერსონაჟები რამეს
          ეჯახებიან ან მათ ვაჭერთ. გამოსცადეთ ეს ბლოკებიც და გაერთეთ!'
    C2_relay_programming:
      1:
        image: notes/C2_relay_programming_1.png
        text: დღეს ესტაფეტური პროგრამირების დროა. შევეხებით წნეხის ქვეშ პროგრმირებას
          და სწრაფად ან ჯგუფურად მუშაობისას დაშვებული შეცდომების გამოსწორებას. გამოვიყენებთ
          გრაფიკულ პროგრამირებას ქაღალდზე კოდის წერის წარმოსადგენად და ესტაფეტურ რბოლას
          დედლაინების წარმოსადგენად.
      2:
        image: notes/C2_relay_programming_2.png
        text: ესტაფეტურ პროგრამირებაში გუნდები ერთმანეთს გრაფიკული გამოსახულების დასრულებაში
          შეეჯიბრებიან. თქვენი თანაგუნდელის სამუშაო უნდა შეამოწმოთ, შეასწოროთ, თუ
          შეცდომას იპოვით, დაამატოთ თქვენი ისარი, გაიქცეთ უკან და შემდეგი თანაგუნდელი
          მონიშნოთ.
      3:
        image: notes/C2_relay_programming_3.png
        text: პროგრამისტები ხშირად ასწორებენ ბაგებს თავიან ალგორითმებსა ან კოდში.
          ბაგების გამოსწორების ბევრი გზა არსებობს. ერთ-ერთი ყველაზე მარტივია უბრალოდ
          მიჰყვეთ კოდს ნაბიჯ-ნაბიჯ, სანამ რაღაც არასწორად არ წავა, შემდეგ კი გამოასწოროთ
          ეს ხარვეზი.
      4:
        image: notes/C2_relay_programming_4.png
        text: მე ვცდილობ გავაკეთო უკანა სალტო, მაგრამ არ გამომდის. ნაბიჯ-ნაბიჯ უნდა
          გავიარო ყველა მოძრაობა და გავიგო, სად ვუშვებ შეცდომას. ჩემმა მწვრთნელმა
          მითხრა, რომ არასწორად ვდებდი ხელებს ძელზე. ამიტომ, ხელების ახალი პოზიციით
          ვცადე ნახტომის გაკეთბა და გამომივიდა! ძალიან მიხარია, რომ გამოვასწორე ჩემი
          უკანა სალტოს ბაგი. ბაგების გამოსწორება არის იგივე პრობლემების აღმოჩენა და
          აღმოფხვრა. ეს კარგად გამოგვივიდა!
    C2_zuck_repeat_loop:
      1:
        image: notes/C2_zuck_repeat_loop_1.png
        text: კომპიუტერებს ნამდვილად ძალიან კარგად გამოსდით ბრძანებების გამეორება.
          ადამიანს მალევე სწყინდება ერთი და იმავე რამის ზედიზედ ბევრჯერ გამეორება,
          მაგრამ კომპიუტერი უპრობლემოდ გაიმეორებს ნებისმიერ რამეს მილიონჯერ ან მილიარდჯერაც
          კი.
      2:
        image: notes/C2_zuck_repeat_loop_2.png
        text: მაგალითად, თუ მინდა რომ დაბადების დღე მივულოცო ყველას Facebook-ზე, შემიძლია
          გავუგზავნო მათ ელ. წერილი.. მაგრამ საუკენეზე მეტი დამჭირდებოდა იმისთვის,
          რომ ყველასთვის სათითაოდ გამეგზავნა ეს წერილები. არადა კოდის სულ რამდენიმე
          ხაზია საკმარისი, რომ ყველას Facebook-ზე გაეგზავნოს მისალოცი წერილი. სწორედ
          ამას აკეთებენ ციკლები - კომპიუტერს კი მათი შესრულება მარტივად შეუძლია.
      3:
        image: notes/C2_zuck_repeat_loop_3.png
        text: ამ მაგალითში თქვენი მიზანია დააჭერინოთ ჩიტს გოჭი. "გამეორების" ბლოკის
          გამოყენებით ამის გაკეთება ძალიან მარტივი იქნება. ან შეგიძლიათ ხუთჯერ მისცეთ
          კომპიუტერს "წინ გადაადგილების" ბრძანება და ყოველ ჯერ ჩიტი გოჭს ერთი ნაბიჯით
          მიუახლოვდება.
      4:
        image: notes/C2_zuck_repeat_loop_4.png
        text: ან უბრლოდ შეგიძლიათ უბრძანოთ კომპიუტერს "წინ გადაადგილება" ერთხელ და
          შემდეგ უბრძანოთ მას ამის 5-ჯერ "გამეორება" - შედეგი იგივე იქნება. ესე იგი,
          იღებთ თქვენს ბრძანებას "წინ გადაადგილება" და სვამთ მას ბლოკში "გამეორება".
          შემდეგ დაკლიკეთ ბლოკი და ჩაწერეთ, რამდენჯერ უნდა გამეორდეს მოქმედება, ანუ,
          რამდენჯერ უნდა წავიდეს პერსონაჟი წინ.
      5:
        image: notes/C2_zuck_repeat_loop_5.png
        text: კიდევ ერთი - გამეორების ბლოკში უსასრულო რაოდენობის ბრძანებების ჩაყრა
          შეგიძლიათ. ამ მაგალითში ბლოკმა ხუთჯერ უნდა გაიმეოროს "წინ გადაადგილება"
          და "მობრუნება მარცხნივ". მშვენიერია, გაერთეთ!
    C3_artist_functions:
      1:
        image: notes/C3_artist_functions_1.png
        text: პროგრამირებაში ერთ-ერთი ყველაზე კარგი ისაა, რომ როცა ერთხელ ასწავლით
          კომპიუტერს, როგორ გააკეთოს რამე, შემდეგ ამ პროცესის ფუნქციის სახით გამოძახება
          შეგიძლიათ. ერთხელ შექმნით, დაარქმევთ სახელს და მერე უბრალოდ გამოიძახებთ.
          ეს ძალიან ჰგავს ენაში ლექსიკური მარაგის გამდიდრებას.
      2:
        image: notes/C3_artist_functions_2.png
        text: პროგრამაში, რომელიც შევქმენით, ჩვენ ვისწავლეთ კვადრატის დახატვა ოთხ-ოთხჯერ
          მოძრაობითა და მობრუნებით. შეგვიძლია შევქმნათ ასეთი ფუნქცია და დავარქვათ
          მას "კვადრატის დახატვა" - ასე ნებისმიერ დროს, როცა ამის გაკეთება დაგვჭიდება,
          უბრალოდ გამოვიძახებთ ფუნქციას და ის თვითონ შეასრულებს კოდს. ასე დავუმატეთ
          პროგრამირების ჩვენს ლექსიკონს კიდევ ერთი კონცეპტი.
    C3_artist_intro:
      1:
        image: notes/C3_artist_intro_1.png
        text: რბოლაში მონაწილეობის შანსიც კი არ გაქვთ, თუ თქვენს გუნდში გაწაფული პროგრამისტები
          არ გეყოლებათ. სწორედ მათ უნდა მოაგროვონ და გამოიყენონ ინფორმაცია და გააუმჯობესონ
          თქვენი შედეგები.
      2:
        image: notes/C3_artist_intro_2.png
        text: ამ თავსატეხებში თქვენ იქნებით მხატვარი, რომელიც ფანქრით ხატავს სხვადასხვა
          ფიგურებს. სადაც კი წახვალთ, თქვენ უკან ხაზს დატოვებთ კვალად.
      3:
        image: notes/C3_artist_intro_3.png
        text: ტილოზე გადასაადგილებლად უნდა გამოიყენოთ ბლოკი "წინ გადაადგილება". ბლოკი
          "წინ გადაადგილება" განსაზღვრულია, როგორც "გადაადგილება წინ 100 პიქსელით".
          რა მოხდება, თუ ამ კოდს გავუშვებთ? მხატვარი გადაადგილდება ჩვენს ეკრანზე ზუსტად
          100 პიქსელით. (პიქსელი უმცირესი წერტილია ეკრანზე.)
      4:
        image: notes/C3_artist_intro_4.png
        text: შემდეგი ბლოკი, რომელიც მოცემული გვაქვს ამ თავსატეხში, განსაზღვრულია,
          როგორც "90 გრადუსით მობრუნება". როცა ვიყენებთ ბლოკს "მარჯვნივ მობრუნება",
          ჩვენი პერსონაჟი ტრიალდება გაკრვეული კუთხით. თქვენ შეგიძლიათ სხვადასხვა მნიშვნელობები
          ჩაწეროთ და ნახოთ, რა მოხდება. ეს არის 90 გრადუსით მობრუნება.
      5:
        image: notes/C3_artist_intro_5.png
        text: ეს კი არის 120-გრადუსიანი მობრუნება. გახსოვდეთ, რომ ამ მნიშვნელობების
          შეცვლა შეგიძლიათ რიცხვების გვერდით ისრებზე დაჭერით. ისიამოვნეთ თქვენს მხატრავრთან
          ერთად შემოქმედებით!
    C3_artist_nested_loops:
      1:
        image: notes/C3_artist_nested_loops_1.png
        text: როცა ერთ ციკლს მეორე ციკლში სვამთ, ამას ჩასმული ციკლი ეწოდება. მაგალითად,
          აქ მოცემული გვაქვს კოდი, რომლითაც შეგვიძლია დავხატოთ საკმუთხედი გვერდით
          100 პიქსელი - გამოეყენებულია გამეორების ბლოკი, სამი გამეორებით - თითო გამეორება
          თითო გვერდისთვის.
      2:
        image: notes/C3_artist_nested_loops_2.png
        text: მაგრამ ჩვენ ექვსი სამკუთხედის დახატვა გვინდა. ამის გასაკეთებლად ავიღოთ
          ეს ციკლი და ჩავსვათ "გამეორების" ბლოკში. მაგარია!
    C3_bee_conditionals:
      1:
        image: notes/C3_bee_conditionals_1.png
        text: ეს არის პირობის ბლოკი. ის ამბობს, თუ კონკრეტულ რიცხვზე მეტი, ნაკლები
          ან მისი ტოლი ნექტარია, უნდა მოხდეს რაღაც.
      2:
        image: notes/C3_bee_conditionals_2.png
        text: ეს გამოსადეგია, როცა არ ვიცით რამდენი ნექტარი ან თაფლი უნდა მივიღოთ,
          ანუ, როცა ასეთი კითხვის ნიშანს ვხედავთ.
      3:
        image: notes/C3_bee_conditionals_3.png
        text: ამ მაგალითში ჩვენ ვამბობთ, თუ იასამნისფერ ყვავილში 0-ზე მეტი ნექტარია,
          მოვკრიბოთ ნექტარი. ასე ჩვენი ფუტკარი გააგრძელებს ნექტარის მოკრებას, სანამ
          იგი არ გათავდება. ესაა და ეს!
    C3_bee_debugging:
      1:
        image: notes/C3_debugging_bee_1.png
        text: გაგიგონიათ თუ არა აქამდე "პროგრამის ბაგების გამოსწორება"? ეს არის პრობლემების
          აღმოჩენისა და აღმოფხვრის გზა - კოდის ბაგების გამოსწორება.
      2:
        image: notes/C3_debugging_bee_2.png
        text: ჩვენს სამუშაო სივრცეში უკვე არის რამდენიმე ბლოკი. გამოვიყენოთ ნაბიჯის
          ღილაკი და გავიაროთ ეს ბლოკები ერთი მეორეს მიყოლებით - ვნახოთ, არის თუ არა
          ეს სწორი გადაწყვეტა და სადმე რამე ხომ არ არის შესასწორებელი.
      3:
        image: notes/C3_debugging_bee_3.png
        text: როგორც ჩანს, აი, აქ შეგვეშალა! კიდევ ერთი "წინ გადაადგილების" ბლოკი
          გვჭირდება. ნაბიჯის ღილაკი გვეხმარება ბაგების პოვნასა და გამოსწორებაში.
    C3_bee_functions:
      1:
        image: notes/C3_bee_functions_1.png
        text: ახალი ბრძანებების განსაზღვრა პროგრამირების ძალიან მნიშვნელოვანი ნაწილია
          - ეს კომპიუტერისთვის ახალი, თქვენი საკუთარი სიტყვების სწავლებაა. პროგრამირების
          ენების უმეტესობას სულ 100 სიტყვა ან ბრძანება აქვს. ამ ერთეულების გამოყენებით
          ახალი ბრძანებების შექმნა ნამდვილი ხელოვნებაა.
      2:
        image: notes/C3_bee_functions_2.png
        text: ასე იწყება სპორტის სწავლაც - მაგალითად, კალათბურთში ჯერ ვსწავლობთ ბურთის
          ტარებას და კალათიდან ასხლეტილი ბურთის დაჭერას. როცა ელემენტარულ მოძრაობებს
          ვისწავლით, შემდეგ შეგვიძლია ახალი მოძრაობების სწავლა, მაგალითად ბურთის გადაცემის.
          შემდეგ უფრთო რთული მოძრაობების შექმნა შეგიძლიათ. როცა მათ ისწავლით და სახელს
          დაარქმევთ, გუნდში ყველას ეცოდინება, როგორ შეასრულონ ისინი.
      3:
        image: notes/C3_bee_functions_3.png
        text: ზუსტად ასევე, როცა ერთხელ განუმარტავთ კომპიუტერს, როგორ უნდა შეასრულოს
          მოქმედებების რიგი, შეგიძლიათ ამ ერთიან მოქმედებას რამე სახელი დაარქვათ -
          ასე მისი გამეორება მომავალში უფრო მარტივი იქნება. ამას ფუნქციის შექმნა ეწოდება.
          ახლა კი უნდა გამოვიყენოთ ფუნქციები და დავეხმაროთ ფუტკარს.
      4:
        image: notes/C3_bee_functions_4.png
        text: 'ამ მაგალითში ჩვენს ფუნქციას, აი, ამ მწვანე ბლოკს ჰქვიაა "2 ნექტარის
          მოპოვება". ის თუ, რას აკეთებს "2 ნექტარის მოპოვება", მოცემულია ამ ნაცრისფერ
          ბლოკში, ფუნქციის განსაზღვრებაში. შევიხედოთ: "2 ნექტარის მოპოვება" აიღებს
          ერთ ნექტარს და შემდეგ კიდევ ერთ ნექტარს. ყოველთვის ნახეთ, რა არის მოცემული
          ნაცრისფერ ბლოკში და გაიგებთ, რას აკეთებს ფუნქცია.'
    C3_bee_nested_loops:
      1:
        image: notes/C3_bee_nested_loops_1.png
        text: 'ახლა ჩასმულ ციკლებს ფუტკართან გამოვიყენებთ. მოცემული გვაქვს კოდი: "წინ
          გადაადგილება" და "ნექტარის მოპოვება" სამჯერ და შემდეგ "მარჯვნივ მოხვევა".
          ავიღოთ ეს მთლიანი კოდი და ჩავსვათ გამეორების სხვა ბლოკში, მივუთითოთ, რომ
          გამეორდეს სამჯერ. მზადაა!'
    C3_bounce:
      1:
        image: notes/C3_bounce_1.png
        text: თქვენ შექმნით ასხლეტის თქვენს საკუთარ თამაშს და შეგეძლებათ მისი მეგობრებისთვის
          გაზიარება. მაგარია!
      2:
        image: notes/C3_bounce_2.png
        text: დავიწყოთ ნიჩბის კონტროლის კლავიატურის ისრებზე გადაბმით.
      3:
        image: notes/C3_bounce_3.png
        text: ამის გაკეთება შეგვიძლია "როცა მარცხენა ისრისა" და "მარცხნივ გადაადგილების"
          ბლოკების შეერთებით, ასევე "როცა მარჯვენა ისრის" ბლოკისა და "მარჯვნივ გადაადგილების"
          ბლოკის შეერთებით. სცადეთ და ცოტა ხანში ასხლეტის თქვენს საკუთრ თამაშს დაწერთ!
    C3_computational_thinking:
      1:
        image: notes/C3_computational_thinking_1.png
        text: ეს გაკვეთილი გამოთვლით აზროვნებაზეა. ხანდახან ახალი თამაშის სწავლა რთულია,
          არა? ერთი შეხედვით დამაბნეველი შეიძლება იყოს და თანაც გვერდით არავინ გყავდეთ,
          რომ გასწავლოთ მისი წესები - ასეთ შემთხვევაში, თქვენით გიწევთ ყველაფრის გარკვევა.
      2:
        image: notes/C3_computational_thinking_2.png
        text: კარგი ამბავი კი ისაა, რომ როცა მსჯელობის რამდენიმე ხრიკს გაეცნობით,
          უფრო მარტივად შეძლებთ გადაწყვეტილებების დამოუკიდებლად მიღებას. ამ გაკვეთილში
          4 ხრიკს ისწავლით და მეგობრებთან ერთად ივარჯიშებთ ამ ხრიკების მეშვეობით თამაშის
          წესების გამოცნობაში.
      3:
        image: notes/C3_computational_thinking_3.png
        text: როცა დიდ ამოცანას პატარა ნაბიჯებად ჰყოფთ, თქვენი ტვინი ამოცანის ნაწილების
          გამოყოფას სწავლობს. როცა ამ პროცესს მოვრჩებით, მეორე ხრიკის გამოყენების
          დრო დგება - კანონზომიერებების პოვნის.
      4:
        image: notes/C3_computational_thinking_4.png
        text: ასე ხდება, როცა საგნებს შორის მსგავსებებს ვეძებთ. როცა ვნახავ, რა არის
          მსგავსი, შემდეგ მარტივად განვსაზღვრავ, რა არის განსხვავებული. ამ სხვაობების
          მოშორებას კი აბსტრაგირება ჰქვია.
      5:
        image: notes/C3_computational_thinking_5.png
        text: მას მერე რაც ამოცანის ამოსახსნელად საჭირო ნაბიჯებს განვსაზღვრავ, შემიძლია
          დავალაგო ისინი კონკრეტული თანმიმდევრობით - ამას ალგორითმი ეწოდება. ასე ნებისმიერს
          შეეძლება უბრალოდ მიჰყვეს ჩემს მითითებებებს და ამოხსნას ამოცანა. ამ ოთხ ნაბიჯს
          გამოვიყენებთ იმისთვის, რომ განვსაზღვროთ, როგორ ვითამაშოთ თამაში წესების
          გარეშე. ბოლოს მსგავსი თამაშების გავლას მარტივად შეძლებთ!
    C3_crowdsourcing:
      1:
        image: notes/C3_crowdsourcing_1.png
        text: ამ გაკვეთილს ჰქვია ქრაუდსორსინგი. ჩვენ გამოვიყენებთ კარტების დასტას
          და ვისწვლით, რამდენად უფრო მარტივია რაღაცების ჯგუფურად და არა დამოუკიდებლად
          გაკეთება. ასე რომ, მოიწვიეთ მეგობრები, რაღაც საინტერესო უნდა გავაკეთოთ.
          ქრაუდსორსინგი არის ადამინების დიდი ჯგუფისგან დახმარების მიღება და რაღაც
          საქმის უფრო მალე დასრულება.
      2:
        image: notes/C3_crowdsourcing_2.png
        text: 'კომპიუტერულ მეცნიერებაში ქრაუდსორსინგს განუწყვეტლივ ვიყენებთ. ათასობით
          დამწყები და პროფესიონალი აერთიანებს ძალებს ინფორამციის ძიებაში: იქნება ეს
          ახალი მერსენის რიცხვი თუ უცხოპლანეტელებთან ურთიერთობა.'
      3:
        image: notes/C3_crowdsourcing_3.png
        text: ფილმის ყოველი წამი 24 ცალკეულ სურათს შეიცავს - ჩვენ მათ კადრებს ვეძახით.
          თითეული სურათი უნდა შევქმნათ, დავარენდეროთ და მერე ყველა შევკრათ. მე და
          ჩემი გუნდი დეველოპერები ვართ. ჩვენ ვქმნით პროგრამას, რომელიც შექმნის საბოლოო
          სურათს, იმას, რასაც თქვენ ეკრანზე უყურებთ. ეს არის ინსტრუმენტი, რომლის გამოყენებაც
          შეუძლიათ ხელოვანებსა და სხვა დეველოპერებს იდეალური სურათის მისაღებად.
      4:
        image: notes/C3_crowdsourcing_4.png
        text: მაგალითად, მულტფილმში "ვიპოვოთ ნემო", როცა ქრაში, სქვირთი და მათი მეგობრები
          აღმოსავლეთ ავსტრალიურ დინებას მიუყვებიან, თქვენ ხედავთ მდინარე წყალს, კუს
          ბაკანის ფერებს, თევზის გვერდებს. ეს ყველაფერი შექმნილია მათემატიკითა და
          ჩვენ მიერ დაწერილი კომპიუტერული პროგრამებით, რომლებითაც ხელოვანები შემდეგ
          ამ მშვენიერ და სახალისო კარდებს ქმნიან.
    C3_dice_race:
      1:
        image: notes/C3_dice_race_1.png
        text: ამ გაკვეთილს ჰქვია კამათლების რბოლა. თითქმის ყველას მოსწონს კომპიუტერული
          თამაშები. გიფიქრიათ იმაზე, როგორ გარდაქმნიან პროგრამისტები თამაშის ნაბიჯებს
          პროგრამად? პირველი ნაბიჯი, რომელიც საჭიროა, როგორც კომპიუტერული პროგრამის
          შექმნისას, ასევე ნებისმიერი პრობლემბის გადაწყეტისას, არის ფიქრი და გეგმა.
      2:
        image: notes/C3_dice_race_2.png
        text: 'ამოცანის ამოხსნის მნიშვნელოვანი ნაწილია ალგორითმის შემქნა: გეგმის,
          რომელიც ნაბიჯ-ნაბიჯ ხსნის პრობლემას ან ასრულებს დავალებას. ამ გაკვეთილში
          თქვენ შექმნით ალგორითმს კამათლის გაგორების თამაშისთვის. შემდეგ უნდა თხოვოთ
          მეგობრებს, გამოსცადონ თქვენი გეგმა და ნახოთ, თუ შეძლებენ თამაშს თქვენ მიერ
          გაწერილი ნაბიჯების მიხედვით. როცა პროგრამისტი დარწმუნებულია, რომ ალგორითმი
          სწორია, დროა "თარგმნოს" ის პროგრამად: ენაზე, რომელსაც კომპიუტერი გაიგებს.'
      3:
        image: notes/C3_dice_race_3.png
        text: თითქმის ყველაფერი, რასაც ყოველდღე ვაკეთებთ, მოითხოვს ალგორითმს - დავალების
          შესასრულებლად საჭირო ნაბიჯების სიას. გაიხსენეთ, როგორ ემზადებით სკოლაში
          წასასვლელად ან გეგმავთ მეგობრებთან ერთად სახალისო დღის გატარებას. ამ საქმეებიდან
          ნებისმიერის შესასრულებლად საჭიროა მისი პატარ-პატარა ნაბიჯებად დაყოფა, ხანდახან
          კი ნაბიჯები კონკრეტული თანმიმდევრობით უნდა შესრულდეს.
      4:
        image: notes/C3_dice_race_4.png
        text: იფიქრეთ, როგორ კეთდება სენდვიჩი. მნიშვნელობა არ აქვს, რა თანმიმდევრობით
          ამოალაგებთ ინგრედიენტებს, მაგრამ არაქისის კარაქის ჯამის გახსნამდე კარაქს
          ვერ გამოიყენებთ. შეიძლება ეს თქვენთვის ძალიან მარტივია და დაუფიქრებლად აკეთბთ
          ხოლმე ამას, მაგრამ კომპიუტერს ამოცანის შესრულებისთვის ზედმიწევნით ზუსტი
          ალგორითმი სჭირდება.
      5:
        image: notes/C3_dice_race_5.png
        text: პროგრამა არის კომპიუტერისთვის მიცემული რეალური ინსტრუქცია, ალგორითმი
          კი ისაა, რაც მის უკან დგას. სანამ კომპიუტერი შეძლებს ალგორითმის გაშვებას,
          ეს უკანასკნელი პროგრამად უნდა ჩაიწეროს. დავალების ნაბიჯებად გაწერა, ანუ
          ალგორითმის შექმნა, ხანდახან შეიძლება რთული იყოს. მაგრამ ისევე, როგორც ნებისმიერი
          ახალი უნარის შემთხვევაში, საჭიროა ცოტაოდენი პრაქტიკა და ყველაფერი გაცილებით
          მარტივი იქნება.
    C3_farmer_while:
      1:
        image: notes/C3_farmer_while_1.png
        text: '"სანამ" ციკლები ძალიან ჰგავს იმას, რასაც ყოველდღიურ ცხოვრებაში აკეთებთ.
          წარმოიდგინეთ, რომ მანქანას რეცხავთ - თქვენ წმენდთ მას, სანამ არ გასუფთავდება.
          სანამ ის გასუფთავებული არ არის, წმენდთ.'
      2:
        image: notes/C3_farmer_while_2.png
        text: თქვენი ფერმერის დასახმარებლად ახალი ციკლი გვაქვს. მას ჰქვია "სანამ"
          ბლოკი - ძალიან მარტივი რამეა. სანამ დებულება ჭეშმარიტია, შეასრულეთ რაღაც.
          მაგალითად, სანამ ზვინი ჯერ კიდევ არის, მოაშორეთ ერთი პორცია თივა. მიდით,
          გამოსცადეთ ეს ბლოკი თქვენს ფერმერთან ერთად.
    C3_functional_suncatchers:
      1:
        image: notes/C3_functional_suncatchers_1.png
        text: ამ გაკვეთილს ჰქვია "ფუნქციური სანქეჩერები". თქვენ შექნით ამ მშვენიერ
          სანქეჩერებს ფუნქციების გამოყენებით. სანქეჩერის შესაქმნელად სხვადასხვა ნაბიჯების
          გავლა დაგჭირდებათ, მათგან ზოგის კი ბევრჯერ გამეორება მოგიწევთ.
      2:
        image: notes/C3_functional_suncatchers_2.png
        text: სანქეჩერის შექმნის პროცესი გამარტივება იწყება გამეორებადი ქმედებების
          გამოყოფით. ამ ქმედებების ფუნქციებად გაერთიანება შეგივიძლია.
      3:
        image: notes/C3_functional_suncatchers_3.png
        text: მაგრამ ლამაზი სანქეჩერის შექმნა უფრო საინტერესო შეიძლება იყოს, ვიდრე
          უბრალოდ ნაბიჯების ზუსტი შესრულება. შეიძლება, სხვადასხვა ფერის მძივის გაკეთბა
          გვინდა - ასე თუ ვიზამთ, ყველა სანქეჩერი უნიკალური გამოვა.
      4:
        image: notes/C3_functional_suncatchers_4.png
        text: თქვენი სანქეჩერი შეიძლება იყოს უნიკალური, თუ მძივებზე იფიქრებთ ისე,
          როგორც ცვლადებზე - ცვალებადი ინფორმაციის ჩამნაცვლებელზე. იმხიარულეთ ფუნქციებითა
          და ცვლადებით ლამაზი სანქეჩერების შექმნისას!
    C3_internet:
      1:
        image: notes/C3_internet_1.png
        text: ეს გაკვეთილი ინტერნეტს ეხება. ინტერნეტი ძალიან ჰგავს დატვირთულ ტრასას.
          შეტყობინებები, მანქანების მსგავსად, თავიანთი დანიშნულების ადგილებისკენ მიისწრაფიან,
          ოღონ შეტყობინებები ინტერნეტში გაცილებით სწრაფად მოძრაობენ.
      2:
        image: notes/C3_internet_2.png
        text: იმის განსაზღვრა, თუ როგორ მუშაობს ინტერნეტი დაგეხმარებათ გაარკვიოთ,
          რა ხდება, როცა მას იყენებთ. თქვენ ისწავლით, როგორ იგზავნება შეტყობინებები
          თქვენი კომპიუტერიდან საყვარელ ვებ-საიტზე, ან როგორ მოგდით მეგობრის შეტყობინებები
          თქვენს ელ. ფოსტზე. როცა გზა და საგზაო ნიშნები იცით, მგზავრობა უფრო მარტივია
          - ასევა ინტერნეტის შემთხვევაშიც. როცა იცით, რა ხდება ეკრანის მიღმა, უფრო
          მარტივად ხვდებით, როგორ უნდა იმოქმედოთ.
      3:
        image: notes/C3_internet_3.png
        text: შეტყობინებების ინტერნეტით გაგზავნა მათი ფოსტით გაგზავნას ჰგავს - რამდენიმე
          სხვაობის გამოკლებით. ახლა ვარ საიტზე Google.com - მისი IP მისამართი არის
          ეს რიცხვი. IP მისამართი არის იგივე ადრესანტის მისამართი. წარმოვიდგინოთ,
          რომ მინდა წერილი გავუგზავნო ვინმეს დაბლა ოფისში. ხედავთ URL და IP მისამართს
          ამ კარზე? მე დავწერე ეს შეტყობინება და დავაჭირე გაგზავნას.
      4:
        image: notes/C3_internet_4.png
        text: ფოსტისგან განსხვავებით, ინტერნეტი შეტყობინებას უფრო პატარა ნაწილებად
          ჰყოფს - ასე მისი გაგზავნა უფრო მარტივი ხდება. ამ პატარა ნაწილებს ეწოდება
          პაკეტები. შეტყობინების პაკეტები დანიშნულების ადგილას იგზავნება თითო-თითო
          და, რა თქმა უნდა, სწორი თანმიმდევრობით, რომ მიმღებმა შეძლოს შეტყობინების
          სწორად წაკითხვა. ცხადია, ინტერნეტის შესახებ კიდევ ძალიან ბევრი რამის სწავლა
          შეგიძლიათ, მაგრამ ესეც კარგი დასაწყისია. მალე ინტერნეტის პროგრესული მომხმარებელი
          გახდებით - მთავარია, არ დაგავიწყდეთ, მოუყვეთ თქვენს ოჯახსა და მეგობრებს
          ყველაფერი, რასაც ისწავლით!
      5:
        image: notes/C3_internet_5.png
        text: 'მე მქვია ამანდა კემპი და მე ვარ პროგრამული უზრუნველყოფის ინჟინერი გუგლში.
          მე ვმუშაობ ჯგუფში, რომელის მთავარი საქმეა სერვერი, რომელშიც ინახება ანგარიშები
          და კონტაქტები. მაგალითად, ჩვენ ვფქირობთ იმაზე, როგორ შეიძლება გავუგზავნოთ
          კონტაქტები სხვა მოწყობილობას, მაგალითად, თქვენს ტელეფონს. ადამიანების უმეტესობას
          ბევრი კონტაქტი ჰყავს, 1000 მაინც. ერთიანად კი 1000-ის გაგზავნა არ გვინდა,
          იმიტომ რომ ეს ძალიან დიდი მოცულობაა. ისევე, როგორც ინტერნეტი დიდ შეტყობინებებს
          რამდენიმე ნაწილად ჰყოფს, ჩვენც ვიყენებთ კონცეპტს, რომელსაც ჰქვია ფეიჯინგი:
          ვაგზავნით მხოლოდ 100 კონტაქტს, მერე კი თქვენი ტელეფონი გვიკავშირდება და
          მოითხოვს შემდეგ 100-ს.'
      6:
        image: notes/C3_internet_6.png
        text: პროგრამული უზრუნველყოფის ყველაზე საინტერესო და ამაღელვებელი თვისება
          ისაა, რომ მას შეუძლია გავლენის მოხდება მთელ მსოფლიოზე. პროგრმირება ვისწავლე
          როცა 19 წლის ვიყავი, მეორე თუ მესამე კურსზე უნივერსიტეტში. პირველი პროგრამა,
          რომელიც დავწერე უბრალოდ აკონვერტებდა ცელსიუსს ფარენჰეითში. მე მომწონს პროგრამირება,
          იმიტომ რომ მომწონს ადამიანების დახმარება. გუგლში ვწერ პროგრამებს, რომლებიც
          ეხმარება ადამიანებს მთელს მსოფლიოში - და ეს ჩემთვის ძალიან დიდი სტიმულია.
    C3_maze_conditionals:
      1:
        image: notes/C3_maze_conditionals_1.png
        text: 'ადამიანები ყოველდღე იღებენ გადაწყვეტილებებს. მაგალითად, სანამ გარეთ
          გახვალთ, თქვენ განიხილავთ "თუ" დებულებას: თუ გარეთ წვიმს, უნდა ავიღო პალტო.
          კომპიუტერები საოცრად კარგად უმკლავდებიან მსგავს დებულებებს და დაუჯერებელი
          სიჩქარით ასრულებენ მათ. პრინციპში, კომპიუტერული პროგრამა არის ცოტაოდენი
          მათემატიკა და "თუ" დებულებები - როცა გადაწყვეტილებაა მისაღები.'
      2:
        image: notes/C3_maze_conditionals_2.png
        text: '"თუ" ბლოკი ეხამრება ზომბის გადაწყვეტილების მიღებისას. ის რაღაცას ამოწმებს.
          მაგალითად, ავიღოთ ბლოკი, რომელიც გვეკითხება, არის თუ არა მარცხნივ მოსახვევი
          და ასევე შეიცავს მარცხნივ მოხვევის ბრძანებას. ამ ბლოკის გამოყენებით ჩვენ
          ვეუბნებით ზომბის: "დაზევერე შემოგარენი და თუ აღმოაჩენ მარცხნივ შესახვევს,
          მოუხვიე".'
      3:
        image: notes/C3_maze_conditionals_3.png
        text: შემდეგ ჩვენ გამოვიყენებთ ბლოკს "წინ გადაადგილება" - ჩავსვამთ მას გამეორების
          ბლოკში, რომ პერსონაჟმა გააგრძელოს წინ სვლა. თუ სადმე მოსახვევი შეგვხვდება,
          "თუ" ბლოკი დაგვეხმარება მარცხნივ მობრუნებაში. როგორც ხედავთ, თუ ამას გავაკეთებთ,
          ანუ, თუ საჭიროების შემთხვევაში მოვუხვევთ მარცხნივ, ისე კი სულ წინ ვივლით,
          აუცილებლად მივაღწევთ მიზანს.
      4:
        image: notes/C3_maze_conditionals_4.png
        text: 'ეს არის "თუ" დებულების გამოყენების მაგალითი - პროგრამირების ერთ-ერთი
          ფუნდამენტური კონცეპტის. ერთ-ერთი პირველი თამაში, რაც დავწერე იყო Tic-Tac-Toe,
          რომელიც შეიცავდა შემდეგ დებულებას: "თუ სხვა მოთამაშე იგებს, დაბლოკე კვადრატი,
          რომლითაც შეუძლია მოგება". იხალისეთ და ისწავლეთ "თუ" დებულებების გამოყენება,
          ეს დებულება საკვანძოა.'
    C3_maze_level_4:
      1:
        image: notes/C3_maze_level_4_1.png
        text: ამ მაგალითში თქვენი მიზანია ზობმი მზესუმზირამდე მიიყვანოთ. შეგვიძლია
          გამოვყენოთ ხუთი ბლოკი "წინ გადაადგილება" ან გამოვიყენოთ გამეორების ბლოკი
          და ვუთხრათ კომპიუტერს ხუთჯერ გაიმეოროს "წინ გადაადგილება".
      2:
        image: notes/C3_maze_level_4_2.png
        text: ეს არა მხოლოდ დროს გვიზოგავს, მაგრამ ზოგადადაც ამარტივებს ამოცანას.
          ჩავსვათ ბლოკი "წინ გადაადგილება" გამეორების ბლოკში. დავაჭიროთ გაშვებას და
          ზომბი გადაადგილდება წინ, გემრიელი მზესუმზირისკენ, ხუთჯერ.
    C3_playlab_create_game:
      1:
        image: notes/playlab_1.png
        text: აქამდე თქვენ ქმნიდით ანიმაციებს ან თამაშებს, რომლებიც ყოველი გაშვებისას
          ერთსა და იმავეს აკეთებდნენ. ახლა შეგეძლებათ ნამდვილი ინტერაქტიული თამაშის
          შექმნა.
      2:
        image: notes/playlab_2.png
        text: 'რამდენიმე ახალი ბლოკი გვაქვს: "როცა ისარი" და "მოთამაშის გადაადგილება".
          თუ ამ ბლოკებს გააერთიანებთ, შეძლებთ ამოძრავოთ მოთამაშე ისრების გამოყენებით.
          კიდევ არის რამდენიმე ბლოკი, რომელიც საქმეში ერთვება, თუ პერსონაჟები რამეს
          ეჯახებიან ან მათ ვაჭერთ. გამოსცადეთ ეს ბლოკებიც და გაერთეთ!'
    C3_songwriting_with_parameters:
      1:
        image: notes/C3_songwriting_with_parameters_1.png
        text: ეს გაკვეთილი სიმღერის დაწერას ეძღვნება. მუსიკა ძალიან ჰგავს კომპიუტერულ
          პროგრამას. ნოტები და სიტყვები ზუსტად მიუთითებენ მომღერალს, თუ რა უნდა გააკეთოს.
          მუსიკის რაღაც ნაწილი განმეორებით გამოიყენება.
      2:
        image: notes/C3_songwriting_with_parameters_2.png
        text: ეს არის მისამღერი. კომპიუტერულ პროგრამაში კი იმ ნაწილებს, რომელთაც კვლავ
          და კვლავ ვიყენებთ, ფუნქციები ჰქვია. როცა სიმღერის ტექსტს კითხულობთ და გხვდებათ
          სიტყვა "მისამღერი", მას ხომ არ კითხულობთ? რა თქმა უნდა, არა - თქვენ იყურებით
          ზემოთ, იქ, სადაც მოცემულია მისამღერის ტექსტი და კითხულობ მას.
      3:
        image: notes/C3_songwriting_with_parameters_3.png
        text: ამ გაკვეთილში თქვენ ისწავლით მოკლე სულელურ სიმღერას, რომელსაც ჰქვია
          ბანი ფუ-ფუ (bunny foo-foo). ამ სიმღერას აქვს მისამღერი, რომელიც რამდენჯერმე
          უნდა გამეორდეს. ფუნქცია არის კოდი, რომლის კვლავ და კვლავ გამოძახებაც შეგიძლიათ.
          ის პროგრამირებას ამარტივებს და თქვენ აღარ გიწევთ ფუნქციის ნაბიჯების თავიდან
          ჩამოწერა - ერთხელ დაწერთ და საკმარისია!
    C4_bee_conditional:
      1:
        image: notes/C4_bee_conditional_1.png
        text: 'ეს არის პირობის შემცველი ბლოკი. ის გვეუბნება: თუ ყვავილთან ან სკასთან
          ხართ, გააკეთეთ რაღაც. ეს ფუნქცია გამოსადეგია, როცა არ ვიცით, რამდენი თაფლი
          გავაკეთოთ ან ნექტარი ავიღოთ - მაგალითად, როცა ასეთ კითხვის ნიშანს ვხედავთ.'
      2:
        image: notes/C4_bee_conditional_2.png
        text: 'ამ მაგალითში ჩვენ ვამბობთ: თუ ეს ყვავილია, ავიღოთ მთელი ნექტარი და
          თუ ეს სკაა, გავაკეთოთ თაფლი. ესაა და ეს!'
    C4_conditionals:
      1:
        image: notes/C4_conditionals_1.png
        text: გვაქვს ახალი ბლოკი "თუ/სხვაგვარად". ეს ბლოკიც ისეთივე პირობითი დებულებაა,
          როგორც "თუ" ბლოკი, რომელიც წინა თავსატეხებში გამოიყენეთ. მაგრამ ახლა მას
          აქვს კიდევ ერთი ნაწილი, რომელიც ამბობს "სხვაგვარად". "თუ/სხვაგვარად" ბლოკი
          აძლევს კომპიუტერს საშუალებას აირჩიოს ქმედებების ორ ნაკრებს შორის. თუ ფუტკარი
          ყვავილთანაა, ის ქმედებების პირველ ნაკრებს შეასრულებს და თუ არა, მაშინ ქმედებების
          მეორე ნაკრებს შეასრულებს, იმას, რომელიც "სხვაგვარად" სლოტშია მითითებული.
      2:
        image: notes/C4_conditionals_2.png
        text: '"თუ" დებულებები აძლევს კომპიუტერს გადაწყვეტილების მიღების საშუალებას.
          ადამიანი ატყობინებს კომპიუტერს პირობებს: იმ შემთხვევაში, თუ განხორციელდა
          გარკვეული სიტუაცია, გააკეთე ასე. სხვა შემთხვევაში, გააკეთე ისე. ჩვენი "თუ/სხვაგვარად"
          ბლოკის სათაური ამბობს "თუ ყვავილთან". შეიძლება სხვა პირობაც ყოფილიყო, მაგალითად,
          "თუ ნექტარი უდრის 2-ს", ან "თუ წინ არის გზა" - ჩვენი ბლოკი მაინც იგივენაირად
          მოიქცეოდა. თუ მოცემული დებულება ჭეშმრიტია, ბლოკი ქმედებების ერთ ჯგუფს განახორციელბს,
          თუ კი მცდარია - ქმედებების მეორე ჯგუფს.'
    C4_for_loops:
      1:
        image: notes/C4_for_loops_1.png
        text: როცა გამეორების ბლოკს თქვენი კოდის ციკლურად გასაშვებად იყენებთ, როგორ
          უნდა მიხვდეს კომპიუტერი, რომ საკმარისად გაიმეორა რაღაც ქმედება? გამეორების
          ბლოკში ჩამალულია კოდის საინტერესო დეტალი, for ციკლი, რომელიც საწყისი მნიშვნელობიდან
          საბოლოო მნიშვნელობამდე გარკვეული ნაზრდით ითვლის.
      2:
        image: notes/C4_for_loops_2.png
        text: მაგალითად, გამეორების ბლოკი ითვლის 1-დან 3-მდე ბიჯით 1. ყოველი დათვლისას
          ის უშვებს ციკლის კოდს. "for" ციკლმა იცის, რამდენჯერ უნდა გაეშვას - ამისთვის
          ის იყენებს ცვლადების მთვლელს, რომელშიც მოცემულია საწყისი მნიშვნელობა და
          განსაზღვრულია ნაზრდი, ანუ ის, რაც ემატება მნიშვნელობას ციკლის ყოველი გაშვებისას.
          როგორც კი მთვლელის ცვლადი სასრულ მნიშვნელობაზე მეტი ხდება, ციკლი ჩერდება.
      3:
        image: notes/C4_for_loops_3.png
        text: გამეორების ბლოკის მაგივრად ნამდვილი for ციკლის გამოყენების უპირატესობა
          ისაა, რომ მთვლელის ცვლადს უშუალოდ ხედავთ და შეგიძლიათ მისი ციკლში გამოყენება.
          თუ მაქვს რამდნიმე ყვავილი და პირველში არის ერთი ნექტარი, მეორეში ორი, მესამეში
          სამი, შემიძლია გამოვიყენო for ციკლი და ვუთხრა ფუტკარს ყოველ ჯერზე მოკრიბოს
          'მთვლელი' ნექტარი, ანუ ერთი პირველ ყვავილზე, ორი მეორეზე და სამი მესამეზე.
      4:
        image: notes/C4_for_loops_4.png
        text: For ციკლში მთვლელი ერთისგან განსხვავებული ნაზრდით შეიძლება იცვლებოდეს.
          შეიძლება ითვლიდეთ 2X ან 4X ბიჯით, ან სულაც ცვალოთ ბიჯი ყოველი დათვლისას.
    C4_for_loops_bee:
      1:
        image: notes/C4_for_loops_bee_1.png
        text: როცა გამეორების ბლოკს თქვენი კოდის ციკლურად გასაშვებად იყენებთ, როგორ
          უნდა მიხვდეს კომპიუტერი, რომ საკმარისად გაიმეორა რაღაც ქმედება? გამეორების
          ბლოკში ჩამალულია კოდის საინტერესო დეტალი, for ციკლი, რომელიც საწყისი მნიშვნელობიდან
          საბოლოო მნიშვნელობამდე გარკვეული ნაზრდით ითვლის.
      2:
        image: notes/C4_for_loops_bee_2.png
        text: მაგალითად, გამეორების ბლოკი ითვლის 1-დან 3-მდე ბიჯით 1. ყოველი დათვლისას
          ის უშვებს ციკლის კოდს. "for" ციკლმა იცის, რამდენჯერ უნდა გაეშვას - ამისთვის
          ის იყენებს ცვლადების მთვლელს, რომელშიც მოცემულია საწყისი მნიშვნელობა და
          განსაზღვრულია ნაზრდი, ანუ ის, რაც ემატება მნიშვნელობას ციკლის ყოველი გაშვებისას.
          როგორც კი მთვლელის ცვლადი სასრულ მნიშვნელობაზე მეტი ხდება, ციკლი ჩერდება.
      3:
        image: notes/C4_for_loops_bee_3.png
        text: გამეორების ბლოკის მაგივრად ნამდვილი for ციკლის გამოყენების უპირატესობა
          ისაა, რომ მთვლელის ცვლადს უშუალოდ ხედავთ და შეგიძლიათ მისი ციკლში გამოყენება.
          თუ მაქვს რამდნიმე ყვავილი და პირველში არის ერთი ნექტარი, მეორეში ორი, მესამეში
          სამი, შემიძლია გამოვიყენო for ციკლი და ვუთხრა ფუტკარს ყოველ ჯერზე მოკრიბოს
          'მთვლელი' ნექტარი, ანუ ერთი პირველ ყვავილზე, ორი მეორეზე და სამი მესამეზე.
      4:
        image: notes/C4_for_loops_bee_4.png
        text: For ციკლში მთვლელი ერთისგან განსხვავებული ნაზრდით შეიძლება იცვლებოდეს.
          შეიძლება ითვლიდეთ 2X ან 4X ბიჯით, ან სულაც ცვალოთ ბიჯი ყოველი დათვლისას.
    C4_for_loops_no_bee:
      1:
        image: notes/C4_for_loops_no_bee_1.png
        text: როცა გამეორების ბლოკს თქვენი კოდის ციკლურად გასაშვებად იყენებთ, როგორ
          უნდა მიხვდეს კომპიუტერი, რომ საკმარისად გაიმეორა რაღაც ქმედება? გამეორების
          ბლოკში ჩამალულია კოდის საინტერესო დეტალი, for ციკლი, რომელიც საწყისი მნიშვნელობიდან
          საბოლოო მნიშვნელობამდე გარკვეული ნაზრდით ითვლის.
      2:
        image: notes/C4_for_loops_no_bee_2.png
        text: მაგალითად, გამეორების ბლოკი 1-დან 3-მდე ერთეულობით ითვლის. ყოველი დათვლისას
          ის უშვებს ციკლის კოდს. "for" ციკლმა იცის, რამდენჯერ უნდა გაეშვას - ამისთვის
          ის იყენებს ცვლადების მთვლელს, რომელშიც მოცემულია საწყისი მნიშვნელობა და
          განსაზღვრულია ნაზრდი, ანუ ის, რაც ემატება მნიშვნელობას ციკლის ყოველი გაშვებისას.
          როგორც კი მთვლელის ცვლადი სასრულ მნიშვნელობაზე მეტი ხდება, ციკლი ჩერდება.
          გამეორების ბლოკის ნაცვლად for ციკლის გამოყენების უპირატესობა არის ის, რომ
          პირდაპირ ხედავთ მთვლელის ცვლადს და იყენებთ მას ციკლში.
    C4_function_create:
      1:
        image: notes/C4_function_create_1.png
        text: ახლა, როცა ფუნქციების ბლოკების რედაქტირება უკვე იცით, დროა ფუნქცია ნულიდან
          დავწეროთ. ეს მარტივია, მართლა. როგორც ხედავთ, ინსტრუმენტების პანელზე არის
          კატეგორია "ფუნქციები". თუ მას დააჭერთ, დაინახავთ ნარინჯისფერ ღილაკს "ფუნქციის
          შექმნა". ამ ღილაკზე დაჭერით ჩნდება ფუნქციის რედაქტორი, რომელიც თქვენთვის
          უკვე ნაცნობია - ზუსტად მასში ვცვლიდით უკვე არსებულ ფუნქციების ბლოკებს.
      2:
        image: notes/C4_function_create_2.png
        text: ისევე, როგორც ადრე, თქვენ ფუნქციის სახელის დარქმევით დაიწყეთ, შემდეგ
          კი დაწერეთ ფუნქციის აღწერა - ანუ, რა უნდა გააკეთოს ფუნქციამ. მაგალითად,
          უნდა დახატოს კვადრატი ან სამკუთხედი. შემდეგ ინსტრუმენტების პანელიდან გადმოგაქვთ
          ბლოკები სამუშაო სივრცეში. გახსოვდეთ, რომ ეს ბლოკები ფუნქციის მწვანე ბლოკში
          უნდა ჩასვათ.
      3:
        image: notes/C4_function_create_3.png
        text: როცა დაასრულებთ, დააჭირეთ შენახვასა და გასლვას. ასე თავსატეხის მთავარ
          სამუშაო სივრცეში დაბრუნდებით. თქვენ მიერ შექმნილი ახალი ფუქნცია ინსტრუმენტების
          პანელზე ფუნქციების კატეგორიაში მწვანე ბლოკის სახით გამოჩნდება. გადმოიტანეთ
          იგი სამუშაო სივრცეში და გამოიყენეთ ისევე, როგორც ნებისმიერი სხვა ბლოკი.
    C4_function_edit:
      1:
        image: notes/C4_function_edit_1.png
        text: პროგრამირებაში ერთ-ერთი ყველაზე კარგი ისაა, რომ როცა ერთხელ ასწავლით
          კომპიუტერს, როგორ გააკეთოს რამე, შემდეგ ამ პროცესის ფუნქციის სახით გამოძახება
          შეგიძლიათ. ერთხელ შექმნით, დაარქმევთ სახელს და მერე უბრალოდ გამოიძახებთ.
          ეს ძალიან ჰგავს ენაში ლექსიკური მარაგის გამდიდრებას.
      2:
        image: notes/C4_function_edit_2.png
        text: პროგრამაში, რომელიც შევქმენით, ჩვენ ვისწავლეთ კვადრატის დახატვა ოთხ-ოთხჯერ
          მოძრაობითა და მობრუნებით. შეგვიძლია შევქმნათ ასეთი ფუნქცია და დავარქვათ
          მას "კვადრატის დახატვა" - ასე ნებისმიერ დროს, როცა ამის გაკეთება დაგვჭიდება,
          უბრალოდ გამოვიძახებთ ფუნქციას და ის თვითონ შეასრულებს კოდს. ასე დავუმატეთ
          პროგრამირების ჩვენს ლექსიკონს კიდევ ერთი კონცეპტი.
      3:
        image: notes/C4_function_edit_3.png
        text: ამ თავსატეხში ჩვენ უკვე შევქმენით ფუნქცია "კვადრატის დახატვა" - მწვანე
          ბლოკი ინსტრუმენტების პანელზე. ახლა უნდა დაწეროთ იგივე კოდი, რაც წინა ჯერ
          დაწერეთ კვადრატის დასახატად და ჩასვათ ამ ფუნქციაში. ამისთვის, მწვანე ბლოკზე
          "დახატე კვადრატი" დააჭირეთ რედაქტირებას. ასე გაიხსნება ფუნქციის რედაქტორი,
          რომელიც სამი ნაწილისგან შედგება. არის ადგილი, სადაც იწერება ფუნქციის სახელი
          - რაც გამოჩნდება მწვანე ბლოკზე. შემდეგ იწერება ფუნქციის მოქმედების მოკლე
          აღწერა.
      4:
        image: notes/C4_function_edit_4.png
        text: ამ შემთხვევაში, უნდა დაიხატოს კვადრატი. თეთრი სივრცე არის სამუშაო სივრცე
          - ზუსტად ისეთი, როგორიც უკვე გამოგიყენებიათ. გადმოიტანეთ ამ სივრცეში ბლოკები
          ინსტრუმენტების პანელიდან. არ დაგავიწყდეთ კვადრატის დახატვისთვის საჭირო ბლოკები
          ფუნქციის მწვანე ბლოკში ჩასვათ. როცა დაასრულებთ, დააჭირეთ "შენახვასა და გასვლას".
          ასე გადახვალთ თავსატეხის მთავარ სამუშაო სივრცეში და შეძლებთ გამოიყენოთ კვადრატის
          დახატვის ფუქნცია, როგორც ნებისმიერი სხვა ბლოკი.
    C4_function_parameters:
      1:
        image: notes/C4_function_parameters_1.png
        text: ეს ფუნქცია ხატავს კვადრატს გვერდით 50 პიქსელი. ძალიან კარგია, მაგრამ
          დავუშვათ, მინდა დავხატო ერთი კვადრატი გვერდით 50 პიქსელი და მეორე - გვერდით
          100 პიქსელი? თითქმის იგივე დავალებაა და მის შესასრულებლად არ უნდა გვჭირდებოდეს
          ახალი ფუნქციის შექმნა. გამოვიყენოთ ერთი ფუნქცია ორივე საქმისთვის, უბრალოდ
          დავუმატოთ მას პარამეტრები.
      2:
        image: notes/C4_function_parameters_2.png
        text: პარამეტრები გვაძლევს საშუალებას გადავცეთ ფუნქციას მნიშვნელობები, რომლებიც
          ფუნქციაში ცვლადებივით გამოიყენება. დავუმატოთ ამ ფუნქციას პარამეტრი "სიგრძე"
          და შევქმნათ სხვადასხვა ზომის კვადრატები. ფუნქციის რედაქტორში ისევე, როგორც
          ადრე, შეგიძლიათ სახელის და აღწერის შეცვლა, მაგრამ ასევე შეგიძლიათ პარამეტრის
          დამატება. ჩაწერეთ პარამეტრის სახელი ცარიელ ადგილას და დააჭირეთ "პარამეტრის
          დამატებას". ასე შეიქმნება წითელი ბლოკი თქვენ მიერ შექმნილი პარამეტრის სახელით.
          ახლა შეგიძლიათ ჩაანაცვლოთ ბლოკი "წინ გადაადგილება 100-ით" პარამეტრით "სიგრძე"
          და ყველაფერი გადაინაცვლებს წინ მოცემული "სიგრძით".
      3:
        image: notes/C4_function_parameters_3.png
        text: დააჭირეთ შენახვასა და დახურვას და გადმოიტანეთ თქვენი ახალი ბლოკი "კვადრატის
          შექმნა" ფუნქციების კატეგორიიდან ინსტრუმენტების პანელზე. ალბათ, შეამჩნიეთ
          რომ სიგრძის გვერდით ცარიელი ადგილია, იმიტომ რომ ფუნქციას სჭირდება იცოდეს,
          რა მნიშვნელობა უნდა ჰქონდეს სიგრძის პარამეტრს. გადმოიტანეთ რიცხვითი ბლოკი
          მათემატიკის კატეგორიიდან და ჩასვით ამ ცარიელ ადგილას. ხედავთ, როგორ შეგიძლიათ
          ფუნქციის მრავალჯერადად გამოყენება და სხვადასხვა სიგრძის მითითებით სხვადასხვა
          ზომის კვადრატების შექმნა? სცადეთ დამოუკიდებლად!
    C4_intro:
      1:
        image: notes/C4_intro_1.png
        text: ჩვეულებრივ, პროგრამას ტექსტით წერენ, მაგრამ დღეს ჩვენ გამოვიყენებთ ბლოკლის,
          სისტემას, რომელიც იყენებს ვიზუალურ ბლოკებს, რომელთა გადაადგილებითაც იწერება
          პროგრამა. დასაწყისისთვის, დავწერთ კოდს, რომელიც დაეხმარება ამ გაბრაზებულ
          ჩიტს გაიაროს ლაბირინთი და დაიჭიროს ბოროტი გოჭები, რომლებმაც მისი კვერცხები
          მოიპარეს.
      2:
        image: notes/C4_intro_2.png
        text: ბლოკლი სამ ძირითად ნაწილადაა დაყოფილი. მარცხნივ არის ჩიტის ლაბირინთი,
          სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ლაბირინთის ქვემოთ
          არის მოცემული. შუაში არის ინსტრუმენტების პანელი და ყოველი ბლოკი არის ბრძანება,
          რომლის გაგებაც ამ ჩიტს შეუძლია. მარჯვნივ მდებარე თეთრი სივრცე არის სამუშაო
          სივრცე - სწორედ აქ აეწყობა ჩვენი პროგრამა.
      3:
        image: notes/C4_intro_3.png
        text: რა მოხდება, თუ გადაადგილების ბლოკს სამუშაო სივრცეში გადმოვიტან და "გაშვებას"
          დავაჭერ? ჩიტი წინ ერთი კვადრატით გადაადგილდება. დავუშვათ, მინდა რომ ჩიტმა
          წინ გადაადგილების მერე კიდევ რამე გააკეთოს. რა ვქნა? ჩვენს პროგრამას კიდევ
          ერთი ბლოკი უნდა დავუმატო.
      4:
        image: notes/C4_intro_4.png
        text: მე ავირჩევ ბლოკს "მარჯვნივ მობრუნება" და მივუმაგრებ მას ბლოკს "წინ გადაადგილება"
          - უნდა გადავიტანოთ ერთი ბლოკი მეორეს ქვემოთ და მივუახლოვოთ, სანამ არ გამოჩნდება
          ყვითელი ისარი  - მაშინ შეიძლება გავუშვათ ბლოკი და ის მიემაგრება ზემოთას.
          ახლა, როცა დავაჭერთ ღილაკს "გაშვება" ჩიტი შეასრულებს ყველა ბრძანებას, თანმიმდევრობით
          ზემოდან ქვემოთ.
      5:
        image: notes/C4_intro_5.png
        text: თუ ბლოკის წაშლა დაგჭირდათ, გადაიტანეთ ის სანაგვე ყუთში. გაშვების შემდეგ
          ყოველთვის შეგიძლიათ დააჭიროთ ღილაკს "თავიდან" და ჩიტი საწყის პოზიციას დაუბრუნდება.
          ახლა კი დროა დავიჭიროთ ეს გოჭები!
    C4_math_artist:
      1:
        image: notes/C4_math_artist_1.png
        text: თუ მინდა დავხატო მართკუთხედი განით 50 პიქსელი და ორჯერ დიდი სიგრძით,
          როგორ დავაპროგრამო კომპიუტერი ამის გასაკეთბლად? ცხადია, შემიძლია ვუთხრა
          მხატვარს ავიდეს ზემოთ ორმოცდაათით, მოუხვიოს მარჯვნივ და წავიდეთ წინ ასით
          და შემდეგ გავიმეორო ეს კიდევ ერთხელ. მაგრამ რატომ უნდა ვითვალო კომპიუტერის
          მაგივრად?
      2:
        image: notes/C4_math_artist_2.png
        text: ორმოცდაათის ორზე გამრავლება შეიძლება ზეპირადაც არ არის რთული, მაგრამ
          კომპიუტერებს გადასარევად ეხერხებათ მათემატიკა, ამიტომ ყოველთვის, როცა ეს
          შესაძლებელია, გამოთვლები მათ უნდა მივანდოთ. მაგალითად, რომ გამომეყენებინა
          ცვლადი "სიმაღლე", შევძლებდი განმესაზღვრა ის ორმოცდაათად, შემდეგ კი შემეცვალა
          ალგორითმი და მეთქვა მხატვრისთვის, რომ ჯერ ასულიყო "სიმაღლით", მოეხვია მარჯვნივ
          და წასულიყო 2X"სიმაღლით". მივიღებდით მართკუთხედს, რომლის სიგრძეც სიმაღლეზე
          2-ჯერ მეტი იქნებოდა.
    C4_unplugged_algorithms:
      1:
        image: notes/C4_unplugged_algorithms_1.png
        text: 'ამ გაკვეთილს ჰქვია "ალგორითმები: ტანგრამები". ტანგრამი არის თავსატეხი,
          რომელიც შვიდი ნაწილისგან შედგება. ამ ნაწილების შეერთებით სხვადასხვა ფიგურების
          მიღებაა შესაძლებელი. თქვენ გამოიყენებთ ალგორითმს და აუხსნით თქვენს პარტნიორს,
          თუ როგორ შეკრას ფიგურა.'
      2:
        image: notes/C4_unplugged_algorithms_2.png
        text: ალგორითმი არის იმ ნაბიჯების სია, რომელიც გჭირდებათ დავალების შესასრულებლად.
          ჩვენ მათ ყოველდღე ვიყენებთ - როცა ვადგენთ საყიდლების სიას ან მივყვებით რეცეპტს.
          თუ თქვენი ალგორითმი ძალიან ზოგადი იქნება, ყველას შეეძლება მისი თავისებურად
          განმარტება და შედეგად, შეიძლება სულაც არ მიიღონ ზუსტად ის, რაც თქვენ გსურთ.
          თუ გინდათ, რომ ყველამ ერთი და იგივე შედეგი მიიღოს, თქვენი ალგორითმი უნდა
          იყოს დეტალური და კონკრეტული.
      3:
        image: notes/C4_unplugged_algorithms_3.png
        text: ნახატის დასასრულებლად ალგორითმს ვიყენებ. მგლების დახატვა მინდოდა, მაგრამ
          არც თუ ისე ნიჭიერი მხატვარი ვარ. საბედნიეროდ, ჩემნაირი ადამიანებისთვის რიცხვების
          მიხედვით ხატვა არსებობს. სულ ორმოცი ფერია და პატარა რიცხვები და ასოებიცაა
          მოცემული, რითაც ვხვდებით, რომელი სექცია რა ფერით უნდა შევღებოთ.
      4:
        image: notes/C4_unplugged_algorithms_4.png
        text: ეს ძალიან ზუსტია, ამიტომ შემიძლია მივყვე ინსტრუქციებს და მშვენიერი ნახატი
          გამომივა. ძალიან კარგი ალგორითმია. ინსტრუქციები საკმარისად ზუსტი რომ არ
          ყოფილითო, არც ისე კარგი მგლები გამომივიდოდა. როცა გინდათ, რომ რაღაც ზუსტად
          ისეთი გამოვიდეს, როგორსაც გეგმავთ, უმჯობესია ყველაფერი მაქსიმალური სიზუსტით
          ახსნათ.
    C4_unplugged_binary:
      1:
        image: notes/C4_unplugged_binary_1.png
        text: ყოველ გუნდში ინსტრუქტორმა, ანუ, იმ ადამიანმა, რომელსაც ქაღალდი უჭირავს
          ხელში, უნდა განსაზღვროს, რა იქნება მათი გამორთვის სიმბოლო და რა იქნება ჩართვის
          სიმბოლო. ბინარული სისტემა ორასოიან ანბანს ჰგავს - აი, ა და ბ რომ გქონდეთ
          მთელი ანბანის მაგივრად, ისე გაქვთ 0 და 1.
      2:
        image: notes/C4_unplugged_binary_2.png
        text: 'ბინარულობის გამოყენების ყველაზე გავრცელებული გზა არის "თუ" დებულებები
          - პროგრამირების კლასიკური ელემენტი. პროგრამა გაშვებულია და გვეუბნება "თუ
          რაღაც ჭეშმარიტია, გააკეთე ეს. თუ არა, გააკეთე რაღაც სხვა." დავუშვათ, რაღაც
          უფრო რთულის შექმნა გინდათ: მაგალითად, "თუ" დებულების მაგივრად გამოსახულებაზე
          ან ხმაზე მოქმედება.'
      3:
        image: notes/C4_unplugged_binary_3.png
        text: კომპიუტერმა მარტო ბინარული სისტემა იცის, მაგრამ სურთი არ არის ბინარული,
          ის არ შედგება ნულებისა და ერთიანებისგან.. რა გავაკეთოთ? ავიღოთ მაგალითი
          - აი, ეს მშვენიერი სურათი. სურათი არის რაღაც სახის ინფორმაცია. ნებისმიერი
          ინფორმაცია შეიძლება ავსახოთ ბინარულად - მთავარია, მოვიფიქროთ, როგორ.
      4:
        image: notes/C4_unplugged_binary_4.png
        text: წარმოიდგინეთ, რომ ამ პანდას უნდა დავადოთ ბადე და ყოველი კვადრატისთვის
          უნდა გადავწყვიტოთ, ის უფრო შავია, თუ უფრო თეთრი - შემდეგ კი უნდა შევღებოთ
          გადაწყვეტილების შესაბამისად. ამ ბადეზე ყოველი კვადრატი ან შავია, ან თეთრი
          და ვთქვათ, რომ შავი კვარდატი არის ნული (ბინარული ციფრი) და თეთრი კვადრატი
          არის ერთი (მეორე ბინარული ციფრი). ბოლოს მხოლოდ ნულები და ერთიანები დაგრჩებათ
          - აი, როგორ გამოვსახოთ სურათი ბინარული სისტემით.
    C4_unplugged_forloops:
      1:
        image: notes/C4_unplugged_forloops_1.png
        text: ამ გაკვეთილს ჰქვია for ციკლების მხიარულება. ჩვენ გამოვიყენებთ რიცხვით
          ღერძს და ვითამაშებთ კამათელს. ყოველი მოთამაშე სამჯერ გააგორებს კამათელს
          და მიიღებს საწყის მნიშნველობას, საბოლოო მნიშვნელობასა და ინტერვალს. ყოველი
          სვლისას ჩვენ შემოვხაზავთ საწყის მნიშვნელობას და იმ მნიშვნელობას, რომელიც
          უდრის ინტერვალის ტოლი ნაბიჯების რაოდენობას. შემოხაზვას შევწყვეტთ, როგორც
          კი მივაღწევთ საბოლოო მნიშვნელობას. მოიგებს ის, ვინც ყველაზე მეტს დააგროვებს!
      2:
        image: notes/C4_unplugged_forloops_2.png
        text: For ციკლები საერთოდ ძალიან გამოსადეგი რამეა და მეტეოროლიგი რომ ყოფილიყავით,
          გამუდმებით გამოიყენებდით მათ. გამარჯობა, მე ბეკი ვარ. მე ვმუშაობ კომპანიაში
          EverPower Renewables, ქარის მეტეოროლოგად. ჩემი საქმეა ქარის სიჩქარის განსაზღვრა
          კოლუბმიის გორჯის მდინარის მიდამოებში, სადაც ჩვენს კომპანიას ქარის ფერმები
          აქვს.
      3:
        image: notes/C4_unplugged_forloops_3.png
        text: ჩვენ ვცდილობთ დავადგინოთ, რამდენად ძლიერი ქარი იქნება და რამდენ ენერგიას
          მოგვცემს ეს - შემდეგ ამ ინფორმაციას ენერგიით მოვაჭრეებს გადავცემთ. ისინი
          ყიდულობენ და ყიდიან ენერგიას ჩვენს მონაცემებზე დაყრდნობით, ისე, რომ ყველაფერი
          წესრიგზე იყოს - შუქი განუწყვეტლივ გქონდეთ და მაქსმალურად გამოვიყენოთ და
          მივიღოთ ენერგია ჩვენი ფერმებიდან.
      4:
        image: notes/C4_unplugged_forloops_4.png
        text: ჩვენ ვართ  EverPower Renewables ცენტრიდან, რომელიც აქ, პორტლანდშია განლაგებული.
          სწორედ აქ იყრის თავს ყველა ინფორმაცია, რასაც კი ჩვენი ფერმები გვაწვდიან
          ქვეყნის მასშტაბით. დღეს ყველაზე ძლიერ კომპიუტერებსაც კი ჯერ კიდევ არ შეუძლიათ
          ამინდის სიმულაცია. ამინდის პროგნოზის კომპიუტერულ მოდელებში გვაქვს ე. წ.
          ბადე. ბადის ყოველ წერტილს მინიჭებული აქვს გრძედი და განედი. ვითვლით მონაცემებს
          და ვცდილობთ გამოვიცნოთ ქარის სიჩქარე, ტემპერატურა, წნევა და ა. შ.
      5:
        image: notes/C4_unplugged_forloops_5.png
        text: ეს ბადეები ძალიან დიდია და ძალიან-ძალიან ბევრი წერტილი გვაქვს, ამ წერტილებს
          კი ციკლურად მილიონობით ჯერ გავდივართ ხოლმე. მე ყველგან ვიყენებ for ციკლებს.
          აი, მაგალითად, აქაც არის for ციკლი. ქარის განსაზღვრის პროცესში იმდენი სხვადასხვა
          პარამეტრია ჩართული, უბრალოდ შეუძლებელია, რომ ადამიანმა ეს ყველაფერი გამოთვალოს.
          იმდენი რამე არსებობს, რამაც შეიძლება გავლენა მოახდინოს ქარზე, რომ მის განსასაზღვრად
          აუცილებელია კომპიუტერული მოდელი.
    C4_unplugged_madlibs:
      1:
        image: notes/C4_unplugged_madlibs_1.png
        text: ამ გაკვეთილში ვითამაშებთ ისტორიებით "შეავსეთ ცარიელი ადგილი". მოცემული
          გაქვთ შაბლონი, რომელიც შეგიძლიათ შეავსოთ და შექმნათ მსგავსი ისტორიები, მაგრამ
          ძალიან სახალისო და საინტერესო სხვაობებით.
      2:
        image: notes/C4_unplugged_madlibs_2.png
        text: ამ გაკვეთილში ჩვენ ასევე ვისწავლეთ, როგორ შევქნათ ორი უკვე არსებული
          ისტორიიდან აბსტრაქტული ნიმუში. აბსტრაქცისს ხელოვნება გულისხმობს სხვაობებისა
          და დეტალების მოშორებას და გვაჩვენებს, როგორ შეიძლება ბევრი სხვადასხვა პრობლემისთვის
          ერთი გადაწყვეტის მორგება. ეს ძალიან სასარგებლო უნარია კომპიუტერულ მეცნიერებაში,
          იმიტომ რომ გვაძლევს საშუალებას შევქმნათ ფუნქციები, რომლებიც ბევრ სხვადასხვა
          სიტუაციაში გამოგვადგება.
    C4_unplugged_parameters:
      1:
        image: notes/C4_unplugged_parameters_1.png
        text: ამ გაკვეთილს ჰქვია "სიმღერის წერა პარამატრებით" - აქ რაღაც სიმღერები
          უნდა დავწეროთ. ხანდახან მისამღერი ცოტათი განსხვავებულია ყოველ ჯერზე. გახსოვთ
          სიმღერა Old Macdonald Had a farm? მისამღერი ცოტათი იცვლებოდა ყოველი ცხოველისთვის.
          ამ ცვლილებების განხორციელება შეგვიძლია პარამეტრებით.
      2:
        image: notes/C4_unplugged_parameters_2.png
        text: ხანდახან ფუნქციაში საჭიროა პარამეტრი. პარამეტრი არის ინფორმაციის დამატებითი
          ნაწილი, რომელიც შეგიძლიათ გადასცეთ ფუნქციას და მოარგოთ ის გაკრევეულ საჭიროებას.
          როცა მეგობრებისთვის ნაყინებს ამზადებთ, გადიხართ პროგამირებაში პარამეტრების
          გამოყენების მსგავსს პროცესს.
      3:
        image: notes/C4_unplugged_parameters_3.png
        text: ვანილის ნაყინი შეიძლება ყველასთვის ერთნაირი იყოს, მაგრამ თუ ჰკითხავთ
          თქვენს მეგობრებს, რომელი ორი ტოპინგი უნდათ, უამრავ სხვადასხვაგვარ კომბინაციას
          მიიღებთ. ტოპინგი არის ფუნქციის სახელი, მაგრამ ყოველი ტიპის ტოპინგი არის
          პარამეტრი. ფუნქციები და პარამეტრები სწორედ ის წყვილია, რომელიც კარგ კომპიუტერულ
          პროგრმებს ქმნის.
    C4_unplugged_variables:
      1:
        image: notes/C4_unplugged_variables_1.png
        text: 'ამ გაკვეთილს ჰქვია ცვლადები კონვერტებში. ჩვენ ვისწავლით, როგორ ავაგოთ
          წინადადება იმ შემთხვევაში, თუ რაღაც ინფორმაცია ჯერ კიდევ გვაკლია. ალბათ,
          ყველამ ვიცით, რას ნიშნავს, ცარიელი ველის შევსება: მაგალითად, როცა ჩვენს
          სახელს ვწერთ სადმე. ხანდახან, ერთზე მეტი ტიპის ინფორმაციაა შესაყვანი და
          ასეთი შემთხვევებისთვის ცარიელ ველებს იარლიყს ვანიჭებთ - იმის განსასაზღვრად,
          რომელი ინფორმაცია სად უნდა ჩაისვას.'
      2:
        image: notes/C4_unplugged_variables_2.png
        text: 'ცვლადები იგივე ადგილის შემავსებლებია ისეთი ინფორმაციისთვის, რომელიც
          შეიძლება შეიცვალოს. თუ რამე ინფომრაცია გვაკლია, მის ადგილას შეგვიძლია გამოვიყენოთ
          ცვლადი და გავაგრძელოთ მუშაობა: შემდეგ ვინმე სხვა შეავსებს ამ გამოტოვებულ
          ინფორმაციას. პროგრამულ უზრუნველყოფაში ცვლადები ძალიან ხშირად გამოიყენება,
          მაგალითად, სახელის, ელ. ფოსტისა ან მომხმრებლის სახელის ადგილას. ასე ჩვენ
          ვასწავლით პროგრამას, სად უნდა გამოჩნდეს ესა თუ ის დეტალი იმის მერე, რაც
          მომხმარებელი მას შეავსებს. ჩვენს სამუშაოში განუწყვეტლივ გვიწევს ცვლადების
          გამოყენება.'
      3:
        image: notes/C4_unplugged_variables_3.png
        text: ყოველთვის, როცა სამომავლოდ გვინდა ინფორმაციის ნაწილის შენახვა, ვიყნებთ
          ცვლადებს. დავუშვათ, გვინდა დავითვალოთ, რამდენი ტვიტი დაპოსტა მომხმარებელმა.
          ყოველ ჯერ, როცა მომხამერებელი დაპოსტავს ტვიტს, ანგარიშს უნდა დავუმატოთ ერთი
          და ყოველ ჯერ, როცა ის რომელიმე ტვიტს წაშლის, ანგარიშს ერთი უნდა გამოვაკლოთ.
          როცა კი დაგვჭირდება ვნახოთ, რამდენი ტვიტი დაპოსტა მომხმარებელმა, უბრალოდ
          ამ ცვლადს უნდა შევხედოთ.
    C4_variables_artist:
      1:
        image: notes/C4_variables_artist_1.png
        text: 'ცვლადი არის კონტეინერი, რომელშიც მნიშვნელობის შენახვა შეგიძლიათ. როცა
          ეს ცვლადი ალგორითმში გამოიყენება, ალგორითმი ამოწმებს, რა მნიშვნელობა არის
          შენახული ამ კონტეინერში: ასე უფრო "ჭკვიან" ალგორითმებს წერთ, რომლებიც ცვლადიდან
          გამომდინარე სხვადასხვაგვარად მოქმედებენ.'
      2:
        image: notes/C4_variables_artist_2.png
        text: 'მაგალითად, გვინდა დავწეროთ ალგორითმი, რომელიც ჩემს უმცროს ძმას ასე
          მიულოცავს დაბადების დღეს "გილოცავ! შენ 10 წლის ხდები!". მაგრამ მე მინდა,
          რომ მომავალ წელს პროგრამამ უთხრას "გილოცავ! შენ 11 წლის ხდები!". ამისთვის
          შემიძლია შევქმნა ცვლადი, რომელშიც შეინახება ჩემი ძმის ასაკი და დავწერო ალგორითმი
          ასე: "გილოცავ! შენ "ასაკი" წლის ხდები!". იმის გამო, რომ ცვლადი შეიძლება
          იცვლებოდეს, ყოველი წელს განვაახლებ ცვლადს და გავუტოლებ მას "ასაკი" +1-ს.'
      3:
        image: notes/C4_variables_artist_3.png
        text: ამ თავსატეხში ჩვენ გამოვიყენებთ ცვლადს, რომელიც მხატვრის მიერ გავლებული
          ხაზის სიგრძეს განსაზღვრავს. მოგვიანებით, "წინ გადაადგილების" ბლოკი შეამოწმებს
          ამ სიგრძის ცვლადს, რომ გაიგოს, რა მნიშვნელობა განუსაზღვრეთ მას.
    C4_variables_playlab:
      1:
        image: notes/C4_variables_playlab_1.png
        text: 'ცვლადი არის კონტეინერი, რომელშიც მნიშვნელობის შენახვა შეგიძლიათ. როცა
          ეს ცვლადი ალგორითმში გამოიეყენება, ალგორითმი ამოწმებს, რა მნიშვნელობა არის
          შენახული ამ კონტეინერში: ასე უფრო "ჭკვიან" ალგორითმებს წერთ, რომლებიც ცვლადიდან
          გამომდინარე სხვადასხვაგვარად მოქმედებენ.'
      2:
        image: notes/C4_variables_playlab_2.png
        text: 'ახლა თამაშების ლაბორატორიაში უნდა მოსინჯოთ თავი: აქ ბევრი სხვადასხვა
          თამაშია და თქვენ შეგიძლიათ ცვლადების შეცვლა, ანუ, სიჩქარის, სიმაღლის, ანგარიშის,
          მოკლედ, თამაშის მოდიფიცირება. იმისთვის, რომ თამაში შეიცვალოს არ არის აუცილებელი
          მისი ალგორითმის შეცვლა, ცვლადების შეცვლა საკმარისია.'
      3:
        image: notes/C4_variables_playlab_3.png
        text: მე ხშირად ვიყენებ ცვლადებს სხვადასხვა მიზნით - ახლა ვმუშაობ ქინდლზე
          და X-ray ფუნქციონალზე. ცვლადების გამოყენების ერთი გზაა, შიენახო წიგნების
          გვერდების ნომრები. მომხმარებელს შეუძლია გაზარდოს ან შეამციროს გვერდზე ფონტის
          ზომა და აქედან გამომდინარე იცვლება გვერდების რაოდენობა. ჩვენ კი ამ რაოდენობას
          ცვლადის სახით ვინახავთ.
    infinity_playlab_events:
      1:
        image: notes/infinity_playlab_events_1.png
        text: ახლა ისეთ რამეს ვისწავლით, რასაც პროგრამისტები ყოველ დღე იყენებენ -
          მოვლენებს. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას უნდა დაუცადოს.
          როცა ეს რაღაც მოხდება, პროგრამა გარკვეულ ქმედებას განახორციელებს. მოვლენა
          შეიძლება იყოს მაუსის ღილაკზე დაჭერა, ისარზე დაჭერა ან ეკრანზე შეხება.
      2:
        image: notes/infinity_playlab_events_2.png
        text: ახლა უნდა გავაკეთოთ ისე, რომ ბეიმაქსი ავიდეს, შეეხოს ჰიროს და ჩავიდეს,
          შეეხოს რაპუნცელს, როცა მოთამაშე გამოიყენებს ქვემოთ/ზემოთ ისრებს ან ღილაკებს.
          გამოვიყენებთ ბლოკს "როცა ზემოთა ისარი" და მივუმაგრებთ მას ბლოკს "მსახიობის
          ზემოთ გადაადგილება" - ასე, როცა მოთამაშე ზემოთა ისარს დააჭერს, გაეშვება
          ყველაფერი, რაც მიმაგრებულია ბლოკს "როცა ზემოთა ისარი". იგივეს გავაკეთებთ
          ბეიმაქსის ქვემოთ გადასაადგილებლად. ნელ-ნელა თქვენი თამაში უფრო ინტერაქტიული
          ხდება.
    infinity_playlab_intro:
      1:
        image: notes/infinity_playlab_intro_1.png
        text: რომელ კლასში ხარ? მეორეში. მეათეში. პირველში. მე მერვეში ვიყავი, როცა
          დავიწყე პროგრამირების სწავლა. ჩემი პირველი კომპიუტერი მეექვსე კლასში მაჩუქეს.
          ძალიან მომწონს ის, რომ შემიძლია ადამიანების პრობლემების მოგვარება, თვითრეალიზაცია,
          იდეების განხორციელება.
      2:
        image: notes/infinity_playlab_intro_2.png
        text: კომპიუტერული მეცნიერება იმის საფუძველია, რასაც სტუდენტები და პროფესიონალები
          უახლოესი ოცი-ოცდაათი წლის მანძილზე გააკეთებენ. მე მომწონს პროგრამირება,
          იმიტომ რომ მომწონს ადამიანების დახმარება. ახლა მაქვს შესაძლებლობა შევქმნა
          რაღაც ისეთი, რაც სხვა ადამიანების ცხოვრებას გაამარტივებს. ვფიქრობ, ეს ძალიან
          ჰგავს სუპერ-ძალას. ყველაზე მნიშვნელოვანი ნაბიჯი კი დაწყებაა. მე თვითონაც
          დამწყები ვარ - და გთავაზობთ, ჩემთან ერთად ისწავლოთ.
      3:
        image: notes/infinity_playlab_intro_3.png
        text: მე ვარ ჯონ ვეკი, PopCap თამაშების ერთ-ერთი დამფუძნებელი. ჩვენ ვქმნით
          თამაშებს, ისეთებს, როგორიცაა Plants vs. Zombies, Bejeweled და Peggle. თამაშებში
          ყველაზე მნიშვნელოვანი ის კი არ არის, რამდენად იდეალურია შენი კოდი, არამედ,
          რამდენად იდელაურია თამაში - რამდენად სახალისოა და რა გრძნობებს იწვევს. ამისთვის
          უნდა სცადოთ, გააკეთოთ და განავითაროთ თამაშის შექმნის თქვენი უნარები.
      4:
        image: notes/infinity_playlab_intro_4.png
        text: 'გაქვთ საყვარელი ვიდეო-თამაში? ახლა თამაშების ლაბორატორიაში მსგავსი
          თამაშების შექმნისკენ ერთ მნიშვნელოვან ნაბიჯს გადავდგამთ. კარგ თამაშებს ყოველთვის
          აქვთ ისტორია და ისტორიაში, რა თქმა უნდა, მონაწილეობენ პერსონაჟები. პერსონაჟები
          საუბრობენ, მოძრაობენ და აქვთ ერთმანეთთან კონტაქტი. შეიძლება ქულებიც დააგროვონ,
          გააჩნია თამაშის წესებს. დღეს ამ ყველაფრის გაკეთებას ვისწავლით დისნეის პერსონაჟების
          მაგალითზე: ანა, ელზა, ჰირო, ბეიმაქსი და რაპუნცელი. ჩვენ სუფთა ფურცლიდან
          დავწერთ თამაშს, რომლის გაზიარებაც და ტელეფონზე თამაში შეგვეძლება.'
      5:
        image: notes/infinity_playlab_intro_5.png
        text: თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად. მარცხნივ არის სათამაშო სივრცე,
          სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ქვემოთ არის მოცემული.
          შუაში არის ინსტრუმენტების პანელი, სადაც ყოველი ბლოკი არის კოდი. თეთრი სივრცე
          მარჯვნივ არის სამუშაო სივრცე, სადაც დაიწერება ჩვენი პროგრამა.
      6:
        image: notes/infinity_playlab_intro_6.png
        text: 'პირველ რგიში, თქვენი ბლოკები უნდა მიუმაგროთ ნარინჯისფერ ბლოკს "გაშვებისას".
          ერთმანეთზე ბევრი ბლოკის გადაბმა შეიძლება, გადმოიტანეთ ისინი, მიუახლოვეთ
          ერთი მეორეს სანამ ყვითელი ზოლი არ გაჩნდება - და მერე ისინი მიეკვრებიან ერთმანეთს.
          ამ პირველ თავსატეხში ჰირო არის პერსონაჟი 1 და ბეიმაქსი არის პერსონაჟი 2.
          ჩვენი მიზანია, ჰირო მივიდეს ბეიმაქსამდე. ვაკეთებთ ასე: ვიღებთ ბლოკს "მოძრაობა
          მარჯვნივ" და ვუმაგრებთ მას ბლოკს "გაშვებისას". როცა ბლოკები მიმაგრებულია,
          დააჭირეთ "გაშვებას" და ნახეთ, რა დააპროგრამეთ.'
      7:
        image: notes/infinity_playlab_intro_7.png
        text: დაიწყეთ და ბოლოს თქვენ საკუთარი თამაშის შექმნას შეძლებთ. თქვენ გამოიყენებთ
          ამ საოცარ პერსონაჟებს, რომელთაც შეეძლებათ ურთიერთობა, ქულების დაგროვება,
          მიკრობოტების, ალუბლის, ქვაბების, ბრჭყვიალების, ყინულის სროლა და ერთმანეთის
          გაქრობა. ყველაფერი თქვენზეა დამოკიდებული!
    infinity_playlab_repeat_forever:
      1:
        image: notes/infinity_playlab_repeat_forever_1.png
        text: წარმოიდგინეთ, რომ რაღაც უსასრულოდ უნდა გაიმეოროთ. იმედია, ეს არასდროს
          არ მოგიწევთ - იმიტომ რომ ამ საქმეს კომპიუტერებიც მშვენივრად უმკლავდებიან.
          ეს არის ბლოკი "გამეორება უსასრულოდ". ყველაფერი, რაც ამ ბლოკშია, თამაშში
          უსასრულოდ გამეორდება.
      2:
        image: notes/infinity_playlab_repeat_forever_2.png
        text: თუ გვინდა, რომ პერსონაჟმა რაღაც ქმედება გაიმეოროს ისე, რომ მოთამაშეს
          არაფრის გაკეთება არ უწევდეს, უნდა ჩავსვათ ეს ბლოკები ბლოკში "გამეორება უსასრულოდ".
          შემდეგ თავსატეხში ჩვენი მიზანია დავეხმაროთ ანას ზემოთ და ქვემოთ უსასრულოდ
          მოძრაობაში. გამეორების ფუნქციების კარგად შესწავლა უამრავ დროს დაგიზოგავთ
          მომავალში, როცა თქვენს საკუთარ თამაშს დაწერთ.
    tutorial_puzzle_challenge:
      1:
        image: notes/tutorial_puzzle_challenge_1.png
        text: ვინ გინდა, რომ გამოხვიდე, როცა გაიზრდები, ოლივია? მმმ, ასტრონავტი! და
          პროგრამისტი ვინ არის, თუ იცი? მმ, არა. როგორ? ისე, არც კი ვიცი, როგორ ავხსნა.
          პროგრმირება საკმაოდ მარტივია. ინსტრუქციების ნაკრებია - რეცეპტივით. ამ ინსტრუქციებს
          ნაბიჯ-ნაბიჯ უნდა მიჰყვე და ბოლოს სასრუველ შედეგს მიიღებ.
      2:
        image: notes/tutorial_puzzle_challenge_2.png
        text: პიქსელების რიცხვის, ანუ ხაზის სიგრძის შეცვლა ამ ჩამოსაშლელი მენიუდან
          შემიძლია. რა სიგრძის უნდა იყოს? ინსტრუქციების ხელახლა ნახვა "გაშვების" ღილაკის
          ქვემოთ შეიძლება. მე გამოვიყენე ბლოკი "წინ გადაადგილება" და ვაპირებ ავირჩიო
          100 პიქსელი. ბლოკის წაშლა შემიძლია მისი ინსტრუმენტების პანელზე ან სანაგვე
          ყუთში გადატანით. დავაბრუნოთ ბლოკი.
      3:
        image: notes/tutorial_puzzle_challenge_3.png
        text: დავაჭიროთ ღილაკს "გაშვება" და გავუშვათ კოდი. ჰმ, არ გამოვიდა! დავაჭერ
          ღილაკს "თავიდან" და ვნახავ, რა შემეშალა. რამდენჯერაც გინდათ, იმდენჯერ შეგიძლიათ
          სცადოთ, ამოხსნათ თავსატეხი ან სულაც გამოტოვოთ იგი და მოგვიანებით დაუბრუნდეთ.
          მთავარია, მაქსიმალურად სცადეთ და არ დანებდეთ. ახლა კი დავუმატოთ კიდევ ერთი
          წინ გადაადგილების ბლოკი. მაინც არ გამოვიდა. შემიძლია ბლოკი სხვა ბლოკებს
          შორის განვალაგო.
      4:
        image: notes/tutorial_puzzle_challenge_4.png
        text: ავიღოთ მობრუნების ბლოკი და ჩავსვათ იგი წინ გადაადგილების ბლოკებს შორის.
          განვსაზღვროთ იგი მარცხნივ 45 გრადუსით მობრუნებით. გავუშვათ კოდი ხელახლა.
          მშვენიერია! აი, კიდევ ერთი თავსატეხი. (ხანდახან კოდის რაღაც ნაწილი უკვე
          მოცემულია და უნდა შეავსოთ). აქ შესაბამისი სიგრძეები და გრადუსული ზომები
          უნდა დავამატო.
      5:
        image: notes/tutorial_puzzle_challenge_5.png
        text: ხანდახან შეიძლება მთლიანად ჩააფლავოთ საწყისი კოდი. რა უნდა ქნათ ასეთ
          შემთხვევაში? შეგიძლიათ წაშალოთ არსებული კოდი და თავიდან დაიწყოთ. მე ვაპირებ
          გადმოვიტანო ეს რიცხვითი ბლოკი პიქსელების სხვადასხვა არეებში. აირჩიეთ 100
          პიქსელებში, 45 გრადუსებში და ისევ 100 პიქსელებში. მშვენიერია! აი, კოდის
          სტუდიის ფუტკარი. ჩემი ამოცანაა მივიყვანო ფუტკარი ყოველ ყვავილთან და მოვკრიბო
          ნექტარი.
      6:
        image: notes/tutorial_puzzle_challenge_6.png
        text: პირველი ყვავილი სამი ბლოკის დაშორებაზეა, ანუ, წინ სამი გადაადგილება
          მჭირდება. 1, 2, 3. შემდეგ მჭირდება ერთი ნექტარის აღება და კიდევ ერთი ნექტარის
          აღება. ჰმ, რაღაც არ გამოვიდა! ნექტარების აღებას შორის წინ გადაადგილების
          კიდევ ერთ ბლოკს ჩავსვამ და ისე ვცდი. აჰა, გამოვიდა! აი, ახლა თქვენ ისწავლეთ
          როგორ გამოიყენოთ კოდის სტუდიის მხატვარი და ფუტკრის თავსატეხები. წარმატებებს
          გისურვებთ სხვა თავსატეხების ამოხნაში.
    unplug1:
      1:
        image: notes/unplug1_1.png
        text: ვინ გინდა რომ გამოხვიდე, როცა გაიზრდები, ოლივია? მმმ, ასტრონავტი! და
          პროგრამისტი ვინ არის, თუ იცი? მმ, არა. როგორ? ისე, არც კი ვიცი, როგორ ავხსნა.
          პროგრმირება საკმაოდ მარტივია. ინსტრუქციების ნაკრებია - რეცეპტივით. ამ ინსტრუქციებს
          ნაბიჯ-ნაბიჯ უნდა მიჰყვე და ბოლოს სასრუველ შედეგს მიიღებ.
      2:
        image: notes/unplug1_2.png
        text: კომპიუტერული მეცნიერება გვაძლევს საშუალებას მსოფლიოზე გავლენა მოვახდინოთ.
          ეს შეიძლება იყოს მუსიკალური ვიდეობი, თამაშები, იმის განსაზღვრა არის თუ არა
          ორი ადამიანი ერთმანეთთან რამე კავშირში, ადამიანის მეგობრების პოვნა. ან თუნდაც
          ვინმეს სიცოცხლის გადარჩენა. მთავარია, გინდოდეს. ჩემთვის პროგრმარება იგივე
          დიდი ხელოვნებაც არის.
      3:
        image: notes/unplug1_3.png
        text: როცა ბოლოს და ბოლოს რაღაც ვისწავლე პროგრამირებაზე, ეს თეთრი კედელი გადაიქცა
          ბევრ კარად - აღებ მათ და, რა თქმა უნდა, ხედავ კიდევ უამრავ კარს. პროგრამირება
          არის მარტივი და სახალისო. ყველაფრის გაკეთება შეგიძლია, რაც შენს ტვინს მოესურვება.
          ბოლოს, იმდენ კარს აღებ, რომ სინათლე შემოდის. ჩემთვის დასრულებული პროგრამა
          არის სინათლით სავსე სტრუქტურა, სადაც ყველა კუთხეა განათებული. ადამიანების
          რაოდენობა, რომელთაც შეგიძლია დაუკავშირდე ტექნოლოგიების მეშვეობით დღეს უპრეცედენტოდ
          მაღალია.
      4:
        image: notes/unplug1_4.png
        text: ამ სერიის ჩვენი პირველი გაკვეთილი ახსნის, თუ რა არის ინფორმატიკა, რას
          აკეთებენ პროგრამისტები და როგორ უნდა გამოიყენოთ ტექნოლოგიები. ეს გაკვეთილი
          ძალიან მნიშვნელოვანია, თუმცა ბევრ საკითხავს შეიცავს. ბოლოს თქვენ შეძლებთ
          დაშიფროთ რამე თქვენივე ინიციალების გამოყენებით. ეს მხიარული აქტივობა ძალიან
          მნიშვნელოვანიც არის, იმიტომ რომ ბინარულობა ისეთი საკითხია, რომელიც შეიძლება
          ჟღერს ძალიან ტექნიკურად, მაგრამ როცა მას გაიგებთ, გეგონებათ, რომ საიდუმლო
          ენა ისწავლეთ.
    unplug2:
      1:
        image: notes/unplug2_1.png
        text: ეს არის გამოთვლითი აზროვნების გაკვეთილი, რომელმაც უნდა გასწავლოთ, როგორ
          დაშალოთ დიდი, რთული პრობლემა რამდენიმე უფრო მარტივ ამოცანად. ამ გაკვეთლის
          მიზანია დაწეროთ ინსტრუქციები, რომელთა მიხედვითაც ნებისმიერი შეძლებს დახატოს
          გაკვეთილის გეგმაში მოცემული ერთ-ერთი მონსტრი.
      2:
        image: notes/unplug2_2.png
        text: 'მოსწავლები იყოფიან ორ ჯგუფად და წერენ ინსტრუქციებს, შემდეგ კი ცვლიან
          ნამუშევრებს ერთმანეთში და მათ მიხედვით ხატავენ მონსტრს. ჯგუფები ინსტრუქციების
          გამოთვლითი აზროვნების ოთხი ნაბიჯის გამოყენებით დაწერენ: დაშლა, შაბლონის
          განსაზღვრა, აბსტრაგირება და ალგორითმები.'
      3:
        image: notes/unplug2_3.png
        text: 'პირველი ჯგუფები დაანაწევრებენ დავალებას, ანუ შექმნიან თამაშის გეგმას.
          შემდეგ ისინი გადაარჩევენ მონსტრებს და შექმნიან შაბლონს - ყველა სხვაობას
          გამოყოფენ ან წაშლიან. მაგალითად, ერთ მონსტრს აქვს ელფის თვალები, მეორეს
          კი - ტროლის თვალები. მთავარია, რომ ორივეს აქვს თვალები, ამიტომ ჩვენ დავწერთ
          ხაზს, რომელიც ამბობს: მონსტრს აქვს *ცარიელი* თვალები.'
      4:
        image: notes/unplug2_4.png
        text: მოსწავლეები შეძლებენ დაწერონ ინსტრუქციები, ანუ, ალგორითმი - მონსტრების
          ნაწილების სია გამოტოვებული ადგილებით, სადაც უნდა ჩაჯდეს კონკრეტული სტილები.
          შემდეგ ამ ინსტრუქციების სიას ისინი სხვა მოსწავლეებს გადასცემენ, მათ კი უნდა
          შექმნან თავიანთი მონსტრები.
    unplug3:
      1:
        image: notes/unplug3_1.png
        text: გრაფიკული პროგრამირება ქაღალდზე კარგად ხსნის კოდის არსს. ამ დავალებაში
          მოსწავლეებმა მხოლოდ ისრებითა და კონტურებით უნდა სცადონ სურათის გადახატვა.
          ერთი მიიღებს საწყის სურათს და მხოლოდ კონკრეტული ისრების გამოყენებით უნდა
          ახსნას, როგორ უნდა გაიმერონ ეს ნახატი სხვებმა.
      2:
        image: notes/unplug3_2.png
        text: 'ამ აქტივობაში მხოლოდ ამ სიმბოლოების გამოყენება შეგიძლიათ: ერთი კვადრატით
          წინ, უკან, ზემოთ ან ქვემოთ გადაადგლება, შემდეგ ფერზე შეცვლა და თქვენი კვადრატის
          შეღებვა. როცა კოდის წერას დავასრულებთ, გადავცეთ იგი სხვა ადამიანს და ვანხოთ,
          თუ გამოუვა სურათის გამეორება.'
    unplug4:
      1:
        image: notes/unplug4_1.png
        text: გრაფიკული პროგრამირება ქაღალდზე კარგად ხსნის კოდის არსს. ამ დავალებაში
          მოსწავლეებმა მხოლოდ ისრებითა და კონტურებით უნდა სცადონ სურათის გადახატვა.
          ერთი მიიღებს საწყის სურათს და მხოლოდ კონკრეტული ისრების გამოყენებით უნდა
          ახსნას, როგორ უნდა გაიმერონ ეს ნახატი სხვებმა.
      2:
        image: notes/unplug4_2.png
        text: აქტივობის მეორე ნახევარში ჩვენ ვეკითხებით მოსწავლეებს რამდენი სხვადასხვა
          გზით შეუძლიათ დაკეცონ ქაღალდის ფურცელი, რომ 16 იდენტური მართკუთხედი მიიღონ.
          შემდეგ განვიხილავთ, როგორ არის შესაძლებელი ერთისა და იმავე შედეგის სხვადასხვა
          გზებით მიეღება და რატომ ხდება ისე, რომ ზოგ სიტუაციაში ზოგი მეთოდი უფრო ეფექტურია.
    unplug5:
      1:
        image: notes/unplug5_1.png
        text: გრაფიკული პროგრამირება ქაღალდზე კარგად ხსნის კოდის არსს. ამ დავალებაში
          მოსწავლეებმა მხოლოდ ისრებითა და კონტურებით უნდა სცადონ სურათის გადახატვა.
          ერთი მიიღებს საწყის სურათს და მხოლოდ კონკრეტული ისრების გამოყენებით უნდა
          ახსნას, როგორ უნდა გაიმერონ ეს ნახატი სხვებმა.
      2:
        image: notes/unplug5_2.png
        text: აქტივობის მეორე ნახევარში ჩვენ ვეკითხებით მოსწავლეებს რამდენი სხვადასხვა
          გზით შეუძლიათ დაკეცონ ქაღალდის ფურცელი, რომ 16 იდენტური მართკუთხედი მიიღონ.
          შემდეგ განვიხილავთ, როგორ არის შესაძლებელი ერთისა და იმავე შედეგის სხვადასხვა
          გზებით მიეღება და რატომ ხდება ისე, რომ ზოგ სიტუაციაში ზოგი მეთოდი უფრო ეფექტურია.
    unplug6:
      1:
        image: notes/unplug6_1.png
        text: ამ აქტივობას ჰქვია კოდი კარტებით და ის ნებისმიერი ასაკისთვის არის გამოსადეგი.
          როგორც უკვე ისწავლეთ ბლოკლის გაკვეთილებში, "თუ" დებულებებში არის რაღაც ნაწილი,
          რომელიც უნდა შეფასდეს - ჭეშმარიტია თუ არა. ეს ნაწილი არის პირობა და მისი
          გამოყენება ბევრნაირად შეიძლება.
      2:
        image: notes/unplug6_2.png
        text: 'გამოვიყენოთ უპირატესობა და შევქმნათ პროგრამები ქაღალდზე, რომელთაც კარტების
          ნახატებით გავუშვებთ. მაგალითად, შეიძლება გქონდეთ "თუ" დებულება, რომელიც
          ამბობს: თუ თქვენ მიერ ამოღებული კარტი 8-ზე მეტია, თქვენ იღებთ ქულას. თუ
          არა - ქულას იღებს თქვენი მოწინააღმდეგე. რამდენად რთული ან მარტივი უნდა იყოს
          თამაში, შეგიძლიათ დამოუკიებლად განსაზღვროთ.'
    unplug7:
      1:
        image: notes/unplug7_1.png
        text: წარმოიდგინეთ, რომ სიმღერის ტექსტს ეძებთ - სადღაც ერთხელ არის მოცემული
          მისამღერი და შემდეგ ყოველჯერ, როცა სიმღერის მიხედვით მისამღერის დროა, ტექსტის
          სანახავად იმ ადგილს უბრუნდებით. ზუსტად ასეთივეა ფუნქციის გამოძახება.
      2:
        image: notes/unplug7_2.png
        text: ამ გაკვეთილში ჩვენ განვსაზღვრავთ, სად არის ჩვენს სიმღერაში მისამღერი
          და ვიმღერებთ სიმღერას. შემდეგ დავუბრუნდებით ტექსტს და შევამჩნევთ, რომ კლასს
          არ უმღერია სიტყვა "მისამღერი", ის პირდაპირ მისამღერის ტექსტზე გადადიოდა.
          ჩვენი აზრით, ეს არის მშვენირი აღწერა იმისა, თუ რას აკეთებს პროგრამა, როცა
          ის განსაზღვრავს და იძახებს ფუნქციას.
      3:
        image: notes/unplug7_3.png
        text: 'მისამღერი ხშირად მეორდება, მაგრამ ხანდახან შეიძლება შეიცვალოს - ამის
          მაგალითად, ასე ხდება ყველასთვის ნაცნობ სიმღერაში Old Macdonald. ეს და მსგავსი
          სიმღერები, სადაც მისამღერში ცალკეული სიტყვები იცვლება, იდეალური მაგალითია
          პარამეტრების იდეის გასაცნობად: ფუნქციაში დამატებითი ინფორმაციის გასაგზავნად,
          ვაწოდებთ მას ცალკეულ სიტყვებს. როცა დავრწმუნდებით, რომ ყველამ გაიგო საკითხი,
          აიღეთ სხვა, ყველასთვის ნაცნობი სიმღერები და სცადეთ თქვენით გაარჩიოთ ისინი.'
    unplug8:
      1:
        image: notes/unplug8_1.png
        text: ჩვენი აბსტრაგირების გაკვეთილი იყენებს მედლიბების ცნობილ კონცეპტს - როცა
          ისტორიაში გამოტოვებულ ადგილებს სხვადასხვა სიტყვებით ავსებთ. ბავშვების დავალებაა
          შეავსონ თავიანთი ისტორიები თავიანთივე სიტყვებით - ჩვენ კი მათ აბსტრაქციის
          ცნებას ვუხსნით.
      2:
        image: notes/unplug8_2.png
        text: ეს ყველაფერი ეხება ფუნქციებს და იმას, როგორ შეიძლება გქონდეთ ფუნქცია
          ძირითადი სტრუქტურით და მცირე ცვლილებებით, ასევე როგორ გამოყოთ ცვლილების
          ადგილი და ყოველ ჯერზე თქვენი მონაცემით შეავსოთ, როგორც ეს Old Macdonald
          სიმღერის მისამღერში ხდება. თუ სამი მონაცემი იცვლება, მაშინ სამ პარამეტრს
          იყენებთ - რაც მაინც ძალიან მოსახერხებელია.
      3:
        image: notes/unplug8_3.png
        text: სავსებით შესაძლებელია, გქონდეთ ერთი ფუნქცია, რომელიც უამრავ პრობლემას
          არეგულირებს. ხშირად ადამიანები სხვადასხვა ამოცანების შესასრულებლად ბევრ
          ცალკეულ ფუნქციას წერენ და ვერ ხვდებიან, რომ სხვაობა მათ შორის ძალიან მცირეა.
          ამ მცირე სხვაობის გამოყოფა რომ შეეძლოთ, 14 განსხვავებული ფუნქციის მაგივრად
          ერთიც ეყოფოდათ.
    unplug9:
      1:
        image: notes/unplug9_1.png
        text: ესტაფეტური პროგრამირება ძალიან სახალისო გაკვეთილია, რომელიც კომპიუტერულ
          მეცნიერებაზე გაცილებით მეტს მოიცავს. ის განსაკუთრებით გამოგადგაბათ, თუ ატყობთ,
          რომ მოსწავლეები დაიღალნენ და უფრო ინტერაქტიული აქტივობის დროა. შესძინეთ
          კომპიუტერული მეცნიერების სწავლას მეტი ხალისი!
      2:
        image: notes/unplug9_2.png
        text: დაყავით ყველა ორ ჯგუფად და დააყენეთ ხაზებად. ყოველი ჯგუფის თავში მდგომი
          ბავშვი უნდა გაიქცეს ოთახის მეორე კუთხეში, სადაც გაქვთ გრაფიკული გამოსახულება
          და სუფთა ფურცელი. ამ ცარიელ ფურცელზე ბავშვმა უნდა დაწეროს გამოსახულების
          შექმნის პირველი ნაბიჯი, დაბრუნდეს თავის ხაზში და შეეხოს შემდეგ მონაწილეს,
          რომელიც გაიქცევა მეორე ნაბიჯის დასაწერად.
      3:
        image: notes/unplug9_3.png
        text: 'ეს ძალიან კარგი გზაა ბაგების გამოსწორების იდეის ასახსნელად: იმის გასაგებად,
          რატომ უნდა შეამოწმოთ თქვენი და თქვენამდე შესრულებული სხვა ადამიანების ნამუშევარი.
          მალევე მიხვდებით, რამდენად მნიშვნელვანია ფრთხილად წეროთ თქვენი კოდი, განსაკუთრებით,
          როცა თქვენ მთელი გუნდი გეყრდნობათ.'
    unplug10:
      1:
        image: notes/unplug10_1.png
        text: ეს აქტივობა მარტივად ხსნის, თუ როგორ მუშაობს ინტერნეტი. ტერმინოლოგიას
          გასაგები სიტყვებით ვხსნით, ისე, რომ მოსწავლეებს შეეძლოთ შეტყობინებების (მაგალითად,
          ელ. წერილების) გაგზავნის სიმულაცია.
      2:
        image: notes/unplug10_2.png
        text: 'მოსწავლეები შეტყობინებების გაგზავნის სამ მეთოდს განასახიერებენ: უსადენო
          ინტერნეტს, DSL კავშირსა და ბოჭკოვან ოპტიკას. იმათ, ვინც უსადენო ინტერნეტს
          განასახიერებენ, წერილი თავზე უნდა დაიდონ და ისე გადაიტანონ - იმიტომ რომ
          სწორედ ვაი-ფაის აქვს ყველაზე მეტი შანსი გზაში რაღაც ინფორმაცია დაკარგოს.'
      3:
        image: notes/unplug10_3.png
        text: მოსწავლეები, რომლებიც კაბელს ან DSL-ს განასახიერებენ, შეტყობინებას ხელის
          ზურგით ატარებენ - ასე ოდნავ ნაკლებია შანსი, რომ ინფორმაციას დაკარგავენ.
          ის მოსწავლეები, რომლებიც ბოჭკოვან ოპტიკას განასახიერებენ, ინფორმაციას ორივე
          ხელით დაიჭერენ. ეს აქტივობა შესანიშნავად ხნის იმას, რასაც ადამიანების უმეტესობა
          ყოველდღე იყენებს.
    unplug11:
      1:
        image: notes/unplug11_1.png
        text: ახლა კი დროა თვალი გადაავლოთ იმ ყველაფერს, რაც წინა ცხრამეტ გაკვეთილში
          ისწავლეთ - და დროა შეაქოთ თქვენი მოსწავლეები. ამ გაკვეთილებით მათ ისწავლეს
          მეტი, ვიდრე ზრდასრულების უმეტესობამ იცის კომპიუტერულ მეცნიერებაზე.
      2:
        image: notes/unplug11_2.png
        text: კლასში ან პატარა ჯგუფებში განიხილეთ მოსწავლეების საყვარელი გაკვეთილები.
          როცა გაიხსენებთ ყველაფერს, რაც ისწავლეთ, თქვენმა მოსწავლეებმა შეიძლება გამოამჟღავნონ
          თავიანთი კრეატიულობა. დაყავით ისინი ჯგუფებად და დაავალეთ შემქნან დავალებები,
          რომელთა შესრულებაც კომპიუტერის გარეშე იქნება შესაძლებელი. მიეცით თითოეულ
          ჯგუფს ძირითადი კონცეპტი, მაგალითად ფუნქცია ან ალგორითმი - და აუცილებლად
          მოიმარაგეთ ბევრი სხვადასხვა მასალა. შემდეგ მიეცით თითოეულ ჯგუფს მათი დავალების
          პრეზენტაციის საშუალება, ან დანიშნეთ დამატებითი დღე და შეასრულეთ ეს დავალებები.
      3:
        image: notes/unplug11_3.png
        text: ჩვენ, Сode.org გუნდს, გვაქვს იმედი, რომ ამ გაკვეთილების დროს ძალიან
          კარგად იხალისეთ. შეიძლება, თქვენი ოცნებაა ახალი საუკეთესო აპლიკაციის შექმნა
          ან დაავადებების დამარცხება, ან უბრალოდ პრობლემების მარტივად და ლოგიკურად
          გადაწყვეტის ოსტატობა - ეს კურსი იყო პირველი ნაბიჯი თქვენი ოცნებისკენ.
    starwars_intro:
      1:
        image: notes/starwars_intro_1.JPG
        text: გამარჯობა, მე ვარ ქეთლინ კენედი, ვარსკვლავური ომების პროდიუსერი. დღეს
          თქვენ იმუშავებთ ჩვენს ერთ-ერთ ვარსკვლავთან, BB-8-სთან. BB-8 არის სფერული
          დროიდი. ყველა მის მოქმედებასა და მოძრაობას მართავს პროგრამა. კომპიუტერული
          მეცნიერება გავლენას ახდენს ყველა ინდუსტრიაზე, მარკეტინგით დაწყებული, ჯანმრთელობის
          დაზღვევით გაგრძელებული, კინოინდუსტრიით დასრულებული. ვარსკვლავური ომების
          ბოლო ნაწილის შექმნაზე ასობით პროგრამისტი მუშაობდა.
      2:
        image: notes/starwars_intro_2.JPG
        text: გამარჯობა, მე რეიჩელ როუზი ვარ. მე ვარ ILM-ში კვლევისა და განვითარების
          განყოფილების უფროსი და ანიმაციისა და შემოქმედების გუნდს ვხელმძღვანელობ.
          ვარსკვლავური ომების ახალ ნაწილში ჩემი მოვალეობაა ვუხელმძღვანელო ხელოვანთა
          გუნდებს და ერთად შევქმნათ პერსონაჟების უფრო რეალისტური სურათი.
      3:
        image: notes/starwars_intro_3.JPG
        text: შემდეგი ერთი საათის განმავლობაში ჩვენ ავაწყობთ ვარსკვლავური ომების ჩვენს
          საკუთარ თამაშს. ჩვეულებრივ, პროგრამირება ტექსტის წერას ნიშნავს, მაგრამ ჩვენ
          ვიყენებთ ბლოკებს - პროგრამა მათი გადმოტანითა და დალაგებით იწერება. სინამდვილეში,
          თქვენ მაინც წერთ კოდს, რომელიც ბლოკებშია მოთავსებული. როცა პროგრამიერების
          საფუძვლებს ბლოკებით გავეცნობით, გადავლთ JavaScript-ზე, პროგრამირების ყველაზე
          პოპულარულ ენაზე ინტერნეტში.
      4:
        image: notes/starwars_intro_4.JPG
        text: დასაწყისისთვის, რეისთან ერთად BB-8 უნდა დავაპროგრამოთ - უნდა ვასწავლოთ
          სიარული და ნაგლეჯების შეგროვება. თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად.
          მარცხნივ არის ვარსკვლავური ომების სათამაშო სივრცე, სადაც გაეშვება თქვენი
          პროგრამა. ყოველი დონის ინსტრუქციები ქვემოთ არის მოცემული.
      5:
        image: notes/starwars_intro_5.JPG
        text: სივრცე შუაში არის ინსტრუმენტების პანელი - ამ ბლოკებიდან ყოველი არის
          ბრძანება, რომლის გაგებაც შეუძლია BB-8-ს.
      6:
        image: notes/starwars_intro_6.JPG
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
      7:
        image: notes/starwars_intro_7.JPG
        text: რა მოხდება, თუ ბლოკს "მარცხნივ_გადაადგილება();" ჩვენს სამუშაო სივრცეში
          გადავიტანთ და დავაჭერთ ღილაკს "გაშვება"? BB-8 ბადეზე ერთი ნაბიჯით მარცხნივ
          გადავა.
      8:
        image: notes/starwars_intro_8.JPG
        text: დავუშვათ მინდა, რომ BB-8-მ კიდევ რაღაც გააკეთოს გადაადგილებამარცხნივ();
          ბლოკის შემდეგ - რა გავაკეთო? შემიძლია, კიდევ ერთი ბლოკი დავუმატო ჩვენს პროგრამას.
          მე ვირჩევ ბლოკს გადაადგილებაზემოთ(); - გადმოვიტან მას გადაადგილებამარცხნივ();
          ბლოკის ქვემოთ და შევაერთებ.
      9:
        image: notes/starwars_intro_9.JPG
        text: როცა კიდევ ერთხელ დავაჭერ "გაშვებას", BB-8 შეასრულებს სამუშაო სივრცეში
          მოცემულ ბრძანებებს, ქვემოდან ზემოთ თანმიმდევრობით. თუ ბლოკის წაშლა მოგინდებათ,
          უბრალოდ გადაიტანეთ ის უკან, ინსტრუმენტების პანელზე.
      10:
        image: notes/starwars_intro_10.JPG
        text: გაშვების შემდეგ ყოველთვის შეგიძლიათ გამოიყენოთ ღილაკი "თავიდან" და BB-8
          თავიდან დაიწყებს. ახლა კი დროა!
    starwars_typing:
      1:
        image: notes/starwars_typing_1.JPG
        text: ბლოკების შიგნით JavaScript ბრძანებებს ვიყენებთ. პროფესიონალ დეველოპერებში
          JavaScript დღეს-დღეობით ყველაზე პოპოლარული ენაა. ბლოკები კი მშვენიერი გზაა
          პროგრამირების სწავლის დაასაწყებად - ასე ასწავლიან ჰარვარდსა და ბერკლიშიც.
          მაგრამ საფუძვლების დაძლევის შემდეგ კოდის უშუალოდ წერაზე გადავალთ - იმიტომ,
          რომ ასე უფრო სწრაფია.
      2:
        image: notes/starwars_typing_2.JPG
        text: ასობით ბრძანების დაწერა შეგვიძლია ისე, რომ არ დაგვჭირდეს მათი პოვნა
          ინსტრუმენტების პანელზე და მერე გადმოტანა. თქვენ ახლა სწავლობთ და ამიტომ
          საქმე ნელა წავა, მაგრამ აუცილებლად უნდა სცადოთ.
      3:
        image: notes/starwars_typing_3.JPG
        text: თქვენი სამუშაო სივრცის ზედა მარჯვენა კუთხეში შეგიძლიათ დააჭიროთ ღილაკს
          "ტექსტის ჩვენება" და ბლოკების გადატანის მაგივრად ტექსტის შეყვანა შეგეძლებათ.
      4:
        image: notes/starwars_typing_4.JPG
        text: შემდეგ გაკვეთილში ჩვენ დავიწყებთ კოდის წერას. აქ თქვენ ჯერ კიდევ შეგიძლიათ
          ან ბლოკები გადმოიტანოთ ინსტრუმენტების პანელიდან ან ჩაწეროთ ბრძანებები. როცა
          კოდის წერას დაიწყებთ, დაინახავთ დამხმარე მენიუს, რომელიც ბრძანებების შესაძლო
          სახელებს მოგაწვდით. მთელი ბრძანების დაწერის მაგივრად შეგეძლებათ მისი ამ
          სიიდან არჩევა, რაც უფრო სწრაფია. მე ყოველთვის ვიყენებ ამ ავტომატური შევსების
          ფუნქციას, როცა ვწერ კოდს.
      5:
        image: notes/starwars_typing_5.JPG
        text: როცა კოდს წერთ, აუცილებელია, ზედმიწევნით ზუსტნი იყოთ. ბრძანება აბსოლუტურად
          სწორად უნდა აკრიბოთ - არც ერთი ასო და რეგისტრი არ უნდა შეგეშალოთ, არც ფრჩხილები
          ან წერტილ-მძიმე. პატარა შეცდომაც კი გამოიწვევს იმას, რომ BB-8 ვერ გაიგებს
          კოდს და ვერც კი გაინძრევა.
      6:
        image: notes/starwars_typing_6.JPG
        text: როცა ხაზში შეცდომას უშვებთ, ედიტორი გამოჰყოფს მას - ასე თქვენ შეგიძლიათ
          შეცვალოთ ტექსტი და გამოასწოროთ შეცდომა.
      7:
        image: notes/starwars_typing_7.JPG
        text: თუ გაეჭედეთ, ყოველთვის შეგიძლიათ თავიდან დაწყება და ბლოკების რეჟიმში
          გადართვა ზედა მარჯვენა კუთხიდან. მაგრამ ახლა დროა ბეჭდვა ვცადოთ! ნუ შეუშინდებით
          შეცდომებს - შედეგის მისაღწევად ყველას სჭირდება რამდენიმე ცდა.
    starwars_events:
      1:
        image: notes/starwars_events_1.JPG
        text: გამარჯობა, მე ვარ ჩარიტა კარტერი. მე ვარ დისნეის იმაჯინარიუმის უფროსი
          პროდიუსერი. ჩემი მოვალეობაა იმ გუნდების მართვა, რომლებიც ჩვენი სტუმრების
          გასართობებს იგონებენ და ქმნიან. ჩვენ ყოველთვის ვეძებთ ჩვენი სტუმრების გამოცდილების
          გაუმჯობესების გზებს და ტექნოლოგიები ამ საკითხის ქვაკუთხედია.
      2:
        image: notes/starwars_events_2.JPG
        text: გილოცავთ, თქვენ ეს შეძელით! თქვენ დააპროგრამეთ BB-8. მე ვფიქრობ, ახლა
          მზად ვართ უფრო რთული დავალებისთვის. ახლა, როცა პროგრამირების საფუძვლები
          უკვე იცით, დავბრუნდეთ დროში და შევქმნათ თქვენი საკუთარი თამაში, მთავარ როლებში
          კი R2-D2 და C3PO გვყავდეს.
      3:
        image: notes/starwars_events_3.JPG
        text: თამაშის შესაქმნელად ისეთი რამე უნდა ვისწავლოთ, რასაც პროგრამისტები ყოველ
          დღე იყენებენ - მოვლენები. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას
          უნდა დაუცადოს. როცა ეს რაღაც - მოვლენა - მოხდება, პროგრამა გარკვეულ ქმედებას
          განახორციელებს.
      4:
        image: notes/starwars_events_4.JPG
        text: 'მოვლენა შეიძლება იყოს: მაუსის დაკლიკვა, ისრის ღილაკზე დაჭერა, ეკრანზე
          შეხება.'
      5:
        image: notes/starwars_events_5.JPG
        text: 'ახლა R2-D2 უნდა ავიდეს და გადასცეს შეტყობინება მეამბოხე პილოტს, შემდეგ
          ჩავიდეს სხვა მეამბოხე პილოტთან. მის გადასაადგილებლად გამოვიყენებთ მოვლენებს:
          ქვემოთა/ზემოთა ისრებზე ან ღილაკებზე დაჭერას.'
      6:
        image: notes/starwars_events_6.JPG
        text: ვიყენებთ მოვლენას "როცამაღლა()" და ვუმაგრებთ მას ბლოკს "ასვლა()". როცა
          მოთამაშე ზემოთა ისარს დააჭერს, გაეშვება "როცამაღლა()" ბლოკს მიმაგრებული
          კოდი. იგივეს ვაკეთბთ R2-D2-ის ქვემოთ გადასაადგილებლად.
      7:
        image: notes/starwars_events_7.JPG
        text: 'ამის გასაკეთებლად ჩვენ გამოვიყენებთ ბრძანებას როცაზემოთ(). როცა ბრძანებას
          ინსტრუმენტების პანელიდან გადმოიტანთ, შეამჩნევთ, რომ ის იწყება და მთავრდება
          ფრჩხილებით და არა წერტილ-მძიმით: ეს გვაძლევს საშუალებას, შუაში სხვა ბრძანებებიც
          ჩავსვათ. ყოველი ბრძანება, რომელსაც ამ ფრჩხილებში ჩავსვამთ, გაეშვება, როცა
          მოთამაშე დააჭერს ზემოთა ისარს.'
      8:
        image: notes/starwars_events_8.JPG
        text: ჩვენ გვინდა, რომ R2-D2 ავიდეს ზემოთ, ამიტომ ჩავსვათ ბრძანებაში ბლოკი
          "ზემოთასვლა();". იგივე გავაკეთოთ R2-D2-ის ქვემოთ გადასაადგილებლად.
      9:
        image: notes/starwars_events_9.JPG
        text: ახლა კი, იმის მაგივრად, რომ წინასწარ განვსაზღვროთ ჩვენი დროიდის ყველა
          მოძრაობა, ვასწავლოთ ღილაკებზე დაჭერის მოვლენებზე რეაგირება. ნაბიჯ-ნაბიჯ,
          თქვენი თამაში უფრო ინტერაქტიული ხდება.
    starwars_congrats:
      1:
        image: notes/starwars_congrats_1.JPG
        text: გამრჯობა, მე მქვია ელისი - მე ვარ Code.org-ის სერვისისა და პროგრამირების
          გუნდის წამყვანი. მე ვმუშაობდი ზუსტად ამ ტუტორიალზე - რომელსაც თქვენ ახლა
          გადიხართ.
      2:
        image: notes/starwars_congrats_2.JPG
        text: აი, ბოლო დონეც დაასრულეთ. გილოცავთ! თქვენ ისწავლეთ ყველაფერი, რაც გჭირდებათ
          ვარსკვლავური ომების თქვენი საკუთარი თამაშის შესაქმნელად. მეტი არც ინსტრუქციები
          და არც ამოსახნელი თავსატეხებია დარჩენილი. ახლა შეგიძლიათ საკუთარი თამაში
          შექმნათ და თქვენით აირჩიოთ, როგორი იქნება ის. ამის გარდა, რამდენიმე ახალი
          ხმა და ბრძანებაც გაქვთ.
      3:
        image: notes/starwars_congrats_3.JPG
        text: "[ლაპარაკობს მოსწავლე] მოკლედ, ჩვენ შევქმენით თამაში, რომელშიც პაფერ
          გოჭების დაჭერისას ქულები გიგროვდებათ. ხრიკი იმაშია, რომ ყოველჯერ, როცა პაფერ
          გოჭს იჭერთ, ჩნდება შტორმტრუპერი. მთელი ეკრანი სავსეა პაფერ გოჭებით და როცა
          მათგან 10,000-ს შეეხებით, იგებთ."
      4:
        image: notes/starwars_congrats_4.JPG
        text: "[საუბრობენ სტუდენტები] ჩვენ შევქმენით თამაში, რომლის წაგებაც შეუძლებელია
          და ყველფარი, რასაც კლავთ, გაძლევთ ქულებს. ჩემს პროგრამაში ადგილები შევუბრუნე
          ორ ღილაკს: როცა აჭერთ ზემოთ, პერსონაჟი მიდის ქვემოთ და როცა აჭერთ მარჯვნივ,
          პერსონაჟი მიდის მარცხნივ. ეს მართლა რთულია! ხანდახან არც თუ ისე სამართლიანი
          უპირატესობა აქვთ თამაშის დეველოპერებს - აი, მაგალითად, როგორიც მე მქონდა!"
      5:
        image: notes/starwars_congrats_5.JPG
        text: როცა მორჩებით თქვენი თამაშის შექმნას, აირჩიეთ "გაზიარება" და გაუგზავნეთ
          მიღებული ბმული თქვენს მეგობრებს ან ითამაშეთ თქვენი თამაში მობილურზე. გაერთეთ!
    starwars_blocks_intro:
      1:
        image: notes/starwars_blocks_intro_1.JPG
        text: გამარჯობა, მე ვარ ქეთლინ კენედი, ვარსკვლავური ომების პროდიუსერი. დღეს
          თქვენ იმუშავებთ ჩვენს ერთ-ერთ ვარსკვლავთან, BB-8-სთან. BB-8 არის სფერული
          დროიდი. ყველა მის მოქმედებასა და მოძრაობას მართავს პროგრამა. კომპიუტერული
          მეცნიერება გავლენას ახდენს ყველა ინდუსტრიაზე, მარკეტინგით დაწყებული, ჯანმრთელობის
          დაზღვევით გაგრძელებული, კინოინდუსტრიით დასრულებული. ვარსკვლავური ომების
          ბოლო ნაწილის შექმნაზე ასობით პროგრამისტი მუშაობდა!
      2:
        image: notes/starwars_blocks_intro_2.JPG
        text: გამარჯობა, მე რეიჩელ როუზი ვარ. მე ვარ ILM-ში კვლევისა და განვითარების
          განყოფილების უფროსი და ანიმაციისა და შემოქმედების გუნდს ვხელმძღვანელობ.
          ვარსკვლავური ომების ახალ ნაწილში ჩემი მოვალეობაა ვუხელმძღვანელო ხელოვანთა
          გუნდებს და ერთად შევქმნათ პერსონაჟების უფრო რეალისტური სურათი შორეულ გალაქტიკაში.
      3:
        image: notes/starwars_blocks_intro_3.JPG
        text: 'შემდეგი ერთი საათის განმავლობაში ჩვენ ავაწყობთ ვარსკვლავური ომების
          ჩვენს საკუთარ თამაშს და პროგრამირების საფუძვლებს ვისწავლით. ჩვეულებრივ,
          პგორამირება ტექსტის წერას ნიშნავს, მაგრამ ჩვენ ვიყენებთ ბლოკებს - პროგრამა
          მათი გადმოტანითა და დალაგებით იწერება. დავიწყოთ რეისთან ერთად BB-8-ის დაპროგრამებით:
          მან უნდა ააგროვოს ყველა ნაგლეჯი.'
      4:
        image: notes/starwars_blocks_intro_4.JPG
        text: თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად. მარცხნივ არის ვარსკვლავური
          ომების სათამაშო სივრცე, სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები
          ქვემოთ არის მოცემული.
      5:
        image: notes/starwars_blocks_intro_5.JPG
        text: სივრცე შუაში არის ინსტრუმენტების პანელი - ამ ბლოკებიდან ყოველი არის
          ბრძანება, რომლის გაგებაც შეუძლია BB-8-ს.
      6:
        image: notes/starwars_blocks_intro_6.JPG
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
      7:
        image: notes/starwars_blocks_intro_7.JPG
        text: რა მოხდება, თუ ბლოკს "მარცხნივ_გადაადგილება();" ჩვენს სამუშაო სივრცეში
          გადავიტანთ? BB-8 ბადეზე ერთი ნაბიჯით მარცხნივ გადავა.
      8:
        image: notes/starwars_blocks_intro_8.JPG
        text: დავუშვათ მინდა, რომ BB-8-მ კიდევ რაღაც გააკეთოს გადაადგილებამარცხნივ();
          ბლოკის შემდეგ - რა გავაკეთო? შემიძლია, კიდევ ერთი ბლოკი დავუმატო ჩვენს პროგრამას.
          მე ვირჩევ ბლოკს გადაადგილებაზემოთ(); - გადმოვიტან მას გადაადგილებამარცხნივ();
          ბლოკის ქვემოთ და შევაერთებ. ახლა, როცა ისევ გავუშვებს პროგრამას, BB-8 შეასრულებს
          ყველა ბრძანებას თანმიმდევრობით ზემოდან ქვემოთ.
      9:
        image: notes/starwars_blocks_intro_9.JPG
        text: თუ ბლოკის წაშლა მოგინდებათ, უბრალოდ გადაიტანეთ ის უკან, ინსტრუმენტების
          პანელზე.
      10:
        image: notes/starwars_blocks_intro_10.JPG
        text: გაშვების შემდეგ ყოველთვის შეგიძლიათ გამოიყენოთ ღილაკი "თავიდან" და BB-8
          თავიდან დაიწყებს. ახლა კი დროა!
    starwars_blocks_events:
      1:
        image: notes/starwars_blocks_events_1.JPG
        text: გამარჯობა, მე ვარ ჩარიტა კარტერი. მე ვარ დისნეის იმაჯინარიუმის უფროსი
          პროდიუსერი. ჩემი მოვალეობაა იმ გუნდების მართვა, რომლებიც ჩვენი სტუმრების
          გასართობებს იგონებენ და ქმნიან. ჩვენ ყოველთვის ვეძებთ ჩვენი სტუმრების გამოცდილების
          გაუმჯობესების გზებს და ტექნოლოგიები ამ საკითხის ქვაკუთხედია.
      2:
        image: notes/starwars_blocks_events_2.JPG
        text: გილოცავთ, თქვენ ეს შეძელით! თქვენ დააპროგრამეთ BB-8. მე ვფიქრობ, ახლა
          მზად ვართ უფრო რთული დავალებისთვის. ახლა, როცა პროგრამირების საფუძვლები
          უკვე იცით, დავბრუნდეთ დროში და შევქმნათ თქვენი საკუთარი თამაში, მთავარ როლებში
          კი R2-D2 და C3PO გვყავდეს.
      3:
        image: notes/starwars_blocks_events_3.JPG
        text: თამაშის შესაქმნელად ისეთი რამე უნდა ვისწავლოთ, რასაც პროგრამისტები ყოველ
          დღე იყენებენ - მოვლენები. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას
          უნდა დაუცადოს. როცა ეს რაღაც - მოვლენა - მოხდება, პროგრამა გარკვეულ ქმედებას
          განახორციელებს.
      4:
        image: notes/starwars_blocks_events_4.JPG
        text: 'მოვლენა შეიძლება იყოს: მაუსის დაკლიკვა, ისრის ღილაკზე დაჭერა, ეკრანზე
          შეხება.'
      5:
        image: notes/starwars_blocks_events_5.JPG
        text: 'ახლა R2-D2 უნდა ავიდეს და გადასცეს შეტყობინება მეამბოხე პილოტს, შემდეგ
          ჩავიდეს სხვა მეამბოხე პილოტთან. მის გადასაადგილებლად გამოვიყენებთ მოვლენებს:
          ქვემოთა/ზემოთა ისრებზე ან ღილაკებზე დაჭერას.'
      6:
        image: notes/starwars_blocks_events_6.JPG
        text: ჩვენ ვიღებთ "როცა_ზემოთ" მოვლენის ბლოკს და ვუმაგრებთ მას ბლოკს "ასვლა".
          როცა მოთამაშე აჭერს ზემოთა ისარს, გაეშვება კოდი, რომელიც მიმაგრებულია ბლოკს
          "როცა_ზემოთ". ზუსტად იგივეს ვაკებთ, რომ R2-D2 ქვემოთ გადავაადგილოთ. იმის
          მაგივრად, რომ მთელი კოდი წინასწარ დავწეროთ და ასე ვაკონტროლოთ ჩვენი დროიდის
          მოძრაობები, უბრალოდ მივცეთ მას საშუალება იმოძრაოს ღილაკებზე დაჭერის მოვლენების
          შესაბამისად.
      7:
        image: notes/starwars_blocks_events_7.JPG
        text: ნაბიჯ-ნაბიჯ, თქვენი თამაში უფრო ინტერაქტიული ხდება.
    starwars_blocks_congrats:
      1:
        image: notes/starwars_blocks_congrats_1.JPG
        text: გამრჯობა, მე მქვია ელისი - მე ვარ Code.org-ის სერვისისა და პროგრამირების
          გუნდის წამყვანი. მე ვმუშაობდი ზუსტად ამ ტუტორიალზე - რომელსაც თქვენ ახლა
          გადიხართ.
      2:
        image: notes/starwars_blocks_congrats_2.JPG
        text: აი, ბოლო დონეც დაასრულეთ. გილოცავთ! თქვენ ისწავლეთ ყველაფერი, რაც გჭირდებათ
          ვარსკვლავური ომების თქვენი საკუთარი თამაშის შესაქმნელად. მეტი არც ინსტრუქციები
          და არც ამოსახნელი თავსატეხებია დარჩენილი. ახლა შეგიძლიათ საკუთარი თამაში
          შექმნათ და თქვენით აირჩიოთ, როგორი იქნება ის. ამის გარდა, რამდენიმე ახალი
          ხმა და ბრძანებაც გაქვთ.
      3:
        image: notes/starwars_blocks_congrats_3.JPG
        text: "[ლაპარაკობს მოსწავლე] მოკლედ, ჩვენ შევქმენით თამაში, რომელშიც პაფერ
          გოჭების დაჭერისას ქულები გიგროვდებათ. ხრიკი იმაშია, რომ ყოველჯერ, როცა პაფერ
          გოჭს იჭერთ, ჩნდება შტორმტრუპერი. მთელი ეკრანი სავსეა პაფერ გოჭებით და როცა
          მათგან 10,000-ს შეეხებით, იგებთ."
      4:
        image: notes/starwars_blocks_congrats_4.JPG
        text: "[საუბრობენ სტუდენტები] ჩვენ შევქმენით თამაში, რომლის წაგებაც შეუძლებელია
          და ყველფარი, რასაც კლავთ, გაძლევთ ქულებს. ჩემს პროგრამაში ადგილები შევუბრუნე
          ორ ღილაკს: როცა აჭერთ ზემოთ, პერსონაჟი მიდის ქვემოთ და როცა აჭერთ მარჯვნივ,
          პერსონაჟი მიდის მარცხნივ. ეს მართლა რთულია! ხანდახან არც თუ ისე სამართლიანი
          უპირატესობა აქვთ თამაშის დეველოპერებს - აი, მაგალითად, როგორიც მე მქონდა!"
      5:
        image: notes/starwars_blocks_congrats_5.JPG
        text: როცა მორჩებით თქვენი თამაშის შექმნას, აირჩიეთ "გაზიარება" და გაუგზავნეთ
          მიღებული ბმული თქვენს მეგობრებს ან ითამაშეთ თქვენი თამაში მობილურზე. გაერთეთ!
    mc_intro:
      1:
        image: notes/mc_intro_1.JPG
        text: მე მქვია ჯენს ბერგენსტენი, მაგრამ ყველა ჯებს მეძახის. მე ვარ მაინკრაფტის
          მთავარი დეველოპერი. ჩვენი კომპანია მოჯანგი სტოკჰოლმში მდებარეობს. თუ სწორად
          მახსოვს, თერთმეტის ან თორმეტის ვიყავი, როცა პროგრამირება დავიწყე - თამაშების
          შექმნა მინდოდა. მამის ერთმა მეგობარმა მითხრა, რომ თუ თამაშების შექმნა მინდა,
          პროგრამირება უნდა ვისწავლო. აი, ასე დაიწყო ყველაფერი. მომწონს თამაშების
          არქიტექტურის მოფიქრება და შექმნა - და მაინკრაფტიც ძალიან მომწონს.
      2:
        image: notes/mc_intro_2.JPG
        text: შემდეგი საათის განმავლობაში თქვენ ისწავლით კომპიუტერული მეცნიერების
          საწყისებს - დააპროგრამებთ ალექსსა ან სტივს მაინკრაფტის სამყაროს გასავლელად.
      3:
        image: notes/mc_intro_3.JPG
        text: ჩვეულებრივ, პროგრამას ტექსტით წერენ, მაგრამ დღეს ჩვენ გამოვიყენებთ ბლოკლის,
          სისტემას, რომელიც იყენებს ვიზუალურ ბლოკებს, რომელთა გადაადგილებითაც იწერება
          პროგრამა. სინამდვილეში თქვენ Javascript კოდს შექმნით.
      4:
        image: notes/mc_intro_4.JPG
        text: კონცეპტებს, რომელთაც თქვენ ისწავლით, პროგრამისტები ყოველდღე იყენებენ
          - ისინი კომპიუტერული მეცნიერების საფუძველს წარმოადგენენ. აქ, მოჯანგში, მაინკრაფტის
          შესაქმნელად ზუსტად იგივე კონცეპტებს ვიყენებთ.
      5:
        image: notes/mc_intro_5.JPG
        text: დაწყებამდე უნდა აირჩიოთ თქვენი პერსონაჟი. მე ალექსს ავირჩევ. დავწეროთ
          კოდი პროგრამისთვის, რომელიც დაეხმარება მას ეკრანზე იმოძრაოს.
      6:
        image: notes/mc_intro_6.JPG
        text: თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად. მარცხნივ არის მაინკრაფტის
          სათამაშო სივრცე, სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები
          ქვემოთ არის მოცემული.
      7:
        image: notes/mc_intro_7.JPG
        text: სივრცე შუაში არის ინსტრუმენტების პანელი - ამ ბლოკებიდან ყოველი არის
          ბრძანება, რომელიც განსაზღვრავს ალექსის მოქმედებებს.
      8:
        image: notes/mc_intro_8.JPG
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
      9:
        image: notes/mc_intro_9.JPG
        text: რა მოხდება, თუ ბლოკს წინგადაადგილება(); ჩვენს სამუშაო სივრცეში გადავიტანთ
          და დავაჭერთ ღილაკს "გაშვება"? ალექსი ბადეზე ერთი ნაბიჯით წინ გადავა.
      10:
        image: notes/mc_intro_10.JPG
        text: დავუშვათ, გვინდა, რომ წინ გადაადგილების მერე კიდევ რამე გააკეთოს. რა
          უნდა ვქნათ? კიდევ ერთი ბლოკი დავუმატოთ ჩვენს პროგრამას. მე ავირჩევ ბლოკს
          "მარჯვნივ_მობრუნება" და მივუმაგრებ მას ბლოკს "წინ_გადაადგილება" - უნდა გადავიტანოთ
          ერთი ბლოკი მეორეს ქვემოთ და მივუახლოვოთ, სანამ არ გამოჩნდება ნარინჯისფერი
          ხაზი - მაშინ შეიძლება გავუშვათ ბლოკი და ის მიემაგრება ზემოთას. ახლა, როცა
          დავაჭერთ ღილაკს "გაშვება" ალექსი შეასრულებს ყველა ბრძანებას, თანმიმდევრობით
          ზემოდან ქვემოთ.
      11:
        image: notes/mc_intro_11.JPG
        text: თუ ბლოკის წაშლა მოგინდებათ, უბრალოდ გადაიტანეთ ის უკან, ინსტრუმენტების
          პანელზე.
      12:
        image: notes/mc_intro_12.JPG
        text: 'ცვლილებების გასაუქმებლად და საწყის პოზიციაში დასაბრუნებლად გამოიყენეთ
          სამუშაო სივრცის მარჯვენა ზედა კუთხეში განლაგებული ღილაკი "ხელახლა დაწყება".
          და კიდევ: ხედავთ პატარა სამკუთხედებს მოტრიალების ბლოკებზე? ყოველთვის, როცა
          სამკუთხედს ხედავთ, ეს ნიშნავს, რომ რამდენიმე ვარიანტიდან არჩევა შეგიძლიათ.
          დავიწყოთ კოდის წერა!'
    mc_repeat:
      1:
        image: notes/mc_repeat_1.JPG
        text: მე ვარ ლიდია უინტერსი, მოჯანგის ბრენდ-დირექტორი. ჩვენ შევქმენით პატარა
          თამაში, რომელსაც ჰქვია მაინკრაფტი.
      2:
        image: notes/mc_repeat_2.JPG
        text: მაინკრაფტში ყველაზე მეტად გამოკვლევა მიყვარს. მომწონს გამოქვაბულებში
          თავგადასავლები და რაღაცების პოვნა. მე თვითონ არ ვარ პროგარმისტი, ამიტომ
          ძალიან მაინტერესებს მაინკრაფტის გაკვეთილის გავლა და პროგრამირების სწავლა.
      3:
        image: notes/mc_repeat_3.JPG
        text: ბოლო დონეზე ბევრი წინგადაადგილების(); ბლოკი დაგვჭირდა. უფრო მარტივი
          იქნებოდა, უბრალოდ რომ გვეთქვა კომპიუტერისთვის, რომ წინგადაადგილება(); ოთხჯერ
          ან ხუთჯერ უნდა შეასრულოს. საბედნიეროდ, ეს შესაძლებელია გამეორების ციკლების
          გამოყენებით.
      4:
        image: notes/mc_repeat_4.JPG
        text: მაინკრაფტის შექმნისას ჩვენ ვიყენებთ გამეორების ციკლებს, სადაც ვათავსებთ
          ყველა საწყის მასალას სამყაროს შესაქმნელად - ანუ, ათასობით ბლოკს. ციკლებს
          პატარ-პატარა დავალებებისთვისაც ვიყენებთ, მაგალიტად, იმისთვის, რომ ალექსის
          ფეხემა იმოძრაოს, როცა ის წინ და უკან გადაადგილდება. გამეორების ციკლები პროგრამირების
          მნიშვნელოვანი ნაწილია.
      5:
        image: notes/mc_repeat_5.JPG
        text: ღამდება - უსაფრთოების მიზნით შემდეგ რადენიმე დონეზე სახლს ავაშენებთ,
          რისთვისაც გამოვიყენებთ გამეორების ბლოკს.
      6:
        image: notes/mc_repeat_6.JPG
        text: სახლის კედლის ასაშენებლად შეგვიძლია ვუთხრათ ალექსას რომ გადაადგილდესწინ();
          და დადოს ფიცარი ოთხ-ოთხჯერ, ან ვუთხრათ რომ გადაადგილდესწინ(); და დადოს ერთი
          ფიცარი, შემდეგ კი გამოვიყენოთ გამეორების ბლოკი და გავამეორებინოთ ეს მთლიანი
          მოძრაობა რამდენჯერაც საჭიროა - ამისთვის დავაჭიროთ "გამეორების" ბლოკს და
          ჩავსვათ შესაბამისი რიცხვი. ახლა კი დროა ავაშენოთ სახლი, სანამ დაღამებულა!
          იმხიარულეთ.
    mc_if_statements:
      1:
        image: notes/mc_if_statements_1.JPG
        text: ახლა კი დროა "თუ" დებულებები ვისწავლოთ. "თუ" დებულებები პროგრამირების
          საფუძველს წარმოადგენს. ისინი კომპიუტერს გადაწყვეტილების მიღებაში ეხმარებიან.
      2:
        image: notes/mc_if_statements_2.JPG
        text: ყველა კომპიუტერი, ჩემი ტელეფონის ჩათვლით, იყენებს "თუ" დებულებებს. მაგალითად,
          როცა მისი განბლოკვა მინდა, ეშვება კოდი, რომელიც ამბობს, რომ თუ მე სწორად
          შევიყვან პაროლს, ტელეფონი უნდა განიბლოკოს. სხვა შემთხვევაში კი შეცდომის
          შესახებ შეტყობინება უნდა მაჩვენოს.
      3:
        image: notes/mc_if_statements_3.JPG
        text: თუ გინდათ, რომ სტივი და ელისი სამყაროზე რეაგირებდნენ, გამოიყენეთ "თუ"
          დებულებები თქვენს კოდში. მაგალითად, თუ წინ არის ქვა, მოუხვიონ მარცხნივ.
          ან მოუხვიონ მარჯვნივ, თუ ხეს შეეჯახებიან.
      4:
        image: notes/mc_if_statements_4.JPG
        text: ამ შემთხვევაში, ჩვენ არ გვინდა ლავაში ჩავარდნა. ლავასთვის წინასწარ მომზადება
          არც ისე რთულია - ჩვენ მას ეკრანზე ვხედავთ. მაგრამ ქვების ქვეშ დამალულ ლავას
          რა ვუყოთ?
      5:
        image: notes/mc_if_statements_5.JPG
        text: ქვის მოვიპოვების შემდეგ სანამ წინ წავალთ, უნდა შევამოწმოთ, გზად ლავა
          ხომ არ არის. თუ ლავა არის, პერსონაჟის წინ უნდა დავდოთ ქვა და მხოლოდ შემდეგ
          გადავადგილდეთ - ასე ეს უსაფრთხო იქნება. ნედლეულის მოპოვების დროა! და არ
          დაგავიწყდეთ "თუ" დებულებები, გადაადგილების უსაფრთხოების უზრუნველსაყოფად.
    mc_congrats_share:
      1:
        image: notes/mc_congrats_share_1.JPG
        text: გილცოავთ! თქვენ ისწავლეთ კომპიუტერული მეცნიერების საბაზისო ბლოკები.
      2:
        image: notes/mc_congrats_share_2.JPG
        text: ახლა შეგიძლიათ გამოიყენოთ ეს ბლოკები თქვენი საკუთარი ქმნილებისთვის.
          არანაირი ინსტრუქციები და ამოსახსნელი თავსატეხები. ააწყვეთ, რაც გინდათ. თქვენი
          ჯერია, აირჩიოთ.
      3:
        image: notes/mc_congrats_share_3.JPG
        text: "[მოსწავლეების საუბარი] მალე რეალური გახდება. გაკრეჭა. მე ჩირაღდნებიდან
          ასო L გავაკეთე. მე არყის ხის ფიცრებიდან გავაკეთე A. გამოვიდა. მატყლის სახლი
          ავაშენეთ!"
      4:
        image: notes/mc_congrats_share_4.JPG
        text: როცა მორჩებით თქვენს ქმნილებას, აირჩიეთ "გაზიარება" და გაუგზავნეთ მიღებული
          ბმული თქვენს მეგობრებს. გაერთეთ!
    mc_congrats_no_share:
      1:
        image: notes/mc_congrats_no_share_1.JPG
        text: გილცოავთ! თქვენ ისწავლეთ კომპიუტერული მეცნიერების საბაზისო ბლოკები.
      2:
        image: notes/mc_congrats_no_share_2.JPG
        text: ახლა შეგიძლიათ გამოიყენოთ ეს ბლოკები თქვენი საკუთარი ქმნილებისთვის.
          არანაირი ინსტრუქციები და ამოსახსნელი თავსატეხები. ააწყვეთ, რაც გინდათ. თქვენი
          ჯერია, აირჩიოთ.
      3:
        image: notes/mc_congrats_no_share_3.JPG
        text: "[მოსწავლეების საუბარი] მალე რეალური გახდება. გაკრეჭა. მე ჩირაღდნებიდან
          ასო L გავაკეთე. მე არყის ხის ფიცრებიდან გავაკეთე A. გამოვიდა. მატყლის სახლი
          ავაშენეთ!"
      4:
        image: notes/mc_congrats_no_share_4.JPG
        text: ახლა კი შეგიძლიათ, რაც მოგესურვებათ, ის გააკეთოთ. იმხიარულეთ!
    gumball_intro:
      1:
        image: notes/gumball_intro_1.JPG
        text: თუ გინდათ თქვენი საკუთარი თამაში შექმნათ, გეტყვით, რომ ეს საკმაოდ მარტივია.
          პროგრამირების საფუძვლებს უნდა გაეცნოთ და ცოტა ხანში თქვენ მიერ დაწერილი
          თამაშით გაერთობით.
      2:
        image: notes/gumball_intro_2.JPG
        text: 'გაქვთ საყვარელი ვიდეო-თამაში? სწორედ მსგავსი თამაშების შექმნას ვისწავლით
          თამაშების ლაბორატორიაში. კარგ თამაშებში არის ისტორია და ყოველ ისტორიაში
          არიან პერსონაჟები. პერსონაჟები საუბრობენ, მოძრაობენ და აქვთ ერთმანეთთან
          კონტაქტი. შეიძლება ქულებიც დააგროვონ, გააჩნია თამაშის წესებს. დღეს ამ ყველაფრის
          რიგრიგობით გაკეთებას ვისწავლით: ჩვენ სუფთა ფურცლიდან დავწერთ თამაშს, რომლის
          გაზიარება და ტელეფონზე თამაში შეგვეძლება.'
      3:
        image: notes/gumball_intro_3.JPG
        text: დღეს ჩვენ ვისწავლით, როგორ გავაკეთოთ ეს ყველაფერი ნაბიჯ-ნაბიჯ, მხიარული
          პერსონაჟების მონაწილეობით. შემდეგ კი ნულიდან დავწერთ თამაშს, რომლის გაზიარებაც
          ნებისმიერთან შეგვეძლება.
      4:
        image: notes/gumball_intro_4.JPG
        text: თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად. მარცხნივ არის სათამაშო სივრცე,
          სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ქვემოთ არის მოცემული.
      5:
        image: notes/gumball_intro_5.JPG
        text: ეს შუა ნაწილი არის ინსტრუმენტების პანელი და ყოველი ბლოკი არის კოდი.
      6:
        image: notes/gumball_intro_6.JPG
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
      7:
        image: notes/gumball_intro_7.JPG
        text: პირველ რიგში, ბლოკები უნდა მიემაგროს ნარინჯისფერ ბლოკს "გაშვებისას".
          რამდენიმე ბლოკის ერთად შეკვრა შეგიძლიათ - მიუახლოვეთ ისინი ერთმანეთს, სანამ
          არ გაჩნდება ყვითელი ხაზი და შემდეგ შეაერთეთ.
      8:
        image: notes/gumball_intro_8.JPG
        text: პირველ თავსატეხში პერსონაჟებს რაღაც უნდა ვათქმევინოთ. ამისთვის მივუმაგროთ
          ბლოკს "გაშვებისას" ბლოკი "თქმა" და ჩავწეროთ მასში ჩვენი შეტყობინება. როცა
          ყველა ბლოკს დაალაგებთ, გაუშვით პროგრამა და ნახეთ, რა გამოგივიდათ.
      9:
        image: notes/gumball_intro_9.JPG
        text: დაიწყეთ და ბოლოს თქვენ საკუთარი თამაშის შექმნას შეძლებთ. თქვენ გამოიყენებთ
          ყველა სახის პერსონაჟებს, რომელთაც შეეძლებათ უერთიერთობა, ქულების დაგროვება,
          სხვადასხვა საგნების სროლა და ერთმანეთის გაქრობა. ყველაფერი თქვენზეა დამოკიდებული!
    gumball_events:
      1:
        image: notes/gumball_events_1.JPG
        text: ახლა ისეთ რამეს ვისწავლით, რასაც პროგრამისტები ყოველ დღე იყენებენ -
          მოვლენებს. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას უნდა დაუცადოს.
          როცა ეს რაღაც - მოვლენა - მოხდება, თამაში გარკვეულ ქმედებას განახორციელებს.
      2:
        image: notes/gumball_events_2.JPG
        text: 'მოვლენა შეიძლება იყოს: მაუსის დაკლიკვა, ქვედა ან ზედა ისრის ღილაკზე
          დაჭერა, ეკრანზე შეხება.'
      3:
        image: notes/gumball_events_3.JPG
        text: ახლა უნდა ვქნათ ისე, რომ პერსონაჟი მიესალმოს დედამიწელებს, როცა მასზე
          დაკლიკავენ. გამოიყენეთ ბლოკი "როცა დაკლიკავენ" და მიუმაგრეთ მას ბლოკი "თქმა".
          როცა მოთამაშე დაკლიკავს პერსონაჟს, მოხდება ყველაფერი, რაც მიმაგრებულია ბლოკს
          "როცა დაკლიკავენ".
      4:
        image: notes/gumball_events_4.JPG
        text: კიდევ გვაქვს ბლოკები "როცა ისარი". თუ ამ ბლოკებს მოძრაობის ბლოკებს მიუმაგრებთ,
          თქვენი პერსონაჟები ზემოთ, ქვემოთ, მარჯვნივ ან მარცხნივ იმოძრავებენ. ხედავთ?
          თქვენი თამაში უფრო და უფრო ინტერაქტიული ხდება.
    gumball_repeat:
      1:
        image: notes/gumball_repeat_1.JPG
        text: წარმოიდგინეთ, რომ რაღაც უსასრულოდ უნდა გაიმეოროთ. იმედია, ეს არასდროს
          არ მოგიწევთ - იმიტომ რომ ამ საქმეს კომპიუტერებიც მშვენივრად უმკლავდებიან.
      2:
        image: notes/gumball_repeat_2.JPG
        text: ეს არის ბლოკი "გამეორება უსასრულოდ". ყველაფერი, რაც ამ ბლოკშია, თამაშში
          უსასრულოდ გამეორდება. თუ გვინდა, რომ პერსონაჟი რაღაც ქმედებას იმეორებდეს
          ისე, რომ მოთამაშეს არაფრის გაკეთება არ უწევდეს, ამ ქმედების ბლოკები "გამეორება
          უსასრულოდ" ბლოკში უნდა ჩავსვათ.
      3:
        image: notes/gumball_repeat_3.JPG
        text: შემდეგ თავსატეხში ჩვენი მიზანია დავეხმაროთ პერსონაჟს საქმის უწყვეტად
          შესრულებაში. გამეორების ფუნქციების კარგად შესწავლა უამრავ დროს დაგიზოგავთ
          მომავალში, როცა თქვენს საკუთარ თამაშს დაწერთ.
    iceage_intro:
      1:
        image: notes/iceage_intro_1.JPG
        text: თუ გინდათ თქვენი საკუთარი თამაში შექმნათ, გეტყვით, რომ ეს საკმაოდ მარტივია.
          პროგრამირების საფუძვლებს უნდა გაეცნოთ და ცოტა ხანში თქვენ მიერ დაწერილი
          თამაშით გაერთობით.
      2:
        image: notes/iceage_intro_2.JPG
        text: 'გაქვთ საყვარელი ვიდეო-თამაში? სწორედ მსგავსი თამაშების შექმნას ვისწავლით
          თამაშების ლაბორატორიაში. კარგ თამაშებში არის ისტორია და ყოველ ისტორიაში
          არიან პერსონაჟები. პერსონაჟები საუბრობენ, მოძრაობენ და აქვთ ერთმანეთთან
          კონტაქტი. შეიძლება ქულებიც დააგროვონ, გააჩნია თამაშის წესებს. დღეს ამ ყველაფრის
          რიგრიგობით გაკეთებას ვისწავლით: ჩვენ სუფთა ფურცლიდან დავწერთ თამაშს, რომლის
          გაზიარება და ტელეფონზე თამაში შეგვეძლება.'
      3:
        image: notes/iceage_intro_3.JPG
        text: დღეს ჩვენ ვისწავლით, როგორ გავაკეთოთ ეს ყველაფერი ნაბიჯ-ნაბიჯ, მხიარული
          პერსონაჟების მონაწილეობით. შემდეგ კი ნულიდან დავწერთ თამაშს, რომლის გაზიარებაც
          ნებისმიერთან შეგვეძლება.
      4:
        image: notes/iceage_intro_4.JPG
        text: თქვენი ეკრანი დაყოფილია სამ მთავარ ნაწილად. მარცხნივ არის სათამაშო სივრცე,
          სადაც გაეშვება თქვენი პროგრამა. ყოველი დონის ინსტრუქციები ქვემოთ არის მოცემული.
      5:
        image: notes/iceage_intro_5.JPG
        text: ეს შუა ნაწილი არის ინსტრუმენტების პანელი და ყოველი ბლოკი არის კოდი.
      6:
        image: notes/iceage_intro_6.JPG
        text: თეთრი სივრცე მარჯვნივ არის სამუშაო სივრცე - აქ დაიწერება ჩვენი პროგრამა.
      7:
        image: notes/iceage_intro_7.JPG
        text: პირველ რიგში, ბლოკები უნდა მიემაგროს ნარინჯისფერ ბლოკს "გაშვებისას".
          რამდენიმე ბლოკის ერთად შეკვრა შეგიძლიათ - მიუახლოვეთ ისინი ერთმანეთს, სანამ
          არ გაჩნდება ყვითელი ხაზი და შემდეგ შეაერთეთ.
      8:
        image: notes/iceage_intro_8.JPG
        text: პირველ თავსატეხში პერსონაჟებს რაღაც უნდა ვათქმევინოთ. ამისთვის მივუმაგროთ
          ბლოკს "გაშვებისას" ბლოკი "თქმა" და ჩავწეროთ მასში ჩვენი შეტყობინება. როცა
          ყველა ბლოკს დაალაგებთ, გაუშვით პროგრამა და ნახეთ, რა გამოგივიდათ.
      9:
        image: notes/iceage_intro_9.JPG
        text: დაიწყეთ და ბოლოს თქვენ საკუთარი თამაშის შექმნას შეძლებთ. თქვენ გამოიყენებთ
          ყველა სახის პერსონაჟებს, რომელთაც შეეძლებათ უერთიერთობა, ქულების დაგროვება,
          სხვადასხვა საგნების სროლა და ერთმანეთის გაქრობა. ყველაფერი თქვენზეა დამოკიდებული!
    iceage_events:
      1:
        image: notes/iceage_events_1.JPG
        text: ახლა ისეთ რამეს ვისწავლით, რასაც პროგრამისტები ყოველ დღე იყენებენ -
          მოვლენებს. მოვლენა აცნობებს თქვენს პროგრამას, რომ რაღაცას უნდა დაუცადოს.
          როცა ეს რაღაც - მოვლენა - მოხდება, თამაში გარკვეულ ქმედებას განახორციელებს.
      2:
        image: notes/iceage_events_2.JPG
        text: 'მოვლენა შეიძლება იყოს: მაუსის დაკლიკვა, ქვედა ან ზედა ისრის ღილაკზე
          დაჭერა, ეკრანზე შეხება.'
      3:
        image: notes/iceage_events_3.JPG
        text: ახლა უნდა ვქნათ ისე, რომ პერსონაჟმა რამე თქვას, როცა მასზე დაკლიკავენ.
          გამოიყენეთ ბლოკი "როცა დაკლიკავენ" და მიუმაგრეთ მას ბლოკი "თქმა". როცა მოთამაშე
          დაკლიკავს პერსონაჟს, მოხდება ყველაფერი, რაც მიმაგრებულია ბლოკს "როცა დაკლიკავენ".
      4:
        image: notes/iceage_events_4.JPG
        text: კიდევ გვაქვს ბლოკები "როცა ისარი". თუ ამ ბლოკებს მოძრაობის ბლოკებს მიუმაგრებთ,
          თქვენი პერსონაჟები ზემოთ, ქვემოთ, მარჯვნივ ან მარცხნივ იმოძრავებენ. ხედავთ?
          თქვენი თამაში უფრო და უფრო ინტერაქტიული ხდება.
    iceage_repeat:
      1:
        image: notes/iceage_repeat_1.JPG
        text: წარმოიდგინეთ, რომ რაღაც უსასრულოდ უნდა გაიმეოროთ. იმედია, ეს არასდროს
          არ მოგიწევთ - იმიტომ რომ ამ საქმეს კომპიუტერებიც მშვენივრად უმკლავდებიან.
      2:
        image: notes/iceage_repeat_2.JPG
        text: ეს არის ბლოკი "გამეორება უსასრულოდ". ყველაფერი, რაც ამ ბლოკშია, თამაშში
          უსასრულოდ გამეორდება. თუ გვინდა, რომ პერსონაჟი რაღაც ქმედებას იმეორებდეს
          ისე, რომ მოთამაშეს არაფრის გაკეთება არ უწევდეს, ამ ქმედების ბლოკები "გამეორება
          უსასრულოდ" ბლოკში უნდა ჩავსვათ.
      3:
        image: notes/iceage_repeat_3.JPG
        text: შემდეგ თავსატეხში ჩვენი მიზანია დავეხმაროთ პერსონაჟს საქმის უწყვეტად
          შესრულებაში. გამეორების ფუნქციების კარგად შესწავლა უამრავ დროს დაგიზოგავთ
          მომავალში, როცა თქვენს საკუთარ თამაშს დაწერთ.
    mc_2016_intro:
      1:
        image: notes/mc_2016_intro_1.jpg
        text: სალამი, მე ჯენსი მქვია და მე მაინკრაფტის მთავარი დიზაინერი ვარ. შემდეგი
          ერთი საათის განმავლობაში თქვენ მაინკრაფტის საკუთარ თამაშს შექმნით. ეს უკვე
          ჰგავს მაინკრაფტს, მაგრამ სამყარო გაჩერებულია. ცხვარი არ მოძრაობს, ქათამი
          კვერცხს არ დებს და ზომბიც თავისთვის დგას გაუნძრევლად. ახლა თქვენი ჯერია
          – დაამატეთ კოდი და გააცოცხლეთ მაინკრაფტის სამყარო.
      2:
        image: notes/mc_2016_intro_2.jpg
        text: 'მე მქვია მელისა და ჩემი საქმე მაინკრაფტის ფარგლებში არის მომხმარებლის
          კვლევა. რაც ნამდვილად მაინტერესებს არის ის, თუ როგორ შედიან ადამიანები ინტერაქციაში
          ტექნოლოგიებთან, ასე რომ ამ სამუშაოს ფარგლებში ერთმანეთს კომპიუტერულ მეცნიერებასა
          და ფსიქოლოგიას ვუთავსებ ერთმანეთს: როგორ ფიქრობენ და იქცევიან ადამიანები.'
      3:
        image: notes/mc_2016_intro_3.jpg
        text: როგორც ხედავთ, თქვენი ეკრანი სამ ძირითად ნაწილადაა დაყოფილი. 1) მარცხნივ
          მაინკრაფტის თამაშია. ახლა სამყარო გაყინულია, მაგრამ ამას კოდის მეშვეობით
          გამოვასწორებთ.
      4:
        image: notes/mc_2016_intro_4.jpg
        text: 2) ეს შუა ნაწილი არის ინსტრუმენტების პანელი. ამ ბლოკებიდან ყოველი არის
          ბრძანება, რომლის გაგებაც შეუძლია მაინკრაფტის არსებას, მაგალითად ქათამსა
          ან ცხვარს.
      5:
        image: notes/mc_2016_intro_5.jpg
        text: 3) მარჯვნივ განთავსებულ სივრცეს ჰქვია სამუშაო სივრცე - აქ დაიწერება
          ჩვენი პროგრამა.
      6:
        image: notes/mc_2016_intro_6.jpg
        text: თუ დაგავიწყდებათ, რა უნდა გააკეთოთ, ყოველი დონის ინსტრუქციები ზემოთაა
          მოცემული.
      7:
        image: notes/mc_2016_intro_7.jpg
        text: ქათმის დაპროგრამებით დავიწყებთ. გადმოვიტანოთ სამუშაო სივრცეში ბრძანება
          "წინ გადაადგილება". როცა "გაშვებას" დავაჭერ, ქათამი წინ ერთ ნაბიჯით გადაადგილდება.
          იმისთვის, რომ მან სვლა განაგრძოს, კიდევ ერთ "წინ გადაადგილების" ბლოკს გადმოვიტან
          პირველის ქვემოთ. (დაველოდოთ, სანამ ბლოკებს შორის ხაზი განათდება, შემდეგ
          გავუშვათ ბლოკი და ის წინას მიემაგრება). ახლა, თუ "გაშვებას" დავაჭერ, ქათამი
          ორ ნაბიჯს გადადგამს.
      8:
        image: notes/mc_2016_intro_8.jpg
        text: თუ ბლოკის წაშლა მოგინდებათ, უბრალოდ გადაიტანეთ ის უკან, ინსტრუმენტების
          პანელზე.
      9:
        image: notes/mc_2016_intro_9.jpg
        text: '"გაშვების" შემდეგ ყოველთვის შეგიძლიათ დააჭიროთ ღილაკს "თავიდან დაწყება",
          რომ... თავიდან დაიწყოთ! მოკლედ, ახლა თქვენი ჯერია შექმნათ მაინკრაფტის სამყარო.
          იხალისეთ!'
    mc_2016_loops:
      1:
        image: notes/mc_2016_loops_1.jpg
        text: 'სალამი, მე ლიზა ვარ - პროგრამული უზრუნველყოფის დეველოპერი მაინკრაფტში.
          თამაშში სხვადასხვა ცხოველებსა და მტრებს მე ვქმნი. მაგალითად, ერთ-ერთი ცხოველი,
          რომელზეც ვმუშაობდი, იყო ოცელოტი. იდეა მდგომარეობდა შემდეგში: მოთამაშეს უნდა
          შეძლებოდა ეჭმია ოცელოტისთვის თევზი და მოეშინაურებინა ცხოველი.'
      2:
        image: notes/mc_2016_loops_2.jpg
        text: ჩვენ ადამიანები ვართ და მალევე გვბეზრდება ერთისა და იმავე მოქმედების
          ბევრჯერ გამეორება. მაგრამ, აი, რა განასხვავებს ჩვენგან კომპიუტერებს - მათ
          შეუძლიათ ერთი და იგივე მილიონჯერ ან თუნდაც მილიარდჯერ გაიმეორონ - და მოწყენას
          ვერც კი შეატყობთ. ასეთ გამეორებას ჰქვია ციკლი და მაინკრაფტის ყოველი არსება
          იყენებს ციკლს.
      3:
        image: notes/mc_2016_loops_3.jpg
        text: წინა ჯერ ჩვენმა ქათამმა ეკრანზე მოძრაობა დაიწყო, მაგრამ მერე გაჩერდა.
          მაინკრაფტში ქათმები დაუსრულებლად დადიან აქეთ–იქით. ავიღოთ "მუდმივად" ციკლი
          ჩვენი იარაღების პანელიდან და უსასრულოდ ვამოძრავოთ ჩვენი ქათამი. ციკლები
          ძალიან გამოგადგებათ მაინკრაფტის თქვენეული ვერსიის შექმნისას და უამრავ დროს
          დაგიზოგავთ.
    mc_2016_events:
      1:
        image: notes/mc_2016_events_1.jpg
        text: შემდეგ დონეზე შეგიძლიათ აირჩიოთ - სტივი იქნებით თუ ალექსი. კლავიატურაზე
          ისრებზე დაჭერით შეგიძლიათ იმოძრავოთ ქვემოთ, ზემოთ, მარცხნივ და მარჯვნივ.
          ახლა უკვე ყველგან შეგიძლიათ მისვლა. ქმნილების გამოსაყენებლად უბრალოდ მიუახლოვდით,
          დაუდექით პირისპირ და ჰარეს დააჭირეთ.
      2:
        image: notes/mc_2016_events_2.jpg
        text: თუ კონტაქტურ ეკრანს იყენებთ, სამოძრაოდ შეეხეთ ეკრანს შესაბამისი მიმართულებით.
          იმისთვის, რომ თქვენს წინაშე მდებარე საგანი გამოიყენოთ, დააჭირეთ ეკრანს.
      3:
        image: notes/mc_2016_events_3.jpg
        text: და რა უნდა მოხდეს მათი გამოყენებისას? მაინკრაფტის სამყაროში შეკრეჭისას
          ცხვარი მატყლს ყრის, ძროხა დატყმისას გარბის, ქრიფერები კი მოახლოვებისას ფეთქდებიან.
          ეს ყველაფერი მოვლენების წყალობით ხდება. მოვლენა ეუბნება თქვენს პროგრამას,
          რომ დააკვირდეს, როდის მოხდება რაღაც კონკრეტული მოვლენა - შემდეგ კი შესაბამისი
          ქმედება განახორციელოს.
      4:
        image: notes/mc_2016_events_4.jpg
        text: ჯერ–ჯერობით მხოლოდ ერთი მოვლენა გამოიყენეთ. კოდი, რომელსაც სვამთ "შექმნისას"
          სლოტში გაეშვება, როცა თქვენი ქმნილება შეიქმნება ან როცა თამაში დაიწყება.
          რამდენიმე მომდევნო დონეზე ახალი მოვლენების სლოტები გაგიჩნდებათ, მაგალითად,
          "შეხებისას", რომელიც გაეშვება, როცა არსებას შეეხებით ან "გამოყენებისას",
          რომელიც, შესაბამისად, არსების გამოყენებისას გაეშვება. თუ გინდათ, რომ თქვენი
          ზომბი გაქრეს მზის ამოსვლისას, ჩადეთ ეს ქმედება სლოტში "როცა დღეა"
    mc_2016_spawn:
      1:
        image: notes/mc_2016_spawn_1.jpg
        text: თამაშებში გამოჩენა იგივეა, რაც შექმნა. ამ დონეზე მზის ჩასვლისას ზომბები
          უნდა გამოვაჩინოთ. ამისთვის კი "როცა ღამეა" ბლოკი უნდა გამოვიყენოთ.
      2:
        image: notes/mc_2016_spawn_2.jpg
        text: რადგანაც გვინდა, რომ ზომბები ღამ-ღამობით ჩნდებოდნენ, "როცა ღამეა" ბლოკის
          ქვემოთ უნდა დავამატოთ ბლოკი "ზომბების გაჩენა". როცა ზომბები გაჩნდებიან,
          ყოველი მათგანი იმ კოდს შეასრულებს, რომელიც მათი "გაჩენისას" სლოტშია გაწერილი.
          აბა, იხალისეთ!
    mc_2016_congrats:
      1:
        image: notes/mc_2016_congrats_1.jpg
        text: გილოცავთ! თქვენ ისწავლეთ როგორ გააცოცხლოთ მაინკრაფტის სამყარო კომპიუტერული
          მეცნიერების ბრძანებების გამოყენებით! ახლა დეველოპერი ხართ! ახლა უკვე ყველა
          ბრძანება და ქმნილება იცით. თქვენი ასარჩევია, რა მოხდება.
      2:
        image: notes/mc_2016_congrats_2.jpg
        text: როცა მორჩებით თქვენი თამაშის შექმნას, აირჩიეთ "გაზიარება" და გაუგზავნეთ
          მიღებული ბმული თქვენს მეგობრებს ან ითამაშეთ თქვენი თამაში მობილურზე. გაერთეთ!
          მე პირადად ერთი სული მაქვს, როდის შევძლებ, ვითამაშო მაინკრაფტის თქვენი ვერსია.
    applab_intro_welcome:
      1:
        image: notes/applab_intro_welcome_1.png
        text: My name is Mei'lani. I'm an intern at code.org and I'm also a computer
          science student. I like computer science because it's really creative. I
          get to be the problem solver. I get to make everything function how I want
          it to. But I also get to be the designer. I get to be the artist and choose
          everything on the creative side of it.
      2:
        image: notes/applab_intro_welcome_2.png
        text: Making your own apps is easy with App Lab! Whether you're new to coding
          or have some experience. App Lab is a great tool for building new apps and
          sharing them with your friends.
      3:
        image: notes/applab_intro_welcome_3.png
        text: This is a App Lab. On the left side is your app. On the right side is
          the code that will make it run. You build your program by dragging in blocks
          from the toolbox. To start you'll just have one block called 'setProperty'.
      4:
        image: notes/applab_intro_welcome_4.png
        text: The set property block changes the look of the elements on your screen.
          Like the buttons, labels, or even the screen itself. First you need to decide
          which element you want to change. If you hover over an element in your app
          you can see the name or ID here. Then go select that ID from the first drop
          down.
      5:
        image: notes/applab_intro_welcome_5.png
        text: Elements have lots of properties you can change like their text color,
          background color or font size. You can see the full list and choose which
          property you want to change in the second drop down.
      6:
        image: notes/applab_intro_welcome_6.png
        text: The last drop down is where you'll write the value you want to use value
          you want to use. The block will make a suggestion for you. But you can always
          type in different colors or numbers yourself.
      7:
        image: notes/applab_intro_welcome_7.png
        text: Once you're done, the block reads a bit like a sentence:'Set button1's
          background color to green.' Hit run to see the changes you're building in
          code. If you reset you can drag in more blocks to change other things about
          your app. Like the text!
      8:
        image: notes/applab_intro_welcome_8.png
        text: For this tutorial we'll be working in block mode but App Lab also supports
          working in text.
      9:
        image: notes/applab_intro_welcome_9.png
        text: Either way you'll be programming in JavaScript, the language of the
          web. Each level has a goal, instructions and an image of what you're aiming
          to create.
      10:
        image: notes/applab_intro_welcome_10.png
        text: If you're ever stuck, click on this picture and it will show you exactly
          how to complete the level. But see if you can do it on your own first.
      11:
        image: notes/applab_intro_welcome_11.png
        text: Once you've completed the goal for this level click Finish to move on.
          That's all there is to it! Hit the orange "continue" button to go to the
          next level and start your adventure with an App Lab!
    applab_intro_events:
      1:
        image: notes/applab_intro_events_1.png
        text: Apps are really cool because it's kind of like starting your own business
          I mean, you get to design everything from the ground up, you get to manage
          everything, and you're the owner of this piece of work that you just created
          with code.
      2:
        image: notes/applab_intro_events_2.png
        text: Now that you can change the look of your app let's make it interactive
          by responding to events! Events are user actions like clicking a button,
          scrolling through a menu, or hovering over a picture. Interactive apps need
          ways to respond to events, like playing a sound when I click this button.
          To do this in App Lab you need to use a new block called 'onEvent'.
      3:
        image: notes/applab_intro_events_3.png
        text: This program sets the screen to blue. I want the screen to turn green
          when I click this button. First I'll need to drag in an onEvent block. By
          hovering I know the button's ID is "bigButton" so I'll select that in the
          first drop-down.
      4:
        image: notes/applab_intro_events_4.png
        text: Next I'll choose the type of event. There's lots of options you can
          pick from but right now I'll leave it as a regular old click.
      5:
        image: notes/applab_intro_events_5.png
        text: 'Finally I''ll add code inside the on event that will change the background
          color of the screen. You can read this block like a sentence: "On the event
          that the button is clicked run all this code."'
      6:
        image: notes/applab_intro_events_6.png
        text: Let's test it. Blocks outside an onEvent still run right away so the
          screen starts blue.
      7:
        image: notes/applab_intro_events_7.png
        text: And when I click the big button the code inside my onEvent runs and
          my screen turns green.
      8:
        image: notes/applab_intro_events_8.png
        text: If you want to change more things after the event, like the text on
          the screen just add more code to the onEvent
      9:
        image: notes/applab_intro_events_9.png
        text: To make your program respond to more events add more onEvent blocks.
          Just make sure not to put them inside of each other. Now it's time to try
          it out for yourself. Have fun!
    applab_intro_sounds:
      1:
        image: notes/applab_intro_sounds_1.png
        text: Next you'll learn about adding images and sounds to your app. Let's
          start by checking out the sound options.
      2:
        image: notes/applab_intro_sounds_2.png
        text: In the tool box you'll find a new block called "playSound". Drag it
          into the workspace. You can pick a sound to play by clicking the drop-down
          then clicking "Choose".
      3:
        image: notes/applab_intro_sounds_3.png
        text: From here you can either upload a sound file from your computer, or
          search for a sound from the sound library. The sound library has lots of
          different categories like instruments, background music or animals.
      4:
        image: notes/applab_intro_sounds_4.png
        text: Once you've got the sound you want, click "Choose". When this block
          runs, it will play the sound you chose.
      5:
        image: notes/applab_intro_sounds_5.png
        text: To add images to your elements you can just use the setProperty block.
          Select the image property in the second drop-down
      6:
        image: notes/applab_intro_sounds_6.png
        text: Then select "Choose" from the third drop down.
      7:
        image: notes/applab_intro_sounds_7.png
        text: From here you can upload an image from your computer or you can look
          through a huge library of icons in the icon library.
      8:
        image: notes/applab_intro_sounds_8.png
        text: Back in code mode you can use the "setProperty" block to change the
          icon color of your icon. Once you've picked what image your icon to use
          click "Run" to see how it looks.
      9:
        image: notes/applab_intro_sounds_9.png
        text: That's all there is to it! Now you can start adding images and sounds
          to make your apps even more fun and dynamic.
    applab_intro_designmode:
      1:
        image: notes/applab_intro_designmode_1.png
        text: To build your own apps you're going to need to start designing screens
          and elements from scratch. App Lab makes this easy to do with Design Mode.
      2:
        image: notes/applab_intro_designmode_2.png
        text: Use the switch on top of your app to go into Design Mode.
      3:
        image: notes/applab_intro_designmode_3.png
        text: You can add new elements by dragging them onto the screen. You can move
          them around to different locations and change their size by dragging the
          bottom right corner.
      4:
        image: notes/applab_intro_designmode_4.png
        text: To change an element's properties use the controls on the right. For
          example, it's really easy to change this button's text, color, and font
          size.
      5:
        image: notes/applab_intro_designmode_5.png
        text: When you add a new element to your screen it'll get a generic ID like
          button1. It's a good idea to change this button's ID to something more meaningful
          like "rightButton". So that you'll know which one it is when you go to the
          program.
      6:
        image: notes/applab_intro_designmode_6.png
        text: If you add an element to your app by mistake, just drag it out or hit
          the delete.
      7:
        image: notes/applab_intro_designmode_7.png
        text: You can add entirely new screens to your app by dragging in a screen
          element
      8:
        image: notes/applab_intro_designmode_8.png
        text: From the drop-down at the top you can quickly switch back and forth
          between the screens you create.
      9:
        image: notes/applab_intro_designmode_9.png
        text: Inside your app, you'll need a way to switch between all of these screens,
          so the setScreen block has been added to the toolbox. Use "setScreen" inside
          the "onEvent" block to change screens at the click of a button.
      10:
        image: notes/applab_intro_designmode_10.png
        text: In the next few levels you'll be working on a single project. First
          you'll add a button then you'll add a new screen and finally you'll write
          code so that the button switches to the new screen.
    applab_intro_share:
      1:
        image: notes/applab_intro_share_1.png
        text: Now that you've learned some of the basics of App Lab like adding buttons,
          sounds, images, text and new screens you can make all sorts of apps.
      2:
        image: notes/applab_intro_share_2.png
        text: In the next level you'll find the app you just finished building. With
          a little creativity, you can turn this into a personality quiz for your
          friends, a greeting card that you can share with your family or a choose-your-own-adventure
          game. All of these apps are just a combination of the skills you've already
          learned, and I bet you can come up with even more.
      3:
        image: notes/applab_intro_share_3.png
        text: Once you're done with your app you can easily send it to your phone
          to see how it looks. Just click "Share" and enter your phone number here.
      4:
        image: notes/applab_intro_share_4.png
        text: You'll receive a text message that'll let you open up your app instantly.
      5:
        image: notes/applab_intro_share_5.png
        text: You can also share a link to your app over social media or post it to
          the code.org public gallery for other people to play and share.
      6:
        image: notes/applab_intro_share_6.png
        text: You've just scratched the surface of what App Lab can do. Full App Lab
          features more advanced user interactions, new screen elements and even a
          built-in database so you can quickly build full featured apps. At "code.org/applab"
          you'll find the full tool and lots of ideas if you want to keep going.
      7:
        image: notes/applab_intro_share_7.png
        text: Thanks for coming along the ride. Now go build and share your first
          app, and keep on building apps with App Lab!
    mc_2017_agent_intro:
      1:
        image: notes/mc_2017_agent_intro_1.png
        text: 'Stacy: Stampy, Lizzy, Preston - thank you for coming with me. What
          I want to show you is just over this mesa plateau. I think you''re going
          to love it!'
      2:
        image: notes/mc_2017_agent_intro_2.png
        text: Wait a minute - there's a hole in the track! (screaming)
      3:
        image: notes/mc_2017_agent_intro_3.png
        text: 'Is everyone okay? Stampy: Ah, I see the problem. Look! There was a
          hole in the track. Stacy: Really, Stampy? Lizzy: Maybe we should gather
          blocks to fix it. Preston: Let''s make it a race. First one back to the
          top wins. Stacy: Ok, on your mark, get set, GO! Ok, I''m just gonna gather
          some of this terracotta. Wait. Guys, I can''t mine! Preston: Same. Lizzy:
          I can''t either. Stacy: Ok, that is really strange. Stampy, can you mine?
          Stampy: I can''t mine! Stacy: Ok, everyone stay calm. Stampy: Is the game
          broken? Stacy: If it is, how do we fix it? Lizzy: I don''t know. Stampy:
          Does anyone know how to write Minecraft code?'
      4:
        image: notes/mc_2017_agent_intro_4.png
        text: "(poof) Preston: What is that? Stampy: I've never seen one of these
          before. Lizzy: It's so adorable! Stacy: Is it...is it tameable? Preston:
          Okay, what is going on? Someone needs to go back to the real world and fix
          this.  All: Not it! Stacy: Not i- (Sigh.) Ok, I'll go."
      5:
        image: notes/mc_2017_agent_intro_5.png
        text: Oh, okay, hey, so I'm in the real world now. I'm going to go try to
          find the Minecraft offices.
      6:
        image: notes/mc_2017_agent_intro_6.png
        text: But, I'm going to need your help. Start doing the tutorial, start learning
          how to code, and I'll catch up with you guys after a few levels, okay? Wish
          me luck! I think it's this way. Ow! Cactus! I'm okay!
      7:
        image: notes/mc_2017_agent_intro_7.png
        text: To complete the Hour of Code challenge, you'll need to write code to
          program the agent. You'll work together with The Agent to clear any obstacles
          in your path, so you can pick up the items you'll need for your journey.
          Only the Agent can place and break blocks, and only you can collect items.
          Your screen is split into three main parts. On the left is Minecraft.
      8:
        image: notes/mc_2017_agent_intro_8.png
        text: The middle area is the toolbox with commands that the Agent can understand.
      9:
        image: notes/mc_2017_agent_intro_9.png
        text: And on the right, is the workspace. That's where you stack the commands
          to build your program to control the Agent.
      10:
        image: notes/mc_2017_agent_intro_10.png
        text: The Agent can walk, turn, and activate pressure plates. It can also
          destroy blocks and place blocks. When it places the block like these minecart
          rails, it places it underneath itself.
      11:
        image: notes/mc_2017_agent_intro_11.png
        text: თუ დაგავიწყდებათ, რა უნდა გააკეთოთ, ყოველი დონის ინსტრუქციები ზემოთაა
          მოცემული.
      12:
        image: notes/mc_2017_agent_intro_12.png
        text: If you want to try again, you can hit the blue reset button to reset
          everything to where it started. And if you need to delete a block of code,
          drag it from your workspace to the toolbox. Remember to hit run to get the
          Agent moving. Okay, go ahead and try out the first few levels. Good luck!
    mc_2017_repeat:
      1:
        image: notes/mc_2017_repeat_1.png
        text: 'Stampy: I wonder what Stacy is up to?'
      2:
        image: notes/mc_2017_repeat_2.png
        text: 'Stacy: Woah, I think I''m in the right place. This is amazing!'
      3:
        image: notes/mc_2017_repeat_3.png
        text: I feel like I'm back in Minecraft! Hello. How are you? Hello?
      4:
        image: notes/mc_2017_repeat_4.png
        text: 'Oh, there''s a creeper. You don''t do anything, do you? Katie: Stacy?
          Stacy:Hi, Katie? Katie: Yes, welcome to Minecraft!'
      5:
        image: notes/mc_2017_repeat_5.png
        text: 'Stacy: This is amazing. So you work here every day as a developer,
          right? Katie: Yeah, it''s pretty awesome. I''m a developer on the Minecraft
          marketplace team. Stacy: How many coding languages do you know? Katie: In
          my career I''ve probably worked with over a dozen. Stacy: A dozen? Katie:
          Yeah. Stacy: So now, you wouldn''t happen to know anything about this little
          golem guy that calls himself the Agent? Katie: We use the Agent to do things
          that Steve or Alex can''t, like go across lava. Stacy: Well, I want to learn
          how to code, and they want to learn how to code, so what is one of the first
          things that you need to know when you''re learning?'
      6:
        image: notes/mc_2017_repeat_6.png
        text: 'Katie: Well, you need to learn how to use loops. Loops are things that
          developers write to give commands to a computer that can be run over and
          over again. Stacy: Got it, so I think there''s actually some of that coming
          up in the levels ahead, so go ahead and give loops a try.'
      7:
        image: notes/mc_2017_repeat_7.png
        text: In the next level, you can use a loop to move the Agent along the path.
          Drag the repeat block into the workspace and place the move forward block
          inside the repeat block. This tells the computer to do the same thing many
          times in a row without having to drag a whole bunch of blocks into the workspace.
          You can choose how many times to repeat by putting a number in the repeat
          block.
      8:
        image: notes/mc_2017_repeat_8.png
        text: You can put turns and multiple commands in the repeat block too, but
          for now try using a repeat to move the Agent forward a few steps. Remember,
          if you get stuck on a puzzle you can always hit the blue reset button and
          try again.
      9:
        image: notes/mc_2017_repeat_9.png
        text: 'If you are thinking about having a cool job like Katie''s, go ahead
          and click the show code button when you finish every level. That''s going
          to actually show you the Javascript code that someone like Katie uses when
          she''s actually programming Minecraft. Katie: Yeah, good luck everyone!'
    mc_2017_functions:
      1:
        image: notes/mc_2017_functions_1.png
        text: 'Preston: I''m not trying to brag, but I''m pretty good at parkour.
          Lizzy: Let''s sleep so it''s day when Stacy comes back.'
      2:
        image: notes/mc_2017_functions_2.png
        text: 'Stacy: Ok guys, I am back from the Minecraft offices, and I think I
          know how to solve the problem I''m having in my game. I think I can use
          a function. Let me just open this.'
      3:
        image: notes/mc_2017_functions_3.png
        text: So a function is a specific set of instructions to accomplish a certain
          task, kind of like a recipe. In the next few levels, you'll have access
          to functions that you can use to solve the puzzles.
      4:
        image: notes/mc_2017_functions_4.png
        text: Look at the code in the function when it's in the workspace to see what
          it does.
      5:
        image: notes/mc_2017_functions_5.png
        text: Then, find the block with that name in the toolbox and drag it from
          the toolbox to the when run block.
      6:
        image: notes/mc_2017_functions_6.png
        text: Remember, you can use the same function every time you need to run the
          same set of instructions to do something, like build a bridge. Good luck,
          I know you can do it!
    mc_2017_congratulations:
      1:
        image: notes/mc_2017_congratulations_1.png
        text: 'Preston: Congratulations!'
      2:
        image: notes/mc_2017_congratulations_2.png
        text: 'Lizzy: Congratulations!'
      3:
        image: notes/mc_2017_congratulations_3.png
        text: 'Stampy: Congratulations, you did it!'
      4:
        image: notes/mc_2017_congratulations_4.png
        text: 'Stacy: Congratulations guys, you totally rocked that! And now that
          you''ve completed the Hour of Code, you can start coding in Minecraft. You''ve
          learned about loops, functions, and what a software Agent does.'
      5:
        image: notes/mc_2017_congratulations_5.png
        text: Now, it's time for the free play level, where you are the developer.
          Use any remaining time to write your own functions to explore, mine, and
          build.
      6:
        image: notes/mc_2017_congratulations_6.png
        text: 'You can take the code that you write in this level into your Minecraft
          world on Minecraft: Education Edition. Just click ''Finish'' and follow
          the instructions for getting the link to use in your world. to continue
          coding with the Agent. Have fun, and good job!'
      7:
        image: notes/mc_2017_congratulations_7.png
        text: 'Stacy: And I''m back! Okay, you guys, this is the Agent! Let me show
          you what it can do. Look, it''s doing it! I told it to build a staircase
          out of these terra cotta blocks, now we can just use this to get out of
          here. And you guys, it''s not just staircases. I can tell the Agent to do
          anything I want, and it will do it for me.'
      8:
        image: notes/mc_2017_congratulations_8.png
        text: 'Stampy: How did you do that? Stacy: It was easy, actually. I just used
          code!'
    csd_concept_how_computers_work:
      1:
        image: notes/csd_concept_how_computers_work_1.png
        text: 'Everywhere you look, computers are changing the world. Whether they''re
          on our desktops, in our homes, our pockets, or just about anywhere else.
          But while most of us use this revolutionary technology daily, we don''t
          often ask: "How do computers work?" In this series, you''re going to learn
          how computers really work, starting with what makes a computer a computer.
          Then, you''ll look at how information is represented inside the computer
          using tiny electrical signals going on and off at mind-boggling speeds.'
      2:
        image: notes/csd_concept_how_computers_work_2.png
        text: After that, you'll learn how computers use circuits to do everything
          from simple math to simulating entire virtual worlds. Next, you'll zoom
          out and look at the different parts of a computer that actually input, output,
          and store all that information. Finally, you'll take a look at what code
          actually is and how software controls hardware. So whether you're just curious
          about the devices you use every day or you want to design the innovations
          of the future, the first step is learning how computers work.
    csd_concept_computer:
      1:
        image: notes/csd_concept_computer_1.png
        text: My name is May-Li Khoe and I'm a designer and an inventor. So some of
          the things I've designed have been at Apple, and now I design products for
          kids to use so that they can have an easier time in school. My other jobs
          include DJ-ing and dancing.
      2:
        image: notes/csd_concept_computer_2.png
        text: Computers are everywhere! They're in people's pockets, they're in people's
          cars, people have them on their wrists. They might be in your backpack right
          now. But what makes a computer a computer? What does make a computer a computer
          anyway? And how does it even work?
      3:
        image: notes/csd_concept_computer_3.png
        text: Hi I'm Nat! I was one of the original designers of the Xbox. I've been
          working with computers since I was maybe seven years old and now I work
          on virtual reality. As humans, we've always built tools to help us solve
          problems. Tools like a wheelbarrow, a hammer, or a printing press, or a
          tractor-trailer.
      4:
        image: notes/csd_concept_computer_4.png
        text: All of these inventions helped us with manual work. Over time, people
          began to wonder if a machine could be designed and built to help us with
          the thinking work we do, like solving equations or tracking the stars in
          the sky. Rather than moving or manipulating physical things like dirt and
          stone, these machines would need to be designed to manipulate information.
          As the pioneers of computer science explored how to design a thinking machine,
          they realized that it had to perform four different tasks.
      5:
        image: notes/csd_concept_computer_5.png
        text: It would need to take input, store information process it and then output
          the results. Now this might sound simple, but these four things are common
          to all computers. That's what makes a computer a computer.
      6:
        image: notes/csd_concept_computer_6.png
        text: Computers started out as basic calculators, which was already really
          awesome at the time, and they were only manipulating numbers back then.
          But now we can use them to talk to each other, we can use them to play games,
          control robots, and do any crazy thing that you could probably imagine.
          Modern computers look nothing like those clunky old machines but they still
          do these same four things.
      7:
        image: notes/csd_concept_computer_7.png
        text: First, we're going to talk about input. You can tell computers what
          to do with the keyboard, you can tell them what to do with the mouse, the
          microphone, the camera. All these different inputs give a computer information,
          which is then stored in memory.
      8:
        image: notes/csd_concept_computer_8.png
        text: A computer's processor takes information from memory. It manipulates
          it or changes it using an algorithm, which is just a series of commands.
          And then it sends the processed information back to be stored in memory
          again. This continues until the processed information is ready to be output.
      9:
        image: notes/csd_concept_computer_9.png
        text: How a computer outputs information depends on what the computer is designed
          to do. A computer display can show text, photos, videos, or interactive
          games -- even virtual reality! The output of a computer may even include
          signals to control a robot.
      10:
        image: notes/csd_concept_computer_10.png
        text: And who knows what the computers of tomorrow will be like? My hope is
          that you get to help decide what you want the computers of tomorrow to look
          like. But across all computers, regardless of the different types of technology
          they use, they're always doing those same four things. They take in information,
          they store it as data, they process it, and then they output the results.
    csd_concept_binary_data:
      1:
        image: notes/csd_concept_binary_data_1.png
        text: Hi! My name is Limor Fried, and I'm an engineer here at Adafruit Industries.
          And this is where I do engineering and design, and I design circuits for
          fashion and music and technology.
      2:
        image: notes/csd_concept_binary_data_2.png
        text: My name is Federico Gomez Suarez, and I'm a software developer with
          Microsoft Hack for Good. And I look into using technology to help us solve
          some of the big social problems of our times.
      3:
        image: notes/csd_concept_binary_data_3.png
        text: You may have heard that computers work on ones and zeros. But almost
          nobody today actually deals directly with these ones and zeros. But ones
          and zeroes do play a big role in how computers work on the inside.
      4:
        image: notes/csd_concept_binary_data_4.png
        text: Inside a computer are electric wires and circuits that carry all the
          information in a computer. How do you store or represent information using
          electricity?
      5:
        image: notes/csd_concept_binary_data_5.png
        text: Well, if you have a single wire with electricity flowing through it,
          the signal could either be on or off. That's not a lot of choices, but it's
          a really important start. With one wire, we can represent a yes or no, true
          or false, a one or zero, or anything else with only two options. This on/off
          state of a single wire is called a bit, and it's the smallest piece of information
          a computer can store.
      6:
        image: notes/csd_concept_binary_data_6.png
        text: 'If you use more wires you get more bits: more ones and zeros. With
          more bits you can represent more complex information. But to understand
          that, we need to learn about something called the binary number system.'
      7:
        image: notes/csd_concept_binary_data_7.png
        text: 'In the decimal number system, we have ten digits from zero to nine,
          and that''s how we''ve all learned to count. In the binary number system,
          we only have two digits: zero and one. With these two digits, we can count
          up to any number.'
      8:
        image: notes/csd_concept_binary_data_8.png
        text: Here's how this works. In a decimal number system we're all used to,
          each position in a number has a different value. There's a 1 position, the
          10 position, the 100 position, and so on. For example, a 9 in the 100 position
          is a 900. In binary, each position also carries a value. But instead of
          multiplying by 10 each time, we multiply by 2. So there's the 1 position,
          the 2 position, the 4 position, the 8 position, and so on. For example,
          the number 9 in binary is 1001. To calculate the value, we add 1 times 8,
          plus 0 times 4, plus 0 times 2, plus 1 times 1. Almost nobody does this
          math because computers do it for us. What's important is that any number
          can be represented with only ones and zeros, or by a bunch of wires that
          are on or off. The more wires you use, the larger the numbers you can store.
          With 8 wires, you can store numbers between 0 and 255. That's 8 ones. With
          just 32 wires, you can store all the way from 0 to over 4 billion. Using
          the binary number system, you can represent any number you like.
      9:
        image: notes/csd_concept_binary_data_9.png
        text: But what about other types of information? Like text, images, or sound?
          It turns out that all these things can also be represented with numbers.
          Think of all the letters in the alphabet. You could assign a number to each
          letter. A could be 1, B could be 2, and so on. You can then represent any
          word or paragraph as a sequence of numbers. And as we saw, these numbers
          can be stored as on or off electrical signals. Every word you see on every
          webpage or your phone is represented using a system like this.
      10:
        image: notes/csd_concept_binary_data_10.png
        text: Now, let's consider photos, videos, and all the graphics you see on
          a screen.
      11:
        image: notes/csd_concept_binary_data_11.png
        text: All of these images are made out of teeny dots called pixels, and each
          pixel has a color. Each of the colors can be represented with numbers. When
          you consider the typical image has millions of these pixels, and the typical
          video shows 30 images per second now we're talking about a lot of data here.
      12:
        image: notes/csd_concept_binary_data_12.png
        text: Every sound is basically a series of vibrations in the air. Vibrations
          can be represented graphically as a waveform. Any point on this waveform
          can be represented by a number. And this way, any sound can be broken down
          into a series of numbers. If you want higher quality sound, you will pick
          32-bit audio or an 8-bit audio. More bits means a higher range of numbers.
      13:
        image: notes/csd_concept_binary_data_13.png
        text: When you use a computer to write code or make your own app, you're not
          dealing directly with these ones and zeros. But you will be dealing with
          images or sound or video. So if you want to understand how computers work
          on the inside, it all comes down these simple ones and zeros and the electrical
          signals in the circuits behind them.
    csd_concept_circuits_logic:
      1:
        image: notes/csd_concept_circuits_logic_1.png
        text: One of the coolest things I've discovered about circuits is circuitry
          can be an art form like if I have a creative idea, I can get that creative
          idea out using circuits. So if you have ideas, you can use technology to
          make those ideas come to life.
      2:
        image: notes/csd_concept_circuits_logic_2.png
        text: Every input or output of a computer is effectively a type of information,
          which can be represented by on or off electrical signals or ones and zeros.
      3:
        image: notes/csd_concept_circuits_logic_3.png
        text: In order to process the information that comes in as input, and to make
          the information that is output, a computer needs to modify and combine the
          input signals. To do this, a computer uses millions of teeny electronic
          components, which come together to form circuits.
      4:
        image: notes/csd_concept_circuits_logic_4.png
        text: Let's take a closer look at how circuits can modify and process information
          that's represented in ones and zeros. This is an incredibly simple circuit.
          It takes an electrical signal, on or off, and it flips it. So if the signal
          you give it is a 1, the circuit gives you a 0, and if you give the circuit
          a 0, it gives you a 1. The signal that goes in is not the same as the signal
          that comes out, and so we call this circuit NOT.
      5:
        image: notes/csd_concept_circuits_logic_5.png
        text: More complicated circuits can take multiple signals and combine them,
          and give you a different result. In this example, a circuit will take two
          electrical signals, now each one might be a 1 or a 0. If either of the signals
          coming in is a 0, then the result is also a 0. This circuit will only give
          you a 1, if the first signal and the second signal are both a 1, and so
          we call the circuit AND.
      6:
        image: notes/csd_concept_circuits_logic_6.png
        text: There are many small circuits like this that perform simple logical
          calculations. By connecting these circuits together, we can make more complex
          circuits that perform more complex calculations.
      7:
        image: notes/csd_concept_circuits_logic_7.png
        text: For example, you can make a circuit that adds 2 bits together called
          an adder. This circuit takes in 2 individual bits, each one a 1 or a 0,
          and adds them together to calculate the sum. The sum can be 0 plus 0 equals
          0, 0 plus 1 equals 1, or 1 plus 1 equals 2. You need two wires coming out
          because it can take up to two binary digits to represent the sum. Once you
          have a single adder for adding two bits of information, you can put together
          multiples of these adder circuits side-by-side to add together much larger
          numbers.
      8:
        image: notes/csd_concept_circuits_logic_8.png
        text: For example, here's how an 8-bit adder adds the numbers 25 and 50. Each
          number is represented using 8 bits, resulting in 16 different electrical
          signals that go into the circuit. The circuit for an 8-bit adder has lots
          of little adders inside of it, which together, calculate the sum.
      9:
        image: notes/csd_concept_circuits_logic_9.png
        text: Different electrical circuits can perform other simple calculations
          like subtraction or multiplication. In fact, all the information processing
          your computer does is just lots and lots of small simple operations put
          together. Each individual operation done by a computer is so, so simple
          it could be done by a human, but these circuits inside computers are way
          way faster.
      10:
        image: notes/csd_concept_circuits_logic_10.png
        text: Back in the day, these circuits were big and clunky, and an 8-bit adder
          could be as big as a fridge, and it would take minutes for them to perform
          a simple calculation. Today, computer circuits are microscopic in size,
          and way way faster. Why are smaller computers also faster? Well, because
          the smaller the circuit is, the less distance the electrical signal has
          to go. Electricity moves at just about the speed of light, which is why
          modern circuits can perform billions of calculations per second.
      11:
        image: notes/csd_concept_circuits_logic_11.png
        text: So whether you're playing a game, recording a video, or exploring the
          cosmos, everything you could possibly do with technology requires lots of
          information to be processed extremely quickly. Underneath all this complexity
          is just lots of teeny little circuits that turn binary signals into websites,
          videos, music, and games. These circuits can even help us decode DNA to
          diagnose and cure disease. So what would you like to do with all these circuits?
    csd_concept_memory_cpu_input_output:
      1:
        image: notes/csd_concept_memory_cpu_input_output_1.png
        text: Hi, my name is Madison Maxey. I have a company called Loomia, and we
          focus on making smart fabrics for smart clothing and smart soft good products.
          The sky's the limit when it comes to textiles.
      2:
        image: notes/csd_concept_memory_cpu_input_output_2.png
        text: My name is Danielle Applestone, and I'm CEO of Othermachine Company.
          We build a desktop milling machine. A milling machine takes a rotating cutting
          tool and moves it through material to create a 3D object.
      3:
        image: notes/csd_concept_memory_cpu_input_output_3.png
        text: Under the hood, all computers do the same four basic things. They input
          information, store and process the information, and then, output information.
          Each of these things is done by a different part of the computer.
      4:
        image: notes/csd_concept_memory_cpu_input_output_4.png
        text: There are input devices that take input from the outside world and convert
          it into binary information. There is memory to store this information. There's
          a central processing unit or CPU, where all the calculations are done. And,
          finally, there are output devices that take information and convert it into
          a physical output.
      5:
        image: notes/csd_concept_memory_cpu_input_output_5.png
        text: Let's talk about input first. Computers can take many different types
          of input, like the keyboard of a computer, the touchpad of a phone, a camera,
          a microphone, or a GPS. But even the sensors on a car, a thermostat, or
          a drone are also different input devices.
      6:
        image: notes/csd_concept_memory_cpu_input_output_6.png
        text: Now, let's look at a simple example of how input travels through a computer
          and becomes output. When you press a key on your keyboard - let's say the
          letter "B". The keyboard converts the letter to a number. That number is
          sent as binary, ones and zeros, into the computer.
      7:
        image: notes/csd_concept_memory_cpu_input_output_7.png
        text: Starting from this number, the CPU calculates how to display the letter
          "B" pixel by pixel. The CPU requests step-by-step instructions from memory,
          which tell it how to draw the letter "B". The CPU runs these instructions
          and stores the results as pixels in memory.
      8:
        image: notes/csd_concept_memory_cpu_input_output_8.png
        text: Finally, this pixel information is sent in binary to the screen. The
          screen is an output device, which converts the binary signals into the tiny
          lights and colors that make up what you see.
      9:
        image: notes/csd_concept_memory_cpu_input_output_9.png
        text: This all happens so quickly it feels instantaneous, but to display each
          letter a computer runs thousands of instructions, starting from the moment
          your finger presses the key point.
      10:
        image: notes/csd_concept_memory_cpu_input_output_10.png
        text: In that example, the output device was the screen, but there are many
          different types of output which take a binary signal from the computer and
          do something in the physical world. For example, a speaker will play sound,
          and a 3D printer will print an object. Output devices can also control physical
          motion like a robotic arm, the motor of a car, or the cutting tool of the
          milling machine that my company makes. New types of inputs and outputs let
          computers interact with the world in entirely new ways. This has been helped
          out by improvements to the speed and size of the memory and CPU.
      11:
        image: notes/csd_concept_memory_cpu_input_output_11.png
        text: The more complicated a task is and the more information that is input
          or output, the more processing power and memory a computer needs. Typing
          letters on a screen may be easy but to do complicated 3d graphics or record
          a high-definition movie, modern computers often have multiple CPUs to process
          all that information and many gigabytes of memory to store it.
      12:
        image: notes/csd_concept_memory_cpu_input_output_12.png
        text: 'No matter what it is you want to do with the computer, every single
          action is about: inputting information from the physical world, storing
          and processing that information, and getting some output back into the physical
          world.'
    csd_concept_hardware_software:
      1:
        image: notes/csd_concept_hardware_software_1.png
        text: Hi, my name is Erica Gomez and I'm an engineering manager at Amazon.com.
          One of the best things about working in tech, and at Amazon in particular,
          is that I get to bring my dog with me to work every day. My job is to help
          make sure software gets out the door and her job is to nap under my desk
          and snore very loudly.
      2:
        image: notes/csd_concept_hardware_software_2.png
        text: 'My name is Jerome Holman, and I''m a Program Manager on Team Xbox and
          I have a really fun job: Basically bringing the hardware and the software
          together to give you all the games that you love on your Xbox.'
      3:
        image: notes/csd_concept_hardware_software_3.png
        text: When you look inside a computing device you see a bunch of circuits,
          chips, wires, speakers, plugs, and all sorts of other stuff. This is the
          hardware.
      4:
        image: notes/csd_concept_hardware_software_4.png
        text: But what you don't see is the software. Software is all of the computer
          programs, or code, running on this machine. Software can be anything from
          apps and games to webpages and the data science software that me and my
          teams use at Amazon to understand how customers behave.
      5:
        image: notes/csd_concept_hardware_software_5.png
        text: But how do the hardware and the software interact with one another?
          Let's start at looking at a computer's central processing unit, or CPU.
      6:
        image: notes/csd_concept_hardware_software_6.png
        text: The CPU is the master chip that controls all the other parts of the
          computer. A CPU needs to do different things so inside it has smaller, simpler
          parts that handle specific tasks. It has circuits to do simple math and
          logic. It has other circuits to send and receive information to and from
          different parts of the computer.
      7:
        image: notes/csd_concept_hardware_software_7.png
        text: The real magic of the CPU is how it knows which circuits to use and
          when to use them. The CPU receives simple commands that tell it which circuit
          to use to do a specific job. For example, an "add" command tells the CPU
          to use its outer circuit to calculate a new number. And then the "store"
          command tells the CPU to use a different circuit to save that result into
          memory.
      8:
        image: notes/csd_concept_hardware_software_8.png
        text: Just like numbers, all of these simple commands can be represented in
          binary ones and zeros or on and off electrical signals. The binary commands
          are stored in memory and the CPU fetches and executes them in sequence one
          after the other. This sequence of commands is, in fact, a very simple computer
          program.
      9:
        image: notes/csd_concept_hardware_software_9.png
        text: Binary code is the most basic form of software and it controls all the
          hardware of a computer. These days, nobody writes software in binary. It
          would take forever!
      10:
        image: notes/csd_concept_hardware_software_10.png
        text: Today, the software we write looks more like this (Python), or this
          (Ruby), or even this (Blockly). Programming languages like these let you
          type in commands in something that looks a lot like English.
      11:
        image: notes/csd_concept_hardware_software_11.png
        text: To draw a rectangle on the screen, you just need a single command. This
          high-level command is converted into hundreds, or thousands, of simpler
          binary commands that the CPU understands. Software tells the CPU what to
          do, but when you're listening to music, and browsing the web, and chatting
          with a friend, your computer is running multiple pieces of software all
          at once.
      12:
        image: notes/csd_concept_hardware_software_12.png
        text: So, how do all of these programs get on the computer in the first place,
          and how can the CPU run them all at once? To find out we'll have to take
          a look at the operating system.
      13:
        image: notes/csd_concept_hardware_software_13.png
        text: The operating system of the computer is the master program that manages
          how software gets to use the hardware of the computer. For example, I helped
          create the Windows operating system that runs on most personal computers.
      14:
        image: notes/csd_concept_hardware_software_14.png
        text: The operating system is a program with special abilities that let it
          control the other software on the computer. It lets you install new programs
          by loading them into your computer's memory. It decides when a program is
          run by the central processing unit, and whether that program can access
          the computer's input and output devices. And when you think your computer
          is running many programs at once, in reality, it's the operating system
          that's quickly switching between programs sharing that CPU for fractions
          of a second.
      15:
        image: notes/csd_concept_hardware_software_15.png
        text: Inside every computer is an operating system managing software that
          controls the computer's hardware.
      16:
        image: notes/csd_concept_hardware_software_16.png
        text: The software is a series of commands made of simple binary code, and
          that binary code is just electrical signals flowing through billions of
          tiny circuits.
      17:
        image: notes/csd_concept_hardware_software_17.png
        text: Computers have the potential to do all kinds of amazing things. But
          the only thing that makes the computer smart, or useful, is you. When you
          learn to code you get to define the problem you want to solve, and write
          the software that turns those ideas into reality.
