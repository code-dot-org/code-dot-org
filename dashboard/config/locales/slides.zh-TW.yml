"zh-TW":
  slides:
    maze_intro:
      1:
        image: notes/hoc1_1.jpg
        text: 歡迎來到你的第一個一小時玩程式課程！讓我們立刻開始你的程式設計初體驗吧。
      2:
        image: notes/hoc1_2.jpg
        text: 我們將使用 Blockly，一種視覺化的編程語言，讓你用拖曳和放置的方式編寫程式。
      3:
        image: notes/hoc1_3.jpg
        text: 大多數程式是用文字輸入，但 Blockly 是視覺的。每個程式積木相當於一行「真正的」程式碼。
      4:
        image: notes/hoc1_4.jpg
        text: 您將學習的是電腦科學的基礎，從製作應用程式到控制火星車都有用到這些概念。
      5:
        image: notes/hoc1_5.jpg
        text: 程式（Program）是讓你的電腦遵循的一連串指令。
      6:
        image: notes/hoc1_6.jpg
        text: 你的第一個程式的目標就是，讓憤怒鳥通過迷宮，抓到綠豬。
      7:
        image: notes/hoc1_7.jpg
        text: 左側是迷宮，也就是你的程式運行的地方。每個關卡的指示會顯示在迷宮下方。
      8:
        image: notes/hoc1_8.jpg
        text: 中間的工具箱是用來控制憤怒鳥的指令，你會用到這些來建立你的程式。
      9:
        image: notes/hoc1_9.jpg
        text: 右邊是您的工作區，在那裡，您可以從工具箱中拖曳積木來建置程式。若要刪除一個積木，請將積木拖曳到角落裡的垃圾桶。
      10:
        image: notes/hoc1_10.jpg
        text: 每個積木都是個指令。如果你拖曳一個「移動-向前」積木到你的工作區，然後點擊「運行」程式，這隻鳥就會在迷宮移動一格。
      11:
        image: notes/hoc1_11.jpg
        text: 要執行多個動作，可以將許多程式積木拖到工作區並將它們連接在一起。這隻鳥會由上而下依序執行這些指令。
      12:
        image: notes/hoc1_12.jpg
        text: 如果您運行了一個程式，想要把它修正後再試，可以點擊「重置」按鈕。
      13:
        image: notes/hoc1_13.jpg
        text: 讓我們去抓那些豬吧！
    artist_intro:
      1:
        image: notes/stage5_1.jpg
        text: 嗨，我是 JR！每一個車隊都需要計算機科學的協助來贏得比賽。他們分析車子的數據，讓它跑得更快。
      2:
        image: notes/stage5_2.jpg
        text: 在這些關卡中，你將扮演一名四處走動並留下繪畫線條的藝術家。
      3:
        image: notes/stage5_3.jpg
        text: 這個程式積木的意思是「向前移動 100 像素」。像素指的是電腦螢幕上的小點點。
      4:
        image: notes/stage5_4.jpg
        text: 這個積木說的是「向右轉 90 度」。這會讓你的角色轉向指定的角度，就像在迷宮關卡的轉向積木一樣。
      5:
        image: notes/stage5_5.jpg
        text: 點擊這些積木中的箭頭來改變藝術家的動作，使他向前移動或是轉彎。試著隨意玩玩並熟悉這些新積木的功能。
    farmer_intro:
      1:
        image: notes/stage9_1.jpg
        text: 嗨，我是 Paola！在這些關卡中，你是一個農夫，必須將田地整平，好用來種植農作物。
      2:
        image: notes/stage9_2.jpg
        text: 你必須幫助她移除所有的土堆，還有填滿所有的坑洞。
      3:
        image: notes/stage9_3.jpg
        text: 新的積木「移除1」將從小土堆移除 1 鏟的泥土，「填充1」會往坑洞裡填入 1 鏟的泥土。
      4:
        image: notes/stage9_4.jpg
        text: 每一個土堆和坑洞的大小都不相同，所以你必須告訴農夫要使用的鏟數來完成工作。
    flappy_intro:
      1:
        image: 標記/flappy01.jpg
        text: 嗨，我是 Katie！有一個讓人興奮的事情，關於計算機科學，是電腦程式可以做到互動。
      2:
        image: 標記/flappy02.jpg
        text: 當有人在電腦或手機上點擊、觸控、輸入，在電腦或手機上的時候，就會產生一個事件（event），當一個「事件」發生時，就會由一些程式碼來決定接下來該做甚麼。
      3:
        image: 標記/flappy03.jpg
        text: '舉個例子，您可能有一個事件處理常式（EVENT-HANDLER），像是「當滑鼠被點擊時，播放一個音效」 '
      4:
        image: 標記/flappy04.jpg
        text: 你聽過 FlappyBird （笨鳥先飛）這個遊戲嗎？通過使用事件處理常式，我們將學習編製我們自己的 FlappyBird，就叫它像素鳥遊戲吧！
      5:
        image: 標記/flappy05.jpg
        text: 你用拖曳積木所建立的程式（每個積木代表了一個個電腦指令），在其背後，這些積木都代表了一個真正的程式碼。
      6:
        image: 標記/flappy06.jpg
        text: '如果你看到工作區上有一些綠色的積木，那是我們為你準備的，稱為事件處理常式（event handlers）。 '
      7:
        image: 標記/flappy07.jpg
        text: 如果你想讓鳥在你點擊滑鼠時「拍打翅膀」，你可以添加「拍打翅膀」積木到事件處理常式的下面，那樣一來當你在遊戲中點擊滑鼠時，這隻鳥就會拍打翅膀了。
      8:
        image: 標記/flappy08.jpg
        text: 在這個活動的每個關卡，我們會介紹新類型的事件（綠色）積木，你可以決定在下方添加適當的積木以作為這些事件的回應。
      9:
        image: 標記/flappy09.jpg
        text: 當你看到一個像這樣的向下箭頭時，就表示你可以變更一些設置，像是當像素鳥撞到地面時要發出什麼聲音。
      10:
        image: 標記/flappy10.jpg
        text: 在最後的關卡，你將能夠創建自己的遊戲並將它分享給你的朋友。祝玩得愉快！
    loop_times:
      1:
        image: notes/hoc2_1.jpg
        text: 嗨，我是 Mark！讓我們學習一下迴圈（loops）。使用迴圈可以要電腦重複任何的一連串操作，一遍、二遍…幾千甚至幾億遍。
      2:
        image: notes/hoc2_2.jpg
        text: 在這個關卡，我們想要讓鳥向前移動 5 格以抓到豬。
      3:
        image: notes/hoc2_3.jpg
        text: 我們可以用新的「重複」積木來幫助我們走出迷宮。
      4:
        image: notes/hoc2_4.jpg
        text: 而不是使用 5 個「移動-向前」積木…
      5:
        image: notes/hoc2_5.jpg
        text: 我們可以放置「移動-向前」積木到「重複」積木裡，並給個數字，告訴它要重複多少次。
      6:
        image: notes/hoc2_6.jpg
        text: 這一點很重要：你可以在「重複」積木裡放入多個指令。
      7:
        image: notes/hoc2_7.jpg
        text: 好好使用你的新的「重複」積木！
    loop_until:
      1:
        image: notes/hoc3_1.jpg
        text: 嗨，我是 Chris 。在加入邁阿密熱火隊之前，我在喬治亞理工學院學習過計算機科學。讓我們體驗我們的新積木，「重複直到」積木。
      2:
        image: notes/hoc3_2.jpg
        text: 那如果我們不知道要移動多少距離才可以抓到豬呢？
      3:
        image: notes/hoc3_3.jpg
        text: 如果我們放了一個「移動-向前」積木到「重複直到」積木裡，這隻鳥就會向前移動，「直到」它到達這隻豬的位置（或撞到牆壁）。
      4:
        image: notes/hoc3_4.jpg
        text: 這一點很重要：就像之前，我們可以把多個積木放到「重複直到」積木內，它們都將會重複。
    if:
      1:
        image: notes/hoc4_1.jpg
        text: 嗨，我是 Bill！讓我們學習一個新的基本概念：「如果」陳述式，這幫助電腦做出決定。
      2:
        image: notes/hoc4_2.jpg
        text: 你每天都在用如果陳述式，在每天早上出門前，你說如果外面下著雨，我就要穿個外套。
      3:
        image: notes/hoc4_3.jpg
        text: 我們可以告訴殭屍檢查是否有路可以往左，如果他發現左邊有路，我們可以把牠轉到這個方向。
      4:
        image: notes/hoc4_4.jpg
        text: 為了寫出這樣的程式，我們拖曳出「如果」積木，然後放置「轉向-左方」的積木到裡頭。
      5:
        image: notes/hoc4_5.jpg
        text: 現在如果我們放置一個「移動-向前」積木在上頭，再用個「重複」積木包住所有程式，每次殭屍在移動時，他會檢查是否有可以左轉的路。這個「重複」指令是檢查每步是否轉向的關鍵。
      6:
        image: notes/hoc4_6.jpg
        text: 如果陳述式真的很重要，在計算機科學中。第一個我寫的程式是一個井字遊戲，那兒就有如果陳述式，就是如果其他人要贏了，擋住他們會勝利的那個格子。
      7:
        image: notes/hoc4_7.jpg
        text: 盡情享用「如果」積木！
    if_else:
      1:
        image: notes/hoc5_1.jpg
        text: 嗨，我是 Saloni。我用計算機科學來幫忙解決一些衛生和醫學的問題。讓我們學習「如果…否則」這個程式積木。它看起來很像「如果」積木，不過它多了個額外的部分在後面，叫做「否則」。
      2:
        image: notes/hoc5_2.jpg
        text: 如果我放了一個「移動-向前」積木到「執行」的地方，再放一個「轉向-左邊」積木到「否則」的地方，這樣代表這個殭屍會在 2 個選項之間抉擇，如果前面有路，殭屍會往前走；否則（意思是前面沒路）殭屍會左轉。
      3:
        image: notes/hoc5_3.jpg
        text: 就像「如果」積木，我們可以把「如果…否則」積木放進「重複」積木裡，那樣子殭屍會持續移動，而「如果…否則」積木則會不斷的檢查是不是該轉彎了。
      4:
        image: notes/hoc5_4.jpg
        text: 現在，讓那些殭屍回到屬於他們的地方！
    if_else_scrat:
      1:
        image: notes/saloni_ifelse_scrat1.jpg
        text: "「如果…否則」陳述式，就是在二件事情之間做決定。讓我們跟夥伴鼠奎特一起來看看如何利用「如果…否則」陳述句。"
      2:
        image: notes/saloni_ifelse_scrat2.jpg
        text: 這個積木看起來就像是「如果」積木，不過下方多出了一個「否則」。若是我把「移動-向前」積木放在第一個部分，同時把一個「轉向-左方」積木放在寫著第二個部分裡，那麼小松鼠在發現前面有路徑時就會往前走，不然牠會因為沒有路而向左轉。
      3:
        image: notes/saloni_ifelse_scrat3.jpg
        text: 它會決定並執行兩個操作中的一個，就像「如果」積木一樣。你可以把「如果…否則」積木放在「重複」積木裡頭。
      4:
        image: notes/saloni_ifelse_scrat4.jpg
        text: 現在，幫助鼠奎特得到那顆橡樹果吧！
    function:
      1:
        image: notes/stage13_1.jpg
        text: 嗨，我是 Brina，是 Instagram的工程師。函式（Functions）是一連串的程式碼，是那些你想要不斷重複使用的部分，與其每次都要寫出那些代碼，你可以只用一個積木來取代。
      2:
        image: notes/stage13_2.jpg
        text: 我們要學習如何定義函式，函式的定義會在角落的星星，函式的名稱會寫在第一行。
      3:
        image: notes/stage13_3.jpg
        text: 通過在定義內執行的程式積木，能讓我們知道它是做些什麼的。這個函式定義被稱作 fill 5，它的組成是一個「重複」積木和一個「填充」積木。
      4:
        image: notes/stage13_4.jpg
        text: 定義目前在工作區上，但是我們的農夫不會執行這函式，除非我們從函式類別中拖曳出 fill 5（填充 5）函式積木。
      5:
        image: notes/stage13_5.jpg
        text: Let's put the "fun" back in "FUNction!"
    loop_while:
      1:
        image: notes/stage9_5.jpg
        text: '嗨，我是 Makinde！讓我們一起來學習條件迴圈積木（while block）。 '
      2:
        image: notes/stage9_6.jpg
        text: "「只要」裡頭的陳述式為 True，「當…」積木裡頭的程式就會不停的執行。"
      3:
        image: notes/stage9_7.jpg
        text: 舉例來說，如果農夫站在小土堆上，只要還有土堆在她腳下，她就會持續進行移除 1 鏟土的動作。
    loop_for:
      1:
        image: notes/stage11_1.jpg
        text: 嗨，我是 Trina，我在 Pixar 工作，我曾經製作過許多的電影，包含史瑞克。
      2:
        image: notes/stage11_2.jpg
        text: 這是我們的新計數迴圈，它會不斷的執行操作，你可以在每次的循環中讓這些操作有些小小的變動。
      3:
        image: notes/stage11_3.jpg
        text: 在這個例子，我們的計數迴圈內容為「從 50 數到 90，間隔數為 10」，然後在迴圈裡，我們放了 draw a square（畫個正方形）積木，從變數類別裡拖曳出「計數器」積木，嵌入到
          length（長度）的位置。
      4:
        image: notes/stage11_4.jpg
        text: 這表示我們的小藝術家會先畫出一個邊長 50 像素的正方形，然後將計數增加 10 後再畫出一個邊長 60 像素的正方形。然後計數會持續的增加
          10 再畫個正方形…直到邊長到達 90 為止。這樣我們就會有邊長分別為 50、60、70、80 及 90 像素的正方形了。
    parameters:
      1:
        image: notes/stage15_1.jpg
        text: 嗨，我是 Janete，我是 Zynga 的工程師。
      2:
        image: notes/stage15_2.jpg
        text: 那如果我們想要畫出一堆的三角形，而它們的邊長的長度又各不相同呢？
      3:
        image: notes/stage15_3.jpg
        text: 我們可以一行一行慢慢寫出所有的程式碼，或者，我們可以使用帶有參數的函式來完成它。
      4:
        image: notes/stage15_4.jpg
        text: 要做到這個，請點擊藍色星星（在 draw a triangle 函式定義的上面）。接著拖曳「輸入名稱」到「輸入」積木中。
      5:
        image: notes/stage15_5.jpg
        text: 接著，如果你在寫著 x 的地方輸入 length（長度）並點擊鍵盤的 Enter，就可以替你的函式建立一個名為 length 的輸入變數。
      6:
        image: notes/stage15_6.jpg
        text: 然後點擊星星。現在你可以用點選「變數」類別，再將 length（長度）積木拖曳到你的定義函式中的「移動-向前」積木裡。最後再將原有的「數值」積木拖曳到垃圾桶丟掉。
      7:
        image: notes/stage15_7.jpg
        text: 要使用帶參數的函式，先點選函式類別，然後將函式 draw a triangle with length（畫個三角形，帶長度參數）拖曳出來。
      8:
        image: notes/stage15_8.jpg
        text: 現在你可以使用運算類別的積木，輸入不同的數值來畫出不同尺寸的三角形。
    hoc_wrapup:
      1:
        image: notes/hoc6_1.jpg
        text: 恭喜！隨著你解決了最後一個關卡，你剛才也寫出了一個程式，它可以告訴任何機器人如何找到自己的路來通過迷宮或任何長度通道，無論對象是一個殭屍，一隻鳥、還是台火星車、甚至是可自動駕駛的汽車。
      2:
        image: notes/hoc6_2.jpg
        text: 你用到的基礎概念，是任何程式中最核心。我們學到了重複迴圈、重複直到陳述式、如果陳述式、如果否則陳述式。
      3:
        image: notes/hoc6_3.jpg
        text: 如果喜歡你的第一個「一小時玩程式」課程，訪問 code.org 繼續你在計算機科學的教育！一旦你完成我們 20 小時課程，你就會掌握編程的基礎知識，同時也可以學習如何編寫手機、機器人、遊戲的應用程式。
      4:
        image: notes/hoc6_4.jpg
        text: 科技正在改變我們所做的一切，不管你的年紀是多大：程式設計是件很好玩、很有創意的事，任何人都可以學習！
    20_wrapup:
      1:
        image: notes/bird.png
        text: 顯示備註即將推出 ！
    frozen_intro:
      1:
        image: notes/frozen1_1.jpg
        text: 嗨，我的名字是 Lyndsey，我是模特兒、演員，還寫一些自己的應用程式。讓我們用程式來幫助安娜和艾莎，和他們探索充滿魔力的、美麗的冰。
      2:
        image: notes/frozen1_2.jpg
        text: 您將用你的溜冰鞋劃出雪花圖形，建立冬天的仙境，並與你的朋友一同分享。
      3:
        image: notes/frozen1_3.jpg
        text: 在接下來的 1 小時，你會學習到編碼的基礎。傳統的編程是透過文字，而我們使用 Blockly，它是視覺式的積木，你可以利用拖曳方式組合出程式積木。即便是大學生，也會利用它來學習基礎。在積木的背後，你仍然在建立文字代碼。
      4:
        image: notes/frozen1_4.jpg
        text: 程式（Program）是由一組指令組成，用來告訴電腦要做什麼。讓我們為程式建立一個代碼幫助艾莎畫出一個簡單的線條。在那之後，我們會用它來創建更複雜的圖形。
      5:
        image: notes/frozen1_5.jpg
        text: 你的畫面分成三個主要部分：在左側是冰的表面，也是您的程式運行的地方。每個關卡的指南會顯示在該面板的右下方。
      6:
        image: notes/frozen1_6.jpg
        text: 中間區域是工具箱，裡面的每個方塊積木都可以讓艾爾莎和安娜用來動作。
      7:
        image: notes/frozen1_7.jpg
        text: 右邊的空白區稱為工作區，這是我們建造程式的地方。你會用到「移動-向前」積木。
      8:
        image: notes/frozen1_8.jpg
        text: 這裡的向前移動積木寫著：「移動-向前 100 像素」。當我們點擊運行…會發生什麼事呢？在螢幕上艾莎會向前移動指定的距離，也就是 100
          像素。像素（Pixels）是在電腦屏幕上的最小單位。
      9:
        image: notes/frozen1_9.jpg
        text: 關卡上的另一個積木寫著：「轉向-右方 90 度」。當我們使用「轉向-右方」積木時，會讓艾莎朝指定方向轉彎。你可以控制艾莎要轉的角度。角度是從艾莎正前方的方向開始算。所以這個是
          90 度的彎度。還有這個是 120 度的彎度。
      10:
        image: notes/frozen1_10.jpg
        text: 請記住，您可以按一下旁邊的箭頭來更改像素和角度的數值。
    frozen_loops:
      1:
        image: notes/frozen2_1.jpg
        text: 嗨，我是Paola！電腦相當擅長執行重複的動作。你可以數到 10、20 或到 100…但一台電腦可以數到 10 億或上萬億。它不會感到無聊而且它只需要幾秒鐘就完成。不管是計時，或是繪畫，或是任何事，電腦可以重複數百，甚至上億次。
      2:
        image: notes/frozen2_2.jpg
        text: 在程式設計裡，我們稱這為迴圈（Loop）。一個迴圈是讓你可以一遍遍重複您的程式碼。在下一關中，你的目標是利用循環積木，幫助安娜建立一個四邊形。
      3:
        image: notes/frozen2_3.jpg
        text: 任何在重複積木中的程式積木將會被依序執行，並重複你指定的次數。
      4:
        image: notes/frozen2_4.jpg
        text: 要繪製一個四邊形，你可以使用「移動-向前」與「轉向」積木四次。但有更簡單的方法，是告訴電腦向前移動並轉彎 90 度，接著告訴電腦重複這些操作四次。要做到這樣，你必須將「移動-向前」和「轉向-右」放到循環積木裡頭。
      5:
        image: notes/frozen2_5.jpg
        text: 記住，你可以修改重複的次數，那麼它就會執行積木中的操作很多次。
    frozen_functions:
      1:
        image: notes/frozen3_1.jpg
        text: 嗨，我是 Chris Bosh。我是一個職業籃球員，讀大學時我也寫過程式。
      2:
        image: notes/frozen3_2.jpg
        text: |-
          在計算機科學中一個最重要的概念是如何定義新的命令。大多數的計算機語言大概都
          只有 100 個詞語或指令。而真正神奇和美妙的地方是用這些程式積木來定義自己的新詞。
      3:
        image: notes/frozen3_3.jpg
        text: 當你用一序列的指令教導電腦要執行什麼操作後，你可以給這個操作一個名稱，這樣下回就可以很容易再利用它。定義你自己的指令，並給它起了個名字，這就是所謂的函式（function）。
      4:
        image: notes/frozen3_4.jpg
        text: 嗨，我是傑西。當使用程式積木來編寫程式碼時，有一組動作你想用很多次，你就要使用函式。打個比方，你已經寫了程式來繪製四邊形。
      5:
        image: notes/frozen3_5.jpg
        text: '你可以把它定義成函式，並命名為 create a square（畫個正方形）。 '
      6:
        image: notes/frozen3_6.jpg
        text: 現在你就會有個新的積木，你可以使用很多次來繪製多個四邊形。
      7:
        image: notes/frozen3_7.jpg
        text: 很多簡單的函式可以被使用，就可以製作出更多複雜的圖案。在下一關中，你剛寫的畫圓程式被包裝成函式，那麼就可以繪製不同尺寸的圓。你能幫助艾莎在雪地上創造出一個複雜又美麗的圖案嗎？
    playlab_intro:
      1:
        image: notes/playlab_intro_1.png
        text: 我們會用 Play Lab 來創建遊戲。一個好的遊戲會有故事，每個故事都會有演員。我們將要學習讓巫師、外星人、動物等演員說話、移動、互動…在這個教程結束時，你就能從頭創建一個遊戲，並且分享給朋友。
      2:
        image: notes/playlab_intro_2.png
        text: 你的畫面分割為三部分。左邊是遊戲區，也是程式運行的地方。每一關的說明都會寫在下面。
      3:
        image: notes/playlab_intro_3.png
        text: 中間的部分是工具箱，裡面是程式積木；它們各代表了一段程式碼。右邊的空間是工作區，也是我們編寫程式的地方。
      4:
        image: notes/playlab_intro_4.png
        text: 一開始，你會需要連接你的程式積木到橘色的「當運行時」積木中。你可以把多個積木連接在一起，拖曳它們直到你看到黃色的線條出現，放開後它們就會貼合在一起。
      5:
        image: notes/playlab_intro_5.png
        text: 第一個關卡中的角色是一隻企鵝。我們要讓他說出 Hello! ，你要把「說出」積木拖曳出來，連接到「當運行時」的積木，並輸入 Hello!。我們也可以讓企鵝移動，靠著使用「移動-向右」和「移動-向左」積木。當你完成積木的組合後，點擊「運行」來看看你的編程。
      6:
        image: notes/playlab_intro_6.png
        text: 從頭學完後，你能用所有的角色來創建自己的遊戲。你能讓他們之間能夠互動，獲得分數，互相扔東西，甚至能夠消失。這都由你決定！
    playlab_events:
      1:
        image: notes/playlab_events_1.png
        text: 現在，我們要學習一些每天遊戲設計師都要用的東西。他們稱之為事件 (events)。事件用來告訴程式某件事情發生了，而程式會監聽這些事件。當事件發生時，程式會執行相對應的動作。
      2:
        image: notes/playlab_events_2.png
        text: 舉一些事件的例子，像是點擊滑鼠、按下方向鍵，或在觸控螢幕上點了一下。
      3:
        image: notes/playlab_events_3.png
        text: 這裡，我們要在玩家點擊太空寶寶時，讓他向地球打招呼。我們會用到「當點擊時」積木並附加「說出」積木到下面。當玩家在太空寶寶上頭點一下時，所有在「當點擊時」積木上連接的積木都會被執行。想讓你的外星人說些什麼呢？
      4:
        image: notes/playlab_events_4.png
        text: 這裡也有「當方向鍵被按下時」的積木。如果在這些積木下方連結「移動」積木，你就可以開始讓你的角色向上、下、左、右方移動。循序漸進的，你的遊戲會有愈來愈多的互動性。
    playlab_repeat_forever:
      1:
        image: notes/playlab_repeat_forever_1.png
        text: 這個是「重複無限次」積木，任何在裡頭的程式積木將會不斷的在遊戲中發生。
      2:
        image: notes/playlab_repeat_forever_2.png
        text: 如果我們想讓一個角色重複地做一些事情，而玩家又不需要做任何事情，我們可以將那些積木放到「重複無限次」積木裡。
      3:
        image: notes/playlab_repeat_forever_3.png
        text: 在下一個關卡，我們的目標是要幫助巫師巡邏王國的邊界，一會左一會右不停地移動。從中學習如何使用重複指令，幫你節省大量的時間 - 在以後你創建自己的遊戲時。
    C1_artist_intro:
      1:
        image: notes/C1_artist_intro_1.png
        text: 這些是你用來畫圖的積木，使用正確的一個來讓小藝術家移動到該去的地方，然後填滿灰色線條。
      2:
        image: notes/C1_artist_intro_2.png
        text: 這些是跳躍積木，當你使用它們時，你的小藝術家只會移動不會畫畫，所以你可以用它們來跳到下一條灰線。
    C1_bee_level_intro:
      1:
        image: notes/C1_bee_level_intro_1.png
        text: 很酷的蜜蜂吧！在下個關卡裡，你的目標是幫蜜蜂到花朵那兒採集花蜜，然後再飛到蜂窩製作蜂蜜。這個練習裡，你會需要「採集花蜜」和「釀造蜂蜜」積木。
      2:
        image: notes/C1_bee_level_intro_2.png
        text: 每朵花有不同數目的花蜜：1, 2, 3, 或是更多。我們可以從角落的小數字知道紅花有多少花蜜。記得往前移動之前要把這朵花的所有花蜜都採完。另外，每個蜂窩也只能容納這麼多的花蜜。所以要記得盡量讓蜂窩放它最多能容納的花蜜。
      3:
        image: notes/C1_bee_level_intro_3.png
        text: 如果你能夠採集所有花蜜，並釀出所有蜂蜜，你就過關而且可以往下一關前進。不然，你需要再次的嘗試這個關卡。多玩一會兒，體驗一下當個程式設計師是什麼感覺！
    C1_bee_loops:
      1:
        image: notes/C1_bee_loops_1.png
        text: 迴圈可以讓某個操作不斷重複。我進到蜂窩，拿起一個蜂巢檢查，再放回去，然後重複做了這個動作很多次。這就是迴圈。
      2:
        image: notes/C1_bee_loops_2.png
        text: 在這個關卡，我們要蜜蜂從花朵中收集 3 個花蜜。不過不可以使用三個「採集花蜜」積木，你必須使用「重複」積木，重複三次來得到花蜜。點擊「運行」看看你是否正確。太好了!
    C1_bigevent_unplugged:
      1:
        image: notes/C1_bigevent_unplugged_1.png
        text: 這一課叫做大事件。我們會學到利用事件的控制方法，來改變程式在運行期間的行為，像是點擊按鈕或鼠標這樣的事件。
      2:
        image: notes/C1_bigevent_unplugged_2.png
        text: 在這堂課裡，你會被用紙做的搖控器控制，就像是個真人實境視頻遊戲。
      3:
        image: notes/C1_bigevent_unplugged_3.png
        text: 事件（evnet）是個觸發某件事情發生的行為。比方說，當你按了滑鼠按鍵時，網頁就會載入，這就是一個事件。當你觸控平板的螢幕捲動內容，也是一個事件。事件是個很棒的方式，它讓使用者根據他們的需求決定你程式的走向。
      4:
        image: notes/C1_bigevent_unplugged_4.png
        text: 發生事情後我們做出回應。像肚子餓了就去翻冰箱。聽到郵差把信放到郵筒裡時我們就去收信。這些事件就像按按鈕、點滑鼠、玩搖桿一樣。他們都是發生了什麼事，進而觸發我們去做一些事。
      5:
        image: notes/C1_bigevent_unplugged_5.png
        text: 在電動遊戲裡，有一個事件叫做「更新」，它每秒會發生 30 或 60 次。對遊戲程式設計師來說，這個事件比按鈕或搖桿上的事件還來得更重要。
      6:
        image: notes/C1_bigevent_unplugged_6.png
        text: 我們關注這重要的「更新」事件，然後在下一次更新事件來之前檢查搖桿。所以我們說，「哦，有人在這一幀裡按下了按鈕嗎？有沒有？」若沒有事件，玩家就不能移動角色、不能跳、對於正在發生的事情也不能控制。在電動裡就看不到動畫了。
    C1_building_foundation:
      1:
        image: notes/C1_building_foundation_1.jpg
        text: 從沙雕藝術中，你知道失敗是其中的一部份。但如果你堅持下去的話，就不容易失敗了，然後你會發現它越來愈刺激。堅持是這個遊戲的一部份。玩下去，你會愛上它的。
      2:
        image: notes/C1_building_foundation_2.jpg
        text: 這節課叫做打好基礎。這一課裡，我們要完成一個真的比較困難的任務。你需要搭建出至少和這些杯子一樣高的結構，同時它又必須能承受一本書的重量。
      3:
        image: notes/C1_building_foundation_3.jpg
        text: 有時候，我們的創作不一定會成功。有時候我們會覺得很挫敗而想放棄。也有可能常常會有這種感覺。但如果我們繼續嘗試，不停的盡我們最大的努力，那我們不久後一定能找出解決之道。
      4:
        image: notes/C1_building_foundation_4.jpg
        text: 堅持也就是即使你很想要放棄，你都還是繼續留在那裏。如果你想要創造出與眾不同的新東西，沿途一定會有很多的失敗。
      5:
        image: notes/C1_building_foundation_5.jpg
        text: 堅持的訣竅在於不停的嘗試，並從每次的失敗中學習，不因為挫折就停下。挫折實際上意味著一些美好的東西還在角落裡。所以不要輕言放棄，你才有成功的一日！加油！
    C1_getting_loopy:
      1:
        image: notes/C1_getting_loopy_1.png
        text: 嗨，我的名字是 Miral Kotb，我是 Iluminate 的創造者。在我的工作中，有個東西我們常用在舞蹈和燈光設計，那就是迴圈！迴圈（Loops）就是重複一個動作，一遍又一遍的。
      2:
        image: notes/C1_getting_loopy_2.png
        text: 當你重複某件事情很多次時，就會像是我在不停的讓呼啦圈旋轉一樣，我就是在做一個迴圈的動作。這是個迴圈。這是個迴圈。然後這也是個迴圈。
      3:
        image: notes/C1_getting_loopy_3.png
        text: 今天我們來開個舞蹈派對。我們透過新的舞蹈動作展示迴圈，也就是遞迴。我們學習一下迴圈，用舞蹈的方式。你會學到一些簡單的動作，重複它們，一遍又一遍的，以完成這個舞蹈。
      4:
        image: notes/C1_getting_loopy_4.png
        text: 這些是你需要學習的步驟。拍手。把你的手放到頭後面。把你的手放到腰上。舉起你的左手。舉起你的右手。很簡單，對吧？你將會發現你能能夠藉由把舞步放到迴圈中來減少指令。
      5:
        image: notes/C1_getting_loopy_5.png
        text: 我們在跳舞時真的會用到迴圈。舞者都是穿戴式的電腦，全部都在相同的網域中。我可以用迴圈把燈光打到舞者身上。在一個迴圈中，我可能會有一個遞迴告訴你我想要不停地在這六個舞者身上輪流打光，而在迴圈中，我要讓光的速度變快。而這些全部都是透過迴圈創造的。在電腦科學中，迴圈是很重要的，因為他可以讓我們的工作很簡潔容易。
    C1_happy_maps_unplugged:
      1:
        image: notes/C1_happy_maps_unplugged_1.png
        text: 這節課叫做快樂的地圖。今天我們要幫助我們的毛朋友 Flurb 找到她的水果。
      2:
        image: notes/C1_happy_maps_unplugged_2.png
        text: 讓Flurb走到你的水果。為了做到這個，你要找出Flurb需要往哪邊走，並以箭頭引導她。為了讓Flurb拿到蘋果，她須要往哪裡走呢？讓她往上走。
      3:
        image: notes/C1_happy_maps_unplugged_3.png
        text: 為了要到那裏，你要圈出要走的方向。
      4:
        image: notes/C1_happy_maps_unplugged_4.png
        text: 把箭頭黏在你要解開的地圖旁邊來創造你的演算法。第二個是一樣的，只是她是往下。
      5:
        image: notes/C1_happy_maps_unplugged_5.png
        text: 它就像在紙上設計程式，而事實上它就是！
    C1_maze_debugging:
      1:
        image: notes/C1_maze_debugging_1.png
        text: 除錯就是找到並且處理問題。有很多種方法可以除錯，最簡單的方法就是一步步的往下找，直到你找到錯誤為止。我現在要在平衡木上做一個後手翻，但我不停的掉下來，幫我看看是哪兒出錯了。
      2:
        image: notes/C1_maze_debugging_2.png
        text: 我一步步的檢視每一個步驟，然後發現我哪裡有問題。我沒有把手正確的放到平衡木上面。所以我用新的手的姿勢在平衡木上再試一次後手翻，然後我就做對了。我很開心我能夠對我的後手翻除錯。
      3:
        image: notes/C1_maze_debugging_3.png
        text: 為了學習關於除錯，我們從這個階段已經有的一堆積木開始。你會注意到這些程式積木無法完成你的目標。我們需要找到問題的錯誤並修正它。是哪兒出錯啦？你會發現你需要再往西走一格。
      4:
        image: notes/C1_maze_debugging_4.png
        text: 我們多加一個往西的積木來修正它，然後點擊運行來看看你是否正確。耶，你做對了！
    C1_maze_intro_sequencing:
      1:
        image: notes/C1_maze_intro_sequencing_1.png
        text: 這一關，你要讓鳥走到豬那裏。仔細觀察這個關卡，看看它要往什麼方向移動。
      2:
        image: notes/C1_maze_intro_sequencing_2.png
        text: 你需要把程式積木從工具箱中拖到工作區塊中。確定它是在「當按下執行時」的程式積木下面，而當你覺得你有對的答案的時候，按下「執行」，然後看那隻鳥往豬的方向移動。
    C1_maze_loops:
      1:
        image: notes/C1_maze_loops_1.png
        text: 電腦很擅長的其中一件事就是重複指令。身為一個人，如果你要不停地重複某個東西，你一定會感到很無趣。但是一個電腦可以把同樣的事情做幾百萬或是幾十億次也做得很好，更不會感到無聊。
      2:
        image: notes/C1_maze_loops_2.png
        text: 例如，如果我想發電子郵件給 Facebook 上每個人獻上生日快樂的祝福，我可能需要花一個世紀的時間對來寫完所有的郵件。但是只需要幾行程式碼，就可以有一個系統發送電子郵件給
          Facebook 上的每個人，祝他們生日快樂。
      3:
        image: notes/C1_maze_loops_3.png
        text: 在這關要幫助鳥抓到豬，與其把三個往北移動的積木放到工作區中，你可以改用「重複」積木。拖曳「重複」積木到工作區，然後輸入數字 3。然後再把往北移動的積木放到「重複」積木內，再點擊「運行」來看看你是否正確。恭喜你，你做到了！
    C1_moveitmoveit_unplugged:
      1:
        image: notes/C1_moveitmoveit_unplugged_1.png
        text: 這一課叫做移動它，移動它。我們將一起寫一個程式來讓我們的朋友用指南針從起點抵達笑臉目的地。
      2:
        image: notes/C1_moveitmoveit_unplugged_2.png
        text: 但是笑臉是朝下的，只有一個人知道怎樣到達那兒。讓我們開始這個程式吧。
      3:
        image: notes/C1_moveitmoveit_unplugged_3.png
        text: 程序是一個機器可以運行的算法編碼。我們大多數人認為程序是我們寫給電腦的東西。程序很好的地方在於它們可以對其他地方很有幫助。你可以編一個屬於自己的遊戲或者讓一個機器人為你效勞。
    C1_going_places_safely:
      1:
        image: notes/C1_going_places_safely_1.png
        text: 我的名字是 Jeremiah。嗨！我今年七歲，我喜歡玩我媽的電腦，不過我每次都會先經過她的同意。「媽，我能用電腦嗎？」「當然，甜心！」
      2:
        image: notes/C1_going_places_safely_2.png
        text: 我愛我媽的電腦，因為我可以瀏覽網路。網路有點像你的鄰居，您可以造訪很酷的地方，你也可以跟家人和朋友聊天，也可以學到很多新的東西。
      3:
        image: notes/C1_going_places_safely_3.png
        text: 昨天，我參觀了我家附近的動物園。我看到了一隻小斑馬。我給她照了張照片並且改變了她條紋的顏色，還加了一頂帽子。最後加到我的古怪動物收集作品裡。太棒了！後來，我去了很遠的地方；我來到了肯亞。這是一個在非洲的國家，有很多的斑馬住在那裡。
      4:
        image: notes/C1_going_places_safely_4.png
        text: 有時候我在網路上與認識的人聊天，像我的奶奶住在另一個國家。嗨，阿嬤！她正在準備要送我的生日餅乾。 "看起來真好吃！真希望味道可以透過網路傳來！"
          我也會跟不同的人聊天，像是我表姐。但我只跟我認識的人聊天。
      5:
        image: notes/C1_going_places_safely_5.png
        text: 我在網路上最喜歡的就是玩有趣的遊戲。得分！我也喜歡畫畫，還有創作新玩意並分享給我的朋友。酷！有時候我會瀏覽網站來學習新的東西，但我只看適合我的網站。哇嗚，是恐龍！
      6:
        image: notes/C1_going_places_safely_6.png
        text: 網路是一個超有趣的地方。但就像你在家附近過馬路一樣，你也在上網時也要小心！有三個守則要記住：1、一定要先問父母；2、只跟認識的人聊天；3、堅持只看適合自己的地方。
      7:
        image: notes/C1_going_places_safely_7.png
        text: 哇，真是太好玩了！現在是吃飯時間了，我要離開了！我已經等不及再上線找看看我還可以去哪裡！
    C1_pair_programming:
      1:
        image: notes/C1_pair_programming_1.png
        text: 今天我們要學習小組編程，在小組編程活動中，你們要分組。為什麼要兩人共用一台電腦？因為兩個臭皮匠勝過一個諸葛亮，在小組編程活動你和你的伙伴會坐在一台電腦前，彼此合作來完成一個專案。
      2:
        image: notes/C1_pair_programming_2.png
        text: 在小組編程活動中，一人是駕駛，另一個人是導航器，就像駕駛一輛汽車一樣。司機坐著，電腦在旁，司機使用鍵盤和滑鼠（或觸控式螢幕）來控制電腦。另一個人是導航器，導航器通過回答司機的問題來幫助他，並指出潛在的問題或錯誤給司機。
      3:
        image: notes/C1_pair_programming_3.png
        text: 溝通是讓小組編程成功的關鍵。不要冒犯，要互相尊重，不要當個只會指使人做東做西的導航器，因為沒有人喜歡被指揮。你和你的夥伴應該時時刻刻對話。駕駛可以解釋他要做的是什麼，而導航器則可以幫忙建議下一步要做什麼。
      4:
        image: notes/C1_pair_programming_4.png
        text: 導航器應該要思考大局，駕駛則要專注在細節。兩個角色都很重要，小組編程活動是一個訓練團隊合作的活動。
    C1_planting_seed:
      1:
        image: notes/C1_planting_seed_1.png
        text: "「植物種植」這一課可以幫助我們了解演算法（Algorithm），演算法的定義是「在有限步驟內解決事情的程序」，即便是像吃早餐、刷牙這樣的小事，都需要一定的步驟才會完成。"
      2:
        image: notes/C1_planting_seed_2.png
        text: 電腦可以非常聰明，但你得精準地一步一步的告訴他們你的想法，他們才能明白。演算法很棒的地方是，如果你按順序跟從指示，就可以做到一些你不知道如何提前處理的事，就像是跟著食譜做東西一樣。
      3:
        image: notes/C1_planting_seed_3.png
        text: 今天我們要種植植物，不過用的是演算法。把圖片剪下後，你就可以開始建立自己的演算法。將種出植物的步驟圖片重新排列成你認為正確的順序。
      4:
        image: notes/C1_planting_seed_4.png
        text: 現在來看看你的演算法是否有效。仔細地按照演算法中的步驟，想想它們的順序正確嗎？照著這個步驟真能種出植物嗎？這就像用圖片編程一樣！
      5:
        image: notes/C1_planting_seed_5.png
        text: 當我們製作巧克力時，會有很多的關鍵步驟，而每個關鍵步驟都各自有不同的烹調的小程序，隨著我們想製造出的味道不同，程序就會調整。即便是一個小程序都扮演舉足輕重的角色，缺一不可。同時，要建立一個別人都看得懂的程序也是相當重要的，把它們紀錄下來，如此一來不管是誰來做，得到的結果都會相同。
    C1_playlab_storytelling:
      1:
        image: notes/C1_playlab_storytelling_1.png
        text: 是時候發揮你的創意了，使用你學到的編程技能來創作一個故事。你的故事會有角色，你要讓角色之間對話、互動。現在開始思考一下你想要設計個什麼樣的故事。
      2:
        image: notes/C1_playlab_storytelling_2.png
        text: 如果小貓知道小狗只是想示好的話，還會這麼怕小狗嗎？一切都從「當運行時」積木開始。「移動」積木將會移動你的角色，「說出」積木則會讓你的角色說出你輸入的內容。
      3:
        image: notes/C1_playlab_storytelling_3.png
        text: 這是「當角色遇到」積木，它可以讓你連結其它的程式積木。
      4:
        image: notes/C1_playlab_storytelling_4.png
        text: 我想讓狗靠過來，然後說：「嗨！」但是貓因為害怕跑走了。「啊」如果還有更多時間，它會是一個快樂的結局。結束！
    C1_spelling_bee_intro:
      1:
        image: notes/C1_spelling_bee_intro_1.png
        text: 這關是拼字蜜蜂。使用積木來移動蜜蜂，當牠移動時，牠會收集字母以拼出單字。
      2:
        image: notes/C1_spelling_bee_intro_2.png
        text: 看看你能不能拼出英文單字（單字在下方舞台的文字方塊裡）。細心一些！如果移錯方向會添加更多你不想要的字母。
    C1_zuck_repeat_loop:
      1:
        image: notes/C1_zuck_repeat_loop_1.png
        text: 電腦很擅長的其中一件事就是重複指令。身為一個人，如果你要不停地重複某個東西，你一定會感到很無趣。但是一個電腦可以把同樣的事情做幾百萬或是幾十億次也做得很好，更不會感到無聊。
      2:
        image: notes/C1_zuck_repeat_loop_2.png
        text: 例如，如果我想發電子郵件給 Facebook 上每個人獻上生日快樂的祝福，我可能需要花一個世紀的時間對來寫完所有的郵件。但是只需要幾行程式碼，就可以有一個系統發送電子郵件給
          Facebook 上的每個人，祝他們生日快樂。
      3:
        image: notes/C1_zuck_repeat_loop_3.png
        text: 這個範例裡，你要移動鳥去抓豬。現在我們要使用「重複」程式積木來讓我們輕易地完成。你可以給電腦 5 個向前走的指令來讓鳥一步一步走到豬的位置，也可以告訴電腦向前走一步，然後重複
          5 次來完成同樣的動作。
      4:
        image: notes/C1_zuck_repeat_loop_4.png
        text: 為了做到這個，請把「向前走」程式積木拖到「重複」程式積木的區間裡。然後點「重複」程式積木告訴它你要重複向前走幾次。
      5:
        image: notes/C1_zuck_repeat_loop_5.png
        text: 還有一點，你可以放你想要的指令到「重複」程式積木裡，多少都可以。在這個範例裡，你告訴他向前、再向左，他會重覆 5 次。玩看看！
    C2_artist_intro:
      1:
        image: notes/C2_artist_intro_1.png
        text: 若你不找個電腦科學專家來收集這麼多車子的資料，也不明白可以找人寫程式來讓你持續有好的表現的必要性；那你將會失去競賽的資格。
      2:
        image: notes/C2_artist_intro_2.png
        text: 在這些關卡裡，你指揮一位拿著筆的小藝術家來畫出不同的圖形。你的小藝術家走到哪裡，他就會在身後留下線條。
      3:
        image: notes/C2_artist_intro_3.png
        text: 你會使用「移動-向前」程式積木來在畫布上移動。這裡的積木寫著向前移動 100 像素。當我們點擊運行，會發生什麼事？小藝術家向前移動了一些距離，這距離就是
          100 像素，像素是電腦螢幕上的最小單位。
      4:
        image: notes/C2_artist_intro_4.png
        text: 這關裡還有叫做「轉向-右方 90 度」的程式積木。我們把它拖出來可以讓小畫家轉一個角度。所以，你可以讓小畫家轉任意的角度。這是轉 90
          度。
      5:
        image: notes/C2_artist_intro_5.png
        text: 這個則是轉 120 度。記住，你可以點擊數字旁的箭號來改變像素及角度。享受與小藝術家一同畫畫的樂趣吧！
    C2_bee_conditionals:
      1:
        image: notes/C2_bee_conditionals_1.png
        text: 這是條件判斷積木。它是說「如果」這裡有花蜜或蜂蜜小於、等於或大於一個數字，「那麼就」做這一些事。
      2:
        image: notes/C2_bee_conditionals_2.png
        text: 當我們不知道有多少花蜜或蜂蜜時，這個就很有用。像我們在這裡看到了問號。
      3:
        image: notes/C2_bee_conditionals_3.png
        text: 這個例子中，我們會說「如果」這朵紫花有花蜜（大於 0），就告訴我們的蜜蜂持續的採集花蜜，有多少採多少，噠啦！
    C2_binary_bracelets:
      1:
        image: notes/C2_binary_bracelets_1.png
        text: 這課叫做「密碼手環」，我們要將自己的英文姓名用二進制編碼，並製作成手環。做完後戴上它讓朋友猜猜你的密碼是什麼！
      2:
        image: notes/C2_binary_bracelets_2.png
        text: 二進制（Binary）是個只用兩種符號來傳達訊息的方法。有些人以為它只是「1」和「0」。但其實你可以運用一些組合來表達，例如開與關、上與下、進與出，又或者其他一些相對的組合。
      3:
        image: notes/C2_binary_bracelets_3.png
        text: 嗨，我是 Orion，我在 Play-im 編寫機器人程式，所有電腦和機器人的腦袋是一堆小小的電子闡道所組成。當闡道打開，電流可以通過；當闡道關上，電流就無法通過。
      4:
        image: notes/C2_binary_bracelets_4.png
        text: 機器人的眼睛就是個二進制（binary）的例子，它們的眼睛是 LED（發光二極體），是可以打開或關閉的。它就是個二進位系統，我們可以用燈光來表示二進位數，假設我們有一堆機器人，第一機器人就可以說是
          1s、第二個叫它 2s，第三個是 4s…以此類推（第四個就是 8s）…這是我們表示二進位數的方法，機器人會用它們的二進制的眼睛計數給你看。
    C2_conditionals_with_cards:
      1:
        image: notes/C2_conditionals_with_cards_1.png
        text: 這一節課叫「條件判斷撲克牌」，每一天，你都會依著自己看到的、聽到的來決定些事情。
      2:
        image: notes/C2_conditionals_with_cards_2.png
        text: 我想到公園散散步，但要先考慮是不是該帶把傘，所以我往窗外看，如果天空很多雲，就帶傘出門；如果沒有，就戴太陽眼鏡。好吧，我想我會帶雨傘的。我會照自己的所見所聞，決定去公園時要帶些什麼在身上。
      3:
        image: notes/C2_conditionals_with_cards_3.png
        text: 在遊戲裡頭也用上了很多的條件判斷。今天我們就把它用在撲克牌遊戲上，這個遊戲中，我的朋友要依照我拿的牌做反應。比方說我的牌子是數字 7，每個人就歡呼大叫；若不是，每個人就說「喔」。我們來試試吧！（喔…）（歡呼聲）
      4:
        image: notes/C2_conditionals_with_cards_4.png
        text: 你絕對可以訂出一個更有趣的條件判斷卡的玩法，試試吧！我們就是利用條件判斷來讓電腦變得聰明的。電腦會依據使用者的操作來決定要回應的方式，就是因為程式中包含了無數的條件判斷。
      5:
        image: notes/C2_conditionals_with_cards_5.png
        text: 拿你最愛的電視遊戲來說吧，當你執行某些操作時可以獲得比較高的分數，原因是？因為電腦用了條件判斷，這就是電腦做決定的方式，比方說，如果你擊中目標可以加
          10 分，不然，你就減 3 分…當你知道了條件判斷如果運作的，你就可以利用它來製作各種刺激的遊戲。
    C2_artist_debugging:
      1:
        image: notes/C2_artist_debugging_1.png
        text: 我們已經在工作區放上了一些積木，但是有個地方出錯了。
      2:
        image: notes/C2_artist_debugging_2.png
        text: 我們可以將運行的速度調慢一點，一步一步地，仔細觀察程式的每一步驟來找出錯誤。
      3:
        image: notes/C2_artist_debugging_3.png
        text: 哦！找到問題了！貓咪鬍鬚的長度應該是 75 像素，不是 25。
    C2_bee_debugging:
      1:
        image: notes/C2_bee_debugging_1.png
        text: 你有聽過替程式除錯嗎？其實就是找出程式哪兒不正常的方法。當你找到時，指出並且移除這些錯誤。
      2:
        image: notes/C2_bee_debugging_2.png
        text: 已經有一些積木在我們的工作區了，我們要使用這個「步進」按鈕來執行這些積木，一步接著一步，以檢視是否這是正確的解法，以及哪兒我們可能需要修正。
      3:
        image: notes/C2_bee_debugging_3.png
        text: 看來這兒有些問題！我們需要添加更多的「移動-向前」程式積木。「步進」按鈕可以幫助我們確認問題點，讓我們可以修正它。
    C2_digital_footprint:
      1:
        image: notes/C2_digital_footprint_1.png
        text: |-
          你的頭可以戴著帽，還有你聰明的腦袋會告訴你現在在哪裡。想像一下你現在在動物園裡面，跟每一個遇到的動物點頭打聲招呼吧!
          在上網的時候，要隨時動動你的腦袋，還有要保持平穩的心，你要知道怎麼去保護你在網路上的安全和私人空間(網路上面不要透露你太多資料 不然會很危險喔)
          從頭到腳想一想吧! 停一停 想一想 從頭到腳想一想吧! 停一停 想一想
      2:
        image: notes/C2_digital_footprint_2.png
        text: 用心成長，讓自己健康的成長，然後在情人節的時候，對某人說你是我的！當你在線的時候，也要用心，要明白什麼是對的，永遠是和藹的，並且尊重你的朋友，在互聯網上保持公正和友好。從低頭看看你的腳趾頭，想一想...
          再從你的腳看到你的鼻子... 暫停... 想想網絡！
      3:
        image: notes/C2_digital_footprint_3.png
        text: 用你的裝備來擁抱寵物，別讓你的衣服被打濕，還要穿上你最喜歡的袖套，這會幫助你假裝飛起來。當你上網的時候，也要用上你的裝備。要歇一歇平衡時間。有時候要放下技術，找棵樹爬一爬。低頭看看你的腳趾頭，想一想...
          再從你的腳看到你的鼻子... 暫停... 想想網絡！
      4:
        image: notes/C2_digital_footprint_4.png
        text: 用你的腸胃來存放你的食物，聽聽它咆哮的聲響，感覺蘇打水里的氣體。當上網的時候也要用你的腸胃，知道看某些信號，讓它引導你的路，告訴你什麼時候不行。低頭看看你的腳趾頭，想一想...
          再從你的腳看到你的鼻子... 暫停... 想想網絡！
      5:
        image: notes/C2_digital_footprint_5.png
        text: 因此，用你的頭腦來思考，感覺你的心，用手臂保持平衡，聽聽你的腸胃，上網。用你的腿來跑和踢，在蹦蹦蹺上蹦跳，在街上跳舞，跳過你的臭襪子。當你上網的時候，要用你的腿站起來，提抗越過底線的霸道者，對大小動物都保持友好。
      6:
        image: notes/C2_digital_footprint_6.png
        text: 低頭看看你的腳趾頭，暫停... 想一想... 再從你的腳看到你的鼻子... 暫停... 想想網絡！用你的頭腦來思考，感覺你的心，用手臂保持平衡，聽聽你的腸胃，用你的雙腿站立。低頭看看你的腳趾頭，暫停...
          想一想... 再從你的腳看到你的鼻子... 暫停... 想想網絡！
    C2_digital_footprint_v2:
      1:
        image: notes/C2_digital_footprint_v2_1.png
        text: 當你每次上線，你也會留下足跡，這些紀錄可以被查詢、複製、分享、廣播，而且它是永久性的。你留下了哪些數位足跡？你想留下哪些數位足跡？
    C2_graph_paper:
      1:
        image: notes/C2_graph_paper_1.png
        text: 這節課用「方格紙編程」來談談演算法（Algorithm）。今天我們要學習如何只用手繪的箭頭，來讓其他人畫出簡單的黑、白交錯的圖案。
      2:
        image: notes/C2_graph_paper_2.png
        text: 演算法是用來完成某項任務的指令清單。我們依序執行這一組指令來完成事情。演算法在你需要讓別人瞭解如何做某件事時是很有用的。
      3:
        image: notes/C2_graph_paper_3.png
        text: 如果你要為電腦寫個演算式，你必須把事情切割成多個步驟，愈小愈好，讓它在做完一行後再接著進行下一行，依序的執行，最後你就完成了。
      4:
        image: notes/C2_graph_paper_4.png
        text: 我在我的工作中使用演算法。如果我寫下所有步驟，我可以用這個程序完成同樣的事情，或者，我可以告訴別人該怎麼做…把玻璃放到窯裡…將它熔在一起…按部就班的做就可以做出個碗來。演算法就像地圖，讓你順利到達目的地。
    C2_artist_loops:
      1:
        image: notes/C2_artist_loops_1.png
        text: 這裡我們使用重複積木來替代程序中重複的部分，這可以讓編寫的程式更精簡。工作區上已經有些積木，除非我們開始執行，不然這些積木不會運作的。
      2:
        image: notes/C2_artist_loops_2.png
        text: 讓這些積木重複執行四次就可以畫出一個四邊形，我們只要用一個重複執行積木把移動和右轉積木給包住就可以了。當我們點擊運行按鈕，就會看到它重複做了四次的動作並完成了四邊形。
    C2_bee_loops:
      1:
        image: notes/C2_bee_loops_1.png
        text: 迴圈可以讓某個操作不斷重複。我進到蜂窩，拿起一個蜂巢檢查，再放回去，然後重複做了這個動作很多次。這就是迴圈。
      2:
        image: notes/C2_bee_loops_2.png
        text: 這是重複積木，不管你在重複積木裡放進什麼，程式都會重複那些操作，依照你告訴它的次數。舉個例子，在這個關卡，與其拖曳向前移動和採集花蜜積木三次，我們不如只拖曳它們各一次，然後重複這個操作三次，這樣是不是更簡單了！
    C2_maze_intro:
      1:
        image: notes/C2_maze_intro_1.png
        text: 程式設計通常是用純文字所寫，但 Blocky 讓我們可以用圖像來寫程式，我們只要將積木拖曳排列就可以完成程式，非常直覺。這些積木的背後還是
          code。現在我們用它來建立個程式，幫助憤怒鳥通過迷宮，抓到那群偷蛋的邪惡豬。
      2:
        image: notes/C2_maze_intro_2.png
        text: Blocky 有三個主要部分，在左側是迷宮，你的程式要實作的地方。而上方則是每階段關卡的過關指示。中間區域的左邊則是指令工具箱，裡頭的積木是用來指揮憤怒鳥的命令，右邊就是工作區域，你要你需要用的指令拖曳到這裡，並建立一個程序。
      3:
        image: notes/C2_maze_intro_3.png
        text: 如果我拖曳移動積木到工作區並點擊「運行」，會發生什麼事呢？這隻鳥會向前移動一格。那如果我想要這隻鳥在移動後做些什麼呢？我可以添加其它的積木到程式中。
      4:
        image: notes/C2_maze_intro_4.png
        text: 我選擇了「轉向-右方」積木，而且我會把它拖曳到我移動的積木下方，直到黃色箭頭出現，放開後兩個積木就會貼合在一起。當我再次點擊「運行」，這隻鳥就會將工作區上堆疊的指令由上而下的執行一遍。
      5:
        image: notes/C2_maze_intro_5.png
        text: 如果你想要刪除一個積木，只要將它從程式堆中移出，然後拖曳到垃圾桶。在您點擊運行後，你可以隨時點擊重置按鈕，讓小鳥回到開始點。現在讓我們抓到這些豬吧！
    C2_paper_airplanes:
      1:
        image: notes/C2_paper_airplanes_1.png
        text: 這一課叫做「生活中的演算法」。演算法描述人們每天做的事情。餅乾配方和築鳥巢指南都是日常生活中的演算法。
      2:
        image: notes/C2_paper_airplanes_2.png
        text: 今天，我們要製作、創造、測試一個紙飛機的演算法。但一開始，我們需要將這個大型的專案打散成容易上手的小步驟。要製作一架紙飛機，我們需要決定製作的步驟以及它們的排列順序。
      3:
        image: notes/C2_paper_airplanes_3.png
        text: 要創造你的演算法，第一步是剪下這些圖片，接著，你要選擇 6 張圖片以表示做一架紙飛機的所需的步驟，然後排出這些圖片的正確順序。當你排好順序後，你就交換你的演算法給另一個組別的學生，然後測試看看該演算法是否有用。一個精心設計的演算法是非常重要的，這樣才能折出最棒的紙飛機。
      4:
        image: notes/C2_paper_airplanes_4.png
        text: 當我們製作巧克力時，會有很多的關鍵步驟，而每個關鍵步驟都各自有不同的烹調的小程序，隨著我們想製造出的味道不同，程序就會調整。即便是一個小程序都扮演舉足輕重的角色，缺一不可。同時，要建立一個別人都看得懂的程序也是相當重要的，把它們紀錄下來，如此一來不管是誰來做，得到的結果都會相同。
    C2_playlab_createstory:
      1:
        image: notes/C2_playlab_createastory_1.png
        text: 目前為止你已經製作了一個動畫或故事，在你運行它時，它會執行相同的操作。現在你可以設計一個互動式的、可以玩的遊戲了。
      2:
        image: notes/C2_playlab_createastory_2.png
        text: 這裡有些新的積木可以試試。例如「當按方向鍵時」積木以及「移動角色」積木，你可以將這些積木放在一起，利用方向鍵來移動角色。另外還有一些積木會在角色互撞或是被點擊時作用。試試它們，玩得愉快！
    C2_relay_programming:
      1:
        image: notes/C2_relay_programming_1.png
        text: 今天我們來玩個接力編程，在編程過程中常常會遇到壓力和發生錯誤，尤其是當你做得太快或是用團隊分工方式時。我們用圖畫紙來模擬實際編程，並用接力賽的方式來揣摩截止日期快到的情況。
      2:
        image: notes/C2_relay_programming_2.png
        text: 在接力編程活動中，團隊比賽看誰先完成圖紙編程，你必須檢查你的隊友的進度，或是幫他找到錯誤然後修正它。添加你的箭頭，然後傳給下一個隊友。
      3:
        image: notes/C2_relay_programming_3.png
        text: 程式設計師花很長時間來做很多偵測的工作和修改在演算法或是編碼中的問題。有很多方法來偵錯問題。其中最簡單的方式就是一步接著一步地檢查直到發現有什麼東西出錯了，然後將它修正。
      4:
        image: notes/C2_relay_programming_4.png
        text: 在這裡，我要嘗試來做後空翻，但我一直摔倒。我檢查了每個步驟，一步接著一步的，然後了解到我的錯誤在哪裡。我的教練說我並沒有把手放在橫桿上的正確位置。所以我再一次嘗試，在橫桿上試著把手放在新位置做後空翻，然後我安全落地！我很高興我成功的找到了後空翻的錯誤。我們也搞清楚了！除錯就是發現以及修正問題，這真的太棒囉！
    C2_zuck_repeat_loop:
      1:
        image: notes/C2_zuck_repeat_loop_1.png
        text: 重複執行指力是電腦很擅長的事情。對人來說，如果你不斷重複做一模一樣的事情，你將會感到無聊。但一部電腦卻可以做一樣的事情重複數百萬或是數十億次而不會感到厭煩且能夠完美的勝任它。
      2:
        image: notes/C2_zuck_repeat_loop_2.png
        text: 舉例來說，如果我希望祝福每個在 Facebook 的人生日快樂，透過寄送電子郵件的方式，可能要花我一百年的時間來寫完所有信件給所有人。但透過幾行的程式碼，我就能有個系統來寄信給所有在
          Facebook 上的人並祝他們生日快樂。這個系統就是所謂的迴圈（loops），也是電腦非常擅於處理的事情。
      3:
        image: notes/C2_zuck_repeat_loop_3.png
        text: 在這個例子中，你的目標是移動小鳥來抓到豬。現在我們能夠用「重複」積木來輕易的做到這件事。你可以給電腦一個「移動-向前」的指令五次，讓鳥每次向豬的位置前進一格。
      4:
        image: notes/C2_zuck_repeat_loop_4.png
        text: 或者，你可以告訴電腦「向前移動」一次，接著再向它說「重複」那個指令五次，這將會做到一樣的事情。所以為了做到這件事，你要拖曳你的「移動-向前」指令，再把指令放進「重複」積木裡。
          然後你可以點一下它，告訴它你想要重複這個積木幾次，相當於告訴它你想要向前移動多少格。
      5:
        image: notes/C2_zuck_repeat_loop_5.png
        text: 還有一點，你可以放入你任何你想要執行的指令到「重複」積木裡。在這個範例，你告訴它向前移動，向左轉，他會重複 5 次。玩得開心！
    C3_artist_functions:
      1:
        image: notes/C3_artist_functions_1.png
        text: 在計算機編程中，有一個很棒的事，就是一旦你教會電腦如何執行一個操作，你可以再次呼叫那個功能。你給它一個名字然後呼叫它，那真的就像擴展了這個程式語言。
      2:
        image: notes/C3_artist_functions_2.png
        text: 在我們建立的程式中，我們學會了怎樣通過移動和轉彎四次來畫個正方形。我們可以將它變成一個函式，然後將它叫做 draw a square，這樣任何時候我們都可以用它了。我們只要說
          draw a square，然後它就會被呼叫，就可以透過函式裡的指令幫我們畫出正方形。這樣，我們就等於是添加了一個新的概念到這個編程語言。
    C3_artist_intro:
      1:
        image: notes/C3_artist_intro_1.png
        text: 若你不找個電腦科學專家來收集這麼多車子的資料，也不明白可以找人寫程式來讓你持續有好的表現的必要性；那你將會失去競賽的資格。
      2:
        image: notes/C3_artist_intro_2.png
        text: 在這些關卡裡，你指揮一位拿著筆的小藝術家來畫出不同的圖形。你的小藝術家走到哪裡，他就會在身後留下線條。
      3:
        image: notes/C3_artist_intro_3.png
        text: 你會使用「移動-向前」程式積木來在畫布上移動。這裡的積木寫著向前移動 100 像素。當我們點擊運行，會發生什麼事？小藝術家向前移動了一些距離，這距離就是
          100 像素，像素是電腦螢幕上的最小單位。
      4:
        image: notes/C3_artist_intro_4.png
        text: 這關裡還有叫做「轉向-右方 90 度」的程式積木。我們把它拖出來可以讓小畫家轉一個角度。所以，你可以讓小畫家轉任意的角度。這是轉 90
          度。
      5:
        image: notes/C3_artist_intro_5.png
        text: 這個則是轉 120 度。記住，你可以點擊數字旁的箭號來改變像素及角度。享受與小藝術家一同畫畫的樂趣吧！
    C3_artist_nested_loops:
      1:
        image: notes/C3_artist_nested_loops_1.png
        text: 當你放置一個迴圈在另一個迴圈裡頭時，我們稱它做巢狀迴圈。舉例來說，這裡我們已經有一段程式碼用重複積木設定 3 次，一次一邊來準備畫一個邊長
          100 像素的三角形。
      2:
        image: notes/C3_artist_nested_loops_2.png
        text: 但是我們想畫出 6 個三角形。為了完成這件事，我們會把那些操作指令放置在另一個重複積木裡，很酷吧！
    C3_bee_conditionals:
      1:
        image: notes/C3_bee_conditionals_1.png
        text: 這是條件判斷積木。它是說「如果」這裡有花蜜或蜂蜜小於、等於或大於一個數字，「那麼就」做這一些事。
      2:
        image: notes/C3_bee_conditionals_2.png
        text: 當我們不知道有多少花蜜或蜂蜜時，這個就很有用。像我們在這裡看到了問號。
      3:
        image: notes/C3_bee_conditionals_3.png
        text: 這個例子中，我們會說「如果」這朵紫花有花蜜（大於 0），就告訴我們的蜜蜂持續的採集花蜜，有多少採多少，噠啦！
    C3_bee_debugging:
      1:
        image: notes/C3_debugging_bee_1.png
        text: 你有聽過替程式除錯嗎？其實就是找出程式哪兒不正常的方法。當你找到時，指出並且移除這些錯誤。
      2:
        image: notes/C3_debugging_bee_2.png
        text: 已經有一些積木在我們的工作區了，我們要使用這個「步進」按鈕來執行這些積木，一步接著一步，以檢視是否這是正確的解法，以及哪兒我們可能需要修正。
      3:
        image: notes/C3_debugging_bee_3.png
        text: 看來這兒有些問題！我們需要添加更多的「移動-向前」程式積木。「步進」按鈕可以幫助我們確認問題點，讓我們可以修正它。
    C3_bee_functions:
      1:
        image: notes/C3_bee_functions_1.png
        text: 在計算機科學中有個很重要的概念，就是如何定義新指令。還有如何添加你自己的詞語到計算機語言中。絕大多數的計算機語言只有約一百個的詞語或指令。在這些已建置的積木之外，如何定義出你自己的新詞語，這就是門藝術，也是個神奇的事。
      2:
        image: notes/C3_bee_functions_2.png
        text: 我們在運動中一直在做這件事情。舉例來說，在籃球中，你開始學會如何運球，如何上籃，如何搶籃板。一旦你已經學會那些基本動作，你會學新的動作及把積木揍在一起，像是擋拆戰術或是傳切戰術。你可以再從這裡做一些更複雜的動作。一旦你學會打球和給定一個名稱，在隊上的每個人就知道如何做到它。
      3:
        image: notes/C3_bee_functions_3.png
        text: 同樣地，一旦你透過一連串的指令教會電腦如何執行一個操作，你就可以幫那個操作取個名字，這樣一來就可以很容易的再次使用它。當你定義你自己的指令並給它一個名稱時，就是所謂的函式（function）。現在我們就來使用函式幫助蜜蜂。
      4:
        image: notes/C3_bee_functions_4.png
        text: 在這個範例中，我們的函式叫做 get 2 nectar（採集 2 個花蜜），就是這個綠色積木。若要知道 get 2 netctar 可以做什麼，可以觀看灰色的方框，也就是函式定義。再往下看就可以了解
          get 2 nectar 是要採集一個花蜜，然後再採集一個花蜜的意思。透過查看灰色方框裡的內容，你就能知道這些綠色函式積木可以做些什麼。
    C3_bee_nested_loops:
      1:
        image: notes/C3_bee_nested_loops_1.png
        text: 現在我們要對蜜蜂使用嵌套循環。這裡已經有一些初始代碼了，它告訴蜜蜂前進並採集花蜜三次，然後右轉。讓我們將整塊代碼嵌套在一個重複模塊中，讓它重複3次。完成！
    C3_bounce:
      1:
        image: notes/C3_bounce_1.png
        text: 你將創造專屬於你的彈跳球遊戲，你也能把它分享給你的朋友！多酷啊！
      2:
        image: notes/C3_bounce_2.png
        text: 若想開始，我們必須賦予鍵盤上的方向鍵有控制球拍的功能。
      3:
        image: notes/C3_bounce_3.png
        text: 我們把「移動-向左」積木連接到「當按向左鍵時」積木，然後將「移動-向右」積木連接到「當按向右鍵時」積木底下。試試看，你馬上就能有自己的彈跳球遊戲了！
    C3_computational_thinking:
      1:
        image: notes/C3_computational_thinking_1.png
        text: 這節課叫做計算思維（Computational Thinking）。有時候，學習新遊戲很難對吧？剛開始時，它確實難以理解，而且有時候沒有人教你這些規則，所以你必須自己去弄清楚。
      2:
        image: notes/C3_computational_thinking_2.png
        text: 好消息是，當你學會了一些思考的訣竅後，你能更容易的把事情搞清楚。這些技巧是用看問題和解決問題的獨特方法。在這一課中，你會學會這4個技巧，並且通過和你的朋友一起練習來了解一個遊戲的規則。
      3:
        image: notes/C3_computational_thinking_3.png
        text: 當你將一個大難題打散成很多小片段時，你就是在用你的大腦來「分解」難題。一旦我們將這個大問題分解成數個較小的問題，我們就可以開始使用下一個技巧，它稱為模式匹配（pattern
          match）。
      4:
        image: notes/C3_computational_thinking_4.png
        text: 這時候就需要尋找事物之間的相似性。一旦我找到了一些事物的相同點，我就能明白什麼是不同點。當我把不同點去掉的時候，就叫做「抽象」。
      5:
        image: notes/C3_computational_thinking_5.png
        text: 當我找到了解決一個問題的所有步驟後，我就能把這些步驟按照一定的順序組合起來，這叫做「演算法」。這樣一來，任何人都能用我的方法來解決這個問題。我們將使用這
          4 個步驟，在沒有指導的情況下，找到怎麼玩這個遊戲的方法。在遊戲結束時，你也學會玩類似的遊戲了！
    C3_crowdsourcing:
      1:
        image: notes/C3_crowdsourcing_1.png
        text: 這一節課叫做群眾外包（Crowdsourcing）。在這一課中，我們會用到撲克牌來學習團隊合作可以讓事情變得多麼簡單，而不是依靠個人單打獨鬥。所以，找一些朋友來，一起做一些令人驚嘆的事情。群眾外包就是通過一大堆人的幫助來更快的完成一件事。
      2:
        image: notes/C3_crowdsourcing_2.png
        text: 在計算機科學中，我們隨時都會用到群眾力量 （crowdsourcing）。數以千計的業餘愛好者和專業人士透過電腦彼此串連在一起，一起搜尋數以億計的資訊。探索著像是下一個
          Mersenne prime number ，甚至有可能跟外星生物通訊。
      3:
        image: notes/C3_crowdsourcing_3.png
        text: 當你在看電影時，電影中的每一秒都是由 24 張單獨的圖片組成的，我們稱那些為幀（frames）。每一張圖片都需要被創建、渲染，然後組合到一起。我的團隊和我都是軟體開發人員，我們一起工作來編寫一些軟體能創建圖片，就像你在屏幕上最終看到的圖像一樣。這些軟體工具，能夠讓藝術家和其他開發人員通過團隊合作和流程，製造出他們想在屏幕上播放的圖像。
      4:
        image: notes/C3_crowdsourcing_4.png
        text: 例如，在《海底總動員》尋找尼莫的片段，柯路西、斯庫特和他們朋友在東澳大利亞洋流裡面穿梭著，你會看見在海龜背上和小魚的兩邊都看見水流的倒影。所有這些，都是通過數學和我們的電腦程式來生成的。藝術家們用這些軟件調整最終圖像，讓它看起來更美，更有趣。
    C3_dice_race:
      1:
        image: notes/C3_dice_race_1.png
        text: 這課叫做擲骰子比賽。幾乎每個人都喜歡玩電腦遊戲，但你有沒有想過程式師是怎樣將遊戲的步驟編寫出一個程序的？設計電腦遊戲以及解決問題的第一步，就是要思考和計劃。
      2:
        image: notes/C3_dice_race_2.png
        text: 思考如何一步一步的解決問題就是演算法，用步驟來解決問題或完成任務。這堂課裡，你會為骰子遊戲設計演算法。然後請你的朋友來試試看，看他們是否可以按照你計劃的步驟來玩遊戲。當程式設計師確認步驟是正確的之後，就可以把演算法用電腦看得懂的語言
          (程式語言) 來寫成程式。
      3:
        image: notes/C3_dice_race_3.png
        text: 我們每天做的事情都有一套演算法，你依著步驟來做就可以完成事情。想看看你上學前要準備什麼？或者如何規劃跟朋友一起出遊的行程或者要去吃什麼。要完成這些事情，你需要把它分解成小步驟，有時候這些小步驟還得有一定的順序。
      4:
        image: notes/C3_dice_race_4.png
        text: 想一下要怎麼做一個三明治。你根本不要考慮是否要先打開罐子，因為你沒辦法先塗花生醬後才打開罐子。有些小事情小到我們都不用去思考，但是電腦就需要演算法和程式來告訴它如何做這些小事情。
      5:
        image: notes/C3_dice_race_5.png
        text: 電腦真正執行的是程式裡的指令，而程式是讓電腦執行它背後的想法，這就是演算法。演算法轉化為程式讓電腦去執行。有時候要把步驟拆解成演算法會遇到困難。但就就像學習新的技能一樣，透過不斷的練習就會愈來愈簡單。
    C3_farmer_while:
      1:
        image: notes/C3_farmer_while_1.png
        text: 當…迴圈相當類似於你日常生活做的事。想像你在洗車時，你會不斷的擦車直到它乾淨。當它不乾淨時，你就繼續擦。你都在做這樣的事，無時無刻。
      2:
        image: notes/C3_farmer_while_2.png
        text: 我們有個新的迴圈可以幫助你的農夫，它叫做當…積木。它相當的容易使用。當在上頭的陳述式結果為 true，就做一些事情。舉個例來說，當那裡有個土堆時，就移除一部分，趕快和你的農夫試驗一下。
    C3_functional_suncatchers:
      1:
        image: notes/C3_functional_suncatchers_1.png
        text: 這一節課叫作函式透光窗飾。你將會通過函式來創作出漂亮的窗飾。這裡有創建窗飾的步驟，有些步驟可能需要重複很多次。
      2:
        image: notes/C3_functional_suncatchers_2.png
        text: 要簡化創作透光窗飾過程的第一步，是要找出哪些步驟會重複多次。我們可以群組這些步驟，放到所謂的函式裡頭。
      3:
        image: notes/C3_functional_suncatchers_3.png
        text: 如果只是按著步驟製作，是沒有辦法創作出個獨一無二的吊飾的。有時候，我們可以創新，像是改變珠子的顏色，通過使用不同的顏色，每個吊飾都會更加別出心裁。
      4:
        image: notes/C3_functional_suncatchers_4.png
        text: 當你開始學習思考把珠子當作變數時，你就能讓你的透光窗飾獨一無二了。變數，表示一個可以改變的東西，每個變數都有自己的名字。用函式和變數做出美麗的透光窗飾吧！
    C3_internet:
      1:
        image: notes/C3_internet_1.png
        text: 這節課是關於網際網路。網路是一個非常繁忙的地方，就像繁忙的馬路一樣。上面的訊息就像汽車，轟轟轟的跑向它們的目的地。訊息在網路上傳送得非常快。
      2:
        image: notes/C3_internet_2.png
        text: 演示網路網路（Internet）是如何運作的，這可以幫助你理解當你在上網過程中發生了哪些事情。你會學到訊息是怎樣從你的電腦傳遞到你喜愛的網站或是你的朋友的電子信箱。這就好比是，當你認識路、看懂信號燈後，就可以輕鬆的在繁忙的馬路上開車。在互聯網上瀏覽網頁也一樣，當你理解了後面發生了什麼，會發現其實並不是那麼複雜。
      3:
        image: notes/C3_internet_3.png
        text: 在互聯網上發送消息，有點像通過郵件發送消息，雖然還是有一點不同。我現在在google.com。這個網站的網絡協議地址（也叫做IP地址）是一個數字。你可以想像這個地址就像是郵件中的回信地址一樣。讓我們想像，我想要通過郵件發一個消息給辦公室那邊的人。你能看到門上的鏈接和網絡地址嗎？我已經寫好了消息，點擊發送。
      4:
        image: notes/C3_internet_4.png
        text: 和郵政系統不同的是，首先發生的事情是互聯網會將消息分成更小的部分，以便它能更容易發送出去。這些小的部分叫做數據包。這個消息的數據包會一個一個的發到目的地。這些數據包都會被排成正確的順序，以便接收者能夠正確的讀出消息。當然，我們還有很多很多關於互聯網如何工作的知識要學，但這是一個很好的開始。你已經在成為一個機智的互聯網用戶的路上了！別忘了告訴你的家人和朋友，你學到了什麼！
      5:
        image: notes/C3_internet_5.png
        text: 我是阿曼達·坎普，我是谷歌的軟件工程師。我在一個用來存放簡介和聯繫人的後台服務器團隊工作。在我的工作中，我們非常仔細的思考如何讓聯繫人數據能被發送到其它設備，例如手機。大多數人都有很多聯繫人，你可能會說，有1000個聯繫人，但我們沒法通過一條消息就把它們發送到你的手機上，因為這實在是太大了。和互聯網將消息拆分成數據包一樣，我們用叫做“分頁”的概念來每次發送100個聯繫人，等待手機響應以後，再發送下100個。
      6:
        image: notes/C3_internet_6.png
        text: 關於軟件最令人激動的事情是它能夠影響整個世界。我在19歲的時候第一次編寫了程序。我想我那時候已經是大學二年級或者三年級了。我記得我寫的第一個程序能把攝氏度轉變成華氏度。我喜歡編程序，因為我希望能幫到別人。我能在谷歌寫程序，幫助到全世界的人，這真令人難以置信和興奮。
    C3_maze_conditionals:
      1:
        image: notes/C3_maze_conditionals_1.png
        text: 人們每天都要做決定。例如，在出門前，你會用一個“如果”判斷語句來說，如果下雨，我就需要穿上戴帽子的夾克。電腦令人驚奇的地方是，一旦你確定了這類判斷語句，它們能用難以置信的速度可靠的執行下去。電腦程序，只需要一點點數學和一些“如果”判斷語句就能幫忙做決定了。
      2:
        image: notes/C3_maze_conditionals_2.png
        text: 如果積木幫助殭屍做決定。它檢查了一些事情，打個比方，我們用這個積木，比如說如果左邊有路，那就放一個左轉的指令到裡頭。這就告訴殭屍要檢查它的周圍，如果有個左邊的路徑就轉彎。
      3:
        image: notes/C3_maze_conditionals_3.png
        text: 接著我們把向前移動的積木放進這個重複積木，讓它持續的向前，只要前面有路的話。然後當有轉彎時，這個如果積木就會告訴它轉向左方。你可以看到假使我們這麼執行的話，當我們遇到轉彎就左轉，否則就往前走，我們就能到達目的地了。
      4:
        image: notes/C3_maze_conditionals_4.png
        text: 這是使用如果陳述式的一個例子，它是計算機編程裡的一個非常基本的概念。我學會的第一件事是如何寫一個井字遊戲的程式。我用到「如果陳述式」，內容是，如果另一個人要贏了，就在那個地方阻止他。享受學習使用如果陳述式的樂趣，它是一個關鍵的概念。
    C3_maze_level_4:
      1:
        image: notes/C3_maze_level_4_1.png
        text: 在這個例子中，你的目標是讓殭屍去向日葵那裡。我們可以使用 5 個向前移動積木，或者我們可以告訴電腦向前移動，然後用 1 個重複積木來重複五次。
      2:
        image: notes/C3_maze_level_4_2.png
        text: 這可以節省時間，而且讓它變得簡單。若要使用它，只要將向前移動的積木放到重複積木裡，點擊運行，然後殭屍就會移動五次走到美味的向日葵那。
    C3_playlab_create_game:
      1:
        image: notes/playlab_1.png
        text: 目前為止你已經製作了一個動畫或故事，在你運行它時，它會執行相同的操作。現在你可以設計一個互動式的、可以玩的遊戲了。
      2:
        image: notes/playlab_2.png
        text: 這裡有些新的積木可以試試。例如「當按方向鍵時」積木以及「移動角色」積木，你可以將這些積木放在一起，利用方向鍵來移動角色。另外還有一些積木會在角色互撞或是被點擊時作用。試試它們，玩得愉快！
    C3_songwriting_with_parameters:
      1:
        image: notes/C3_songwriting_with_parameters_1.png
        text: 這一課我們要寫歌。音樂非常像電腦程序。這些寫好的註釋和詞語能夠幫助歌手精確的明白應該做什麼。音樂的有些部分還被用到了多次。
      2:
        image: notes/C3_songwriting_with_parameters_2.png
        text: 我們稱這作副歌，在一個計算機程式中，不斷被重複利用的程式片段被稱為函式（Functions）。當你在唱歌並讀到「副歌」二字時，你會把這兩個字唱出來嗎？當然不會，你會去頁面上尋找哪些地方被組成了副歌。
      3:
        image: notes/C3_songwriting_with_parameters_3.png
        text: 在這一課中，你會學到一首兒歌，叫做小兔子拂拂。這首歌有一段副歌會被唱好幾遍。函式（function）就是一段程式，你可以呼叫然後使用它不只一次。它讓編程更容易，更有效率，這樣你就不必把在函式裡的每個步驟都再寫出來好多次，只要寫一次就可以了！
    C4_bee_conditional:
      1:
        image: notes/C4_bee_conditional_1.png
        text: 這是條件判斷積木，它是說如果你在花朵或是蜂窩上的話，就做一些事情。這非常有用，當我們不知道有多少的蜂蜜或花蜜時，因為這裡只有問號。
      2:
        image: notes/C4_bee_conditional_2.png
        text: 在這個例子中，我們會說，如果它是朵花，就採集所有花蜜。然後用另一個說，如果是蜂窩就釀蜂蜜，噠啦！
    C4_conditionals:
      1:
        image: notes/C4_conditionals_1.png
        text: 我們有一個新的積木，叫做「如果... 否則」積木。這是個條件判斷陳述式，就像先前用過的「如果」積木一樣。但是它有個叫「否則」的部分。「如果...
          否則」積木讓蜜蜂在兩組操作之中選擇一個來執行。如果蜜蜂在花朵上，蜜蜂會執行第一個你要他做的動作。如果蜜蜂不是在花朵上，蜜蜂會執行在「否則」區間裡的操作。
      2:
        image: notes/C4_conditionals_2.png
        text: 如果陳述式（if statements）讓電腦能夠做出決定。人們設下條件給電腦，讓電腦在某些特定的情況執行這個。否則，或者說除此之外，執行那個。這個「如果..
          否則」積木上面寫，如果在花朵上。但這個如果可以改成其它狀態；像是如果有兩個花蜜，或如果前面有條路。程式積木會用同樣的方式執行判斷。倘若符合如果陳述式的條件，那就會行第一個部分的指令。不成立的話，會執行第二個部分的指令。
    C4_for_loops:
      1:
        image: notes/C4_for_loops_1.png
        text: 當你用重複積木來循環你的程式時，計算機要如何知道是否重複了足夠多的次數了呢？重複積木實際上隱藏了一個更複雜的部分，叫做計數迴圈。它會從一個起始數值，每次增加一定的值，直到結束的數值。
      2:
        image: notes/C4_for_loops_2.png
        text: 例如，一個重複三次的積木會從 1 算到 3，每次增加 1。每次它都會執行迴圈裡面的程式碼。這個計數迴圈（for loop）藉由一個帶有初始值的計數變數來計算已經執行的次數，這個計數變數在迴圈的開始被設定並且在每次迴圈執行時增加，當計數變數比結束值還大的時候，便會停止迴圈。
      3:
        image: notes/C4_for_loops_3.png
        text: 和重複循環相比，計數循環的好處在於你能看到計數器變量，並能在循環中使用它。例如，如果你有一排花，第一朵有一個花蜜，第二朵有兩個花蜜，第三朵有三個。我可以用計數循環來告訴蜜蜂每次收集計數器變量這麼多花蜜。它就會在第一朵收集一個，第二朵兩個，第三朵三個。
      4:
        image: notes/C4_for_loops_4.png
        text: 而且，在計數循環中，你也可以不讓計數器每次加一。你也許可以讓它每次加二，加三，甚至每次都變化它。
    C4_for_loops_bee:
      1:
        image: notes/C4_for_loops_bee_1.png
        text: 當你用重複積木來循環你的程式時，計算機要如何知道是否重複了足夠多的次數了呢？重複積木實際上隱藏了一個更複雜的部分，叫做計數迴圈。它會從一個起始數值，每次增加一定的值，直到結束的數值。
      2:
        image: notes/C4_for_loops_bee_2.png
        text: 例如，一個重複三次的積木會從 1 算到 3，每次增加 1。每次它都會執行迴圈裡面的程式碼。這個計數迴圈（for loop）藉由一個帶有初始值的計數變數來計算已經執行的次數，這個計數變數在迴圈的開始被設定並且在每次迴圈執行時增加，當計數變數比結束值還大的時候，便會停止迴圈。
      3:
        image: notes/C4_for_loops_bee_3.png
        text: 和重複循環相比，計數循環的好處在於你能看到計數器變量，並能在循環中使用它。例如，如果你有一排花，第一朵有一個花蜜，第二朵有兩個花蜜，第三朵有三個。我可以用計數循環來告訴蜜蜂每次收集計數器變量這麼多花蜜。它就會在第一朵收集一個，第二朵兩個，第三朵三個。
      4:
        image: notes/C4_for_loops_bee_4.png
        text: 而且，在計數循環中，你也可以不讓計數器每次加一。你也許可以讓它每次加二，加三，甚至每次都變化它。
    C4_for_loops_no_bee:
      1:
        image: notes/C4_for_loops_no_bee_1.png
        text: 當你用重複積木來循環你的程式時，計算機要如何知道是否重複了足夠多的次數了呢？重複積木實際上隱藏了一個更複雜的部分，叫做計數迴圈。它會從一個起始數值，每次增加一定的值，直到結束的數值。
      2:
        image: notes/C4_for_loops_no_bee_2.png
        text: 例如，一個重複三次的積木會從 1 算到 3，每次增加 1。每次它都會執行迴圈裡面的程式碼。這個計數迴圈（for loop）藉由一個帶有初始值的計數變數來計算已經執行的次數，這個計數變數在迴圈的開始被設定並且在每次迴圈執行時增加，當計數變數比結束值還大的時候，便會停止迴圈。和重複積木比起來，計數迴圈的好處是你可以看到計數變數，並且可以在迴圈中使用它。
    C4_function_create:
      1:
        image: notes/C4_function_create_1.png
        text: 現在你已經會編輯函式積木了吧，是時候從頭創建一個新函式積木了，這真的很簡單，你會看到工具箱裡有個分類叫做函式，如果你點擊這裡，就能看到一個橙色的叫做建立一個函式的按鈕，點擊它，會彈出函式編輯視窗，這和你編輯函式用過的視窗是一樣的。
      2:
        image: notes/C4_function_create_2.png
        text: 像以前一樣，一開始要命名你的函式，然後寫一個描述來說明函式是做什麼用的。例如，它是用來畫正方形，還是畫三角形，然後從工具箱裡拖出積木，放到下面的工作區。記得要拖曳這些積木到函式（綠色積木）裡頭。
      3:
        image: notes/C4_function_create_3.png
        text: 當你完成後，點擊儲存並離開，然後你會回到目前的關卡頁。這個你創建的新函式會是綠色的，就放在工具箱的函式類別裡。就像其他積木一樣，你可以拖曳它，把它放置它到工作區來解決關卡的問題。
    C4_function_edit:
      1:
        image: notes/C4_function_edit_1.png
        text: 在計算機編程中，有一個很棒的事，就是一旦你教會電腦如何執行一個操作，你可以再次呼叫那個功能。你給它一個名字然後呼叫它，那真的就像擴展了這個程式語言。
      2:
        image: notes/C4_function_edit_2.png
        text: 在我們建立的程式中，我們學會了怎樣通過移動和轉彎四次來畫個正方形。我們可以將它變成一個函式，然後將它叫做 draw a square，這樣任何時候我們都可以用它了。我們只要說
          draw a square，然後它就會被呼叫，就可以透過函式裡的指令幫我們畫出正方形。這樣，我們就等於是添加了一個新的概念到這個編程語言。
      3:
        image: notes/C4_function_edit_3.png
        text: 在這一關中，我們已經創建了一個 draw a square（畫個正方形）的函式。你會在工具箱裡看見它，是一個綠色模塊。你需要做的是，將你以前寫的，能畫出正方形程式碼寫到這個函式里。若要做到這一點，點擊
          draw a square 上的編輯按鈕，這會打開函式編輯器。函式編輯器有三個部分。一個是命名函式的地方，它會在顯示在綠色的函式積木上，接著是一個簡短的描述，說明函式的用途是什麼。
      4:
        image: notes/C4_function_edit_4.png
        text: 這個情況下，它會畫出一個正方形。底下是工作區，和你用過的工作區很類似，你可以從工具箱裡拖曳積木到這個工作區。記住將建立正万形的積木放置到綠色的函式積木中，當你做完了，點擊儲存並離開，你會回到目前關卡的工作區上，現在你就可以像其他積木一樣，使用它來解決問題。
    C4_function_parameters:
      1:
        image: notes/C4_function_parameters_1.png
        text: 這個函式畫了一個邊長 50 像素的正方形，看起來還不錯，但如果我們除了畫邊長 50 像素之外，還想畫另一個邊長為 100 像素的正方形呢？我們不應該、也不需要分別建立二個函式來做幾乎一樣的事情，取而代之的，我們能在函式上再加上參數來實現。
      2:
        image: notes/C4_function_parameters_2.png
        text: 參數允許我們將數值傳到一個函式中，這個值會做為一個變量在函式中被使用。讓我們試試加一個參數叫做 length（長度）到這個函式中，從而我們能用它來創造不同大小的正方形。在函式編輯器中，你可以像以前一樣編輯函式名稱和描述，但現在你也可以增加一個參數了。在空間裡寫下你的參數的名字，然後點擊添加參數。這會創建一個紅色的積木，他的名稱就是你剛剛寫的參數名字。現在我們能將向前移動100的積木的值變為參數length
          了，這樣它就能按照 length 移動了。
      3:
        image: notes/C4_function_parameters_3.png
        text: 點擊保存並關閉，然後從工具箱的函式分類中拖曳出你的新建的 create a square（建個正方形）積木。你會看到在 length（長度）旁邊有一個空格，因為這個函式想知道這個長度參數的值應該是多少。從運算分類中拖曳一個數字積木，放到這裡。看看你能如何一次又一次的給這個函式賦予不同的長度，來創造不同大小的正方形？自己試試吧！
    C4_intro:
      1:
        image: notes/C4_intro_1.png
        text: 程式設計通常是用純文字所寫，但 Blocky 讓我們可以用圖像來寫程式，我們只要將積木拖曳排列就可以完成程式，非常直覺。這些積木的背後還是
          code。現在我們用它來建立個程式，幫助憤怒鳥通過迷宮，抓到那群偷蛋的邪惡豬。
      2:
        image: notes/C4_intro_2.png
        text: Blocky 有三個主要部分，在左側是迷宮，你的程式要實作的地方。而上方則是每階段關卡的過關指示。中間區域的左邊則是指令工具箱，裡頭的積木是用來指揮憤怒鳥的命令，右邊就是工作區域，你要你需要用的指令拖曳到這裡，並建立一個程序。
      3:
        image: notes/C4_intro_3.png
        text: 如果我拖曳移動積木到工作區並點擊「遲行」，會發生什麼事呢？這隻鳥會向前移動一格。那如果我想要這隻鳥在移動後做些什麼呢？我可以添加其它的積木到程式中。
      4:
        image: notes/C4_intro_4.png
        text: 我選了「轉向-右方」積木，並把它拖曳到移動積木下，直到黃色箭頭出現，放開後這兩個積木就會貼合在一起。當我再一次點擊「運行」時，這隻鳥就會將堆疊在工作區中的指令由上到下的執行一遍。
      5:
        image: notes/C4_intro_5.png
        text: 如果你想要刪除一個積木，只要將它從程式堆中移出，然後拖曳到垃圾桶。在您點擊運行後，你可以隨時點擊重置按鈕，讓小鳥回到開始點。現在讓我們抓到這些豬吧！
    C4_math_artist:
      1:
        image: notes/C4_math_artist_1.png
        text: 如果我想畫一個長方形，高為 50 像素，寬是高的兩倍。我要編寫什麼程式讓電腦照做？這樣吧，我可以告訴小藝術家往上走 50 點，向左轉，接著走
          100 點。這程式要做兩次，但接下來我要電腦自己做這件事情。
      2:
        image: notes/C4_math_artist_2.png
        text: 在你頭腦中用50乘以2也許不難，但是計算機真的很擅長做這樣的數學題，因此我們應該盡量讓計算機來做這些運算。如果我就用一個叫做高度的變量，然後我能很容易的將它改成50，並且將我的算法改為，告訴小藝術家往上走高度，向右轉，然後走高度的2倍。這也會給我們一個寬度是高度的兩倍的長方形。
    C4_unplugged_algorithms:
      1:
        image: notes/C4_unplugged_algorithms_1.png
        text: 這一課叫做七巧板演算法。七巧板是一個有七塊板子的解謎遊戲，它需要用這七塊板子放到一起拼出各種形狀。你要用演算法來向你的同伴解釋，怎樣拼出這些謎題的圖案。
      2:
        image: notes/C4_unplugged_algorithms_2.png
        text: 一個演算法就是一系列的步驟，這能用來完成一個任務。我們每天都在使用它，例如購物清單，或是做菜的食譜。如果你的演算法太簡陋，這樣就會產生不同的解讀，別人可能就無法按照演算法做到你所想的那樣。如果你想要每個人都能精確做到你想的事情，那麼你的演算法需要很詳細，很具體。
      3:
        image: notes/C4_unplugged_algorithms_3.png
        text: 我現在用了個演算法來完成一幅畫。我想試試為一些狼塗色，但是我並不是一流的畫家。還好，對我這樣的人來說，我能夠利用數字來畫畫，這裡有 40
          種顏色，還有些小寫英文字母及數字組成的字串來告訴你哪個區塊用了哪種顏色。用數字來塗顏色讓我能清楚知道哪個顏色應該被塗到哪裡。
      4:
        image: notes/C4_unplugged_algorithms_4.png
        text: 它非常具體，所以我能夠跟著指示做，塗色之後的作品看起來也會很棒。這是非常好的演算法。如果指令不夠詳細，我的狼看起來就不會很好。當你真的想讓一些事情按照計劃好的那樣發生，指令最好要非常的精確。
    C4_unplugged_binary:
      1:
        image: notes/C4_unplugged_binary_1.png
        text: 每個團隊裡，負責指示的人拿著這張紙，必須指明他們的「關閉」符號是什麼樣的，「打開」符號是什麼樣的。在二進制中，除了你已經明白的 0 和
          1，是只有兩個符號的符號表，就像是整個字母表裡只有 A 和 B。
      2:
        image: notes/C4_unplugged_binary_2.png
        text: 二進制被使用最常見的例子就是在「如果」陳述式中。它是編程裡的經典。程式會一直往前運行，它會說，如果某件事情為 true，那麼就執行這個。否則它不是
          true，就執行別的。如果你想做的事情稍微有些複雜，除了如果陳述式，你想在計算機裡使用圖像或者音訊之類的東西。
      3:
        image: notes/C4_unplugged_binary_3.png
        text: 計算機只知道二進制（binary），不知道圖片。圖像不是由 1 和 0 組成的。那麼你應該怎麼做？這裡有個例子：你有張美麗的圖片，這個圖片實際上是某種形式的信息。所有信息都能被編碼（encode）成二進制或別的，你剛剛已經弄清楚怎麼做了。
      4:
        image: notes/C4_unplugged_binary_4.png
        text: 想像一下，我們將一個網格放到修毛上面，對於每個方格，我們要決定這裡面是黑色多，還是白色多。我們要按照這種方法來塗色。現在，網格的每個單元格都是黑的或者白的了，然後我們說黑找那個方形就是0（二進制數字的0），白方塊是1，另一個二進制的數字。你已經留下了很多1和0了。這就是你怎樣用二進製表達這幅畫。
    C4_unplugged_forloops:
      1:
        image: notes/C4_unplugged_forloops_1.png
        text: 這一課叫做有趣的計數迴圈。在本課中，我們會用一串數字來玩骰子遊戲。每個玩家將擲三次骰子來確定起始值、 終止值和間隔值。在每一輪中，我們從起始值開始循環，並且每次向前走間隔值那麼多步。當我們到達停止值時，就停止循環。得分最高的人獲勝！
      2:
        image: notes/C4_unplugged_forloops_2.png
        text: 計數迴圈（For Loops）可以在很多場合的派上用途。如果你是要成為一位氣象學家，你總是會用上計數迴圈。你好，我是貝琪。我在 EverPower
          Renewables 當一名氣象學家。我為公司位於格爾地區哥倫比亞河的風力發電廠預測風速。
      3:
        image: notes/C4_unplugged_forloops_3.png
        text: 我們試圖理解有多少風量要經過那裡，以便知道會輸出多少電能。我們把這些信息交給實時能源交易商。他們根據我們告訴他們的數字來交易電能，以確保你的電燈接入的電網平衡。並且我們能讓風力發電廠的電能輸出量最大化。
      4:
        image: notes/C4_unplugged_forloops_4.png
        text: 我們在恆力可再生能源位於波特蘭的國家控制中心，它的所有信息都來源於全國各地的風力發電站。當今，即使性能最好的計算機業不能模擬各處的大氣氣象。在電腦的預測模型裡，有我們稱之為網格的東西。網格里的每個點是一個經緯度的位置。我們必須按照物理學計算，並算出風速，溫度，壓力之類的東西。
      5:
        image: notes/C4_unplugged_forloops_5.png
        text: 因為這是一個相當大的網格，裡面有非常多的點，我們會進行萬億次循環來計算這些值。這些值的計算都需要計數循環。這就是一個計數循環的例子。當你試圖預測風時，會有很多不同的參數會影響它。人類基本上是不可能坐下來算出這些數據的。有如此多的不同因素影響了風的產生和發展，所以我們必須有一個計算機模型才能預測它。
    C4_unplugged_madlibs:
      1:
        image: notes/C4_unplugged_madlibs_1.png
        text: 這節課，我們將玩故事填空遊戲。你有一個模板，你可以填入一些東西，來創造有些相似，但又有些差異的故事。
      2:
        image: notes/C4_unplugged_madlibs_2.png
        text: 在這堂課中，我們可以學到，如何從已經被創建出的兩個故事中，構造一個抽象的模型。抽象，是一門藝術，可以移除差異處和細節，從而找到一個解決方案能夠用來解決許多不同的問題。它在計算機科學中非常有用，因為它讓我們能夠建立可能可以應付不同的情況的函式。
    C4_unplugged_parameters:
      1:
        image: notes/C4_unplugged_parameters_1.png
        text: 這一課叫做用參數寫歌。我們要在這裡寫一些歌，有時，副歌在每次唱的時候只有一點點不同。你記得《Old Macdonald Had a Farm》這首歌嗎？每個動物都有個稍微有點不同的副歌部分。在那個農場上，他有一頭奶牛，咿呀咿呀呦。每個副歌中的不同之處，可以通過我們稱作參數的部分來表達。
      2:
        image: notes/C4_unplugged_parameters_2.png
        text: 有時函式需要參數（parameter）。參數是一個額外的資訊片段，你可以用它來傳遞到函式中以達到特定的用途。當你和朋友製作聖代冰淇淋時，你會用到和計算機編程中參數類似的流程。
      3:
        image: notes/C4_unplugged_parameters_3.png
        text: 每個香草冰淇淋聖代的基本組成基本都是一樣的，但當你讓朋友放上兩種自己喜歡的點綴時，你會看到很多不同的組合。冰淇淋的點綴就像是函式的名字，而點綴的類型就是參數。函式和參數在一起就可以組成非常棒的計算機程式，像是非常可口的聖代一樣。
    C4_unplugged_variables:
      1:
        image: notes/C4_unplugged_variables_1.png
        text: 這一課叫做信封中的變數。我們需要學習在缺少信息的情況下，如何構造句子。我們大部分人已經熟悉瞭如何填空。我們會在家庭作業中將自己的姓名寫到空白處。有時，我們需要填寫不止一處空白處，這種情況下，我們會給每個空白一個標籤，這樣我們就知道每處空白應該填寫什麼內容了。
      2:
        image: notes/C4_unplugged_variables_2.png
        text: 變量是一個可變的信息的佔位符。通過將變量用到缺失信息處，我們能夠繼續工作，然後讓別人晚些時候再來填寫缺失的信息。在軟件中，我們大量使用了變量。我們將變量作為名字、電子郵件地址、甚至用戶名的佔位符。這樣，我們可以讓程序知道當用戶填寫了這些信息後，它們應該出現在何處。我們一直在工作中使用變量。
      3:
        image: notes/C4_unplugged_variables_3.png
        text: 當你需要儲存一個過會兒再使用的訊息時，就要用到變數。這樣說吧，我們需要統計用戶發 Twitter 的次數，就會在每次用戶發 twitter
          時，我們會將這個次數加 1，每次用戶刪除一條 twiiter 時，我們會將這個數字減 1。當我們需要知道用戶發了多少條 Twitter 時，只要查看這個變數目前的數值就可以了。
    C4_variables_artist:
      1:
        image: notes/C4_variables_artist_1.png
        text: 一個變數（variable）可以想像成是一個容器，你能在裡頭存放一個值（value）並隨時替換。當你在演算過程中要使用變數，容器就會打開並把裡面的值拿出來。這讓你能寫出一些依據變數值而做不同行為的聰明演算式。
      2:
        image: notes/C4_variables_artist_2.png
        text: 例如，如果你想寫個演算法「生日快樂，你 10 歲了！給我的小弟。」，現在看起來非常棒，但當我明年再使用它時，我希望它自己變成「生日快樂，你
          11 歲了！」，我會創建一個叫做 age 的變數來儲存我弟弟的年齡，然後寫出我的演算法：「生日快樂，你 age 歲了！」因為變數能夠被改變，每年我會將
          age 變數賦值為 age = age + 1。
      3:
        image: notes/C4_variables_artist_3.png
        text: 在這一關，我們會使用一個變數，它會被設成線條的長度（小藝術家畫出的）。稍後在我們的程式中，移動-向前積木將會查看 length（長度）變數裡設定的是什麼數值。
    C4_variables_playlab:
      1:
        image: notes/C4_variables_playlab_1.png
        text: 一個變數（variable）可以想像成是一個容器，你能在裡頭存放一個值（value）並隨時替換。當你在演算過程中要使用變數，容器就會打開並把裡面的值拿出來。這讓你能寫出一些依據變數值而做不同行為的聰明演算式。
      2:
        image: notes/C4_variables_playlab_2.png
        text: 現在，你會試試遊戲實驗室裡的不同遊戲。為了改變遊戲，你可以給速度、高度、分數這些變量不同的值。你不需要改變遊戲的算法來改變整個遊戲，僅僅通過修改變量就足夠了。
      3:
        image: notes/C4_variables_playlab_3.png
        text: 在我為kindle和x-ray for books功能開發時，我們用很多不同的方式使用了變量。一種方法是你能用變量來儲存書的頁碼。用戶可以增加或者減小每頁的字體大小。根據字體的大小，整本書的頁數就會發生變量，我們能通過改變在變量中儲存的頁數來改變它。
    infinity_playlab_events:
      1:
        image: notes/infinity_playlab_events_1.png
        text: 現在，我們會學習到所有遊戲程序員每天都要用到的一些東西。它們被稱為事件。事件告訴你的程序來傾聽某件事情什麼時候發生。然後，當它發生時，會執行一些動作。事件的一些例子包括，鼠標點擊，方向鍵按鈕，或者點擊了屏幕。
      2:
        image: notes/infinity_playlab_events_2.png
        text: 這裡，我們要用鍵盤或是畫面的向上/下鍵，讓杯麵向上移動碰到阿廣，然後向下移動碰到長髮公主。我們會用到「當按向上鍵」積木並連接「移動角色向上」積木，這樣子當玩家點擊向上鍵，附加在「當按向上鍵」裡的程式就會執行。我們也做相同的事讓杯麵往下。循序漸進的，你的遊戲會變得更具互動性。
    infinity_playlab_intro:
      1:
        image: notes/infinity_playlab_intro_1.png
        text: 那麼，你是哪個年級的？二年級。十年級。一年級。我在八年級的時候學習的編程。我六年級的時候有了自己的第一台計算機。讓我感到激動的是，我能解決人們的問題。你可以表達自己，為一個想法做一些事情。
      2:
        image: notes/infinity_playlab_intro_2.png
        text: 計算機科學，是接下來二十、三十年裡，大學生和專業人士要完成很多事情的基礎。我喜歡編程，因為我喜歡幫助別人。我有機會創造一些東西，能讓人們的生活變得更容易。我想這是最接近超能力的事情。入門是一個很重要的關鍵。我是一個初學者，我希望你也和我一起學習。
      3:
        image: notes/infinity_playlab_intro_3.png
        text: 我是 John Vechey。我是 PopCap 遊戲的聯合創始人之一。我們製作許多遊戲，像是植物大戰殭屍、寶石迷陣、幻幻球。所謂的遊戲，不在於你能寫出多完美的程式，不在於你的藝術水平如何，而是它給人的感覺、它多有樂趣。要有培養這種感覺的唯一方式，就是多試、多做、多學習、多調適，以及不斷的鍛鍊你自己製作遊戲的技能。
      4:
        image: notes/infinity_playlab_intro_4.png
        text: 你有喜歡的電視遊戲嗎？好的，我們將會採取一個步驟來創建遊戲，就像使用遊戲實驗室一樣。一個好遊戲需要一個故事，每個故事都需要演員，而演員會做些事情，像說話、移動、互動…也許還需要制定一些得分的規則。今天，我們會和迪士尼的安娜、艾莎、阿廣、杯麵、長髮公主等演員們，來一樣一樣的學到怎樣做到這些事情。我們會從頭創造一個遊戲，你可以分享它，在手機遊玩。
      5:
        image: notes/infinity_playlab_intro_5.png
        text: 你的畫面分割為三部分。左邊是遊戲區，也是程式運行的地方。每一關的說明都會寫在下面。中間是工具箱，裡面的每個積木都是一個指令。右邊的白色區域叫做工作區，是我們編寫程式的地方。
      6:
        image: notes/infinity_playlab_intro_6.png
        text: 一開始，你會需要連接你的程式積木到橘色的「當運行時」積木中。你可以把多個積木連接在一起，拖曳它們直到你看到黃色的線條出現，放開後它們就會貼合在一起。第一個關卡中，阿廣是角色1，杯麵是角色2，我們要讓阿廣移動到杯麵那，就拖曳「移動-向右」積木並連接到「當運行時」積木中。當你放置了積木到工作區後，點擊「運行」按鈕就可以看到你的程式結果。
      7:
        image: notes/infinity_playlab_intro_7.png
        text: 從頭學完後，你能用所有的角色來創建自己的遊戲。你能讓他們之間能夠互動，獲得分數，互相扔東西，甚至能夠消失。這都由你決定！
    infinity_playlab_repeat_forever:
      1:
        image: notes/infinity_playlab_repeat_forever_1.png
        text: 你能想像每天不斷的不斷的做重複的事情嗎？希望你永遠不需要，因為電腦真的非常擅長重複做一件事情。這是「重複無限次」積木。任何在積木裡的東西都會在遊戲中永遠重複下去。
      2:
        image: notes/infinity_playlab_repeat_forever_2.png
        text: 所以如果我們想讓一個角色重複的執行一個操作，但又不需要玩家做任何事情，我們只要將那些積木放到重複無限次積木中。在接下來的關卡，我們的目標是幫安娜不斷地上下走動。學習重複指令是如何作用後，就可以節省你一堆的時間，當你建立你自己的遊戲時。
    tutorial_puzzle_challenge:
      1:
        image: notes/tutorial_puzzle_challenge_1.png
        text: 奧莉維亞，你長大後想幹什麼？當宇航員。你知道電腦程序是什麼嗎？嗯，不知道。等等，是什麼？我真的不確定怎麼解釋，但電腦程序挺簡單的。它就是一組像食譜一樣的指令，你只要一步步的遵循它們，就能得到你想要的結果。
      2:
        image: notes/tutorial_puzzle_challenge_2.png
        text: 我可以改變像素的數值、線段的長度，利用這個下拉清單。開始說是多長來著？你可以再一次觀看指南（在運行按鈕下方）。這裡我用了「移動-向前」積木，然後選擇了
          100 像素。我可以刪除一個積木，只要把它拖曳回工具箱或是垃圾桶。讓我們把它放回來。
      3:
        image: notes/tutorial_puzzle_challenge_3.png
        text: 點擊“運行”來運行代碼。好吧，沒有奏效！我會點擊重置按鈕，然後找找哪裡錯了。只要你願意，就可以嘗試同一關很多次，也可以跳過某一關，以後再回來看看。一定要盡最大的努力，不要放棄。讓我們添加另一個向前移動的模塊。還是不行。我能將一個模塊放到其他模塊之間。
      4:
        image: notes/tutorial_puzzle_challenge_4.png
        text: 讓我們拖曳出一個轉向積木，然後將它放到兩個移動-向前積木的中間，並設成向左轉 45 度。讓我們再運行一次。重置，運行，棒極了！這是另一個關卡。有時候你會在開始時被提供一些初始的積木。這裡我需要填入合適的長度和角度。
      5:
        image: notes/tutorial_puzzle_challenge_5.png
        text: 有時候你也許會不小心刪除了開始的代碼。那該怎麼辦呢？你可以點擊“清除”按鈕，然後重新開始。我要將這個數字模塊拖到不同的像素區域裡。選擇100像素，45度，再選擇100像素。棒極了！這是代碼工作室的蜜蜂。我需要將蜜蜂挪到每朵花那裡，然後收集花蜜。
      6:
        image: notes/tutorial_puzzle_challenge_6.png
        text: 第一朵花距離是 3 格，所以我需要 2 個向前移動。1、2、3，然後一個採集花蜜，再來是另一個採集花蜜，嗯，失敗了！那我放置另一個移動向前在採集花蜜之間，然後再運行一次，耶，成功了！你剛剛學習了如何使用
          Code Studio 上的藝術家和蜜蜂關卡，祝你在 Code Studio 挑戰關卡時一切順利。
    unplug1:
      1:
        image: notes/unplug1_1.png
        text: 奧莉維亞，你長大後想幹什麼？當宇航員。你知道電腦程序是什麼嗎？嗯，不知道。等等，是什麼？我真的不確定怎麼解釋，但電腦程序挺簡單的。它就是一組像食譜一樣的指令，你只要一步步的遵循它們，就能得到你想要的結果。
      2:
        image: notes/unplug1_2.png
        text: 計算機科學是影響世界的一種方式。它可以是音樂影片，它可以是遊戲，它能檢測兩人是否有關聯，找到你認識的人的朋友。你能在極短時間做到類似這樣瘋狂的事情。我想你真的必須要有一些動力，對我來說它就像是畫筆。我想最棒的程式設計和偉大的藝術創作之間沒什麼不同。
      3:
        image: notes/unplug1_3.png
        text: 當我最後學到了一點編程後，就像白色的牆變成了好多扇門。當你打開它們，你又會發現它們後面又是一個有很多扇門的通道。編程很有趣，而且很容易。你可以做到頭腦裡想到的任何事情。最終，當你打開足夠多的門以後，光就能進來了。對於我來說，完成一個程序就像給一個建築物填滿光一樣。所有角落都被照亮了。你能接觸和交流的人的數量是以前從來沒有過的。
      4:
        image: notes/unplug1_4.png
        text: 這個系列的第一課是關於計算機科學是什麼，計算機科學做什麼，和怎樣你才能對自己使用的技術更負責。雖然這是非常重要的一課，但沒有很多文字。結束的時候，你能夠得到你的名字首字母組成的個性化的編碼。這是由有趣的活動，而且它非常有用，因為二進制是讓人感到非常有技術性的東西之一。一旦你理解了它，就像會說一種秘密語言了一樣。
    unplug2:
      1:
        image: notes/unplug2_1.png
        text: 計算思維（Computational Thinking）的這一課旨在教你如何把一個大型的難題打散分解成數個比較簡單的小問題。這課的目標是寫出一連串的指令，別人能依照這組指令畫出教案中的指定怪物。
      2:
        image: notes/unplug2_2.png
        text: 學生們會被打散成小組，各自寫出一些指示，然後交給其他組別畫出這個怪物。每個組別會用到計算思維中的四個步驟（分解、模式匹配、抽象化、演算法）來寫出指示。
      3:
        image: notes/unplug2_3.png
        text: 首先，小組需要分解任務，這意味著要做一個行動計劃。然後他們需要在目錄裡所有怪物中尋找模式。當他們找到怪物間的不同點後，他們需要抽象，或者移除那些細節。例如，目錄中的怪物有不同的眼睛。但他們都有眼睛，因此我們能畫出一條線，表明怪物都有眼睛。
      4:
        image: notes/unplug2_4.png
        text: 這樣學生就能夠寫出一連串的指令，這就是所謂的演算法（algorithm），演算法列出了怪物的每個部分，並用空白來表示風格。透過這樣的一組指令，他們可以交給其他學生來重建他們自己的怪物。
    unplug3:
      1:
        image: notes/unplug3_1.png
        text: 在方格紙編程中，我們會通過怎麼只用箭頭和塗鴉幫助別人重新畫出圖畫來解釋了代碼是如何工作的。一個人會有一張小的圖畫，他們要通過只用明確的箭頭來試圖描述怎樣重新這張圖。
      2:
        image: notes/unplug3_2.png
        text: 在這個活動中，你只能使用這些符號：向前移動、向後移動、向上移動、向下移動、改變顏色、用顏色填滿方格。一旦你寫好程式碼後，將它交給另一個人來讀這些程式碼，並試著重新畫出這張圖。
    unplug4:
      1:
        image: notes/unplug4_1.png
        text: 在方格紙編程中，我們會通過怎麼只用箭頭和塗鴉幫助別人重新畫出圖畫來解釋了代碼是如何工作的。一個人會有一張小的圖畫，他們要通過只用明確的箭頭來試圖描述怎樣重新這張圖。
      2:
        image: notes/unplug4_2.png
        text: 這活動的過程中，我們可以詢問學生可以摺出十六個相同長方形的方法有哪些。然後可以一起討論為什麼相同的結果可以有不同的解決方案，以及為什麼有些解法在某些情況下比較好。
    unplug5:
      1:
        image: notes/unplug5_1.png
        text: 在方格紙編程中，我們會通過怎麼只用箭頭和塗鴉幫助別人重新畫出圖畫來解釋了代碼是如何工作的。一個人會有一張小的圖畫，他們要通過只用明確的箭頭來試圖描述怎樣重新這張圖。
      2:
        image: notes/unplug5_2.png
        text: 這活動的過程中，我們可以詢問學生可以摺出十六個相同長方形的方法有哪些。然後可以一起討論為什麼相同的結果可以有不同的解決方案，以及為什麼有些解法在某些情況下比較好。
    unplug6:
      1:
        image: notes/unplug6_1.png
        text: 這個活動叫做用撲克牌編程，適合任何年齡。就像你先前學習的如果陳述式，在 Blocky 中，如果陳述式中有個部分，是關於怎樣找到它是 true
          還是 false 的部分。這就是條件判斷，它能被應用在很多不同的地方。
      2:
        image: notes/unplug6_2.png
        text: 我們會在紙上創建程式，利用隨機抽出撲克牌的方式。你可能需要用到如果陳述式，像是如果抽出的牌大於大於 8，就得一分，否則就是你的對手得分。你可以讓它變更簡單或是變得複雜，隨你的感覺而定。
    unplug7:
      1:
        image: notes/unplug7_1.png
        text: 你知道嗎，當你查閱歌詞時，會發現副歌會被定義在最開始處，然後在歌詞中只有它們的引用？這就像調用函數一樣。
      2:
        image: notes/unplug7_2.png
        text: 在本節課中，我們在一首歌的開頭就定義了副歌部分，我們唱一遍然後再回來，我們注意到班級並沒有唱“副歌”這個詞，他們自動到了我們定義副歌的地方並且唱了一遍。我們將這個作為一個很好的介紹，來理解當一個程序定義並調用一個函數時做了什麼。
      3:
        image: notes/unplug7_3.png
        text: 我們會一些熟悉的曲子，像是 Old Macdonald，來談一談副歌是如何被一遍一遍的被呼叫，以及有時它是如何能改變的。當你找了一首像
          Old Macdonald 這樣的歌時，某些地方會有單詞的改變，這是引入參數概念最恰當的時機。傳入某些單詞，就像就可以向函式傳達額外信息。一旦確信每個人都明白它了，你可以找一些熟悉的歌曲，分解它們，看看你能否將它們重新組合起來。
    unplug8:
      1:
        image: notes/unplug8_1.png
        text: 我們在“抽象”這個課程中會用到和瘋狂字謎類似的概念。你在故事中的空白處可以填上很多不一樣的詞。我們用這個注意來讓孩子們用自己的詞語來創建自己的故事，而且真的能夠解釋了“抽象”這個概念。
      2:
        image: notes/unplug8_2.png
        text: 這部分是關於函式（Functions）和你可以如何創建函式。就像 Old Macdonald，歌曲中副歌的部分有一個結構，但每次都可以有一點不一樣。你可以把不一樣的部分抽象出來，然後每次填上自己的詞。但是有時候會有三個詞不一樣，所以將它們把它們放到三個參數裡會更好。
      3:
        image: notes/unplug8_3.png
        text: 你可以用一個函式來處理很多不一樣的問題。很多時候，人們會為這些問題寫出不同的函式，而沒意識到其實只有一點不同。如果他們能找到一個方法來處理這一點點的不同，就能一次次的重用同一個函式，而不是由14個不同的函式。
    unplug9:
      1:
        image: notes/unplug9_1.png
        text: 接力編程是一個非常有趣的課程，不只是有計算機科學。有時候，每個人都有有點煩躁不安，你想讓他們站起來。這是一個很好的辦法，能給計算機科學帶來興奮。
      2:
        image: notes/unplug9_2.png
        text: 你需要將所有人分成兩組，他們會排成兩列，準備好接力比賽。每個組的第一個人會跑到場地的另一邊，那裡會有準備好的圖紙，和一張白紙等著他們。他們會寫下創建這個圖像的第一步，然後跑回他們的隊伍，拍到下一個人。下一個人一樣跑過去再寫一步。
      3:
        image: notes/unplug9_3.png
        text: 這是一個把除錯（Debugging）搞明白的好方法，你需要校對你自己的工作，然後需要檢查前面的人是否做對了。你會馬上明白，認真寫好你的代碼是一件多重要的事，因為整個團隊都依靠你。
    unplug10:
      1:
        image: notes/unplug10_1.png
        text: 這個活動用一個容易理解的方式解釋了網際網路是怎麼運作的。我們用簡單的方式解釋了所有你需要的術語，這樣一來學生就能夠揣模像電子郵件這樣的訊息傳送方式。
      2:
        image: notes/unplug10_2.png
        text: 學生模仿三個傳輸方法（無線網路、有線網路、光纖網路）中的其中一個來交換訊息。代表無線傳輸的學生將消息放在頭上，因為無線網路最有可能丟失一些訊息。
      3:
        image: notes/unplug10_3.png
        text: 假裝用有線網路傳輸的學生把訊息放在手背上，這裡不容易丟失訊息。而用光纖傳遞訊息的學生則用雙手，這個活動是理解我們每天使用的網路的好方法。
    unplug11:
      1:
        image: notes/unplug11_1.png
        text: 現在是時候回顧一下了，縱觀你在過去 19 堂課中完成的所有東西。這是個好時機，快讓學生知道他們剛完成了多麼大的成就。他們在這些教學內容裡學到了比大多數成年人還多的計算機科學知識。
      2:
        image: notes/unplug11_2.png
        text: 在班級或者小組裡面討論他們喜歡哪一堂課。一旦你回顧已經學到的東西，你會發現學生們的創造力是如何發光的。將它們分成小組，讓他們創造一個自己的線下課程。給每個小組分派一個關鍵的概念，比如函數、算法，再給他們一些手工藝的材去使用。讓每個小組都演示他們新的線下活動，甚至在某天讓大家參與一下他們自己創造的活動。
      3:
        image: notes/unplug11_3.png
        text: 對於在 Code.org 的每個人，我們希望你能在課程中獲得大量的樂趣。不管你的夢想是不是創建最好最新的 app，還是用程式來幫助治療疾病，或者你只是想成為一個善於解決問題的人，這個課程都是實現這些夢想的第一步。
    starwars_intro:
      1:
        image: notes/starwars_intro_1.JPG
        text: 嗨，我是凱瑟琳 · 肯尼迪，我是《星球大戰：原力覺醒》的製作人。今天你將與我們的明星之一--BB-8--合作。 BB-8 是一個球形的機器人。他所做的每一個動作都由計算機軟件控制。計算機影響著每一個行業，從市場營銷到健康再到電影。事實上，一部像《原力覺醒》一樣的電影需要數以百計的電腦工程師一起工作才能完成。
      2:
        image: notes/starwars_intro_2.JPG
        text: Hi，我是 Rachel Rose，我是 ILM 的一名高級研發工程師，我帶領動畫和生物開發團隊。在《原力覺醒》中，我負責幫助藝術家開發飛船的一部分，這讓角色移動起來像是真的在非常遙遠的星系上。
      3:
        image: notes/starwars_intro_3.JPG
        text: 在接下來的 1 個小時，我們要建立我們自己的星際大戰遊戲。我們會教你基本的編程概念。程式的編寫一般來說都是用文字，而我們要在這裡使用程式積木，如此我們就可以用拖曳組合的方式來編程。但在背後，你還是在創建程式碼。在你嘗試過基礎的程式積木後，我們將會為你轉換成
          JavaScript，它是網路世界最流行的編程語言之一。
      4:
        image: notes/starwars_intro_4.JPG
        text: 開始的時候，我們將和雷伊一起寫程式，控制 BB-8 去收集所有廢零件。你的畫面被分成三個部分。左邊是星際大戰遊戲的空間。每個關卡的指引則寫在這個遊戲空間的下面。
      5:
        image: notes/starwars_intro_5.JPG
        text: 中間的區域是工具箱，這些積木都是 BB-8 可以理解的指令。
      6:
        image: notes/starwars_intro_6.JPG
        text: 右邊的空白區域稱為工作區，這兒就是我們建立程式的地方。
      7:
        image: notes/starwars_intro_7.JPG
        text: 如果我拖曳「移動-向左」積木到工作區然後點擊運行，會發生什麼事呢？BB-8 會在畫面上往左移動一格。
      8:
        image: notes/starwars_intro_8.JPG
        text: 那如果我想 BB-8 在「移動-向左」積木之後再做些事情，該怎麼做呢？我可以將另一個積木到程式裡。比方說我用「移動-向上」，把它拖到「移動-向左」積木下面，直到高亮顯示出現。然後放下它，這兩個積木就會自動連接在一起。
      9:
        image: notes/starwars_intro_9.JPG
        text: 當我再次點擊運行時，BB-8 將從上到下執行工作區裡連在一起的指令。如果你想要刪除其中一個積木，只要把它拖回工具箱就可以了。
      10:
        image: notes/starwars_intro_10.JPG
        text: 在你點擊運行後，您可以隨時點擊重置按鈕，讓 BB-8 回到一開始的狀態。現在讓我們繼續吧！
    starwars_typing:
      1:
        image: notes/starwars_typing_1.JPG
        text: 積木的背後實際上是 JavaScript 指令。JavaScript 是目前最受專業開發人員歡迎的編程語言。使用積木是剛開始學習編程的一個好方法。而事實上，頂尖大學如哈佛和伯克利學校都開始用這種方式教學。不過在了解了基礎後，工程師就會開始用文字來編寫代碼，因為用打字來編程會更快。
      2:
        image: notes/starwars_typing_2.JPG
        text: 我們可以通過鍵盤輸入數以百計的指令，而不需要在工具箱中找到它們，然後又要把它們拖曳出來。因為從打字開始學習可能會慢一些，所以我們希望你要先試試用積木的方式。
      3:
        image: notes/starwars_typing_3.JPG
        text: 在工作區的右上角，您可以在任何關卡中點擊顯示程式碼按鈕將積木以代碼形式顯示。
      4:
        image: notes/starwars_typing_4.JPG
        text: 在下一課中，我們將以文字模式開始。在這裡你還是可以從工具箱拖曳積木，或你可以直接輸入指令。當您開始輸入時，會看到所有可能的指令顯示在下方。你可以從中挑選，不需逐字打完整個指令，這可以幫你更快設計出程式。我在寫程式時，總是會利用這種自動完成功能。
      5:
        image: notes/starwars_typing_5.JPG
        text: 當你用打字的方式編寫程式時，計算機需要你輸入的非常精確。指令名稱的拼寫和大小寫要完全正確，包括括號和分號。只要是一個小小的打字錯誤，BB-8
          就無法理解程式，也就不能移動了。
      6:
        image: notes/starwars_typing_6.JPG
        text: 當你的某一行程式出錯時，編輯器會將它高亮顯示，這樣你就可以試著變更文本來修正它。
      7:
        image: notes/starwars_typing_7.JPG
        text: 如果你卡關了，你隨時可以用重置按鈕重新開始。你也可以點擊右上角，隨時切換回積木模式。好了，讓我們試試用文字的方式！如果途中做錯了，別氣餒，每個人都是從錯誤中學習的。
    starwars_events:
      1:
        image: notes/starwars_events_1.JPG
        text: 你好，我的名字叫 Charita Carter。我是 Walt Disney Imagineering 的高級創意製作。負責領導團隊開發用戶沉浸式體驗的產品。我們總是在尋找能提高更好的用戶體驗的方法，而科技正是它的核心。
      2:
        image: notes/starwars_events_2.JPG
        text: 恭喜，你做到了！你編程了 BB-8。我認為我們現在該準備做更難點的事情。讓我們繼續吧！既然你已經學會了編程的基礎知識，是時候回來創建由R2-D2
          和 C3PO主演的你自己的遊戲了。
      3:
        image: notes/starwars_events_3.JPG
        text: '要製作一個遊戲，我們需要了解的遊戲程序員每天在使用的東西: 他們被稱為事件。事件告訴你的程序偵聽並等待其發生。當它發生時，就會執行對應的動作。'
      4:
        image: notes/starwars_events_4.JPG
        text: 舉一些事件的例子，像是點擊滑鼠、按下方向鍵或在觸控螢幕上點了一下。
      5:
        image: notes/starwars_events_5.JPG
        text: 這裡我們要讓 R2-D2 往上移動以傳送消息給反抗軍，接著向下移動到其他反抗軍那兒。我們會用到事件（Evnets），讓玩家在使用畫面或鍵盤上的向上/下鍵時讓它移動。
      6:
        image: notes/starwars_events_6.JPG
        text: 我們使用「當按向上鍵時」事件積木並附加「移動-向上」積木到它的下面。當玩下點擊向上鍵，附加在「當按向上鍵時」積木底下的程式就會執行。我們要用一樣的做法來讓
          R2-D2 向下移動。
      7:
        image: notes/starwars_events_7.JPG
        text: 要做到這個，我們會用到一個指令，叫做 whenUp()。當你把這個指令拖出工具箱時，你會看到它開頭和結尾是用大括號而不是分號。這給了我們可以放其它指令的空間。當玩家按了向上鍵，就會執行運行大括號內的每一個指令。
      8:
        image: notes/starwars_events_8.JPG
        text: 我們想要 R2-D2 往上移動，就要放置一個「移動-向上」積木在指令裡。然後我們用同樣的方式讓 R2-D2 向下移動。
      9:
        image: notes/starwars_events_9.JPG
        text: 現在，在能編寫出進階控制機器人的所有程式碼之前，我們可以先讓 R2-D2 對按鈕按下事件做出反應，讓它在畫面上移動。循序漸進的，你的遊戲就會有愈來多的互動性。
    starwars_congrats:
      1:
        image: notes/starwars_congrats_1.JPG
        text: 嗨，我的名字叫 Alice，我領導著產品和工程團隊，就在 Code.org ，還有負責教程，也就是你現在正在玩的這些。
      2:
        image: notes/starwars_congrats_2.JPG
        text: 你剛剛完成了最後一關。祝賀你! 你已經學到了製作自己的星球大戰遊戲的所有東西。現在無需更多的指示，也沒有關卡需要通過。你可以做出你自己的遊戲，由你決定它如何運行。對了，你已經解鎖新的聲音和新的命令，你可以做更多的事了。
      3:
        image: notes/starwars_congrats_3.JPG
        text: "[學生發言]我們製作一個遊戲，大體上是當你抓到澎澎豬時獲得分數。同時每當你獲得河豚豬時，一個暴風突擊隊員會出現。實際上整個屏幕全是澎澎豬，當你得到
          10,000分時就贏了。"
      4:
        image: notes/starwars_congrats_4.JPG
        text: "[學生發言] 我們做的遊戲中，你不能輸，你消滅任何東西都會得分。我把按鍵反轉了，每當您單擊向上時，你的角色會往下，而當你點擊向右時，你的角色卻往會左。它是真的很難!
          如果你是遊戲開發者，有時候你會得到不公平的優勢。是不是呀？耶!"
      5:
        image: notes/starwars_congrats_5.JPG
        text: 當你製作完遊戲時，選擇分享可取得連結。分享給好友，或玩你的遊戲，在你的手機上。玩得開心！
    starwars_blocks_intro:
      1:
        image: notes/starwars_blocks_intro_1.JPG
        text: 嗨，我是凱瑟琳 · 肯尼迪，我是《星球大戰：原力覺醒》的製作人。今天你將與我們的明星之一--BB-8--合作。 BB-8 是一個球形的機器人。他所做的一切和每一個動作都由計算機軟件控制。計算機影響著每一個行業，從市場營銷到生理健康再到電影。事實上，一部像《原力覺醒》一樣的電影需要數以百計的電腦工程師一起工作才能完成。
      2:
        image: notes/starwars_blocks_intro_2.JPG
        text: 嗨，我是 Rachel Rose，我是 ILM 的一名高級研發工程師，我帶領動畫和生物開發團隊。在原力覺醒中，我負責幫助藝術家開發服裝，那是角色中的一部分，這些角色的部分讓他們看起來非常像是真的來自遙遠的銀河系。
      3:
        image: notes/starwars_blocks_intro_3.JPG
        text: 在接下來的 1 個小時，我們要建立我們自己的星際大戰遊戲。我們會教你基本的編程概念。程式的編寫一般來說都是用文字，而我們要在這裡使用程式積木，如此我們就可以用拖曳組合的方式來編程。開始吧，我們和雷伊一起編程
          BB-8，幫助它收集到所有的零件。
      4:
        image: notes/starwars_blocks_intro_4.JPG
        text: 您的屏幕分成三個部分。左邊是運行代碼的星球大戰遊戲空間。每個關卡的說明寫在遊戲空間的下面。
      5:
        image: notes/starwars_blocks_intro_5.JPG
        text: 中間的區域是工具箱，這些積木都是 BB-8 可以理解的指令。
      6:
        image: notes/starwars_blocks_intro_6.JPG
        text: 在右邊的空白稱為工作區，這是我們構建我們程式的地方。
      7:
        image: notes/starwars_blocks_intro_7.JPG
        text: 如果我拖曳「移動-向左」積木到工作區然後點擊運行，會發生什麼事呢？BB-8 會在畫面上往左移動一格。
      8:
        image: notes/starwars_blocks_intro_8.JPG
        text: 那如果我想 BB-8 在「移動-向左」積木之後再做些事情，該怎麼做呢？我可以將另一個積木到程式裡。比方說我用「移動-向上」，把它拖到「移動-向左」積木下面，直到高亮顯示出現。然後放下它，這兩個積木就會自動連接在一起。當我再次按下運行時，BB-8
          將從上到下執行工作區裡的所有指令。
      9:
        image: notes/starwars_blocks_intro_9.JPG
        text: 如果你要刪除一個積木，只要移出積木堆，並且把它拖曳回工具箱。
      10:
        image: notes/starwars_blocks_intro_10.JPG
        text: 在你點擊運行後，您可以隨時點擊重置按鈕，讓 BB-8 回到一開始的狀態。現在讓我們繼續吧！
    starwars_blocks_events:
      1:
        image: notes/starwars_blocks_events_1.JPG
        text: 你好，我的名字叫 Charita Carter。我是 Walt Disney Imagineering 的高級創意製作。負責領導團隊開發用戶沉浸式體驗的產品。我們總是在尋找能提高更好的用戶體驗的方法，而科技正是它的核心。
      2:
        image: notes/starwars_blocks_events_2.JPG
        text: 恭喜，你做到了！你編程了 BB-8。我認為我們現在該準備做更難點的事情。讓我們繼續吧！既然你已經學會了編程的基礎知識，是時候回來創建由R2-D2
          和 C3PO主演的你自己的遊戲了。
      3:
        image: notes/starwars_blocks_events_3.JPG
        text: '要製作一個遊戲，我們需要了解的遊戲程序員每天在使用的東西: 他們被稱為事件。事件告訴你的程序偵聽並等待其發生。當它發生時，就會執行對應的動作。'
      4:
        image: notes/starwars_blocks_events_4.JPG
        text: 舉一些事件的例子，像是點擊滑鼠、按下方向鍵或在觸控螢幕上點了一下。
      5:
        image: notes/starwars_blocks_events_5.JPG
        text: 這裡我們要讓 R2-D2 往上移動以傳送消息給反抗軍，接著向下移動到其他反抗軍那兒。我們會用到事件（Evnets），讓玩家在使用畫面或鍵盤上的向上/下鍵時讓它移動。
      6:
        image: notes/starwars_blocks_events_6.JPG
        text: 我們使用「當按向上鍵時」事件積木並附加「移動-向上」積木到它的下面。當玩下點擊向上鍵，附加在「當按向上鍵時」積木底下的程式就會執行。我們要用一樣的做法來讓
          R2-D2 向下移動。現在取代事先編寫的用來控制我們的機器人的程式，我們可以讓 R2-D2 對按鈕點擊的事件做出反應，讓它在畫面上移動。
      7:
        image: notes/starwars_blocks_events_7.JPG
        text: 循序漸進的，你的遊戲會變得愈來愈有互動性。
    starwars_blocks_congrats:
      1:
        image: notes/starwars_blocks_congrats_1.JPG
        text: 嗨，我的名字叫 Alice，我領導著產品和工程團隊，就在 Code.org ，還有負責教程，也就是你現在正在玩的這些。
      2:
        image: notes/starwars_blocks_congrats_2.JPG
        text: 你剛剛完成了最後一關。祝賀你! 你已經學到了製作自己的星球大戰遊戲的所有東西。現在無需更多的指示，也沒有關卡需要通過。你可以做出你自己的遊戲，由你決定它如何運行。對了，你已經解鎖新的聲音和新的命令，你可以做更多的事了。
      3:
        image: notes/starwars_blocks_congrats_3.JPG
        text: "[學生發言]我們製作一個遊戲，大體上是當你抓到澎澎豬時獲得分數。同時每當你獲得河豚豬時，一個暴風突擊隊員會出現。實際上整個屏幕全是澎澎豬，當你得到
          10,000分時就贏了。"
      4:
        image: notes/starwars_blocks_congrats_4.JPG
        text: "[學生發言] 我們做的遊戲中，你不能輸，你消滅任何東西都會得分。我把按鍵反轉了，每當您單擊向上時，你的角色會往下，而當你點擊向右時，你的角色卻往會左。它是真的很難!
          如果你是遊戲開發者，有時候你會得到不公平的優勢。是不是呀？耶!"
      5:
        image: notes/starwars_blocks_congrats_5.JPG
        text: 當你製作完遊戲時，選擇分享可取得連結。分享給好友，或玩你的遊戲，在你的手機上。玩得開心！
    mc_intro:
      1:
        image: notes/mc_intro_1.JPG
        text: 我是 Jens Bergensten，大家叫我 Jeb。我在斯德哥爾摩的 Mojang 工作，擔任 Minecraft 首席開發師。記得我是在十一或十二歲開始玩程式設計，因為我想製作遊戲。我父親的一個朋友告訴我，想做些遊戲的話，必須學習如何編程，因此開始了我的程式之路。我平常喜歡設計和研究遊戲的架構，這正是我最愛
          Minecraft 的地方。
      2:
        image: notes/mc_intro_2.JPG
        text: 接下來的 1 小時，你會學習到基本的計算機科學。藉由用程式控制 Alex 或 Steve，讓他們在 Minecraft 虛擬世界中活動。
      3:
        image: notes/mc_intro_3.JPG
        text: 傳統的編程通常是用純文字，不過今天我們會用到 blocky：一個積木化的系統，你可以透過拖曳的方式來寫程式。在背後，你其實是在建立 JavaScript
          代碼。
      4:
        image: notes/mc_intro_4.JPG
        text: 你在這裡會學到的概念，是程式設計師每天都在用的，也是資訊計算機科學的基礎。在 Mojang 這裡，我們也用同樣的概念，來完成 Minecraft
          的工作。
      5:
        image: notes/mc_intro_5.JPG
        text: 在開始前，選個你要的角色，我選擇 Alex。讓我們用代碼來組成程式，幫助她在螢幕上四處移動。
      6:
        image: notes/mc_intro_6.JPG
        text: 你的畫面分成三個主要部份，左邊是 Minecraft 的遊戲區域，也就是你的程式的運行處。指南會顯示在每個關卡下方。
      7:
        image: notes/mc_intro_7.JPG
        text: 中間的部分是工具區，這些積木可以讓 Alex 做動作。
      8:
        image: notes/mc_intro_8.JPG
        text: 右邊的空白區域稱為工作區，這兒就是我們建立程式的地方。
      9:
        image: notes/mc_intro_9.JPG
        text: 如果我們拖曳「移動-向前」積木到我們的工作區，然後按下「運行」，會怎樣呢？Alex 會往前移動一格。
      10:
        image: notes/mc_intro_10.JPG
        text: 那如果我們想做其他動作，在她往前移動之後？我們可以添加其他積木到程式，比方說我選擇「轉向-右方」積木，把它拖到「移動-向前」下面，直到橘色線條出現，再把它放下。這樣兩個積木就會黏在一起。當我們按下運行時，Alex
          就會依照指令由上而下的做出動作。
      11:
        image: notes/mc_intro_11.JPG
        text: 如果你想要刪除其中的積木，只要把它從程式區拖回工具區。
      12:
        image: notes/mc_intro_12.JPG
        text: 若要還原你的變更，並返回到關卡原來的樣子，可以使用「重新開始」按鈕（在右上角）。還有件事，有看到小小的三角形嗎（在「轉向」積木旁邊）？只要看到這樣的三角形，就表示你可以有不同的選擇。讓我們開始寫程式吧！
    mc_repeat:
      1:
        image: notes/mc_repeat_1.JPG
        text: 我是 Lydia Winters，Mojang 的品牌總監，我們製作了一個小遊戲，叫做 Minecraft。
      2:
        image: notes/mc_repeat_2.JPG
        text: 我最愛的事情，在 Minecraft 裡，就是探險。我喜歡在洞穴冒險，看看我能發現些什麼。對於不是程式設計師的人來說，我真的很興奮，能夠透過
          Minecraft 課程自行學習到如何寫程式。
      3:
        image: notes/mc_repeat_3.JPG
        text: 最後一關需要一大堆的「移動-向前」積木，要變得簡單一點的話，就是直接告訴電腦我要前進四或五次。很幸運的是，電腦很擅長重複執行指令，透過重複循環。
      4:
        image: notes/mc_repeat_4.JPG
        text: 在建置 Minecraft 時，我們用了重複循環的方式來放置所有素材以創建一個新的世界，那可是成千上萬個的方塊。我們也利用迴圈做其他的事，例如，讓
          Alex 向前、向後移動，就像她自己在走路一樣。循環迴圈是很強大的，在編寫程式時。
      5:
        image: notes/mc_repeat_5.JPG
        text: 夜晚即將到來，所以在接下來的關卡中，我們要蓋個房子以策安全，我們將會用到「循環」積木來輕鬆地完成。
      6:
        image: notes/mc_repeat_6.JPG
        text: 要建造房子的一堵牆，我們可以告訴 Alex 向前移動並放下木板，連續做四次；或是我們可以告訴她向前移動，並放下一個木板，接著將這串指令放進「循環」積木之中，如此她就可以會執行同樣的操作很多次。現在，我們點擊「循環」積木，並告訴她要執行幾次這個操作，現在蓋完我們的房子，在夜晚來臨之前！玩的開心。
    mc_if_statements:
      1:
        image: notes/mc_if_statements_1.JPG
        text: 現在我們要學習如果陳述式。如果陳述式是基本的部分，對寫程式來說。它們幫助電腦做決定。
      2:
        image: notes/mc_if_statements_2.JPG
        text: 所有計算機都會用到如果陳述式，包括我的手機，舉個例子，當我要解鎖手機，它會運行一些程式，「如果」我輸入了正確的密碼，就解鎖手機；否則，它會出現錯誤訊息。
      3:
        image: notes/mc_if_statements_3.JPG
        text: 你可以使用如果陳述式，在你的程式裡，讓 Steve 和 Alice 對他們看到的東西產生反應。打個比方，「如果」有個石頭在前面，他們可以向左轉，或是轉向右邊，「如果」他們碰到樹。
      4:
        image: notes/mc_if_statements_4.JPG
        text: 這個關卡中，我們不想跌進熔岩裡，很容易避開熔岩吧，那是因為我們可以在畫面上看到它。但是怎麼避開那些藏在石頭下的？
      5:
        image: notes/mc_if_statements_5.JPG
        text: 在採完礦後，我們必須檢查是不是有熔岩在那個地方，在往前走之前。「如果」有熔岩在那兒，我們要放一塊石頭到我們的角色的前方，在向前走之前。這樣我們才可以安全移動。開始採礦囉！記住利用如果陳述式小心的前進吧。
    mc_congrats_share:
      1:
        image: notes/mc_congrats_share_1.JPG
        text: 恭喜！你已學會了計算機科學中基礎的程式積木用法。
      2:
        image: notes/mc_congrats_share_2.JPG
        text: 現在，你能用這些積木來發揮自己的創意。不會再有指南，也沒有什麼關卡要完成。你可以建立任何東西，你想的到的。一切由你做主。
      3:
        image: notes/mc_congrats_share_3.JPG
        text: "[學生們的聊天] 讓它變得更真實。修剪羊毛。我用火把排成了 L。我用木板製作了個 A。有用，有用耶。我們蓋了間房子，用羊毛！"
      4:
        image: notes/mc_congrats_share_4.JPG
        text: 當您完成了你的創作時，選擇分享，取得連結來分享給你的朋友。玩得愉快！
    mc_congrats_no_share:
      1:
        image: notes/mc_congrats_no_share_1.JPG
        text: 恭喜！你已學會了計算機科學中基礎的程式積木用法。
      2:
        image: notes/mc_congrats_no_share_2.JPG
        text: 現在，你能用這些積木來發揮自己的創意。不會再有指南，也沒有什麼關卡要完成。你可以建立任何東西，你想的到的。一切由你做主。
      3:
        image: notes/mc_congrats_no_share_3.JPG
        text: "[學生們的聊天] 讓它變得更真實。修剪羊毛。我用火把排成了 L。我用木板製作了個 A。有用，有用耶。我們蓋了間房子，用羊毛！"
      4:
        image: notes/mc_congrats_no_share_4.JPG
        text: 現在你可以建立任何你想要的，玩得開心！
    gumball_intro:
      1:
        image: notes/gumball_intro_1.JPG
        text: 如果你想創造自己的遊戲，那真的很容易。所有你需要的只是一些基礎的編程知識，然後你就可以開始玩你創造的遊戲了。
      2:
        image: notes/gumball_intro_2.JPG
        text: 你有喜歡的電視遊戲嗎？好的，我們將會採取一個步驟來創建遊戲，就像使用遊戲實驗室一樣。一個好遊戲需要一個故事，每個故事都需要演員，而演員會做些事情，像說話、移動、互動…也許還需要制定一些得分的規則。今天，我們會一樣一樣的學到怎樣做到這些事情，我們會從頭創造一個遊戲，你可以將它共享出來，在手機上遊玩。
      3:
        image: notes/gumball_intro_3.JPG
        text: 今天，我們會一樣一樣的學到怎樣做到這些事情。我們會從頭創造一個遊戲，你可以分享它，在手機遊玩。
      4:
        image: notes/gumball_intro_4.JPG
        text: 你的畫面分割為三部分。左邊是遊戲區，也是程式運行的地方。每一關的說明都會寫在下面。
      5:
        image: notes/gumball_intro_5.JPG
        text: 中間是工具箱，這裡的每個積木都是一段程式。
      6:
        image: notes/gumball_intro_6.JPG
        text: 右邊的空白區域稱為工作區，這兒就是我們建立程式的地方。
      7:
        image: notes/gumball_intro_7.JPG
        text: 一開始，你會需要連接你的程式積木到橘色的「當運行時」積木中。你可以把多個積木連接在一起，拖曳它們直到你看到黃色的線條出現，放開後它們就會貼合在一起。
      8:
        image: notes/gumball_intro_8.JPG
        text: 在第一個關卡中，我們讓角色說了一些話，透過連結「說出」積木到「當運行時」積木然後輸入了你的訊息，當你完成你的積木，點擊運行按鈕來看看你的編程。
      9:
        image: notes/gumball_intro_9.JPG
        text: 從頭學完後，你能用所有的角色來創建自己的遊戲。你能讓他們之間能夠互動，獲得分數，互相扔東西，甚至能夠消失。這都由你決定！
    gumball_events:
      1:
        image: notes/gumball_events_1.JPG
        text: 現在，我們會學習到所有遊戲程序員每天都要用到的一些東西。它們被稱為事件。事件告訴你的程序來傾聽某件事情什麼時候發生。然後，當它發生時，會執行一些動作。
      2:
        image: notes/gumball_events_2.JPG
        text: 舉一些事件的例子，像是點擊滑鼠、按下方向鍵或在觸控螢幕上點了一下。
      3:
        image: notes/gumball_events_3.JPG
        text: 這裡，我們會在玩家點擊角色時，讓他說些什麼。我們會用到「當點擊時」積木，然後附加一個「說出」積木。當玩家點擊時，所有連接在下面積木將會被執行。
      4:
        image: notes/gumball_events_4.JPG
        text: 這裡也有「當方向鍵被按下時」的積木。如果在這些積木下方連結「移動」積木，你就可以開始讓你的角色向上、下、左、右方移動。循序漸進的，你的遊戲會有愈來愈多的互動性。
    gumball_repeat:
      1:
        image: notes/gumball_repeat_1.JPG
        text: 你能想像每天不斷的不斷的做重複的事情嗎？希望你永遠不需要，因為電腦真的非常擅長重複做一件事情。
      2:
        image: notes/gumball_repeat_2.JPG
        text: 這是重複無限次積木，在積木裡的任何東西都會在遊戲中永遠重複。如果我們想讓一個角色重複地做一些事 - 在沒有玩家操作的情況下。我們可以放置那些程式到重複無限次積木裡。
      3:
        image: notes/gumball_repeat_3.JPG
        text: 在下一關中，我們的目標是幫助角色能連續的完成工作。從中學習如何使用重複指令來節省大量的時間 - 當你在創建自己的遊戲時。
    iceage_intro:
      1:
        image: notes/iceage_intro_1.JPG
        text: 如果你想創造自己的遊戲，那真的很容易。所有你需要的只是一些基礎的編程知識，然後你就可以開始玩你創造的遊戲了。
      2:
        image: notes/iceage_intro_2.JPG
        text: 你有喜歡的電視遊戲嗎？好的，我們將會採取一個步驟來創建遊戲，就像使用遊戲實驗室一樣。一個好遊戲需要一個故事，每個故事都需要演員，而演員會做些事情，像說話、移動、互動…也許還需要制定一些得分的規則。今天，我們會一樣一樣的學到怎樣做到這些事情，我們會從頭創造一個遊戲，你可以將它共享出來，在手機上遊玩。
      3:
        image: notes/iceage_intro_3.JPG
        text: 今天，我們會一樣一樣的學到怎樣做到這些事情。我們會從頭創造一個遊戲，你可以分享它，在手機遊玩。
      4:
        image: notes/iceage_intro_4.JPG
        text: 你的畫面分割為三部分。左邊是遊戲區，也是程式運行的地方。每一關的說明都會寫在下面。
      5:
        image: notes/iceage_intro_5.JPG
        text: 中間是工具箱，這裡的每個積木都是一段程式。
      6:
        image: notes/iceage_intro_6.JPG
        text: 右邊的空白區域稱為工作區，這兒就是我們建立程式的地方。
      7:
        image: notes/iceage_intro_7.JPG
        text: 一開始，你會需要連接你的程式積木到橘色的「當運行時」積木中。你可以把多個積木連接在一起，拖曳它們直到你看到黃色的線條出現，放開後它們就會貼合在一起。
      8:
        image: notes/iceage_intro_8.JPG
        text: 在第一個關卡中，我們讓角色說了一些話，透過連結「說出」積木到「當運行時」積木然後輸入了你的訊息，當你完成你的積木，點擊運行按鈕來看看你的編程。
      9:
        image: notes/iceage_intro_9.JPG
        text: 從頭學完後，你能用所有的角色來創建自己的遊戲。你能讓他們之間能夠互動，獲得分數，互相扔東西，甚至能夠消失。這都由你決定！
    iceage_events:
      1:
        image: notes/iceage_events_1.JPG
        text: 現在，我們會學習到所有遊戲程序員每天都要用到的一些東西。它們被稱為事件。事件告訴你的程序來傾聽某件事情什麼時候發生。然後，當它發生時，會執行一些動作。
      2:
        image: notes/iceage_events_2.JPG
        text: 舉一些事件的例子，像是點擊滑鼠、按下方向鍵或在觸控螢幕上點了一下。
      3:
        image: notes/iceage_events_3.JPG
        text: 這裡，我們會在玩家點擊角色時，讓他說些什麼。我們會用到「當點擊時」積木，然後附加一個「說出」積木。當玩家點擊時，所有連接在下面積木將會被執行。
      4:
        image: notes/iceage_events_4.JPG
        text: 這裡也有「當方向鍵被按下時」的積木。如果在這些積木下方連結「移動」積木，你就可以開始讓你的角色向上、下、左、右方移動。循序漸進的，你的遊戲會有愈來愈多的互動性。
    iceage_repeat:
      1:
        image: notes/iceage_repeat_1.JPG
        text: 你能想像每天不斷的不斷的做重複的事情嗎？希望你永遠不需要，因為電腦真的非常擅長重複做一件事情。
      2:
        image: notes/iceage_repeat_2.JPG
        text: 這是重複無限次積木，在積木裡的任何東西都會在遊戲中永遠重複。如果我們想讓一個角色重複地做一些事 - 在沒有玩家操作的情況下。我們可以放置那些程式到重複無限次積木裡。
      3:
        image: notes/iceage_repeat_3.JPG
        text: 在下一關中，我們的目標是幫助角色能連續的完成工作。從中學習如何使用重複指令來節省大量的時間 - 當你在創建自己的遊戲時。
    mc_2016_intro:
      1:
        image: notes/mc_2016_intro_1.jpg
        text: 嗨，我是 Jens，是 Minecraft 的首席創意設計師。接下來的一小時，你將創造自己的 Minecraft 遊戲。這看來像 Minecraft，但世界已停止運行。綿羊呆住了，雞不下蛋，而殭屍只是站著不動。你可隨意加入程式代碼，讓
          Minecraft 世界運作。
      2:
        image: notes/mc_2016_intro_2.jpg
        text: 我是 Melissa，是個用戶分析師，就在 Minecraft 。（所以你想要它們做那些事情重複不停？對。）我非常好奇人們面對科技的思考並互動的方式，因此這工作正可讓我將計算機工程與心理學並用：研究人們的思考與行為。
      3:
        image: notes/mc_2016_intro_3.jpg
        text: 你會看到，畫面分割為三個主要部分。1) 左側是 Minecraft 遊戲。現在，世界是靜止的，我們將用代碼來修正它。
      4:
        image: notes/mc_2016_intro_4.jpg
        text: 2) 中間部分是工具箱。每個積木都是個指令，這些指令是雞、綿羊和 Minecraft 其他生物所能瞭解的。
      5:
        image: notes/mc_2016_intro_5.jpg
        text: 3) 右側的空間稱為工作區，是我們建置程式的地方。
      6:
        image: notes/mc_2016_intro_6.jpg
        text: 以防你忘了要做什麼，指示會顯示在每個關卡的頂端。
      7:
        image: notes/mc_2016_intro_7.jpg
        text: 一開始，我們建個程式來控制雞。當我點擊「運行」，雞就會往前一步。要繼續走的話，我會將另一個「移動-向前」積木，拖曳到第一個「移動-向前」積木下，在出現高亮顯示後。這時我再放開它，兩個積木就會貼合在一起。如果我再點一次「運行」，雞就會走兩步。
      8:
        image: notes/mc_2016_intro_8.jpg
        text: 若你想刪除積木，只要把它從堆疊移出，並拖曳回工具箱。
      9:
        image: notes/mc_2016_intro_9.jpg
        text: 點擊「運行」之後，你可以隨時點擊 「重置」 按鈕，重頭開始。現在，該你製作自己的 Minecraft。玩得愉快！
    mc_2016_loops:
      1:
        image: notes/mc_2016_loops_1.jpg
        text: 嗨，我是 Lisa。我是 Minecraft 的軟體開發師，負責一些動物和敵人在遊戲中。其中一個是豹貓，我負責的部分是當你拿著魚，豹貓會偷偷靠近。若你餵牠魚，可馴化牠，這隻豹貓就是你的貓了。
      2:
        image: notes/mc_2016_loops_2.jpg
        text: 身為人類，我們會非常厭煩，如果我們老是做同樣的事，一而再再而三的做…不過很酷的是，電腦對同一件事能連續做百萬，甚至數十億遍，卻一點也不厭倦。這種重複工作稱為迴圈
          (loop)，每個在 Minecraft 的生物都用到了迴圈。
      3:
        image: notes/mc_2016_loops_3.jpg
        text: 之前，我們已控制讓雞在畫面移動，但之後她又停止了。在 Minecraft 裡，雞可是會不停地走來走去的。我們使用「重複無限次」迴圈，讓我們的雞也能不停地在四處走來走去。迴圈可以幫我們省下大把時間，讓你的程式不這麼雜亂，利用它打造自己的
          Minecraft。
    mc_2016_events:
      1:
        image: notes/mc_2016_events_1.jpg
        text: 利用它打造自己的 Minecraft。按鍵盤的方向鍵可以移動到上、下、左、右方。現在你可在關卡內任意移動。若要「使用」生物，只要走過去，轉向它，再按下空格鍵。
      2:
        image: notes/mc_2016_events_2.jpg
        text: 若你使用的是觸控螢幕，用手指滑動上、下、左、右方即可移動。輕點遊戲畫面，就可以使用在你前方的物品。
      3:
        image: notes/mc_2016_events_3.jpg
        text: 不過會發生什麼事呢？當你「使用」它的時候…在 Minecraft，幫綿羊修剪時會掉落羊毛，當你點擊乳牛時，牠們會跑開。苦力怕則會爆炸，在你接近牠們時。之所以能有這些反應，得感謝事件（events）這玩意。事件告訴你的程式要監聽，或等候某件事發生。當它發生時，就執行一個動作。
      4:
        image: notes/mc_2016_events_4.jpg
        text: 目前，你已經使用了一個事件。你放進「當生成時」 裡的代碼會在你的生物被創造出來或遊戲開始時執行。後面的幾個關卡，你會有新的事件指令可用，像是「當碰觸時」
          ，執行的時機是在你碰到生物時；或「當使用時」， 是在你使用生物時執行。或者，如果你想讓殭屍消失在日出前，就把該指令放進「當白天時」裡。
    mc_2016_spawn:
      1:
        image: notes/mc_2016_spawn_1.jpg
        text: 在遊戲中，生成 (Spawn) 的意思是創造同樣的東西（像生蛋一樣）。在這個關卡，我們要讓殭屍生成，在太陽下山的時候。要完成這個，我們會用到「當夜晚時」積木。
      2:
        image: notes/mc_2016_spawn_2.jpg
        text: 因為我們想讓殭屍在夜晚出現，我們要添加「生成殭屍」積木，並放到「當夜晚時」積木之下。一旦牠們增生，每個殭屍將會執行程式代碼…那些你放進「當生成時」的事件指令。隨心所欲的生出殭屍吧！
    mc_2016_congrats:
      1:
        image: notes/mc_2016_congrats_1.jpg
        text: 恭喜！你已經學會用電腦科學指令讓 Minecraft 世界重新活過來。你是個開發師囉，現在。你已解鎖所有指令和全部生物。你可以選擇想要發生的事。
      2:
        image: notes/mc_2016_congrats_2.jpg
        text: 當你製作完遊戲時，選擇分享可取得連結。分享給好友，或玩你的遊戲，在你的手機上。玩得開心！我很期待玩你所製作的 Minecraft 。
    applab_intro_welcome:
      1:
        image: notes/applab_intro_welcome_1.png
        text: My name is Mei'lani. I'm an intern at code.org and I'm also a computer
          science student. I like computer science because it's really creative. I
          get to be the problem solver. I get to make everything function how I want
          it to. But I also get to be the designer. I get to be the artist and choose
          everything on the creative side of it.
      2:
        image: notes/applab_intro_welcome_2.png
        text: Making your own apps is easy with App Lab! Whether you're new to coding
          or have some experience. App Lab is a great tool for building new apps and
          sharing them with your friends.
      3:
        image: notes/applab_intro_welcome_3.png
        text: This is a App Lab. On the left side is your app. On the right side is
          the code that will make it run. You build your program by dragging in blocks
          from the toolbox. To start you'll just have one block called 'setProperty'.
      4:
        image: notes/applab_intro_welcome_4.png
        text: The set property block changes the look of the elements on your screen.
          Like the buttons, labels, or even the screen itself. First you need to decide
          which element you want to change. If you hover over an element in your app
          you can see the name or ID here. Then go select that ID from the first drop
          down.
      5:
        image: notes/applab_intro_welcome_5.png
        text: Elements have lots of properties you can change like their text color,
          background color or font size. You can see the full list and choose which
          property you want to change in the second drop down.
      6:
        image: notes/applab_intro_welcome_6.png
        text: The last drop down is where you'll write the value you want to use value
          you want to use. The block will make a suggestion for you. But you can always
          type in different colors or numbers yourself.
      7:
        image: notes/applab_intro_welcome_7.png
        text: Once you're done, the block reads a bit like a sentence:'Set button1's
          background color to green.' Hit run to see the changes you're building in
          code. If you reset you can drag in more blocks to change other things about
          your app. Like the text!
      8:
        image: notes/applab_intro_welcome_8.png
        text: For this tutorial we'll be working in block mode but App Lab also supports
          working in text.
      9:
        image: notes/applab_intro_welcome_9.png
        text: Either way you'll be programming in JavaScript, the language of the
          web. Each level has a goal, instructions and an image of what you're aiming
          to create.
      10:
        image: notes/applab_intro_welcome_10.png
        text: If you're ever stuck, click on this picture and it will show you exactly
          how to complete the level. But see if you can do it on your own first.
      11:
        image: notes/applab_intro_welcome_11.png
        text: Once you've completed the goal for this level click Finish to move on.
          That's all there is to it! Hit the orange "continue" button to go to the
          next level and start your adventure with an App Lab!
    applab_intro_events:
      1:
        image: notes/applab_intro_events_1.png
        text: Apps are really cool because it's kind of like starting your own business
          I mean, you get to design everything from the ground up, you get to manage
          everything, and you're the owner of this piece of work that you just created
          with code.
      2:
        image: notes/applab_intro_events_2.png
        text: Now that you can change the look of your app let's make it interactive
          by responding to events! Events are user actions like clicking a button,
          scrolling through a menu, or hovering over a picture. Interactive apps need
          ways to respond to events, like playing a sound when I click this button.
          To do this in App Lab you need to use a new block called 'onEvent'.
      3:
        image: notes/applab_intro_events_3.png
        text: This program sets the screen to blue. I want the screen to turn green
          when I click this button. First I'll need to drag in an onEvent block. By
          hovering I know the button's ID is "bigButton" so I'll select that in the
          first drop-down.
      4:
        image: notes/applab_intro_events_4.png
        text: Next I'll choose the type of event. There's lots of options you can
          pick from but right now I'll leave it as a regular old click.
      5:
        image: notes/applab_intro_events_5.png
        text: 'Finally I''ll add code inside the on event that will change the background
          color of the screen. You can read this block like a sentence: "On the event
          that the button is clicked run all this code."'
      6:
        image: notes/applab_intro_events_6.png
        text: Let's test it. Blocks outside an onEvent still run right away so the
          screen starts blue.
      7:
        image: notes/applab_intro_events_7.png
        text: And when I click the big button the code inside my onEvent runs and
          my screen turns green.
      8:
        image: notes/applab_intro_events_8.png
        text: If you want to change more things after the event, like the text on
          the screen just add more code to the onEvent
      9:
        image: notes/applab_intro_events_9.png
        text: To make your program respond to more events add more onEvent blocks.
          Just make sure not to put them inside of each other. Now it's time to try
          it out for yourself. Have fun!
    applab_intro_sounds:
      1:
        image: notes/applab_intro_sounds_1.png
        text: Next you'll learn about adding images and sounds to your app. Let's
          start by checking out the sound options.
      2:
        image: notes/applab_intro_sounds_2.png
        text: In the tool box you'll find a new block called "playSound". Drag it
          into the workspace. You can pick a sound to play by clicking the drop-down
          then clicking "Choose".
      3:
        image: notes/applab_intro_sounds_3.png
        text: From here you can either upload a sound file from your computer, or
          search for a sound from the sound library. The sound library has lots of
          different categories like instruments, background music or animals.
      4:
        image: notes/applab_intro_sounds_4.png
        text: Once you've got the sound you want, click "Choose". When this block
          runs, it will play the sound you chose.
      5:
        image: notes/applab_intro_sounds_5.png
        text: To add images to your elements you can just use the setProperty block.
          Select the image property in the second drop-down
      6:
        image: notes/applab_intro_sounds_6.png
        text: Then select "Choose" from the third drop down.
      7:
        image: notes/applab_intro_sounds_7.png
        text: From here you can upload an image from your computer or you can look
          through a huge library of icons in the icon library.
      8:
        image: notes/applab_intro_sounds_8.png
        text: Back in code mode you can use the "setProperty" block to change the
          icon color of your icon. Once you've picked what image your icon to use
          click "Run" to see how it looks.
      9:
        image: notes/applab_intro_sounds_9.png
        text: That's all there is to it! Now you can start adding images and sounds
          to make your apps even more fun and dynamic.
    applab_intro_designmode:
      1:
        image: notes/applab_intro_designmode_1.png
        text: To build your own apps you're going to need to start designing screens
          and elements from scratch. App Lab makes this easy to do with Design Mode.
      2:
        image: notes/applab_intro_designmode_2.png
        text: Use the switch on top of your app to go into Design Mode.
      3:
        image: notes/applab_intro_designmode_3.png
        text: You can add new elements by dragging them onto the screen. You can move
          them around to different locations and change their size by dragging the
          bottom right corner.
      4:
        image: notes/applab_intro_designmode_4.png
        text: To change an element's properties use the controls on the right. For
          example, it's really easy to change this button's text, color, and font
          size.
      5:
        image: notes/applab_intro_designmode_5.png
        text: When you add a new element to your screen it'll get a generic ID like
          button1. It's a good idea to change this button's ID to something more meaningful
          like "rightButton". So that you'll know which one it is when you go to the
          program.
      6:
        image: notes/applab_intro_designmode_6.png
        text: If you add an element to your app by mistake, just drag it out or hit
          the delete.
      7:
        image: notes/applab_intro_designmode_7.png
        text: You can add entirely new screens to your app by dragging in a screen
          element
      8:
        image: notes/applab_intro_designmode_8.png
        text: From the drop-down at the top you can quickly switch back and forth
          between the screens you create.
      9:
        image: notes/applab_intro_designmode_9.png
        text: Inside your app, you'll need a way to switch between all of these screens,
          so the setScreen block has been added to the toolbox. Use "setScreen" inside
          the "onEvent" block to change screens at the click of a button.
      10:
        image: notes/applab_intro_designmode_10.png
        text: In the next few levels you'll be working on a single project. First
          you'll add a button then you'll add a new screen and finally you'll write
          code so that the button switches to the new screen.
    applab_intro_share:
      1:
        image: notes/applab_intro_share_1.png
        text: Now that you've learned some of the basics of App Lab like adding buttons,
          sounds, images, text and new screens you can make all sorts of apps.
      2:
        image: notes/applab_intro_share_2.png
        text: In the next level you'll find the app you just finished building. With
          a little creativity, you can turn this into a personality quiz for your
          friends, a greeting card that you can share with your family or a choose-your-own-adventure
          game. All of these apps are just a combination of the skills you've already
          learned, and I bet you can come up with even more.
      3:
        image: notes/applab_intro_share_3.png
        text: Once you're done with your app you can easily send it to your phone
          to see how it looks. Just click "Share" and enter your phone number here.
      4:
        image: notes/applab_intro_share_4.png
        text: You'll receive a text message that'll let you open up your app instantly.
      5:
        image: notes/applab_intro_share_5.png
        text: You can also share a link to your app over social media or post it to
          the code.org public gallery for other people to play and share.
      6:
        image: notes/applab_intro_share_6.png
        text: You've just scratched the surface of what App Lab can do. Full App Lab
          features more advanced user interactions, new screen elements and even a
          built-in database so you can quickly build full featured apps. At "code.org/applab"
          you'll find the full tool and lots of ideas if you want to keep going.
      7:
        image: notes/applab_intro_share_7.png
        text: Thanks for coming along the ride. Now go build and share your first
          app, and keep on building apps with App Lab!
    mc_2017_agent_intro:
      1:
        image: notes/mc_2017_agent_intro_1.png
        text: 'Stacy: Stampy, Lizzy, Preston - thank you for coming with me. What
          I want to show you is just over this mesa plateau. I think you''re going
          to love it!'
      2:
        image: notes/mc_2017_agent_intro_2.png
        text: Wait a minute - there's a hole in the track! (screaming)
      3:
        image: notes/mc_2017_agent_intro_3.png
        text: 'Is everyone okay? Stampy: Ah, I see the problem. Look! There was a
          hole in the track. Stacy: Really, Stampy? Lizzy: Maybe we should gather
          blocks to fix it. Preston: Let''s make it a race. First one back to the
          top wins. Stacy: Ok, on your mark, get set, GO! Ok, I''m just gonna gather
          some of this terracotta. Wait. Guys, I can''t mine! Preston: Same. Lizzy:
          I can''t either. Stacy: Ok, that is really strange. Stampy, can you mine?
          Stampy: I can''t mine! Stacy: Ok, everyone stay calm. Stampy: Is the game
          broken? Stacy: If it is, how do we fix it? Lizzy: I don''t know. Stampy:
          Does anyone know how to write Minecraft code?'
      4:
        image: notes/mc_2017_agent_intro_4.png
        text: "(poof) Preston: What is that? Stampy: I've never seen one of these
          before. Lizzy: It's so adorable! Stacy: Is it...is it tameable? Preston:
          Okay, what is going on? Someone needs to go back to the real world and fix
          this.  All: Not it! Stacy: Not i- (Sigh.) Ok, I'll go."
      5:
        image: notes/mc_2017_agent_intro_5.png
        text: Oh, okay, hey, so I'm in the real world now. I'm going to go try to
          find the Minecraft offices.
      6:
        image: notes/mc_2017_agent_intro_6.png
        text: But, I'm going to need your help. Start doing the tutorial, start learning
          how to code, and I'll catch up with you guys after a few levels, okay? Wish
          me luck! I think it's this way. Ow! Cactus! I'm okay!
      7:
        image: notes/mc_2017_agent_intro_7.png
        text: To complete the Hour of Code challenge, you'll need to write code to
          program the agent. You'll work together with The Agent to clear any obstacles
          in your path, so you can pick up the items you'll need for your journey.
          Only the Agent can place and break blocks, and only you can collect items.
          Your screen is split into three main parts. On the left is Minecraft.
      8:
        image: notes/mc_2017_agent_intro_8.png
        text: The middle area is the toolbox with commands that the Agent can understand.
      9:
        image: notes/mc_2017_agent_intro_9.png
        text: And on the right, is the workspace. That's where you stack the commands
          to build your program to control the Agent.
      10:
        image: notes/mc_2017_agent_intro_10.png
        text: The Agent can walk, turn, and activate pressure plates. It can also
          destroy blocks and place blocks. When it places the block like these minecart
          rails, it places it underneath itself.
      11:
        image: notes/mc_2017_agent_intro_11.png
        text: 以防你忘了要做什麼，指示會顯示在每個關卡的頂端。
      12:
        image: notes/mc_2017_agent_intro_12.png
        text: If you want to try again, you can hit the blue reset button to reset
          everything to where it started. And if you need to delete a block of code,
          drag it from your workspace to the toolbox. Remember to hit run to get the
          Agent moving. Okay, go ahead and try out the first few levels. Good luck!
    mc_2017_repeat:
      1:
        image: notes/mc_2017_repeat_1.png
        text: 'Stampy: I wonder what Stacy is up to?'
      2:
        image: notes/mc_2017_repeat_2.png
        text: 'Stacy: Woah, I think I''m in the right place. This is amazing!'
      3:
        image: notes/mc_2017_repeat_3.png
        text: I feel like I'm back in Minecraft! Hello. How are you? Hello?
      4:
        image: notes/mc_2017_repeat_4.png
        text: 'Oh, there''s a creeper. You don''t do anything, do you? Katie: Stacy?
          Stacy:Hi, Katie? Katie: Yes, welcome to Minecraft!'
      5:
        image: notes/mc_2017_repeat_5.png
        text: 'Stacy: This is amazing. So you work here every day as a developer,
          right? Katie: Yeah, it''s pretty awesome. I''m a developer on the Minecraft
          marketplace team. Stacy: How many coding languages do you know? Katie: In
          my career I''ve probably worked with over a dozen. Stacy: A dozen? Katie:
          Yeah. Stacy: So now, you wouldn''t happen to know anything about this little
          golem guy that calls himself the Agent? Katie: We use the Agent to do things
          that Steve or Alex can''t, like go across lava. Stacy: Well, I want to learn
          how to code, and they want to learn how to code, so what is one of the first
          things that you need to know when you''re learning?'
      6:
        image: notes/mc_2017_repeat_6.png
        text: 'Katie: Well, you need to learn how to use loops. Loops are things that
          developers write to give commands to a computer that can be run over and
          over again. Stacy: Got it, so I think there''s actually some of that coming
          up in the levels ahead, so go ahead and give loops a try.'
      7:
        image: notes/mc_2017_repeat_7.png
        text: In the next level, you can use a loop to move the Agent along the path.
          Drag the repeat block into the workspace and place the move forward block
          inside the repeat block. This tells the computer to do the same thing many
          times in a row without having to drag a whole bunch of blocks into the workspace.
          You can choose how many times to repeat by putting a number in the repeat
          block.
      8:
        image: notes/mc_2017_repeat_8.png
        text: You can put turns and multiple commands in the repeat block too, but
          for now try using a repeat to move the Agent forward a few steps. Remember,
          if you get stuck on a puzzle you can always hit the blue reset button and
          try again.
      9:
        image: notes/mc_2017_repeat_9.png
        text: 'If you are thinking about having a cool job like Katie''s, go ahead
          and click the show code button when you finish every level. That''s going
          to actually show you the Javascript code that someone like Katie uses when
          she''s actually programming Minecraft. Katie: Yeah, good luck everyone!'
    mc_2017_functions:
      1:
        image: notes/mc_2017_functions_1.png
        text: 'Preston: I''m not trying to brag, but I''m pretty good at parkour.
          Lizzy: Let''s sleep so it''s day when Stacy comes back.'
      2:
        image: notes/mc_2017_functions_2.png
        text: 'Stacy: Ok guys, I am back from the Minecraft offices, and I think I
          know how to solve the problem I''m having in my game. I think I can use
          a function. Let me just open this.'
      3:
        image: notes/mc_2017_functions_3.png
        text: So a function is a specific set of instructions to accomplish a certain
          task, kind of like a recipe. In the next few levels, you'll have access
          to functions that you can use to solve the puzzles.
      4:
        image: notes/mc_2017_functions_4.png
        text: Look at the code in the function when it's in the workspace to see what
          it does.
      5:
        image: notes/mc_2017_functions_5.png
        text: Then, find the block with that name in the toolbox and drag it from
          the toolbox to the when run block.
      6:
        image: notes/mc_2017_functions_6.png
        text: Remember, you can use the same function every time you need to run the
          same set of instructions to do something, like build a bridge. Good luck,
          I know you can do it!
    mc_2017_congratulations:
      1:
        image: notes/mc_2017_congratulations_1.png
        text: 'Preston: Congratulations!'
      2:
        image: notes/mc_2017_congratulations_2.png
        text: 'Lizzy: Congratulations!'
      3:
        image: notes/mc_2017_congratulations_3.png
        text: 'Stampy: Congratulations, you did it!'
      4:
        image: notes/mc_2017_congratulations_4.png
        text: 'Stacy: Congratulations guys, you totally rocked that! And now that
          you''ve completed the Hour of Code, you can start coding in Minecraft. You''ve
          learned about loops, functions, and what a software Agent does.'
      5:
        image: notes/mc_2017_congratulations_5.png
        text: Now, it's time for the free play level, where you are the developer.
          Use any remaining time to write your own functions to explore, mine, and
          build.
      6:
        image: notes/mc_2017_congratulations_6.png
        text: 'You can take the code that you write in this level into your Minecraft
          world on Minecraft: Education Edition. Just click ''Finish'' and follow
          the instructions for getting the link to use in your world. to continue
          coding with the Agent. Have fun, and good job!'
      7:
        image: notes/mc_2017_congratulations_7.png
        text: 'Stacy: And I''m back! Okay, you guys, this is the Agent! Let me show
          you what it can do. Look, it''s doing it! I told it to build a staircase
          out of these terra cotta blocks, now we can just use this to get out of
          here. And you guys, it''s not just staircases. I can tell the Agent to do
          anything I want, and it will do it for me.'
      8:
        image: notes/mc_2017_congratulations_8.png
        text: 'Stampy: How did you do that? Stacy: It was easy, actually. I just used
          code!'
    csd_concept_how_computers_work:
      1:
        image: notes/csd_concept_how_computers_work_1.png
        text: 'Everywhere you look, computers are changing the world. Whether they''re
          on our desktops, in our homes, our pockets, or just about anywhere else.
          But while most of us use this revolutionary technology daily, we don''t
          often ask: "How do computers work?" In this series, you''re going to learn
          how computers really work, starting with what makes a computer a computer.
          Then, you''ll look at how information is represented inside the computer
          using tiny electrical signals going on and off at mind-boggling speeds.'
      2:
        image: notes/csd_concept_how_computers_work_2.png
        text: After that, you'll learn how computers use circuits to do everything
          from simple math to simulating entire virtual worlds. Next, you'll zoom
          out and look at the different parts of a computer that actually input, output,
          and store all that information. Finally, you'll take a look at what code
          actually is and how software controls hardware. So whether you're just curious
          about the devices you use every day or you want to design the innovations
          of the future, the first step is learning how computers work.
    csd_concept_computer:
      1:
        image: notes/csd_concept_computer_1.png
        text: My name is May-Li Khoe and I'm a designer and an inventor. So some of
          the things I've designed have been at Apple, and now I design products for
          kids to use so that they can have an easier time in school. My other jobs
          include DJ-ing and dancing.
      2:
        image: notes/csd_concept_computer_2.png
        text: Computers are everywhere! They're in people's pockets, they're in people's
          cars, people have them on their wrists. They might be in your backpack right
          now. But what makes a computer a computer? What does make a computer a computer
          anyway? And how does it even work?
      3:
        image: notes/csd_concept_computer_3.png
        text: Hi I'm Nat! I was one of the original designers of the Xbox. I've been
          working with computers since I was maybe seven years old and now I work
          on virtual reality. As humans, we've always built tools to help us solve
          problems. Tools like a wheelbarrow, a hammer, or a printing press, or a
          tractor-trailer.
      4:
        image: notes/csd_concept_computer_4.png
        text: All of these inventions helped us with manual work. Over time, people
          began to wonder if a machine could be designed and built to help us with
          the thinking work we do, like solving equations or tracking the stars in
          the sky. Rather than moving or manipulating physical things like dirt and
          stone, these machines would need to be designed to manipulate information.
          As the pioneers of computer science explored how to design a thinking machine,
          they realized that it had to perform four different tasks.
      5:
        image: notes/csd_concept_computer_5.png
        text: It would need to take input, store information process it and then output
          the results. Now this might sound simple, but these four things are common
          to all computers. That's what makes a computer a computer.
      6:
        image: notes/csd_concept_computer_6.png
        text: Computers started out as basic calculators, which was already really
          awesome at the time, and they were only manipulating numbers back then.
          But now we can use them to talk to each other, we can use them to play games,
          control robots, and do any crazy thing that you could probably imagine.
          Modern computers look nothing like those clunky old machines but they still
          do these same four things.
      7:
        image: notes/csd_concept_computer_7.png
        text: First, we're going to talk about input. You can tell computers what
          to do with the keyboard, you can tell them what to do with the mouse, the
          microphone, the camera. All these different inputs give a computer information,
          which is then stored in memory.
      8:
        image: notes/csd_concept_computer_8.png
        text: A computer's processor takes information from memory. It manipulates
          it or changes it using an algorithm, which is just a series of commands.
          And then it sends the processed information back to be stored in memory
          again. This continues until the processed information is ready to be output.
      9:
        image: notes/csd_concept_computer_9.png
        text: How a computer outputs information depends on what the computer is designed
          to do. A computer display can show text, photos, videos, or interactive
          games -- even virtual reality! The output of a computer may even include
          signals to control a robot.
      10:
        image: notes/csd_concept_computer_10.png
        text: And who knows what the computers of tomorrow will be like? My hope is
          that you get to help decide what you want the computers of tomorrow to look
          like. But across all computers, regardless of the different types of technology
          they use, they're always doing those same four things. They take in information,
          they store it as data, they process it, and then they output the results.
    csd_concept_binary_data:
      1:
        image: notes/csd_concept_binary_data_1.png
        text: Hi! My name is Limor Fried, and I'm an engineer here at Adafruit Industries.
          And this is where I do engineering and design, and I design circuits for
          fashion and music and technology.
      2:
        image: notes/csd_concept_binary_data_2.png
        text: My name is Federico Gomez Suarez, and I'm a software developer with
          Microsoft Hack for Good. And I look into using technology to help us solve
          some of the big social problems of our times.
      3:
        image: notes/csd_concept_binary_data_3.png
        text: You may have heard that computers work on ones and zeros. But almost
          nobody today actually deals directly with these ones and zeros. But ones
          and zeroes do play a big role in how computers work on the inside.
      4:
        image: notes/csd_concept_binary_data_4.png
        text: Inside a computer are electric wires and circuits that carry all the
          information in a computer. How do you store or represent information using
          electricity?
      5:
        image: notes/csd_concept_binary_data_5.png
        text: Well, if you have a single wire with electricity flowing through it,
          the signal could either be on or off. That's not a lot of choices, but it's
          a really important start. With one wire, we can represent a yes or no, true
          or false, a one or zero, or anything else with only two options. This on/off
          state of a single wire is called a bit, and it's the smallest piece of information
          a computer can store.
      6:
        image: notes/csd_concept_binary_data_6.png
        text: 'If you use more wires you get more bits: more ones and zeros. With
          more bits you can represent more complex information. But to understand
          that, we need to learn about something called the binary number system.'
      7:
        image: notes/csd_concept_binary_data_7.png
        text: 'In the decimal number system, we have ten digits from zero to nine,
          and that''s how we''ve all learned to count. In the binary number system,
          we only have two digits: zero and one. With these two digits, we can count
          up to any number.'
      8:
        image: notes/csd_concept_binary_data_8.png
        text: Here's how this works. In a decimal number system we're all used to,
          each position in a number has a different value. There's a 1 position, the
          10 position, the 100 position, and so on. For example, a 9 in the 100 position
          is a 900. In binary, each position also carries a value. But instead of
          multiplying by 10 each time, we multiply by 2. So there's the 1 position,
          the 2 position, the 4 position, the 8 position, and so on. For example,
          the number 9 in binary is 1001. To calculate the value, we add 1 times 8,
          plus 0 times 4, plus 0 times 2, plus 1 times 1. Almost nobody does this
          math because computers do it for us. What's important is that any number
          can be represented with only ones and zeros, or by a bunch of wires that
          are on or off. The more wires you use, the larger the numbers you can store.
          With 8 wires, you can store numbers between 0 and 255. That's 8 ones. With
          just 32 wires, you can store all the way from 0 to over 4 billion. Using
          the binary number system, you can represent any number you like.
      9:
        image: notes/csd_concept_binary_data_9.png
        text: But what about other types of information? Like text, images, or sound?
          It turns out that all these things can also be represented with numbers.
          Think of all the letters in the alphabet. You could assign a number to each
          letter. A could be 1, B could be 2, and so on. You can then represent any
          word or paragraph as a sequence of numbers. And as we saw, these numbers
          can be stored as on or off electrical signals. Every word you see on every
          webpage or your phone is represented using a system like this.
      10:
        image: notes/csd_concept_binary_data_10.png
        text: Now, let's consider photos, videos, and all the graphics you see on
          a screen.
      11:
        image: notes/csd_concept_binary_data_11.png
        text: All of these images are made out of teeny dots called pixels, and each
          pixel has a color. Each of the colors can be represented with numbers. When
          you consider the typical image has millions of these pixels, and the typical
          video shows 30 images per second now we're talking about a lot of data here.
      12:
        image: notes/csd_concept_binary_data_12.png
        text: Every sound is basically a series of vibrations in the air. Vibrations
          can be represented graphically as a waveform. Any point on this waveform
          can be represented by a number. And this way, any sound can be broken down
          into a series of numbers. If you want higher quality sound, you will pick
          32-bit audio or an 8-bit audio. More bits means a higher range of numbers.
      13:
        image: notes/csd_concept_binary_data_13.png
        text: When you use a computer to write code or make your own app, you're not
          dealing directly with these ones and zeros. But you will be dealing with
          images or sound or video. So if you want to understand how computers work
          on the inside, it all comes down these simple ones and zeros and the electrical
          signals in the circuits behind them.
    csd_concept_circuits_logic:
      1:
        image: notes/csd_concept_circuits_logic_1.png
        text: One of the coolest things I've discovered about circuits is circuitry
          can be an art form like if I have a creative idea, I can get that creative
          idea out using circuits. So if you have ideas, you can use technology to
          make those ideas come to life.
      2:
        image: notes/csd_concept_circuits_logic_2.png
        text: Every input or output of a computer is effectively a type of information,
          which can be represented by on or off electrical signals or ones and zeros.
      3:
        image: notes/csd_concept_circuits_logic_3.png
        text: In order to process the information that comes in as input, and to make
          the information that is output, a computer needs to modify and combine the
          input signals. To do this, a computer uses millions of teeny electronic
          components, which come together to form circuits.
      4:
        image: notes/csd_concept_circuits_logic_4.png
        text: Let's take a closer look at how circuits can modify and process information
          that's represented in ones and zeros. This is an incredibly simple circuit.
          It takes an electrical signal, on or off, and it flips it. So if the signal
          you give it is a 1, the circuit gives you a 0, and if you give the circuit
          a 0, it gives you a 1. The signal that goes in is not the same as the signal
          that comes out, and so we call this circuit NOT.
      5:
        image: notes/csd_concept_circuits_logic_5.png
        text: More complicated circuits can take multiple signals and combine them,
          and give you a different result. In this example, a circuit will take two
          electrical signals, now each one might be a 1 or a 0. If either of the signals
          coming in is a 0, then the result is also a 0. This circuit will only give
          you a 1, if the first signal and the second signal are both a 1, and so
          we call the circuit AND.
      6:
        image: notes/csd_concept_circuits_logic_6.png
        text: There are many small circuits like this that perform simple logical
          calculations. By connecting these circuits together, we can make more complex
          circuits that perform more complex calculations.
      7:
        image: notes/csd_concept_circuits_logic_7.png
        text: For example, you can make a circuit that adds 2 bits together called
          an adder. This circuit takes in 2 individual bits, each one a 1 or a 0,
          and adds them together to calculate the sum. The sum can be 0 plus 0 equals
          0, 0 plus 1 equals 1, or 1 plus 1 equals 2. You need two wires coming out
          because it can take up to two binary digits to represent the sum. Once you
          have a single adder for adding two bits of information, you can put together
          multiples of these adder circuits side-by-side to add together much larger
          numbers.
      8:
        image: notes/csd_concept_circuits_logic_8.png
        text: For example, here's how an 8-bit adder adds the numbers 25 and 50. Each
          number is represented using 8 bits, resulting in 16 different electrical
          signals that go into the circuit. The circuit for an 8-bit adder has lots
          of little adders inside of it, which together, calculate the sum.
      9:
        image: notes/csd_concept_circuits_logic_9.png
        text: Different electrical circuits can perform other simple calculations
          like subtraction or multiplication. In fact, all the information processing
          your computer does is just lots and lots of small simple operations put
          together. Each individual operation done by a computer is so, so simple
          it could be done by a human, but these circuits inside computers are way
          way faster.
      10:
        image: notes/csd_concept_circuits_logic_10.png
        text: Back in the day, these circuits were big and clunky, and an 8-bit adder
          could be as big as a fridge, and it would take minutes for them to perform
          a simple calculation. Today, computer circuits are microscopic in size,
          and way way faster. Why are smaller computers also faster? Well, because
          the smaller the circuit is, the less distance the electrical signal has
          to go. Electricity moves at just about the speed of light, which is why
          modern circuits can perform billions of calculations per second.
      11:
        image: notes/csd_concept_circuits_logic_11.png
        text: So whether you're playing a game, recording a video, or exploring the
          cosmos, everything you could possibly do with technology requires lots of
          information to be processed extremely quickly. Underneath all this complexity
          is just lots of teeny little circuits that turn binary signals into websites,
          videos, music, and games. These circuits can even help us decode DNA to
          diagnose and cure disease. So what would you like to do with all these circuits?
    csd_concept_memory_cpu_input_output:
      1:
        image: notes/csd_concept_memory_cpu_input_output_1.png
        text: Hi, my name is Madison Maxey. I have a company called Loomia, and we
          focus on making smart fabrics for smart clothing and smart soft good products.
          The sky's the limit when it comes to textiles.
      2:
        image: notes/csd_concept_memory_cpu_input_output_2.png
        text: My name is Danielle Applestone, and I'm CEO of Othermachine Company.
          We build a desktop milling machine. A milling machine takes a rotating cutting
          tool and moves it through material to create a 3D object.
      3:
        image: notes/csd_concept_memory_cpu_input_output_3.png
        text: Under the hood, all computers do the same four basic things. They input
          information, store and process the information, and then, output information.
          Each of these things is done by a different part of the computer.
      4:
        image: notes/csd_concept_memory_cpu_input_output_4.png
        text: There are input devices that take input from the outside world and convert
          it into binary information. There is memory to store this information. There's
          a central processing unit or CPU, where all the calculations are done. And,
          finally, there are output devices that take information and convert it into
          a physical output.
      5:
        image: notes/csd_concept_memory_cpu_input_output_5.png
        text: Let's talk about input first. Computers can take many different types
          of input, like the keyboard of a computer, the touchpad of a phone, a camera,
          a microphone, or a GPS. But even the sensors on a car, a thermostat, or
          a drone are also different input devices.
      6:
        image: notes/csd_concept_memory_cpu_input_output_6.png
        text: Now, let's look at a simple example of how input travels through a computer
          and becomes output. When you press a key on your keyboard - let's say the
          letter "B". The keyboard converts the letter to a number. That number is
          sent as binary, ones and zeros, into the computer.
      7:
        image: notes/csd_concept_memory_cpu_input_output_7.png
        text: Starting from this number, the CPU calculates how to display the letter
          "B" pixel by pixel. The CPU requests step-by-step instructions from memory,
          which tell it how to draw the letter "B". The CPU runs these instructions
          and stores the results as pixels in memory.
      8:
        image: notes/csd_concept_memory_cpu_input_output_8.png
        text: Finally, this pixel information is sent in binary to the screen. The
          screen is an output device, which converts the binary signals into the tiny
          lights and colors that make up what you see.
      9:
        image: notes/csd_concept_memory_cpu_input_output_9.png
        text: This all happens so quickly it feels instantaneous, but to display each
          letter a computer runs thousands of instructions, starting from the moment
          your finger presses the key point.
      10:
        image: notes/csd_concept_memory_cpu_input_output_10.png
        text: In that example, the output device was the screen, but there are many
          different types of output which take a binary signal from the computer and
          do something in the physical world. For example, a speaker will play sound,
          and a 3D printer will print an object. Output devices can also control physical
          motion like a robotic arm, the motor of a car, or the cutting tool of the
          milling machine that my company makes. New types of inputs and outputs let
          computers interact with the world in entirely new ways. This has been helped
          out by improvements to the speed and size of the memory and CPU.
      11:
        image: notes/csd_concept_memory_cpu_input_output_11.png
        text: The more complicated a task is and the more information that is input
          or output, the more processing power and memory a computer needs. Typing
          letters on a screen may be easy but to do complicated 3d graphics or record
          a high-definition movie, modern computers often have multiple CPUs to process
          all that information and many gigabytes of memory to store it.
      12:
        image: notes/csd_concept_memory_cpu_input_output_12.png
        text: 'No matter what it is you want to do with the computer, every single
          action is about: inputting information from the physical world, storing
          and processing that information, and getting some output back into the physical
          world.'
    csd_concept_hardware_software:
      1:
        image: notes/csd_concept_hardware_software_1.png
        text: Hi, my name is Erica Gomez and I'm an engineering manager at Amazon.com.
          One of the best things about working in tech, and at Amazon in particular,
          is that I get to bring my dog with me to work every day. My job is to help
          make sure software gets out the door and her job is to nap under my desk
          and snore very loudly.
      2:
        image: notes/csd_concept_hardware_software_2.png
        text: 'My name is Jerome Holman, and I''m a Program Manager on Team Xbox and
          I have a really fun job: Basically bringing the hardware and the software
          together to give you all the games that you love on your Xbox.'
      3:
        image: notes/csd_concept_hardware_software_3.png
        text: When you look inside a computing device you see a bunch of circuits,
          chips, wires, speakers, plugs, and all sorts of other stuff. This is the
          hardware.
      4:
        image: notes/csd_concept_hardware_software_4.png
        text: But what you don't see is the software. Software is all of the computer
          programs, or code, running on this machine. Software can be anything from
          apps and games to webpages and the data science software that me and my
          teams use at Amazon to understand how customers behave.
      5:
        image: notes/csd_concept_hardware_software_5.png
        text: But how do the hardware and the software interact with one another?
          Let's start at looking at a computer's central processing unit, or CPU.
      6:
        image: notes/csd_concept_hardware_software_6.png
        text: The CPU is the master chip that controls all the other parts of the
          computer. A CPU needs to do different things so inside it has smaller, simpler
          parts that handle specific tasks. It has circuits to do simple math and
          logic. It has other circuits to send and receive information to and from
          different parts of the computer.
      7:
        image: notes/csd_concept_hardware_software_7.png
        text: The real magic of the CPU is how it knows which circuits to use and
          when to use them. The CPU receives simple commands that tell it which circuit
          to use to do a specific job. For example, an "add" command tells the CPU
          to use its outer circuit to calculate a new number. And then the "store"
          command tells the CPU to use a different circuit to save that result into
          memory.
      8:
        image: notes/csd_concept_hardware_software_8.png
        text: Just like numbers, all of these simple commands can be represented in
          binary ones and zeros or on and off electrical signals. The binary commands
          are stored in memory and the CPU fetches and executes them in sequence one
          after the other. This sequence of commands is, in fact, a very simple computer
          program.
      9:
        image: notes/csd_concept_hardware_software_9.png
        text: Binary code is the most basic form of software and it controls all the
          hardware of a computer. These days, nobody writes software in binary. It
          would take forever!
      10:
        image: notes/csd_concept_hardware_software_10.png
        text: Today, the software we write looks more like this (Python), or this
          (Ruby), or even this (Blockly). Programming languages like these let you
          type in commands in something that looks a lot like English.
      11:
        image: notes/csd_concept_hardware_software_11.png
        text: To draw a rectangle on the screen, you just need a single command. This
          high-level command is converted into hundreds, or thousands, of simpler
          binary commands that the CPU understands. Software tells the CPU what to
          do, but when you're listening to music, and browsing the web, and chatting
          with a friend, your computer is running multiple pieces of software all
          at once.
      12:
        image: notes/csd_concept_hardware_software_12.png
        text: So, how do all of these programs get on the computer in the first place,
          and how can the CPU run them all at once? To find out we'll have to take
          a look at the operating system.
      13:
        image: notes/csd_concept_hardware_software_13.png
        text: The operating system of the computer is the master program that manages
          how software gets to use the hardware of the computer. For example, I helped
          create the Windows operating system that runs on most personal computers.
      14:
        image: notes/csd_concept_hardware_software_14.png
        text: The operating system is a program with special abilities that let it
          control the other software on the computer. It lets you install new programs
          by loading them into your computer's memory. It decides when a program is
          run by the central processing unit, and whether that program can access
          the computer's input and output devices. And when you think your computer
          is running many programs at once, in reality, it's the operating system
          that's quickly switching between programs sharing that CPU for fractions
          of a second.
      15:
        image: notes/csd_concept_hardware_software_15.png
        text: Inside every computer is an operating system managing software that
          controls the computer's hardware.
      16:
        image: notes/csd_concept_hardware_software_16.png
        text: The software is a series of commands made of simple binary code, and
          that binary code is just electrical signals flowing through billions of
          tiny circuits.
      17:
        image: notes/csd_concept_hardware_software_17.png
        text: Computers have the potential to do all kinds of amazing things. But
          the only thing that makes the computer smart, or useful, is you. When you
          learn to code you get to define the problem you want to solve, and write
          the software that turns those ideas into reality.
