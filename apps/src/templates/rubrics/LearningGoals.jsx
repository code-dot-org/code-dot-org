import React, {useEffect, useState, useRef} from 'react';
import PropTypes from 'prop-types';
import i18n from '@cdo/locale';
import classnames from 'classnames';
import style from './rubrics.module.scss';
import EditorAnnotator from '@cdo/apps/EditorAnnotator';
import {ai_rubric_cyan} from '@cdo/apps/util/color';
import {
  learningGoalShape,
  reportingDataShape,
  studentLevelInfoShape,
  submittedEvaluationShape,
  aiEvaluationShape,
} from './rubricShapes';
import FontAwesome from '@cdo/apps/templates/FontAwesome';
import {
  BodyThreeText,
  OverlineThreeText,
  Heading5,
  StrongText,
} from '@cdo/apps/componentLibrary/typography';
import {UNDERSTANDING_LEVEL_STRINGS} from './rubricHelpers';
import analyticsReporter from '@cdo/apps/lib/util/AnalyticsReporter';
import {EVENTS} from '@cdo/apps/lib/util/AnalyticsConstants';
import EvidenceLevels from './EvidenceLevels';
import SafeMarkdown from '@cdo/apps/templates/SafeMarkdown';
import AiAssessment from './AiAssessment';
import HttpClient from '@cdo/apps/util/HttpClient';
import ProgressRing from './ProgressRing';
import AiAssessmentFeedbackContext from './AiAssessmentFeedbackContext';
import infoIcon from './images/info-icon.svg';
import tipIcon from './images/AiBot_Icon.svg';

const INVALID_UNDERSTANDING = -1;

/**
 * Annotation tooltip styling.
 *
 * Needs to be here to capture the image URL and because EditorAnnotator can
 * better add the styling overrides directly to the element so they always
 * apply over other styling (including those also directly added to the
 * element by the editor implementation, aka Droplet or Ace).
 */
const tipStyle = {
  backgroundImage: `url(${tipIcon})`,
  backgroundColor: '#333',
  backgroundPosition: '2px center',
  backgroundSize: '24px',
  backgroundRepeat: 'no-repeat',
  borderColor: '#555',
  color: 'white',
  borderRadius: '6px',
  padding: '6px',
  paddingLeft: '30px',
};

/**
 * Clear prior line annotations
 */
export function clearAnnotations() {
  EditorAnnotator.clearAnnotations();
  EditorAnnotator.clearHighlightedLines();
}

/**
 * Adds annotations to the source code viewed in the current editor based
 * on the AI evidence of the learning goal referenced by the given index.
 *
 * Observations is a text block generated by the AI. This will parse out
 * sections that match a particular style:
 *
 *   Line x: Some description `some code`
 *   Line x-y: Some description `some code`
 *
 * More than one can appear within the same text chunk:
 *
 *   Line 3: Creates a sprite `var p = createSprite(100, 100);` Line 4: Sets
 *   velocity `p.velocityX = 0;`
 *
 * In this case, we expect to highlight lines 3 and 4 and to annotate each with
 * the provided description. Although, we might find that this code actually
 * exists on lines 5 and 6, since the AI is somewhat unreliable about line
 * number reporting. The `findCodeRegion` function is responsible for finding
 * the actual lines.
 *
 * When the AI gives us multiple lines, it will generally remove the whitespace.
 * This means that the newlines are not within the observation text block. We
 * have to match the code similarly. You might see this:
 *
 *   Line 5: Jump condition `if (keyDown('up')) { p.velocityY = -100; }`
 *
 * In this case, we might find this code on lines 8 through 10. So, we would
 * annotate line 8 and highlight lines 8 through 10.
 *
 * This will return a list of annotation blocks containing the line numbers
 * and the description.
 *
 * @param {string} evidence - A text block described above.
 * @returns {Array} The ordered list of annotations.
 */
export function annotateLines(evidence) {
  let ret = [];

  // Go through the AI evidence
  // For every reference the AI gave us, we will find it in the code.
  // The AI has trouble giving line numbers, so even though we parse
  // those out, we do not trust them and instead find the code it
  // references to highlight it.
  for (const match of evidence.matchAll(
    'Lines? (\\d+)(?:\\s*-\\s*(\\d+))?:(.+?)\\s*(?=Line|$)'
  )) {
    let lineNumber = parseInt(match[1]);
    let lastLineNumber = parseInt(match[2] || lineNumber);
    let found = false;
    let hasSnippet = false;
    const context = match[3].trim();

    const message = context
      .substring(0, context.indexOf('`') || context.length)
      .trim();

    // We look at all of the code references the AI gave us which are
    // surrounded by backticks.
    const references = context.substring(message.length);
    for (const submatch of references.matchAll(/`([^\`]+)`/g)) {
      let snippet = submatch[1].trim();

      // Skip empty code snippets... just in case the AI very strangely
      // gives an empty code response (e.g. 'Line 1: Description ` `')
      if (snippet === '') {
        continue;
      }

      // We have some kind of code reference
      hasSnippet = true;

      // Find where this snippet actually happens
      let position = EditorAnnotator.findCodeRegion(snippet, {
        stripComments: true,
      });

      // Annotate that first line and highlight all lines, if they were found
      if (position.firstLine && position.lastLine) {
        found = true;
        EditorAnnotator.annotateLine(
          position.firstLine,
          message,
          'INFO',
          ai_rubric_cyan,
          infoIcon,
          tipStyle
        );
        for (let i = position.firstLine; i <= position.lastLine; i++) {
          EditorAnnotator.highlightLine(i, ai_rubric_cyan);
        }
        ret.push({
          firstLine: position.firstLine,
          lastLine: position.lastLine,
          message: message,
        });
      }
    }

    // If we have some code but couldn't find it, use the AI provided line
    // numbers, which may be inaccurate.
    if (!found && hasSnippet) {
      EditorAnnotator.annotateLine(
        lineNumber,
        message,
        'INFO',
        ai_rubric_cyan,
        infoIcon,
        tipStyle
      );
      for (let i = lineNumber; i <= lastLineNumber; i++) {
        EditorAnnotator.highlightLine(i, ai_rubric_cyan);
      }
      ret.push({
        firstLine: lineNumber,
        lastLine: lastLineNumber,
        message: message,
      });
    }
  }

  return ret;
}

export default function LearningGoals({
  open,
  learningGoals,
  teacherHasEnabledAi,
  canProvideFeedback,
  reportingData,
  studentLevelInfo,
  submittedEvaluation,
  isStudent,
  feedbackAdded,
  setFeedbackAdded,
  aiEvaluations,
}) {
  const STATUS = Object.freeze({
    NOT_STARTED: 0,
    IN_PROGRESS: 1,
    FINISHED: 2,
    ERROR: 3,
  });
  const [autosaveStatus, setAutosaveStatus] = useState(STATUS.NOT_STARTED);
  const [displayFeedback, setDisplayFeedback] = useState('');
  const [loaded, setLoaded] = useState(false);
  const [displayUnderstanding, setDisplayUnderstanding] = useState(
    INVALID_UNDERSTANDING
  );
  const [aiFeedback, setAiFeedback] = useState(-1);
  const [aiEvidence, setAiEvidence] = useState([]);
  const [doneLoading, setDoneLoading] = useState(false);
  // The ref version of this state is used when updating the information based
  // on saved info retrieved by network requests so as not to race them.
  const [currentLearningGoal, setCurrentLearningGoal] = useState(0);
  const currentLearningGoalRef = useRef(0);
  const learningGoalEvalIds = useRef(Array(learningGoals.length).fill(null));
  const teacherFeedbacks = useRef(Array(learningGoals.length).fill(''));
  const teacherFeedbacksLoaded = useRef(
    Array(learningGoals.length).fill(false)
  );
  const understandingLevels = useRef(
    Array(learningGoals.length).fill(INVALID_UNDERSTANDING)
  );

  const aiEnabled =
    currentLearningGoal === learningGoals.length
      ? false
      : learningGoals[currentLearningGoal].aiEnabled && teacherHasEnabledAi;
  const base_teacher_evaluation_endpoint = '/learning_goal_teacher_evaluations';

  // Timer variables for autosaving
  const autosaveTimer = useRef();
  const saveAfter = 2000;

  const handleFeedbackChange = event => {
    if (
      currentLearningGoal !== learningGoals.length &&
      studentLevelInfo.user_id &&
      learningGoals[currentLearningGoal].id
    ) {
      if (autosaveTimer.current) {
        clearTimeout(autosaveTimer.current);
      }
      teacherFeedbacks.current[currentLearningGoal] = event.target.value;
      setDisplayFeedback(teacherFeedbacks.current[currentLearningGoal]);
      autosaveTimer.current = setTimeout(() => {
        autosave();
      }, saveAfter);
    }
  };

  const getAiInfo = learningGoalId => {
    if (!!aiEvaluations) {
      const aiInfo = aiEvaluations.find(
        item => item.learning_goal_id === learningGoalId
      );
      if (aiInfo) {
        aiInfo.showExactMatch = aiInfo.aiConfidenceExactMatch === 3;
      }
      return aiInfo;
    } else {
      return null;
    }
  };

  const aiEvalInfo =
    currentLearningGoal === learningGoals.length
      ? null
      : getAiInfo(learningGoals[currentLearningGoal].id);

  // The backend provides two ai confidence levels. aiConfidenceExactMatch is
  // our confidence that the ai score is exactly correct, and and
  // aiConfidencePassFail indicates our confidence in its accuracy on a
  // pass/fail basis where Extended/Convincing are passing and Limited/No are
  // failing.
  //
  // Use the precomputed showExactMatch value to decide which of these two
  // confidence levels we will show in the UI. Throughout client code,
  // aiConfidence should represent this computed value, and the more specific
  // variable names should be used for exact-match or pass/fail confidence.
  let aiConfidence;
  if (aiEvalInfo) {
    aiConfidence = aiEvalInfo.showExactMatch
      ? aiEvalInfo.aiConfidenceExactMatch
      : aiEvalInfo.aiConfidencePassFail;
  }

  const autosave = () => {
    setAutosaveStatus(STATUS.IN_PROGRESS);
    const bodyData = JSON.stringify({
      studentId: studentLevelInfo.user_id,
      learningGoalId: learningGoals[currentLearningGoal].id,
      feedback: teacherFeedbacks.current[currentLearningGoal],
      understanding: understandingLevels.current[currentLearningGoal],
    });
    HttpClient.put(
      `${base_teacher_evaluation_endpoint}/${learningGoalEvalIds.current[currentLearningGoal]}`,
      bodyData,
      true,
      {
        'Content-Type': 'application/json',
      }
    )
      .then(() => {
        setAutosaveStatus(STATUS.FINISHED);
        if (!feedbackAdded) {
          setFeedbackAdded(true);
        }
      })
      .catch(error => {
        console.error(error);
        setAutosaveStatus(STATUS.ERROR);
      });
    clearTimeout(autosaveTimer.current);
  };

  useEffect(() => {
    if (studentLevelInfo && learningGoals) {
      // Set our current idea of the feedback immediately
      setDisplayFeedback(teacherFeedbacks.current[currentLearningGoal]);
      setLoaded(teacherFeedbacksLoaded.current[currentLearningGoal]);
      setDisplayUnderstanding(understandingLevels.current[currentLearningGoal]);

      // Only load prior learning goal feedback once
      learningGoals
        .filter((learningGoal, index) => {
          return !teacherFeedbacksLoaded.current[index];
        })
        .forEach((learningGoal, index) => {
          const body = JSON.stringify({
            userId: studentLevelInfo.user_id,
            learningGoalId: learningGoal.id,
          });
          HttpClient.post(
            `${base_teacher_evaluation_endpoint}/get_or_create_evaluation`,
            body,
            true,
            {
              'Content-Type': 'application/json',
            }
          )
            .then(response => response.json())
            .then(json => {
              learningGoalEvalIds.current[index] = json.id;
              if (json.feedback) {
                teacherFeedbacks.current[index] = json.feedback;
              }
              teacherFeedbacksLoaded.current[index] = true;
              if (json.understanding >= 0 && json.understanding !== null) {
                understandingLevels.current[index] = json.understanding;
              }

              // Uses the redundant ref here instead of state to defeat a race
              // condition where the current learning goal changes before the
              // fetch resolves.
              if (index === currentLearningGoalRef.current) {
                setDisplayFeedback(teacherFeedbacks.current[index]);
                setLoaded(teacherFeedbacksLoaded.current[index]);
                setDisplayUnderstanding(understandingLevels.current[index]);
              }
              if (index === learningGoals.length - 1) {
                setDoneLoading(true);
              }
            })
            .catch(error => console.error(error));
        });
    }
  }, [studentLevelInfo, learningGoals, currentLearningGoal, open]);

  useEffect(() =>
    document.addEventListener('keydown', handleKeyDown, {once: true})
  );

  // Callback to retrieve understanding data from EvidenceLevels
  const radioButtonCallback = radioButtonData => {
    if (currentLearningGoal !== learningGoals.length) {
      analyticsReporter.sendEvent(EVENTS.TA_RUBRIC_EVIDENCE_LEVEL_SELECTED, {
        ...(reportingData || {}),
        learningGoalId: learningGoals[currentLearningGoal].id,
        learningGoal: learningGoals[currentLearningGoal].learningGoal,
        newlySelectedEvidenceLevel: radioButtonData,
        previouslySelectedEvidenceLevel:
          understandingLevels.current[currentLearningGoal],
      });
      setDisplayUnderstanding(radioButtonData);
      understandingLevels.current[currentLearningGoal] = radioButtonData;
      autosave();
    }
  };

  const renderAutoSaveTextbox = () => {
    return (
      <div className={`${style.feedbackArea} uitest-learning-goal`}>
        <label className={style.evidenceLevelLabel}>
          <span>{i18n.feedbackHeader()}</span>
          <textarea
            id="ui-teacherFeedback"
            className={style.inputTextbox}
            placeholder={i18n.feedbackPlaceholderShort()}
            name="teacherFeedback"
            value={displayFeedback}
            onChange={handleFeedbackChange}
            disabled={!canProvideFeedback || !loaded}
          />
        </label>
        {autosaveStatus === STATUS.IN_PROGRESS ? (
          <span className={style.autosaveMessage}>{i18n.saving()}</span>
        ) : (
          autosaveStatus === STATUS.FINISHED && (
            <span id="ui-autosaveConfirm" className={style.autosaveMessage}>
              <FontAwesome icon="circle-check" /> {i18n.savedToGallery()}
            </span>
          )
        )}
        {autosaveStatus === STATUS.ERROR && (
          <span className={style.autosaveMessage}>
            {i18n.feedbackSaveError()}
          </span>
        )}
      </div>
    );
  };

  const renderSubmittedFeedbackTextbox = () => {
    return (
      <div className={style.feedbackArea}>
        <label className={style.evidenceLevelLabel}>
          <span>{i18n.feedback()}</span>
          <textarea
            className={style.inputTextbox}
            name="teacherFeedback"
            value={submittedEvaluation.feedback}
            disabled
          />
        </label>
      </div>
    );
  };

  const onCarouselPress = buttonValue => {
    let currentIndex = currentLearningGoal;
    currentIndex += buttonValue;
    if (currentIndex < 0) {
      currentIndex = learningGoals.length;
    } else if (currentIndex > learningGoals.length) {
      currentIndex = 0;
    }
    currentLearningGoalRef.current = currentIndex;
    setCurrentLearningGoal(currentIndex);

    // Clear feedback (without sending it)
    setAiFeedback(-1);

    // Annotate the lines based on the AI observation
    clearAnnotations();
    if (currentIndex !== learningGoals.length) {
      const aiEvalInfo = getAiInfo(learningGoals[currentIndex].id);
      if (!!aiEvalInfo && aiEvalInfo.evidence) {
        setAiEvidence(annotateLines(aiEvalInfo.evidence));
      }

      if (!isStudent) {
        const eventName = EVENTS.TA_RUBRIC_LEARNING_GOAL_SELECTED;
        analyticsReporter.sendEvent(eventName, {
          ...(reportingData || {}),
          learningGoalKey: learningGoals[currentIndex].key,
          learningGoal: learningGoals[currentIndex].learningGoal,
        });
      }
    }
  };

  const handleKeyDown = event => {
    if (event.key === 'ArrowLeft') {
      onCarouselPress(-1);
    } else if (event.key === 'ArrowRight') {
      onCarouselPress(1);
    }
  };

  return (
    <div className={style.learningGoalsContainer}>
      <div className={style.learningGoalsHeader}>
        <div className={style.learningGoalsHeaderLeftSide}>
          <button
            type="button"
            className={classnames(
              style.learningGoalButton,
              style.learningGoalButtonLeft
            )}
            onClick={() => onCarouselPress(-1)}
          >
            <FontAwesome icon="angle-left" />
          </button>
          <ProgressRing
            className={style.learningGoalRing}
            learningGoals={learningGoals}
            currentLearningGoal={currentLearningGoal}
            understandingLevels={understandingLevels.current}
            radius={30}
            stroke={4}
            loaded={doneLoading}
          />
          <div className={style.learningGoalsHeaderText}>
            <Heading5
              className={[
                style.learningGoalsHeaderTextBody,
                'uitest-learning-goal-title',
              ]}
            >
              <span>
                {currentLearningGoal === learningGoals.length
                  ? i18n.rubricLearningGoalSummary()
                  : learningGoals[currentLearningGoal].learningGoal}
              </span>
              {aiEnabled && displayUnderstanding === INVALID_UNDERSTANDING && (
                <AiToken />
              )}
            </Heading5>
            <BodyThreeText className={style.learningGoalsHeaderTextBody}>
              {i18n.next()}:{' '}
              {currentLearningGoal + 1 === learningGoals.length
                ? i18n.rubricLearningGoalSummary()
                : learningGoals[
                    (currentLearningGoal + 1) % learningGoals.length
                  ].learningGoal}
            </BodyThreeText>
          </div>
        </div>
        <div className={style.learningGoalsHeaderRightSideV2}>
          {submittedEvaluation && (
            <div className={style.submittedEvaluation}>
              {submittedEvaluation.understanding !== null && (
                <BodyThreeText className={style.feedbackIndicatorText}>
                  {
                    UNDERSTANDING_LEVEL_STRINGS[
                      submittedEvaluation.understanding
                    ]
                  }
                </BodyThreeText>
              )}
              {submittedEvaluation.feedback && (
                <FontAwesome
                  icon="message"
                  className="fa-regular"
                  title={i18n.feedback()}
                />
              )}
            </div>
          )}
          <button
            id="uitest-next-goal"
            type="button"
            className={classnames(
              style.learningGoalButton,
              style.learningGoalButtonRight
            )}
            onClick={() => onCarouselPress(1)}
          >
            <FontAwesome icon="angle-right" />
          </button>
        </div>
      </div>

      <div className={style.learningGoalOuterBlock}>
        {currentLearningGoal !== learningGoals.length && (
          <div className={style.learningGoalExpanded}>
            <AiAssessmentFeedbackContext.Provider
              value={{aiFeedback, setAiFeedback}}
            >
              {!!submittedEvaluation && renderSubmittedFeedbackTextbox()}
              <div>
                <EvidenceLevels
                  aiEvalInfo={aiEvalInfo}
                  isAiAssessed={learningGoals[currentLearningGoal].aiEnabled}
                  learningGoalKey={learningGoals[currentLearningGoal].key}
                  evidenceLevels={
                    learningGoals[currentLearningGoal].evidenceLevels
                  }
                  canProvideFeedback={canProvideFeedback}
                  understanding={displayUnderstanding}
                  radioButtonCallback={radioButtonCallback}
                  submittedEvaluation={submittedEvaluation}
                  isStudent={isStudent}
                  isAutosaving={autosaveStatus === STATUS.IN_PROGRESS}
                />
                {teacherHasEnabledAi &&
                  !!studentLevelInfo &&
                  !!aiEvalInfo &&
                  aiEvalInfo.understanding !== undefined && (
                    <div className={style.aiAssessmentOuterBlock}>
                      <AiAssessment
                        isAiAssessed={
                          learningGoals[currentLearningGoal].aiEnabled
                        }
                        studentName={studentLevelInfo.name}
                        aiConfidence={aiConfidence}
                        aiUnderstandingLevel={aiEvalInfo.understanding}
                        aiEvalInfo={aiEvalInfo}
                        aiEvidence={aiEvidence}
                      />
                    </div>
                  )}
                {learningGoals[currentLearningGoal].tips && !isStudent && (
                  <details>
                    <summary className={style.tipsDetailsSummary}>
                      <strong>{i18n.tipsForEvaluation()}</strong>
                    </summary>

                    <div className={style.learningGoalsTips}>
                      <SafeMarkdown
                        markdown={learningGoals[currentLearningGoal].tips}
                      />
                    </div>
                  </details>
                )}
              </div>
              {!!studentLevelInfo && renderAutoSaveTextbox()}
            </AiAssessmentFeedbackContext.Provider>
          </div>
        )}
        {currentLearningGoal === learningGoals.length && (
          <div>
            {learningGoals.map((lg, i) => (
              <div className={style.learningGoalSummary} key={i}>
                <BodyThreeText>
                  <StrongText>{lg.learningGoal}</StrongText>
                </BodyThreeText>
                <BodyThreeText>
                  {UNDERSTANDING_LEVEL_STRINGS[understandingLevels.current[i]]}
                </BodyThreeText>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

LearningGoals.propTypes = {
  open: PropTypes.bool,
  teacherHasEnabledAi: PropTypes.bool,
  canProvideFeedback: PropTypes.bool,
  reportingData: reportingDataShape,
  studentLevelInfo: studentLevelInfoShape,
  submittedEvaluation: submittedEvaluationShape,
  isStudent: PropTypes.bool,
  feedbackAdded: PropTypes.bool,
  setFeedbackAdded: PropTypes.func,
  learningGoals: PropTypes.arrayOf(learningGoalShape),
  aiEvaluations: PropTypes.arrayOf(aiEvaluationShape),
};

const AiToken = () => {
  return (
    <div className={classnames('uitest-uses-ai', style.aiTokenContainer)}>
      {' '}
      <OverlineThreeText
        className={classnames(style.aiToken, style.aiTokenText)}
      >
        {i18n.usesAi()}
      </OverlineThreeText>
    </div>
  );
};
