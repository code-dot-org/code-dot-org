import React, {useEffect, useRef, useState} from 'react';

type Circle = {
  x: number;
  y: number;
};

interface AiGeneratingViewProps {
  imageUrls: string[];
  onComplete: () => void;
}

/**
 * Previews the blocks generated by the AI block in Dance Party.
 */
const AiGeneratingView: React.FunctionComponent<AiGeneratingViewProps> = ({
  imageUrls,
  onComplete,
}) => {
  const refTimer = useRef<number | null>(null);
  const [tick, setTick] = useState<number>(0);
  const [done, setDone] = useState<boolean>(false);

  // Update currentTick using a timer.
  useEffect(() => {
    refTimer.current = window.setInterval(() => {
      if (!done) {
        setTick(tick => tick + 1);
      }
    }, 1000 / 60);

    return () => {
      if (refTimer.current) {
        clearInterval(refTimer.current);
        refTimer.current = null;
      }
    };
  }, [done]);

  useEffect(() => {
    if (tick > 60 * 5) {
      setDone(true);
      onComplete();
      if (refTimer.current) {
        clearInterval(refTimer.current);
      }
    }
  }, [tick, onComplete]);

  const circles = [
    {x: 0, y: 1},
    {x: 0, y: 3},
    {x: 0, y: 5},
    {x: 1, y: 0},
    {x: 1, y: 2},
    {x: 1, y: 4},
    {x: 1, y: 6},
    {x: 2, y: 2},
    {x: 2, y: 4},
    {x: 3, y: 3},
  ];

  const lines = [
    {start: 0, end: 3},
    {start: 0, end: 4},
    {start: 0, end: 5},
    {start: 0, end: 6},
    {start: 1, end: 3},
    {start: 1, end: 4},
    {start: 1, end: 5},
    {start: 1, end: 6},
    {start: 2, end: 3},
    {start: 2, end: 4},
    {start: 2, end: 5},
    {start: 2, end: 6},
    {start: 3, end: 7},
    {start: 4, end: 7},
    {start: 5, end: 7},
    {start: 6, end: 7},
    {start: 3, end: 8},
    {start: 4, end: 8},
    {start: 5, end: 8},
    {start: 6, end: 8},
    {start: 7, end: 9},
    {start: 8, end: 9},
  ];

  const gridOffsetX = 200;
  const gridOffsetY = 40;
  const gridWidth = 90;
  const gridHeight = 35;
  const circleRadius = 25;
  const imageWidth = 40;
  const imageHeight = 40;

  const getCircleX = (circle: Circle) => {
    return gridOffsetX + circle.x * gridWidth;
  };

  const getCircleY = (circle: Circle) => {
    return gridOffsetY + circle.y * gridHeight;
  };

  const getOpacity = (index: number) => {
    const fadeTicks = 60;

    let opacity;
    const startTick = 120 + index * 20;
    if (tick > startTick) {
      opacity = 1;
    } else if (tick > startTick - fadeTicks) {
      opacity = 1 - (startTick - tick) / fadeTicks;
    } else {
      opacity = 0;
    }

    return opacity;
  };

  const getColor = (index: number) => {
    return `rgba(191, 228, 232, ${getOpacity(index)})`;
  };

  return (
    <div>
      <svg viewBox="0 0 800 290" xmlns="http://www.w3.org/2000/svg">
        {circles.map((circle, circleIndex) => {
          return (
            <circle
              key={circleIndex}
              cx={getCircleX(circle)}
              cy={getCircleY(circle)}
              r={circleRadius}
              fill={getColor(circleIndex)}
            />
          );
        })}
        {lines.map((line, lineIndex) => {
          return (
            <line
              key={lineIndex}
              x1={getCircleX(circles[line.start])}
              y1={getCircleY(circles[line.start])}
              x2={getCircleX(circles[line.end])}
              y2={getCircleY(circles[line.end])}
              stroke={getColor(line.start)}
            />
          );
        })}
        {imageUrls.map((imageUrl, imageIndex) => {
          return (
            <image
              key={imageIndex}
              href={imageUrl}
              x={getCircleX(circles[imageIndex]) - imageWidth / 2}
              y={getCircleY(circles[imageIndex]) - imageHeight / 2}
              width={imageWidth}
              height={imageHeight}
              opacity={getOpacity(imageIndex)}
            />
          );
        })}
      </svg>
    </div>
  );
};

export default AiGeneratingView;
