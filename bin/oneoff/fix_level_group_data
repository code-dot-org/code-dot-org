#!/usr/bin/env ruby

# This script creates a UserLevel for each contained level of a LevelGroup level
# (if one does not already exist). Though current production code creates a
# UserLevel for each contained UserLevel, there was a period of time where this
# was not the case.
#
# The script expects a data file of user_level_id's to (possibly) fix. This list
# was generated via the following SQL.
#
#   SELECT user_levels.id AS user_level_id
#   FROM user_scripts
#   INNER JOIN user_levels
#     ON user_levels.user_id = user_scripts.user_id
#       AND user_levels.script_id = user_scripts.script_id
#   WHERE
#     user_scripts.script_id IN (
#       SELECT script_levels.script_id
#       FROM script_levels
#       INNER JOIN levels_script_levels
#         ON levels_script_levels.script_level_id = script_levels.id
#       WHERE levels_script_levels.level_id IN (
#         SELECT id
#         FROM levels
#         WHERE type = "LevelGroup"
#       )
#     )
#   AND
#     user_levels.level_id IN (
#       SELECT id
#       FROM levels
#       WHERE type = "LevelGroup"
#     );
#
# where the script IDs are those scripts containing the level IDs and the level
# IDs are the levels of type LevelGroup.

require_relative '../../dashboard/config/environment'
require 'digest/md5'

DATA_FILE = '/tmp/user_level_ids.csv'.freeze

# Validates raw_data and extracts the answer data from it. Raises an exception
# if raw_data is not of the appropriate format.
# @param raw_data [Hash] The LevelGroup value (within LevelSource.data) for a
#   contained level.
# @return [String] The string to persist in LevelSource.data for the contained
#   level.
def get_data(raw_data)
  unless raw_data.keys == ['result', 'valid']
    raise "raw_data malformed: #{raw_data}"
  end

  return raw_data['result']
end

# Retrieves the UserLevel and the (JSON-parsed) LevelSource.data associated with
# a user_level_id. Raises an exception if the UserLevel or LevelSource is
# missing.
# @param user_level_id [Integer] The ID of the user_level.
# @return [Array[UserLevel, Hash]] An array of a UserLevel and the corresponding
#   (JSON-parsed) LevelSource.data.
def get_user_level_and_level_source_data(user_level_id)
  user_level = UserLevel.find_by_id(user_level_id)
  unless user_level && user_level.level_source_id
    raise "Malformed UserLevel: #{user_level_id}"
  end

  level_source = LevelSource.find_by_id(user_level.level_source_id)
  unless level_source
    raise "Missing LevelSource: #{user_level.level_source_id} "\
      "(#{user_level_id})"
  end
  level_source_data = JSON.parse(level_source.data)

  [user_level, level_source_data]
end

# Creates a UserLevel for each contained level in the LevelGroup UserLevel, if
# one does not already exist. As part of this, creates any necessary LevelSource
# objects.
# @param user_level [UserLevel]
# @param level_id [Integer]
# @param raw_data [Hash]
def create_contained_level_sources(user_level, level_id, raw_data)
  # Determine if there is an existing sublevel UserLevel, continuing if so.
  sublevel_user_level = UserLevel.
    where(
      user_id: user_level.user_id,
      level_id: level_id,
      script_id: user_level.script_id
    ).
    first
  next if sublevel_user_level

  # There was not, so create the sublevel UserLevel based on the LevelGroup
  # UserLevel. Before doing so, verify the existence of an appropriate
  # LevelSource, creating one if not.
  data = get_data raw_data
  md5 = Digest::MD5.hexdigest data
  level_source = LevelSource.
    create_with(data: data).
    find_or_create_by(
      md5: md5,
      level_id: level_id
    )

  # Actually create the UserLevel for the sublevel.
  UserLevel.create!(
    user_id: user_level.user_id,
    level_id: level_id,
    script_id: user_level.script_id,
    level_source_id: level_source.id,
    # Since UserLevel.attempts for the LevelGroup encompasses the number of
    # state changes across all answers and the number of submits, we do not
    # try to populate attempts with an accurate number.
    attempts: 2,
    # As UserLevel.created_at and UserLevel.updated_at are use for analysis, we
    # manually set them rather than allow Rails to manage the timestamps.
    created_at: user_level.created_at,
    updated_at: user_level.updated_at,
    # For various reasons (including not telling the answer to the client),
    # regardless of correctness, we purposely set best_result to zero.
    best_result: 0
  )
end

# The main method for the script. Reads the CSV and persists UserLevel and
# LevelSource objects as necessary.
def main
  CSV.foreach(DATA_FILE, headers: true, col_sep: "\t") do |row|
    user_level_id = row['user_level_id'].to_i

    user_level, level_source_data = get_user_level_and_level_source_data(
      user_level_id
    )

    ActiveRecord::Base.transaction do
      level_source_data.each do |contained_level_id, contained_level_raw_data|
        create_contained_level_sources(
          user_level,
          contained_level_id,
          contained_level_raw_data
        )
      end
    end
  end
end
