#!/usr/bin/env ruby
require_relative '../only_one'
abort 'Script already running' unless only_one_running?(__FILE__)

# This script fetches spotify data from api.spotify and uploads to the shared firebase channel.
require_relative '../../../deployment'
require 'ostruct'
require_relative '../../../shared/middleware/helpers/firebase_helper'
require 'cdo/profanity_filter'
require 'rest-client'

BASE_URL = 'https://api.spotify.com/v1'

#PLAYLIST IDs
VIRAL_50_GLOBAL_ID = '37i9dQZEVXbLiRSasKsNU9'
VIRAL_50_USA_ID = '37i9dQZEVXbKuaTI1Z1Afx'
TOP_50_GLOBAL_ID = '37i9dQZEVXbMDoHDwVN2tF'
TOP_50_USA_ID = '37i9dQZEVXbLRQDuF5jeBp'

PROFANITY_LOCALE = 'en-US'

CHART_TYPE = {
  TOP: 'TOP',
  VIRAL: 'VIRAL',
}

def get_token
  client_id = CDO.spotify_api_client_id
  client_secret = CDO.spotify_api_client_secret

  begin
    url = "https://accounts.spotify.com/api/token"
    headers = {
      'authorization' => 'Basic ' + Base64.strict_encode64(client_id + ':' + client_secret),
      'content-type' => 'application/x-www-form-urlencoded',
    }
    form = {
      'grant_type' => 'client_credentials'
    }
    auth_response = JSON.parse(RestClient.post(url, form, headers))
    $token = auth_response['access_token']
  rescue RestClient::Exception => e
    Honeybadger.notify(
      e,
      error_message: "Failed to retrieve OAuth token from Spotify for use in App Lab Datasets.",
      context: {
        tenant_id: client_id,
        url: url
      }
    )
  end
end

def get_playlist_data(chart_type, playlist_id)
  # Filters for the query: a comma-separated list of the fields to return
  field_query = 'fields=tracks.items(track(name,href,artists,popularity))'

  begin
    url = "#{BASE_URL}/playlists/#{playlist_id}?#{field_query}"
    response = RestClient.get(url, {authorization: "Bearer #{$token}"})
  rescue RestClient::Exception => e
    Honeybadger.notify(
      e,
      error_message: "Failed to retrieve playlist data from Spotify for use in App Lab Datasets.",
      context: {
        playlist_id: playlist_id,
      }
    )
    return
  end

  items = JSON.parse(response)['tracks']['items']
  columns = ['id', 'Track Name', 'Artist', 'Position', 'URL']
  if chart_type === CHART_TYPE[:TOP]
    columns.insert(4, 'Popularity')   # Only include Popularity for Top Charts
  end

  regex = generate_profanity_regex(items)
  records = {}
  id = 1

  items.each do |item|
    track = item['track']
    next if track.nil? || regex&.match?(get_string_to_check(track)) # skip track if it is nil or contains profanity

    record = OpenStruct.new
    record.id = id
    record.Position = id
    record['Track Name'] = track['name']
    record.Artist = track['artists'][0]['name'] # first will be main artist, featured artists included in record name
    if chart_type === CHART_TYPE[:TOP] then record.Popularity = track['popularity'] end
    record.URL = track['href']

    records[id] = record.to_h.to_json
    id += 1
  end

  return records, columns
end

# Only check artist and track names for profanity
def get_string_to_check(track)
  if track.nil?
    return ""
  else
    return "#{track['name']} - #{track['artists'][0]['name']} "
  end
end

# Generates a case-insensitive regex of profanities in the entire dataset
# to match each item against.
def generate_profanity_regex(items)
  str = items.reduce('') {|acc, item| acc + get_string_to_check(item['track'])}
  profanities = ProfanityFilter.find_potential_profanities(str, PROFANITY_LOCALE) || []
  profanities.empty? ? nil : /(#{profanities.join("|")})/i
end

def main
  get_token
  fb = FirebaseHelper.new('shared')

  records, columns = get_playlist_data(CHART_TYPE[:TOP], TOP_50_GLOBAL_ID)
  fb.upload_live_table('Top 50 Worldwide', records, columns)

  records, columns = get_playlist_data(CHART_TYPE[:TOP], TOP_50_USA_ID)
  fb.upload_live_table('Top 50 USA', records, columns)

  records, columns = get_playlist_data(CHART_TYPE[:VIRAL], VIRAL_50_GLOBAL_ID)
  fb.upload_live_table('Viral 50 Worldwide', records, columns)

  records, columns = get_playlist_data(CHART_TYPE[:VIRAL], VIRAL_50_USA_ID)
  fb.upload_live_table('Viral 50 USA', records, columns)
end

main
