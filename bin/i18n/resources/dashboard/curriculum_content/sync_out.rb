#!/usr/bin/env ruby

require 'json'

require_relative '../../../../../dashboard/config/environment'
require_relative '../../../../../dashboard/lib/script_constants'
require_relative '../../../../../dashboard/lib/services/i18n/curriculum_sync_utils/serializers'
require_relative '../../../../../dashboard/lib/services/globally_unique_identifiers'
require_relative '../../../i18n_script_utils'
require_relative '../../../redact_restore_utils'
require_relative '../../../utils/sync_out_base'
require_relative '../curriculum_content'

module I18n
  module Resources
    module Dashboard
      module CurriculumContent
        class SyncOut < I18n::Utils::SyncOutBase
          # The ScriptCrowdinSerializer used in the sync in organizes all content by
          # script; each script is a single file, containing all the individual
          # lessons, activities, etc, for the script. This works great for organizing
          # content in a way that can easily be worked on by translators, but for
          # rendering translations in model and view logic we're going to need to do
          # something different.
          #
          # Specifically, we want to flatten the complex files generated by the
          # sync in. Ultimately, we want one file per content type; one for all
          # lessons, one for all activities, one for all resources, etc.
          def process(language)
            crowdin_locale_dir = crowdin_locale_dir_of(language)
            return unless File.directory?(crowdin_locale_dir)

            unless I18nScriptUtils.source_lang?(language)
              distribute_localization(language)
            end

            i18n_locale_dir = I18nScriptUtils.locale_dir(language[:locale_s], DIR_NAME)
            I18nScriptUtils.rename_dir(crowdin_locale_dir, i18n_locale_dir)
          end

          private

          def crowdin_locale_dir_of(language)
            I18nScriptUtils.locale_dir(language[:crowdin_name_s], DIR_NAME)
          end

          # We use URLs as keys for lessons in Crowdin, to make things easier for translators.
          # For the actual translation files, though, we'd like to use more-standard keys.
          def restore_lesson_i18n_keys(types_i18n_data)
            return types_i18n_data unless types_i18n_data[:lessons]

            rekeyed_lessons = types_i18n_data[:lessons].map do |lesson_url, lesson_data|
              route_params = Rails.application.routes.recognize_path(lesson_url)
              # Filter for only lessons which are "numbered".
              # Only these lessons guarantee that their relative position is unique.
              lessons = Lesson.joins(:script).
                where(
                  'scripts.name': route_params[:script_id],
                  relative_position: route_params[:position].to_i,
                ).select(&:numbered_lesson?)
              if lessons.count == 0
                warn "Could not find lesson for url #{lesson_url.inspect}"
                next
              end
              if lessons.count > 1
                warn "More than one lesson found for url #{lesson_url.inspect}. This should be investigated."
                next
              end
              lesson = lessons.first
              [Services::GloballyUniqueIdentifiers.build_lesson_key(lesson), lesson_data]
            end

            types_i18n_data.merge(lessons: rekeyed_lessons.compact.to_h)
          end

          # We use URLs as keys for reference_guides in Crowdin, to make things easier for translators.
          # For the actual translation files, though, we'd like to use more-standard keys.
          def restore_reference_guide_i18n_keys(types_i18n_data)
            return types_i18n_data unless types_i18n_data[:reference_guides]

            rekeyed_reference_guides = types_i18n_data[:reference_guides].map do |reference_guide_url, reference_guide_data|
              route_params = Rails.application.routes.recognize_path(reference_guide_url)
              # :course_course_name param is generated with ReferenceGuide.course_offering_version.
              # Reversing that to look up the object.
              split_course_name = route_params[:course_course_name].split('-')
              course_version_key = split_course_name.pop
              course_offering_key = split_course_name.join('-')

              course_offering = CourseOffering.find_by_key(course_offering_key)
              next unless course_offering

              course_version = course_offering.course_versions.find_by_key(course_version_key)
              next unless course_version

              reference_guide = course_version.reference_guides.find_by_key(route_params[:key])
              if reference_guide.nil?
                warn "Could not find reference_guide for url #{reference_guide_url.inspect}"
                next
              end

              [Services::GloballyUniqueIdentifiers.build_reference_guide_key(reference_guide), reference_guide_data]
            end

            types_i18n_data.merge(reference_guides: rekeyed_reference_guides.compact.to_h)
          end

          def fix_resource_urls(types_i18n_data)
            return types_i18n_data unless types_i18n_data[:resources]

            # We also provide URLs to the translators for Resources only;
            # because the sync has a side effect of applying Markdown formatting to everything it encounters,
            # we want to make sure to un-Markdownify these URLs
            types_i18n_data[:resources].each do |_key, resource|
              next if resource[:url].blank?

              resource[:url].strip!
              resource[:url].delete_prefix!('<')
              resource[:url].delete_suffix!('>')
            end

            types_i18n_data
          end

          # Given a deeply-nested hash of serialized objects (as generated by a
          # CrowdinCollectionSerializer) and a Serializer for the top-level object,
          # recursively extract all nested objects and return a flattened hash
          # organized by type.
          #
          # For example, given a hash of scripts like:
          #
          # {
          #   "coursea-2021": {
          #     "lessons": {
          #       "http://studio.code.org/s/coursea-2021/lessons/1": {
          #         "overview": "...",
          #         "preparation": "...",
          #         "purpose": "...",
          #         "student_overview": "...",
          #         "lesson_activities": {
          #           "09eb0525-dfae-44f2-831f-5c1f2ffee133": {
          #             "name": "...",
          #             "activity_sections": {
          #               "ef4f13d4-c5b0-4778-8ca1-359132023d82": {
          #                 "progression_name": "..."
          #               }
          #             }
          #           },
          #           ...
          #         },
          #         "resources": {
          #           "url": {
          #             "name": "..."
          #           },
          #         },
          #       },
          #       ...
          #     },
          #     "resources": {...}
          #   },
          #   "courseb-2021": {
          #     "lessons": {...}
          #     "resources": {...}
          #   },
          #   ...
          # }
          #
          # return:
          #
          # {
          #   "scripts": {
          #     "coursea-2021": {...},
          #     "courseb-2021": {...},
          #     ...
          #   },
          #   "lessons": {
          #     "http://studio.code.org/s/coursea-2021/lessons/1": {
          #       "overview": "...",
          #       "preparation": "...",
          #       "purpose": "...",
          #       "student_overview": "...",
          #     },
          #     "http://studio.code.org/s/courseb-2021/lessons/1": {...},
          #     ...
          #   },
          #   "lesson_activities": {
          #     "09eb0525-dfae-44f2-831f-5c1f2ffee133": {
          #       "name": "...",
          #     },
          #     ...
          #   },
          #   "activity_sections": {
          #     "ef4f13d4-c5b0-4778-8ca1-359132023d82": {
          #       "progression_name": "..."
          #     },
          #     ...
          #   },
          #   "resources": {
          #     "url": {
          #       "name": "..."
          #     },
          #     ...
          #   }
          # }
          def flatten(raw_i18n_data, serializer = UNIT_SERIALIZER, name = :scripts)
            raw_i18n_data.each_with_object({}) do |(key, object), i18n_data|
              object = object.symbolize_keys

              # store attributes directly on the results for this object
              attributes = object.slice(*serializer._attributes)
              if attributes.present?
                i18n_data[name] ||= {}
                i18n_data[name][key] = attributes
              end

              # recursively process "reflections" (ie, related model data) into their own objects
              serializer._reflections.each do |reflection_key, reflection|
                next unless object.key?(reflection_key) && object[reflection_key].present?
                i18n_data.deep_merge!(flatten(object[reflection_key], reflection.options[:serializer], reflection.name))
              end
            end
          end

          # Restores redacted Crowdin file content
          #
          # @param crowdin_file_path [String] the full Crowdin file path
          # @return [Hash] the restored i18n data or an empty hash
          def restore_file_content(crowdin_file_path)
            # Separates the file subpath (e.g. `2017/csd/csd1-2017.json`)
            # from the Crowdin file path (e.g. `i18n/locales/source/curriculum_content/2017/csd/csd1-2017.json`)
            file_subpath = crowdin_file_path.partition(DIR_NAME).last

            original_file_path = File.join(I18N_BACKUP_DIR_PATH, file_subpath)

            RedactRestoreUtils.restore(original_file_path, crowdin_file_path, crowdin_file_path, REDACT_RESTORE_PLUGINS)
          end

          def types_i18n_data_of(language)
            types_i18n_data = {}

            crowdin_file_paths = Dir.glob(File.join(crowdin_locale_dir_of(language), '**/*.json'))
            mutex.synchronize {progress_bar.total += crowdin_file_paths.size}

            # First we gather together all our script objects into a single hash
            crowdin_file_paths.each do |crowdin_file_path|
              type_i18n_data = restore_file_content(crowdin_file_path)
              type = File.basename(crowdin_file_path, '.json')

              types_i18n_data[type] = type_i18n_data if type_i18n_data.present?
            ensure
              mutex.synchronize {progress_bar.increment}
            end

            # Then we recursively flatten all of our hashes of objects, to group them by type rather than by script
            types_i18n_data = flatten(types_i18n_data)

            # Then we apply some postprocessing before writing them out to config files
            types_i18n_data = restore_lesson_i18n_keys(types_i18n_data)
            types_i18n_data = restore_reference_guide_i18n_keys(types_i18n_data)
            types_i18n_data = fix_resource_urls(types_i18n_data)

            types_i18n_data.deep_stringify_keys
          end

          def distribute_localization(language)
            types_i18n_data = types_i18n_data_of(language)
            return if types_i18n_data.blank?

            # Finally, write each resulting collection of strings out to a rails i18n config file.
            types_i18n_data.each do |type, type_i18n_data|
              target_i18n_file_path = File.join(ORIGIN_I18N_DIR_PATH, "#{type}.#{language[:locale_s]}.json")

              if File.exist?(target_i18n_file_path)
                existing_type_i18n_data = JSON.load_file(target_i18n_file_path).dig(language[:locale_s], 'data', type)
                type_i18n_data = existing_type_i18n_data.deep_merge(type_i18n_data)
              end

              i18n_data = I18nScriptUtils.to_dashboard_i18n_data(language[:locale_s], type, type_i18n_data)

              I18nScriptUtils.write_json_file(target_i18n_file_path, i18n_data)
            end
          end
        end
      end
    end
  end
end

I18n::Resources::Dashboard::CurriculumContent::SyncOut.perform if __FILE__ == $0
