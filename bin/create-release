#!/usr/bin/env ruby
require_relative '../deployment.rb'
require 'cdo/only_one'
require 'cdo/cdo_cli'
include CdoCli

require 'octokit'
require 'open3'
require 'tempfile'

REPO = 'code-dot-org/code-dot-org'

def git_generate_changelog
  changes, _err, status = Open3.capture3("git log --merges --oneline production^1..production^2 --format=\"%s %b\"")

  # command will error out unless the latest commit is a merge
  return nil if status.exitstatus != 0

  re = /Merge pull request #(?<pr>\d*) from code-dot-org\/(?<branch>\S*) (?<description>.*)/

  matches = changes.split("\n").map do |change|
    # first, extract the relevant data from the commit message
    re.match(change)
  end

  relevant_matches = matches.select do |match|
    # ignore merges from staging; those represent DTTs
    match['branch'] != 'staging'
  end

  items = relevant_matches.map do |match|
    # finally, create a changelog entry linking the description to the PR
    "- [#{match['description']}](https://github.com/#{REPO}/pull/#{match['pr']})"
  end

  items.join("\n")
end

def get_next_release_version
  # version format is "v{year}-{month}-{day}.{version number}"
  today = Time.now.strftime("v%Y-%m-%d")
  version_number = 0

  # if we've already released a .0 or more today, increment the version
  # number appropriately
  last_release = Octokit.latest_release(REPO).tag_name
  last_version = /^#{today}\.(\d*)#/.match(last_release)
  unless last_version.nil?
    version_number = matched_version[0].to_i + 1
  end

  # we now have a best-guess next version number. Manually-created
  # releases could invalidate this guess; in this rare case, we resort
  # to guess-and-check
  begin
    # try no more than five versions before accepting that something
    # else is horribly wrong
    (version_number..version_number + 5).each do |attempted_version|
      version_number = attempted_version
      Octokit.release_for_tag(REPO, "#{today}.#{attempted_version}")
    end
  rescue Octokit::NotFound
    # intentional noop
  else
    puts "Tried and failed to find a valid version number for this date; please check that the latest release has an integer version number"
    exit(-1)
  end

  "#{today}.#{version_number}"
end

def create_release(version, body)
  Octokit.create_release(
    REPO,
    version,
    {
      'name' => version,
      'body' => body
    }
  )
end

def edit(content)
  file = Tempfile.new(['create-release', '.md'])
  editor = ENV['EDITOR'].to_s || 'vim'
  begin
    file.write(content)
    file.close
    system editor, file.path
    file.open
    content = file.read
  ensure
    file.close
    file.unlink
  end
  content
end

def main
  changes = git_generate_changelog

  if changes.nil?
    puts "No changes detected; this could be because the latest commit to production was not a merge (ie., a hotfix)."
    exit(-1)
  end

  next_release_version = get_next_release_version

  unless CDO.github_access_token
    puts "This server does not have permission to create a new release automatically; you can still do so manually at https://github.com/#{REPO}/releases/new"
    puts "Tag version / Release title: #{next_release_version}"
    puts "Changelog:"
    puts changes
    exit(-1)
  end
  Octokit.configure do |c|
    c.access_token = CDO.github_access_token
  end

  puts "Creating release #{next_release_version}"
  loop do
    puts "Does this changelog look correct?"
    puts changes
    print "[#{underline 'Y'}es]/#{underline 'E'}dit/#{underline 'S'}kip: "
    response = gets.strip.downcase
    if 'yes'.start_with?(response)
      puts "POSTing changelog to github ..."
      create_release(next_release_version, changes)
      break
    elsif 'skip'.start_with?(response)
      puts "Skipping release"
      break
    elsif 'edit'.start_with?(response)
      changes = edit(changes)
    else
      puts "Sorry, I didn't understand that.\n\n"
    end
  end
end

main if only_one_running?(__FILE__)
